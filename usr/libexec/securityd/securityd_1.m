void sub_100105188(id a1)
{
  void *v1;
  OctagonControlServer *v2;
  void *v3;
  NSXPCListener *v4;
  void *v5;
  v1 = objc_autoreleasePoolPush();
  v2 = objc_opt_new(&OBJC_CLASS___OctagonControlServer);
  v3 = (void *)qword_1002DEB00;
  qword_1002DEB00 = (uint64_t)v2;

  v4 = -[NSXPCListener initWithMachServiceName:]( objc_alloc(&OBJC_CLASS___NSXPCListener),  "initWithMachServiceName:",  @"com.apple.security.octagon");
  v5 = (void *)qword_1002DEB08;
  qword_1002DEB08 = (uint64_t)v4;

  [(id)qword_1002DEB08 setDelegate:qword_1002DEB00];
  [(id)qword_1002DEB08 resume];
  objc_autoreleasePoolPop(v1);
}

CFTypeRef *sub_10010520C(__CFString **a1, const void *a2, __CFString **a3)
{
  while (a1 == &off_10028B168)
  {
    uint64_t v5 = sub_10010C560((uint64_t)@"cert", &qword_1002DEB48, (uint64_t)&unk_1002DEB40);
    uint64_t v6 = sub_10010520C(v5, a2, 0LL);
    if (v6) {
      return (CFTypeRef *)v6;
    }
    a1 = (__CFString **)sub_10010C560((uint64_t)@"keys", &qword_1002DEB58, (uint64_t)&unk_1002DEB50);
  }

  if (!a2) {
    goto LABEL_11;
  }
  CFTypeID v7 = CFGetTypeID(a2);
  if (v7 != CFStringGetTypeID()) {
    goto LABEL_11;
  }
  v8 = (CFTypeRef *)a1[2];
  if (!v8)
  {
LABEL_10:
    if (CFEqual(kSecUseDataProtectionKeychain, a2)) {
      return 0LL;
    }
LABEL_11:
    sub_1000194E0(-25303, a3, @"attribute %@ not found in class %@", a2, *a1);
    return 0LL;
  }

  v9 = (CFTypeRef **)(a1 + 3);
  while (!CFEqual(*v8, a2))
  {
    v10 = *v9++;
    v8 = v10;
    if (!v10) {
      goto LABEL_10;
    }
  }

  return v8;
}

BOOL sub_100105354(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4)
{
  v7[0] = 0LL;
  v7[1] = v7;
  v7[2] = 0x2000000000LL;
  char v8 = 1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  v6[2] = sub_1001053DC;
  v6[3] = &unk_100286DD8;
  v6[4] = a4;
  v6[5] = v7;
  BOOL v4 = sub_1000163F4(a1, a2, a3, (uint64_t)v6);
  _Block_object_dispose(v7, 8);
  return v4;
}

uint64_t sub_1001053DC(uint64_t a1, _BYTE *a2)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  *a2 = result;
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = result;
  return result;
}

uint64_t sub_100105418(uint64_t a1, unsigned int *a2, const __CFArray *a3, int a4, uint64_t a5)
{
  uint64_t v19 = 0LL;
  v20 = &v19;
  uint64_t v21 = 0x2000000000LL;
  char v22 = 1;
  CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
  v11 = Mutable;
  if (a3)
  {
    context[0] = _NSConcreteStackBlock;
    context[1] = 0x40000000LL;
    context[2] = sub_1001055B8;
    context[3] = &unk_100286DF8;
    context[4] = a2;
    context[5] = Mutable;
    v24.length = CFArrayGetCount(a3);
    v24.location = 0LL;
    CFArrayApplyFunction(a3, v24, (CFArrayApplierFunction)sub_1001055CC, context);
  }

  else
  {
    v12 = (uint64_t *)*((void *)a2 + 1);
    if (v12)
    {
      v13 = (uint64_t **)(a2 + 4);
      do
      {
        sub_1001055E0(v11, v12);
        v14 = *v13++;
        v12 = v14;
      }

      while (v14);
    }
  }

  if (a4) {
    CFStringAppendFormat(v11, 0LL, @"INSERT INTO tversion(version,minor) VALUES(%d, %d);", *a2, a2[1]);
  }
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000LL;
  v17[2] = sub_100105824;
  v17[3] = &unk_100286E20;
  v17[4] = &v19;
  v17[5] = a1;
  v17[6] = a5;
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000LL;
  v23[2] = sub_1000134E4;
  v23[3] = &unk_100283030;
  v23[4] = v17;
  sub_10001337C(v11, (uint64_t)v23);
  if (v11) {
    CFRelease(v11);
  }
  uint64_t v15 = *((unsigned __int8 *)v20 + 24);
  _Block_object_dispose(&v19, 8);
  return v15;
}

void sub_1001055B8(uint64_t a1, int a2)
{
}

uint64_t sub_1001055CC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_1001055E0(__CFString *a1, uint64_t *a2)
{
  uint64_t v4 = a2[2];
  if (!v4) {
    goto LABEL_26;
  }
  uint64_t v5 = a2 + 3;
  do
  {
    if ((*(_BYTE *)(v4 + 16) & 2) == 0) {
      goto LABEL_11;
    }
    unsigned int v6 = *(_DWORD *)(v4 + 8) - 2;
    CFTypeID v7 = @"BLOB";
    if (v6 <= 0xD) {
      CFTypeID v7 = off_100287368[v6];
    }
    CFStringAppendFormat(a1, 0LL, @"%@ %@", *(void *)v4, v7);
    uint64_t v8 = *(void *)(v4 + 16);
    if ((v8 & 0x1000) != 0)
    {
      CFStringAppend(a1, @" NOT NULL");
      uint64_t v8 = *(void *)(v4 + 16);
      if ((v8 & 0x400) != 0)
      {
LABEL_14:
        CFStringAppend(a1, @" DEFAULT 0");
        if ((*(void *)(v4 + 16) & 0x800) == 0) {
          goto LABEL_10;
        }
LABEL_9:
        CFStringAppend(a1, @" DEFAULT ''");
        goto LABEL_10;
      }
    }

    else if ((v8 & 0x400) != 0)
    {
      goto LABEL_14;
    }

    if ((v8 & 0x800) != 0) {
      goto LABEL_9;
    }
LABEL_10:
    CFStringAppend(a1, @",");
LABEL_11:
    uint64_t v9 = *v5++;
    uint64_t v4 = v9;
  }

  while (v9);
  uint64_t v10 = a2[2];
  if (v10)
  {
    char v11 = 0;
    v12 = a2 + 3;
    do
    {
      if ((~*(_DWORD *)(v10 + 16) & 3LL) == 0)
      {
        v13 = *(const __CFString **)v10;
        if (v11) {
          v14 = @",";
        }
        else {
          v14 = CFSTR("UNIQUE(");
        }
        char v11 = 1;
        CFStringAppend(a1, v14);
        CFStringAppend(a1, v13);
      }

      uint64_t v15 = *v12++;
      uint64_t v10 = v15;
    }

    while (v15);
    if (v11) {
      CFStringAppend(a1, @""));
    }
  }

BOOL sub_100105824(uint64_t a1, const char *a2)
{
  uint64_t v4 = sqlite3_exec(*(sqlite3 **)(*(void *)(a1 + 40) + 64LL), a2, 0LL, 0LL, 0LL);
  BOOL result = sub_1000149A0( v4,  *(sqlite3 **)(*(void *)(a1 + 40) + 64LL),  *(CFTypeRef **)(a1 + 48),  @"sqlite3_exec: %s",  a2);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

CFDataRef sub_100105888(uint64_t a1, int a2, __CFString **a3)
{
  if (a2 == 8)
  {
    CFTypeID v7 = sub_1000E9614((void **)a1, a3);
    return (CFDataRef)_SecItemCreateUUIDBasedPersistentRef(**(void **)(a1 + 16), v7, *(void *)(a1 + 48));
  }

  char v5 = a2;
  if (a2 == 1)
  {
    uint64_t v9 = (__CFDictionary *)sub_1000E7EC0((void *)a1, kSecValueData);
    if (!v9) {
      return CFDataCreate(kCFAllocatorDefault, 0LL, 0LL);
    }
    unsigned int v6 = v9;
    CFRetain(v9);
  }

  else if (a2)
  {
    uint64_t v10 = CFGetAllocator((CFTypeRef)a1);
    CFMutableStringRef Mutable = CFDictionaryCreateMutable(v10, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    unsigned int v6 = Mutable;
    if ((v5 & 4) != 0) {
      CFDictionarySetValue(Mutable, kSecClass, **(const void ***)(a1 + 16));
    }
    uint64_t v12 = *(void *)(a1 + 16);
    uint64_t v13 = *(void *)(v12 + 16);
    if (v13)
    {
      v14 = (uint64_t *)(v12 + 24);
      do
      {
        if ((*(void *)(v13 + 16) & ((16LL * ((v5 & 6) != 0)) | (32LL * ((v5 & 5) != 0)))) != 0)
        {
          uint64_t v15 = sub_1000E705C((const void *)a1, v13, a3);
          if (!v15)
          {
            if (v6)
            {
              CFRelease(v6);
              unsigned int v6 = 0LL;
            }

            break;
          }

          v16 = v15;
          if (!CFEqual(kCFNull, v15)) {
            CFDictionarySetValue(v6, *(const void **)v13, v16);
          }
        }

        uint64_t v17 = *v14++;
        uint64_t v13 = v17;
      }

      while (v17);
    }

    CFDictionaryRemoveValue(v6, kSecAttrUUID);
    if ((v5 & 8) != 0)
    {
      int v18 = sub_1000E9614((void **)a1, a3);
      UUIDBasedPersistentRef = (const void *)_SecItemCreateUUIDBasedPersistentRef( **(void **)(a1 + 16),  v18,  *(void *)(a1 + 48));
      CFDictionarySetValue(v6, kSecValuePersistentRef, UUIDBasedPersistentRef);
      if (UUIDBasedPersistentRef) {
        CFRelease(UUIDBasedPersistentRef);
      }
    }
  }

  else
  {
    return kCFNull;
  }

  return v6;
}

uint64_t sub_100105ABC(uint64_t a1, uint64_t a2, CFDataRef *a3, __CFString **a4)
{
  if (*(void *)(a2 + 24) == *(void *)(a2 + 16) && !*(void *)(a2 + 88))
  {
    uint64_t v10 = (void **)sub_1000E8E18(*(void *)a2, *(const __CFDictionary **)(a2 + 8), 0, a4);
    if (!v10) {
      return 0LL;
    }
    char v11 = v10;
    if (sub_1000E9A9C(v10))
    {
      if (*(void *)(a2 + 96)) {
        uint64_t v12 = *(const __CFData **)(a2 + 96);
      }
      else {
        uint64_t v12 = kCFBooleanTrue;
      }
      sub_1000E7958((uint64_t)v11, &off_1002875E0, v12, 0LL);
    }

    uint64_t v13 = *(const __CFData **)(a2 + 56);
    if (v13) {
      int v14 = sub_1000E8AF8((uint64_t)v11, @"v_Data", v13, a4);
    }
    else {
      int v14 = 1;
    }
    uint64_t v15 = *(void *)(a2 + 72);
    if (v15) {
      int v14 = sub_1000E97C0(v11, v15, a4);
    }
    v16 = *(const __CFData **)(a2 + 80);
    if (v16) {
      int v14 = sub_1000E96B4((uint64_t)v11, v16, a4);
    }
    uint64_t v17 = *(const __CFData **)(a2 + 128);
    if (v17) {
      int v14 = sub_1000E8AF8((uint64_t)v11, @"musr", v17, a4);
    }
    sub_1000E7E78((uint64_t)v11, *(CFTypeRef *)(a2 + 144));
    if (sub_100098648(v18, v19))
    {
      sub_100105E24(v11, *(unsigned __int8 *)(a2 + 154), a4);
      if (*(void *)(a2 + 160))
      {
        uint64_t v20 = sub_1000E705C(v11, (uint64_t)&off_1002905E8, a4);
        if (v20)
        {
          sub_100098B84((uint64_t)v20, *(void **)(a2 + 160));
        }

        else
        {
          uint64_t v21 = (os_log_s *)sub_10001267C("SecError");
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Couldn't fetch UUID from item; can't call callback",
              buf,
              2u);
          }
        }
      }
    }

    if (v14)
    {
      char v22 = *(_BYTE *)(a2 + 154);
      *(void *)buf = _NSConcreteStackBlock;
      uint64_t v33 = 0x40000000LL;
      v34 = sub_1000EBBC4;
      v35 = &unk_100285F88;
      v36 = v11;
      char v37 = v22;
      char v38 = 0;
      int v23 = sub_1000EA178((uint64_t)v11, a1, a4, (uint64_t)buf);
      int v24 = v23;
      if (a3 && v23)
      {
        int v25 = *(_DWORD *)(a2 + 48);
        if (v25) {
          *a3 = sub_100105888((uint64_t)v11, v25, a4);
        }
        goto LABEL_50;
      }
    }

    else
    {
      int v24 = 0;
    }

    if (a4 && (v24 & 1) == 0 && *a4)
    {
      CFErrorDomain Domain = CFErrorGetDomain((CFErrorRef)*a4);
      if (CFEqual(Domain, @"com.apple.utilities.sqlite3") && CFErrorGetCode((CFErrorRef)*a4) == 19)
      {
        v27 = *a4;
        if (*a4)
        {
          *a4 = 0LL;
          CFRelease(v27);
        }

        sub_1000194E0(-25299, a4, @"duplicate item %@", v11);
        goto LABEL_54;
      }

      CFErrorDomain v28 = CFErrorGetDomain((CFErrorRef)*a4);
      if (CFEqual(v28, kCFErrorDomainOSStatus))
      {
        if (CFErrorGetCode((CFErrorRef)*a4) == -26275)
        {
          uint64_t v29 = sub_1000E6D50(v11[2], 14LL, a4);
          v30 = sub_1000E705C(v11, v29, a4);
          if (v30)
          {
            if (CFEqual(v30, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly))
            {
              v31 = *a4;
              if (*a4)
              {
                *a4 = 0LL;
                CFRelease(v31);
              }

              sub_1000194E0(-25293, a4, @"authentication failed");
              goto LABEL_54;
            }
          }
        }
      }
    }

    if (v24)
    {
LABEL_50:
      uint64_t v5 = 1LL;
      *(_BYTE *)(a2 + 113) = 1;
      goto LABEL_55;
    }

void sub_100105E24(void *a1, int a2, __CFString **a3)
{
  if (a1)
  {
    if (!a2) {
      goto LABEL_13;
    }
    uint64_t v5 = sub_1000F4058(a1, 1LL, a3);
    if (v5)
    {
      unsigned int v6 = v5;
      CFTypeID v7 = sub_10001A36C(v5);
      CFRelease(v6);
    }

    else
    {
      CFTypeID v7 = 0LL;
    }

    if (CFDataGetLength(v7) < 16)
    {
      uint64_t v8 = 0LL;
      if (!v7) {
        goto LABEL_11;
      }
    }

    else
    {
      memset(buffer, 170, sizeof(buffer));
      v10.location = 0LL;
      v10.length = 16LL;
      CFDataGetBytes(v7, v10, buffer);
      uint64_t v8 = CFUUIDCreateWithBytes( 0LL,  buffer[0],  buffer[1],  buffer[2],  buffer[3],  buffer[4],  buffer[5],  buffer[6],  buffer[7],  buffer[8],  buffer[9],  buffer[10],  buffer[11],  buffer[12],  buffer[13],  buffer[14],  buffer[15]);
      if (!v7)
      {
LABEL_11:
        if (v8)
        {
          sub_1000E8AF8((uint64_t)a1, kSecAttrUUID, v8, a3);
LABEL_14:
          CFRelease(v8);
          return;
        }

BOOL sub_100105F8C(uint64_t a1, const __CFArray *a2, uint64_t a3, __CFString **a4, uint64_t a5)
{
  uint64_t v17 = 0LL;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2000000000LL;
  char v20 = 1;
  if (*(void *)(a1 + 64))
  {
    BOOL v6 = sub_1000194E0(-50, a4, @"value ref not supported by queries");
  }

  else
  {
    char v11 = sub_1001060CC(a1, a2);
    *((_BYTE *)v18 + 24) = v11 != 0LL;
    if (v11)
    {
      uint64_t v12 = v11;
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 0x40000000LL;
      v16[2] = sub_1001062C4;
      v16[3] = &unk_100286EB0;
      v16[6] = &v17;
      v16[7] = a1;
      v16[8] = a2;
      v16[9] = a4;
      v16[10] = a3;
      v16[4] = &stru_100286E60;
      v16[5] = a5;
      unsigned __int8 v13 = sub_100015B70(a3, v11, (CFTypeRef *)a4, (uint64_t)v16);
      if (*((_BYTE *)v18 + 24)) {
        unsigned __int8 v14 = v13;
      }
      else {
        unsigned __int8 v14 = 0;
      }
      *((_BYTE *)v18 + 24) = v14;
      CFRelease(v12);
      BOOL v6 = *((_BYTE *)v18 + 24) != 0;
    }

    else
    {
      BOOL v6 = 0LL;
    }
  }

  _Block_object_dispose(&v17, 8);
  return v6;
}

__CFString *sub_1001060CC(uint64_t a1, const __CFArray *a2)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(0LL, 0LL);
  uint64_t v5 = *(const __CFData **)(a1 + 80);
  if (*(__CFString ***)a1 == &off_10028B168)
  {
    if (v5 && CFDataGetLength(v5) == 16) {
      CFTypeID v7 = CFSTR("SELECT crowid, certdata, certpersistref, rowid, data, persistref FROM (SELECT cert.rowid AS crowid, cert.labl AS labl, cert.issr AS issr, cert.slnr AS slnr, cert.skid AS skid, cert.tkid AS tkid, keys.*,cert.data AS certdata, cert.persistref AS certpersistref FROM keys, cert WHERE keys.priv == 1 AND cert.pkhh == keys.klbl");
    }
    else {
      CFTypeID v7 = CFSTR("SELECT crowid, certdata, rowid, data FROM (SELECT cert.rowid AS crowid, cert.labl AS labl, cert.issr AS issr, cert.slnr AS slnr, cert.skid AS skid, cert.tkid AS tkid, keys.*,cert.data AS certdata FROM keys, cert WHERE keys.priv == 1 AND cert.pkhh == keys.klbl");
    }
    CFStringAppend(Mutable, v7);
    sub_100106784(Mutable, @"cert.agrp", a2, 0LL);
    sub_100106830(Mutable, (uint64_t)@"crowid", *(void *)(a1 + 72), 0LL);
    CFStringAppend(Mutable, @""));
    char v10 = 1;
    sub_10010688C(Mutable, a1, &v10);
    sub_1001068DC(Mutable, a1, &v10);
    uint64_t v8 = *(const __CFData **)(a1 + 80);
    if (v8 && CFDataGetLength(v8) == 16)
    {
      sub_1000E950C(Mutable, &v10);
      CFStringAppend(Mutable, @"certpersistref = ?");
    }

    sub_100106784(Mutable, @"agrp", a2, &v10);
    sub_100106938(Mutable, *(_BYTE *)(a1 + 153), &v10);
  }

  else
  {
    if (v5 && CFDataGetLength(v5) == 16)
    {
      BOOL v6 = @"SELECT rowid, data, agrp, persistref FROM ";
    }

    else if ((*(_BYTE *)(a1 + 48) & 8) != 0)
    {
      BOOL v6 = @"SELECT rowid, data, agrp, persistref FROM ";
    }

    else
    {
      BOOL v6 = @"SELECT rowid, data, agrp FROM ";
    }

    CFStringAppend(Mutable, v6);
    CFStringAppend(Mutable, **(CFStringRef **)a1);
    sub_100106974(Mutable, a1, a2);
  }

  if (!*(void *)(a1 + 176)
    && !*(void *)(a1 + 200)
    && !*(void *)(a1 + 208)
    && !*(void *)(a1 + 224)
    && !*(void *)(a1 + 232)
    && *(void *)(a1 + 104) != -1LL)
  {
    CFStringAppendFormat(Mutable, 0LL, @" LIMIT %ld", *(void *)(a1 + 104));
  }

  return Mutable;
}

uint64_t sub_1001062C4(uint64_t result, sqlite3_stmt *a2)
{
  uint64_t v3 = result;
  int v18 = 1;
  if (**(__CFString ****)(result + 56) == &off_10028B168)
  {
    BOOL result = sub_1001063D4(a2, *(CFArrayRef *)(result + 64), &v18, *(CFTypeRef **)(result + 72));
    uint64_t v4 = *(void *)(*(void *)(v3 + 48) + 8LL);
    if (*(_BYTE *)(v4 + 24)) {
      char v5 = result;
    }
    else {
      char v5 = 0;
    }
    *(_BYTE *)(v4 + 24) = v5;
  }

  if (*(_BYTE *)(*(void *)(*(void *)(v3 + 48) + 8LL) + 24LL))
  {
    BOOL result = sub_100106498(a2, *(void *)(v3 + 56), *(const __CFArray **)(v3 + 64), &v18, *(CFTypeRef **)(v3 + 72));
    uint64_t v6 = *(void *)(*(void *)(v3 + 48) + 8LL);
    if (*(_BYTE *)(v6 + 24)) {
      char v7 = result;
    }
    else {
      char v7 = 0;
    }
    *(_BYTE *)(v6 + 24) = v7;
    if (*(_BYTE *)(*(void *)(*(void *)(v3 + 48) + 8LL) + 24LL))
    {
      uint64_t v9 = *(CFTypeRef **)(v3 + 72);
      uint64_t v8 = *(void *)(v3 + 80);
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 0x40000000LL;
      v11[2] = sub_10010660C;
      v11[3] = &unk_100286E88;
      uint64_t v10 = *(void *)(v3 + 64);
      uint64_t v13 = *(void *)(v3 + 56);
      unsigned __int8 v14 = a2;
      uint64_t v15 = v9;
      uint64_t v16 = v8;
      uint64_t v17 = v10;
      __int128 v12 = *(_OWORD *)(v3 + 32);
      return sub_100015CD8(v8, a2, v9, (uint64_t)v11);
    }
  }

  return result;
}

BOOL sub_1001063D4(sqlite3_stmt *a1, CFArrayRef theArray, int *a3, CFTypeRef *a4)
{
  int v5 = *a3;
  if (theArray && (CFIndex Count = CFArrayGetCount(theArray), Count >= 1))
  {
    CFIndex v10 = Count;
    BOOL v11 = 0;
    CFIndex v12 = 0LL;
    do
    {
      CFIndex v13 = v12;
      uint64_t v14 = (v5 + v12);
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v12);
      if ((sub_1000182E4(a1, v14, ValueAtIndex, a4) & 1) == 0) {
        break;
      }
      CFIndex v12 = v13 + 1;
      BOOL v11 = v13 + 1 >= v10;
    }

    while (v10 != v13 + 1);
    v5 += v13 + 1;
  }

  else
  {
    BOOL v11 = 1;
  }

  *a3 = v5;
  return v11;
}

uint64_t sub_100106498(sqlite3_stmt *a1, uint64_t a2, const __CFArray *a3, _DWORD *a4, CFTypeRef *a5)
{
  uint64_t v10 = *a4;
  uint64_t v11 = *(void *)(a2 + 32);
  if (v11 < 1)
  {
LABEL_5:
    uint64_t v15 = (CFTypeRef *)(a2 + 128);
    if (sub_1000F7718(*(CFTypeRef *)(a2 + 128)))
    {
      int v20 = v10;
    }

    else
    {
      if (*v15)
      {
        CFTypeID v16 = CFGetTypeID(*v15);
        if (v16 == CFNullGetTypeID())
        {
          if (qword_1002DEA70 != -1) {
            dispatch_once(&qword_1002DEA70, &stru_100286568);
          }
          uint64_t v15 = (CFTypeRef *)&qword_1002DEA78;
        }

        uint64_t v17 = (const __CFString *)*v15;
      }

      else
      {
        uint64_t v17 = 0LL;
      }

      uint64_t result = sub_1000182E4(a1, v10, v17, a5);
      int v20 = v10 + 1;
      uint64_t v10 = (v10 + 1);
      if (!(_DWORD)result) {
        goto LABEL_20;
      }
    }

    uint64_t v19 = *(const __CFData **)(a2 + 80);
    if (v19
      && CFDataGetLength(v19) == 16
      && (uint64_t result = sub_1000182E4(a1, v10, *(const __CFString **)(a2 + 80), a5), v20 = v10 + 1, !(_DWORD)result))
    {
      LODWORD(v10) = v10 + 1;
    }

    else
    {
      uint64_t result = sub_1001063D4(a1, a3, &v20, a5);
      LODWORD(v10) = v20;
    }

    goto LABEL_20;
  }

  CFIndex v12 = (const __CFString **)(a2 + 264);
  while (1)
  {
    uint64_t v13 = v10;
    uint64_t v10 = (v10 + 1);
    uint64_t v14 = *v12;
    v12 += 2;
    if ((sub_1000182E4(a1, v13, v14, a5) & 1) == 0) {
      break;
    }
    if (!--v11) {
      goto LABEL_5;
    }
  }

  uint64_t result = 0LL;
LABEL_20:
  *a4 = v10;
  return result;
}

void sub_10010660C(uint64_t a1)
{
  uint64_t v2 = sub_1000E90CC( kCFAllocatorDefault,  **(void ***)(a1 + 48),  *(sqlite3_stmt **)(a1 + 56),  *(_DWORD *)(*(void *)(a1 + 48) + 120LL),  *(void *)(a1 + 32));
  if (v2)
  {
    uint64_t v3 = v2;
    uint64_t v4 = *(void *)(a1 + 48);
    uint64_t v5 = *(void *)(v4 + 144);
    *(void *)(v4 + 144) = 0LL;
    uint64_t v6 = *(const void **)(v2 + 56);
    if (v6) {
      CFRelease(v6);
    }
    *(void *)(v3 + 56) = v5;
    if (sub_100111BDC( *(void *)(a1 + 72),  *(void *)(a1 + 48),  *(void *)(a1 + 80),  *(CFDictionaryRef *)(v3 + 48))) {
      (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
    }
    CFRelease((CFTypeRef)v3);
  }

  else
  {
    char v7 = (os_log_s *)sub_10001267C("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(const char ***)(a1 + 64);
      if (v8) {
        uint64_t v9 = *v8;
      }
      else {
        uint64_t v9 = "no error";
      }
      int v12 = 138412290;
      uint64_t v13 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "failed to create item from stmt: %@",  (uint8_t *)&v12,  0xCu);
    }

    uint64_t v10 = *(const void ***)(a1 + 64);
    if (v10)
    {
      uint64_t v11 = *v10;
      if (*v10)
      {
        CFAllocatorRef v10 = 0LL;
        CFRelease(v11);
      }
    }
  }

void sub_100106784(__CFString *a1, const __CFString *a2, CFArrayRef theArray, _BYTE *a4)
{
  if (theArray)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count)
    {
      uint64_t v8 = Count;
      sub_1000E950C(a1, a4);
      CFStringAppend(a1, a2);
      CFStringAppend(a1, @" IN (?");
      if (v8 >= 2)
      {
        uint64_t v9 = v8 - 1;
        do
        {
          CFStringAppend(a1, @",?");
          --v9;
        }

        while (v9);
      }

      CFStringAppend(a1, @""));
    }
  }

void sub_100106830(__CFString *a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  if (a3 >= 1)
  {
    sub_1000E950C(a1, a4);
    CFStringAppendFormat(a1, 0LL, @"%@=%lld", a2, a3);
  }

void sub_10010688C(__CFString *a1, uint64_t a2, _BYTE *a3)
{
  uint64_t v3 = *(void *)(a2 + 32);
  if (v3 >= 1)
  {
    uint64_t v6 = (const __CFString **)(a2 + 256);
    do
    {
      char v7 = *v6;
      v6 += 2;
      sub_1000E9558(a1, v7, a3);
      --v3;
    }

    while (v3);
  }

void sub_1001068DC(__CFString *a1, uint64_t a2, _BYTE *a3)
{
  if (!sub_1000F7718(*(CFTypeRef *)(a2 + 128)))
  {
    uint64_t v5 = *(const void **)(a2 + 128);
    if (v5)
    {
      CFGetTypeID(v5);
      CFNullGetTypeID();
    }

    CFStringAppend(a1, @"musr = ?");
  }

void sub_100106938(__CFString *a1, char a2, _BYTE *a3)
{
  if (a2)
  {
    sub_1000E950C(a1, a3);
    CFStringAppend(a1, @"clip = 0");
  }

void sub_100106974(__CFString *a1, uint64_t a2, const __CFArray *a3)
{
  char v7 = 1;
  sub_100106830(a1, (uint64_t)@"ROWID", *(void *)(a2 + 72), &v7);
  sub_10010688C(a1, a2, &v7);
  sub_1001068DC(a1, a2, &v7);
  uint64_t v6 = *(const __CFData **)(a2 + 80);
  if (v6 && CFDataGetLength(v6) == 16)
  {
    sub_1000E950C(a1, &v7);
    CFStringAppend(a1, @"persistref = ?");
  }

  sub_100106784(a1, @"agrp", a3, &v7);
  sub_100106938(a1, *(_BYTE *)(a2 + 153), &v7);
}

BOOL sub_100106A3C(id a1, const SecDbAttr *a2)
{
  int var1 = a2->var1;
  return (var1 & 0xFFFFFFFE) == 8 || var1 == 16;
}

uint64_t sub_100106A54(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4, __CFString **a5)
{
  v12[0] = a2;
  v12[1] = a4;
  v12[2] = a1;
  CFTypeRef cf = 0LL;
  uint64_t v8 = *(const __CFData **)(a2 + 80);
  if (v8 && CFDataGetLength(v8) == 16 && *(void *)(a2 + 32)) {
    return sub_1000194E0( -50,  a5,  @"attributes to query illegal; both persistent ref and other attributes can't be searched at the same time");
  }
  if (*(void *)(a2 + 232) && *(void *)(a2 + 32) != 1LL) {
    return sub_1000194E0( -50,  a5,  @"attributes to query illegal; both token persistent ref and other attributes can't be searched at the same time");
  }
  uint64_t v10 = (const void *)kSecAttrTombstone;
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(a2 + 8), kSecAttrTombstone)) {
    sub_1000F7B40(v10, kCFBooleanFalse, a2);
  }
  unint64_t v14 = 0xAAAAAAAA00000000LL;
  BOOL v11 = sub_100107624((uint64_t)sub_100106B6C, (uint64_t)v12, a5);
  if (a3 && v11)
  {
    *a3 = cf;
    return 1LL;
  }

  else if (cf)
  {
    CFRelease(cf);
  }

  return v11;
}

void sub_100106B6C(sqlite3_stmt *a1, uint64_t a2)
{
  uint64_t v4 = *(const void ****)a2;
  int v5 = *(_DWORD *)(*(void *)a2 + 48LL);
  sqlite3_int64 v6 = sqlite3_column_int64(a1, 0);
  CFDictionaryRef theDict = 0LL;
  char v7 = (CFDictionaryRef *)(v4 + 5);
  while ((sub_100107910(a1, (uint64_t)v4, 1, *(const __CFArray **)(a2 + 8), &theDict, 0LL, 0LL, (__CFString **)v4 + 5) & 1) != 0)
  {
    if (!theDict)
    {
      *((_DWORD *)v4 + 12) = v5;
      return;
    }

    if (!CFDictionaryContainsKey(theDict, kSecAttrTokenID) || (int v8 = *((_DWORD *)v4 + 12), (v8 & 1) != 0))
    {
      uint64_t v10 = v4[29];
      if (v10)
      {
        Value = CFDictionaryGetValue(theDict, kSecValueData);
      }

      *(void *)buf = 0LL;
      int v12 = (const __CFData *)v4[10];
      if (v12 && CFDataGetLength(v12) == 16)
      {
        uint64_t v13 = *(const __CFArray **)(a2 + 8);
        unint64_t v14 = a1;
        uint64_t v15 = (uint64_t)v4;
        int v16 = 4;
      }

      else
      {
        uint64_t v13 = *(const __CFArray **)(a2 + 8);
        unint64_t v14 = a1;
        uint64_t v15 = (uint64_t)v4;
        int v16 = 3;
      }

      if (!sub_100107910(v14, v15, v16, v13, (CFDictionaryRef *)buf, 0LL, 0LL, (__CFString **)v4 + 5)
        || !*(void *)buf)
      {
        goto LABEL_99;
      }

      v31 = CFDictionaryGetValue(theDict, kSecValueData);
      if (v31)
      {
        CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, @"certdata", v31);
        CFDictionaryRemoveValue(theDict, kSecValueData);
      }

      v32 = CFDictionaryGetValue(theDict, kSecAttrTokenID);
      if (v32)
      {
        CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, @"certtkid", v32);
        CFDictionaryRemoveValue(theDict, kSecAttrTokenID);
      }

      CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_100107C6C, *(void **)buf);
      CFRelease(theDict);
      CFDictionaryRef theDict = *(CFDictionaryRef *)buf;
LABEL_45:
      if (*((_BYTE *)v4 + 116))
      {
        uint64_t v33 = (const __CFString *)CFDictionaryGetValue(theDict, kSecAttrSharingGroup);
        if (v33)
        {
          v34 = v33;
          CFTypeID v35 = CFGetTypeID(v33);
          if (v35 == CFStringGetTypeID())
          {
            if (CFStringCompare(v34, kSecAttrSharingGroupNone, 0LL)) {
              goto LABEL_99;
            }
          }
        }
      }

      v36 = (const __CFData *)CFDictionaryGetValue(theDict, kSecAttrPersistentReference);
      char v37 = theDict;
      char v38 = (void *)CFDictionaryGetValue(theDict, kSecValueData);
      int v39 = *((_DWORD *)v4 + 12);
      if ((v39 & 8) != 0)
      {
        if (v36 && CFDataGetLength(v36) == 16)
        {
          uint64_t UUIDBasedPersistentRef = _SecItemCreateUUIDBasedPersistentRef(**v4, v36, v37);
        }

        else
        {
          v50 = (os_log_s *)sub_10001267C("pref");
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            *(void *)&buf[4] = v6;
            _os_log_impl( (void *)&_mh_execute_header,  v50,  OS_LOG_TYPE_DEFAULT,  "handle_result: Creating old persistent ref for %llu",  buf,  0xCu);
          }

          uint64_t UUIDBasedPersistentRef = _SecItemCreatePersistentRef(**v4, v6, v37);
        }

        v40 = (const void *)UUIDBasedPersistentRef;
        int v39 = *((_DWORD *)v4 + 12);
      }

      else
      {
        v40 = 0LL;
      }

      switch(v39)
      {
        case 8:
          if (v36 && CFDataGetLength(v36) == 16)
          {
            CFDataRef PersistentRef = (CFDataRef)_SecItemCreateUUIDBasedPersistentRef(**v4, v36, v37);
          }

          else
          {
            v52 = (os_log_s *)sub_10001267C("pref");
            if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 134217984;
              *(void *)&buf[4] = v6;
              _os_log_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_DEFAULT,  "handle_result: Creating old persistent ref for %llu",  buf,  0xCu);
            }

            CFDataRef PersistentRef = (CFDataRef)_SecItemCreatePersistentRef(**v4, v6, v37);
          }

          break;
        case 1:
          if (v38)
          {
            CFRetain(v38);
            char v37 = (__CFDictionary *)v38;
            if (v40) {
              goto LABEL_88;
            }
            goto LABEL_89;
          }

          CFDataRef PersistentRef = CFDataCreate(kCFAllocatorDefault, 0LL, 0LL);
          break;
        case 0:
          char v37 = kCFNull;
          if (!v40) {
            goto LABEL_89;
          }
LABEL_88:
          CFRelease(v40);
          goto LABEL_89;
        default:
          if ((v39 & 4) != 0)
          {
            CFDictionarySetValue(v37, kSecClass, **v4);
            goto LABEL_140;
          }

          if ((v39 & 2) == 0)
          {
            if (v38) {
              CFRetain(v38);
            }
            CFDictionaryRemoveAllValues(v37);
            if (v38 && ((_DWORD)v4[6] & 1) != 0)
            {
              CFDictionarySetValue(v37, kSecValueData, v38);
              goto LABEL_139;
            }

            if (v38) {
LABEL_139:
            }
              CFRelease(v38);
LABEL_140:
            if (((_BYTE)v4[6] & 8) != 0 && v40) {
              CFDictionarySetValue(v37, kSecValuePersistentRef, v40);
            }
            CFRetain(v37);
            if (v40) {
              goto LABEL_88;
            }
LABEL_89:
            if (v37)
            {
              if (v37 != kCFNull)
              {
                if (v4[13] == (const void **)1)
                {
                  *(void *)(a2 + 24) = v37;
                  goto LABEL_95;
                }

                CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 24), v37);
              }

              CFRelease(v37);
LABEL_95:
              ++*(_DWORD *)(a2 + 32);
            }

            if (CFDictionaryContainsKey(theDict, kSecAttrPersistentReference) && ((_BYTE)v4[6] & 2) != 0) {
              CFDictionaryRemoveValue(theDict, kSecAttrPersistentReference);
            }
LABEL_99:
            CFDictionaryRef v53 = theDict;
            *((_DWORD *)v4 + 12) = v5;
            if (v53) {
LABEL_100:
            }
              CFRelease(v53);
            return;
          }

          if ((v39 & 1) == 0) {
            CFDictionaryRemoveValue(v37, kSecValueData);
          }
          v56 = (uint64_t (**)(const void *, const void *, _BYTE *))(*v4)[2];
          if (!v56)
          {
LABEL_137:
            CFDictionaryRemoveValue(v37, kSecAttrUUID);
            goto LABEL_140;
          }

          v57 = 0LL;
          v58 = *v4 + 3;
          while (2)
          {
            if (((_BYTE)v56[2] & 0x10) != 0 && !CFDictionaryGetValue(v37, *v56) && v56[3])
            {
              v60 = 0LL;
              *(void *)buf = 0LL;
              if (!v57)
              {
                v57 = sub_1000E8E18((uint64_t)*v4, v37, 0, (__CFString **)buf);
                v60 = *(const void **)buf;
              }

              if (v60 || !v57) {
                goto LABEL_133;
              }
              if (*((_DWORD *)v56 + 2) != 7 || ((_BYTE)v4[6] & 1) != 0)
              {
                v61 = (const void *)v56[3](v57, v56, buf);
                v60 = *(const void **)buf;
                if (!*(void *)buf && v61)
                {
                  CFDictionarySetValue(v37, *v56, v61);
                  goto LABEL_132;
                }

                if (v61)
                {
LABEL_132:
                  CFRelease(v61);
                  v60 = *(const void **)buf;
                }

LABEL_133:
                if (v60)
                {
                  *(void *)buf = 0LL;
                  CFRelease(v60);
                }
              }
            }

            v59 = (uint64_t (**)(const void *, const void *, _BYTE *))*v58++;
            v56 = v59;
            if (!v59)
            {
              if (v57) {
                CFRelease(v57);
              }
              goto LABEL_137;
            }

            continue;
          }
      }

      char v37 = PersistentRef;
      if (!v40) {
        goto LABEL_89;
      }
      goto LABEL_88;
    }

    *((_DWORD *)v4 + 12) = v8 | 1;
    CFDictionaryRef v9 = theDict;
    if (theDict)
    {
      CFDictionaryRef theDict = 0LL;
      CFRelease(v9);
    }
  }

  int OSStatus = SecErrorGetOSStatus(*v7);
  int v18 = OSStatus;
  if (OSStatus > -25331)
  {
    if (OSStatus == -25330)
    {
      v42 = (os_log_s *)sub_10001267C("SecWarning");
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      v43 = **v4;
      v44 = v4[5];
      *(_DWORD *)buf = 138413058;
      *(void *)&buf[4] = v43;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v6;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v64) = -25330;
      WORD2(v64) = 2112;
      *(void *)((char *)&v64 + 6) = v44;
      v45 = "Authentication is needed for %@,rowid=%lld (%d): %@";
      v46 = v42;
      goto LABEL_59;
    }

    if (OSStatus == -25308)
    {
      if (qword_1002DEB10 != -1) {
        dispatch_once(&qword_1002DEB10, &stru_1002872C8);
      }
      dispatch_source_merge_data((dispatch_source_t)qword_1002DEB18, 1uLL);
      return;
    }

LABEL_57:
    v47 = (os_log_s *)sub_10001267C("SecError");
    if (!os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    v48 = **v4;
    v49 = v4[5];
    *(_DWORD *)buf = 138413058;
    *(void *)&buf[4] = v48;
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v6;
    *(_WORD *)&buf[22] = 1024;
    LODWORD(v64) = v18;
    WORD2(v64) = 2112;
    *(void *)((char *)&v64 + 6) = v49;
    v45 = "decode %@,rowid=%lld failed (%d): %@";
    v46 = v47;
LABEL_59:
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, v45, buf, 0x26u);
    return;
  }

  if (OSStatus == -34018) {
    goto LABEL_111;
  }
  if (OSStatus != -26275) {
    goto LABEL_57;
  }
  uint64_t v19 = (os_log_s *)sub_10001267C("SecWarning");
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    int v20 = **v4;
    uint64_t v21 = v4[5];
    *(_DWORD *)buf = 138412802;
    *(void *)&buf[4] = v20;
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v6;
    *(_WORD *)&buf[22] = 2112;
    *(void *)&__int128 v64 = v21;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "ignoring corrupt %@,rowid=%lld %@", buf, 0x20u);
  }

  CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, (CFStringRef)**v4);
  int v23 = (const void *)sub_1001110DC(0LL);
  if (v23)
  {
    int v24 = v23;
    CFRetain(v23);
    CFRetain(Copy);
    *(void *)buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000LL;
    *(void *)&buf[16] = sub_1001126EC;
    *(void *)&__int128 v64 = &unk_10028F440;
    *((void *)&v64 + 1) = v24;
    CFStringRef v65 = Copy;
    sqlite3_int64 v66 = v6;
    if (qword_1002DEBD0 != -1) {
      dispatch_once(&qword_1002DEBD0, &stru_10028FAD8);
    }
    dispatch_async((dispatch_queue_t)qword_1002DEBD8, buf);
  }

  if (Copy) {
    CFRelease(Copy);
  }
  int v25 = sub_100107BA0(a1, 1);
  CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
  if (Mutable)
  {
    BytePtr = CFDataGetBytePtr(v25);
    CFIndex Length = CFDataGetLength(v25);
    if ((Length & 0x8000000000000000LL) == 0)
    {
      unint64_t v29 = Length;
      CFStringAppendFormat(Mutable, 0LL, @"%04lx:", Length);
      if (v29 > 8)
      {
        *(void *)buf = 0LL;
        CNCRC(60LL, BytePtr + 8, v29 - 8, buf);
        for (uint64_t i = 0LL; i != 8; ++i)
          CFStringAppendFormat(Mutable, 0LL, @"%02X", BytePtr[i]);
        CFStringAppendFormat(Mutable, 0LL, @"...|%08llx", *(void *)buf);
      }

      else
      {
        for (; v29; --v29)
        {
          unsigned int v30 = *BytePtr++;
          CFStringAppendFormat(Mutable, 0LL, @"%02X", v30);
        }
      }
    }

    v55 = (os_log_s *)sub_10001267C("item");
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      *(void *)&buf[4] = Mutable;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "corrupted edata=%@", buf, 0xCu);
    }
  }

  if (v25) {
    CFRelease(v25);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
LABEL_111:
  CFDictionaryRef v53 = *v7;
  if (*v7)
  {
    *char v7 = 0LL;
    goto LABEL_100;
  }

  v6[11] = self->_timestampRequestEnd;
  *((_DWORD *)v6 + 70) |= 0x400u;
  int v25 = self->_has;
  if ((*(_WORD *)&v25 & 0x2000) == 0)
  {
LABEL_26:
    if ((*(_WORD *)&v25 & 0x1000) == 0) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }

    uint64_t v19 = 1;
    goto LABEL_230;
  }

  v155 = 0LL;
  v156 = &v155;
  v157 = 0x2020000000LL;
  v158 = 0LL;
  v34 = (const __CFSet *)sub_1001ABD80(a4);
  CFTypeID v35 = v34;
  if (v34)
  {
    if (CFSetGetCount(v34) == 1)
    {
      *(void *)buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3221225472LL;
      *(void *)&buf[16] = sub_1001ABDDC;
      v160 = (const char *)&unk_100292A88;
      v161 = &v155;
      v162 = 0LL;
      CFSetApplyFunction(v35, (CFSetApplierFunction)sub_1001ABE58, buf);
    }
  }

  else
  {
    SOSCreateError(1045LL, @"Wrong set count for one return", 0LL, 0LL);
  }

  char v37 = v156[3];
  _Block_object_dispose(&v155, 8);
  if (!v37
    || (v136 = v37, !SOSPeerInfoIsViewPermitted(v140, v37))
    || (v23 & SOSPeerInfoHasBackupKey(v140) & 1) == 0)
  {
LABEL_56:
    Instance = 0LL;
    goto LABEL_57;
  }

BOOL sub_100107624(uint64_t a1, uint64_t a2, __CFString **a3)
{
  uint64_t v4 = *(void *)a2;
  if (*(void *)(*(void *)a2 + 64LL)) {
    return sub_1000194E0(-50, a3, @"value ref not supported by queries");
  }
  CFDictionaryRef v9 = *(const __CFArray **)(a2 + 8);
  uint64_t v8 = *(void *)(a2 + 16);
  if (*(void *)(v4 + 104) == 1LL) {
    CFMutableArrayRef Mutable = 0LL;
  }
  else {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
  }
  *(void *)(a2 + 24) = Mutable;
  BOOL v11 = sub_1001060CC(v4, v9);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000LL;
  v14[2] = sub_10010779C;
  v14[3] = &unk_100287288;
  v14[4] = v4;
  v14[5] = v9;
  v14[6] = a3;
  v14[7] = v8;
  v14[8] = a1;
  v14[9] = a2;
  v14[10] = a2;
  int v12 = sub_1000162BC(v8, v11, (CFTypeRef *)a3, (uint64_t)v14);
  CFRelease(v11);
  BOOL v13 = 0LL;
  if (sub_1000F80C8(v4, (CFErrorRef *)a3) && v12)
  {
    if (*(_DWORD *)(a2 + 32))
    {
      return 1LL;
    }

    else
    {
      BOOL v13 = sub_1000194E0(-25300, a3, @"no matching items found");
      if (*(_BYTE *)(v4 + 196)) {
        sub_10001BE54(@"ItemNotFound", 0x53C00008u);
      }
    }
  }

  return v13;
}

uint64_t sub_10010779C(uint64_t a1, sqlite3_stmt *a2)
{
  int v11 = 1;
  uint64_t v4 = *(__CFString ****)(a1 + 32);
  if (*v4 == &off_10028B168)
  {
    uint64_t result = sub_1001063D4(a2, *(CFArrayRef *)(a1 + 40), &v11, *(CFTypeRef **)(a1 + 48));
    if (!(_DWORD)result) {
      return result;
    }
    uint64_t v4 = *(__CFString ****)(a1 + 32);
  }

  uint64_t result = sub_100106498(a2, (uint64_t)v4, *(const __CFArray **)(a1 + 40), &v11, *(CFTypeRef **)(a1 + 48));
  if ((_DWORD)result)
  {
    char v7 = *(CFTypeRef **)(a1 + 48);
    uint64_t v6 = *(void *)(a1 + 56);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 0x40000000LL;
    v10[2] = sub_100107868;
    v10[3] = &unk_100287268;
    uint64_t v8 = *(void *)(a1 + 72);
    v10[4] = *(void *)(a1 + 64);
    v10[5] = a2;
    uint64_t v9 = *(void *)(a1 + 32);
    v10[6] = v8;
    v10[7] = v9;
    v10[8] = *(void *)(a1 + 80);
    sub_100018624(v6, a2, v7, (uint64_t)v10);
    return 1LL;
  }

  return result;
}

uint64_t sub_100107868(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v3 = *(__CFError **)(v2 + 40);
  if (v3)
  {
    CFIndex Code = CFErrorGetCode(v3);
    BOOL v5 = Code == -25330;
    uint64_t v2 = *(void *)(a1 + 56);
    if (*(_BYTE *)(v2 + 152)) {
      BOOL v6 = Code == -25330;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6)
    {
      char v7 = *(const void **)(v2 + 40);
      if (v7)
      {
        *(void *)(v2 + 40) = 0LL;
        CFRelease(v7);
        uint64_t v2 = *(void *)(a1 + 56);
      }

      BOOL v5 = 1;
    }
  }

  else
  {
    BOOL v5 = 0;
  }

  uint64_t v8 = *(void *)(v2 + 104);
  if (*(void *)(v2 + 40)) {
    return v5;
  }
  return 1LL;
}

uint64_t sub_100107910( sqlite3_stmt *a1, uint64_t a2, int a3, const __CFArray *a4, CFDictionaryRef *a5, void *a6, _DWORD *a7, __CFString **a8)
{
  unint64_t v14 = sub_100107BA0(a1, a3);
  if (!v14) {
    return 0LL;
  }
  uint64_t v15 = v14;
  CFTypeRef cf = 0LL;
  unsigned int v28 = 0;
  if ((*(_BYTE *)(a2 + 48) & 5) != 0
    || *(void *)(a2 + 200)
    || *(void *)(a2 + 208)
    || (uint64_t v16 = *(void *)(a2 + 224)) != 0)
  {
    LOBYTE(v16) = 1;
  }

  if (sub_1000F212C( *(unsigned int *)(a2 + 120),  0LL,  @"od",  &cf,  *(const __CFData **)(a2 + 144),  v14,  *(void *)a2,  *(const __CFString **)(a2 + 184),  (const void **)a5,  &v28,  v16,  a7,  a8))
  {
    if (v28 > 1)
    {
      int v18 = (const void *)SecAccessControlCopyData(cf);
      Value = (const __CFString *)CFDictionaryGetValue(*a5, kSecAttrAccessGroup);
      if ((sub_10010DD28(a4, Value, 0LL) & 1) != 0)
      {
        if (v28 >= 4) {
          CFDictionarySetValue(*a5, kSecAttrAccessControl, v18);
        }
        uint64_t v17 = 1LL;
      }

      else
      {
        int v20 = sub_10001267C("SecError");
        uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          char v22 = CFDictionaryGetValue(*a5, kSecAttrAccessGroup);
          *(_DWORD *)buf = 138412546;
          v31 = v22;
          __int16 v32 = 2112;
          uint64_t v33 = a4;
          _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "item's accessGroup '%@' not in %@",  buf,  0x16u);
        }

        int v23 = CFDictionaryGetValue(*a5, kSecAttrAccessGroup);
        sub_1000194E0(-34018, a8, @"item's access group '%@' not in %@", v23, a4);
        CFDictionaryRef v24 = *a5;
        if (*a5)
        {
          *a5 = 0LL;
          CFRelease(v24);
        }

        uint64_t v17 = 0LL;
      }

      goto LABEL_20;
    }

    sub_1000194E0(-26275, a8, @"version is unexpected: %d", v28);
  }

  uint64_t v17 = 0LL;
  int v18 = 0LL;
LABEL_20:
  CFTypeRef v25 = cf;
  if (a6)
  {
    if (cf)
    {
      CFRetain(cf);
      CFTypeRef v26 = cf;
    }

    else
    {
      CFTypeRef v26 = 0LL;
    }

    *a6 = v25;
    CFTypeRef v25 = v26;
  }

  if (v25) {
    CFRelease(v25);
  }
  if (v18) {
    CFRelease(v18);
  }
  CFRelease(v15);
  return v17;
}

CFDataRef sub_100107BA0(sqlite3_stmt *a1, int a2)
{
  uint64_t v4 = (const UInt8 *)sqlite3_column_blob(a1, a2);
  int v5 = sqlite3_column_bytes(a1, a2);
  return CFDataCreateWithBytesNoCopy(0LL, v4, v5, kCFAllocatorNull);
}

BOOL sub_100107BF4(const void *a1, uint64_t a2)
{
  if (!a2) {
    return 0LL;
  }
  uint64_t v3 = (const __CFDictionary *)SecTokenItemValueCopy(a2, 0LL);
  if (!v3) {
    return 0LL;
  }
  uint64_t v4 = v3;
  Value = CFDictionaryGetValue(v3, @"oid");
  if (Value) {
    BOOL v6 = CFEqual(a1, Value) != 0;
  }
  else {
    BOOL v6 = a1 == 0LL;
  }
  CFRelease(v4);
  return v6;
}

void sub_100107C6C(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

void sub_100107C80(id a1)
{
  dispatch_source_t v1 = sub_10001A100("ratelimiterdisabledlogevent", 1LL);
  qword_1002DEB18 = (uint64_t)v1;
  context = dispatch_get_context(v1);
  context[2] = _Block_copy(&stru_100287308);
  dispatch_activate(v1);
}

void sub_100107CD0(id a1)
{
  dispatch_source_t v1 = (os_log_s *)sub_10001267C("SecError");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    v2[0] = 67109120;
    v2[1] = -25308;
    _os_log_impl( (void *)&_mh_execute_header,  v1,  OS_LOG_TYPE_DEFAULT,  "decode item failed, keychain is locked (%d)",  (uint8_t *)v2,  8u);
  }

void sub_100107D70(sqlite3_stmt *a1, uint64_t a2)
{
  uint64_t v4 = *(uint64_t ***)a2;
  sqlite3_int64 v5 = sqlite3_column_int64(a1, 0);
  BOOL v6 = sub_100107BA0(a1, 1);
  char v7 = (const UInt8 *)sqlite3_column_blob(a1, 3);
  int v8 = sqlite3_column_bytes(a1, 3);
  uint64_t v9 = CFDataCreate(kCFAllocatorDefault, v7, v8);
  if (!v9)
  {
    uint64_t UUIDBasedPersistentRef = 0LL;
    if (v6) {
      goto LABEL_8;
    }
LABEL_5:
    BOOL v12 = 0;
    BOOL v13 = 0LL;
    BOOL v14 = UUIDBasedPersistentRef != 0LL;
    goto LABEL_13;
  }

  uint64_t v10 = v9;
  if (CFDataGetLength(v9) == 16) {
    uint64_t UUIDBasedPersistentRef = (const void *)_SecItemCreateUUIDBasedPersistentRef(**v4, v10, 0LL);
  }
  else {
    uint64_t UUIDBasedPersistentRef = 0LL;
  }
  CFRelease(v10);
  if (!v6) {
    goto LABEL_5;
  }
LABEL_8:
  BOOL v13 = sub_10001A36C(v6);
  BOOL v12 = v13 != 0LL;
  BOOL v14 = UUIDBasedPersistentRef != 0LL;
  if (v13 && UUIDBasedPersistentRef)
  {
    CFDictionaryRef v22 = sub_100107FA8( 0LL,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  (uint64_t)kSecValuePersistentRef,  (uint64_t)UUIDBasedPersistentRef);
    if (v22)
    {
      CFDictionaryRef v23 = v22;
      CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 24), v22);
      CFRelease(v23);
    }

    ++*(_DWORD *)(a2 + 32);
    BOOL v14 = 1;
    goto LABEL_15;
  }

CFDictionaryRef sub_100107FA8( CFAllocatorRef allocator, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  CFDictionaryRef v22 = &a10;
  unint64_t v11 = 0LL;
  if (a9)
  {
    do
    {
      v11 += 2LL;
      BOOL v12 = v22;
      v22 += 2;
    }

    while (v12[1]);
  }

  unint64_t v13 = v11 >> 1;
  CFDictionaryRef v23 = (const void **)&a9;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( allocator,  v11 >> 1,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!Mutable) {
    return 0LL;
  }
  int v15 = Mutable;
  if (v11)
  {
    do
    {
      int v16 = v23;
      int v17 = *v23;
      v23 += 2;
      int v18 = (const __CFNull *)v16[1];
      if (v18) {
        CFNullRef v19 = v18;
      }
      else {
        CFNullRef v19 = kCFNull;
      }
      CFDictionarySetValue(v15, v17, v19);
      --v13;
    }

    while (v13);
  }

  CFDictionaryRef Copy = CFDictionaryCreateCopy(allocator, v15);
  CFRelease(v15);
  return Copy;
}

void sub_100108098(CFDictionaryRef *a1)
{
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  uint64_t v3 = CFDateCreate(0LL, Current);
  uint64_t v4 = *((void *)*a1 + 2);
  if (v4)
  {
    sqlite3_int64 v5 = (uint64_t *)((char *)*a1 + 24);
    do
    {
      uint64_t v6 = *(void *)(v4 + 16);
      if ((v6 & 2) != 0)
      {
        if ((*(_DWORD *)(v4 + 8) - 5) > 1)
        {
          uint64_t v7 = *(void *)(v4 + 16);
          if ((v7 & 0x400) != 0)
          {
            if (*(_DWORD *)(v4 + 8) == 4)
            {
              CFDateRef v9 = CFDateCreate(kCFAllocatorDefault, 0.0);
            }

            else
            {
              int valuePtr = 0;
              CFDateRef v9 = CFNumberCreate(0LL, kCFNumberSInt32Type, &valuePtr);
            }
          }

          else
          {
            if ((v7 & 0x800) == 0) {
              goto LABEL_18;
            }
            int v8 = *(_DWORD *)(v4 + 8);
            if (v8 != 16 && v8 != 1)
            {
              CFRetain(&stru_100294B48);
              uint64_t v10 = (const __CFData *)&stru_100294B48;
LABEL_17:
              sub_1000F7914((void *)v4, v10, (uint64_t)a1);
              CFRelease(v10);
              goto LABEL_18;
            }

            CFDateRef v9 = CFDataCreate(kCFAllocatorDefault, 0LL, 0LL);
          }

          uint64_t v10 = v9;
          if (v9) {
            goto LABEL_17;
          }
        }

        else
        {
          sub_1001081F4((CFTypeRef *)v4, v3, (uint64_t)a1);
        }
      }

void sub_1001081F4(CFTypeRef *a1, const __CFData *a2, uint64_t a3)
{
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a3 + 8), *a1) && *(uint64_t *)(a3 + 32) >= 1)
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = (CFTypeRef *)(a3 + 272);
    while (!CFEqual(*a1, *(v7 - 2)))
    {
      ++v6;
      v7 += 2;
      if (v6 >= *(void *)(a3 + 32)) {
        goto LABEL_13;
      }
    }

    int v8 = *(const void **)(a3 + 16 * v6 + 264);
    if (v8) {
      CFRelease(v8);
    }
    uint64_t v9 = *(void *)(a3 + 32);
    *(void *)(a3 + 32) = v9 - 1;
    if (v6 < v9 - 1)
    {
      uint64_t v10 = ~v6 + v9;
      do
      {
        *((_OWORD *)v7 - 1) = *(_OWORD *)v7;
        v7 += 2;
        --v10;
      }

      while (v10);
    }

    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a3 + 8), *a1);
  }

BOOL sub_1001082CC(void *a1, _BYTE *a2)
{
  uint64_t v4 = (const void *)kSecAttrTombstone;
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(a1[5] + 8LL), kSecAttrTombstone)) {
    sub_1000F7B40(v4, kCFBooleanFalse, a1[5]);
  }
  sqlite3_int64 v5 = (const __CFArray *)a1[6];
  uint64_t v6 = a1[7];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000LL;
  v12[2] = sub_1001083AC;
  void v12[3] = &unk_100286ED8;
  uint64_t v7 = (__CFString **)a1[8];
  v12[6] = a1[9];
  v12[7] = v6;
  uint64_t v8 = a1[5];
  v12[4] = a1[4];
  v12[5] = v8;
  v12[8] = v7;
  BOOL result = sub_100105F8C(v8, v5, v6, v7, (uint64_t)v12);
  uint64_t v10 = *(void *)(a1[4] + 8LL);
  if (*(_BYTE *)(v10 + 24)) {
    BOOL v11 = result;
  }
  else {
    BOOL v11 = 0;
  }
  *(_BYTE *)(v10 + 24) = v11;
  if (!*(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL)) {
    *a2 = 0;
  }
  return result;
}

void sub_1001083AC(uint64_t a1, void **a2)
{
  CFTypeRef cf = 0LL;
  uint64_t v4 = *(void *)(a1 + 40);
  if (*(void *)(v4 + 232))
  {
    uint64_t v5 = sub_1000E6D50(a2[2], 1LL, 0LL);
    uint64_t v6 = sub_1000E705C(a2, v5, 0LL);
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v7 = *(const void **)(v4 + 232);
    if (v7)
    {
      uint64_t v4 = *(void *)(a1 + 40);
    }
  }

  if (*(_BYTE *)(v4 + 116))
  {
    uint64_t v8 = (const __CFString *)sub_1000E7EC0(a2, kSecAttrSharingGroup);
    if (v8)
    {
      uint64_t v9 = v8;
      CFTypeID v10 = CFGetTypeID(v8);
      if (v10 == CFStringGetTypeID())
      {
        if (CFStringCompare(v9, kSecAttrSharingGroupNone, 0LL))
        {
          BOOL v11 = (os_log_s *)sub_10001267C("SecError");
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Cannot update shared item for unentitled client",  buf,  2u);
          }

          return;
        }
      }
    }
  }

  BOOL v12 = (void *)sub_1000E6D50(a2[2], 7LL, 0LL);
  unint64_t v13 = (const __CFData *)sub_1000E705C(a2, (uint64_t)v12, 0LL);
  BOOL v14 = v13;
  if (v13) {
    CFRetain(v13);
  }
  int v15 = sub_1000E9350((uint64_t)a2, *(const __CFDictionary **)(*(void *)(a1 + 48) + 8LL), (__CFString **)&cf);
  sub_1000E7958((uint64_t)a2, v12, v14, 0LL);
  if (v14) {
    CFRelease(v14);
  }
  if (SecErrorGetOSStatus(cf) == -26275)
  {
    int v16 = (os_log_s *)sub_10001267C("SecWarning");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = ***(void ***)(a1 + 40);
      uint64_t v18 = sub_1000E9718(a2, 0LL);
      *(_DWORD *)buf = 138412802;
      uint64_t v36 = v17;
      __int16 v37 = 2048;
      uint64_t v38 = v18;
      __int16 v39 = 2112;
      CFTypeRef v40 = cf;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "deleting corrupt %@,rowid=%lld %@",  buf,  0x20u);
    }

    CFTypeRef v19 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v19);
    }

    if ((sub_1000ECAF0((CFStringRef **)a2, *(void *)(a1 + 56), 0LL, 0, &cf) & 1) == 0)
    {
      int v20 = (os_log_s *)sub_10001267C("SecError");
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v21 = ***(void ***)(a1 + 40);
        uint64_t v22 = sub_1000E9718(a2, 0LL);
        *(_DWORD *)buf = 138412802;
        uint64_t v36 = v21;
        __int16 v37 = 2048;
        uint64_t v38 = v22;
        __int16 v39 = 2112;
        CFTypeRef v40 = cf;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "failed to delete corrupt %@,rowid=%lld %@",  buf,  0x20u);
      }

      CFTypeRef v23 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
        CFRelease(v23);
      }
    }

    if (!v15) {
      return;
    }
LABEL_58:
    CFRelease(v15);
    return;
  }

  if (v15)
  {
    uint64_t v24 = *(void *)(*(void *)(a1 + 48) + 136LL);
    if (v24) {
      sub_1000E8D5C((uint64_t)v15, v24, (__CFString **)&cf);
    }
  }

  uint64_t v25 = (__CFError *)cf;
  CFTypeRef v26 = *(CFErrorRef **)(a1 + 64);
  if (cf && v26)
  {
    if (*v26)
    {
      if (CFErrorGetCode(*v26) != -25330) {
        goto LABEL_38;
      }
      CFErrorRef v27 = *v26;
      if (*v26)
      {
        *CFTypeRef v26 = 0LL;
        CFRelease(v27);
LABEL_38:
        if (*v26) {
          goto LABEL_39;
        }
      }
    }

    char v28 = 0;
    *CFTypeRef v26 = v25;
    goto LABEL_42;
  }

  if (cf)
  {
    if (!v26)
    {
LABEL_39:
      CFRelease(v25);
      char v28 = 0;
      goto LABEL_42;
    }

    goto LABEL_38;
  }

  char v28 = 1;
LABEL_42:
  if (!v15) {
    char v28 = 0;
  }
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v28;
  if (v15)
  {
    int v29 = sub_1000E9934(a2);
    unsigned __int8 v30 = sub_1000E9990(a2);
    uint64_t v31 = *(void *)(a1 + 56);
    __int16 v32 = *(const __CFBoolean **)(*(void *)(a1 + 40) + 96LL);
    if (!v32)
    {
      else {
        __int16 v32 = kCFBooleanFalse;
      }
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = sub_1000EC42C( a2,  (void **)v15,  v31,  v32,  *(unsigned __int8 *)(*(void *)(a1 + 40) + 154LL),  *(__CFString ***)(a1 + 64));
    if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)) {
      goto LABEL_58;
    }
    uint64_t v33 = *(void *)(a1 + 40);
    *(_BYTE *)(v33 + 113) = 1;
    if ((v29 & 1) == 0)
    {
      if (!sub_1000E9934((void **)v15))
      {
LABEL_55:
        goto LABEL_58;
      }

      uint64_t v33 = *(void *)(a1 + 40);
    }

    *(_BYTE *)(v33 + 114) = 1;
    goto LABEL_55;
  }

BOOL sub_100108830(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v22 = 0LL;
  CFTypeRef v23 = &v22;
  uint64_t v24 = 0x2000000000LL;
  char v25 = 1;
  uint64_t v18 = 0LL;
  CFTypeRef v19 = &v18;
  uint64_t v20 = 0x2000000000LL;
  char v21 = 0;
  uint64_t v8 = (const void *)kSecAttrTombstone;
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(a2 + 8), kSecAttrTombstone)) {
    sub_1000F7B40(v8, kCFBooleanFalse, a2);
  }
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000LL;
  v17[2] = sub_100108A00;
  v17[3] = &unk_100286F60;
  v17[4] = a2;
  v17[5] = a3;
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 0x40000000LL;
  v16[2] = sub_100108A24;
  v16[3] = &unk_100286F80;
  v16[4] = a2;
  v16[5] = a3;
  v16[6] = a4;
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000LL;
  v15[2] = sub_100108A58;
  v15[3] = &unk_100286FA8;
  v15[6] = a2;
  v15[7] = a4;
  v15[4] = &v18;
  v15[5] = &v22;
  v15[8] = a1;
  BOOL v9 = sub_1000EA68C((CFDictionaryRef *)a2, a1, a4, 0LL, &stru_100286F40, (uint64_t)v17, (uint64_t)v16, (uint64_t)v15);
  if (*((_BYTE *)v23 + 24)) {
    BOOL v10 = v9;
  }
  else {
    BOOL v10 = 0;
  }
  *((_BYTE *)v23 + 24) = v10;
  if (!v10) {
    goto LABEL_12;
  }
  BOOL v11 = v19;
  if (*(_BYTE *)(a2 + 113) || *((_BYTE *)v19 + 24)) {
    goto LABEL_11;
  }
  BOOL v12 = sub_1000194E0(-25300, (__CFString **)a4, @"Delete failed to delete anything");
  *((_BYTE *)v23 + 24) = v12;
  if (!v12)
  {
LABEL_12:
    BOOL v13 = 0LL;
    goto LABEL_13;
  }

  BOOL v11 = v19;
LABEL_11:
  BOOL v13 = *((unsigned __int8 *)v11 + 24) == 0;
LABEL_13:
  _Block_object_dispose(&v18, 8);
  _Block_object_dispose(&v22, 8);
  return v13;
}

uint64_t sub_100108A00(uint64_t a1, __CFString *a2)
{
  return 1LL;
}

uint64_t sub_100108A24(uint64_t a1, sqlite3_stmt *a2, int a3)
{
  int v4 = a3;
  return sub_100106498(a2, *(void *)(a1 + 32), *(const __CFArray **)(a1 + 40), &v4, *(CFTypeRef **)(a1 + 48));
}

void sub_100108A58(uint64_t a1, uint64_t a2)
{
  if (*(void *)(*(void *)(a1 + 48) + 232LL))
  {
    uint64_t v4 = sub_1000E6D50(*(void **)(a2 + 16), 1LL, 0LL);
    uint64_t v5 = sub_1000E705C((const void *)a2, v4, 0LL);
    uint64_t v6 = *(const void **)(*(void *)(a1 + 48) + 232LL);
    if (v6)
    {
    }
  }

  *(void *)(a2 + 64) = @"odel";
  uint64_t v7 = *(CFErrorRef **)(a1 + 56);
  CFErrorRef err = 0LL;
  BOOL v8 = sub_1000E714C(a2, 1, (__CFString **)&err);
  CFErrorRef v9 = err;
  if (!v8 && err)
  {
    if (CFErrorGetCode(err) == -25330)
    {
      if (v7) {
        *uint64_t v7 = err;
      }
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
      return;
    }

    CFErrorRef v9 = err;
  }

  if (v9) {
    CFRelease(v9);
  }
  if (*(_BYTE *)(*(void *)(a1 + 48) + 116LL)
    && (BOOL v10 = (const __CFString *)sub_1000E7EC0((void *)a2, kSecAttrSharingGroup)) != 0LL
    && (BOOL v11 = v10, v12 = CFGetTypeID(v10), v12 == CFStringGetTypeID())
    && CFStringCompare(v11, kSecAttrSharingGroupNone, 0LL))
  {
    BOOL v13 = (os_log_s *)sub_10001267C("SecError");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v22 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Cannot delete shared item for unentitled client",  v22,  2u);
    }
  }

  else
  {
    BOOL v14 = (void *)sub_1000E6D50(*(void **)(a2 + 16), 7LL, 0LL);
    int v15 = (const __CFData *)sub_1000E705C((const void *)a2, (uint64_t)v14, 0LL);
    if (v15)
    {
      int v16 = v15;
      CFRetain(v15);
      int v17 = sub_1000E9934((void **)a2);
      unsigned int v18 = sub_1000E9990((void *)a2);
      sub_1000E7958(a2, v14, v16, 0LL);
      CFRelease(v16);
    }

    else
    {
      int v17 = sub_1000E9934((void **)a2);
      unsigned int v18 = sub_1000E9990((void *)a2);
      sub_1000E7958(a2, v14, 0LL, 0LL);
    }

    uint64_t v19 = *(void *)(a1 + 64);
    uint64_t v20 = *(const __CFBoolean **)(*(void *)(a1 + 48) + 96LL);
    if (!v20)
    {
      else {
        uint64_t v20 = kCFBooleanFalse;
      }
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = sub_1000ECAF0( (CFStringRef **)a2,  v19,  v20,  *(unsigned __int8 *)(*(void *)(a1 + 48) + 155LL),  *(CFTypeRef **)(a1 + 56));
    if (*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL))
    {
      char v21 = *(_BYTE **)(a1 + 48);
      v21[113] = 1;
      if (v17) {
        v21[114] = 1;
      }
      if (v18) {
        v21[115] = 1;
      }
    }
  }

BOOL sub_100108CFC(id a1, const SecDbAttr *a2)
{
  return 0;
}

uint64_t sub_100108D04(const __CFDictionary *a1, uint64_t a2, int a3)
{
  Value = (const __CFNumber *)CFDictionaryGetValue(a1, kSecAttrSysBound);
  if (Value && (uint64_t v7 = Value, v8 = CFGetTypeID(Value), v8 == CFNumberGetTypeID()))
  {
    int valuePtr = 0;
    if (CFNumberGetValue(v7, kCFNumberSInt32Type, &valuePtr)) {
      BOOL v9 = valuePtr == 0;
    }
    else {
      BOOL v9 = 1;
    }
    return !v9;
  }

  else
  {
    uint64_t result = (uint64_t)CFDictionaryGetValue(a1, kSecAttrAccessGroup);
    if (result)
    {
      BOOL v11 = (const void *)result;
      CFTypeID v12 = CFGetTypeID((CFTypeRef)result);
      if (v12 != CFStringGetTypeID()) {
        return 0LL;
      }
      if (kSOSInternalAccessGroup && CFEqual(v11, kSOSInternalAccessGroup)
        || CFEqual(v11, @"lockdown-identities"))
      {
        return 1LL;
      }

      if (CFEqual(v11, @"apple")
        && sub_10010C560((uint64_t)@"genp", &qword_1002DEB28, (uint64_t)&unk_1002DEB20) == a2)
      {
        __int16 v37 = CFDictionaryGetValue(a1, kSecAttrService);
        uint64_t v38 = CFDictionaryGetValue(a1, kSecAttrAccount);
        if (sub_100109378(v37))
        {
          if (sub_100109378(v38) && CFEqual(v37, @"com.apple.managedconfiguration"))
          {
            char v39 = 0;
            uint64_t v40 = 0LL;
            char v41 = 1;
            char v42 = 1;
            do
            {
              char v43 = v42;
              char v44 = v39;
              char v42 = v41;
              int v45 = CFEqual(v38, off_100286FC8[v40]);
              if (v45) {
                break;
              }
              char v41 = 0;
              char v39 = 1;
              uint64_t v40 = 1LL;
            }

            while ((v44 & 1) == 0);
            char v46 = v45 ? v43 : v42;
            if ((v46 & 1) != 0) {
              return 1LL;
            }
          }
        }

        if (sub_100109378(v37) && CFEqual(v37, @"com.apple.account.CloudKit.token")
          || sub_100109378(v37) && CFEqual(v37, @"com.apple.account.idms.continuation-key"))
        {
          return 1LL;
        }
      }

      if (a3)
      {
        if (CFEqual(v11, @"com.apple.apsd"))
        {
          if (sub_10010C560((uint64_t)@"genp", &qword_1002DEB28, (uint64_t)&unk_1002DEB20) == a2)
          {
            BOOL v13 = CFDictionaryGetValue(a1, kSecAttrService);
            if (sub_100109378(v13))
            {
              char v14 = 0;
              uint64_t v15 = 0LL;
              char v16 = 1;
              char v17 = 1;
              do
              {
                char v18 = v17;
                char v19 = v14;
                char v17 = v16;
                int v20 = CFEqual(v13, off_100286FD8[v15]);
                if (v20) {
                  break;
                }
                char v16 = 0;
                char v14 = 1;
                uint64_t v15 = 1LL;
              }

              while ((v19 & 1) == 0);
              char v21 = v20 ? v18 : v17;
              if ((v21 & 1) != 0) {
                return 1LL;
              }
            }
          }
        }

        if (CFEqual(v11, @"appleaccount"))
        {
          if (sub_10010C560((uint64_t)@"genp", &qword_1002DEB28, (uint64_t)&unk_1002DEB20) == a2)
          {
            uint64_t v22 = CFDictionaryGetValue(a1, kSecAttrService);
            if (sub_100109378(v22))
            {
              unint64_t v23 = 0LL;
              BOOL v24 = 1;
              do
              {
                if (CFEqual(v22, off_100286FE8[v23])) {
                  break;
                }
                BOOL v24 = v23++ < 3;
              }

              while (v23 != 4);
              if (v24) {
                return 1LL;
              }
            }
          }
        }

        if (CFEqual(v11, @"apple")
          && sub_10010C560((uint64_t)@"genp", &qword_1002DEB28, (uint64_t)&unk_1002DEB20) == a2)
        {
          v47 = (const __CFString *)CFDictionaryGetValue(a1, kSecAttrService);
          if (sub_100109378(v47))
          {
            unint64_t v48 = 0LL;
            BOOL v49 = 1;
            do
            {
              if (CFEqual(v47, off_100287008[v48])) {
                break;
              }
              BOOL v49 = v48++ < 0xD;
            }

            while (v48 != 14);
            if (v49) {
              return 1LL;
            }
          }

          if (sub_100109378(v47))
          {
            if (CFEqual(v47, @"com.apple.facetime"))
            {
              v50 = CFDictionaryGetValue(a1, kSecAttrAccount);
              if (sub_100109378(v50))
              {
                if (CFEqual(v50, @"registrationV1")) {
                  return 1LL;
                }
              }
            }
          }
        }

        if (CFEqual(v11, @"com.apple.ind"))
        {
          if (sub_10010C560((uint64_t)@"genp", &qword_1002DEB28, (uint64_t)&unk_1002DEB20) == a2)
          {
            char v25 = CFDictionaryGetValue(a1, kSecAttrService);
            if (sub_100109378(v25))
            {
              if (CFEqual(v25, @"com.apple.ind.registration")) {
                return 1LL;
              }
            }
          }
        }

        if (CFEqual(v11, @"ichat"))
        {
          if (sub_10010C560((uint64_t)@"genp", &qword_1002DEB28, (uint64_t)&unk_1002DEB20) == a2)
          {
            CFTypeRef v26 = CFDictionaryGetValue(a1, kSecAttrService);
            if (sub_100109378(v26))
            {
              if (CFEqual(v26, @"ids")) {
                return 1LL;
              }
            }
          }
        }

        if (CFEqual(v11, @"ichat"))
        {
          if (sub_10010C560((uint64_t)@"keys", &qword_1002DEB58, (uint64_t)&unk_1002DEB50) == a2)
          {
            CFErrorRef v27 = CFDictionaryGetValue(a1, kSecAttrLabel);
            if (sub_100109378(v27))
            {
              char v28 = 0;
              uint64_t v29 = 0LL;
              char v30 = 1;
              char v31 = 1;
              do
              {
                char v32 = v31;
                char v33 = v28;
                char v31 = v30;
                int v34 = CFEqual(v27, off_100287078[v29]);
                if (v34) {
                  break;
                }
                char v30 = 0;
                char v28 = 1;
                uint64_t v29 = 1LL;
              }

              while ((v33 & 1) == 0);
              char v35 = v34 ? v32 : v31;
              if ((v35 & 1) != 0) {
                return 1LL;
              }
            }
          }
        }

        if (CFEqual(v11, @"com.apple.rapport")
          && sub_10010C560((uint64_t)@"genp", &qword_1002DEB28, (uint64_t)&unk_1002DEB20) == a2)
        {
          return 1LL;
        }
      }

      CFTypeRef cf = 0LL;
      if (CFDictionaryGetValueIfPresent(a1, kSecAttrSharingGroup, &cf)
        && cf
        && (CFTypeID v36 = CFGetTypeID(cf), v36 == CFStringGetTypeID()))
      {
        return 1LL;
      }

      else
      {
        return 0LL;
      }
    }
  }

  return result;
}

const void *sub_100109378(const void *result)
{
  if (result)
  {
    CFTypeID v1 = CFGetTypeID(result);
    return (const void *)(v1 == CFStringGetTypeID());
  }

  return result;
}

uint64_t sub_1001093A8(uint64_t a1)
{
  if (sub_10010943C( *(void *)(a1 + 32),  @"DELETE FROM genp WHERE musr = ?",  *(const __CFString **)(a1 + 40),  *(unsigned __int8 *)(a1 + 56),  *(CFTypeRef **)(a1 + 48))
    && sub_10010943C( *(void *)(a1 + 32),  @"DELETE FROM inet WHERE musr = ?",  *(const __CFString **)(a1 + 40),  *(unsigned __int8 *)(a1 + 56),  *(CFTypeRef **)(a1 + 48))
    && sub_10010943C( *(void *)(a1 + 32),  @"DELETE FROM cert WHERE musr = ?",  *(const __CFString **)(a1 + 40),  *(unsigned __int8 *)(a1 + 56),  *(CFTypeRef **)(a1 + 48)))
  {
    return sub_10010943C( *(void *)(a1 + 32),  @"DELETE FROM keys WHERE musr = ?",  *(const __CFString **)(a1 + 40),  *(unsigned __int8 *)(a1 + 56),  *(CFTypeRef **)(a1 + 48));
  }

  else
  {
    return 0LL;
  }

uint64_t sub_10010943C(uint64_t a1, CFTypeRef cf, const __CFString *a3, int a4, CFTypeRef *a5)
{
  if (a4) {
    CFTypeID v8 = CFStringCreateWithFormat(0LL, 0LL, @"%@ AND pdmn NOT IN ('aku','akpu','cku','dku')", cf);
  }
  else {
    CFTypeID v8 = (const __CFString *)CFRetain(cf);
  }
  BOOL v9 = v8;
  if (v8)
  {
    BOOL v10 = sub_100015014(a1, v8, 0LL, a5);
    if (v10)
    {
      BOOL v11 = v10;
      if (sub_100015290(v11, a5))
      {
        uint64_t v12 = 1LL;
LABEL_16:
        CFRelease(v9);
        return v12;
      }
    }
  }

  BOOL v13 = (os_log_s *)sub_10001267C("SecWarning");
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    if (a5) {
      CFTypeRef v14 = *a5;
    }
    else {
      CFTypeRef v14 = 0LL;
    }
    *(_DWORD *)buf = 138412802;
    char v17 = v9;
    __int16 v18 = 2112;
    char v19 = a3;
    __int16 v20 = 2112;
    CFTypeRef v21 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "DeleteAllFromTableForMUSRView failed for %@ for musr: %@: %@",  buf,  0x20u);
  }

  uint64_t v12 = 0LL;
  uint64_t result = 0LL;
  if (v9) {
    goto LABEL_16;
  }
  return result;
}

uint64_t sub_1001095C4(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)sub_10001267C("item");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Request to delete app clip keychain items for identifier '%@'",  (uint8_t *)&buf,  0xCu);
  }

  *(void *)&__int128 buf = 0LL;
  *((void *)&buf + 1) = &buf;
  uint64_t v22 = 0x2000000000LL;
  uint64_t v23 = 0LL;
  uint64_t v11 = 0LL;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000LL;
  char v14 = 1;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000LL;
  v10[2] = sub_1001097A4;
  v10[3] = &unk_100287100;
  v10[4] = &buf;
  v10[5] = &v11;
  v10[6] = a1;
  unsigned __int8 v3 = sub_100110ECC(1, 1, 0LL, (uint64_t)&v23, (uint64_t)v10);
  int v4 = v3 & (*((_BYTE *)v12 + 24) != 0);
  *((_BYTE *)v12 + 24) = v4;
  if (v4) {
    uint64_t v5 = 0LL;
  }
  else {
    uint64_t v5 = 4294941020LL;
  }
  uint64_t v6 = (os_log_s *)sub_10001267C("item");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(*((void *)&buf + 1) + 24LL);
    *(_DWORD *)uint64_t v15 = 138412802;
    uint64_t v16 = a1;
    __int16 v17 = 1024;
    int v18 = v5;
    __int16 v19 = 2112;
    uint64_t v20 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Finished request to delete app clip keychain items for identifier '%@' with status %i: %@",  v15,  0x1Cu);
  }

  CFTypeID v8 = *(const void **)(*((void *)&buf + 1) + 24LL);
  if (v8)
  {
    *(void *)(*((void *)&buf + 1) + 24LL) = 0LL;
    CFRelease(v8);
  }

  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&buf, 8);
  return v5;
}

BOOL sub_1001097A4(int8x16_t *a1, uint64_t a2)
{
  v6[0] = _NSConcreteStackBlock;
  int8x16_t v2 = vextq_s8(a1[2], a1[2], 8uLL);
  unsigned __int8 v3 = (CFTypeRef *)(*(void *)(a1[2].i64[0] + 8) + 24LL);
  v6[1] = 0x40000000LL;
  v6[2] = sub_100109818;
  v6[3] = &unk_1002870D8;
  int8x16_t v7 = v2;
  uint64_t v4 = a1[3].i64[0];
  uint64_t v8 = a2;
  uint64_t v9 = v4;
  return sub_100105354(a2, 2LL, v3, (uint64_t)v6);
}

uint64_t sub_100109818(int8x16_t *a1)
{
  int8x16_t v2 = &off_1002898F8;
  unsigned __int8 v3 = off_10028BA88;
  do
  {
    if (*((_BYTE *)v2 + 8))
    {
      uint64_t v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"DELETE FROM %@ WHERE agrp = ? AND clip = 1", *v2);
      uint64_t v6 = a1[2].i64[0];
      uint64_t v5 = a1[2].i64[1];
      int8x16_t v7 = (CFTypeRef *)(*(void *)(v5 + 8) + 24LL);
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 0x40000000LL;
      v14[2] = sub_100109934;
      v14[3] = &unk_1002870B0;
      v14[4] = v6;
      v14[5] = v5;
      int8x16_t v8 = a1[3];
      int8x16_t v15 = vextq_s8(v8, v8, 8uLL);
      unsigned __int8 v9 = sub_100015B70(v8.i64[0], v4, v7, (uint64_t)v14);
      uint64_t v10 = *(void *)(a1[2].i64[0] + 8);
      if (*(_BYTE *)(v10 + 24)) {
        unsigned __int8 v11 = v9;
      }
      else {
        unsigned __int8 v11 = 0;
      }
      *(_BYTE *)(v10 + 24) = v11;
      if (v4) {
        CFRelease(v4);
      }
    }

    uint64_t v12 = *v3++;
    int8x16_t v2 = v12;
  }

  while (v12);
  return *(unsigned __int8 *)(*(void *)(a1[2].i64[0] + 8) + 24LL);
}

uint64_t sub_100109934(uint64_t a1, sqlite3_stmt *a2)
{
  char v4 = sub_1000182E4( a2,  1LL,  *(const __CFString **)(a1 + 48),  (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL));
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if (*(_BYTE *)(v5 + 24)) {
    char v6 = v4;
  }
  else {
    char v6 = 0;
  }
  *(_BYTE *)(v5 + 24) = v6;
  uint64_t result = sub_100015CD8(*(void *)(a1 + 56), a2, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL), 0LL);
  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if (*(_BYTE *)(v8 + 24)) {
    char v9 = result;
  }
  else {
    char v9 = 0;
  }
  *(_BYTE *)(v8 + 24) = v9;
  return result;
}

BOOL sub_1001099B8(int8x16_t *a1, uint64_t a2)
{
  v6[0] = _NSConcreteStackBlock;
  int8x16_t v2 = vextq_s8(a1[2], a1[2], 8uLL);
  unsigned __int8 v3 = (CFTypeRef *)(*(void *)(a1[2].i64[0] + 8) + 24LL);
  v6[1] = 0x40000000LL;
  v6[2] = sub_100109A30;
  v6[3] = &unk_1002871B0;
  int8x16_t v7 = v2;
  uint64_t v4 = a1[3].i64[1];
  uint64_t v8 = a1[3].i64[0];
  uint64_t v9 = a2;
  uint64_t v10 = v4;
  return sub_100105354(a2, 2LL, v3, (uint64_t)v6);
}

uint64_t sub_100109A30(uint64_t a1)
{
  int8x16_t v2 = &off_1002898F8;
  unsigned __int8 v3 = off_10028BA88;
  do
  {
    if (*((_BYTE *)v2 + 8))
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), kSecClass, *v2);
      uint64_t v4 = *(const __CFDictionary **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
      if (qword_1002DEA80 != -1) {
        dispatch_once(&qword_1002DEA80, &stru_1002865A8);
      }
      uint64_t v5 = (CFDictionaryRef *)sub_1000F8790( v4,  (const void *)qword_1002DEA88,  -1LL,  0LL,  (__CFString **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL));
      if (v5)
      {
        char v6 = (const void **)v5;
        v20[0] = _NSConcreteStackBlock;
        int8x16_t v7 = vextq_s8(*(int8x16_t *)(a1 + 40), *(int8x16_t *)(a1 + 40), 8uLL);
        uint64_t v8 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
        v20[1] = 0x40000000LL;
        v20[2] = sub_100109C84;
        v20[3] = &unk_100287188;
        int8x16_t v9 = *(int8x16_t *)(a1 + 56);
        int8x16_t v21 = v7;
        int8x16_t v22 = vextq_s8(v9, v9, 8uLL);
        BOOL v10 = sub_1000EA68C(v5, v9.i64[0], v8, 0LL, &stru_100287140, 0LL, 0LL, (uint64_t)v20);
        uint64_t v11 = *(void *)(*(void *)(a1 + 48) + 8LL);
        if (*(_BYTE *)(v11 + 24)) {
          BOOL v12 = v10;
        }
        else {
          BOOL v12 = 0;
        }
        *(_BYTE *)(v11 + 24) = v12;
        sub_1000F8150(v6, 0LL);
      }

      else
      {
        uint64_t v13 = (os_log_s *)sub_10001267C("SecError");
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = (uint64_t)**(v3 - 1);
          uint64_t v15 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
          *(_DWORD *)__int128 buf = 138412546;
          uint64_t v24 = v14;
          __int16 v25 = 2112;
          uint64_t v26 = v15;
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "AppcClipPromotion: unable to create query for class %@: %@",  buf,  0x16u);
        }

        uint64_t v16 = *(void *)(*(void *)(a1 + 40) + 8LL);
        __int16 v17 = *(const void **)(v16 + 24);
        if (v17)
        {
          *(void *)(v16 + 24) = 0LL;
          CFRelease(v17);
        }
      }
    }

    int v18 = *v3++;
    int8x16_t v2 = v18;
  }

  while (v18);
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
}

void sub_100109C84(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  CFTypeRef cf = 0LL;
  if (!sub_1000E714C(a2, 1, (__CFString **)&cf)) {
    goto LABEL_13;
  }
  char v6 = sub_1000E9350(a2, *(const __CFDictionary **)(a1 + 48), (__CFString **)&cf);
  int8x16_t v7 = v6;
  if (cf || (sub_1000E985C((uint64_t)v6, (__CFString **)&cf), cf))
  {
LABEL_11:
    if (!v7) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }

  uint64_t v8 = *(void *)(a1 + 56);
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 0x40000000LL;
  v19[2] = sub_100109FAC;
  v19[3] = &unk_100287160;
  v19[4] = v7;
  if ((sub_1000EA178((uint64_t)v7, v8, (__CFString **)&cf, (uint64_t)v19) & 1) == 0)
  {
    if (!sub_1000EA124((__CFError *)cf))
    {
      int v10 = 0;
      goto LABEL_10;
    }

    CFTypeRef v9 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v9);
    }
  }

  int v10 = 1;
LABEL_10:
  uint64_t v11 = (os_log_s *)sub_10001267C("item");
  if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
    goto LABEL_11;
  }
  *(_DWORD *)__int128 buf = 67109120;
  int v22 = v10;
  _os_log_debug_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEBUG,  "SecServerPromoteAppClipItemsToParentApp SecDbItemInsertOrReplace %d",  buf,  8u);
  if (v7) {
LABEL_12:
  }
    CFRelease(v7);
LABEL_13:
  if (cf)
  {
    int Code = CFErrorGetCode((CFErrorRef)cf);
    if (Code == -25330 || Code == -26275)
    {
      uint64_t v14 = (os_log_s *)sub_10001267C("item");
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 67109379;
        int v22 = Code;
        __int16 v23 = 2113;
        uint64_t v24 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Unable (%i) to promote item: %{private}@",  buf,  0x12u);
      }
    }

    else
    {
      uint64_t v15 = (os_log_s *)sub_10001267C("item");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 67109379;
        int v22 = Code;
        __int16 v23 = 2113;
        uint64_t v24 = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Encountered error %i during promotion: %{private}@",  buf,  0x12u);
      }

      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
    }
  }

  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    CFTypeRef v17 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v17);
    }
  }

  else
  {
    *a3 = 1;
    if (cf)
    {
      uint64_t v18 = *(void *)(*(void *)(a1 + 40) + 8LL);
      if (!*(void *)(v18 + 24)) {
        *(void *)(v18 + 24) = cf;
      }
    }
  }

BOOL sub_100109F34(id a1, const SecDbAttr *a2)
{
  var0 = a2->var0;
  if (!a2->var0)
  {
    CFStringRef v5 = kSecAttrAccessGroup;
    return var0 == v5;
  }

  if (CFEqual(var0, @"clip")) {
    return 1;
  }
  var0 = a2->var0;
  CFStringRef v5 = kSecAttrAccessGroup;
  if (!a2->var0 || !kSecAttrAccessGroup) {
    return var0 == v5;
  }
  return CFEqual(var0, kSecAttrAccessGroup) != 0;
}

CFTypeRef sub_100109FAC(CFTypeRef result, uint64_t a2, void *a3)
{
  uint64_t v4 = *((void *)result + 4);
  if (v4) {
    uint64_t result = CFRetain(*((CFTypeRef *)result + 4));
  }
  *a3 = v4;
  return result;
}

__CFDictionary *sub_100109FDC(uint64_t a1, int *a2, unsigned int a3, __CFString **a4)
{
  __int128 v48 = 0u;
  __int128 v49 = 0u;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  __int128 cf = 0u;
  __int128 v43 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v37 = 0u;
  memset(v36, 0, sizeof(v36));
  CFDictionaryRef theDict = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!theDict)
  {
    if (a4 && !*a4) {
      sub_1000194E0(-108, a4, @"Can't create keychain dictionary");
    }
    CFStringRef v23 = 0LL;
    goto LABEL_51;
  }

  LODWORD(v37) = 11;
  *((void *)&v40 + 1) = -1LL;
  WORD4(v43) = 257;
  if (qword_1002DEA70 != -1) {
    dispatch_once(&qword_1002DEA70, &stru_100286568);
  }
  *(void *)&__int128 cf = qword_1002DEA78;
  CFRetain((CFTypeRef)qword_1002DEA78);
  if (a2)
  {
    CFStringRef v8 = sub_10010A5FC(*a2, 0LL);
  }

  else
  {
    memset(buf, 170, 16);
    int v24 = sub_100005BC0(0, buf);
    if (v24)
    {
      int v25 = v24;
      uint64_t v26 = (os_log_s *)sub_10001267C("SecError");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(void *)v51 = 67109376LL;
        *(_WORD *)&v51[8] = 1024;
        *(_DWORD *)&v51[10] = v25;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "keybag-uuid: could not determine backup keybag UUID for %d: %d",  v51,  0xEu);
      }

      CFStringRef v9 = 0LL;
      goto LABEL_7;
    }

    memset(v51, 0, 37);
    uuid_unparse_lower(buf, v51);
    CFStringRef v8 = CFStringCreateWithCString(0LL, v51, 0x8000100u);
  }

  CFStringRef v9 = v8;
LABEL_7:
  if (v9) {
    CFDictionarySetValue(theDict, @"keybag-uuid", v9);
  }
  CFStringRef v32 = v9;
  v54[0] = sub_10010C560((uint64_t)@"genp", &qword_1002DEB28, (uint64_t)&unk_1002DEB20);
  v54[1] = sub_10010C560((uint64_t)@"inet", &qword_1002DEB38, (uint64_t)&unk_1002DEB30);
  v54[2] = sub_10010C560((uint64_t)@"cert", &qword_1002DEB48, (uint64_t)&unk_1002DEB40);
  uint64_t v10 = 0LL;
  v54[3] = sub_10010C560((uint64_t)@"keys", &qword_1002DEB58, (uint64_t)&unk_1002DEB50);
  if (a2) {
    uint64_t v11 = a2;
  }
  else {
    uint64_t v11 = (int *)&unk_100205554;
  }
  BOOL v12 = "non-";
  if (a3 == 1) {
    BOOL v12 = "";
  }
  char v33 = v12;
  while (1)
  {
    *(void *)&v36[0] = v54[v10];
    unint64_t v52 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v53 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&v51[32] = 0xAAAAAAAAAAAAAAAALL;
    *(void *)v51 = v36;
    *(void *)&v51[8] = 0LL;
    *(void *)&v51[16] = a1;
    *(void *)&v51[24] = 0LL;
    int v13 = *v11;
    *(_DWORD *)&v51[32] = 0;
    LODWORD(v52) = v13;
    BYTE4(v52) = a2 == 0LL;
    LODWORD(v53) = a3;
    BYTE4(v53) = 0;
    uint64_t v14 = (os_log_s *)sub_10001267C("item");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = **(void **)&v36[0];
      *(_DWORD *)__int128 buf = 136315394;
      *(void *)&uint8_t buf[4] = v33;
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "exporting %ssysbound class '%@'", buf, 0x16u);
    }

    CFErrorRef err = 0LL;
    uint64_t v16 = (os_log_s *)sub_10001267C("item");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = **(void **)&v36[0];
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "exporting class '%@' complete", buf, 0xCu);
    }

    if (CFArrayGetCount(*(CFArrayRef *)&v51[24]))
    {
      uint64_t v18 = **(const __CFString ***)&v36[0];
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)&v51[24]);
      if (CFStringGetLength(v18) == 4)
      {
        memset(buf, 170, 5);
      }

      CFDictionaryAddValue(theDict, **(const void ***)&v36[0], *(const void **)&v51[24]);
    }

CFStringRef sub_10010A5FC(int a1, uint64_t a2)
{
  *(void *)&__int128 v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  if (a2)
  {
    uuid_copy((unsigned __int8 *)&v7, (const unsigned __int8 *)(a2 + 32));
LABEL_3:
    memset(out, 0, sizeof(out));
    uuid_unparse_lower((const unsigned __int8 *)&v7, out);
    return CFStringCreateWithCString(0LL, out, 0x8000100u);
  }

  int v4 = sub_1000052A0(a1, &v7);
  if (!v4) {
    goto LABEL_3;
  }
  int v5 = v4;
  char v6 = (os_log_s *)sub_10001267C("SecError");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uuid_string_t out = 67109376;
    *(_DWORD *)&out[4] = a1;
    *(_WORD *)&out[8] = 1024;
    *(_DWORD *)&out[10] = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "keybag-uuid: could not determine keybag UUID for %d: %d",  (uint8_t *)out,  0xEu);
  }

  return 0LL;
}

void sub_10010A70C(sqlite3_stmt *a1, uint64_t a2)
{
  int v4 = *(CFTypeRef **)a2;
  __int128 v64 = 0LL;
  CFTypeRef cf = 0LL;
  sqlite3_int64 v5 = sqlite3_column_int64(a1, 0);
  CFDictionaryRef theDict = 0LL;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  int v62 = 0;
  int v7 = sub_100107910(a1, (uint64_t)v4, 1, *(const __CFArray **)(a2 + 8), &theDict, &cf, &v62, &v64);
  MutableCFDictionaryRef Copy = 0LL;
  if (v7)
  {
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(0LL, 0LL, theDict);
    uint64_t v9 = *((void *)*v4 + 2);
    if (v9)
    {
      uint64_t v10 = (uint64_t *)((char *)*v4 + 24);
      do
      {
        if ((*(_BYTE *)(v9 + 16) & 0x20) != 0)
        {
          uint64_t v11 = CFDictionaryGetValue(MutableCopy, *(const void **)v9);
          if (v11)
          {
            CFDictionarySetValue(Mutable, *(const void **)v9, v11);
            CFDictionaryRemoveValue(MutableCopy, *(const void **)v9);
          }
        }

        uint64_t v12 = *v10++;
        uint64_t v9 = v12;
      }

      while (v12);
    }
  }

  if (!cf)
  {
    BOOL v15 = (v62 & 0x1F) == 12;
    goto LABEL_14;
  }

  CFStringRef Protection = (CFStringRef)SecAccessControlGetProtection(cf);
  if (!Protection || !kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly)
  {
    BOOL v15 = Protection == kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly;
LABEL_14:
    BOOL v14 = v15;
    goto LABEL_17;
  }

  BOOL v14 = CFEqual(Protection, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly) != 0;
LABEL_17:
  if (theDict) {
    int v16 = v7;
  }
  else {
    int v16 = 0;
  }
  if (v16 == 1) {
    int v17 = CFDictionaryContainsKey(theDict, kSecAttrTokenID);
  }
  else {
    int v17 = 0;
  }
  if (v17) {
    int v18 = 1;
  }
  else {
    int v18 = v14;
  }
  BOOL v19 = v18 == 1 && *(_DWORD *)(a2 + 48) == 2;
  uint64_t v20 = theDict;
  if (theDict) {
    int v21 = v7;
  }
  else {
    int v21 = 0;
  }
  if (v21 != 1 || v19)
  {
    if ((v21 & 1) != 0)
    {
      uint64_t v26 = (os_log_s *)sub_10001267C("item");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 134218240;
        *(void *)v67 = v5;
        *(_WORD *)&v67[8] = 1024;
        *(_DWORD *)&v67[10] = v19;
        _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "export rowid %llu skipped. akpu/token: %i",  buf,  0x12u);
      }

      goto LABEL_83;
    }

    int OSStatus = SecErrorGetOSStatus(v64);
    if (OSStatus == -25308 && v14)
    {
      if (!v19)
      {
        uint64_t v29 = (os_log_s *)sub_10001267C("SecError");
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          int v30 = *(_DWORD *)(a2 + 48);
          *(_DWORD *)__int128 buf = 67109378;
          *(_DWORD *)v67 = v30;
          *(_WORD *)&v67[4] = 2112;
          *(void *)&v67[6] = v64;
          _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "Encountered akpu item we cannot export (filter %d), skipping. %@",  buf,  0x12u);
        }

        if (sqlite3_column_count(a1) >= 3)
        {
          char v31 = sqlite3_column_text(a1, 2);
          CFStringRef v32 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v31, 0x8000100u);
          if (v32)
          {
            CFStringRef v40 = v32;
            CFDictionaryRef v41 = sub_100107FA8(0LL, v33, v34, v35, v36, v37, v38, v39, (uint64_t)@"agrp", (uint64_t)v32);
            SecABCTrigger(@"keychain", @"invalid-akpu+sysbound", 0LL, v41);
            if (v41) {
              CFRelease(v41);
            }
            CFRelease(v40);
          }
        }
      }
    }

    else
    {
      int v52 = OSStatus;
      unint64_t v53 = (os_log_s *)sub_10001267C("item");
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 134218242;
        *(void *)v67 = v5;
        *(_WORD *)&v67[8] = 2112;
        *(void *)&v67[10] = v64;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_DEBUG,  "Could not export item for rowid %llu: %@",  buf,  0x16u);
      }

      if (v52 != -26275)
      {
        v60 = v4[5];
        if (v60) {
          CFRelease(v60);
        }
        v4[5] = v64;
        goto LABEL_83;
      }
    }

    v54 = v64;
    if (!v64) {
      goto LABEL_83;
    }
    __int128 v64 = 0LL;
    goto LABEL_82;
  }

  int v22 = *(_DWORD *)(a2 + 48);
  if (v22)
  {
    uint64_t v20 = theDict;
  }

  CFStringRef v23 = (const __CFData *)CFDictionaryGetValue(v20, kSecAttrPersistentReference);
  if (v23 && (int v24 = v23, CFDataGetLength(v23) == 16))
  {
    uint64_t UUIDBasedPersistentRef = _SecItemCreateUUIDBasedPersistentRef(*(void *)*v4, v24, theDict);
  }

  else
  {
    char v42 = (os_log_s *)sub_10001267C("pref");
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      *(void *)v67 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "s3dl_export_row: Creating old persistent ref for %llu",  buf,  0xCu);
    }

    uint64_t UUIDBasedPersistentRef = _SecItemCreatePersistentRef(*(void *)*v4, v5, theDict);
  }

  __int128 v43 = (__CFString *)UUIDBasedPersistentRef;
  if (UUIDBasedPersistentRef)
  {
    if (*(_DWORD *)(a2 + 40) != -1)
    {
      __int128 v44 = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      uint64_t v45 = *((void *)*v4 + 2);
      if (v45)
      {
        __int128 v46 = (uint64_t *)((char *)*v4 + 24);
        do
        {
          if ((*(_BYTE *)(v45 + 17) & 0x20) != 0)
          {
            __int128 v47 = CFDictionaryGetValue(MutableCopy, *(const void **)v45);
            if (v47)
            {
              CFDictionaryAddValue(v44, *(const void **)v45, v47);
              CFDictionaryRemoveValue(MutableCopy, *(const void **)v45);
            }
          }

          uint64_t v48 = *v46++;
          uint64_t v45 = v48;
        }

        while (v48);
      }

      value = 0LL;
      __int128 v49 = (void **)(v4 + 5);
      BOOL v50 = sub_1000F1D54( (const __CFData *)*(unsigned int *)(a2 + 40),  (uint64_t)cf,  (const __CFData *)v4[18],  Mutable,  MutableCopy,  v44,  (__CFData **)&value,  0,  *(_BYTE *)(a2 + 44),  v4 + 5);
      CFDictionaryRemoveAllValues(theDict);
      CFRelease(v44);
      if (v50)
      {
        v51 = value;
        CFDictionarySetValue(theDict, kSecValueData, value);
        if (!v51) {
          goto LABEL_79;
        }
      }

      else
      {
        v55 = (os_log_s *)sub_10001267C("SecCritical");
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v56 = *(void *)*v4;
          v57 = v4[5];
          *(_DWORD *)__int128 buf = 138412802;
          *(void *)v67 = v56;
          *(_WORD *)&v67[8] = 2048;
          *(void *)&v67[10] = v5;
          __int16 v68 = 2112;
          v69 = v57;
          _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_DEFAULT,  "ks_encrypt_data %@,rowid=%lld: failed: %@",  buf,  0x20u);
        }

        v51 = *v49;
        if (!*v49) {
          goto LABEL_79;
        }
        *__int128 v49 = 0LL;
      }

      CFRelease(v51);
    }

LABEL_79:
    if (CFDictionaryGetCount(theDict))
    {
      CFDictionarySetValue(theDict, kSecValuePersistentRef, v43);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 24), theDict);
      ++*(_DWORD *)(a2 + 32);
    }

    v54 = v43;
LABEL_82:
    CFRelease(v54);
  }

    CFStringRef v32 = 0;
LABEL_56:
    int v24 = v112;
LABEL_57:
    v76 = v109;
    v75 = v110;
    v77 = v108;
    goto LABEL_58;
  }

  v80 = v79;
  v81 = *(void *)v122;
  v107 = v31;
LABEL_61:
  v82 = 0LL;
  while (1)
  {
    if (*(void *)v122 != v81) {
      objc_enumerationMutation(v31);
    }
    v83 = *(void **)(*((void *)&v121 + 1) + 8 * v82);
    v84 = (void *)objc_claimAutoreleasedReturnValue([v83 senderPeerID]);

LABEL_69:
    if (v80 == (id)++v82)
    {
      v80 = -[os_log_s countByEnumeratingWithState:objects:count:]( v31,  "countByEnumeratingWithState:objects:count:",  &v121,  v140,  16LL);
      if (v80) {
        goto LABEL_61;
      }
      goto LABEL_71;
    }
  }

  v85 = (void *)objc_claimAutoreleasedReturnValue([v83 storedCKRecord]);
  v86 = (void *)objc_claimAutoreleasedReturnValue([v85 modificationDate]);
  v87 = v80;
  v88 = v81;
  v89 = [v86 compare:v116];

  v90 = v89 == (id)1;
  v81 = v88;
  v80 = v87;
  char v31 = v107;
  if (!v90) {
    goto LABEL_69;
  }
  v99 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView zoneName](self, "zoneName"));
  v100 = sub_1000AA6AC(@"ckkskey", v99);
  v71 = (os_log_s *)objc_claimAutoreleasedReturnValue(v100);

  if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412290;
    v142 = (os_log_s *)v83;
    v102 = "Trusted TLK Share (%@) created recently; other devices have keys and should send them to us";
    goto LABEL_84;
  }

  __int128 v46 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  self->_timestampRequestEnd));
  [v3 setObject:v46 forKey:@"timestamp_request_end"];

  BOOL v19 = self->_has;
  if ((*(_WORD *)&v19 & 0x2000) == 0)
  {
LABEL_42:
    if ((*(_WORD *)&v19 & 0x1000) == 0) {
      goto LABEL_44;
    }
    goto LABEL_43;
  }

  PBDataWriterWriteUint64Field(v20, self->_timestampRequestEnd, 210LL);
  BOOL v14 = self->_has;
  if ((*(_WORD *)&v14 & 0x2000) == 0)
  {
LABEL_42:
    if ((*(_WORD *)&v14 & 0x1000) == 0) {
      goto LABEL_44;
    }
    goto LABEL_43;
  }

  v4[11] = self->_timestampRequestEnd;
  *((_DWORD *)v4 + 70) |= 0x400u;
  int v7 = self->_has;
  if ((*(_WORD *)&v7 & 0x2000) == 0)
  {
LABEL_42:
    if ((*(_WORD *)&v7 & 0x1000) == 0) {
      goto LABEL_44;
    }
    goto LABEL_43;
  }

  self->_timestampTcpStart = v5[17];
  *(_DWORD *)&self->_has |= 0x10000u;
  uint64_t v10 = *((_DWORD *)v5 + 70);
  if ((v10 & 0x8000) == 0)
  {
LABEL_50:
    if ((v10 & 0x4000) == 0) {
      goto LABEL_51;
    }
    goto LABEL_81;
  }

BOOL sub_10010ADD4( uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, const __CFDictionary *a6, int a7, int a8, __CFString **a9)
{
  int v16 = (CFTypeRef *)a9;
  if (a7 == 2)
  {
    LODWORD(buf) = -1;
    BOOL v17 = 1LL;
    int v18 = sub_100109FDC(a1, (int *)&buf, 1u, a9);
    if (!v18) {
      return v17;
    }
  }

  else
  {
    int v18 = 0LL;
  }

  __int128 v47 = (const void *)a1;
  CFStringRef v19 = sub_10010A5FC(a3, a4);
  if (!v19) {
    goto LABEL_10;
  }
  Value = CFDictionaryGetValue(a6, @"keybag-uuid");
  if (!Value) {
    goto LABEL_10;
  }
  int v21 = Value;
  int v22 = a6;
  CFStringRef v23 = v19;
  CFTypeID v24 = CFGetTypeID(Value);
  BOOL v25 = v24 == CFStringGetTypeID();
  CFStringRef v19 = v23;
  a6 = v22;
  int v16 = (CFTypeRef *)a9;
  if (!v25 || CFEqual(v19, v21))
  {
LABEL_10:
    if (a8)
    {
      uint64_t v26 = (os_log_s *)sub_10001267C("SecWarning");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "SecServerDeleteAll", (uint8_t *)&buf, 2u);
      }

      *(void *)&__int128 buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 0x40000000LL;
      uint64_t v62 = (uint64_t)sub_10010B310;
      v63[0] = &unk_100287348;
      CFErrorRef v27 = v47;
      v63[1] = v47;
      v63[2] = v16;
      if (!sub_100105354((uint64_t)v47, 2LL, v16, (uint64_t)&buf))
      {
        BOOL v17 = 0LL;
        if (!v18) {
          goto LABEL_43;
        }
LABEL_42:
        CFRelease(v18);
        goto LABEL_43;
      }

uint64_t sub_10010B310(uint64_t a1)
{
  {
    return sub_100014F28(*(void *)(a1 + 32), @"DELETE from keys;", *(CFTypeRef **)(a1 + 40));
  }

  else
  {
    return 0LL;
  }

uint64_t sub_10010B388(uint64_t a1)
{
  int v2 = sub_100014F28( *(void *)(a1 + 40),  @"DELETE FROM genp WHERE sync = 0 AND NOT agrp IN ('com.apple.security.sos', 'com.apple.security.sos-usercredential', 'com.apple.security.ckks', 'com.apple.security.egoIdentities', 'com.apple.security.octagon') AND NOT ggrp <> '';",
         (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
  int v3 = v2 & sub_100014F28( *(void *)(a1 + 40),  @"DELETE FROM inet WHERE sync = 0 AND NOT agrp IN ('com.apple.security.sos', 'com.apple.security.sos-usercredential', 'com.apple.security.ckks', 'com.apple.security.egoIdentities', 'com.apple.security.octagon') AND NOT ggrp <> '';",
              (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
  int v4 = sub_100014F28( *(void *)(a1 + 40),  @"DELETE FROM cert WHERE sync = 0 AND NOT agrp IN ('com.apple.security.sos', 'com.apple.security.sos-usercredential', 'com.apple.security.ckks', 'com.apple.security.egoIdentities', 'com.apple.security.octagon') AND NOT ggrp <> '';",
         (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
  return v3 & v4 & sub_100014F28( *(void *)(a1 + 40),  @"DELETE FROM keys WHERE sync = 0 AND NOT agrp IN ('com.apple.security.sos', 'com.apple.security.sos-usercredential', 'com.apple.security.ckks', 'com.apple.security.egoIdentities', 'com.apple.security.octagon') AND NOT ggrp <> '';",
                                   (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
}

void sub_10010B424(CFTypeRef cf, const void *a2, uint64_t a3)
{
  int v3 = (__CFString **)(a3 + 8);
  if (*(void *)(a3 + 8)) {
    return;
  }
  if (!cf)
  {
    sub_1000194E0(-50, v3, @"class name %@ is not a string", 0LL);
    return;
  }

  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 != CFStringGetTypeID())
  {
    sub_1000194E0(-50, v3, @"class name %@ is not a string", cf);
    return;
  }

  if (CFEqual(cf, @"keybag-uuid")) {
    return;
  }
  CFStringRef v8 = sub_1000F77E0(cf);
  if (!v8)
  {
    int v16 = (os_log_s *)sub_10001267C("SecWarning");
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)__int128 buf = 138412290;
    uint64_t v28 = (uint64_t)cf;
    BOOL v17 = "Ignoring unknown key class '%@'";
    int v18 = v16;
    uint32_t v19 = 12;
    goto LABEL_26;
  }

  uint64_t v9 = (const __CFString **)v8;
  if (v8 == &off_10028B168)
  {
    sub_1000194E0(-50, v3, @"attempt to import an identity");
    return;
  }

  context[0] = (uint64_t)v8;
  context[1] = a3;
  if (a2)
  {
    CFTypeID v10 = CFGetTypeID(a2);
    if (v10 == CFArrayGetTypeID())
    {
      uint64_t v11 = (os_log_s *)sub_10001267C("SecWarning");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        CFIndex Count = CFArrayGetCount((CFArrayRef)a2);
        int v13 = *(_DWORD *)(a3 + 48);
        *(_DWORD *)__int128 buf = 134218498;
        uint64_t v28 = Count;
        __int16 v29 = 2112;
        CFTypeRef v30 = cf;
        __int16 v31 = 1024;
        int v32 = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Import %ld items of class %@ (filter %d)",  buf,  0x1Cu);
      }

      BOOL v14 = *v9;
      CFIndex v15 = CFArrayGetCount((CFArrayRef)a2);
      sub_10010B770(v14, v15, *(_DWORD *)(a3 + 48));
      v33.length = CFArrayGetCount((CFArrayRef)a2);
      v33.location = 0LL;
      CFArrayApplyFunction((CFArrayRef)a2, v33, (CFArrayApplierFunction)sub_10010B7F4, context);
      return;
    }

    CFTypeID v21 = CFGetTypeID(a2);
    BOOL v20 = v21 == CFDictionaryGetTypeID();
  }

  else
  {
    BOOL v20 = 0;
  }

  int v22 = (os_log_s *)sub_10001267C("SecWarning");
  BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
  if (!v20)
  {
    if (!v23) {
      return;
    }
    int v25 = *(_DWORD *)(a3 + 48);
    *(_DWORD *)__int128 buf = 138412546;
    uint64_t v28 = (uint64_t)cf;
    __int16 v29 = 1024;
    LODWORD(v30) = v25;
    BOOL v17 = "Unknown value type for class %@ (filter %d)";
    int v18 = v22;
    uint32_t v19 = 18;
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v17, buf, v19);
    return;
  }

  if (v23)
  {
    int v24 = *(_DWORD *)(a3 + 48);
    *(_DWORD *)__int128 buf = 134218498;
    uint64_t v28 = 1LL;
    __int16 v29 = 2112;
    CFTypeRef v30 = cf;
    __int16 v31 = 1024;
    int v32 = v24;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Import %ld items of class %@ (filter %d)",  buf,  0x1Cu);
  }

  sub_10010B770(*v9, 1LL, *(_DWORD *)(a3 + 48));
  sub_10010B7F4(a2, context);
}

uint64_t sub_10010B770(const __CFString *a1, uint64_t a2, unsigned int a3)
{
  uint64_t result = CFStringGetLength(a1);
  if (result == 4)
  {
    memset(buffer, 170, 5);
    uint64_t result = CFStringGetCString(a1, buffer, 5LL, 0x8000100u);
    if ((_DWORD)result) {
      return kdebug_trace(726810632LL, *(unsigned int *)buffer, a2, a3, 0LL);
    }
  }

  return result;
}

void sub_10010B7F4(CFTypeRef cf, uint64_t *a2)
{
  uint64_t v3 = a2[1];
  uint64_t v5 = *(void *)(v3 + 8);
  int v4 = (__CFString **)(v3 + 8);
  if (v5) {
    return;
  }
  if (!cf)
  {
    sub_1000194E0(-50, v4, @"value %@ is not a dictionary", 0LL);
    return;
  }

  CFTypeID v7 = CFGetTypeID(cf);
  CFTypeID TypeID = CFDictionaryGetTypeID();
  uint64_t v9 = a2[1];
  if (v7 != TypeID)
  {
    sub_1000194E0(-50, (__CFString **)(v9 + 8), @"value %@ is not a dictionary", cf);
    return;
  }

  int v10 = *(_DWORD *)(v9 + 16);
  uint64_t v11 = *(void *)(v9 + 24);
  uint64_t v12 = (void *)*a2;
  int v13 = *(_DWORD *)(v9 + 32);
  BOOL v14 = (__CFString **)(v9 + 8);
  if (v10 == -1 && v11 == 0)
  {
    int v18 = (const __CFDictionary **)sub_1000E8E18( *a2,  (const __CFDictionary *)cf,  *(_DWORD *)(v9 + 32),  (__CFString **)(v9 + 8));
    if (v18) {
      goto LABEL_16;
    }
  }

  else
  {
    Value = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)cf, @"v_Data");
    if (!Value)
    {
      sub_1000194E0(-26275, v14, @"No v_Data in backup dictionary %@", cf);
LABEL_49:
      int v18 = 0LL;
      goto LABEL_50;
    }

    BOOL v17 = (const __CFDictionary **)sub_1000E92D4(kCFAllocatorDefault, v12, Value, v10, v11, v14);
    int v18 = v17;
    if (v17)
    {
LABEL_16:
      if (!sub_1000E714C((uint64_t)v18, 1, (__CFString **)(a2[1] + 8)))
      {
LABEL_48:
        CFRelease(v18);
        goto LABEL_49;
      }

      uint32_t v19 = v18[6];
      if (!v19) {
        goto LABEL_37;
      }
      if (*(_DWORD *)(a2[1] + 48) == 2)
      {
        if (sub_100108D04(v19, *a2, 0) || CFDictionaryContainsKey(v18[6], kSecAttrTokenID))
        {
          CFRelease(v18);
          return;
        }

        uint32_t v19 = v18[6];
        if (!v19)
        {
LABEL_37:
          uint64_t v22 = a2[1];
          if (*(_DWORD *)(v22 + 48) != 1) {
            sub_1000F3EFC((uint64_t)v18, (CFDictionaryRef)cf, (__CFString **)(v22 + 8));
          }
          CFTypeRef cfa = 0LL;
          BOOL v23 = (const __CFData *)sub_1000E9614((void **)v18, (__CFString **)&cfa);
          if (cfa)
          {
            int v24 = (os_log_s *)sub_10001267C("SecError");
            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 138412290;
              *(void *)&uint8_t buf[4] = cfa;
              _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "import: failed to get the persistent ref: %@",  buf,  0xCu);
            }

            CFTypeRef v25 = cfa;
            if (cfa)
            {
              CFTypeRef cfa = 0LL;
              CFRelease(v25);
            }
          }

          if (v23 && CFDataGetLength(v23) == 16)
          {
            uint64_t v26 = (os_log_s *)sub_10001267C("import");
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 138477827;
              *(void *)&uint8_t buf[4] = v18;
              _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Item already has a UUID persistent ref set: %{private}@",  buf,  0xCu);
            }
          }

          else
          {
            int v34 = CFUUIDCreate(kCFAllocatorDefault);
            CFUUIDBytes bytes = CFUUIDGetUUIDBytes(v34);
            int v35 = CFDataCreate(kCFAllocatorDefault, &bytes.byte0, 16LL);
            CFTypeRef v59 = 0LL;
            sub_1000E96B4((uint64_t)v18, v35, (__CFString **)&v59);
            int v36 = (os_log_s *)sub_10001267C("import");
            if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 138478083;
              *(void *)&uint8_t buf[4] = v18;
              *(_WORD *)&buf[12] = 2112;
              *(void *)&buf[14] = v59;
              _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "SecServerImportItem: generated a new persistentref UUID for item %{private}@: %@",  buf,  0x16u);
            }

            if (v34) {
              CFRelease(v34);
            }
            if (v35) {
              CFRelease(v35);
            }
            CFTypeRef v37 = v59;
            if (v59)
            {
              CFTypeRef v59 = 0LL;
              CFRelease(v37);
            }
          }

          uint64_t v38 = a2[1];
          CFIndex v39 = (const __CFString *)sub_1000E7EC0(v18, kSecAttrSharingGroup);
          if (!v39 || (CFTypeRef v40 = v39, v41 = CFGetTypeID(v39), v41 != CFStringGetTypeID()) || !CFStringGetLength(v40))
          {
            id v42 = sub_1000E7EC0(v18, kSecAttrAccessGroup);
            if (v42)
            {
              __int128 v43 = v42;
              CFTypeID v44 = CFGetTypeID(v42);
              if (v44 == CFStringGetTypeID())
              {
                if (CFEqual(v43, @"com.apple.cfnetwork"))
                {
                  uint64_t v45 = v18[2];
                  if (v45 == (const __CFDictionary *)sub_10010C560( (uint64_t)@"inet",  &qword_1002DEB38,  (uint64_t)&unk_1002DEB30))
                  {
                    int v50 = sub_1000E7EC0(v18, kSecAttrServer);
                    int v51 = sub_1000E7EC0(v18, kSecAttrProtocol);
                    uint64_t v52 = sub_1000E7EC0(v18, kSecAttrAuthenticationType);
                    if (v50)
                    {
                      int v53 = v52;
                      CFTypeID v54 = CFGetTypeID(v50);
                      if (v54 == CFStringGetTypeID())
                      {
                        if (v51)
                        {
                          CFTypeID v55 = CFGetTypeID(v51);
                          if (v55 == CFStringGetTypeID())
                          {
                            if (v53)
                            {
                              CFTypeID v56 = CFGetTypeID(v53);
                              if (v56 == CFStringGetTypeID())
                              {
                                int v57 = sub_10001267C("item");
                                CFTypeRef v58 = (os_log_s *)objc_claimAutoreleasedReturnValue(v57);
                                if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
                                {
                                  *(_DWORD *)__int128 buf = 138477827;
                                  *(void *)&uint8_t buf[4] = v18;
                                  _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_DEFAULT,  "Make this item syncable: %{private}@",  buf,  0xCu);
                                }

                                sub_1000E99D0((uint64_t)v18, (__CFString **)(v38 + 8));
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          uint64_t v46 = a2[1];
          uint64_t v47 = *(void *)v46;
          *(void *)__int128 buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 0x40000000LL;
          *(void *)&buf[16] = sub_1000EBBC4;
          v63 = &unk_100285F88;
          __int128 v64 = v18;
          __int16 v65 = 256;
          if ((sub_1000EA178((uint64_t)v18, v47, (__CFString **)(v46 + 8), (uint64_t)buf) & 1) == 0)
          {
            sub_1000E985C((uint64_t)v18, 0LL);
            uint64_t v48 = a2[1];
            uint64_t v49 = *(void *)v48;
            *(void *)__int128 buf = _NSConcreteStackBlock;
            *(void *)&uint8_t buf[8] = 0x40000000LL;
            *(void *)&buf[16] = sub_1000EBBC4;
            v63 = &unk_100285F88;
            __int128 v64 = v18;
            __int16 v65 = 256;
            sub_1000EA178((uint64_t)v18, v49, (__CFString **)(v48 + 8), (uint64_t)buf);
          }

          char v27 = 0;
          goto LABEL_51;
        }
      }

      BOOL v20 = CFDictionaryGetValue(v19, kSecAttrMultiUser);
      if (qword_1002DEA60 != -1) {
        dispatch_once(&qword_1002DEA60, &stru_100286528);
      }
      if (v20 && qword_1002DEA68)
      {
        if (CFEqual(v20, (CFTypeRef)qword_1002DEA68)) {
          goto LABEL_29;
        }
      }

      else if (v20 == (const void *)qword_1002DEA68)
      {
LABEL_29:
        CFTypeID v21 = CFDataCreateWithBytesNoCopy(0LL, byte_100205530, 16LL, kCFAllocatorNull);
        if (!v21) {
          goto LABEL_48;
        }
        goto LABEL_36;
      }

      if (qword_1002DEA70 != -1) {
        dispatch_once(&qword_1002DEA70, &stru_100286568);
      }
      CFTypeID v21 = (const __CFData *)qword_1002DEA78;
      if (!qword_1002DEA78) {
        goto LABEL_48;
      }
      CFRetain((CFTypeRef)qword_1002DEA78);
LABEL_36:
      sub_1000E8AF8((uint64_t)v18, @"musr", v21, (__CFString **)(a2[1] + 8));
      CFRelease(v21);
      goto LABEL_37;
    }
  }

BOOL sub_10010C008(const void *a1, int a2)
{
  CFErrorRef err = 0LL;
  cf[1] = 0LL;
  __int128 v16 = 0u;
  __int128 v14 = 0u;
  cf[0] = a1;
  DWORD2(v16) = a2;
  v20[0] = sub_10010C560((uint64_t)@"genp", &qword_1002DEB28, (uint64_t)&unk_1002DEB20);
  v20[1] = sub_10010C560((uint64_t)@"inet", &qword_1002DEB38, (uint64_t)&unk_1002DEB30);
  v20[2] = sub_10010C560((uint64_t)@"keys", &qword_1002DEB58, (uint64_t)&unk_1002DEB50);
  BOOL v2 = 0;
  unint64_t v3 = 0LL;
  v20[3] = sub_10010C560((uint64_t)@"cert", &qword_1002DEB48, (uint64_t)&unk_1002DEB40);
  do
  {
    int v4 = (uint64_t *)v20[v3];
    uint64_t v5 = (const void **)sub_1000F82CC((uint64_t)v4, 0LL, 0LL, 0LL, (__CFString **)&err);
    if (!v5) {
      break;
    }
    char v6 = v5;
    *(void *)&__int128 v14 = v5;
    v5[13] = (const void *)-1LL;
    BOOL v7 = sub_100107624((uint64_t)sub_10010C224, (uint64_t)&v14, (__CFString **)&err);
    sub_1000F8150(v6, 0LL);
    CFTypeRef v8 = cf[1];
    if (cf[1])
    {
      cf[1] = 0LL;
      CFRelease(v8);
    }

    if (err) {
      char v9 = v7;
    }
    else {
      char v9 = 1;
    }
    if ((v9 & 1) != 0 || CFErrorGetCode(err) != -25300)
    {
      uint64_t v11 = (os_log_s *)sub_10001267C("SecError");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = *v4;
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v19 = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Class %@ not up to date", buf, 0xCu);
      }

      return v2;
    }

    CFErrorRef v10 = err;
    if (err)
    {
      CFErrorRef err = 0LL;
      CFRelease(v10);
    }

    BOOL v2 = v3++ > 2;
  }

  while (v3 != 4);
  return v2;
}

void sub_10010C224(sqlite3_stmt *a1, _DWORD *a2)
{
  int v3 = a2[10];
  int v4 = sub_100107BA0(a1, 1);
  if (v4)
  {
    uint64_t v5 = v4;
    unint64_t Length = CFDataGetLength(v4);
    BytePtr = CFDataGetBytePtr(v5);
    if (Length >= 8)
    {
      if ((v3 == 0) != *((_DWORD *)BytePtr + 1) > 0x1Fu)
      {
LABEL_6:
        CFRelease(v5);
        return;
      }
    }

    else
    {
      sub_1000194E0(-26275, (__CFString **)(*(void *)a2 + 40LL), @"check_generation: Check for underflow");
    }

    ++a2[8];
    goto LABEL_6;
  }

  ++a2[8];
}

void sub_10010C2D8(uint64_t a1, _BYTE *a2)
{
  uint64_t v9 = 0LL;
  CFErrorRef v10 = &v9;
  uint64_t v11 = 0x2000000000LL;
  char v12 = 0;
  int v8 = -1431655766;
  if (!sub_1000060EC(0, 0, &v8) && (v8 & 2) != 0)
  {
    uint64_t v5 = *(CFTypeRef **)(a1 + 32);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000LL;
    v6[2] = sub_10010C3CC;
    v6[3] = &unk_100287228;
    void v6[4] = &v9;
    __int128 v7 = *(_OWORD *)(a1 + 40);
    int v4 = sub_10001B930(0, v5, (uint64_t)v6);
    if (v4) {
      LOBYTE(v4) = *((_BYTE *)v10 + 24);
    }
    else {
      *((_BYTE *)v10 + 24) = 0;
    }
  }

  else
  {
    LOBYTE(v4) = sub_1000194E0(-909, *(__CFString ***)(a1 + 32), @"No key roll in progress.");
    *((_BYTE *)v10 + 24) = v4;
  }

  *a2 = v4;
  _Block_object_dispose(&v9, 8);
}

void sub_10010C3CC(void *a1)
{
  CFTypeRef cf = 0LL;
  int v8 = -1;
  BOOL v2 = sub_100109FDC(a1[5], &v8, 0, (__CFString **)&cf);
  if (v2)
  {
    int v3 = v2;
    if (cf)
    {
      int v4 = (os_log_s *)sub_10001267C("SecError");
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFTypeRef v11 = cf;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Ignoring export error: %@ during roll export",  buf,  0xCu);
      }

      CFTypeRef v5 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
        CFRelease(v5);
      }
    }

    *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = sub_10010ADD4(a1[5], a1[6], -1, 0LL, 0, v3, 0, 1, (__CFString **)&cf);
    if (cf)
    {
      char v6 = (os_log_s *)sub_10001267C("SecError");
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFTypeRef v11 = cf;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Ignoring export error: %@ during roll export",  buf,  0xCu);
      }

      CFTypeRef v7 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
        CFRelease(v7);
      }
    }

    CFRelease(v3);
  }

uint64_t sub_10010C560(uint64_t a1, dispatch_once_t *predicate, uint64_t a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = sub_10010C5D8;
  v5[3] = &unk_10028EF68;
  v5[4] = a3;
  v5[5] = a1;
  if (*predicate != -1) {
    dispatch_once(predicate, v5);
  }
  return *(void *)a3;
}

const void *sub_10010C5D8(uint64_t a1)
{
  BOOL v2 = *(const void **)(a1 + 40);
  int v3 = off_10028BA80;
  int v4 = (const void **)&off_1002898F8;
  while (1)
  {
    uint64_t result = *v4;
    if (!v2 || !result)
    {
      if (result == v2) {
        goto LABEL_8;
      }
      goto LABEL_7;
    }

    uint64_t result = (const void *)CFEqual(result, v2);
    if ((_DWORD)result) {
      break;
    }
LABEL_7:
    char v6 = (const void **)v3[1];
    ++v3;
    int v4 = v6;
    if (!v6) {
      goto LABEL_8;
    }
  }

  int v4 = (const void **)*v3;
LABEL_8:
  **(void **)(a1 + 32) = v4;
  return result;
}

void sub_10010C64C(id a1)
{
  byte_1002DDD08 = _os_feature_enabled_impl("Security", "EnableSecureObjectSync");
  CFTypeID v1 = sub_10001267C("octagon");
  BOOL v2 = (os_log_s *)objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1002DDD08) {
      int v3 = @"enabled";
    }
    else {
      int v3 = @"disabled";
    }
    int v4 = 138412290;
    CFTypeRef v5 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "SOS Feature is %@ (via feature flags)",  (uint8_t *)&v4,  0xCu);
  }
}

void sub_10010C728(id a1)
{
  byte_1002DEB68 = _os_feature_enabled_impl("Security", "OctagonSupportsPersonaMultiuser");
  CFTypeID v1 = sub_10001267C("octagon");
  BOOL v2 = (os_log_s *)objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1002DEB68) {
      int v3 = "enabled";
    }
    else {
      int v3 = "disabled";
    }
    int v4 = 136315138;
    CFTypeRef v5 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "OctagonSupportsMultiuser is %s",  (uint8_t *)&v4,  0xCu);
  }
}

void sub_10010C804(id a1)
{
  byte_1002DEB78 = _os_feature_enabled_impl("CoreCDP", "DeferSOSFromSignIn");
  CFTypeID v1 = sub_10001267C("octagon");
  BOOL v2 = (os_log_s *)objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1002DEB78) {
      int v3 = "enabled";
    }
    else {
      int v3 = "disabled";
    }
    int v4 = 136315138;
    CFTypeRef v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "DeferSOSFromSignIn is %s", (uint8_t *)&v4, 0xCu);
  }
}

void sub_10010C8E0()
{
  DistributedCenter = CFNotificationCenterGetDistributedCenter();
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1002DEB88);
  CFNotificationCenterPostNotificationWithOptions( DistributedCenter,  @"com.apple.security.shared-items-changed",  0LL,  0LL,  0LL);
}

void sub_10010C930()
{
  if (qword_1002DEB90 != -1) {
    dispatch_once(&qword_1002DEB90, &stru_10028F008);
  }
  dispatch_source_merge_data((dispatch_source_t)qword_1002DEB98, 1uLL);
}

void sub_10010C974(id a1)
{
  dispatch_source_t v1 = sub_10001A100("SecKeychainChanged", 1LL);
  qword_1002DEB98 = (uint64_t)v1;
  context = dispatch_get_context(v1);
  uint64_t context[2] = _Block_copy(&stru_10028F048);
  dispatch_activate(v1);
}

void sub_10010C9C4(id a1)
{
  uint32_t v1 = notify_post("com.apple.security.keychainchanged");
  if (v1)
  {
    uint32_t v2 = v1;
    int v3 = (os_log_s *)sub_10001267C("SecError");
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v8 = 136315394;
    uint64_t v9 = "com.apple.security.keychainchanged";
    __int16 v10 = 1024;
    uint32_t v11 = v2;
    int v4 = "notify_post %s returned: %u";
    CFTypeRef v5 = v3;
    uint32_t v6 = 18;
  }

  else
  {
    CFTypeRef v7 = (os_log_s *)sub_10001267C("item");
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v8 = 136315138;
    uint64_t v9 = "com.apple.security.keychainchanged";
    int v4 = "Sent %s";
    CFTypeRef v5 = v7;
    uint32_t v6 = 12;
  }

  _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v4, (uint8_t *)&v8, v6);
}

uint64_t sub_10010CADC(uint64_t a1, int *a2, CFTypeRef *a3)
{
  uint64_t v33 = 0LL;
  int v34 = &v33;
  uint64_t v35 = 0x2000000000LL;
  char v36 = 1;
  uint64_t v29 = 0LL;
  CFTypeRef v30 = (CFTypeRef *)&v29;
  uint64_t v31 = 0x2000000000LL;
  CFTypeRef v32 = 0LL;
  uint64_t v25 = 0LL;
  uint64_t v26 = &v25;
  uint64_t v27 = 0x2000000000LL;
  char v28 = 0;
  v24[0] = _NSConcreteStackBlock;
  v24[1] = 0x40000000LL;
  v24[2] = sub_10010CE60;
  v24[3] = &unk_10028F098;
  v24[5] = &v25;
  v24[6] = a1;
  v24[4] = &v33;
  unsigned __int8 v6 = sub_100015B70( a1,  @"SELECT name FROM sqlite_master WHERE type='table' AND name='tversion'",  &v32,  (uint64_t)v24);
  if (*((_BYTE *)v34 + 24)) {
    unsigned __int8 v7 = v6;
  }
  else {
    unsigned __int8 v7 = 0;
  }
  *((_BYTE *)v34 + 24) = v7;
  if ((v7 & 1) != 0)
  {
    if (*((_BYTE *)v26 + 24))
    {
      v23[0] = _NSConcreteStackBlock;
      v23[1] = 0x40000000LL;
      v23[2] = sub_10010CED4;
      v23[3] = &unk_10028F0E0;
      v23[4] = &v33;
      void v23[5] = a1;
      v23[6] = a2;
      unsigned int v8 = sub_100015B70(a1, @"SELECT version FROM tversion", v30 + 3, (uint64_t)v23);
      if (*((_BYTE *)v34 + 24)) {
        unsigned int v9 = v8;
      }
      else {
        unsigned int v9 = 0;
      }
      *((_BYTE *)v34 + 24) = v9;
      if (v9 == 1 && *(unsigned __int16 *)a2 >= 9u)
      {
        v22[0] = _NSConcreteStackBlock;
        v22[1] = 0x40000000LL;
        v22[2] = sub_10010CF48;
        v22[3] = &unk_10028F128;
        v22[4] = &v33;
        v22[5] = &v29;
        v22[6] = a2;
        v22[7] = a1;
        sub_100015B70(a1, @"SELECT minor FROM tversion WHERE version = ?", v30 + 3, (uint64_t)v22);
        *((_BYTE *)v34 + 24) = 1;
      }
    }

    else
    {
      __int16 v10 = (os_log_s *)sub_10001267C("upgr");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        CFTypeRef v11 = v30[3];
        *(_DWORD *)__int128 buf = 138412290;
        *(void *)uint64_t v38 = v11;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "no tversion table, will setup a new database: %@",  buf,  0xCu);
      }

      *a2 = 0;
    }
  }

  else
  {
    sub_100014958(11, a3, @"Failed to read sqlite_master table: %@", v30[3]);
  }

  char v12 = (os_log_s *)sub_10001267C("upgr");
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = *a2;
    int v14 = *((unsigned __int8 *)v34 + 24);
    CFTypeRef v15 = v30[3];
    *(_DWORD *)__int128 buf = 67109634;
    *(_DWORD *)uint64_t v38 = v13;
    *(_WORD *)&v38[4] = 1024;
    *(_DWORD *)&v38[6] = v14;
    __int16 v39 = 2112;
    CFTypeRef v40 = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "database version is: 0x%08x : %d : %@",  buf,  0x18u);
  }

  __int128 v16 = (os_log_s *)sub_10001267C("upgr");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uid_t v17 = getuid();
    uid_t v18 = geteuid();
    *(_DWORD *)__int128 buf = 67109376;
    *(_DWORD *)uint64_t v38 = v17;
    *(_WORD *)&v38[4] = 1024;
    *(_DWORD *)&v38[6] = v18;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "UID: %d  EUID: %d", buf, 0xEu);
  }

  CFTypeRef v19 = v30[3];
  if (v19) {
    CFRelease(v19);
  }
  uint64_t v20 = *((unsigned __int8 *)v34 + 24);
  _Block_object_dispose(&v25, 8);
  _Block_object_dispose(&v29, 8);
  _Block_object_dispose(&v33, 8);
  return v20;
}

uint64_t sub_10010CE60(void *a1, sqlite3_stmt *a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = sub_10010D090;
  v5[3] = &unk_10028F070;
  uint64_t v3 = a1[6];
  v5[4] = a1[5];
  uint64_t result = sub_100015CD8(v3, a2, 0LL, (uint64_t)v5);
  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = result;
  return result;
}

uint64_t sub_10010CED4(void *a1, sqlite3_stmt *a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = sub_10010D050;
  v5[3] = &unk_10028F0B8;
  uint64_t v3 = a1[5];
  v5[4] = a1[6];
  void v5[5] = a2;
  uint64_t result = sub_100015CD8(v3, a2, 0LL, (uint64_t)v5);
  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = result;
  return result;
}

uint64_t sub_10010CF48(uint64_t a1, sqlite3_stmt *a2)
{
  int v4 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  uint64_t v5 = sqlite3_bind_int(a2, 1, **(_DWORD **)(a1 + 48));
  uint64_t result = sub_100014AC0(v5, a2, v4, @"bind_int[%d]", 1LL);
  if ((_DWORD)result)
  {
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000LL;
    v9[2] = sub_10010D004;
    v9[3] = &unk_10028F100;
    uint64_t v8 = *(void *)(a1 + 48);
    uint64_t v7 = *(void *)(a1 + 56);
    v9[4] = a2;
    v9[5] = v8;
    uint64_t result = sub_100015CD8(v7, a2, 0LL, (uint64_t)v9);
  }

  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

sqlite3_int64 sub_10010D004(uint64_t a1, _BYTE *a2)
{
  sqlite3_int64 result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 32), 0);
  **(_DWORD **)(a1 + 40) |= ((_DWORD)result << 8) & 0xFF00FF00;
  *a2 = 1;
  return result;
}

uint64_t sub_10010D050(uint64_t a1, _BYTE *a2)
{
  uint64_t result = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 40), 0);
  **(_DWORD **)(a1 + 32) = result;
  if ((_DWORD)result) {
    *a2 = 1;
  }
  return result;
}

uint64_t sub_10010D090(uint64_t result, _BYTE *a2)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  *a2 = 1;
  return result;
}

CFDataRef sub_10010D0A8()
{
  v0 = CFUUIDCreate(kCFAllocatorDefault);
  CFUUIDBytes v3 = CFUUIDGetUUIDBytes(v0);
  CFDataRef v1 = CFDataCreate(kCFAllocatorDefault, &v3.byte0, 16LL);
  if (v0) {
    CFRelease(v0);
  }
  return v1;
}

uint64_t sub_10010D10C(uint64_t a1)
{
  v7.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&v7.tv_usec = 0xAAAAAAAAAAAAAAAALL;
  gettimeofday(&v7, 0LL);
  int64_t v2 = 1000 * (v7.tv_sec - *(void *)a1) + *(_DWORD *)(a1 + 8) / -1000 + v7.tv_usec / 1000;
  uint64_t v3 = 1LL;
  if (v2 >= 101)
  {
    unint64_t v4 = 1000 * (v7.tv_sec - *(void *)a1) + *(_DWORD *)(a1 + 8) / -1000 + v7.tv_usec / 1000;
    do
    {
      int64_t v2 = v4 / 0xA;
      v3 *= 10LL;
      BOOL v5 = v4 > 0x3F1;
      v4 /= 0xAuLL;
    }

    while (v5);
  }

  return v3 * v2;
}

uint64_t sub_10010D1D0(void *a1, sqlite3_stmt *a2)
{
  uint64_t v2 = a1[5];
  uint64_t v3 = (CFTypeRef *)(*(void *)(a1[4] + 8LL) + 24LL);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  v6[2] = sub_10010DBDC;
  v6[3] = &unk_10028F150;
  void v6[4] = v2;
  void v6[5] = a2;
  uint64_t v4 = a1[6];
  void v6[6] = a1[7];
  return sub_100015CD8(v4, a2, v3, (uint64_t)v6);
}

void sub_10010D238(uint64_t a1, uint64_t a2)
{
  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    int v14 = 0LL;
    uint64_t v4 = **(void **)(a1 + 40);
    if (qword_1002DEA80 != -1) {
      dispatch_once(&qword_1002DEA80, &stru_1002865A8);
    }
    BOOL v5 = (CFDictionaryRef *)sub_1000F82CC(v4, (const void *)qword_1002DEA88, 0LL, 0LL, &v14);
    unsigned __int8 v6 = v14;
    if (v14)
    {
      int v14 = 0LL;
      CFRelease(v6);
    }

    uint64_t v7 = *(void *)(a1 + 48);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000LL;
    v13[2] = sub_10010D39C;
    v13[3] = &unk_10028F218;
    v13[4] = a2;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000LL;
    v9[2] = sub_10010D3B0;
    v9[3] = &unk_10028F240;
    v9[4] = *(void *)(a1 + 32);
    v9[5] = a2;
    __int128 v10 = *(_OWORD *)(a1 + 56);
    uint64_t v11 = v7;
    char v12 = v5;
    sub_1000EA68C(v5, v7, (CFTypeRef *)&v14, &stru_10028F1B8, &stru_10028F1F8, 0LL, (uint64_t)v13, (uint64_t)v9);
    if (v5) {
      sub_1000F8150((const void **)v5, 0LL);
    }
    uint64_t v8 = v14;
    if (v14)
    {
      int v14 = 0LL;
      CFRelease(v8);
    }
  }

uint64_t sub_10010D388(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_10010D39C(uint64_t a1, sqlite3_stmt *a2)
{
  return sub_1000182E4(a2, 1LL, *(const __CFString **)(a1 + 32), 0LL);
}

void sub_10010D3B0(uint64_t a1, void **a2)
{
  CFTypeRef v30 = 0LL;
  CFTypeRef cf = 0LL;
  uint64_t v4 = qword_1002DEBA0;
  qword_1002DEBA0 = 0LL;
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5) {
    CFRetain(*(CFTypeRef *)(a1 + 40));
  }
  qword_1002DEBA0 = v5;
  unsigned __int8 v6 = (const __CFData *)sub_1000E9614(a2, (__CFString **)&cf);
  if (cf)
  {
    uint64_t v7 = (os_log_s *)sub_10001267C("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v33 = (uint64_t)cf;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "upgr-phase3: failed to get persistent ref error: %@",  buf,  0xCu);
    }

    if (sub_10010D940((__CFError *)cf, *(__CFError ***)(a1 + 48)))
    {
LABEL_7:
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
      **(_BYTE **)(a1 + 56) = 1;
      if (qword_1002DEBA0) {
        CFRelease((CFTypeRef)qword_1002DEBA0);
      }
      qword_1002DEBA0 = v4;
      CFTypeRef v8 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
LABEL_65:
        CFRelease(v8);
        return;
      }

      return;
    }

    CFTypeRef v9 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v9);
    }
  }

  uint64_t v10 = sub_1000E9718(a2, (__CFString **)&v30);
  if (v30)
  {
    uint64_t v11 = (os_log_s *)sub_10001267C("SecError");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v33 = (uint64_t)v30;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "upgr-phase3: failed to get rowID error: %@",  buf,  0xCu);
    }
  }

  uint64_t v12 = *a2[2];
  int v13 = @"YES";
  if (v6 && CFDataGetLength(v6) == 16) {
    int v13 = @"NO";
  }
  int v14 = (os_log_s *)sub_10001267C("upgr-phase3");
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218498;
    uint64_t v33 = v10;
    __int16 v34 = 2112;
    *(void *)uint64_t v35 = v12;
    *(_WORD *)&v35[8] = 2112;
    *(void *)&v35[10] = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "inspecting item at row %lld in table %@, should add persistref uuid?: %@",  buf,  0x20u);
  }

  CFTypeRef v15 = v30;
  if (v30)
  {
    CFTypeRef v30 = 0LL;
    CFRelease(v15);
  }

  CFTypeRef v16 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v16);
  }

  if (CFStringCompare(v13, @"YES", 0LL)) {
    return;
  }
  uid_t v17 = (os_log_s *)sub_10001267C("upgr-phase3");
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    uint64_t v33 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "upgrading item persistentref at row id %lld",  buf,  0xCu);
  }

  uid_t v18 = sub_10010D0A8();
  char v19 = sub_1000E8AF8((uint64_t)a2, kSecAttrPersistentReference, v18, (__CFString **)&cf);
  if (v18) {
    CFRelease(v18);
  }
  if (cf) {
    char v20 = 0;
  }
  else {
    char v20 = v19;
  }
  if ((v20 & 1) == 0)
  {
    uint64_t v25 = (os_log_s *)sub_10001267C("SecError");
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138478083;
      uint64_t v33 = (uint64_t)a2;
      __int16 v34 = 2112;
      *(void *)uint64_t v35 = cf;
      _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "upgr-phase3: failed to set persistentref for item:%{private}@, error:%@",  buf,  0x16u);
    }

    if (cf)
    {
      CFTypeRef v26 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
        goto LABEL_60;
      }
    }

    else if ((v19 & 1) == 0)
    {
      uint64_t v27 = (os_log_s *)sub_10001267C("SecError");
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "upgr-phase3: SecDbItemSetValueWithName returned false",  buf,  2u);
      }

      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
      **(_BYTE **)(a1 + 56) = 1;
      if (qword_1002DEBA0) {
        CFRelease((CFTypeRef)qword_1002DEBA0);
      }
      qword_1002DEBA0 = v4;
      return;
    }

BOOL sub_10010D924(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

BOOL sub_10010D934(id a1, const SecDbAttr *a2)
{
  return (LOBYTE(a2->var2) >> 1) & 1;
}

uint64_t sub_10010D940(__CFError *a1, __CFError **a2)
{
  CFIndex Code = CFErrorGetCode(a1);
  if (Code > -25331)
  {
    switch(Code)
    {
      case -25330LL:
        uint64_t v11 = (os_log_s *)sub_10001267C("upgr-phase3");
        BOOL v15 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
        uint64_t result = 0LL;
        if (!v15) {
          return result;
        }
        int v16 = 138412290;
        uid_t v17 = a1;
        CFTypeRef v8 = "authentication needed: %@";
        break;
      case -25308LL:
        int v13 = (os_log_s *)sub_10001267C("upgr-phase3");
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          int v16 = 138412290;
          uid_t v17 = a1;
          int v14 = "interaction not allowed: %@";
          goto LABEL_20;
        }

void sub_10010DBDC(uint64_t a1, _BYTE *a2)
{
  sqlite3_int64 v4 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  sqlite3_int64 valuePtr = v4;
  uint64_t v5 = (os_log_s *)sub_10001267C("upgr-phase3");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    sqlite3_int64 v10 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "picked up rowid: %lld that needs a persistref",  buf,  0xCu);
  }

  BOOL v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  uint64_t v7 = v6;
  if (qword_1002DEBA0 && CFNumberCompare(v6, (CFNumberRef)qword_1002DEBA0, 0LL) != kCFCompareGreaterThan)
  {
LABEL_7:
    if (!v7) {
      return;
    }
    goto LABEL_8;
  }

  if (CFArrayGetCount(*(CFArrayRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)) <= 99)
  {
    CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), v7);
    goto LABEL_7;
  }

  *a2 = 1;
  **(_BYTE **)(a1 + 48) = 1;
  if (!v7) {
    return;
  }
LABEL_8:
  CFRelease(v7);
}

uint64_t sub_10010DD28(const __CFArray *a1, const __CFString *cf, uint64_t a3)
{
  if (!a1) {
    return 1LL;
  }
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFStringGetTypeID())
    {
      CFIndex Count = CFArrayGetCount(a1);
      if (Count)
      {
        CFIndex v8 = Count;
        v10.location = 0LL;
        v10.length = Count;
        if (CFArrayContainsValue(a1, v10, cf)) {
          return 1LL;
        }
        v11.location = 0LL;
        v11.length = v8;
        if (CFArrayContainsValue(a1, v11, @"*")
          || a3 && *(_BYTE *)(a3 + 18) && CFStringHasSuffix(cf, kSecNetworkExtensionAccessGroupSuffix))
        {
          return 1LL;
        }
      }
    }
  }

  return 0LL;
}

uint64_t sub_10010DDF0(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, _BYTE *a5, CFTypeRef *a6)
{
  uint64_t v10 = 0LL;
  unsigned int v61 = 0;
  if ((a4 & 1) == 0)
  {
    uint64_t v10 = v61;
  }

  uint64_t v71 = 0LL;
  v72 = &v71;
  uint64_t v73 = 0x2000000000LL;
  char v74 = 0;
  uint64_t v67 = 0LL;
  __int16 v68 = &v67;
  uint64_t v69 = 0x2000000000LL;
  char v70 = 1;
  uint64_t v63 = 0LL;
  __int128 v64 = &v63;
  uint64_t v65 = 0x2000000000LL;
  CFTypeRef v66 = 0LL;
  if (a6) {
    *a6 = 0LL;
  }
  if ((_DWORD)v10 != 2060)
  {
    if (v10 == 12 && ((unsigned __int16)v10 & 0xFF00u) >= 0x801)
    {
      CFRange v11 = (os_log_s *)sub_10001267C("upgr");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "skipping upgrade since minor is newer",  buf,  2u);
      }
    }

    else
    {
      *(void *)__int128 buf = _NSConcreteStackBlock;
      *(void *)&buf[16] = sub_10010E660;
      v82 = &unk_10028F848;
      v83 = &v67;
      v84 = &v63;
      int v89 = v10;
      int v90 = 2060;
      *(void *)&uint8_t buf[8] = 0x40000000LL;
      v87 = dword_10028BA78;
      v88 = a5;
      v85 = &v71;
      uint64_t v86 = a3;
      BOOL v12 = sub_1000163F4(a3, 2LL, &v66, (uint64_t)buf);
      if (*((_BYTE *)v68 + 24)) {
        BOOL v13 = v12;
      }
      else {
        BOOL v13 = 0;
      }
      *((_BYTE *)v68 + 24) = v13;
      if (v13 && *((_BYTE *)v72 + 24)) {
        SecCoreAnalyticsSendValue(@"com.apple.keychain.migration-success", 1LL);
      }
    }
  }

  uint64_t v59 = a1;
  uint64_t v60 = a5;
  if (!*((_BYTE *)v68 + 24))
  {
LABEL_22:
    BOOL v15 = (os_log_s *)sub_10001267C("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = (__CFString *)v64[3];
      *(_DWORD *)v75 = 138412290;
      v76 = v16;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "upgrade: error occurred, considering marking database as corrupt: %@",  v75,  0xCu);
    }

    uid_t v17 = (__CFError *)v64[3];
    if (v17)
    {
      CFErrorDomain Domain = CFErrorGetDomain(v17);
      CFIndex Code = CFErrorGetCode((CFErrorRef)v64[3]);
      if (Domain && CFEqual(Domain, @"com.apple.utilities.sqlite3"))
      {
        if ((unint64_t)Code - 5 < 2
          || Code == -536870184
          || Code == 13LL
          || Code == -25291)
        {
          goto LABEL_36;
        }

        uint64_t v20 = -536870186LL;
      }

      else
      {
        if (Code == -536870186 || Code == -536870184) {
          goto LABEL_36;
        }
        uint64_t v20 = -25291LL;
      }

      if (Code == v20)
      {
LABEL_36:
        int v21 = (os_log_s *)sub_10001267C("SecError");
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          CFTypeRef v22 = (__CFString *)v64[3];
          *(_DWORD *)v75 = 138412290;
          v76 = v22;
          _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "upgrade: not marking keychain database corrupt for error: %@",  v75,  0xCu);
        }

        BOOL v23 = (const void *)v64[3];
        if (v23)
        {
          v64[3] = 0LL;
          CFRelease(v23);
        }

        goto LABEL_74;
      }

      CFTypeID v41 = (os_log_s *)sub_10001267C("SecError");
      if (!os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_63;
      }
      id v42 = (__CFString *)v64[3];
      *(_DWORD *)v75 = 138412290;
      v76 = v42;
      uint64_t v25 = "upgrade: unable to complete upgrade, marking DB as corrupt: %@";
      CFTypeRef v26 = v41;
      uint32_t v27 = 12;
    }

    else
    {
      BOOL v24 = (os_log_s *)sub_10001267C("SecError");
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
LABEL_63:
        __int128 v43 = (os_log_s *)sub_10001267C("SecError");
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v75 = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "upgrade: marking database as corrupt",  v75,  2u);
        }

        CFTypeID v44 = (__CFString *)v64[3];
        if (dword_1002DD0E8 == -1)
        {
          uint64_t v45 = (os_log_s *)sub_10001267C("SecEmergency");
          if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)v75 = 138412290;
            v76 = v44;
            _os_log_fault_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_FAULT, "SecDBCorrupt: %@", v75, 0xCu);
          }
        }

        *(_BYTE *)(a3 + 40) = 1;
        uint64_t v46 = *(__CFString **)(a3 + 56);
        if (v46 != v44)
        {
          if (!v44 || (CFRetain(v44), (uint64_t v46 = *(__CFString **)(a3 + 56)) != 0LL)) {
            CFRelease(v46);
          }
          *(void *)(a3 + 56) = v44;
        }

        SecCoreAnalyticsSendValue(@"com.apple.keychain.migration-failure", 1LL);
        goto LABEL_74;
      }

      *(_WORD *)v75 = 0;
      uint64_t v25 = "upgrade: unable to complete upgrade and no error object returned, marking DB as corrupt";
      CFTypeRef v26 = v24;
      uint32_t v27 = 2;
    }

    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, v25, v75, v27);
    goto LABEL_63;
  }

  if (v64[3])
  {
    int v14 = (os_log_s *)sub_10001267C("SecWarning");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v75 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "upgrade: error has been set but status is true",  v75,  2u);
    }

    *((_BYTE *)v68 + 24) = 0;
    goto LABEL_22;
  }

  if (*((_BYTE *)v72 + 24)) {
    LKAReportKeychainUpgradeOutcomeWithError(v10, 2060LL, 0LL, 0LL);
  }
  if ((_DWORD)v10 == 2060 || *((_BYTE *)v72 + 24))
  {
    sub_10010FB08(a3);
    CFTypeRef v28 = off_10028BA80;
    CFTypeRef v29 = &off_1002898F8;
    do
    {
      CFTypeRef v30 = v29[2];
      if (v30)
      {
        uint64_t v31 = v29 + 3;
        do
        {
          if ((~LODWORD(v30->data) & 6LL) == 0)
          {
            CFTypeRef cf = 0LL;
            CFTypeRef v32 = *v28;
            uint64_t v33 = CFStringCreateWithFormat( 0LL,  0LL,  @"CREATE INDEX IF NOT EXISTS %@%@ ON %@(%@);",
                    **v28,
                    v30->isa,
                    **v28,
                    v30->isa);
            char v34 = sub_100014F28(a3, v33, &cf);
            if (v33) {
              CFRelease(v33);
            }
            if ((v34 & 1) == 0)
            {
              uint64_t v35 = (os_log_s *)sub_10001267C("SecError");
              if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
              {
                char v36 = *v32;
                isa = v30->isa;
                *(_DWORD *)v75 = 138412802;
                v76 = v36;
                __int16 v77 = 2112;
                v78 = isa;
                __int16 v79 = 2112;
                CFTypeRef v80 = cf;
                _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "upgrade: unable to opportunistically create index (%@,%@): %@",  v75,  0x20u);
              }
            }

            CFTypeRef v38 = cf;
            if (cf)
            {
              CFTypeRef cf = 0LL;
              CFRelease(v38);
            }
          }

          __int16 v39 = *v31++;
          CFTypeRef v30 = v39;
        }

        while (v39);
      }

      CFTypeRef v40 = v28[1];
      ++v28;
      CFTypeRef v29 = v40;
    }

    while (v40);
  }

LABEL_80:
  int v51 = (os_log_s *)sub_10001267C("SecError");
  uint64_t v50 = 0LL;
  if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v52 = "";
    if (a4) {
      uint64_t v52 = "from v0 ";
    }
    if (a6) {
      CFTypeRef v53 = *a6;
    }
    else {
      CFTypeRef v53 = 0LL;
    }
    *(_DWORD *)__int128 buf = 136315394;
    *(void *)&uint8_t buf[4] = v52;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v53;
    _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "Upgrade %sfailed: %@", buf, 0x16u);
    uint64_t v50 = 0LL;
  }

  uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  self->_timestampResponseStart));
  [v3 setObject:v47 forKey:@"timestamp_response_start"];

  if ((*(_DWORD *)&self->_has & 0x1000) != 0)
  {
LABEL_43:
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  self->_timestampResponseEnd));
    [v3 setObject:v20 forKey:@"timestamp_response_end"];
  }

  PBDataWriterWriteUint64Field(v20, self->_timestampResponseStart, 211LL);
  if ((*(_DWORD *)&self->_has & 0x1000) != 0) {
LABEL_43:
  }
    PBDataWriterWriteUint64Field(v20, self->_timestampResponseEnd, 212LL);
LABEL_44:
  optionsQualityOfService = self->_optionsQualityOfService;
  if (optionsQualityOfService) {
    PBDataWriterWriteStringField(v20, optionsQualityOfService, 301LL);
  }
  int v16 = self->_has;
  if ((*(_DWORD *)&v16 & 0x8000000) != 0)
  {
    PBDataWriterWriteBOOLField(v20, self->_optionsOutOfProcess, 302LL);
    int v16 = self->_has;
    if ((*(_DWORD *)&v16 & 0x10000000) == 0)
    {
LABEL_48:
      if ((*(_DWORD *)&v16 & 0x1000000) == 0) {
        goto LABEL_49;
      }
      goto LABEL_84;
    }
  }

  else if ((*(_DWORD *)&v16 & 0x10000000) == 0)
  {
    goto LABEL_48;
  }

  PBDataWriterWriteBOOLField(v20, self->_optionsOutOfProcessForceDiscretionary, 303LL);
  int v16 = self->_has;
  if ((*(_DWORD *)&v16 & 0x1000000) == 0)
  {
LABEL_49:
    if ((*(_DWORD *)&v16 & 0x2000000) == 0) {
      goto LABEL_50;
    }
    goto LABEL_85;
  }

  v4[14] = self->_timestampResponseStart;
  *((_DWORD *)v4 + 70) |= 0x2000u;
  if ((*(_DWORD *)&self->_has & 0x1000) != 0)
  {
LABEL_43:
    v4[13] = self->_timestampResponseEnd;
    *((_DWORD *)v4 + 70) |= 0x1000u;
  }

  self->_timestampTcpEnd = v5[16];
  *(_DWORD *)&self->_has |= 0x8000u;
  uint64_t v10 = *((_DWORD *)v5 + 70);
  if ((v10 & 0x4000) == 0)
  {
LABEL_51:
    if ((v10 & 0x800) == 0) {
      goto LABEL_52;
    }
    goto LABEL_82;
  }

LABEL_87:
  if (a6) {
    CFTypeRef v54 = *a6;
  }
  else {
    CFTypeRef v54 = 0LL;
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v54;
  if ((_DWORD)v50 && (!a5 || !*a5))
  {
    dispatch_queue_global_t global_queue = dispatch_get_global_queue(0LL, 0LL);
    *(void *)__int128 buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000LL;
    *(void *)&buf[16] = sub_10010FF90;
    v82 = &unk_10028F340;
    v83 = a2;
    dispatch_async(global_queue, buf);
    if (byte_1002DE9A0 == 1) {
      dispatch_async(global_queue, &stru_10028F380);
    }
  }

  return v50;
}

    v128 = 0LL;
    goto LABEL_88;
  }

  v168 = 0u;
  v169 = 0u;
  v166 = 0u;
  v167 = 0u;
  sqlite3_int64 v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) deps]);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v4 activeManagedViews]);

  obj = v5;
  v137 = [v5 countByEnumeratingWithState:&v166 objects:v177 count:16];
  if (!v137) {
    goto LABEL_82;
  }
  v134 = 0;
  v136 = *(void *)v167;
  v150 = v1;
  do
  {
    CFTypeID v6 = 0LL;
    do
    {
      if (*(void *)v167 != v136) {
        objc_enumerationMutation(obj);
      }
      uint64_t v7 = *(void **)(*((void *)&v166 + 1) + 8 * v6);
      CFIndex v8 = (void *)objc_claimAutoreleasedReturnValue([v7 viewKeyHierarchyState]);
      CFTypeRef v9 = [v8 isEqualToString:@"ready"];

      if ((v9 & 1) == 0)
      {
        uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v7 zoneID]);
        CFRange v11 = (void *)objc_claimAutoreleasedReturnValue([v10 zoneName]);
        BOOL v12 = sub_1000AA6AC(@"ckksreencrypt", v11);
        BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);

        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          v171 = (os_log_s *)v7;
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "View is %@; reencryption will likely fail",
            buf,
            0xCu);
        }
      }

      int v14 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) deps]);
      BOOL v15 = (void *)objc_claimAutoreleasedReturnValue([v14 contextID]);
      int v16 = (void *)objc_claimAutoreleasedReturnValue([v7 zoneID]);
      v165 = 0LL;
      uid_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSOutgoingQueueEntry allInState:contextID:zoneID:error:]( &OBJC_CLASS___CKKSOutgoingQueueEntry,  "allInState:contextID:zoneID:error:",  @"reencrypt",  v15,  v16,  &v165));
      uint64_t v3 = (os_log_s *)v165;

      if (v3)
      {
        v129 = (void *)objc_claimAutoreleasedReturnValue([v7 zoneID]);
        v130 = (void *)objc_claimAutoreleasedReturnValue([v129 zoneName]);
        v131 = sub_1000AA6AC(@"ckksreencrypt", v130);
        v132 = (os_log_s *)objc_claimAutoreleasedReturnValue(v131);

        if (os_log_type_enabled(v132, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 138412290;
          v171 = v3;
          _os_log_impl( (void *)&_mh_execute_header,  v132,  OS_LOG_TYPE_ERROR,  "Error fetching oqes from database: %@",  buf,  0xCu);
        }

        [*(id *)(v1 + 32) setError:v3];
        goto LABEL_87;
      }

      v139 = v6;
      uid_t v18 = (void *)objc_claimAutoreleasedReturnValue([v7 zoneID]);
      char v19 = (void *)objc_claimAutoreleasedReturnValue([v18 zoneName]);
      +[CKKSPowerCollection CKKSPowerEvent:zone:count:]( CKKSPowerCollection,  "CKKSPowerEvent:zone:count:",  @"reencryptOutgoing",  v19,  [v17 count]);

      v146 = objc_alloc_init(&OBJC_CLASS___CKKSMemoryKeyCache);
      v161 = 0u;
      v162 = 0u;
      v163 = 0u;
      v164 = 0u;
      v147 = v17;
      v149 = [v147 countByEnumeratingWithState:&v161 objects:v176 count:16];
      if (v149)
      {
        v148 = *(void *)v162;
        v143 = v7;
        do
        {
          uint64_t v20 = 0LL;
          do
          {
            int v21 = v7;
            if (*(void *)v162 != v148) {
              objc_enumerationMutation(v147);
            }
            CFTypeRef v22 = *(void **)(*((void *)&v161 + 1) + 8LL * (void)v20);
            BOOL v23 = (void *)objc_claimAutoreleasedReturnValue([v22 uuid]);
            BOOL v24 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) deps]);
            uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v24 contextID]);
            CFTypeRef v26 = (void *)objc_claimAutoreleasedReturnValue([v22 item]);
            uint32_t v27 = (void *)objc_claimAutoreleasedReturnValue([v26 zoneID]);
            v160 = 0LL;
            CFTypeRef v28 = (os_log_s *)objc_claimAutoreleasedReturnValue( +[CKKSOutgoingQueueEntry tryFromDatabase:state:contextID:zoneID:error:]( &OBJC_CLASS___CKKSOutgoingQueueEntry,  "tryFromDatabase:state:contextID:zoneID:error:",  v23,  @"new",  v25,  v27,  &v160));
            CFTypeRef v29 = (os_log_s *)v160;

            uint64_t v7 = v21;
            if (v29)
            {
              CFTypeRef v30 = (void *)objc_claimAutoreleasedReturnValue([v21 zoneID]);
              uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v30 zoneName]);
              CFTypeRef v32 = sub_1000AA6AC(@"ckksreencrypt", v31);
              uint64_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue(v32);

              if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)__int128 buf = 138412290;
                v171 = v29;
                _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_ERROR,  "Couldn't load 'new' OQE to determine status: %@",  buf,  0xCu);
              }

              CFDataRef v1 = v150;
              goto LABEL_23;
            }

            char v34 = (void *)objc_claimAutoreleasedReturnValue([v21 zoneID]);
            uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([v34 zoneName]);
            char v36 = sub_1000AA6AC(@"ckksreencrypt", v35);
            CFTypeRef v37 = (os_log_s *)objc_claimAutoreleasedReturnValue(v36);

            CFTypeRef v38 = os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT);
            if (!v28)
            {
              if (v38)
              {
                *(_DWORD *)__int128 buf = 138412290;
                v171 = (os_log_s *)v22;
                _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "Reencrypting item %@", buf, 0xCu);
              }

              CFTypeID v44 = (void *)objc_claimAutoreleasedReturnValue([v22 item]);
              v158 = 0LL;
              CFTypeRef v29 = (os_log_s *)objc_claimAutoreleasedReturnValue( +[CKKSItemEncrypter decryptItemToDictionary:keyCache:error:]( &OBJC_CLASS___CKKSItemEncrypter,  "decryptItemToDictionary:keyCache:error:",  v44,  v146,  &v158));
              uint64_t v45 = v158;

              if (v45)
              {
                uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([v45 domain]);
                if ([v46 isEqualToString:@"securityd"])
                {
                  uint64_t v47 = (os_log_s *)v45;
                  uint64_t v48 = [v45 code];

                  uint64_t v7 = v21;
                  if (v48 == (id)-25300LL)
                  {
                    int v49 = (void *)objc_claimAutoreleasedReturnValue([v21 zoneID]);
                    uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v49 zoneName]);
                    int v51 = sub_1000AA6AC(@"ckksreencrypt", v50);
                    uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue(v51);

                    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)__int128 buf = 138412290;
                      v171 = v47;
                      _os_log_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_ERROR,  "Couldn't find key in keychain; asking for reset: %@",
                        buf,
                        0xCu);
                    }

                    CFDataRef v1 = v150;
                    CFTypeRef v53 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v150 + 32) deps]);
                    CFTypeRef v54 = (void *)objc_claimAutoreleasedReturnValue([v53 flagHandler]);
                    [v54 _onqueueHandleFlag:@"key_process_requested"];

                    [*(id *)(v150 + 32) setNextState:@"unhealthy"];
                    CFTypeRef v28 = 0LL;
                    CFTypeID v55 = v47;
                    goto LABEL_50;
                  }
                }

                else
                {
                  uint64_t v47 = (os_log_s *)v45;

                  uint64_t v7 = v21;
                }

                __int16 v68 = (void *)objc_claimAutoreleasedReturnValue([v7 zoneID]);
                uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue([v68 zoneName]);
                char v70 = sub_1000AA6AC(@"ckksreencrypt", v69);
                uint64_t v71 = (os_log_s *)objc_claimAutoreleasedReturnValue(v70);

                CFTypeID v55 = v47;
                if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)__int128 buf = 138412546;
                  v171 = (os_log_s *)v22;
                  v172 = 2112;
                  v173 = v47;
                  _os_log_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_ERROR,  "Couldn't decrypt item %@: %@",  buf,  0x16u);
                }

                CFDataRef v1 = v150;
                CFTypeRef v28 = 0LL;
LABEL_50:
                [*(id *)(v1 + 32) setError:v55];
              }

              else
              {
                v144 = (void *)objc_claimAutoreleasedReturnValue([v22 item]);
                CFTypeID v56 = (void *)objc_claimAutoreleasedReturnValue([v144 parentKeyUUID]);
                int v57 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v150 + 32) deps]);
                CFTypeRef v58 = (void *)objc_claimAutoreleasedReturnValue([v57 contextID]);
                uint64_t v59 = (void *)objc_claimAutoreleasedReturnValue([v21 zoneID]);
                v157 = 0LL;
                uint64_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue( -[CKKSMemoryKeyCache loadKeyForUUID:contextID:zoneID:error:]( v146,  "loadKeyForUUID:contextID:zoneID:error:",  v56,  v58,  v59,  &v157));
                unsigned int v61 = v157;

                if (v61)
                {
                  CFTypeID v55 = v60;
                  uint64_t v7 = v143;
                  uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue([v143 zoneID]);
                  uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue([v62 zoneName]);
                  __int128 v64 = sub_1000AA6AC(@"ckksreencrypt", v63);
                  uint64_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue(v64);

                  if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
                  {
                    CFTypeRef v66 = (void *)objc_claimAutoreleasedReturnValue([v22 item]);
                    uint64_t v67 = (os_log_s *)objc_claimAutoreleasedReturnValue([v66 parentKeyUUID]);
                    *(_DWORD *)__int128 buf = 138412802;
                    v171 = v67;
                    v172 = 2112;
                    v173 = (os_log_s *)v22;
                    v174 = 2112;
                    v175 = v61;
                    _os_log_impl( (void *)&_mh_execute_header,  v65,  OS_LOG_TYPE_ERROR,  "Couldn't fetch key (%@) for item %@: %@",  buf,  0x20u);
                  }

                  CFDataRef v1 = v150;
                  [*(id *)(v150 + 32) setError:v61];
                  CFTypeRef v28 = 0LL;
                }

                else
                {
                  v145 = v60;
                  v141 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s keyclass](v60, "keyclass"));
                  v72 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v150 + 32) deps]);
                  uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue([v72 contextID]);
                  char v74 = (void *)objc_claimAutoreleasedReturnValue([v143 zoneID]);
                  v156 = 0LL;
                  v75 = (void *)objc_claimAutoreleasedReturnValue( -[CKKSMemoryKeyCache currentKeyForClass:contextID:zoneID:error:]( v146,  "currentKeyForClass:contextID:zoneID:error:",  v141,  v73,  v74,  &v156));
                  v76 = v156;

                  unsigned int v61 = v75;
                  __int16 v77 = (void *)objc_claimAutoreleasedReturnValue([v143 contextID]);
                  v155 = v76;
                  v78 = [v75 ensureKeyLoadedForContextID:v77 cache:v146 error:&v155];
                  __int16 v79 = (os_log_s *)v155;

                  if (v79)
                  {
                    uint64_t v7 = v143;
                    CFTypeRef v80 = (void *)objc_claimAutoreleasedReturnValue([v143 zoneID]);
                    v81 = (void *)objc_claimAutoreleasedReturnValue([v80 zoneName]);
                    v82 = sub_1000AA6AC(@"ckksreencrypt", v81);
                    v83 = (os_log_s *)objc_claimAutoreleasedReturnValue(v82);

                    if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
                    {
                      v84 = (os_log_s *)objc_claimAutoreleasedReturnValue(-[os_log_s keyclass](v145, "keyclass"));
                      *(_DWORD *)__int128 buf = 138412546;
                      v171 = v84;
                      v172 = 2112;
                      v173 = v79;
                      _os_log_impl( (void *)&_mh_execute_header,  v83,  OS_LOG_TYPE_ERROR,  "Couldn't fetch the current key for class %@: %@",  buf,  0x16u);
                    }

                    CFDataRef v1 = v150;
                    [*(id *)(v150 + 32) setError:v79];
                    v85 = v79;
                    CFTypeRef v28 = 0LL;
                    CFTypeID v55 = v145;
                  }

                  else
                  {
                    v140 = v61;
                    uint64_t v86 = (void *)objc_claimAutoreleasedReturnValue([v22 item]);
                    v87 = (void *)objc_claimAutoreleasedReturnValue([v86 uuid]);
                    v88 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v150 + 32) deps]);
                    int v89 = (void *)objc_claimAutoreleasedReturnValue([v88 contextID]);
                    int v90 = (void *)objc_claimAutoreleasedReturnValue([v143 zoneID]);
                    v154 = 0LL;
                    v142 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSMirrorEntry tryFromDatabase:contextID:zoneID:error:]( &OBJC_CLASS___CKKSMirrorEntry,  "tryFromDatabase:contextID:zoneID:error:",  v87,  v89,  v90,  &v154));
                    v91 = v154;

                    if (v91)
                    {
                      uint64_t v7 = v143;
                      v92 = (void *)objc_claimAutoreleasedReturnValue([v143 zoneID]);
                      v93 = (void *)objc_claimAutoreleasedReturnValue([v92 zoneName]);
                      v94 = sub_1000AA6AC(@"ckksreencrypt", v93);
                      v95 = (os_log_s *)objc_claimAutoreleasedReturnValue(v94);

                      if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
                      {
                        v96 = (void *)objc_claimAutoreleasedReturnValue([v22 item]);
                        v97 = (os_log_s *)objc_claimAutoreleasedReturnValue([v96 parentKeyUUID]);
                        *(_DWORD *)__int128 buf = 138412802;
                        v171 = v97;
                        v172 = 2112;
                        v173 = (os_log_s *)v22;
                        v174 = 2112;
                        v175 = v91;
                        _os_log_impl( (void *)&_mh_execute_header,  v95,  OS_LOG_TYPE_ERROR,  "Couldn't fetch ckme (%@) for item %@: %@",  buf,  0x20u);
                      }

                      CFDataRef v1 = v150;
                      v98 = v91;
                      [*(id *)(v150 + 32) setError:v91];
                      CFTypeRef v28 = 0LL;
                      CFTypeID v55 = v145;
                      unsigned int v61 = v140;
                    }

                    else
                    {
                      v99 = (void *)objc_claimAutoreleasedReturnValue([v22 item]);
                      v100 = (void *)objc_claimAutoreleasedReturnValue([v142 item]);
                      v153 = 0LL;
                      v101 = objc_claimAutoreleasedReturnValue( +[CKKSItemEncrypter encryptCKKSItem:dataDictionary:updatingCKKSItem:parentkey:keyCache:error:]( &OBJC_CLASS___CKKSItemEncrypter,  "encryptCKKSItem:dataDictionary:updatingCKKSItem:parentkey:keyCache:error:",  v99,  v29,  v100,  v140,  v146,  &v153));
                      v102 = (CKKSOutgoingQueueEntry *)v153;

                      if (v102)
                      {
                        v103 = (void *)v101;
                        uint64_t v7 = v21;
                        v104 = (void *)objc_claimAutoreleasedReturnValue([v21 zoneID]);
                        v105 = (void *)objc_claimAutoreleasedReturnValue([v104 zoneName]);
                        v106 = sub_1000AA6AC(@"ckksreencrypt", v105);
                        v107 = (os_log_s *)objc_claimAutoreleasedReturnValue(v106);

                        unsigned int v61 = v140;
                        if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
                        {
                          *(_DWORD *)__int128 buf = 138412546;
                          v171 = (os_log_s *)v140;
                          v172 = 2112;
                          v173 = (os_log_s *)v102;
                          _os_log_impl( (void *)&_mh_execute_header,  v107,  OS_LOG_TYPE_ERROR,  "Couldn't encrypt under the new key %@: %@",  buf,  0x16u);
                        }

                        CFDataRef v1 = v150;
                        [*(id *)(v150 + 32) setError:v102];
                        v108 = v102;
                        CFTypeRef v28 = 0LL;
                        CFTypeID v55 = v145;
                        v98 = v103;
                      }

                      else
                      {
                        v109 = objc_alloc(&OBJC_CLASS___CKKSOutgoingQueueEntry);
                        v110 = (void *)objc_claimAutoreleasedReturnValue([v22 action]);
                        v111 = (void *)objc_claimAutoreleasedReturnValue([v22 accessgroup]);
                        v138 = (void *)v101;
                        v112 = -[CKKSOutgoingQueueEntry initWithCKKSItem:action:state:waitUntil:accessGroup:]( v109,  "initWithCKKSItem:action:state:waitUntil:accessGroup:",  v101,  v110,  @"new",  0LL,  v111);

                        v152 = 0LL;
                        [v22 deleteFromDatabase:&v152];
                        v113 = v152;
                        v151 = v113;
                        -[CKKSSQLDatabaseObject saveToDatabase:](v112, "saveToDatabase:", &v151);
                        v114 = (os_log_s *)v151;

                        uint64_t v7 = v21;
                        if (v114)
                        {
                          v115 = (void *)objc_claimAutoreleasedReturnValue([v21 zoneID]);
                          v116 = (void *)objc_claimAutoreleasedReturnValue([v115 zoneName]);
                          v117 = sub_1000AA6AC(@"ckksreencrypt", v116);
                          v118 = (os_log_s *)objc_claimAutoreleasedReturnValue(v117);

                          unsigned int v61 = v140;
                          if (os_log_type_enabled(v118, OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)__int128 buf = 138412546;
                            v171 = (os_log_s *)v112;
                            v172 = 2112;
                            v173 = v114;
                            _os_log_impl( (void *)&_mh_execute_header,  v118,  OS_LOG_TYPE_ERROR,  "Couldn't save newly-encrypted oqe %@: %@",  buf,  0x16u);
                          }

                          CFDataRef v1 = v150;
                          [*(id *)(v150 + 32) setError:v114];

                          v108 = v112;
                          CFTypeRef v28 = 0LL;
                          CFTypeID v55 = v145;
                        }

                        else
                        {
                          v134 = 1;
                          CFDataRef v1 = v150;
                          v108 = v112;
                          CFTypeRef v28 = 0LL;
                          CFTypeID v55 = v145;
                          unsigned int v61 = v140;
                        }

                        v98 = v138;
                      }
                    }

                    v85 = (os_log_s *)v142;
                  }
                }
              }

              goto LABEL_24;
            }

            CFDataRef v1 = v150;
            if (v38)
            {
              *(_DWORD *)__int128 buf = 138412546;
              v171 = (os_log_s *)v22;
              v172 = 2112;
              v173 = v28;
              _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "Have a new OQE superceding %@ (%@), skipping",  buf,  0x16u);
            }

            v159 = 0LL;
            [v22 deleteFromDatabase:&v159];
            __int16 v39 = (os_log_s *)v159;
            if (v39)
            {
              CFTypeRef v29 = v39;
              CFTypeRef v40 = (void *)objc_claimAutoreleasedReturnValue([v21 zoneID]);
              CFTypeID v41 = (void *)objc_claimAutoreleasedReturnValue([v40 zoneName]);
              id v42 = sub_1000AA6AC(@"ckksreencrypt", v41);
              __int128 v43 = (os_log_s *)objc_claimAutoreleasedReturnValue(v42);

              if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)__int128 buf = 138412546;
                v171 = (os_log_s *)v22;
                v172 = 2112;
                v173 = v29;
                _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_ERROR,  "Couldn't delete reencrypting OQE(%@) from database: %@",  buf,  0x16u);
              }

LABEL_23:
              [*(id *)(v1 + 32) setError:v29];
LABEL_24:
            }

            uint64_t v20 = (char *)v20 + 1;
          }

          while (v149 != v20);
          v119 = [v147 countByEnumeratingWithState:&v161 objects:v176 count:16];
          v149 = v119;
        }

        while (v119);
      }

      v120 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](&OBJC_CLASS___CKKSAnalytics, "logger"));
      v121 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) error]);

      v122 = (void *)objc_claimAutoreleasedReturnValue([v7 zoneID]);
      v123 = (void *)objc_claimAutoreleasedReturnValue([v122 zoneName]);
      if (v121) {
        [v120 logRecoverableError:0 forEvent:@"CKKSEventProcessReencryption" zoneName:v123 withAttributes:0];
      }
      else {
        [v120 logSuccessForEvent:@"CKKSEventProcessReencryption" zoneName:v123];
      }

      CFTypeID v6 = v139 + 1;
    }

    while ((id)(v139 + 1) != v137);
    v137 = [obj countByEnumeratingWithState:&v166 objects:v177 count:16];
  }

  while (v137);

  if ((v134 & 1) != 0)
  {
    v124 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) deps]);
    v125 = (void *)objc_claimAutoreleasedReturnValue([v124 ckoperationGroup]);
    v126 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) deps]);
    [v126 setCurrentOutgoingQueueOperationGroup:v125];

    obj = (id)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) deps]);
    v127 = (void *)objc_claimAutoreleasedReturnValue([obj flagHandler]);
    [v127 _onqueueHandleFlag:@"process_outgoing_queue"];

LABEL_82:
  }

  uint64_t v3 = (os_log_s *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) intendedState]);
  [*(id *)(v1 + 32) setNextState:v3];
  v128 = 1LL;
LABEL_88:

  return v128;
}

void sub_10010E654(id a1)
{
}

void sub_10010E660(uint64_t a1, _BYTE *a2)
{
  uint64_t v4 = a1;
  unsigned int v159 = 0;
  int v5 = sub_10010CADC(*(void *)(a1 + 56), (int *)&v159, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL));
  *(_BYTE *)(*(void *)(*(void *)(v4 + 32) + 8LL) + 24LL) = v5;
  if (!v5) {
    goto LABEL_16;
  }
  unsigned int v6 = *(_DWORD *)(v4 + 80);
  if (v6 == v159)
  {
    uint64_t v7 = *(unsigned int **)(v4 + 64);
    unsigned int v8 = v7[1];
    if ((*v7 | (v8 << 8)) == v6) {
      goto LABEL_16;
    }
    if (v6)
    {
      unsigned int v9 = (unsigned __int16)*(_DWORD *)(v4 + 80);
      unsigned int v159 = v9;
      uint64_t v10 = *v7 | (v8 << 8);
      if (v6 < 0x10000 || v9 == (_DWORD)v10)
      {
        CFRange v11 = &v169;
        BOOL v12 = &qword_100205000;
        unsigned int v13 = HIWORD(v6);
        unsigned int v147 = HIWORD(v6);
        v148 = a2;
        uint64_t v149 = v4;
        if (!HIWORD(v6))
        {
          unsigned int v159 = v10;
          int v14 = (const __CFArray *)dword_10028BA78;
          BOOL v15 = (int **)&off_10028E6A0;
          int v16 = dword_10028BA78;
          while ((*v16 | (v16[1] << 8)) != v9)
          {
            uid_t v17 = *v15++;
            int v16 = v17;
            if (!v17)
            {
              sub_100014958( 11,  (CFTypeRef *)(*(void *)(*(void *)(v4 + 40) + 8LL) + 24LL),  @"no schema for version: 0x%x",  (unsigned __int16)v6);
              *(_BYTE *)(*(void *)(*(void *)(v4 + 32) + 8LL) + 24LL) = 0;
              uid_t v18 = (os_log_s *)sub_10001267C("SecError");
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)__int128 buf = 67109120;
                *(_DWORD *)&uint8_t buf[4] = v9;
                _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "no schema for version 0x%x",  buf,  8u);
              }

              uint64_t v19 = v159;
              uint64_t v20 = *(unsigned int *)(v4 + 84);
              uint64_t v21 = 6LL;
              goto LABEL_14;
            }
          }

          unsigned int v143 = v6;
          BOOL v24 = (os_log_s *)sub_10001267C("upgr");
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            int v25 = **(_DWORD **)(v4 + 64) | (*(_DWORD *)(*(void *)(v4 + 64) + 4LL) << 8);
            *(_DWORD *)__int128 buf = 67109376;
            *(_DWORD *)&uint8_t buf[4] = v9;
            *(_WORD *)&uint8_t buf[8] = 1024;
            *(_DWORD *)&buf[10] = v25;
            _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Upgrading from version 0x%x to 0x%x",  buf,  0xEu);
          }

          unsigned int v144 = v9;
          kdebug_trace(726794280LL, 0LL, 0LL, 0LL, 0LL);
          uint64_t v152 = *(void *)(v4 + 56);
          uint64_t v26 = *(void *)(*(void *)(v4 + 40) + 8LL);
          CFRange v11 = (void ***)*v16;
          int v27 = v16[1];
          v196 = 0LL;
          v197 = &v196;
          uint64_t v198 = 0x2000000000LL;
          char v199 = 1;
          v195[0] = 0LL;
          v195[1] = v195;
          v195[2] = 0x2000000000LL;
          v195[3] = 0LL;
          v194.tv_sec = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&v194.tv_usec = 0xAAAAAAAAAAAAAAAALL;
          gettimeofday(&v194, 0LL);
          v214.location = 48LL;
          v214.length = 57LL;
          CFTypeRef v28 = (uint64_t *)CFCharacterSetCreateWithCharactersInRange(0LL, v214);
          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, 0LL);
          CFTypeRef v29 = (const __CFString **)*((void *)v16 + 1);
          if (v29)
          {
            CFTypeRef v30 = 0LL;
            CFMutableStringRef v2 = (CFMutableStringRef)Mutable;
            while (1)
            {
              CFStringRef v31 = sub_1000134F0(*v29, (const __CFCharacterSet *)v28);
              if (CFDictionaryContainsKey(Mutable, v31)) {
                break;
              }
              CFDictionarySetValue(Mutable, v31, v30);
              if (v31) {
                CFRelease(v31);
              }
              CFTypeRef v29 = *(const __CFString ***)&v16[2 * (void)v30 + 4];
              CFTypeRef v30 = (char *)v30 + 1;
              if (!v29) {
                goto LABEL_25;
              }
            }
          }

          else
          {
LABEL_25:
            v151 = (CFTypeRef *)(v26 + 24);
            unsigned int v32 = v11 | (v27 << 8);
            uint64_t v33 = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, 0LL);
            char v34 = 0LL;
            uint64_t v35 = (const __CFString **)&off_1002898F8;
            CFRange v11 = &v169;
            char v36 = Mutable;
            while (1)
            {
              CFStringRef v37 = sub_1000134F0(*v35, (const __CFCharacterSet *)v28);
              if (CFDictionaryContainsKey(v33, v37)) {
                break;
              }
              CFDictionarySetValue(v33, v37, v34);
              if (v37) {
                CFRelease(v37);
              }
              uint64_t v35 = *(const __CFString ***)&dword_10028BA78[2 * (void)v34 + 4];
              char v34 = (char *)v34 + 1;
              if (v34 == (const void *)27)
              {
                unsigned int v142 = v32;
                if (v28) {
                  CFRelease(v28);
                }
                CFTypeRef v38 = CFSetCreateMutable(0LL, 0LL, &kCFTypeSetCallBacks);
                context = _NSConcreteStackBlock;
                uint64_t v187 = 0x40000000LL;
                v188 = sub_10011012C;
                v189 = &unk_10028F868;
                v190 = v33;
                v191 = v16;
                v192 = dword_10028BA78;
                v193 = v38;
                CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)sub_100110254, &context);
                CFMutableStringRef v2 = CFStringCreateMutable(0LL, 0LL);
                CFMutableArrayRef v39 = CFArrayCreateMutable(0LL, 0LL, 0LL);
                *(void *)__int128 buf = _NSConcreteStackBlock;
                *(void *)&uint8_t buf[8] = 0x40000000LL;
                *(void *)&buf[16] = sub_10011026C;
                v207 = &unk_10028F888;
                v208 = Mutable;
                p_context = v16;
                v210 = (__CFString **)v33;
                v211 = dword_10028BA78;
                CFMutableStringRef v212 = v2;
                uint64_t v213 = (uint64_t)v39;
                CFSetApplyFunction(v38, (CFSetApplierFunction)sub_10010D388, buf);
                v178 = _NSConcreteStackBlock;
                uint64_t v179 = 0x40000000LL;
                v180 = sub_1001102F4;
                v181 = &unk_10028F8A8;
                v182 = v38;
                v183 = v33;
                v184 = v16;
                CFMutableStringRef v185 = v2;
                CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)sub_100110254, &v178);
                v169 = _NSConcreteStackBlock;
                uint64_t v170 = 0x40000000LL;
                v171 = sub_10011036C;
                v172 = &unk_10028F8C8;
                CFTypeRef cf = v39;
                theSet = v38;
                v173 = v38;
                v174 = Mutable;
                v175 = dword_10028BA78;
                CFMutableStringRef v176 = v2;
                CFMutableArrayRef v177 = v39;
                CFDictionaryRef theDict = v33;
                CFDictionaryApplyFunction(v33, (CFDictionaryApplierFunction)sub_100110254, &v169);
                CFTypeRef v40 = v151;
                if (CFStringGetLength(v2) >= 1)
                {
                  int v41 = sub_100014F28(v152, v2, v151);
                  int v42 = *((_BYTE *)v197 + 24) ? v41 : 0;
                  *((_BYTE *)v197 + 24) = v42;
                  if (v42 != 1)
                  {
                    int v14 = 0LL;
                    CFTypeRef v28 = 0LL;
                    v153 = 0LL;
                    uint64_t v130 = 8LL;
                    goto LABEL_191;
                  }
                }

                if (v2) {
                  CFRelease(v2);
                }
                CFMutableStringRef v2 = CFStringCreateMutable(0LL, 0LL);
                __int128 v43 = off_10028BA80;
                CFTypeID v44 = &off_1002898F8;
                do
                {
                  uint64_t v45 = v44[2];
                  if (v45)
                  {
                    uint64_t v46 = v44 + 3;
                    do
                    {
                      if ((~LODWORD(v45->data) & 6LL) == 0)
                      {
                        uint64_t v47 = *v43;
                        CFStringAppendFormat(v2, 0LL, @"DROP INDEX IF EXISTS %@%@;", **v43, v45->isa);
                        if (LODWORD(v45->info) == 11) {
                          CFStringAppendFormat(v2, 0LL, @"DROP INDEX IF EXISTS %@%@0;", *v47, v45->isa);
                        }
                      }

                      uint64_t v48 = *v46++;
                      uint64_t v45 = v48;
                    }

                    while (v48);
                  }

                  int v49 = v43[1];
                  ++v43;
                  CFTypeID v44 = v49;
                }

                while (v49);
                CFTypeRef v40 = v151;
                char v50 = sub_100014F28(v152, v2, v151);
                if (*((_BYTE *)v197 + 24)) {
                  char v51 = v50;
                }
                else {
                  char v51 = 0;
                }
                *((_BYTE *)v197 + 24) = v51;
                if ((v51 & 1) == 0)
                {
                  int v14 = 0LL;
                  CFTypeRef v28 = 0LL;
                  v153 = 0LL;
                  uint64_t v130 = 9LL;
                  goto LABEL_191;
                }

                if (v2) {
                  CFRelease(v2);
                }
                int v52 = sub_100105418(v152, (unsigned int *)dword_10028BA78, cf, 0, (uint64_t)v151);
                if (*((_BYTE *)v197 + 24)) {
                  int v53 = v52;
                }
                else {
                  int v53 = 0;
                }
                *((_BYTE *)v197 + 24) = v53;
                if (v53 != 1)
                {
                  int v14 = 0LL;
                  CFMutableStringRef v2 = 0LL;
                  CFTypeRef v28 = 0LL;
                  v153 = 0LL;
                  uint64_t v130 = 10LL;
                  goto LABEL_191;
                }

                int v14 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
                v160 = _NSConcreteStackBlock;
                uint64_t v161 = 0x40000000LL;
                v162 = sub_100110404;
                v163 = &unk_10028F9B0;
                v164 = (__CFString **)v14;
                CFSetApplyFunction(v38, (CFSetApplierFunction)sub_10010D388, &v160);
                CFMutableStringRef v2 = 0LL;
                CFIndex v54 = 0LL;
                CFTypeRef v28 = 0LL;
                v153 = 0LL;
                CFTypeID v55 = @"%@";
                while (2)
                {
                  if (v54 >= CFArrayGetCount(v14))
                  {
                    if (v2) {
                      CFRelease(v2);
                    }
                    CFMutableStringRef v2 = CFStringCreateMutable(0LL, 0LL);
                    v200.tv_sec = (__darwin_time_t)_NSConcreteStackBlock;
                    *(void *)&v200.tv_usec = 0x40000000LL;
                    v201 = sub_100110838;
                    v202 = &unk_10028F990;
                    v203 = v36;
                    v204 = v16;
                    CFMutableStringRef v205 = v2;
                    CFSetApplyFunction(theSet, (CFSetApplierFunction)sub_10010D388, &v200);
                    if (CFStringGetLength(v2) < 1) {
                      goto LABEL_106;
                    }
                    char v77 = sub_100014F28(v152, v2, v40);
                    char v78 = *((_BYTE *)v197 + 24) ? v77 : 0;
                    *((_BYTE *)v197 + 24) = v78;
                    if ((v78 & 1) != 0) {
                      goto LABEL_106;
                    }
                    uint64_t v130 = 13LL;
LABEL_191:
                    LKAReportKeychainUpgradeOutcomeWithError(v142, 2060LL, v130, *v40);
                    goto LABEL_106;
                  }

                  ValueAtIndex = CFArrayGetValueAtIndex(v14, v54);
                  int v57 = *(__darwin_time_t **)&v16[2 * (int)CFDictionaryGetValue(v36, ValueAtIndex) + 2];
                  v157 = *(void **)&dword_10028BA78[2 * (int)CFDictionaryGetValue(theDict, ValueAtIndex) + 2];
                  CFTypeRef v58 = (os_log_s *)sub_10001267C("upgr");
                  if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
                  {
                    __darwin_time_t v59 = *v57;
                    LODWORD(v200.tv_sec) = 138412290;
                    *(__darwin_time_t *)((char *)&v200.tv_sec + 4) = v59;
                    _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_DEFAULT,  "Upgrading table %@",  (uint8_t *)&v200,  0xCu);
                  }

                  if (v57[2])
                  {
                    uint64_t v60 = 0LL;
                    while (v57[v60++ + 3])
                      ;
                    uint64_t v62 = v60;
                    if (!v28) {
                      goto LABEL_70;
                    }
                  }

                  else
                  {
                    uint64_t v62 = 0LL;
                    if (!v28)
                    {
LABEL_70:
                      __int128 v64 = v55;
                      uint64_t v65 = v14;
                      uint64_t v66 = v62;
                      CFTypeRef v28 = (uint64_t *)malloc(8 * v62 + 24);
                      *CFTypeRef v28 = (uint64_t)CFStringCreateWithFormat(0LL, 0LL, @"%@_old", *v57);
                      *((_BYTE *)v28 + 8) = *((_BYTE *)v57 + 8);
                      if ((v62 & 0x80000000) == 0)
                      {
                        do
                        {
                          v28[v66 + 2] = v57[v66 + 2];
                          --v66;
                        }

                        while (v66 != -1);
                      }

                      if (*((_BYTE *)v57 + 8))
                      {
                        CFTypeRef v40 = v151;
                        int v14 = v65;
                        if (v153) {
                          sub_1000F8150(v153, 0LL);
                        }
                        CFRange v11 = &v169;
                        CFTypeID v55 = v64;
                        if (qword_1002DEA80 != -1) {
                          dispatch_once(&qword_1002DEA80, &stru_1002865A8);
                        }
                        uint64_t v67 = (CFDictionaryRef *)sub_1000F82CC( (uint64_t)v28,  (const void *)qword_1002DEA88,  0LL,  0LL,  (__CFString **)v151);
                        if (!v67) {
                          goto LABEL_186;
                        }
                        v160 = _NSConcreteStackBlock;
                        uint64_t v161 = 0x40000000LL;
                        v162 = sub_10011040C;
                        v163 = &unk_10028F970;
                        v164 = (__CFString **)v195;
                        v165 = &v196;
                        v166 = v157;
                        v167 = v151;
                        uint64_t v168 = v152;
                        v153 = (const void **)v67;
                        BOOL v68 = sub_1000EA68C(v67, v152, v151, &stru_10028F908, &stru_10028F948, 0LL, 0LL, (uint64_t)&v160);
                        if (*((_BYTE *)v197 + 24)) {
                          BOOL v69 = v68;
                        }
                        else {
                          BOOL v69 = 0;
                        }
                        *((_BYTE *)v197 + 24) = v69;
                        if (!v69)
                        {
                          uint64_t v130 = 11LL;
                          char v36 = Mutable;
                          goto LABEL_191;
                        }

                        char v36 = Mutable;
                      }

                      else
                      {
                        int v14 = v65;
                        if (v2) {
                          CFRelease(v2);
                        }
                        CFMutableStringRef v2 = CFStringCreateMutable(0LL, 0LL);
                        char v70 = CFStringCreateMutable(0LL, 0LL);
                        uint64_t v71 = v28[2];
                        CFTypeID v55 = v64;
                        if (v71)
                        {
                          char v72 = 0;
                          uint64_t v73 = v28 + 3;
                          do
                          {
                            if ((*(_BYTE *)(v71 + 16) & 2) != 0)
                            {
                              if ((v72 & 1) != 0) {
                                CFStringAppendFormat(v70, 0LL, @",");
                              }
                              CFStringAppendFormat(v70, 0LL, v64, *(void *)v71);
                              char v72 = 1;
                            }

                            uint64_t v74 = *v73++;
                            uint64_t v71 = v74;
                          }

                          while (v74);
                        }

                        CFStringAppendFormat( v2,  0LL,  @"INSERT OR REPLACE INTO %@ (%@) SELECT %@ FROM %@;",
                          *v157,
                          v70,
                          v70,
                          *v28);
                        if (v70) {
                          CFRelease(v70);
                        }
                        CFTypeRef v40 = v151;
                        int v75 = sub_100014F28(v152, v2, v151);
                        CFRange v11 = &v169;
                        if (*((_BYTE *)v197 + 24)) {
                          int v76 = v75;
                        }
                        else {
                          int v76 = 0;
                        }
                        *((_BYTE *)v197 + 24) = v76;
                        char v36 = Mutable;
                        if (v76 != 1)
                        {
                          uint64_t v130 = 12LL;
                          goto LABEL_191;
                        }
                      }

                      ++v54;
                      continue;
                    }
                  }

                  break;
                }

                uint64_t v63 = (const void *)*v28;
                if (*v28)
                {
                  *CFTypeRef v28 = 0LL;
                  CFRelease(v63);
                }

                free(v28);
                goto LABEL_70;
              }
            }

            uint64_t v128 = _os_assert_log(0LL);
            _os_crash(v128);
            __break(1u);
          }

          uint64_t v129 = _os_assert_log(0LL);
          _os_crash(v129);
          __break(1u);
LABEL_186:
          v153 = 0LL;
          char v36 = Mutable;
LABEL_106:
          int v79 = *((unsigned __int8 *)v11[32] + 24);
          int64_t v80 = (int64_t)v11[28][3];
          uint64_t v81 = 1LL;
          if (v80 >= 101)
          {
            unint64_t v82 = (unint64_t)v11[28][3];
            do
            {
              int64_t v80 = v82 / 0xA;
              v81 *= 10LL;
              BOOL v83 = v82 > 0x3F1;
              v82 /= 0xAuLL;
            }

            while (v83);
          }

          uint64_t v84 = v81 * v80;
          uint64_t v85 = sub_10010D10C((uint64_t)&v194);
          if (v79) {
            uint64_t v86 = @"com.apple.keychain.phase1.migrated-items-success";
          }
          else {
            uint64_t v86 = @"com.apple.keychain.phase1.migrated-items-fail";
          }
          if (v79) {
            v87 = @"com.apple.keychain.phase1.migrated-time-success";
          }
          else {
            v87 = @"com.apple.keychain.phase1.migrated-time-fail";
          }
          SecCoreAnalyticsSendValue(v86, v84);
          SecCoreAnalyticsSendValue(v87, v85);
          if (v153) {
            sub_1000F8150(v153, 0LL);
          }
          uint64_t v4 = v149;
          if (v2) {
            CFRelease(v2);
          }
          BOOL v12 = &qword_100205000;
          if (cf) {
            CFRelease(cf);
          }
          a2 = v148;
          if (v28)
          {
            v88 = (const void *)*v28;
            if (*v28)
            {
              *CFTypeRef v28 = 0LL;
              CFRelease(v88);
            }

            free(v28);
          }

          if (v14) {
            CFRelease(v14);
          }
          if (theSet) {
            CFRelease(theSet);
          }
          if (v36) {
            CFRelease(v36);
          }
          if (theDict) {
            CFRelease(theDict);
          }
          int v89 = *((unsigned __int8 *)v11[32] + 24);
          _Block_object_dispose(v195, 8);
          _Block_object_dispose(&v196, 8);
          *(_BYTE *)(*(void *)(*(void *)(v149 + 32) + 8LL) + 24LL) = v89;
          if (v89)
          {
            kdebug_trace(726794284LL, 0LL, 0LL, 0LL, 0LL);
            unsigned int v13 = v144;
            unsigned int v6 = v143;
            goto LABEL_135;
          }

          v140 = (os_log_s *)sub_10001267C("SecError");
          if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v141 = *(void *)(*(void *)(*(void *)(v149 + 40) + 8LL) + 24LL);
            *(_DWORD *)__int128 buf = 138412290;
            *(void *)&uint8_t buf[4] = v141;
            v135 = "upgrade: Upgrade phase1 failed: %@";
            v136 = v140;
            uint32_t v137 = 12;
            goto LABEL_204;
          }

          goto LABEL_16;
        }

LABEL_135:
        unsigned int v156 = v13;
        BOOL v154 = v6 < 0x10000;
        v11[31] = 0LL;
        kdebug_trace(726794288LL, 0LL, 0LL, 0LL, 0LL);
        int v90 = *(__CFString **)(v4 + 72);
        uint64_t v91 = v159;
        off_1002DE618();
        v93 = v92;
        uint64_t v158 = *v92;
        uint64_t *v92 = v94;
        v11[17] = 0LL;
        v11[18] = (void **)&context;
        v95 = (void **)v12[5];
        v11[19] = v95;
        LOBYTE(v189) = 1;
        v11[9] = 0LL;
        v11[10] = (void **)&v178;
        v11[11] = v95;
        v11[12] = 0LL;
        memset(&v200, 170, sizeof(v200));
        gettimeofday(&v200, 0LL);
        v96 = 0LL;
        v97 = &off_1002898F8;
        v98 = off_10028BA88;
        while (!LOBYTE(v90->isa))
        {
          if (*((_BYTE *)v97 + 8))
          {
            uint64_t v99 = sub_1000E6D50(v97, 14LL, &v196);
            if (v99)
            {
              uint64_t v100 = v99;
              if (v96) {
                sub_1000F8150(v96, 0LL);
              }
              uint64_t v101 = (uint64_t)*(v98 - 1);
              if (qword_1002DEA80 != -1) {
                dispatch_once(&qword_1002DEA80, &stru_1002865A8);
              }
              v102 = (CFDictionaryRef *)sub_1000F82CC(v101, (const void *)qword_1002DEA88, 0LL, 0LL, &v196);
              if (!v102)
              {
                *(_BYTE *)(v187 + 24) = 0;
                a2 = v148;
                uint64_t v110 = v158;
                goto LABEL_156;
              }

              v96 = (const void **)v102;
              uint64_t v103 = *v93;
              v169 = _NSConcreteStackBlock;
              uint64_t v170 = 0x40000000LL;
              v171 = sub_10011088C;
              v172 = &unk_10028FA10;
              v173 = (const __CFSet *)v100;
              v160 = _NSConcreteStackBlock;
              uint64_t v161 = 0x40000000LL;
              v162 = sub_1001108E4;
              v163 = &unk_10028FA30;
              v164 = &v196;
              *(void *)__int128 buf = _NSConcreteStackBlock;
              *(void *)&uint8_t buf[8] = 0x40000000LL;
              *(void *)&buf[16] = sub_100110958;
              v207 = &unk_10028FA58;
              v208 = &v178;
              p_context = &context;
              v210 = &v196;
              v211 = (int *)v102;
              CFMutableStringRef v212 = v90;
              uint64_t v213 = v91 | 0x80C00000000LL;
              BOOL v104 = sub_1000EA68C( v102,  v103,  (CFTypeRef *)&v196,  0LL,  &stru_10028F9F0,  (uint64_t)&v169,  (uint64_t)&v160,  (uint64_t)buf);
              BOOL v105 = *(_BYTE *)(v187 + 24) && v104;
              *(_BYTE *)(v187 + 24) = v105;
              if (!v105)
              {
                LKAReportKeychainUpgradeOutcomeWithError(v91, 2060LL, 14LL, v196);
                a2 = v148;
                uint64_t v110 = v158;
LABEL_155:
                sub_1000F8150(v96, 0LL);
                goto LABEL_156;
              }
            }
          }

          v106 = *v98++;
          v97 = v106;
          if (!v106) {
            break;
          }
        }

        int64_t v107 = *(void *)(v179 + 24);
        uint64_t v108 = 1LL;
        if (v107 < 101)
        {
          a2 = v148;
          uint64_t v110 = v158;
        }

        else
        {
          unint64_t v109 = *(void *)(v179 + 24);
          a2 = v148;
          uint64_t v110 = v158;
          do
          {
            int64_t v107 = v109 / 0xA;
            v108 *= 10LL;
            BOOL v83 = v109 > 0x3F1;
            v109 /= 0xAuLL;
          }

          while (v83);
        }

        uint64_t v111 = v108 * v107;
        uint64_t v112 = sub_10010D10C((uint64_t)&v200);
        SecCoreAnalyticsSendValue(@"com.apple.keychain.phase2.migrated-items", v111);
        SecCoreAnalyticsSendValue(@"com.apple.keychain.phase2.migrated-time", v112);
        if (v96) {
          goto LABEL_155;
        }
LABEL_156:
        uint64_t *v93 = v110;
        char v113 = *(_BYTE *)(v187 + 24);
        _Block_object_dispose(&v178, 8);
        _Block_object_dispose(&context, 8);
        uint64_t v4 = v149;
        *(_BYTE *)(*(void *)(*(void *)(v149 + 32) + 8LL) + 24LL) = v113;
        if (*(_BYTE *)(*(void *)(*(void *)(v149 + 32) + 8LL) + 24LL)) {
          goto LABEL_157;
        }
        if (v147)
        {
          v115 = v196;
          if (v196)
          {
            uint64_t v116 = *(void *)(*(void *)(v149 + 40) + 8LL);
            v117 = *(__CFError **)(v116 + 24);
            if (v117)
            {
              if (CFErrorGetCode(v117) == -25330)
              {
                v118 = *(const void **)(v116 + 24);
                if (!v118) {
                  goto LABEL_183;
                }
                *(void *)(v116 + 24) = 0LL;
                CFRelease(v118);
              }

              if (*(void *)(v116 + 24))
              {
                v119 = v115;
LABEL_182:
                CFRelease(v119);
                goto LABEL_157;
              }
            }

LABEL_183:
            *(void *)(v116 + 24) = v115;
          }
        }

        else
        {
          **(_BYTE **)(v149 + 72) = 1;
          *(_BYTE *)(*(void *)(*(void *)(v149 + 32) + 8LL) + 24LL) = 1;
          v119 = v196;
          if (v196)
          {
            v196 = 0LL;
            goto LABEL_182;
          }
        }

LABEL_157:
        if (*(_BYTE *)(*(void *)(*(void *)(v149 + 32) + 8LL) + 24LL))
        {
          if (**(_BYTE **)(v149 + 72))
          {
            unsigned int v114 = v156;
          }

          else
          {
            v120 = (os_log_s *)sub_10001267C("upgr");
            if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
            {
              int v121 = **(_DWORD **)(v149 + 64) | (*(_DWORD *)(*(void *)(v149 + 64) + 4LL) << 8);
              *(_DWORD *)__int128 buf = 67109376;
              *(_DWORD *)&uint8_t buf[4] = v156;
              *(_WORD *)&uint8_t buf[8] = 1024;
              *(_DWORD *)&buf[10] = v121;
              _os_log_impl( (void *)&_mh_execute_header,  v120,  OS_LOG_TYPE_DEFAULT,  "Done upgrading from version 0x%x to 0x%x",  buf,  0xEu);
            }

            *(_BYTE *)(*(void *)(*(void *)(v149 + 48) + 8LL) + 24LL) = 1;
            kdebug_trace(726794292LL, 0LL, 0LL, 0LL, 0LL);
            unsigned int v114 = 0;
          }

          uint64_t v122 = v159 | (v114 << 16);
          uint64_t v123 = (v114 << 8) & 0xFF0000 | BYTE1(v159);
          v124 = (os_log_s *)sub_10001267C("upgr");
          if (os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 67109376;
            *(_DWORD *)&uint8_t buf[4] = v122;
            *(_WORD *)&uint8_t buf[8] = 1024;
            *(_DWORD *)&buf[10] = v123;
            _os_log_impl( (void *)&_mh_execute_header,  v124,  OS_LOG_TYPE_DEFAULT,  "Upgrading saving version major 0x%x minor 0x%x",  buf,  0xEu);
          }

          BOOL v23 = CFStringCreateWithFormat(0LL, 0LL, @"UPDATE tversion SET version='%d', minor='%d'", v122, v123);
          char v125 = sub_100014F28( *(void *)(v149 + 56),  v23,  (CFTypeRef *)(*(void *)(*(void *)(v149 + 40) + 8LL) + 24LL));
          *(_BYTE *)(*(void *)(*(void *)(v149 + 32) + 8LL) + 24LL) = v125;
          if ((v125 & 1) == 0)
          {
            v138 = (os_log_s *)sub_10001267C("SecError");
            if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v139 = *(void *)(*(void *)(*(void *)(v149 + 40) + 8LL) + 24LL);
              *(_DWORD *)__int128 buf = 138412290;
              *(void *)&uint8_t buf[4] = v139;
              _os_log_impl( (void *)&_mh_execute_header,  v138,  OS_LOG_TYPE_DEFAULT,  "upgrade: Setting version failed: %@",  buf,  0xCu);
            }
          }

          goto LABEL_174;
        }

        v133 = (os_log_s *)sub_10001267C("SecError");
        if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v134 = *(void *)(*(void *)(*(void *)(v149 + 40) + 8LL) + 24LL);
          *(_DWORD *)__int128 buf = 67109378;
          *(_DWORD *)&uint8_t buf[4] = v154;
          *(_WORD *)&uint8_t buf[8] = 2112;
          *(void *)&buf[10] = v134;
          v135 = "upgrade: Upgrade phase2 (%d) failed: %@";
          v136 = v133;
          uint32_t v137 = 18;
LABEL_204:
          _os_log_impl((void *)&_mh_execute_header, v136, OS_LOG_TYPE_DEFAULT, v135, buf, v137);
        }

void sub_10010FB08(uint64_t a1)
{
  CFTypeRef cf = 0LL;
    && sub_100014F28( a1,  @"CREATE INDEX IF NOT EXISTS agrp_musr_tomb_svce ON genp(agrp, musr, tomb, svce);",
                       &cf)
    && sub_100014F28( a1,  @"CREATE INDEX IF NOT EXISTS agrp_musr_tomb_srvr ON inet(agrp, musr, tomb, srvr);",
                       &cf)
    && sub_100014F28( a1,  @"CREATE INDEX IF NOT EXISTS agrp_musr_tomb_subj ON cert(agrp, musr, tomb, subj);",
                       &cf)
    && sub_100014F28( a1,  @"CREATE INDEX IF NOT EXISTS agrp_musr_tomb_atag ON keys(agrp, musr, tomb, atag);",
                       &cf)
    && sub_100014F28( a1,  @"CREATE INDEX IF NOT EXISTS synckeys_contextID_ckzone_keyclass_state ON synckeys(contextID, ckzone, keyclass, state);",
                       &cf)
    && sub_100014F28( a1,  @"CREATE INDEX IF NOT EXISTS incomingqueue_contextID_ckzone_UUID ON incomingqueue(contextID, ckzone, UUID);",
                       &cf)
    && sub_100014F28( a1,  @"CREATE INDEX IF NOT EXISTS incomingqueue_contextID_ckzone_state ON incomingqueue(contextID, ckzone, state);",
                       &cf)
    && sub_100014F28( a1,  @"CREATE INDEX IF NOT EXISTS incomingqueue_contextID_ckzone_parentkeyUUID ON incomingqueue(contextID, ckzone, parentKeyUUID);",
                       &cf)
    && sub_100014F28( a1,  @"CREATE INDEX IF NOT EXISTS outgoingqueue_contextID_ckzone_UUID ON outgoingqueue(contextID, ckzone, UUID);",
                       &cf)
    && sub_100014F28( a1,  @"CREATE INDEX IF NOT EXISTS outgoingqueue_contextID_ckzone_state ON outgoingqueue(contextID, ckzone, state);",
                       &cf)
    && sub_100014F28( a1,  @"CREATE INDEX IF NOT EXISTS outgoingqueue_contextID_ckzone_parentkeyUUID ON outgoingqueue(contextID, ckzone, parentKeyUUID);",
                       &cf)
    && sub_100014F28( a1,  @"CREATE INDEX IF NOT EXISTS ckmirror_contextID_ckzone_UUID ON ckmirror(contextID, ckzone, UUID);",
                       &cf)
    && sub_100014F28( a1,  @"CREATE INDEX IF NOT EXISTS ckmirror_contextID_ckzone_parentkeyUUID ON ckmirror(contextID, ckzone, parentKeyUUID);",
                       &cf)
    && sub_100014F28(a1, @"DROP INDEX IF EXISTS ckstatecontextID;", &cf))
  {
    CFMutableStringRef v2 = (os_log_s *)sub_10001267C("upgr");
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_42;
    }
    *(_WORD *)__int128 buf = 0;
    uint64_t v3 = "processed custom indexes (now or in the past)";
    uint64_t v4 = v2;
    uint32_t v5 = 2;
    goto LABEL_41;
  }

  uint64_t v7 = (os_log_s *)sub_10001267C("SecError");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412290;
    CFTypeRef v10 = cf;
    uint64_t v3 = "upgr: failed to process custom indexes: %@";
    uint64_t v4 = v7;
    uint32_t v5 = 12;
LABEL_41:
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v3, buf, v5);
  }

void sub_10010FF90(uint64_t a1, uint64_t a2)
{
  if (byte_1002DEAF0 == 1)
  {
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(+[OTManager manager](&OBJC_CLASS___OTManager, "manager"));
    [v3 initializeOctagon];
    [v3 setupAnalytics];
  }

  if (sub_100098648(a1, a2))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    uint32_t v5 = objc_autoreleasePoolPush();
    CFTypeRef v6 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSViewManager manager](&OBJC_CLASS___CKKSViewManager, "manager"));
    [v6 setupAnalytics];
    sub_100014EB8(v4, &stru_100284A28);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v6 completedSecCKKSInitialize]);
    [v7 fulfill];

    if (qword_1002DE970 != -1) {
      dispatch_once(&qword_1002DE970, &stru_100284A48);
    }

    objc_autoreleasePoolPop(v5);
  }

void sub_10011007C(id a1)
{
  CFDataRef v1 = sub_10001267C("escrowrequest");
  CFMutableStringRef v2 = (os_log_s *)objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFTypeRef v6 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "performing EscrowRequestServerInitialize",  v6,  2u);
  }

  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(+[EscrowRequestServer server](&OBJC_CLASS___EscrowRequestServer, "server"));
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 controller]);
  uint32_t v5 = (void *)objc_claimAutoreleasedReturnValue([v4 stateMachine]);
  [v5 startOperation];
}

void sub_10011012C(uint64_t a1, const void *a2, int a3)
{
  value = (void *)0xAAAAAAAAAAAAAAAALL;
  if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(a1 + 32), a2, (const void **)&value))
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8LL * a3 + 8);
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8LL * (int)value + 8);
    if (CFEqual(*(CFTypeRef *)v6, *(CFTypeRef *)v7) && *(unsigned __int8 *)(v6 + 8) == *(unsigned __int8 *)(v7 + 8))
    {
      uint64_t v8 = *(void *)(v7 + 16);
      uint64_t v9 = *(void *)(v6 + 16);
      if (v9) {
        BOOL v10 = v8 == 0;
      }
      else {
        BOOL v10 = 1;
      }
      if (v10)
      {
LABEL_9:
        if (!(v9 | v8)) {
          return;
        }
      }

      else
      {
        CFRange v11 = (uint64_t *)(v7 + 24);
        BOOL v12 = (uint64_t *)(v6 + 24);
        while (CFEqual(*(CFTypeRef *)v9, *(CFTypeRef *)v8)
             && *(_DWORD *)(v9 + 8) == *(_DWORD *)(v8 + 8)
             && *(void *)(v9 + 16) == *(void *)(v8 + 16)
             && *(void *)(v9 + 24) == *(void *)(v8 + 24)
             && *(void *)(v9 + 32) == *(void *)(v8 + 32))
        {
          uint64_t v13 = *v11++;
          uint64_t v8 = v13;
          uint64_t v14 = *v12++;
          uint64_t v9 = v14;
          if (!v14 || !v8) {
            goto LABEL_9;
          }
        }
      }
    }

    CFSetAddValue(*(CFMutableSetRef *)(a1 + 56), a2);
  }

uint64_t sub_100110254(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_10011026C(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void **)(*(void *)(a1 + 40) + 8LL * (int)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2) + 8);
  Value = (const void *)(int)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), a2);
  CFStringAppendFormat( *(CFMutableStringRef *)(a1 + 64),  0LL,  @"ALTER TABLE %@ RENAME TO %@_old;",
    **(void **)(*(void *)(a1 + 56) + 8LL * (void)Value + 8),
    *v4);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 72), Value);
}

void sub_1001102F4(uint64_t a1, const void *a2, int a3)
{
  if (!CFSetContainsValue(*(CFSetRef *)(a1 + 32), a2) && !CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 40), a2)) {
    CFStringAppendFormat( *(CFMutableStringRef *)(a1 + 56),  0LL,  @"DROP TABLE IF EXISTS %@;",
  }
      **(void **)(*(void *)(a1 + 48) + 8LL * a3 + 8));
}

void sub_10011036C(uint64_t a1, const void *a2, int a3)
{
  if (!CFSetContainsValue(*(CFSetRef *)(a1 + 32), a2) && !CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 40), a2))
  {
    CFStringAppendFormat( *(CFMutableStringRef *)(a1 + 56),  0LL,  @"DROP TABLE IF EXISTS %@;",
      **(void **)(*(void *)(a1 + 48) + 8LL * a3 + 8));
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 64), (const void *)a3);
  }

void sub_100110404(uint64_t a1, const void *a2)
{
}

void sub_10011040C(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  CFTypeRef cf = 0LL;
  ++*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  *(void *)(a2 + 16) = *(void *)(a1 + 48);
  uint64_t v6 = sub_1000E7EC0((void *)a2, kSecAttrAccessible);
  uint64_t v7 = v6;
  if (v6) {
    BOOL v8 = kSecAttrAccessibleAlwaysPrivate == 0LL;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {
  }

  else if (CFEqual(v6, kSecAttrAccessibleAlwaysPrivate))
  {
    goto LABEL_17;
  }

  if (v7) {
    BOOL v10 = kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate == 0LL;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10)
  {
    if (CFEqual(v7, kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate)) {
      goto LABEL_17;
    }
LABEL_15:
    *(_DWORD *)(a2 + 40) = 5;
    goto LABEL_25;
  }

void sub_100110838(uint64_t a1, const void *a2)
{
  signed int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
  CFStringAppendFormat( *(CFMutableStringRef *)(a1 + 48),  0LL,  @"DROP TABLE %@_old;",
    **(void **)(*(void *)(a1 + 40) + 8LL * Value + 8));
}

uint64_t sub_10011088C(uint64_t a1, __CFString *a2, _BYTE *a3)
{
  return 1LL;
}

uint64_t sub_1001108E4(uint64_t a1, sqlite3_stmt *a2, uint64_t a3)
{
  int v3 = a3;
  uint64_t result = sub_1000182E4(a2, a3, kSecAttrAccessibleAlwaysPrivate, *(CFTypeRef **)(a1 + 32));
  if ((_DWORD)result) {
    return sub_1000182E4( a2,  (v3 + 1),  kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate,  *(CFTypeRef **)(a1 + 32));
  }
  return result;
}

void sub_100110958(uint64_t a1, uint64_t a2, BOOL *a3)
{
  CFErrorRef err = 0LL;
  ++*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (sub_1000E714C(a2, 1, (__CFString **)&err))
  {
    uint64_t v6 = (void *)sub_1000E6D50(*(void **)(a2 + 16), 7LL, *(__CFString ***)(a1 + 48));
    int v7 = sub_1000E7958(a2, v6, kCFNull, (__CFString **)&err);
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = v7;
    if (!v7) {
      goto LABEL_50;
    }
    BOOL v8 = (const __CFString *)sub_1000E7EC0((void *)a2, kSecAttrAccessGroup);
    if (v8) {
      BOOL v9 = kSecAttrAccessGroupToken == 0LL;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9)
    {
      if (v8 != kSecAttrAccessGroupToken) {
        goto LABEL_12;
      }
    }

    else if (!CFEqual(v8, kSecAttrAccessGroupToken))
    {
      goto LABEL_12;
    }

    if (!sub_1000E7EC0((void *)a2, kSecAttrTokenID))
    {
      BOOL v20 = (os_log_s *)sub_10001267C("upgr");
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138477827;
        *(void *)&uint8_t buf[4] = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "dropping item during item upgrade due to agrp=com.apple.token: %{private}@",  buf,  0xCu);
      }

      off_1002DE618();
      unsigned __int8 v12 = sub_1000ECAF0((CFStringRef **)a2, *v21, kCFBooleanFalse, 0, (CFTypeRef *)&err);
      goto LABEL_13;
    }

BOOL sub_100110E44(id a1, const SecDbAttr *a2)
{
  return 0;
}

BOOL sub_100110E4C(id a1, const SecDbAttr *a2)
{
  return 0;
}

BOOL sub_100110E54(id a1, const SecDbAttr *a2)
{
  return (LOBYTE(a2->var2) >> 1) & 1;
}

BOOL sub_100110E60(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
  v5[0] = _NSConcreteStackBlock;
  v5[2] = sub_100111804;
  v5[3] = &unk_10028F2F8;
  v5[1] = 0x40000000LL;
  v5[4] = v2;
  void v5[5] = a2;
  __int128 v6 = *(_OWORD *)(a1 + 48);
  return sub_100105354(a2, 2LL, (CFTypeRef *)(v3 + 24), (uint64_t)v5);
}

uint64_t sub_100110ECC(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = a4;
  if (a3 && sub_1001110DC(a4) != a3)
  {
    uint64_t v19 = 0LL;
    BOOL v20 = &v19;
    uint64_t v21 = 0x2000000000LL;
    char v22 = 0;
    if (a1)
    {
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 0x40000000LL;
      v18[2] = sub_100111170;
      v18[3] = &unk_10028F3A8;
      v18[4] = a5;
      v18[5] = &v19;
      uint64_t v23 = 0LL;
      sub_1000169DC(a3, 0, &v23, v6);
      uint64_t v10 = v23;
      if (v23)
      {
        sub_100111170((uint64_t)v18);
LABEL_16:
        sub_100017E28(v10);
      }
    }

    else
    {
      v17[0] = _NSConcreteStackBlock;
      v17[1] = 0x40000000LL;
      v17[2] = sub_1001111A4;
      v17[3] = &unk_10028F3D0;
      v17[4] = a5;
      v17[5] = &v19;
      uint64_t v23 = 0LL;
      sub_1000169DC(a3, 1, &v23, v6);
      uint64_t v10 = v23;
      if (v23)
      {
        sub_1001111A4((uint64_t)v17);
        goto LABEL_16;
      }
    }

    uint64_t v6 = *((_BYTE *)v20 + 24) != 0;
    _Block_object_dispose(&v19, 8);
    return v6;
  }

  off_1002DE618();
  if (*v11) {
    return (*(uint64_t (**)(uint64_t))(a5 + 16))(a5);
  }
  uint64_t v13 = v11;
  int v14 = a1 ^ 1;
  if ((v14 & 1) == 0 && a2)
  {
    uint64_t v15 = sub_1001110DC(0LL);
    sub_100101A94(v15);
  }

  uint64_t v16 = sub_1001110DC(v6);
  if (!v16)
  {
    if (!v6) {
      return v6;
    }
    if (!*(void *)v6) {
      sub_1000194E0(-25316, (__CFString **)v6, @"failed to get a db handle");
    }
    return 0LL;
  }

  if (!sub_1000169DC(v16, v14, v13, v6)) {
    return 0LL;
  }
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 16))(a5, *v13);
  sub_100017E28(*v13);
  uint64_t *v13 = 0LL;
  return v6;
}

uint64_t sub_1001110DC(uint64_t a1)
{
  if (qword_1002DEBC0 != -1) {
    dispatch_once(&qword_1002DEBC0, &stru_10028FA98);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_1001111D8;
  block[3] = &unk_10028FAF8;
  block[4] = a1;
  dispatch_sync((dispatch_queue_t)qword_1002DEBC8, block);
  return qword_1002DEBA8;
}

uint64_t sub_100111170(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = result;
  return result;
}

uint64_t sub_1001111A4(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = result;
  return result;
}

void sub_1001111D8(uint64_t a1)
{
  if (!qword_1002DEBA8)
  {
    if (qword_1002DE780 != -1) {
      dispatch_once(&qword_1002DE780, &stru_1002831F8);
    }
    uint64_t v2 = *(void **)(a1 + 32);
    uint64_t v3 = (const void *)qword_1002DEBA8;
    qword_1002DEBA8 = 0LL;
    if ((os_variant_is_recovery("securityd") & 1) != 0)
    {
      uint64_t v4 = @"keychain-recovery-2.db";
    }

    else
    {
      if (qword_1002DEC08 != -1) {
        dispatch_once(&qword_1002DEC08, &stru_10028FFE0);
      }
      if (byte_1002DEC00) {
        uint64_t v4 = @"keychain-2.db";
      }
      else {
        uint64_t v4 = @"keychain-2-debug.db";
      }
      syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0);
    }

    uint32_t v5 = sub_10001B988((uint64_t)v4);
    if (v5)
    {
      uint64_t v6 = v5;
      int v7 = CFURLCopyFileSystemPath(v5, kCFURLPOSIXPathStyle);
      CFRelease(v6);
    }

    else
    {
      int v7 = 0LL;
    }

    BOOL v8 = (os_log_s *)sub_10001267C("__SecKeychainCopyPath");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      if (v7)
      {
        CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
        uint64_t v10 = "<unknown>";
        if (CStringPtr) {
          uint64_t v10 = CStringPtr;
        }
      }

      else
      {
        uint64_t v10 = "<null>";
      }

      *(_DWORD *)__int128 buf = 136315138;
      *(void *)&uint8_t buf[4] = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "path: %s", buf, 0xCu);
    }

    if (v7)
    {
      uint64_t v25 = 0LL;
      uint64_t v26 = &v25;
      uint64_t v27 = 0x2000000000LL;
      uint64_t v28 = 0LL;
      aBlock = _NSConcreteStackBlock;
      uint64_t v21 = 0x40000000LL;
      char v22 = sub_10010DDF0;
      uint64_t v23 = &unk_10028F290;
      BOOL v24 = &v25;
      *(void *)__int128 buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 0x40000000LL;
      *(void *)&buf[16] = sub_100014C6C;
      uint64_t v33 = &unk_100283278;
      char v34 = &qword_1002DE790;
      if (qword_1002DE788 != -1) {
        dispatch_once(&qword_1002DE788, buf);
      }
      uint64_t Instance = _CFRuntimeCreateInstance(kCFAllocatorDefault, qword_1002DE790, 160LL, 0LL);
      if (Instance)
      {
        if (getenv("__OSINSTALL_ENVIRONMENT"))
        {
          unsigned __int8 v12 = (os_log_s *)sub_10001267C("#SecDB");
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_debug_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEBUG,  "SecDB: running from installer",  buf,  2u);
          }

          CFStringRef Copy = @"file::memory:?cache=shared";
        }

        else
        {
          CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, v7);
        }

        *(void *)(Instance + 16) = Copy;
        v30[0] = _NSConcreteStackBlock;
        v30[1] = 0x40000000LL;
        v30[2] = sub_100014E50;
        v30[3] = &unk_100283298;
        v30[4] = Instance;
        *(void *)__int128 buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 0x40000000LL;
        *(void *)&buf[16] = sub_1000134E4;
        uint64_t v33 = &unk_100283030;
        char v34 = v30;
        sub_10001337C(v7, (uint64_t)buf);
        uint64_t v15 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"%@-commit",  v7,  aBlock,  v21,  v22,  v23,  v24,  v25);
        v29[0] = _NSConcreteStackBlock;
        v29[1] = 0x40000000LL;
        v29[2] = sub_100014E80;
        v29[3] = &unk_1002832B8;
        v29[4] = Instance;
        *(void *)__int128 buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 0x40000000LL;
        *(void *)&buf[16] = sub_1000134E4;
        uint64_t v33 = &unk_100283030;
        char v34 = v29;
        sub_10001337C(v15, (uint64_t)buf);
        if (v15) {
          CFRelease(v15);
        }
        *(void *)(Instance + 40) = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
        *(void *)(Instance + 48) = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
        v31.__sig = 0xAAAAAAAAAAAAAAAALL;
        *(void *)v31.__opaque = 0xAAAAAAAAAAAAAAAALL;
        if (pthread_mutexattr_init(&v31) || (uint64_t v16 = &v31, pthread_mutexattr_setpolicy_np(&v31, 1)))
        {
          uint64_t v17 = (os_log_s *)sub_10001267C("SecCritical");
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "SecDb: SecDbCreate failed to create attributes for the write mutex; fairness properties are no longer present",
              buf,
              2u);
          }

          uint64_t v16 = 0LL;
        }

        if (pthread_mutex_init((pthread_mutex_t *)(Instance + 56), v16))
        {
          CFErrorRef v18 = (os_log_s *)sub_10001267C("SecCritical");
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "SecDb: SecDbCreate failed to init the write mutex, this will end badly",  buf,  2u);
          }
        }

        pthread_mutexattr_destroy(&v31);
        *(void *)(Instance + 120) = dispatch_semaphore_create(5LL);
        *(_BYTE *)(Instance + 128) = 0;
        *(void *)(Instance + 136) = _Block_copy(&aBlock);
        *(_BYTE *)(Instance + 144) = 0;
        *(_DWORD *)(Instance + 148) = 0;
        *(void *)(Instance + 152) = 0LL;
        *(_WORD *)(Instance + 160) = 384;
        *(_DWORD *)(Instance + 162) = 16843009;
        *(_BYTE *)(Instance + 166) = 6;
        *(void *)(Instance + 168) = 0LL;
        *(void *)(Instance + 168) = _Block_copy(&stru_10028F2D0);
      }

      if (v2) {
        *uint64_t v2 = v26[3];
      }
      _Block_object_dispose(&v25, 8);
      qword_1002DEBA8 = Instance;
      CFRelease(v7);
    }

    else
    {
      int v14 = (os_log_s *)sub_10001267C("SecError");
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "no keychain path available", buf, 2u);
      }
    }

    if (v3)
    {
      uint64_t v19 = (os_log_s *)sub_10001267C("SecError");
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412546;
        *(void *)&uint8_t buf[4] = v3;
        *(_WORD *)&_BYTE buf[12] = 2112;
        *(void *)&buf[14] = qword_1002DEBA8;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "replaced %@ with %@", buf, 0x16u);
      }

      CFRelease(v3);
    }
  }

void sub_1001117DC(id a1)
{
  qword_1002DEBC8 = (uint64_t)dispatch_queue_create("sec_kc_dbhandle", 0LL);
}

uint64_t sub_100111804(void *a1)
{
  CFTypeRef cf = 0LL;
  uint64_t v1 = a1[5];
  uint64_t v2 = a1[6];
  v34.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&v34.tv_usec = 0xAAAAAAAAAAAAAAAALL;
  gettimeofday(&v34, 0LL);
  uint64_t v3 = off_10028BA80;
  uint64_t v4 = &off_1002898F8;
  do
  {
    if (*((_BYTE *)v4 + 8))
    {
      CStringPtr = CFStringGetCStringPtr(*v4, 0x8000100u);
      uint64_t v6 = sqlite3_mprintf("%q", CStringPtr);
      if (v6)
      {
        int v7 = v6;
        CFStringRef v8 = CFStringCreateWithCString(kCFAllocatorDefault, v6, 0x8000100u);
        sqlite3_free(v7);
        BOOL v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"SELECT * FROM %@ WHERE persistref IS ''", v8);
        uint64_t v30 = 0LL;
        pthread_mutexattr_t v31 = (CFTypeRef *)&v30;
        uint64_t v32 = 0x2000000000LL;
        uint64_t v33 = 0LL;
        uint64_t v26 = 0LL;
        uint64_t v27 = &v26;
        uint64_t v28 = 0x2000000000LL;
        CFMutableArrayRef Mutable = (CFMutableArrayRef)0xAAAAAAAAAAAAAAAALL;
        CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
        v25[0] = _NSConcreteStackBlock;
        v25[1] = 0x40000000LL;
        v25[2] = sub_10010D1D0;
        v25[3] = &unk_10028F178;
        v25[4] = &v30;
        v25[5] = &v26;
        v25[6] = v1;
        v25[7] = v2;
        sub_100015B70(v1, v9, v31 + 3, (uint64_t)v25);
        if (v9) {
          CFRelease(v9);
        }
        v23[0] = 0LL;
        v23[1] = v23;
        v23[2] = 0x2000000000LL;
        char v24 = 0;
        uint64_t v10 = (const __CFArray *)v27[3];
        *(void *)&__int128 context = _NSConcreteStackBlock;
        *((void *)&context + 1) = 0x40000000LL;
        uint64_t v36 = sub_10010D238;
        __int16 v37 = &unk_10028F268;
        CFTypeRef v38 = v23;
        CFMutableArrayRef v39 = v3;
        uint64_t v40 = v1;
        p_CFTypeRef cf = &cf;
        uint64_t v42 = v2;
        v43.length = CFArrayGetCount(v10);
        v43.location = 0LL;
        CFArrayApplyFunction(v10, v43, (CFArrayApplierFunction)sub_10010D388, &context);
        if (v8) {
          CFRelease(v8);
        }
        CFRange v11 = (const void *)v27[3];
        if (v11)
        {
          v27[3] = 0LL;
          CFRelease(v11);
        }

        CFTypeRef v12 = v31[3];
        if (v12)
        {
          v31[3] = 0LL;
          CFRelease(v12);
        }

        _Block_object_dispose(v23, 8);
        _Block_object_dispose(&v26, 8);
        _Block_object_dispose(&v30, 8);
      }
    }

    uint64_t v13 = v3[1];
    ++v3;
    uint64_t v4 = v13;
  }

  while (v13);
  uint64_t v14 = sub_10010D10C((uint64_t)&v34);
  SecCoreAnalyticsSendValue(@"com.apple.keychain.phase3.add-uuid-persistentref-to-items", 0LL);
  SecCoreAnalyticsSendValue(@"com.apple.keychain.phase3.migrated-time", v14);
  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = 1;
  if (cf)
  {
    uint64_t v15 = (os_log_s *)sub_10001267C("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(context) = 138412290;
      *(void *)((char *)&context + 4) = cf;
      _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "upgr-phase3: failed to perform persistent ref upgrade for keychain item(s): %@",  (uint8_t *)&context,  0xCu);
    }

    CFTypeRef v16 = cf;
    if (cf)
    {
      CFRetain(cf);
      uint64_t v17 = (void *)a1[7];
      if (v17 && !*v17) {
        *uint64_t v17 = v16;
      }
      else {
        CFRelease(v16);
      }
      CFTypeRef v19 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
        CFRelease(v19);
      }
    }
  }

  else
  {
    CFErrorRef v18 = (os_log_s *)sub_10001267C("upgr-phase3");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(context) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "finished upgrading keychain items' persistent refs",  (uint8_t *)&context,  2u);
    }
  }

  return 1LL;
}

void sub_100111BA8(id a1)
{
  uint64_t v1 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  qword_1002DEBD8 = (uint64_t)dispatch_queue_create("sec_async_db", v1);
}

unint64_t sub_100111BDC(uint64_t a1, uint64_t a2, uint64_t a3, CFDictionaryRef theDict)
{
  if (*(void *)(a2 + 176))
  {
    signed int Value = CFDictionaryGetValue(theDict, kSecAttrIssuer);
  }

  if (!*(void *)(a2 + 200)) {
    goto LABEL_6;
  }
  if (*(__CFString ***)a2 == &off_10028B168)
  {
    CFRange v11 = &off_10028B168;
  }

  else
  {
    BOOL v9 = *(__CFString ***)a2;
    if (v9 != (__CFString **)sub_10010C560((uint64_t)@"cert", &qword_1002DEB48, (uint64_t)&unk_1002DEB40))
    {
LABEL_6:
      SecCertificateRef v10 = 0LL;
      goto LABEL_36;
    }

    CFRange v11 = *(__CFString ***)a2;
  }

  SecCertificateRef v12 = sub_1001124D4(v11, theDict);
  if (!v12) {
    return 0LL;
  }
  SecCertificateRef v10 = v12;
  uint64_t v13 = *(void **)(a2 + 200);
  uint64_t v14 = *(const void **)(a2 + 208);
  SecTrustRef trust = 0LL;
  values[0] = v12;
  if (!v13) {
    goto LABEL_108;
  }
  SecTrustResultType result = -1431655766;
  CFArrayRef v15 = CFArrayCreate(0LL, (const void **)values, 1LL, &kCFTypeArrayCallBacks);
  if (SecTrustCreateWithCertificates(v15, v13, &trust)
    || v14 && (CFTypeID v16 = CFGetTypeID(v14), v16 == CFDateGetTypeID()) && SecTrustSetVerifyDate(trust, (CFDateRef)v14))
  {
    BOOL v21 = 0;
    goto LABEL_30;
  }

  uint64_t v17 = SecPolicyCopyProperties((SecPolicyRef)v13);
  CFErrorRef v18 = v17;
  if (v17)
  {
    CFTypeRef v19 = CFDictionaryGetValue(v17, kSecPolicyOid);
    if (v19)
    {
      BOOL v20 = v19;
      if (CFEqual(v19, kSecPolicyAppleX509Basic) || CFEqual(v20, kSecPolicyAppleRevocation))
      {
        if (SecTrustEvaluate(trust, &result))
        {
          BOOL v21 = 0;
LABEL_29:
          CFRelease(v18);
          goto LABEL_30;
        }

        goto LABEL_22;
      }
    }
  }

  if (!SecTrustEvaluateLeafOnly(trust, &result))
  {
LABEL_22:
    BOOL v21 = result == kSecTrustResultUnspecified || result == kSecTrustResultProceed;
    if (v18) {
      goto LABEL_29;
    }
    goto LABEL_30;
  }

  BOOL v21 = 0;
  if (v18) {
    goto LABEL_29;
  }
LABEL_30:
  if (v15) {
    CFRelease(v15);
  }
  if (trust)
  {
    CFRelease(trust);
    if (!v21) {
      goto LABEL_108;
    }
  }

  else if (!v21)
  {
    goto LABEL_108;
  }

LABEL_108:
        unint64_t HasSuffix = 0LL;
LABEL_109:
        CFRelease(v10);
        return HasSuffix;
      }

      return 0LL;
    }
  }

LABEL_77:
  if (!*(void *)(a2 + 240)
    || (CFTypeRef v38 = *(__CFString ***)a2,
        v38 != (__CFString **)sub_10010C560((uint64_t)@"inet", &qword_1002DEB38, (uint64_t)&unk_1002DEB30)))
  {
LABEL_79:
    unint64_t HasSuffix = 1LL;
    goto LABEL_80;
  }

  uint64_t v46 = (const __CFString *)CFDictionaryGetValue(theDict, kSecAttrServer);
  if (!v46) {
    return 0LL;
  }
  uint64_t v47 = v46;
  CFTypeID v48 = CFGetTypeID(v46);
  if (v48 != CFStringGetTypeID()) {
    return 0LL;
  }
  unint64_t HasSuffix = *(void *)(a2 + 240);
  if (HasSuffix)
  {
    if (CFEqual(v47, (CFTypeRef)HasSuffix)) {
      goto LABEL_79;
    }
    CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
    CFStringAppend(Mutable, @".");
    CFStringAppend(Mutable, (CFStringRef)HasSuffix);
    unint64_t HasSuffix = CFStringHasSuffix(v47, Mutable);
    if (Mutable) {
      CFRelease(Mutable);
    }
    if ((_DWORD)HasSuffix) {
      goto LABEL_79;
    }
  }

  return HasSuffix;
}

  CFTypeID v44 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  self->_timestampSslStart));
  [v3 setObject:v44 forKey:@"timestamp_ssl_start"];

  CFTypeRef v19 = self->_has;
  if ((*(_WORD *)&v19 & 0x800) == 0)
  {
LABEL_40:
    if ((*(_WORD *)&v19 & 0x400) == 0) {
      goto LABEL_41;
    }
    goto LABEL_79;
  }

  PBDataWriterWriteUint64Field(v20, self->_timestampSslStart, 208LL);
  uint64_t v14 = self->_has;
  if ((*(_WORD *)&v14 & 0x800) == 0)
  {
LABEL_40:
    if ((*(_WORD *)&v14 & 0x400) == 0) {
      goto LABEL_41;
    }
    goto LABEL_79;
  }

  v4[15] = self->_timestampSslStart;
  *((_DWORD *)v4 + 70) |= 0x4000u;
  int v7 = self->_has;
  if ((*(_WORD *)&v7 & 0x800) == 0)
  {
LABEL_40:
    if ((*(_WORD *)&v7 & 0x400) == 0) {
      goto LABEL_41;
    }
    goto LABEL_79;
  }

  self->_timestampDnsStart = v5[10];
  *(_DWORD *)&self->_has |= 0x200u;
  SecCertificateRef v10 = *((_DWORD *)v5 + 70);
  if ((v10 & 0x100) == 0)
  {
LABEL_48:
    if ((v10 & 0x10000) == 0) {
      goto LABEL_49;
    }
    goto LABEL_79;
  }

uint64_t sub_100112244(uint64_t a1, uint64_t a2, const void *a3, const void *a4, const __CFArray *a5, int a6)
{
  LODWORD(v6) = a6;
  CFArrayRef theArray = 0LL;
  v30.length = CFArrayGetCount(a5);
  v30.location = 0LL;
  if (CFArrayContainsValue(a5, v30, a4)) {
    return 1LL;
  }
  keys[0] = (void *)kSecClass;
  keys[1] = (void *)kSecReturnRef;
  keys[2] = (void *)kSecAttrSubject;
  values[0] = (void *)kSecClassCertificate;
  values[1] = kCFBooleanTrue;
  values[2] = (void *)a4;
  uint64_t v14 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 3LL, 0LL, 0LL);
  SecCertificateRef v12 = v14;
  if (!v14) {
    return (uint64_t)v12;
  }
  char v24 = 0LL;
  CFArrayRef v15 = (const void **)sub_1000F8790(v14, a3, -1LL, 0LL, &v24);
  CFRelease(v12);
  if (v15)
  {
    sub_100106A54(a1, v15, &theArray, a2, &v24);
    sub_1000F8150(v15, (CFErrorRef *)&v24);
  }

  if (v24)
  {
    CFTypeID v16 = (os_log_s *)sub_10001267C("SecError");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v27 = v24;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "items matching issuer parent: %@", buf, 0xCu);
    }

    CFArrayRef v17 = (CFArrayRef)v24;
    if (!v24) {
      return 0LL;
    }
    SecCertificateRef v12 = 0LL;
    char v24 = 0LL;
LABEL_24:
    CFRelease(v17);
    return (uint64_t)v12;
  }

  CFIndex Count = CFArrayGetCount(theArray);
  if (Count < 1)
  {
    SecCertificateRef v12 = 0LL;
  }

  else
  {
    CFIndex v19 = Count;
    uint64_t v20 = 1LL;
    do
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v20 - 1);
      signed int Value = CFDictionaryGetValue(ValueAtIndex, kSecAttrIssuer);
      else {
        SecCertificateRef v12 = (const __CFDictionary *)sub_100112244(a1, a2, a3, Value, a5, v6);
      }
      if (v20 >= v19) {
        break;
      }
      ++v20;
    }

    while (!(_DWORD)v12);
  }

  CFArrayRef v17 = theArray;
  if (theArray) {
    goto LABEL_24;
  }
  return (uint64_t)v12;
}

SecCertificateRef sub_1001124D4(__CFString **a1, CFDictionaryRef theDict)
{
  if (a1 == &off_10028B168)
  {
    signed int Value = (const __CFData *)CFDictionaryGetValue(theDict, @"certdata");
    CFStringRef v5 = @"certtkid";
  }

  else
  {
    signed int Value = (const __CFData *)CFDictionaryGetValue(theDict, kSecValueData);
    CFStringRef v5 = kSecAttrTokenID;
  }

  uint64_t v6 = CFDictionaryGetValue(theDict, v5);
  if (!Value) {
    return 0LL;
  }
  if (v6)
  {
    CFTypeRef cf = 0LL;
    int v7 = (const __CFDictionary *)SecTokenItemValueCopy(Value, &cf);
    if (v7)
    {
      CFStringRef v8 = v7;
      BOOL v9 = (const __CFData *)CFDictionaryGetValue(v7, @"data");
      if (v9)
      {
        SecCertificateRef v3 = SecCertificateCreateWithData(kCFAllocatorDefault, v9);
      }

      else
      {
        SecCertificateRef v12 = (os_log_s *)sub_10001267C("SecError");
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "token item doesn't contain token value data",  buf,  2u);
        }

        SecCertificateRef v3 = 0LL;
      }

      CFRelease(v8);
      return v3;
    }

    CFRange v11 = (os_log_s *)sub_10001267C("SecError");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v15 = cf;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "function SecTokenItemValueCopy failed with: %@",  buf,  0xCu);
    }

    if (cf) {
      CFRelease(cf);
    }
    return 0LL;
  }

  return SecCertificateCreateWithData(kCFAllocatorDefault, Value);
}

void sub_1001126EC(uint64_t a1)
{
  v5[0] = 0LL;
  v5[1] = v5;
  v5[2] = 0x2000000000LL;
  uint64_t v6 = 0LL;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_100112794;
  v4[3] = &unk_10028F420;
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 32);
  v4[5] = *(void *)(a1 + 40);
  v4[6] = v2;
  v4[4] = v5;
  sub_100110ECC(1, 1, v3, (uint64_t)&v6, (uint64_t)v4);
  CFRelease(*(CFTypeRef *)(a1 + 40));
  CFRelease(*(CFTypeRef *)(a1 + 32));
  _Block_object_dispose(v5, 8);
}

uint64_t sub_100112794(void *a1, uint64_t a2)
{
  uint64_t v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"DELETE FROM %@ WHERE rowid=%lli", a1[5], a1[6]);
  uint64_t v23 = 0LL;
  char v24 = &v23;
  uint64_t v25 = 0x2000000000LL;
  char v26 = 1;
  uint64_t v5 = a1[4];
  uint64_t v6 = (CFTypeRef *)(*(void *)(v5 + 8) + 24LL);
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 0x40000000LL;
  v22[2] = sub_1001129BC;
  v22[3] = &unk_10028F3F8;
  v22[5] = v5;
  v22[6] = a2;
  v22[4] = &v23;
  unsigned int v7 = sub_100015B70(a2, v4, v6, (uint64_t)v22);
  if (*((_BYTE *)v24 + 24)) {
    unsigned int v8 = v7;
  }
  else {
    unsigned int v8 = 0;
  }
  *((_BYTE *)v24 + 24) = v8;
  if (v8 != 1 || *(void *)(*(void *)(a1[4] + 8LL) + 24LL))
  {
    BOOL v9 = (os_log_s *)sub_10001267C("SecError");
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_9;
    }
    uint64_t v11 = a1[5];
    uint64_t v10 = a1[6];
    uint64_t v12 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
    *(_DWORD *)__int128 buf = 138412802;
    uint64_t v28 = v11;
    __int16 v29 = 2048;
    uint64_t v30 = v10;
    __int16 v31 = 2112;
    uint64_t v32 = v12;
    uint64_t v13 = "Failed to delete corrupt item, %@ row %lli: %@";
    uint64_t v14 = v9;
    uint32_t v15 = 32;
    goto LABEL_8;
  }

  CFIndex v19 = (os_log_s *)sub_10001267C("item");
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = a1[5];
    uint64_t v20 = a1[6];
    *(_DWORD *)__int128 buf = 134218242;
    uint64_t v28 = v20;
    __int16 v29 = 2112;
    uint64_t v30 = v21;
    uint64_t v13 = "Deleted corrupt rowid %lli from table %@";
    uint64_t v14 = v19;
    uint32_t v15 = 22;
LABEL_8:
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, buf, v15);
  }

uint64_t sub_1001129BC(void *a1, sqlite3_stmt *a2)
{
  uint64_t result = sub_100015CD8(a1[6], a2, (CFTypeRef *)(*(void *)(a1[5] + 8LL) + 24LL), 0LL);
  uint64_t v4 = *(void *)(a1[4] + 8LL);
  if (*(_BYTE *)(v4 + 24)) {
    char v5 = result;
  }
  else {
    char v5 = 0;
  }
  *(_BYTE *)(v4 + 24) = v5;
  return result;
}

BOOL sub_100112A08(const __CFDictionary *a1, uint64_t a2, uint64_t *a3, __CFString **a4)
{
  unsigned int v8 = *(const __CFArray **)(a2 + 8);
  if (!v8) {
    return sub_1000194E0( -34018,  a4,  @"Client has neither %@ entitlements",  @"application-identifier nor keychain-access-groups");
  }
  CFRetain(*(CFTypeRef *)(a2 + 8));
  CFIndex Count = CFArrayGetCount(v8);
  if (!Count)
  {
    CFRelease(v8);
    return sub_1000194E0( -34018,  a4,  @"Client has neither %@ entitlements",  @"application-identifier nor keychain-access-groups");
  }

  CFIndex v10 = Count;
  kdebug_trace(726794336LL, 0LL, 0LL, 0LL, 0LL);
  if (*(_BYTE *)(a2 + 18))
  {
    signed int Value = CFDictionaryGetValue(a1, kSecValuePersistentRef);
    CFDataRef theData = 0LL;
    uint64_t v32 = 0LL;
    uint64_t v30 = 0LL;
    if (Value)
    {
      if (_SecItemParsePersistentRef(Value, &v32, &v30, &theData, 0LL))
      {
        if (theData && CFDataGetLength(theData) == 16)
        {
          uint64_t v45 = 0LL;
          uint64_t v46 = &v45;
          uint64_t v47 = 0x2000000000LL;
          uint64_t v48 = 0LL;
          uint64_t v41 = 0LL;
          double v42 = &v41;
          uint64_t v43 = 0x2000000000LL;
          uint64_t v44 = 0LL;
          values = _NSConcreteStackBlock;
          uint64_t v34 = 0x40000000LL;
          CFIndex v35 = sub_1001130BC;
          BOOL v36 = &unk_10028FB90;
          CFMutableArrayRef v39 = v32;
          CFDataRef v40 = theData;
        }

        else
        {
          uint64_t v45 = 0LL;
          uint64_t v46 = &v45;
          uint64_t v47 = 0x2000000000LL;
          uint64_t v48 = 0LL;
          uint64_t v41 = 0LL;
          double v42 = &v41;
          uint64_t v43 = 0x2000000000LL;
          uint64_t v44 = 0LL;
          values = _NSConcreteStackBlock;
          uint64_t v34 = 0x40000000LL;
          CFIndex v35 = sub_1001131BC;
          BOOL v36 = &unk_10028FC08;
          CFMutableArrayRef v39 = v32;
          CFDataRef v40 = v30;
        }

        __int16 v37 = &v41;
        CFTypeRef v38 = &v45;
        char v13 = sub_100110ECC(0, 1, 0LL, (uint64_t)&v44, (uint64_t)&values);
        uint64_t v14 = (const __CFString *)v46[3];
        if ((v13 & 1) == 0 && v14)
        {
          v46[3] = 0LL;
          CFRelease(v14);
          uint64_t v14 = 0LL;
        }

        _Block_object_dispose(&v41, 8);
        _Block_object_dispose(&v45, 8);
        if (v14)
        {
          if (CFStringHasSuffix(v14, kSecNetworkExtensionAccessGroupSuffix))
          {
            v49.location = 0LL;
            v49.length = v10;
            if (!CFArrayContainsValue(v8, v49, v14))
            {
              MutableCFStringRef Copy = CFArrayCreateMutableCopy(0LL, 0LL, v8);
              CFArrayAppendValue(MutableCopy, v14);
              CFRelease(v8);
              unsigned int v8 = MutableCopy;
            }
          }

          CFRelease(v14);
        }
      }

      CFDataRef v16 = theData;
      if (theData)
      {
        CFDataRef theData = 0LL;
        CFRelease(v16);
      }
    }
  }

  v50.location = 0LL;
  v50.length = v10;
  if (CFArrayContainsValue(v8, v50, @"*") && v8)
  {
    CFRelease(v8);
    unsigned int v8 = 0LL;
  }

  uint64_t v17 = sub_1000F8790(a1, *(const void **)(a2 + 24), 1LL, a2, a4);
  if (!v17)
  {
    uint64_t v22 = 0LL;
    if (!v8) {
      goto LABEL_69;
    }
    goto LABEL_68;
  }

  uint64_t v18 = v17;
  CFIndex v19 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(v17 + 8), kSecAttrAccessGroup);
  if (!v19)
  {
LABEL_32:
    if (*(_DWORD *)(v18 + 192) == 2)
    {
      uint64_t v21 = *(const void **)(v18 + 128);
      if (v21)
      {
        *(void *)(v18 + 128) = 0LL;
        CFRelease(v21);
      }

      *(void *)(v18 + 128) = CFDataCreateWithBytesNoCopy(0LL, byte_100205530, 16LL, kCFAllocatorNull);
    }

    else
    {
      *(_DWORD *)(v18 + 192) = 0;
    }

    sub_1000F98B4(v18, v8);
    if (*(_BYTE *)(a2 + 37) && (sub_1001132BC(a2) & 1) == 0)
    {
      int v25 = sub_1000194E0( -34020,  a4,  @"App clips are not permitted to use access groups other than application identifier");
    }

    else
    {
      if (*(_DWORD *)(v18 + 192) && !*(_BYTE *)(a2 + 16))
      {
        uint64_t v23 = @"client doesn't have entitlement for system keychain";
LABEL_56:
        int v24 = -34018;
        goto LABEL_65;
      }

      if (*(void *)(v18 + 88))
      {
        uint64_t v23 = @"use item list unsupported";
LABEL_45:
        int v24 = -50;
LABEL_65:
        int v25 = sub_1000194E0(v24, a4, v23);
        goto LABEL_66;
      }

      if (*(void *)(v18 + 176))
      {
        char v26 = *(__CFString ***)v18;
        if (v26 != (__CFString **)sub_10010C560((uint64_t)@"cert", &qword_1002DEB48, (uint64_t)&unk_1002DEB40)
          && *(__CFString ***)v18 != &off_10028B168)
        {
          uint64_t v23 = @"unsupported match attribute";
LABEL_64:
          int v24 = -4;
          goto LABEL_65;
        }
      }

      if (*(void *)(v18 + 240))
      {
        uint64_t v27 = *(__CFString ***)v18;
        if (v27 != (__CFString **)sub_10010C560((uint64_t)@"inet", &qword_1002DEB38, (uint64_t)&unk_1002DEB30))
        {
          uint64_t v23 = @"unsupported kSecMatchHostOrSubdomainOfHost attribute";
          goto LABEL_64;
        }
      }

      if (*(void *)(v18 + 200))
      {
        uint64_t v28 = *(__CFString ***)v18;
        if (v28 != (__CFString **)sub_10010C560((uint64_t)@"cert", &qword_1002DEB48, (uint64_t)&unk_1002DEB40)
          && *(__CFString ***)v18 != &off_10028B168)
        {
          uint64_t v23 = @"unsupported kSecMatchPolicy attribute";
          goto LABEL_64;
        }
      }

      if (!a3 && *(_DWORD *)(v18 + 48))
      {
        uint64_t v23 = @"missing pointer";
        goto LABEL_45;
      }

      if (*(_BYTE *)(v18 + 116) && CFDictionaryContainsKey(*(CFDictionaryRef *)(v18 + 8), kSecAttrSharingGroup))
      {
        uint64_t v23 = @"can't copy shared items without Keychain Sharing client entitlement";
        goto LABEL_56;
      }

      if (*(void *)(v18 + 40))
      {
        int v29 = 0;
LABEL_67:
        uint64_t v22 = sub_1000F8150((const void **)v18, (CFErrorRef *)a4) & v29;
        if (!v8)
        {
LABEL_69:
          kdebug_trace(726794340LL, 0LL, 0LL, 0LL, 0LL);
          return v22;
        }

LABEL_66:
    int v29 = v25;
    goto LABEL_67;
  }

  uint64_t v20 = (__CFString *)v19;
  if (sub_10010DD28(v8, v19, a2))
  {
    values = v20;
    if (v8) {
      CFRelease(v8);
    }
    unsigned int v8 = CFArrayCreate(0LL, (const void **)&values, 1LL, &kCFTypeArrayCallBacks);
    goto LABEL_32;
  }

  sub_1000194E0(-34018, a4, @"Client explicitly specifies access group %@ but is only entitled for %@", v20, v8);
  if (v8) {
    CFRelease(v8);
  }
  sub_1000F8150((const void **)v18, 0LL);
  return 0LL;
}

            if ((v43 & 1) == 0)
            {
              uint64_t v62 = (v45 | v61) ^ 1;
LABEL_79:
              if (!v61 || (v39 & 1) != 0)
              {
                int v90 = v62;
                if (a5) {
                  uint64_t v74 = a5;
                }
                else {
                  uint64_t v74 = v40;
                }
                int v75 = sub_1000E7EC0(v74, kSecAttrAccessible);
                uint64_t v67 = (os_log_s *)objc_claimAutoreleasedReturnValue(v75);
                if ((-[os_log_s isEqualToString:]( v67,  "isEqualToString:",  kSecAttrAccessibleWhenUnlocked) & 1) != 0 || (-[os_log_s isEqualToString:]( v67,  "isEqualToString:",  kSecAttrAccessibleAfterFirstUnlock) & 1) != 0 || (-[os_log_s isEqualToString:]( v67,  "isEqualToString:",  kSecAttrAccessibleAlwaysPrivate) & 1) != 0)
                {
                  if (!a4)
                  {
                    int v76 = sub_1000E705C(a5, (uint64_t)&off_1002905E8, 0LL);
                    char v77 = (void *)objc_claimAutoreleasedReturnValue(v76);
                    char v78 = (void *)objc_claimAutoreleasedReturnValue([v34 zoneID]);
                    int v79 = (void *)objc_claimAutoreleasedReturnValue([v78 zoneName]);
                    int64_t v80 = sub_1000AA6AC(@"ckks", v79);
                    uint64_t v81 = (os_log_s *)objc_claimAutoreleasedReturnValue(v80);

                    if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
                    {
                      unint64_t v82 = @"deletion";
                      if (v90) {
                        unint64_t v82 = @"modification";
                      }
                      if (v45) {
                        unint64_t v82 = @"addition";
                      }
                      *(_DWORD *)v106 = 138412546;
                      *(void *)int64_t v107 = v82;
                      *(_WORD *)&v107[8] = 2112;
                      uint64_t v108 = v77;
                      _os_log_impl( (void *)&_mh_execute_header,  v81,  OS_LOG_TYPE_DEFAULT,  "Received an incoming %@ from SOS (%@)",  v106,  0x16u);
                    }
                  }

                  BOOL v83 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView databaseProvider](self, "databaseProvider"));
                  v95 = (os_log_s *)v34;
                  v96 = v94;
                  objc_msgSend(v83, "dispatchSyncWithConnection:readWriteTxion:block:");

                  uint64_t v84 = v95;
                }

                else
                {
                  uint64_t v85 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView zoneName](self, "zoneName"));
                  uint64_t v86 = sub_1000AA6AC(@"ckks", v85);
                  uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue(v86);

                  if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)v106 = 138412290;
                    *(void *)int64_t v107 = v67;
                    _os_log_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_DEFAULT,  "skipping sync of device-bound(%@) item",  v106,  0xCu);
                  }
                }

                goto LABEL_100;
              }

              uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue([v46 zoneID]);
              char v72 = (void *)objc_claimAutoreleasedReturnValue([v71 zoneName]);
              uint64_t v73 = sub_1000AA6AC(@"ckks", v72);
              uint64_t v67 = (os_log_s *)objc_claimAutoreleasedReturnValue(v73);

              if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)v106 = 0;
                BOOL v68 = "Client has asked for an item deletion to not sync. Keychain is now out of sync with account";
                BOOL v69 = v67;
                char v70 = 2;
                goto LABEL_83;
              }

              goto LABEL_100;
            }

            goto LABEL_75;
          }
        }

        double v42 = sub_1000E9A9C(v40);
        uint64_t v43 = v39 & v42;
        __darwin_time_t v59 = a5 == 0LL;
        goto LABEL_48;
      }
    }

    int v25 = [v24 countByEnumeratingWithState:&v97 objects:v115 count:16];
    if (v25) {
      continue;
    }
    break;
  }
  }

  else
  {
    unsigned int v7 = (void *)objc_claimAutoreleasedReturnValue([a1[4] zoneID]);
    unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue([v7 zoneName]);
    BOOL v9 = sub_1000AA6AC(@"ckks-se", v8);
    CFIndex v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);

    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)uint64_t v130 = v95;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Unable to load currentTLK: %@", buf, 0xCu);
    }

    [a1[5] setError:v95];
  }
}

        if (!MutableCopy) {
          goto LABEL_68;
        }
        goto LABEL_67;
      }

      uint64_t v20 = CFDataGetLength(v10);
      MutableCFStringRef Copy = CFDataCreateMutableCopy(0LL, v20, v10);
    }

    else
    {
      MutableCFStringRef Copy = 0LL;
    }

    LODWORD(v18) = 0;
LABEL_82:
    signed int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 104), *(const void **)(a2 + 16));
    uint64_t v44 = (dispatch_source_s *)objc_claimAutoreleasedReturnValue(Value);
    if (v44)
    {
      uint64_t v45 = sub_10001267C("otrtimer");
      uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue(v45);
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf[0]) = 138412290;
        *(uint64_t *)((char *)buf + 4) = a2;
        _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_DEFAULT,  "removing timer for peer: %@",  (uint8_t *)buf,  0xCu);
      }

      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a2 + 104), *(const void **)(a2 + 16));
      dispatch_source_cancel(v44);
    }

    uint64_t v47 = 1;
    switch((int)v18)
    {
      case 0:
        goto LABEL_110;
      case 1:
        uint64_t v48 = sub_10001267C("engine");
        CFRange v49 = (os_log_s *)objc_claimAutoreleasedReturnValue(v48);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf[0]) = 138412290;
          *(uint64_t *)((char *)buf + 4) = v7;
          _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "%@ engine negotiating",  (uint8_t *)buf,  0xCu);
        }

        goto LABEL_98;
      case 2:
        *(_BYTE *)(a2 + 48) = 1;
        sub_1001AFD74((__CFArray **)(a2 + 80), *(const void **)(a2 + 72));
        *a6 = 1;
        int v53 = sub_10001267C("engine");
        CFRange v49 = (os_log_s *)objc_claimAutoreleasedReturnValue(v53);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf[0]) = 138412290;
          *(uint64_t *)((char *)buf + 4) = v7;
          _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "%@ engine negotiation complete",  (uint8_t *)buf,  0xCu);
        }

        goto LABEL_98;
      case 3:
        CFIndex v54 = sub_10001267C("engine");
        CFTypeID v55 = (os_log_s *)objc_claimAutoreleasedReturnValue(v54);
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
        {
          if (v8) {
            CFTypeID v56 = (uint64_t)*v8;
          }
          else {
            CFTypeID v56 = 0LL;
          }
          LODWORD(buf[0]) = 138412546;
          *(uint64_t *)((char *)buf + 4) = v7;
          WORD2(buf[1]) = 2112;
          *(uint64_t *)((char *)&buf[1] + 6) = v56;
          _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_DEFAULT,  "%@ engine failed handling message %@",  (uint8_t *)buf,  0x16u);
        }

        sub_1001A9D20(a3);
        unsigned int v61 = sub_10001267C("SecError");
        uint64_t v60 = (os_log_s *)objc_claimAutoreleasedReturnValue(v61);
        if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf[0]) = 138412290;
          *(uint64_t *)((char *)buf + 4) = (uint64_t)v275;
          _os_log_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_DEFAULT,  "Attempt to recover coder failed to restart: %@",  (uint8_t *)buf,  0xCu);
        }

        goto LABEL_117;
      case 4:
        CFRange v50 = sub_10001267C("engine");
        CFRange v49 = (os_log_s *)objc_claimAutoreleasedReturnValue(v50);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(buf[0]) = 138412290;
          *(uint64_t *)((char *)buf + 4) = v7;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEBUG,  "%@ engine stale event ignored",  (uint8_t *)buf,  0xCu);
        }

uint64_t sub_100113018(const __CFDictionary *a1, uint64_t a2, __CFString **a3)
{
  if (CFDictionaryContainsKey(a1, @"clip"))
  {
    uint64_t v6 = @"Non-API attributes present in query";
    return sub_1000194E0(-50, a3, v6);
  }

  if (CFDictionaryContainsKey(a1, kSecAttrSharingGroup))
  {
    if (sub_100113658(a1))
    {
      uint64_t v6 = @"Can't query the synced keychain with a sharing group";
      return sub_1000194E0(-50, a3, v6);
    }

    if (a2 == 2)
    {
      uint64_t v6 = @"Can't update an item's sharing group";
      return sub_1000194E0(-50, a3, v6);
    }
  }

  return 1LL;
}

BOOL sub_1001130BC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 48;
  int v5 = CFEqual(*(CFTypeRef *)(a1 + 48), kSecClassIdentity);
  uint64_t v6 = &kSecClassCertificate;
  if (!v5) {
    uint64_t v6 = (const CFStringRef *)v4;
  }
  unsigned int v7 = CFStringCreateWithFormat(0LL, 0LL, @"SELECT agrp FROM %@ WHERE persistref = ?", *v6);
  v13[0] = _NSConcreteStackBlock;
  uint64_t v8 = *(void *)(v4 + 8);
  __int128 v9 = *(_OWORD *)(v4 - 16);
  CFIndex v10 = (CFTypeRef *)(*(void *)(*(void *)(v4 - 16) + 8LL) + 24LL);
  v13[1] = 0x40000000LL;
  v13[2] = sub_100113508;
  v13[3] = &unk_10028FB68;
  uint64_t v15 = v8;
  uint64_t v16 = a2;
  __int128 v14 = v9;
  int v11 = sub_1000162BC(a2, v7, v10, (uint64_t)v13);
  if (v7) {
    CFRelease(v7);
  }
  return v11 && *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) != 0LL;
}

BOOL sub_1001131BC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 48;
  int v5 = CFEqual(*(CFTypeRef *)(a1 + 48), kSecClassIdentity);
  uint64_t v6 = &kSecClassCertificate;
  if (!v5) {
    uint64_t v6 = (const CFStringRef *)v4;
  }
  unsigned int v7 = CFStringCreateWithFormat(0LL, 0LL, @"SELECT agrp FROM %@ WHERE rowid == %u", *v6, *(void *)(v4 + 8));
  v12[0] = _NSConcreteStackBlock;
  __int128 v8 = *(_OWORD *)(v4 - 16);
  __int128 v9 = (CFTypeRef *)(*(void *)(*(void *)(v4 - 16) + 8LL) + 24LL);
  v12[1] = 0x40000000LL;
  v12[2] = sub_100113410;
  void v12[3] = &unk_10028FBE0;
  uint64_t v14 = a2;
  __int128 v13 = v8;
  int v10 = sub_1000162BC(a2, v7, v9, (uint64_t)v12);
  if (v7) {
    CFRelease(v7);
  }
  return v10 && *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) != 0LL;
}

uint64_t sub_1001132BC(uint64_t a1)
{
  if (!a1 || !*(void *)(a1 + 40) || (uint64_t v2 = *(const __CFArray **)(a1 + 8)) == 0LL)
  {
    uint64_t v6 = (os_log_s *)sub_10001267C("SecError");
    BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (!v7) {
      return result;
    }
    *(_WORD *)uint64_t v12 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "item: no app clip client or attributes not set, cannot verify restrictions",  v12,  2u);
    return 0LL;
  }

  CFIndex Count = CFArrayGetCount(v2);
  if (Count != 2)
  {
    if (Count == 1)
    {
      uint64_t v4 = *(const void **)(a1 + 40);
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), 0LL);
      if (v4 && ValueAtIndex) {
        return CFEqual(v4, ValueAtIndex) != 0;
      }
      if (v4 == ValueAtIndex) {
        return 1LL;
      }
    }

    return 0LL;
  }

  v13.location = 0LL;
  v13.length = 2LL;
  FirstIndexOfsigned int Value = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 8), v13, kSecAttrAccessGroupToken);
  if (FirstIndexOfValue == -1) {
    return 0LL;
  }
  int v10 = *(const void **)(a1 + 40);
  int v11 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), FirstIndexOfValue == 0);
  if (v10 && v11) {
    return CFEqual(v10, v11) != 0;
  }
  else {
    return v10 == v11;
  }
}

uint64_t sub_1001133FC(uint64_t a1, uint64_t a2)
{
  return sub_100106A54( a2,  *(void *)(a1 + 32),  *(CFTypeRef **)(a1 + 40),  *(void *)(a1 + 48),  *(__CFString ***)(a1 + 56));
}

uint64_t sub_100113410(void *a1, sqlite3_stmt *a2)
{
  uint64_t v3 = a1[5];
  uint64_t v4 = *(void *)(a1[4] + 8LL);
  v7[0] = _NSConcreteStackBlock;
  v7[2] = sub_100113494;
  void v7[3] = &unk_10028FBB8;
  uint64_t v5 = a1[6];
  v7[1] = 0x40000000LL;
  v7[4] = v3;
  v7[5] = a2;
  uint64_t result = sub_100018624(v5, a2, (CFTypeRef *)(v4 + 24), (uint64_t)v7);
  if ((_DWORD)result) {
    return *(void *)(*(void *)(a1[5] + 8LL) + 24LL) != 0LL;
  }
  return result;
}

BOOL sub_100113494(uint64_t a1)
{
  uint64_t v2 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 40), 0);
  int v3 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 40), 0);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = CFStringCreateWithBytes(0LL, v2, v3, 0x8000100u, 0);
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

BOOL sub_100113508(uint64_t a1, sqlite3_stmt *a2)
{
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 48));
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 48));
  BOOL v6 = sub_10001817C(a2, 1LL, BytePtr, Length, (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
  uint64_t v7 = *(void *)(a1 + 40);
  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8LL);
  v12[0] = _NSConcreteStackBlock;
  v12[2] = sub_1001135E4;
  void v12[3] = &unk_10028FB40;
  uint64_t v9 = *(void *)(a1 + 56);
  v12[1] = 0x40000000LL;
  void v12[4] = v7;
  v12[5] = a2;
  else {
    BOOL v10 = 1;
  }
  return !v10 && *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) != 0LL;
}

BOOL sub_1001135E4(uint64_t a1)
{
  uint64_t v2 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 40), 0);
  int v3 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 40), 0);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = CFStringCreateWithBytes(0LL, v2, v3, 0x8000100u, 0);
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

BOOL sub_100113658(const __CFDictionary *a1)
{
  signed int Value = CFDictionaryGetValue(a1, kSecAttrSynchronizable);
  uint64_t v2 = (uint64_t)Value;
  if (Value)
  {
    CFTypeID v3 = CFGetTypeID(Value);
    if (v3 == CFBooleanGetTypeID())
    {
      BOOL v4 = CFBooleanGetValue((CFBooleanRef)v2) == 0;
      return !v4;
    }

    CFTypeID v5 = CFGetTypeID((CFTypeRef)v2);
    if (v5 == CFNumberGetTypeID())
    {
      int valuePtr = 0;
      CFNumberGetValue((CFNumberRef)v2, kCFNumberSInt32Type, &valuePtr);
      BOOL v4 = valuePtr == 0;
      return !v4;
    }

    CFTypeID v7 = CFGetTypeID((CFTypeRef)v2);
    if (v7 == CFStringGetTypeID())
    {
      Intsigned int Value = CFStringGetIntValue((CFStringRef)v2);
      CFStringRef v9 = CFStringCreateWithFormat(0LL, 0LL, @"%ld", IntValue);
      int v10 = CFEqual(v9, (CFTypeRef)v2);
      if (IntValue) {
        BOOL v11 = v10 == 0;
      }
      else {
        BOOL v11 = 1;
      }
      uint64_t v2 = !v11;
      CFRelease(v9);
    }

    else
    {
      return 0LL;
    }
  }

  return v2;
}

BOOL sub_100113768(const __CFDictionary *a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  if (sub_100113018(a1, 0LL, a4))
  {
    uint64_t v8 = sub_100113BEC((CFArrayRef *)a2);
    if (v8)
    {
      CFStringRef v9 = v8;
      CFIndex Count = CFArrayGetCount((CFArrayRef)v8);
      if (Count)
      {
        CFIndex v11 = Count;
        kdebug_trace(726794312LL, 0LL, 0LL, 0LL, 0LL);
        uint64_t v12 = sub_1000F8790(a1, *(const void **)(a2 + 24), 0LL, a2, a4);
        if (!v12)
        {
          uint64_t v16 = 0LL;
          goto LABEL_61;
        }

        uint64_t v13 = v12;
        signed int Value = (const __CFString *)CFDictionaryGetValue(a1, kSecAttrAccessGroup);
        v40.location = 0LL;
        v40.length = v11;
        if (CFArrayContainsValue((CFArrayRef)v9, v40, @"*"))
        {
          CFRelease(v9);
          CFStringRef v9 = 0LL;
        }

        if (Value)
        {
          if ((sub_10010DD28((const __CFArray *)v9, Value, a2) & 1) == 0)
          {
            BOOL v15 = sub_1000194E0( -34018,  a4,  @"Client explicitly specifies access group %@ but is only entitled for %@",  Value,  v9);
            goto LABEL_16;
          }
        }

        else
        {
          signed int Value = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 8), 0LL);
          sub_1000F7B40(kSecAttrAccessGroup, (const __CFBoolean *)Value, v13);
        }

        BOOL v15 = 1;
LABEL_16:
        if (sub_10001891C())
        {
          CFDictionaryRef v25 = sub_100107FA8( 0LL,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  (uint64_t)@"operation",  (uint64_t)@"add");
          if (v25)
          {
            CFDictionaryRef v26 = v25;
            sub_100018C10(@"SecItem", v25);
            CFRelease(v26);
          }
        }

        int v27 = *(_DWORD *)(v13 + 192);
        if (v27 == 2 || v27 == 1 && *(_BYTE *)(a2 + 36))
        {
          uint64_t v28 = *(const void **)(v13 + 128);
          if (v28)
          {
            *(void *)(v13 + 128) = 0LL;
            CFRelease(v28);
          }

          int v29 = CFDataCreateWithBytesNoCopy(0LL, byte_100205530, 16LL, kCFAllocatorNull);
          *(void *)(v13 + 128) = v29;
        }

        else
        {
          *(_DWORD *)(v13 + 192) = 0;
          int v29 = *(const __CFData **)(v13 + 128);
        }

        sub_1000F7914(&off_10028F460, v29, v13);
        if (!v15)
        {
          int v35 = 0;
          goto LABEL_60;
        }

        sub_1000F8028((uint64_t *)v13, Value);
        uint64_t v30 = CFDictionaryGetValue(a1, @"f_ckkscallback");
        if (v30)
        {
          *(_BYTE *)(v13 + 154) = 1;
          *(void *)(v13 + 160) = v30;
        }

        __int16 v31 = sub_10010D0A8();
        sub_1000F7B40(@"persistref", v31, v13);
        uint64_t v32 = *(const __CFBoolean **)(v13 + 80);
        if (v32 != v31)
        {
          if (!v31 || (CFRetain(v31), (uint64_t v32 = *(const __CFBoolean **)(v13 + 80)) != 0LL)) {
            CFRelease(v32);
          }
          *(void *)(v13 + 80) = v31;
        }

        if (v31) {
          CFRelease(v31);
        }
        if (*(_BYTE *)(a2 + 37))
        {
          if ((sub_1001132BC(a2) & 1) == 0)
          {
            uint64_t v34 = @"App clips are not permitted to use access groups other than application identifier";
            goto LABEL_45;
          }

          if (*(_BYTE *)(a2 + 37))
          {
            CFBooleanRef v33 = (CFBooleanRef)CFDictionaryGetValue(a1, kSecAttrSynchronizable);
            if (v33 && kCFBooleanTrue)
            {
              if (CFEqual(v33, kCFBooleanTrue))
              {
LABEL_42:
                uint64_t v34 = @"App clips are not permitted to add synchronizable items to the keychain";
LABEL_45:
                int v36 = -34020;
LABEL_58:
                int v38 = sub_1000194E0(v36, a4, v34);
                goto LABEL_59;
              }
            }

            else if (v33 == kCFBooleanTrue)
            {
              goto LABEL_42;
            }
          }
        }

        int v37 = *(_DWORD *)(v13 + 192);
        if (v37)
        {
          if (!*(_BYTE *)(a2 + 16))
          {
            uint64_t v34 = @"client doesn't have entitlement for system keychain";
            goto LABEL_57;
          }

          if (v37 == 2 && sub_100113658(a1))
          {
            uint64_t v34 = @"Can't store system keychain (always) and synchronizable";
LABEL_55:
            int v36 = -50;
            goto LABEL_58;
          }
        }

        if (*(void *)(v13 + 72) || *(void *)(v13 + 232))
        {
          uint64_t v34 = @"q_row_id";
          goto LABEL_55;
        }

        if (!*(_BYTE *)(v13 + 116) || !CFDictionaryContainsKey(*(CFDictionaryRef *)(v13 + 8), kSecAttrSharingGroup))
        {
          if (*(void *)(v13 + 40))
          {
            int v35 = 1;
LABEL_60:
            uint64_t v16 = sub_1000F8254(v13, v35, (CFErrorRef *)a4);
            if (!v9)
            {
LABEL_62:
              kdebug_trace(726794316LL, 0LL, 0LL, 0LL, 0LL);
              return v16;
            }

CFArrayRef *sub_100113BEC(CFArrayRef *a1)
{
  MutableCFStringRef Copy = a1;
  if (a1)
  {
    uint64_t v2 = a1[1];
    if (v2)
    {
      v6.length = CFArrayGetCount(v2);
      v6.location = 0LL;
      if (CFArrayContainsValue(MutableCopy[1], v6, kSecAttrAccessGroupToken))
      {
        MutableCFStringRef Copy = (CFArrayRef *)CFArrayCreateMutableCopy(kCFAllocatorDefault, 0LL, MutableCopy[1]);
        v7.length = CFArrayGetCount((CFArrayRef)MutableCopy);
        v7.location = 0LL;
        FirstIndexOfsigned int Value = CFArrayGetFirstIndexOfValue((CFArrayRef)MutableCopy, v7, kSecAttrAccessGroupToken);
        if (FirstIndexOfValue != -1)
        {
          for (CFIndex i = FirstIndexOfValue;
                i != -1;
                CFIndex i = CFArrayGetFirstIndexOfValue((CFArrayRef)MutableCopy, v8, kSecAttrAccessGroupToken))
          {
            CFArrayRemoveValueAtIndex((CFMutableArrayRef)MutableCopy, i);
            v8.length = CFArrayGetCount((CFArrayRef)MutableCopy);
            v8.location = 0LL;
          }
        }
      }

      else
      {
        MutableCFStringRef Copy = (CFArrayRef *)MutableCopy[1];
        if (MutableCopy) {
          CFRetain(MutableCopy);
        }
      }
    }

    else
    {
      return 0LL;
    }
  }

  return MutableCopy;
}

BOOL sub_100113CCC(void *a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_100113D30;
  v4[3] = &unk_10028F4B0;
  uint64_t v2 = (CFTypeRef *)a1[4];
  v4[4] = a1[5];
  v4[5] = a2;
  v4[6] = a1[6];
  void v4[7] = v2;
  return sub_100105354(a2, 2LL, v2, (uint64_t)v4);
}

uint64_t sub_100113D30(uint64_t a1)
{
  return sub_100105ABC(*(void *)(a1 + 40), *(void *)(a1 + 32), *(CFDataRef **)(a1 + 48), *(__CFString ***)(a1 + 56));
}

CFNullRef sub_100113D5C(const __CFDictionary *a1, CFTypeRef cf1, uint64_t a3, __CFString **a4)
{
  if (!cf1 || (CFRange v8 = (const __CFBoolean *)kSecAttrSharingGroupNone) != 0LL && CFEqual(cf1, kSecAttrSharingGroupNone))
  {
    CFStringRef v9 = @"A group must be specified to share the item";
LABEL_5:
    int v10 = -50;
LABEL_12:
    sub_1000194E0(v10, a4, v9, v36, v37);
    return 0LL;
  }

  if (!*(_BYTE *)(a3 + 49))
  {
    CFStringRef v9 = @"Client doesn't have Keychain Sharing client entitlement";
    goto LABEL_11;
  }

  if (sub_100113018(a1, 1LL, a4))
  {
    if (CFDictionaryContainsKey(a1, kSecAttrTombstone))
    {
      CFStringRef v9 = @"Tombstones can't be shared";
      goto LABEL_5;
    }

    uint64_t v13 = sub_100113BEC((CFArrayRef *)a3);
    if (v13)
    {
      uint64_t v14 = (const __CFArray *)v13;
      if (CFArrayGetCount((CFArrayRef)v13))
      {
        v52.length = CFArrayGetCount(v14);
        v52.location = 0LL;
        if (CFArrayContainsValue(v14, v52, @"*"))
        {
          CFRelease(v14);
          uint64_t v14 = 0LL;
        }

        signed int Value = (const __CFString *)CFDictionaryGetValue(a1, kSecAttrAccessGroup);
        if (!Value)
        {
LABEL_24:
          uint64_t v24 = sub_1000F8790(a1, *(const void **)(a3 + 24), -1LL, a3, a4);
          if (v24)
          {
            uint64_t v25 = v24;
            sub_1000F98B4(v24, v14);
            if (sub_1000F7684(*(CFTypeRef *)(v25 + 128))
              || sub_1000194E0(-909, a4, @"Items from a multi-user view can't be shared"))
            {
              if (*(_DWORD *)(v25 + 192)) {
                BOOL v26 = sub_1000194E0(-909, a4, @"System keychain items can't be shared");
              }
              else {
                BOOL v26 = 1;
              }
            }

            else
            {
              BOOL v26 = 0;
            }

            int v27 = *(_DWORD *)(v25 + 48);
            *(_DWORD *)(v25 + 48) = 3;
            uint64_t v28 = *(void *)(v25 + 104);
            int v29 = (const void *)kSecAttrSharingGroup;
            if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(v25 + 8), kSecAttrSharingGroup)) {
              sub_1000F7B40(v29, v8, v25);
            }
            if (v26 && (!*(void *)(v25 + 40) || (sub_1000F80C8(v25, (CFErrorRef *)a4) & 1) != 0))
            {
              uint64_t v48 = 0LL;
              CFRange v49 = &v48;
              uint64_t v50 = 0x2000000000LL;
              char v51 = 1;
              uint64_t v44 = 0LL;
              uint64_t v45 = &v44;
              uint64_t v46 = 0x2000000000LL;
              uint64_t v47 = 0LL;
              uint64_t v40 = 0LL;
              uint64_t v41 = &v40;
              uint64_t v42 = 0x2000000000LL;
              uint64_t v43 = 0LL;
              v38[0] = _NSConcreteStackBlock;
              v38[1] = 0x40000000LL;
              v38[2] = sub_10011428C;
              v38[3] = &unk_10028F540;
              v38[8] = v25;
              v38[9] = v14;
              v38[4] = &v48;
              v38[5] = &v44;
              v38[6] = &v40;
              v38[7] = a4;
              _BYTE v38[10] = cf1;
              int v39 = v27;
              char v30 = sub_100110ECC(1, 1, 0LL, (uint64_t)a4, (uint64_t)v38);
              sub_1000F8150((const void **)v25, (CFErrorRef *)a4);
              if (v14) {
                CFRelease(v14);
              }
              if (*((_BYTE *)v49 + 24))
              {
                if ((v30 & 1) != 0)
                {
                  sub_10010C930();
                  sub_10010C8E0();
                  if (!v27)
                  {
                    CFNullRef v11 = kCFNull;
                    goto LABEL_62;
                  }

                  if (v28 == 1)
                  {
                    if (CFArrayGetCount((CFArrayRef)v41[3]) != 1)
                    {
                      CFNullRef v11 = 0LL;
LABEL_62:
                      int v35 = (const void *)v41[3];
                      if (v35)
                      {
                        v41[3] = 0LL;
                        CFRelease(v35);
                      }

                      goto LABEL_64;
                    }

                    ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v41[3], 0LL);
                    CFStringRef Copy = (const __CFNull *)CFRetain(ValueAtIndex);
                  }

                  else
                  {
                    CFStringRef Copy = CFArrayCreateCopy(kCFAllocatorDefault, (CFArrayRef)v41[3]);
                  }

                  CFNullRef v11 = Copy;
                  goto LABEL_62;
                }

                uint64_t v34 = (const void *)v41[3];
                if (v34)
                {
                  v41[3] = 0LL;
                  CFRelease(v34);
                }
              }

              else
              {
                CFBooleanRef v33 = (const void *)v41[3];
                if (v33)
                {
                  v41[3] = 0LL;
                  CFRelease(v33);
                }

                sub_10011430C((void *)v45[3], (CFErrorRef *)a4);
              }

              CFNullRef v11 = 0LL;
LABEL_64:
              _Block_object_dispose(&v40, 8);
              _Block_object_dispose(&v44, 8);
              _Block_object_dispose(&v48, 8);
              return v11;
            }

            sub_1000F8150((const void **)v25, 0LL);
          }

          if (v14) {
            CFRelease(v14);
          }
          return 0LL;
        }

        uint64_t v16 = (uint64_t)Value;
        if ((sub_10010DD28(v14, Value, a3) & 1) != 0)
        {
          if (v14) {
            CFRelease(v14);
          }
          uint64_t v14 = sub_1001141B8(kCFAllocatorDefault, v17, v18, v19, v20, v21, v22, v23, v16);
          goto LABEL_24;
        }

        if (v14) {
          CFRelease(v14);
        }
        int v36 = (const __CFString *)v16;
        uint64_t v37 = 0LL;
        CFStringRef v9 = @"Client explicitly specifies access group %@ but is only entitled for %@";
LABEL_11:
        int v10 = -34018;
        goto LABEL_12;
      }

      CFRelease(v14);
    }

    int v36 = @"application-identifier nor keychain-access-groups";
    CFStringRef v9 = @"Client has neither %@ entitlements";
    goto LABEL_11;
  }

  return 0LL;
}

CFArrayRef sub_1001141B8( CFAllocatorRef allocator, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v19 = &a9;
  CFIndex v10 = -1LL;
  do
  {
    CFNullRef v11 = v19++;
    ++v10;
  }

  while (*v11);
  uint64_t v20 = (const __CFNull **)&a9;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(allocator, v10, &kCFTypeArrayCallBacks);
  if (!Mutable) {
    return 0LL;
  }
  for (CFIndex i = Mutable; v10; --v10)
  {
    uint64_t v14 = v20++;
    BOOL v15 = *v14;
    if (v15) {
      CFNullRef v16 = v15;
    }
    else {
      CFNullRef v16 = kCFNull;
    }
    CFArrayAppendValue(i, v16);
  }

  CFArrayRef Copy = CFArrayCreateCopy(allocator, i);
  CFRelease(i);
  return Copy;
}

BOOL sub_10011428C(uint64_t a1, uint64_t a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = sub_100114384;
  void v5[3] = &unk_10028F518;
  __int128 v8 = *(_OWORD *)(a1 + 64);
  __int128 v6 = *(_OWORD *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v2 = *(CFTypeRef **)(a1 + 56);
  uint64_t v9 = a2;
  CFIndex v10 = v2;
  uint64_t v7 = v3;
  uint64_t v11 = *(void *)(a1 + 80);
  int v12 = *(_DWORD *)(a1 + 88);
  return sub_100105354(a2, 2LL, v2, (uint64_t)v5);
}

void sub_10011430C(void *cf, CFErrorRef *a2)
{
  if (cf && a2)
  {
    if (!*a2) {
      goto LABEL_11;
    }
    if (CFErrorGetCode(*a2) == -25330)
    {
      CFErrorRef v4 = *a2;
      if (!*a2) {
        goto LABEL_11;
      }
      *a2 = 0LL;
      CFRelease(v4);
    }
  }

  else
  {
    if (!cf) {
      return;
    }
    if (!a2) {
      goto LABEL_10;
    }
  }

  if (*a2)
  {
LABEL_10:
    CFRelease(cf);
    return;
  }

BOOL sub_100114384(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  uint64_t v3 = *(void *)(a1 + 56);
  CFErrorRef v4 = *(const __CFArray **)(a1 + 64);
  uint64_t v5 = *(void *)(a1 + 72);
  __int128 v6 = (__CFString **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  v35[0] = _NSConcreteStackBlock;
  v35[1] = 0x40000000LL;
  v35[2] = sub_100114850;
  v35[3] = &unk_10028F4F0;
  v35[4] = Mutable;
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = sub_100105F8C(v3, v4, v5, v6, (uint64_t)v35);
  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    if (!Mutable) {
      return 0LL;
    }
LABEL_59:
    CFRelease(Mutable);
    return 0LL;
  }

  if (!CFArrayGetCount(Mutable))
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = sub_1000194E0( -25300,  *(__CFString ***)(a1 + 80),  @"No items matched the query");
    if (!Mutable) {
      return 0LL;
    }
    goto LABEL_59;
  }

  CFIndex Count = CFArrayGetCount(Mutable);
  CFIndex v8 = 0LL;
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = CFArrayCreateMutable( kCFAllocatorDefault,  Count,  &kCFTypeArrayCallBacks);
  uint64_t v9 = (const void *)kSecAttrUUID;
  CFTypeRef cf2 = (CFTypeRef)kSecAttrSharingGroup;
  __int16 v31 = Mutable;
  while (2)
  {
    if (v8 >= CFArrayGetCount(Mutable)) {
      goto LABEL_64;
    }
    ValueAtIndex = CFArrayGetValueAtIndex(Mutable, v8);
    uint64_t v11 = (__CFString **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
    int v12 = (void *)ValueAtIndex[2];
    uint64_t v13 = v12[2];
    if (!v13)
    {
LABEL_38:
      LOBYTE(v20) = sub_1000194E0(-50, v11, @"Items of class '%@' can't be shared", *v12);
      goto LABEL_41;
    }

    CFIndex v33 = v8;
    uint64_t v14 = 0LL;
    BOOL v15 = 0LL;
    CFNullRef v16 = 0LL;
    uint64_t v17 = 0LL;
    uint64_t v30 = *(void *)(a1 + 72);
    uint64_t v32 = *(const __CFData **)(a1 + 88);
    uint64_t v18 = v12 + 3;
    do
    {
      if (CFEqual(*(CFTypeRef *)v13, v9))
      {
        uint64_t v14 = (void *)v13;
        if (!v13) {
          goto LABEL_22;
        }
      }

      else if (CFEqual(*(CFTypeRef *)v13, cf2))
      {
        uint64_t v17 = (void *)v13;
        if (!v14) {
          goto LABEL_22;
        }
      }

      else if (CFEqual(*(CFTypeRef *)v13, kSecAttrSynchronizable))
      {
        CFNullRef v16 = (void *)v13;
        if (!v14) {
          goto LABEL_22;
        }
      }

      else
      {
        if (*(_DWORD *)(v13 + 8) == 16) {
          BOOL v15 = (void *)v13;
        }
        if (!v14) {
          goto LABEL_22;
        }
      }

      if (v17 && v16 && v15)
      {
        sub_1000E985C((uint64_t)ValueAtIndex, v11);
        goto LABEL_27;
      }

void sub_100114850(uint64_t a1, const void *a2)
{
}

uint64_t sub_100114858(uint64_t a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_1001148D4;
  v4[3] = &unk_10028F5C8;
  v4[4] = a2;
  v4[5] = a1;
  uint64_t v2 = sub_100110ECC(1, 1, 0LL, a2, (uint64_t)v4);
  if ((_DWORD)v2)
  {
    sub_10010C930();
    sub_10010C8E0();
  }

  return v2;
}

BOOL sub_1001148D4(int8x16_t *a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_10011493C;
  v4[3] = &unk_10028F5A8;
  int8x16_t v2 = a1[2];
  int8x16_t v5 = vextq_s8(v2, v2, 8uLL);
  uint64_t v6 = a2;
  return sub_100105354(a2, 2LL, (CFTypeRef *)v2.i64[0], (uint64_t)v4);
}

uint64_t sub_10011493C(uint64_t a1)
{
  uint64_t v32 = 0LL;
  CFIndex v33 = &v32;
  uint64_t v34 = 0x2000000000LL;
  char v35 = 1;
  int8x16_t v2 = *(const void **)(*(void *)(a1 + 32) + 24LL);
  if (!v2)
  {
    if (qword_1002DEA70 != -1) {
      dispatch_once(&qword_1002DEA70, &stru_100286568);
    }
    int8x16_t v2 = (const void *)qword_1002DEA78;
  }

  v40[0] = sub_10010C560((uint64_t)@"inet", &qword_1002DEB38, (uint64_t)&unk_1002DEB30);
  v40[1] = sub_10010C560((uint64_t)@"genp", &qword_1002DEB28, (uint64_t)&unk_1002DEB20);
  v40[2] = sub_10010C560((uint64_t)@"cert", &qword_1002DEB48, (uint64_t)&unk_1002DEB40);
  v40[3] = sub_10010C560((uint64_t)@"keys", &qword_1002DEB58, (uint64_t)&unk_1002DEB50);
  CFIndex v10 = sub_1001141B8(0LL, v3, v4, v5, v6, v7, v8, v9, (uint64_t)@"com.apple.safari.credit-cards");
  uint64_t v11 = v33;
  if (*((_BYTE *)v33 + 24))
  {
    unint64_t v12 = 0LL;
    int v27 = (const void *)kSecAttrMultiUser;
    while (1)
    {
      uint64_t v13 = (os_log_s *)sub_10001267C("SecDeleteItemsOnSignOut");
      BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG);
      BOOL v15 = (uint64_t *)v40[v12];
      if (v14)
      {
        uint64_t v24 = *v15;
        *(_DWORD *)__int128 buf = 138412546;
        uint64_t v37 = v24;
        __int16 v38 = 2112;
        int v39 = v2;
        _os_log_debug_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "Deleting items from class=%@ with multi-user view=%@",  buf,  0x16u);
      }

      CFNullRef v16 = (CFDictionaryRef *)sub_1000F82CC((uint64_t)v15, v2, 0LL, *(void *)(a1 + 32), *(__CFString ***)(a1 + 40));
      if (!v16) {
        break;
      }
      uint64_t v17 = v16;
      sub_1000F7B40(v27, (const __CFBoolean *)v2, (uint64_t)v16);
      sub_1000F7B40(kSecAttrSynchronizable, kCFBooleanTrue, (uint64_t)v17);
      for (CFIndex i = 0LL; i < CFArrayGetCount(v10); ++i)
      {
        ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v10, i);
        sub_1000F7D2C(kSecAttrAccessGroup, ValueAtIndex, (uint64_t)v17);
      }

      uint64_t v20 = *(void *)(a1 + 48);
      uint64_t v29 = *(CFTypeRef **)(a1 + 40);
      v30.isa = _NSConcreteStackBlock;
      *(void *)&v30.flags = 0x40000000LL;
      v30.invoke = (void (*)(void *, ...))sub_100114D1C;
      v30.descriptor = (Block_descriptor_1 *)&unk_10028F560;
      __int16 v31 = v17;
      v28[0] = _NSConcreteStackBlock;
      v28[1] = 0x40000000LL;
      v28[2] = sub_100114D44;
      v28[3] = &unk_10028F588;
      v28[4] = &v32;
      v28[5] = v20;
      BOOL v21 = sub_1000EA68C(v17, v20, v29, 0LL, &v30, 0LL, 0LL, (uint64_t)v28);
      if (*((_BYTE *)v33 + 24)) {
        BOOL v22 = v21;
      }
      else {
        BOOL v22 = 0;
      }
      *((_BYTE *)v33 + 24) = v22;
      sub_1000F8150((const void **)v17, 0LL);
      uint64_t v11 = v33;
      if (*((_BYTE *)v33 + 24))
      {
        if (v12++ < 3) {
          continue;
        }
      }

      goto LABEL_21;
    }

    uint64_t v11 = v33;
    *((_BYTE *)v33 + 24) = 0;
  }

BOOL sub_100114D1C(uint64_t a1, const void **a2)
{
  return CFDictionaryContainsKey(*(CFDictionaryRef *)(*(void *)(a1 + 32) + 8LL), *a2) != 0;
}

CFStringRef **sub_100114D44(uint64_t a1, CFStringRef **a2, _BYTE *a3)
{
  uint64_t result = sub_1000ECAF0(a2, *(void *)(a1 + 40), kCFBooleanFalse, 0, *(CFTypeRef **)(a1 + 48));
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if (*(_BYTE *)(v6 + 24)) {
    char v7 = (char)result;
  }
  else {
    char v7 = 0;
  }
  *(_BYTE *)(v6 + 24) = v7;
  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)) {
    *a3 = 1;
  }
  return result;
}

BOOL sub_100114DB4(const __CFDictionary *a1, const __CFDictionary *a2, uint64_t a3, __CFString **a4)
{
  uint64_t v8 = sub_100113BEC((CFArrayRef *)a3);
  if (!v8) {
    return sub_1000194E0( -34018,  a4,  @"Client has neither %@ entitlements",  @"application-identifier nor keychain-access-groups");
  }
  uint64_t v9 = v8;
  CFIndex Count = CFArrayGetCount((CFArrayRef)v8);
  if (!Count)
  {
    CFRelease(v9);
    return sub_1000194E0( -34018,  a4,  @"Client has neither %@ entitlements",  @"application-identifier nor keychain-access-groups");
  }

  CFIndex v11 = Count;
  signed int Value = (const __CFString *)CFDictionaryGetValue(a1, kSecAttrAccessGroup);
  if (!Value || (uint64_t v13 = Value, (sub_10010DD28((const __CFArray *)v9, Value, a3) & 1) != 0))
  {
    kdebug_trace(726794320LL, 0LL, 0LL, 0LL, 0LL);
    if (sub_10001891C())
    {
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v9, 0LL);
      uint64_t v41 = 0LL;
      int v39 = @"AccessGroup";
      CFDictionaryRef v21 = sub_100107FA8(0LL, v14, v15, v16, v17, v18, v19, v20, (uint64_t)@"operation", (uint64_t)@"update");
      if (v21)
      {
        CFDictionaryRef v22 = v21;
        sub_100018C10(@"SecItem", v21);
        CFRelease(v22);
      }
    }

    v45.location = 0LL;
    v45.length = v11;
    if (CFArrayContainsValue((CFArrayRef)v9, v45, @"*"))
    {
      CFRelease(v9);
      uint64_t v9 = 0LL;
    }

    uint64_t v23 = sub_1000F8790(a1, *(const void **)(a3 + 24), -1LL, a3, a4);
    if (!v23)
    {
      uint64_t v28 = 0LL;
LABEL_71:
      if (v9) {
        CFRelease(v9);
      }
      kdebug_trace(726794324LL, 0LL, 0LL, 0LL, 0LL);
      return v28;
    }

    uint64_t v24 = v23;
    int v25 = *(_DWORD *)(v23 + 192);
    if (v25 == 2 || v25 == 1 && *(_BYTE *)(a3 + 36))
    {
      BOOL v26 = *(const void **)(v23 + 128);
      if (v26)
      {
        *(void *)(v24 + 128) = 0LL;
        CFRelease(v26);
      }

      *(void *)(v24 + 128) = CFDataCreateWithBytesNoCopy(0LL, byte_100205530, 16LL, kCFAllocatorNull);
    }

    else
    {
      *(_DWORD *)(v23 + 192) = 0;
    }

    sub_1000F98B4(v24, v9);
    if (!*(_BYTE *)(a3 + 37)) {
      goto LABEL_41;
    }
    if ((sub_1001132BC(a3) & 1) == 0)
    {
      Block_layout v30 = @"App clips are not permitted to use access groups other than application identifier";
LABEL_39:
      int v32 = -34020;
      goto LABEL_62;
    }

    if (!*(_BYTE *)(a3 + 37)) {
      goto LABEL_41;
    }
    CFBooleanRef v29 = (CFBooleanRef)CFDictionaryGetValue(a1, kSecAttrSynchronizable);
    if (v29 && kCFBooleanTrue)
    {
      if (!CFEqual(v29, kCFBooleanTrue)) {
        goto LABEL_35;
      }
    }

    else if (v29 != kCFBooleanTrue)
    {
LABEL_35:
      CFBooleanRef v31 = (CFBooleanRef)CFDictionaryGetValue(a2, kSecAttrSynchronizable);
      if (kCFBooleanTrue && v31)
      {
        if (CFEqual(v31, kCFBooleanTrue)) {
          goto LABEL_38;
        }
      }

      else if (v31 == kCFBooleanTrue)
      {
        goto LABEL_38;
      }

BOOL sub_1001152E0(uint64_t a1, uint64_t a2)
{
  int8x16_t v2 = *(CFTypeRef **)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_10011534C;
  v4[3] = &unk_10028F5E8;
  void v4[4] = a2;
  __int128 v5 = *(_OWORD *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 56);
  char v7 = v2;
  return sub_100105354(a2, 2LL, v2, (uint64_t)v4);
}

BOOL sub_10011534C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  int8x16_t v2 = *(__CFString ***)(a1 + 64);
  if (*(void *)(v1 + 24) != *(void *)(v1 + 16)) {
    return sub_1000194E0(-50, v2, @"match not supported in attributes to update");
  }
  if (*(void *)(v1 + 64)) {
    return sub_1000194E0(-50, v2, @"value ref not supported in attributes to update");
  }
  uint64_t v4 = *(void *)(a1 + 32);
  __int128 v5 = *(const __CFDictionary **)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 56);
  if (*(void *)(v1 + 72) && *(void *)(v1 + 32)) {
    return sub_1000194E0( -50,  v2,  @"attributes to update illegal; both row_id and other attributes can't be updated at the same time");
  }
  if (*(void *)(v1 + 232) && *(void *)(v1 + 32) != 1LL) {
    return sub_1000194E0( -50,  v2,  @"attributes to update illegal; both token persistent ref and other attributes can't be updated at the same time");
  }
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 48), kSecAttrSharingGroup)) {
    return sub_1000194E0(-50, v2, @"Cannot change SharingGroup using this API");
  }
  uint64_t v19 = 0LL;
  int v20 = &v19;
  uint64_t v21 = 0x2000000000LL;
  char v22 = 1;
  char v7 = (const void **)sub_1000F82CC(*(void *)v1, 0LL, v5, 0LL, v2);
  if (v7)
  {
    uint64_t v8 = v7;
    CFDictionaryApplyFunction(v5, (CFDictionaryApplierFunction)sub_1000F85B4, v7);
    if ((sub_1000F80C8((uint64_t)v8, (CFErrorRef *)v2) & 1) != 0)
    {
      uint64_t v9 = *((void *)*v8 + 2);
      if (v9)
      {
        CFIndex v10 = (uint64_t *)((char *)*v8 + 24);
        do
        {
          if (*(_DWORD *)(v9 + 8) == 6)
          {
            CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
            unint64_t v12 = CFDateCreate(0LL, Current);
            sub_1001081F4((CFTypeRef *)v9, v12, (uint64_t)v8);
            if (v12) {
              CFRelease(v12);
            }
          }

          uint64_t v13 = *v10++;
          uint64_t v9 = v13;
        }

        while (v13);
      }

      v18[0] = _NSConcreteStackBlock;
      v18[1] = 0x40000000LL;
      v18[2] = sub_1001082CC;
      v18[3] = &unk_100286F00;
      v18[4] = &v19;
      v18[5] = v1;
      void v18[6] = v6;
      v18[7] = v4;
      v18[8] = v2;
      v18[9] = v8;
      BOOL v14 = sub_1000163F4(v4, 2LL, (CFTypeRef *)v2, (uint64_t)v18);
      if (*((_BYTE *)v20 + 24)) {
        BOOL v15 = v14;
      }
      else {
        BOOL v15 = 0;
      }
      *((_BYTE *)v20 + 24) = v15;
      if (v15 && !*(_BYTE *)(v1 + 113))
      {
        BOOL v16 = sub_1000194E0(-25300, v2, @"No items updated");
        *((_BYTE *)v20 + 24) = v16;
      }
    }

    else
    {
      *((_BYTE *)v20 + 24) = 0;
    }

    if (sub_1000F8150(v8, (CFErrorRef *)v2))
    {
      BOOL v17 = *((unsigned __int8 *)v20 + 24) != 0;
    }

    else
    {
      BOOL v17 = 0LL;
      *((_BYTE *)v20 + 24) = 0;
    }
  }

  else
  {
    BOOL v17 = 0LL;
  }

  _Block_object_dispose(&v19, 8);
  return v17;
}

BOOL sub_1001155D0(const __CFDictionary *a1, uint64_t a2, __CFString **a3)
{
  uint64_t v6 = sub_100113BEC((CFArrayRef *)a2);
  if (!v6) {
    return sub_1000194E0( -34018,  a3,  @"Client has neither %@ entitlements",  @"application-identifier nor keychain-access-groups");
  }
  char v7 = v6;
  CFIndex Count = CFArrayGetCount((CFArrayRef)v6);
  if (!Count)
  {
    CFRelease(v7);
    return sub_1000194E0( -34018,  a3,  @"Client has neither %@ entitlements",  @"application-identifier nor keychain-access-groups");
  }

  CFIndex v9 = Count;
  signed int Value = (const __CFString *)CFDictionaryGetValue(a1, kSecAttrAccessGroup);
  if (!Value || (CFIndex v11 = Value, (sub_10010DD28((const __CFArray *)v7, Value, a2) & 1) != 0))
  {
    kdebug_trace(726794328LL, 0LL, 0LL, 0LL, 0LL);
    if (sub_10001891C())
    {
      CFArrayGetValueAtIndex((CFArrayRef)v7, 0LL);
      CFDictionaryRef v19 = sub_100107FA8(0LL, v12, v13, v14, v15, v16, v17, v18, (uint64_t)@"operation", (uint64_t)@"delete");
      if (v19)
      {
        CFDictionaryRef v20 = v19;
        sub_100018C10(@"SecItem", v19);
        CFRelease(v20);
      }
    }

    v31.location = 0LL;
    v31.length = v9;
    if (CFArrayContainsValue((CFArrayRef)v7, v31, @"*"))
    {
      CFRelease(v7);
      char v7 = 0LL;
    }

    uint64_t v21 = sub_1000F8790(a1, *(const void **)(a2 + 24), -1LL, a2, a3);
    if (!v21)
    {
      uint64_t v26 = 0LL;
LABEL_42:
      if (v7) {
        CFRelease(v7);
      }
      kdebug_trace(726794332LL, 0LL, 0LL, 0LL, 0LL);
      return v26;
    }

    uint64_t v22 = v21;
    int v23 = *(_DWORD *)(v21 + 192);
    if (v23 == 2 || v23 == 1 && *(_BYTE *)(a2 + 36))
    {
      uint64_t v24 = *(const void **)(v21 + 128);
      if (v24)
      {
        *(void *)(v22 + 128) = 0LL;
        CFRelease(v24);
      }

      *(void *)(v22 + 128) = CFDataCreateWithBytesNoCopy(0LL, byte_100205530, 16LL, kCFAllocatorNull);
    }

    else
    {
      *(_DWORD *)(v21 + 192) = 0;
    }

    sub_1000F98B4(v22, v7);
    if (*(_BYTE *)(a2 + 37) && (sub_1001132BC(a2) & 1) == 0)
    {
      int v28 = sub_1000194E0( -34020,  a3,  @"App clips are not permitted to use access groups other than application identifier");
LABEL_41:
      uint64_t v26 = sub_1000F8254(v22, v28, (CFErrorRef *)a3);
      goto LABEL_42;
    }

    if (*(_DWORD *)(v22 + 192) && !*(_BYTE *)(a2 + 16))
    {
      int v27 = @"client doesn't have entitlement for system keychain";
    }

    else
    {
      if (*(void *)(v22 + 104) != -1LL)
      {
        int v27 = @"match limit not supported by delete";
LABEL_39:
        int v29 = -50;
        goto LABEL_40;
      }

      if (*(void *)(v22 + 24) != *(void *)(v22 + 16))
      {
        int v27 = @"match not supported by delete";
        goto LABEL_39;
      }

      if (*(void *)(v22 + 64))
      {
        int v27 = @"value ref not supported by delete";
        goto LABEL_39;
      }

      if (*(void *)(v22 + 72) && *(void *)(v22 + 32))
      {
        int v27 = @"rowid and other attributes are mutually exclusive";
        goto LABEL_39;
      }

      if (*(void *)(v22 + 232) && *(void *)(v22 + 32) != 1LL)
      {
        int v27 = @"token persistent ref and other attributes are mutually exclusive";
        goto LABEL_39;
      }

      if (!*(_BYTE *)(v22 + 116) || !CFDictionaryContainsKey(*(CFDictionaryRef *)(v22 + 8), kSecAttrSharingGroup))
      {
        v30[0] = _NSConcreteStackBlock;
        v30[1] = 0x40000000LL;
        v30[2] = sub_10011597C;
        v30[3] = &unk_10028F648;
        v30[4] = a3;
        void v30[5] = v22;
        v30[6] = v7;
        int v28 = sub_100110ECC(1, 1, 0LL, (uint64_t)a3, (uint64_t)v30);
        goto LABEL_41;
      }

      int v27 = @"can't delete shared items without Keychain Sharing client entitlement";
    }

    int v29 = -34018;
LABEL_40:
    int v28 = sub_1000194E0(v29, a3, v27);
    goto LABEL_41;
  }

  sub_1000194E0(-34018, a3, @"Client explicitly specifies access group %@ but is only entitled for %@", v11, v7);
  CFRelease(v7);
  return 0LL;
}

BOOL sub_10011597C(uint64_t a1, uint64_t a2)
{
  int8x16_t v2 = *(CFTypeRef **)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_1001159E4;
  v4[3] = &unk_10028F628;
  void v4[4] = a2;
  __int128 v5 = *(_OWORD *)(a1 + 40);
  uint64_t v6 = v2;
  return sub_100105354(a2, 2LL, v2, (uint64_t)v4);
}

BOOL sub_1001159E4(uint64_t a1)
{
  return sub_100108830(*(void *)(a1 + 32), *(void *)(a1 + 40), *(void *)(a1 + 48), *(CFTypeRef **)(a1 + 56));
}

uint64_t sub_1001159F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __CFString **a5)
{
  if (*(_BYTE *)(a4 + 37)) {
    return sub_1000194E0(-34020, a5, @"App Clips may not call this API");
  }
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  v6[2] = sub_100115A84;
  v6[3] = &unk_10028F688;
  void v6[4] = a5;
  void v6[5] = a1;
  void v6[6] = a2;
  void v6[7] = a4;
  v6[8] = a3;
  return sub_100110ECC(1, 1, 0LL, (uint64_t)a5, (uint64_t)v6);
}

BOOL sub_100115A84(uint64_t a1, uint64_t a2)
{
  int8x16_t v2 = *(CFTypeRef **)(a1 + 32);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = sub_100115AF4;
  void v5[3] = &unk_10028F668;
  void v5[4] = a2;
  __int128 v6 = *(_OWORD *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 64);
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v2;
  uint64_t v9 = v3;
  return sub_100105354(a2, 2LL, v2, (uint64_t)v5);
}

uint64_t sub_100115AF4(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  uint64_t v9 = 0LL;
  CFErrorRef err = 0LL;
  v33[0] = kSecClassGenericPassword;
  v33[1] = kSecClassInternetPassword;
  v33[2] = kSecClassCertificate;
  v33[3] = kSecClassKey;
  do
  {
    uint64_t v10 = *(void *)(a1 + 32);
    CFIndex v11 = *(const void **)(a1 + 48);
    uint64_t v12 = *(void *)(a1 + 56);
    int v13 = sub_100107FA8(kCFAllocatorDefault, a2, a3, a4, a5, a6, a7, a8, (uint64_t)kSecClass, v33[v9]);
    uint64_t v14 = sub_1000F8790(v13, *(const void **)(v12 + 24), -1LL, v12, (__CFString **)&err);
    CFRelease(v13);
    if (!v14
      || (sub_1000F98B4(v14, v11),
          BOOL v15 = sub_100108830(v10, v14, (uint64_t)v11, (CFTypeRef *)&err),
          (sub_1000F8254(v14, v15, &err) & 1) == 0))
    {
      CFIndex Code = CFErrorGetCode(err);
      CFErrorRef v17 = err;
      if (Code != -25300)
      {
        if (err)
        {
          Block_layout v30 = *(CFErrorRef **)(a1 + 64);
          if (v30 && !*v30)
          {
            uint64_t result = 0LL;
            CFErrorRef *v30 = err;
            return result;
          }

          CFRelease(err);
        }

        return 0LL;
      }

      if (err)
      {
        CFErrorRef err = 0LL;
        CFRelease(v17);
      }
    }

    ++v9;
  }

  while (v9 != 4);
  int v18 = *(const __CFArray **)(a1 + 72);
  if (v18)
  {
    CFIndex v19 = 0LL;
    while (v19 < CFArrayGetCount(v18))
    {
      uint64_t v20 = *(void *)(a1 + 32);
      CFIndex v31 = v19;
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), v19);
      CFIndex v22 = 0LL;
      int v23 = *(const __CFArray **)(a1 + 48);
      uint64_t v24 = *(void *)(a1 + 56);
      int v25 = *(__CFString ***)(a1 + 64);
      while (v22 < CFArrayGetCount(v23))
      {
        uint64_t result = sub_1000F8790(ValueAtIndex, *(const void **)(v24 + 24), 0LL, v24, v25);
        if (!result) {
          return result;
        }
        int v27 = (uint64_t *)result;
        int v28 = (const __CFBoolean *)CFArrayGetValueAtIndex(v23, v22);
        sub_1000F7B40(kSecAttrAccessGroup, v28, (uint64_t)v27);
        sub_1000F8028(v27, v28);
        if (v27[5])
        {
          int v29 = 0;
        }

        else
        {
          sub_100108098((CFDictionaryRef *)v27);
          int v29 = sub_100105ABC(v20, (uint64_t)v27, 0LL, v25);
        }

        ++v22;
      }

      CFIndex v19 = v31 + 1;
      int v18 = *(const __CFArray **)(a1 + 72);
    }
  }

  return 1LL;
}

uint64_t sub_100115DAC(uint64_t a1)
{
  int8x16_t v2 = (os_log_s *)sub_10001267C("SecError");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SecItemServerDeleteAll", (uint8_t *)v4, 2u);
  }

  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_100115E5C;
  v4[3] = &unk_10028FC48;
  void v4[4] = a1;
  return sub_100110ECC(1, 1, 0LL, a1, (uint64_t)v4);
}

uint64_t sub_100115E5C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(CFTypeRef **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  v6[2] = sub_100115EE0;
  v6[3] = &unk_10028FC28;
  void v6[4] = a2;
  void v6[5] = v4;
  uint64_t result = sub_100105354(a2, 2LL, v4, (uint64_t)v6);
  if ((_DWORD)result) {
    return sub_100014F28(a2, @"VACUUM;", *(CFTypeRef **)(a1 + 32));
  }
  return result;
}

uint64_t sub_100115EE0(uint64_t a1)
{
  int v2 = sub_100014F28(*(void *)(a1 + 32), @"DELETE FROM genp WHERE sync=1;", *(CFTypeRef **)(a1 + 40));
  int v3 = v2 & sub_100014F28(*(void *)(a1 + 32), @"DELETE FROM inet WHERE sync=1;", *(CFTypeRef **)(a1 + 40));
  int v4 = sub_100014F28(*(void *)(a1 + 32), @"DELETE FROM cert WHERE sync=1;", *(CFTypeRef **)(a1 + 40));
  int v5 = v3 & v4 & sub_100014F28(*(void *)(a1 + 32), @"DELETE FROM keys WHERE sync=1;", *(CFTypeRef **)(a1 + 40));
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = sub_10010C560((uint64_t)@"genp", &qword_1002DEB28, (uint64_t)&unk_1002DEB20);
  LODWORD(v6) = sub_100116030(v6, v7, *(const void ***)(a1 + 40));
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = sub_10010C560((uint64_t)@"inet", &qword_1002DEB38, (uint64_t)&unk_1002DEB30);
  LODWORD(v8) = v6 & sub_100116030(v8, v9, *(const void ***)(a1 + 40));
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = sub_10010C560((uint64_t)@"cert", &qword_1002DEB48, (uint64_t)&unk_1002DEB40);
  LODWORD(v8) = v5 & v8 & sub_100116030(v10, v11, *(const void ***)(a1 + 40));
  uint64_t v12 = *(void *)(a1 + 32);
  uint64_t v13 = sub_10010C560((uint64_t)@"keys", &qword_1002DEB58, (uint64_t)&unk_1002DEB50);
  return v8 & sub_100116030(v12, v13, *(const void ***)(a1 + 40));
}

BOOL sub_100116030(uint64_t a1, uint64_t a2, const void **a3)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionaryAddValue(Mutable, kSecMatchLimit, kSecMatchLimitAll);
  uint64_t v16 = 0LL;
  CFErrorRef v17 = (CFTypeRef *)&v16;
  uint64_t v18 = 0x2000000000LL;
  CFIndex v19 = 0LL;
  uint64_t v7 = (CFDictionaryRef *)sub_1000F82CC(a2, 0LL, Mutable, 0LL, &v19);
  if (!v7)
  {
    uint64_t v13 = (os_log_s *)sub_10001267C("SecError");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      CFTypeRef v14 = v17[3];
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v21 = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "SecItemServerDeleteAll: aborting because failed to initialize Query: %@",  buf,  0xCu);
    }

    abort();
  }

  uint64_t v8 = (const void **)v7;
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000LL;
  v15[2] = sub_10011622C;
  v15[3] = &unk_10028FCB0;
  v15[5] = a2;
  v15[6] = a1;
  uint8_t v15[4] = &v16;
  sub_1000EA68C(v7, a1, v17 + 3, &stru_10028FC88, 0LL, 0LL, 0LL, (uint64_t)v15);
  sub_1000F8150(v8, (CFErrorRef *)v17 + 3);
  CFTypeRef v9 = v17[3];
  if (v9)
  {
    if (a3)
    {
      uint64_t v10 = *a3;
      CFTypeRef v11 = v17[3];
      if (*a3)
      {
        *a3 = 0LL;
        CFRelease(v10);
        CFTypeRef v11 = v17[3];
      }

      *a3 = v11;
    }

    else
    {
      v17[3] = 0LL;
      CFRelease(v9);
    }
  }

  _Block_object_dispose(&v16, 8);
  return v9 == 0LL;
}

uint64_t sub_10011622C(void *a1, uint64_t a2)
{
  uint64_t result = sub_100108D04(*(const __CFDictionary **)(a2 + 48), a1[5], 0);
  if ((result & 1) == 0)
  {
    signed int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 48), kSecAttrAccessGroup);
    uint64_t result = CFEqual(Value, @"com.apple.bluetooth");
    if (!(_DWORD)result) {
      return (uint64_t)sub_1000ECAF0( (CFStringRef **)a2,  a1[6],  kCFBooleanFalse,  0,  (CFTypeRef *)(*(void *)(a1[4] + 8LL) + 24LL));
    }
  }

  return result;
}

BOOL sub_1001162B4(id a1, const SecDbAttr *a2)
{
  return (a2->var2 & 2) != 0 && CFEqual(a2->var0, @"data") == 0;
}

uint64_t sub_1001162EC(const void *a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v15 = 0LL;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x2000000000LL;
  char v18 = 1;
  if (qword_1002DEBB0 != -1) {
    dispatch_once(&qword_1002DEBB0, &stru_10028F6C8);
  }
  v19[0] = sub_10010C560((uint64_t)@"inet", &qword_1002DEB38, (uint64_t)&unk_1002DEB30);
  v19[1] = sub_10010C560((uint64_t)@"genp", &qword_1002DEB28, (uint64_t)&unk_1002DEB20);
  v19[2] = sub_10010C560((uint64_t)@"keys", &qword_1002DEB58, (uint64_t)&unk_1002DEB50);
  v19[3] = sub_10010C560((uint64_t)@"cert", &qword_1002DEB48, (uint64_t)&unk_1002DEB40);
  if (a1)
  {
    CFTypeID v7 = CFGetTypeID(a1);
    if (v7 == CFArrayGetTypeID())
    {
      if (CFArrayGetCount((CFArrayRef)a1))
      {
        context[0] = _NSConcreteStackBlock;
        context[1] = 0x40000000LL;
        uint64_t context[2] = sub_10011657C;
        context[3] = &unk_10028F710;
        context[4] = &v15;
        context[5] = a3;
        void context[6] = a1;
        v20.length = CFArrayGetCount((CFArrayRef)a1);
        v20.location = 0LL;
        CFArrayApplyFunction((CFArrayRef)a1, v20, (CFArrayApplierFunction)sub_10010D388, context);
        if (*((_BYTE *)v16 + 24))
        {
          v13[0] = _NSConcreteStackBlock;
          v13[1] = 0x40000000LL;
          v13[2] = sub_100116644;
          v13[3] = &unk_10028F750;
          void v13[4] = a3;
          void v13[5] = v19;
          v13[6] = a2;
          v13[7] = a1;
          char v10 = sub_100110ECC(1, 1, 0LL, (uint64_t)a3, (uint64_t)v13);
          *((_BYTE *)v16 + 24) = v10;
        }
      }

      else
      {
        *((_BYTE *)v16 + 24) = 0;
        sub_1000194B4(1LL, @"com.apple.security.xpc", 0LL, a3, v9, @"accessGroups e empty");
      }
    }

    else
    {
      *((_BYTE *)v16 + 24) = 0;
      sub_1000194B4(1LL, @"com.apple.security.xpc", 0LL, a3, v8, @"accessGroups not CFArray, got %@", a1);
    }
  }

  else
  {
    *((_BYTE *)v16 + 24) = 0;
    sub_1000194B4(1LL, @"com.apple.security.xpc", 0LL, a3, v6, @"accessGroups not CFArray, got %@", 0LL);
  }

  uint64_t v11 = *((unsigned __int8 *)v16 + 24);
  _Block_object_dispose(&v15, 8);
  return v11;
}

void sub_10011657C(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (cf)
  {
    CFTypeID v7 = CFGetTypeID(cf);
    if (v7 == CFStringGetTypeID())
    {
      if (!CFSetContainsValue((CFSetRef)qword_1002DEBB8, cf)) {
        return;
      }
      sub_1000194B4( 1LL,  @"com.apple.security.xpc",  0LL,  *(CFTypeRef **)(a1 + 40),  v9,  @"illegal access group: %@",  *(void *)(a1 + 48));
    }

    else
    {
      sub_1000194B4( 1LL,  @"com.apple.security.xpc",  0LL,  *(CFTypeRef **)(a1 + 40),  v8,  @"access not a string: %@",  cf);
    }
  }

  else
  {
    sub_1000194B4( 1LL,  @"com.apple.security.xpc",  0LL,  *(CFTypeRef **)(a1 + 40),  a5,  @"access not a string: %@",  0LL);
  }

  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
}

uint64_t sub_100116644(uint64_t a1, uint64_t a2)
{
  int v4 = *(CFTypeRef **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  v6[2] = sub_1001166D8;
  v6[3] = &unk_10028F730;
  __int128 v7 = *(_OWORD *)(a1 + 40);
  uint64_t v8 = v4;
  uint64_t v9 = a2;
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t result = sub_100105354(a2, 2LL, v4, (uint64_t)v6);
  if ((_DWORD)result) {
    return sub_100014F28(a2, @"VACUUM", *(CFTypeRef **)(a1 + 32));
  }
  return result;
}

uint64_t sub_1001166D8(uint64_t a1)
{
  uint64_t v2 = 0LL;
  CFTypeRef cf = 0LL;
  do
  {
    int v3 = (const void **)sub_1000F82CC( *(void *)(*(void *)(a1 + 32) + v2),  *(const void **)(*(void *)(a1 + 40) + 24LL),  0LL,  *(void *)(a1 + 40),  *(__CFString ***)(a1 + 48));
    if (v3)
    {
      int v4 = v3;
      sub_100108830(*(void *)(a1 + 56), (uint64_t)v3, *(void *)(a1 + 64), &cf);
      int v5 = *(CFErrorRef **)(a1 + 48);
      int v3 = v4;
    }

    else
    {
      int v5 = *(CFErrorRef **)(a1 + 48);
    }

    sub_1000F8150(v3, v5);
    CFTypeRef v6 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v6);
    }

    v2 += 8LL;
  }

  while (v2 != 32);
  return 1LL;
}

void sub_100116774(id a1)
{
  v1[0] = *(_OWORD *)off_10028F6E8;
  v1[1] = *(_OWORD *)off_10028F6F8;
  qword_1002DEBB8 = (uint64_t)CFSetCreate(0LL, (const void **)v1, 4LL, &kCFTypeSetCallBacks);
}

uint64_t sub_1001167E8(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t *a5)
{
  uint64_t v14 = 0LL;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2000000000LL;
  uint64_t v17 = 0LL;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000LL;
  v12[2] = sub_10011696C;
  void v12[3] = &unk_10028F7A0;
  char v13 = a4;
  void v12[6] = a3;
  v12[7] = a5;
  void v12[4] = &v14;
  v12[5] = a2;
  v12[8] = a1;
  sub_100110ECC(0, 1, 0LL, (uint64_t)a5, (uint64_t)v12);
  CFTypeRef v6 = (os_log_s *)sub_10001267C("SecServerKeychainCreateBackup");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (v15[3]) {
      __int128 v7 = "success";
    }
    else {
      __int128 v7 = "fail";
    }
    if (a5) {
      uint64_t v8 = *a5;
    }
    else {
      uint64_t v8 = 0LL;
    }
    *(_DWORD *)__int128 buf = 136315394;
    CFIndex v19 = v7;
    __int16 v20 = 2112;
    uint64_t v21 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Backup result: %s (%@)", buf, 0x16u);
  }

  if (a5) {
    uint64_t v9 = *a5;
  }
  else {
    uint64_t v9 = 0LL;
  }
  LKABackupReportEnd(v15[3] != 0, v9);
  uint64_t v10 = v15[3];
  _Block_object_dispose(&v14, 8);
  return v10;
}

BOOL sub_10011696C(uint64_t a1, uint64_t a2)
{
  LKABackupReportStart(*(void *)(a1 + 40) != 0LL, *(void *)(a1 + 48) != 0LL, *(unsigned __int8 *)(a1 + 72));
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000LL;
  v7[2] = sub_100116A14;
  void v7[3] = &unk_10028F778;
  char v12 = *(_BYTE *)(a1 + 72);
  uint64_t v4 = *(void *)(a1 + 48);
  __int128 v8 = *(_OWORD *)(a1 + 32);
  uint64_t v9 = v4;
  uint64_t v10 = a2;
  int v5 = *(CFTypeRef **)(a1 + 56);
  int8x16_t v11 = vextq_s8(*(int8x16_t *)(a1 + 56), *(int8x16_t *)(a1 + 56), 8uLL);
  return sub_100105354(a2, 3LL, v5, (uint64_t)v7);
}

BOOL sub_100116A14(uint64_t a1)
{
  uint64_t v2 = (os_log_s *)sub_10001267C("SecServerKeychainCreateBackup");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 40)) {
      int v3 = "provided";
    }
    else {
      int v3 = "device";
    }
    uint64_t v4 = ", EMCS mode";
    if (!*(_BYTE *)(a1 + 80)) {
      uint64_t v4 = "";
    }
    *(_DWORD *)__int128 buf = 136315394;
    *(void *)&uint8_t buf[4] = v3;
    __int16 v20 = 2080;
    uint64_t v21 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Performing backup from %s keybag%s", buf, 0x16u);
  }

  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v7 = *(void *)(a1 + 56);
  if (*(_OWORD *)(a1 + 40) == 0LL)
  {
    CFDataRef v8 = sub_100116CF0(*(void *)(a1 + 56), 0LL, *(__CFString ***)(a1 + 72));
    goto LABEL_24;
  }

  int v9 = *(unsigned __int8 *)(a1 + 80);
  uint64_t v10 = *(CFTypeRef **)(a1 + 72);
  int v17 = -1431655766;
  kdebug_trace(726794272LL, 0LL, 0LL, 0LL, 0LL);
  *(void *)__int128 buf = 0LL;
  uint64_t v11 = MKBKeyBagCreateWithData(v6, buf);
  if (!(_DWORD)v11)
  {
    if (v9)
    {
      char v13 = (os_log_s *)sub_10001267C("keychainbackup");
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)char v18 = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "skipping keybag unlock for EMCS", v18, 2u);
      }
    }

    else
    {
      uint64_t v14 = MKBKeyBagUnlock(*(void *)buf, v5);
      if ((_DWORD)v14)
      {
        uint64_t v15 = v14;
        CFRelease(*(CFTypeRef *)buf);
        if (sub_1000190E4(v15, v10, @"failed to unlock bag: %d", v15)) {
          goto LABEL_12;
        }
LABEL_18:
        kdebug_trace(726794276LL, 0LL, 0LL, 0LL, 0LL);
        CFDataRef v8 = 0LL;
        goto LABEL_24;
      }
    }

    char v12 = *(const void **)buf;
    goto LABEL_20;
  }

  if (!sub_1000190E4(v11, v10, @"MKBKeyBagCreateWithData failed: %d", v11)) {
    goto LABEL_18;
  }
LABEL_12:
  char v12 = 0LL;
LABEL_20:
  if (MKBKeyBagGetAKSHandle(v12, &v17))
  {
    CFDataRef v8 = 0LL;
  }

  else
  {
    kdebug_trace(726794276LL, 0LL, 0LL, 0LL, 0LL);
    kdebug_trace(726794264LL, 0LL, 0LL, 0LL, 0LL);
    CFDataRef v8 = sub_100116CF0(v7, &v17, (__CFString **)v10);
  }

  kdebug_trace(726794276LL, 0LL, 0LL, 0LL, 0LL);
  if (v12) {
    CFRelease(v12);
  }
LABEL_24:
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v8;
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

CFDataRef sub_100116CF0(uint64_t a1, int *a2, __CFString **a3)
{
  uint64_t v6 = sub_100109FDC(a1, a2, 2u, a3);
  if (v6)
  {
    uint64_t v7 = v6;
    CFDataRef Data = CFPropertyListCreateData(kCFAllocatorDefault, v6, kCFPropertyListBinaryFormat_v1_0, 0LL, (CFErrorRef *)a3);
    CFRelease(v7);
  }

  else
  {
    CFDataRef Data = 0LL;
  }

  kdebug_trace(726794300LL, 0LL, 0LL, 0LL, 0LL);
  return Data;
}

uint64_t sub_100116DAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __CFString **a5)
{
  if (!a1 || !a3) {
    return sub_1000194E0(-50, a5, @"backup or keybag missing");
  }
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000LL;
  v6[2] = sub_100116E44;
  v6[3] = &unk_10028F7C0;
  void v6[4] = a2;
  void v6[5] = a1;
  void v6[6] = a3;
  void v6[7] = a4;
  v6[8] = a5;
  uint64_t result = sub_100110ECC(1, 1, 0LL, (uint64_t)a5, (uint64_t)v6);
  if ((_DWORD)result)
  {
    sub_10010C930();
    sub_10010C8E0();
    return 1LL;
  }

  return result;
}

uint64_t sub_100116E44(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[4];
  uint64_t v4 = a1[5];
  uint64_t v6 = (const __CFData *)a1[6];
  uint64_t v5 = (const __CFData *)a1[7];
  uint64_t v7 = (CFTypeRef *)a1[8];
  int v25 = -1;
  *(void *)&__int128 v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v26[2] = v8;
  v26[3] = v8;
  v26[0] = v8;
  v26[1] = v8;
  int v9 = (os_log_s *)sub_10001267C("SecServerKeychainRestore");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Restoring keychain backup", (uint8_t *)&buf, 2u);
  }

  kdebug_trace(726794248LL, 0LL, 0LL, 0LL, 0LL);
  BytePtr = CFDataGetBytePtr(v6);
  CFIndex Length = CFDataGetLength(v6);
  if (v5)
  {
    char v12 = CFDataGetBytePtr(v5);
    CFIndex v13 = CFDataGetLength(v5);
  }

  else
  {
    char v12 = 0LL;
    CFIndex v13 = 0LL;
  }

  uint64_t v14 = sub_100005D04(BytePtr, Length, (uint64_t)v12, v13, &v25, v26);
  if ((_DWORD)v14)
  {
    uint64_t v15 = v14;
    uint64_t v16 = (os_log_s *)sub_10001267C("SecWarning");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 67109120;
      DWORD1(buf) = v15;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "SecServerKeychainRestore: aks_kc_backup_open_keybag failed: %d",  (uint8_t *)&buf,  8u);
    }

    if (v7) {
      sub_1000190E4(v15, v7, @"aks_kc_backup_open_keybag failed: %d", v15);
    }
    kdebug_trace(726794244LL, 0LL, 0LL, 0LL, 0LL);
LABEL_20:
    CFIndex v22 = (os_log_s *)sub_10001267C("SecWarning");
    BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (v23)
    {
      if (v7) {
        CFTypeRef v24 = *v7;
      }
      else {
        CFTypeRef v24 = 0LL;
      }
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v24;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "SecServerKeychainRestore: Restore failed with: %@",  (uint8_t *)&buf,  0xCu);
      return 0LL;
    }

    return result;
  }

  int v17 = (os_log_s *)sub_10001267C("SecServerKeychainRestore");
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 67109120;
    DWORD1(buf) = v25;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "aks_kc_backup_open_keybag got backup_keybag:%d",  (uint8_t *)&buf,  8u);
  }

  kdebug_trace(726794252LL, 0LL, 0LL, 0LL, 0LL);
  kdebug_trace(726794240LL, 0LL, 0LL, 0LL, 0LL);
  char v18 = v26;
  if (v25 != -1) {
    char v18 = 0LL;
  }
  *(void *)&__int128 buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 0x40000000LL;
  int v28 = sub_1001171E8;
  int v29 = &unk_10028FCD0;
  uint64_t v30 = v4;
  CFIndex v31 = v7;
  uint64_t v32 = a2;
  uint64_t v33 = v3;
  int v34 = v18;
  int v35 = v25;
  int v36 = 0;
  BOOL v19 = sub_100105354(a2, 2LL, v7, (uint64_t)&buf);
  kdebug_trace(726794244LL, 0LL, 0LL, 0LL, 0LL);
  if (!v19) {
    goto LABEL_20;
  }
  __int16 v20 = (os_log_s *)sub_10001267C("SecServerKeychainRestore");
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Restore completed successfully",  (uint8_t *)&buf,  2u);
  }

  return 1LL;
}

BOOL sub_1001171E8(uint64_t a1)
{
  uint64_t v2 = (const __CFDictionary *)CFPropertyListCreateWithData( kCFAllocatorDefault,  *(CFDataRef *)(a1 + 32),  0LL,  0LL,  *(CFErrorRef **)(a1 + 40));
  if (v2)
  {
    uint64_t v3 = v2;
    CFTypeID v4 = CFGetTypeID(v2);
    if (v4 == CFDictionaryGetTypeID()) {
      BOOL v5 = sub_10010ADD4( *(void *)(a1 + 48),  *(void *)(a1 + 56),  *(_DWORD *)(a1 + 72),  *(void *)(a1 + 64),  *(_DWORD *)(a1 + 76),  v3,  2,  0,  *(__CFString ***)(a1 + 40));
    }
    else {
      BOOL v5 = sub_1000194E0(-50, *(__CFString ***)(a1 + 40), @"import: keychain is not a dictionary");
    }
    BOOL v6 = v5;
    CFRelease(v3);
  }

  else
  {
    BOOL v6 = 0LL;
  }

  kdebug_trace(726794308LL, 0LL, 0LL, 0LL, 0LL);
  return v6;
}

const void *sub_1001172D8(CFDataRef data, CFErrorRef *error)
{
  uint64_t v3 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, data, 0LL, 0LL, error);
  if (v3)
  {
    CFTypeID v4 = v3;
    CFTypeID v5 = CFGetTypeID(v3);
    if (v5 == CFDictionaryGetTypeID())
    {
      signed int Value = CFDictionaryGetValue(v4, @"keybag-uuid");
      if (Value)
      {
        uint64_t v7 = Value;
        CFTypeID v8 = CFGetTypeID(Value);
        if (v8 == CFStringGetTypeID())
        {
          CFRetain(v7);
LABEL_9:
          CFRelease(v4);
          return v7;
        }
      }

      sub_1000194E0( -26275,  (__CFString **)error,  @"Missing or invalid %@ in backup dictionary",  @"keybag-uuid");
    }

    uint64_t v7 = 0LL;
    goto LABEL_9;
  }

  return 0LL;
}

CFMutableArrayRef sub_1001173B4(uint64_t a1)
{
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  uint64_t v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    LOWORD(v28) = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCHandleUpdateMessage",  " enableTelemetry=YES ",  (uint8_t *)&v28,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  CFIndex v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    int v28 = 134217984;
    os_signpost_id_t v29 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCHandleUpdateMessage  enableTelemetry=YES ",  (uint8_t *)&v28,  0xCu);
  }

  uint64_t v16 = sub_1001C41CC(v14, v15);
  int v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
  if (v17) {
    CFMutableArrayRef updated = (CFMutableArrayRef)SOSCloudKeychainHandleUpdateMessage(a1);
  }
  else {
    CFMutableArrayRef updated = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  }
  CFMutableArrayRef v19 = updated;
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v21 = _OctagonSignpostLogSystem(Nanoseconds);
  CFIndex v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
  BOOL v23 = v22;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v22))
  {
    int v28 = 67240192;
    LODWORD(v29) = v19 != 0LL;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v23,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCHandleUpdateMessage",  " SOSSignpostNameSOSCCHandleUpdateMessage=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCHandleUpdateMessage}d ",  (uint8_t *)&v28,  8u);
  }

  uint64_t v25 = _OctagonSignpostLogSystem(v24);
  uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue(v25);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    int v28 = 134218496;
    os_signpost_id_t v29 = v4;
    __int16 v30 = 2048;
    double v31 = (double)Nanoseconds / 1000000000.0;
    __int16 v32 = 1026;
    BOOL v33 = v19 != 0LL;
    _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCHandleUpdateMessage  SOSSignpostNameSOSCCHandleUpdateMessage=%{public,signpost.telemetry:numb er1,name=SOSSignpostNameSOSCCHandleUpdateMessage}d ",  (uint8_t *)&v28,  0x1Cu);
  }

  return v19;
}

uint64_t sub_10011761C(const void *a1, CFTypeRef cf, const void *a3, __CFString **a4)
{
  if (!cf)
  {
    CFTypeRef v40 = 0LL;
LABEL_57:
    sub_1000194E0(-50, a4, @"keybag %@ not a data", v40);
    return 0LL;
  }

  CFTypeID v8 = CFGetTypeID(cf);
  if (v8 != CFDataGetTypeID())
  {
    CFTypeRef v40 = cf;
    goto LABEL_57;
  }

  if (a1)
  {
    CFTypeID v9 = CFGetTypeID(a1);
    if (v9 != CFDictionaryGetTypeID())
    {
      sub_1000194E0(-50, a4, @"backup %@ not a dictionary", a1);
      return 0LL;
    }
  }

  if (a3)
  {
    CFTypeID v10 = CFGetTypeID(a3);
    if (v10 != CFDataGetTypeID())
    {
      sub_1000194E0(-50, a4, @"password %@ not a data", a3);
      return 0LL;
    }
  }

  CFTypeRef cfa = 0LL;
  CFTypeRef v57 = 0LL;
  uint64_t v52 = 0LL;
  int v53 = &v52;
  uint64_t v54 = 0x2000000000LL;
  uint64_t v55 = 0LL;
  int v51 = -1431655766;
  if (!sub_100120628((const __CFData *)cf, (const __CFData *)a3, &v51, (CFTypeRef *)a4)) {
    goto LABEL_53;
  }
  uint64_t v11 = sub_1001110DC(0LL);
  uint64_t v12 = sub_100101A94(v11);
  sub_100019570(v12 != 0, (CFTypeRef *)a4, @"No datasource");
  if (v12)
  {
    uint64_t v13 = (*(uint64_t (**)(uint64_t, const CFStringRef, __CFString **))(v12 + 8))( v12,  kSecAttrAccessibleWhenUnlocked,  a4);
    if (v13)
    {
      uint64_t v14 = v13;
      if (a1)
      {
        MutableCFArrayRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, (CFDictionaryRef)a1);
        v53[3] = (uint64_t)MutableCopy;
        uint64_t v16 = (const __CFDictionary *)a1;
      }

      else
      {
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        v53[3] = (uint64_t)Mutable;
        uint64_t v16 = 0LL;
      }

      char v18 = (const void *)sub_100102360(v16, (CFTypeRef *)a4);
      uint64_t v19 = *(void *)v14;
      if (-[OTSOSActualAdapter sosEnabled]_0((uint64_t)v18, v20))
      {
        uint64_t v41 = 0LL;
        uint64_t v42 = (uint64_t)&v41;
        uint64_t v43 = 0x2020000000LL;
        uint64_t v44 = 0LL;
        *(void *)&__int128 buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 3221225472LL;
        uint64_t v63 = sub_1000D4E04;
        __int128 v64 = &unk_1002858A8;
        uint64_t v65 = &v41;
        uint64_t v66 = v19;
        uint64_t v67 = 0LL;
        sub_1000D4E44(v19, 0LL, &buf);
        uint64_t v21 = *(const void **)(v42 + 24);
        _Block_object_dispose(&v41, 8);
        if (v21) {
          goto LABEL_18;
        }
      }

      else
      {
        uint64_t v22 = SOSCCSetSOSDisabledError(0LL);
      }

      uint64_t V0ViewSet = SOSViewsGetV0ViewSet(v22);
      uint64_t v21 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t, __CFString **))(v14 + 24))(v14, V0ViewSet, a4);
      if (!v21)
      {
        uint64_t v25 = (const void *)v53[3];
        if (v25)
        {
          v53[3] = 0LL;
          CFRelease(v25);
        }

        uint64_t v26 = (os_log_s *)sub_10001267C("SecError");
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          if (a4) {
            int v27 = *a4;
          }
          else {
            int v27 = 0LL;
          }
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v27;
          _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "failed to obtain manifest for keychain: %@",  (uint8_t *)&buf,  0xCu);
        }

        CFTypeRef v24 = 0LL;
        uint64_t v21 = 0LL;
LABEL_27:
        v50[0] = _NSConcreteStackBlock;
        v50[1] = 0x40000000LL;
        v50[2] = sub_100117B7C;
        v50[3] = &unk_10028FCF8;
        v50[4] = &v52;
        sub_1001AACD0((uint64_t)v24, (uint64_t)v50);
        int v28 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
        uint64_t v41 = _NSConcreteStackBlock;
        uint64_t v42 = 0x40000000LL;
        uint64_t v43 = (uint64_t)sub_100117C38;
        uint64_t v44 = &unk_10028FD20;
        int v49 = v51;
        uint64_t v47 = v14;
        uint64_t v48 = a4;
        CFRange v45 = &v52;
        uint64_t v46 = v28;
        if (((*(uint64_t (**)(uint64_t, void, CFTypeRef, __CFString **, void ***))(v14 + 32))( v14,  0LL,  cfa,  a4,  &v41) & 1) == 0)
        {
          os_signpost_id_t v29 = (const void *)v53[3];
          if (v29)
          {
            v53[3] = 0LL;
            CFRelease(v29);
          }
        }

        CFIndex Count = CFArrayGetCount(v28);
        if (!Count) {
          goto LABEL_37;
        }
        if (-[OTSOSActualAdapter sosEnabled]_0(Count, v31))
        {
          uint64_t v58 = 0LL;
          __darwin_time_t v59 = &v58;
          uint64_t v60 = 0x2020000000LL;
          char v61 = 1;
          *(void *)&__int128 buf = _NSConcreteStackBlock;
          *((void *)&buf + 1) = 3221225472LL;
          uint64_t v63 = sub_1000D4F54;
          __int128 v64 = &unk_100285858;
          uint64_t v65 = (void ***)&v58;
          uint64_t v66 = v19;
          uint64_t v67 = 0LL;
          BOOL v68 = v28;
          BOOL v69 = a4;
          dispatch_sync(*(dispatch_queue_t *)(v19 + 112), &buf);
          int v32 = *((unsigned __int8 *)v59 + 24);
          _Block_object_dispose(&v58, 8);
          if (v32)
          {
LABEL_37:
            if (v28) {
              CFRelease(v28);
            }
            if (((*(uint64_t (**)(uint64_t, __CFString **))(v14 + 72))(v14, a4) & 1) == 0)
            {
              int v34 = (const void *)v53[3];
              if (v34)
              {
                v53[3] = 0LL;
                CFRelease(v34);
              }
            }

            if (v18) {
              CFRelease(v18);
            }
            if (v21) {
              CFRelease(v21);
            }
            goto LABEL_46;
          }
        }

        else
        {
          SOSCCSetSOSDisabledError(a4);
        }

        BOOL v33 = (const void *)v53[3];
        if (v33)
        {
          v53[3] = 0LL;
          CFRelease(v33);
        }

        goto LABEL_37;
      }

LABEL_46:
  if (cfa) {
    CFRelease(cfa);
  }
  if (v57) {
    CFRelease(v57);
  }
  BOOL v35 = sub_100120750(v51, (CFTypeRef *)a4);
  int v36 = v53;
  if (v35) {
    goto LABEL_54;
  }
  uint64_t v37 = (const void *)v53[3];
  if (!v37) {
    goto LABEL_54;
  }
  v53[3] = 0LL;
  CFRelease(v37);
LABEL_53:
  int v36 = v53;
LABEL_54:
  uint64_t v38 = v36[3];
  _Block_object_dispose(&v52, 8);
  return v38;
}

  v6[2] = self->_networkResponseBodyBytesReceived;
  *((_DWORD *)v6 + 70) |= 2u;
  if ((*(_DWORD *)&self->_has & 0x40000) != 0)
  {
LABEL_12:
    *((_DWORD *)v6 + 46) = self->_networkPreviousAttemptCount;
    *((_DWORD *)v6 + 70) |= 0x40000u;
  }

  CFTypeRef v24 = 0LL;
  if ((*(_WORD *)&v5 & 0x400) != 0)
  {
LABEL_35:
    BOOL v23 = 2654435761u * self->_timestampRequestEnd;
    if ((*(_WORD *)&v5 & 0x2000) != 0) {
      goto LABEL_36;
    }
LABEL_48:
    uint64_t v22 = 0LL;
    if ((*(_WORD *)&v5 & 0x1000) != 0) {
      goto LABEL_37;
    }
    goto LABEL_49;
  }

    CFTypeID v10 = 1;
    goto LABEL_58;
  }

  CFTypeRef cf = 0LL;
  CFTypeRef cf2 = 0LL;
LABEL_17:
  CFTypeID v10 = 0;
LABEL_58:
  CFTypeRef v40 = cf2;
  if (cf2)
  {
    CFTypeRef cf2 = 0LL;
    CFRelease(v40);
  }

  uint64_t v41 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v41);
  }

void sub_100117B64(_Unwind_Exception *a1, uint64_t a2, ...)
{
}

void sub_100117B7C(uint64_t a1, CFDataRef theData)
{
  CFIndex Length = CFDataGetLength(theData);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex v7 = CFDataGetLength(theData);
  if (v7 >= 1)
  {
    CFIndex v8 = v7;
    do
    {
      unsigned int v9 = *BytePtr++;
      CFStringAppendFormat(Mutable, 0LL, @"%02X", v9);
      --v8;
    }

    while (v8);
  }

  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), Mutable);
  CFRelease(Mutable);
}

void sub_100117C38(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  CFTypeRef cf = 0LL;
  if (!a3)
  {
    uint64_t v20 = *(__CFArray **)(a1 + 40);
    values = a2;
    CFArrayRef v21 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1LL, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(v20, v21);
    if (!v21) {
      return;
    }
    CFArrayRef v22 = v21;
    goto LABEL_22;
  }

  CFIndex v8 = (const __CFData *)(*(uint64_t (**)(uint64_t, CFTypeRef *))(*(void *)(a1 + 48) + 112LL))(a3, &cf);
  if (!v8
    || (uint64_t v9 = (*(uint64_t (**)(uint64_t, void, CFTypeRef *))(*(void *)(a1 + 48) + 144LL))( a3,  *(int *)(a1 + 64),  &cf)) == 0)
  {
    if (SecErrorGetOSStatus(cf) == -26275)
    {
      CFRelease(cf);
      int v17 = *(__CFArray **)(a1 + 40);
      values = a2;
      CFArrayRef v18 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1LL, &kCFTypeArrayCallBacks);
      CFArrayAppendValue(v17, v18);
      if (v18)
      {
        CFArrayRef v19 = v18;
LABEL_16:
        CFRelease(v19);
      }
    }

    else
    {
      *a4 = 1;
      **(void **)(a1 + 56) = cf;
      uint64_t v23 = *(void *)(*(void *)(a1 + 32) + 8LL);
      CFArrayRef v19 = *(CFArrayRef *)(v23 + 24);
      if (v19)
      {
        *(void *)(v23 + 24) = 0LL;
        goto LABEL_16;
      }
    }

    CFTypeID v10 = 0LL;
    goto LABEL_18;
  }

  CFTypeID v10 = (const void *)v9;
  CFIndex Length = CFDataGetLength(v8);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
  BytePtr = CFDataGetBytePtr(v8);
  CFIndex v14 = CFDataGetLength(v8);
  if (v14 >= 1)
  {
    CFIndex v15 = v14;
    do
    {
      unsigned int v16 = *BytePtr++;
      CFStringAppendFormat(Mutable, 0LL, @"%02X", v16);
      --v15;
    }

    while (v15);
  }

  CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), Mutable, v10);
  if (Mutable) {
    CFRelease(Mutable);
  }
LABEL_18:
  if (v8) {
    CFRelease(v8);
  }
  if (v10)
  {
    CFArrayRef v22 = (CFArrayRef)v10;
LABEL_22:
    CFRelease(v22);
  }

BOOL sub_100117E70(const void *a1, CFTypeRef cf, const void *a3, __CFString **a4)
{
  if (!cf)
  {
    CFTypeRef v19 = 0LL;
    return sub_1000194E0(-50, a4, @"keybag %@ not a data", v19);
  }

  CFTypeID v8 = CFGetTypeID(cf);
  if (v8 != CFDataGetTypeID())
  {
    CFTypeRef v19 = cf;
    return sub_1000194E0(-50, a4, @"keybag %@ not a data", v19);
  }

  if (!a1)
  {
    uint64_t v20 = 0LL;
    return sub_1000194E0(-50, a4, @"backup %@ not a dictionary", v20);
  }

  CFTypeID v9 = CFGetTypeID(a1);
  if (v9 != CFDictionaryGetTypeID())
  {
    uint64_t v20 = a1;
    return sub_1000194E0(-50, a4, @"backup %@ not a dictionary", v20);
  }

  if (a3)
  {
    CFTypeID v10 = CFGetTypeID(a3);
    if (v10 != CFDataGetTypeID()) {
      return sub_1000194E0(-50, a4, @"password not a data");
    }
  }

  uint64_t v24 = 0LL;
  uint64_t v25 = &v24;
  uint64_t v26 = 0x2000000000LL;
  char v27 = 1;
  int v23 = -1431655766;
  if (sub_100120628((const __CFData *)cf, (const __CFData *)a3, &v23, (CFTypeRef *)a4))
  {
    uint64_t v11 = sub_100102360((const __CFDictionary *)a1, (CFTypeRef *)a4);
    if (v11)
    {
      uint64_t v12 = (const void *)v11;
      uint64_t v13 = sub_1001110DC(0LL);
      uint64_t v14 = sub_100101A94(v13);
      sub_100019570(v14 != 0, (CFTypeRef *)a4, @"No datasource");
      if (v14)
      {
        uint64_t v15 = (*(uint64_t (**)(uint64_t, const CFStringRef, __CFString **))(v14 + 8))( v14,  kSecAttrAccessibleWhenUnlocked,  a4);
        if (v15)
        {
          v21[0] = _NSConcreteStackBlock;
          v21[1] = 0x40000000LL;
          v21[2] = sub_1001180B8;
          v21[3] = &unk_10028FD70;
          v21[6] = a4;
          v21[7] = v12;
          v21[8] = a1;
          int v22 = v23;
          v21[4] = &v24;
          v21[5] = v15;
          LOBYTE(v15) = (*(uint64_t (**)(uint64_t, __CFString **, void, void, void *))(v15 + 64))( v15,  a4,  0LL,  0LL,  v21);
        }
      }

      else
      {
        LOBYTE(v15) = 0;
      }

      *((_BYTE *)v25 + 24) &= v15;
      CFRelease(v12);
    }

    BOOL v17 = sub_100120750(v23, (CFTypeRef *)a4);
    if (*((_BYTE *)v25 + 24)) {
      BOOL v16 = v17;
    }
    else {
      BOOL v16 = 0LL;
    }
    *((_BYTE *)v25 + 24) = v16;
  }

  else
  {
    BOOL v16 = 0LL;
  }

  _Block_object_dispose(&v24, 8);
  return v16;
}

void sub_1001180B8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t V0BackupViewSet = SOSViewsGetV0BackupViewSet();
  uint64_t v6 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(v4 + 24))( v4,  V0BackupViewSet,  *(void *)(a1 + 48));
  uint64_t v17 = 0LL;
  CFArrayRef v18 = 0LL;
  sub_1001AAED8((uint64_t)v6, *(void *)(a1 + 56), (uint64_t *)&v18, (const void **)&v17, *(CFTypeRef **)(a1 + 48));
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000LL;
  v15[2] = sub_1001181D4;
  v15[3] = &unk_10028FD48;
  uint64_t v7 = *(void *)(a1 + 32);
  v15[6] = *(void *)(a1 + 40);
  void v15[7] = a2;
  int v16 = *(_DWORD *)(a1 + 72);
  uint64_t v8 = *(void *)(a1 + 64);
  uint8_t v15[4] = v7;
  v15[5] = v8;
  v15[8] = *(void *)(a1 + 48);
  sub_1001AACD0(v17, (uint64_t)v15);
  uint64_t v9 = *(void *)(a1 + 40);
  if (v9) {
    char v10 = (*(uint64_t (**)(uint64_t, void))(v9 + 72))(v9, *(void *)(a1 + 48));
  }
  else {
    char v10 = 1;
  }
  uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if (*(_BYTE *)(v11 + 24)) {
    char v12 = v10;
  }
  else {
    char v12 = 0;
  }
  *(_BYTE *)(v11 + 24) = v12;
  uint64_t v13 = v18;
  if (v18)
  {
    CFArrayRef v18 = 0LL;
    CFRelease(v13);
  }

  uint64_t v14 = (const void *)v17;
  if (v17)
  {
    uint64_t v17 = 0LL;
    CFRelease(v14);
  }

  if (v6) {
    CFRelease(v6);
  }
}

void sub_1001181D4(uint64_t a1, CFDataRef theData, _BYTE *a3)
{
  CFIndex Length = CFDataGetLength(theData);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex v9 = CFDataGetLength(theData);
  if (v9 >= 1)
  {
    CFIndex v10 = v9;
    do
    {
      unsigned int v11 = *BytePtr++;
      CFStringAppendFormat(Mutable, 0LL, @"%02X", v11);
      --v10;
    }

    while (v10);
  }

  if (Mutable)
  {
    signed int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), Mutable);
    CFRelease(Mutable);
    if (Value)
    {
      CFTypeRef cf = 0LL;
      if (((*(uint64_t (**)(void, void, const void *, CFTypeRef *))(*(void *)(a1 + 48) + 104LL))( *(void *)(a1 + 56),  *(int *)(a1 + 72),  Value,  &cf) & 1) == 0)
      {
        int OSStatus = SecErrorGetOSStatus(cf);
        if (OSStatus != -26275)
        {
          if (OSStatus == -25308)
          {
            *a3 = 1;
          }

          else if (OSStatus == -25299)
          {
            uint64_t v14 = (os_log_s *)sub_10001267C("titc");
            if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_20;
            }
            *(_DWORD *)__int128 buf = 138477827;
            int v23 = Value;
            uint64_t v15 = "restore %{private}@ not replacing existing item";
            int v16 = v14;
            uint32_t v17 = 12;
            goto LABEL_14;
          }

          CFTypeRef v19 = (os_log_s *)sub_10001267C("SecError");
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138478083;
            int v23 = Value;
            __int16 v24 = 2112;
            CFTypeRef v25 = cf;
            _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "restore %{private}@ failed %@",  buf,  0x16u);
          }

          *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
          uint64_t v20 = *(CFTypeRef **)(a1 + 64);
          if (v20 && !*v20)
          {
            CFTypeRef *v20 = cf;
            return;
          }

          goto LABEL_20;
        }

        CFArrayRef v18 = (os_log_s *)sub_10001267C("titc");
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_20;
        }
        *(_DWORD *)__int128 buf = 138478083;
        int v23 = Value;
        __int16 v24 = 2112;
        CFTypeRef v25 = cf;
        uint64_t v15 = "restore %{private}@ skipping corrupted item %@";
        int v16 = v18;
        uint32_t v17 = 22;
LABEL_14:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
LABEL_20:
        if (cf) {
          CFRelease(cf);
        }
      }
    }
  }

uint64_t sub_100118464(char a1, uint64_t a2)
{
  return sub_100118470(a1, 0LL, a2);
}

uint64_t sub_100118470(char a1, uint64_t a2, uint64_t a3)
{
  int v11 = 0;
  int v6 = sub_1000060EC(0, 0, &v11);
  uint64_t result = 0LL;
  if (!v6)
  {
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000LL;
    v8[2] = sub_10011851C;
    v8[3] = &unk_10028F7E0;
    int v9 = v11 & 1;
    char v10 = a1;
    v8[4] = a2;
    v8[5] = a3;
    return sub_100110ECC(1, 1, 0LL, a3, (uint64_t)v8);
  }

  return result;
}

BOOL sub_10011851C(uint64_t a1, const void *a2)
{
  BOOL result = sub_10010C008(a2, *(_DWORD *)(a1 + 48));
  if (*(_BYTE *)(a1 + 52) && !result)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v5 = *(CFTypeRef **)(a1 + 40);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 0x40000000LL;
    v10[2] = sub_10010C2D8;
    v10[3] = &unk_100287248;
    v10[4] = v5;
    v10[5] = a2;
    v10[6] = v6;
    uint64_t v7 = (os_log_s *)sub_10001267C("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Completed roll keys.", (uint8_t *)v10, 2u);
    }

    if (sub_10010C008(a2, *(_DWORD *)(a1 + 48)))
    {
      return 1LL;
    }

    else
    {
LABEL_8:
      uint64_t v8 = (os_log_s *)sub_10001267C("SecError");
      BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
      BOOL result = 0LL;
      if (v9)
      {
        LOWORD(v10[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Failed to roll keys.", (uint8_t *)v10, 2u);
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t sub_10011865C( uint64_t a1, char a2, const __CFBoolean *a3, const __CFBoolean *a4, uint64_t a5, __CFString **a6)
{
  int v11 = (const void **)sub_1000F82CC(a5, 0LL, 0LL, 0LL, a6);
  if (!v11) {
    return 0LL;
  }
  char v12 = v11;
  *((_DWORD *)v11 + 12) = 3;
  v11[13] = (const void *)-1LL;
  *((_DWORD *)v11 + 30) = 0;
  sub_1000F7B40(kSecAttrAccessGroup, a3, (uint64_t)v11);
  sub_1000F7B40(kSecAttrSynchronizable, kCFBooleanTrue, (uint64_t)v12);
  sub_1000F7B40(kSecAttrTombstone, kCFBooleanFalse, (uint64_t)v12);
  if (a4) {
    sub_1000F7B40(kSecAttrService, a4, (uint64_t)v12);
  }
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000LL;
  v15[2] = sub_1001187B4;
  v15[3] = &unk_10028FDF0;
  uint8_t v15[4] = a6;
  v15[5] = v12;
  char v16 = a2;
  v15[6] = a1;
  uint64_t v13 = sub_100110ECC(0, 1, 0LL, (uint64_t)a6, (uint64_t)v15);
  sub_1000F8150(v12, 0LL);
  return v13;
}

BOOL sub_1001187B4(uint64_t a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_100118820;
  v4[3] = &unk_10028FDD0;
  uint64_t v2 = *(CFTypeRef **)(a1 + 32);
  void v4[4] = *(void *)(a1 + 40);
  void v4[5] = a2;
  char v5 = *(_BYTE *)(a1 + 56);
  void v4[6] = *(void *)(a1 + 48);
  return sub_100105354(a2, 2LL, v2, (uint64_t)v4);
}

uint64_t sub_100118820(uint64_t a1)
{
  CFTypeRef v9 = 0LL;
  uint64_t v2 = *(CFDictionaryRef **)(a1 + 32);
  uint64_t v1 = *(void *)(a1 + 40);
  v7.isa = _NSConcreteStackBlock;
  *(void *)&v7.flags = 0x40000000LL;
  v7.invoke = (void (*)(void *, ...))sub_1001188D0;
  v7.descriptor = (Block_descriptor_1 *)&unk_10028FD90;
  uint64_t v8 = v2;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000LL;
  v5[2] = sub_1001188F8;
  void v5[3] = &unk_10028FDB0;
  char v6 = *(_BYTE *)(a1 + 56);
  void v5[4] = *(void *)(a1 + 48);
  sub_1000EA68C(v2, v1, &v9, 0LL, &v7, 0LL, 0LL, (uint64_t)v5);
  CFTypeRef v3 = v9;
  if (v9)
  {
    CFTypeRef v9 = 0LL;
    CFRelease(v3);
  }

  return 1LL;
}

BOOL sub_1001188D0(uint64_t a1, const void **a2)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 32) + 8LL), *a2) != 0LL;
}

void sub_1001188F8(uint64_t a1, uint64_t a2)
{
  CFTypeRef cf = 0LL;
  uint64_t v4 = (os_log_s *)sub_10001267C("InitialSyncItems");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Copy item", buf, 2u);
  }

  char v5 = sub_1000E6EA4((void *)a2, 0x10000LL, 0LL, (__CFString **)&cf);
  if (v5)
  {
    char v6 = v5;
    signed int Value = CFDictionaryGetValue(v5, kSecAttrSyncViewHint);
    if (Value && (uint64_t v8 = Value, v9 = CFGetTypeID(Value), v9 == CFStringGetTypeID())) {
      int v10 = SOSViewInSOSSystem(v8);
    }
    else {
      int v10 = 1;
    }
    if (*(_BYTE *)(a1 + 40))
    {
      int valuePtr = -1431655766;
      int v11 = (const __CFNumber *)CFDictionaryGetValue(v6, kSecAttrType);
      if (v11)
      {
        char v12 = v11;
        CFTypeID v13 = CFGetTypeID(v11);
        if (v13 == CFNumberGetTypeID())
        {
          if (!CFNumberGetValue(v12, kCFNumberSInt32Type, &valuePtr))
          {
LABEL_15:
            CFRelease(v6);
            goto LABEL_16;
          }

          int v10 = (BYTE2(valuePtr) & v10);
        }
      }
    }

    if (v10)
    {
      CFDictionaryAddValue(v6, kSecClass, **(const void ***)(a2 + 16));
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v6);
    }

    goto LABEL_15;
  }

BOOL sub_100118A84(uint64_t a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000LL;
  v4[2] = sub_100118AE0;
  v4[3] = &unk_10028F800;
  uint64_t v2 = *(CFTypeRef **)(a1 + 32);
  void v4[4] = *(void *)(a1 + 40);
  void v4[5] = a2;
  return sub_100105354(a2, 2LL, v2, (uint64_t)v4);
}

uint64_t sub_100118AE0(uint64_t a1)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
  CFTypeRef v3 = (os_log_s *)sub_10001267C("ImportInitialSyncItems");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = Count;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Importing %d items", buf, 8u);
  }

  if (Count >= 1)
  {
    for (CFIndex i = 0LL; Count != i; ++i)
    {
      CFTypeRef cf = 0LL;
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 32), i);
      if (!ValueAtIndex) {
        continue;
      }
      char v6 = ValueAtIndex;
      CFTypeID v7 = CFGetTypeID(ValueAtIndex);
      if (v7 != CFDictionaryGetTypeID()) {
        continue;
      }
      signed int Value = CFDictionaryGetValue(v6, kSecClass);
      if (Value)
      {
        CFTypeID v9 = Value;
        int v10 = sub_1000F77E0(Value);
        if (v10)
        {
          int v11 = (void **)sub_1000E8E18((uint64_t)v10, v6, 0, (__CFString **)&cf);
          if (v11)
          {
            uint64_t v12 = (uint64_t)v11;
            CFTypeID v13 = (void *)sub_1000E6D50(v11[2], 11LL, (__CFString **)&cf);
            if ((sub_1000E7958(v12, v13, kCFBooleanTrue, (__CFString **)&cf) & 1) != 0)
            {
              uint64_t v14 = *(void *)(a1 + 40);
              *(void *)__int128 buf = _NSConcreteStackBlock;
              *(void *)&uint8_t buf[8] = 0x40000000LL;
              *(void *)&buf[16] = sub_1000EBBC4;
              __int16 v30 = &unk_100285F88;
              uint64_t v31 = v12;
              __int16 v32 = 0;
              if ((sub_1000EA178(v12, v14, (__CFString **)&cf, (uint64_t)buf) & 1) == 0)
              {
                uint64_t v15 = (os_log_s *)sub_10001267C("ImportInitialSyncItems");
                if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)__int128 buf = 138412547;
                  *(void *)&uint8_t buf[4] = cf;
                  *(_WORD *)&_BYTE buf[12] = 2113;
                  *(void *)&buf[14] = v12;
                  char v16 = v15;
                  uint32_t v17 = "Item store failed with: %@: %{private}@";
                  goto LABEL_31;
                }

                goto LABEL_24;
              }
            }

            else
            {
              CFTypeRef v25 = (os_log_s *)sub_10001267C("ImportInitialSyncItems");
              if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)__int128 buf = 138412547;
                *(void *)&uint8_t buf[4] = cf;
                *(_WORD *)&_BYTE buf[12] = 2113;
                *(void *)&buf[14] = v12;
                char v16 = v25;
                uint32_t v17 = "Failed to set sync=1: %@ for item %{private}@";
LABEL_31:
                _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, v17, buf, 0x16u);
              }

uint64_t sub_100118E98(void *a1, uint64_t a2, __CFString **a3)
{
  keys[0] = (void *)kSecClass;
  keys[1] = (void *)kSecReturnData;
  keys[2] = (void *)kSecMatchLimit;
  keys[3] = (void *)kSecAttrSubject;
  keys[4] = (void *)kSecAttrSynchronizable;
  values[0] = (void *)kSecClassCertificate;
  values[1] = kCFBooleanTrue;
  values[2] = (void *)kSecMatchLimitAll;
  values[3] = a1;
  values[4] = (void *)kSecAttrSynchronizableAny;
  char v5 = CFDictionaryCreate( 0LL,  (const void **)keys,  (const void **)values,  5LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  uint64_t v11 = 0LL;
  v7[0] = 0LL;
  __int128 v8 = 0u;
  uint64_t v10 = 0LL;
  __int128 v9 = 0u;
  v7[1] = a2;
  LOBYTE(v_Block_object_dispose(va, 8) = 1;
  sub_100112A08(v5, (uint64_t)v7, &v11, a3);
  CFRelease(v5);
  return v11;
}

BOOL sub_100118FDC(void *a1, void *a2, uint64_t a3, __CFString **a4)
{
  keys[0] = (void *)kSecClass;
  keys[1] = (void *)kSecMatchLimit;
  keys[2] = (void *)kSecAttrIssuer;
  keys[3] = (void *)kSecAttrSerialNumber;
  keys[4] = (void *)kSecAttrSynchronizable;
  values[0] = (void *)kSecClassCertificate;
  values[1] = (void *)kSecMatchLimitOne;
  values[2] = a1;
  values[3] = a2;
  values[4] = (void *)kSecAttrSynchronizableAny;
  v9[0] = 0LL;
  __int128 v10 = 0u;
  uint64_t v12 = 0LL;
  __int128 v11 = 0u;
  v9[1] = a3;
  LOBYTE(v10) = 1;
  char v5 = CFDictionaryCreate( 0LL,  (const void **)keys,  (const void **)values,  5LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  CFTypeRef cf = 0LL;
  BOOL v6 = sub_100112A08(v5, (uint64_t)v9, (uint64_t *)&cf, a4);
  if (v5) {
    CFRelease(v5);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

void sub_100119918( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
}

void sub_100119BC0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_100119D18(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  __int128 v8 = WeakRetained;
  if (!v6)
  {
    CFTypeID v13 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained deps]);
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v13 ckks]);
    [v14 receiveTLKUploadRecords:v5];

    uint64_t v12 = objc_claimAutoreleasedReturnValue([v8 intendedState]);
LABEL_7:
    uint64_t v15 = (void *)v12;
    [v8 setNextState:v12];

    goto LABEL_15;
  }

  if ([v6 isCuttlefishError:1033])
  {
    __int128 v9 = sub_10001267C("octagon-ckks");
    __int128 v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      __int128 v11 = (void *)objc_claimAutoreleasedReturnValue([v8 ckksConflictState]);
      int v21 = 138412290;
      id v22 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "A CKKS key hierarchy is out of date; moving to '%@'",
        (uint8_t *)&v21,
        0xCu);
    }

    uint64_t v12 = objc_claimAutoreleasedReturnValue([v8 ckksConflictState]);
    goto LABEL_7;
  }

  if ([v6 isCuttlefishError:1037])
  {
    char v16 = sub_10001267C("octagon-ckks");
    uint32_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v21) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Cuttlefish reports we no longer exist.",  (uint8_t *)&v21,  2u);
    }

    CFArrayRef v18 = (os_log_s *)objc_claimAutoreleasedReturnValue([v8 peerMissingState]);
    [v8 setNextState:v18];
  }

  else
  {
    CFTypeRef v19 = sub_10001267C("SecError");
    CFArrayRef v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = 138412290;
      id v22 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "octagon: Error calling tlk upload: %@",  (uint8_t *)&v21,  0xCu);
    }
  }

  [v8 setError:v6];
LABEL_15:
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v8 finishedOp]);
  [v8 runBeforeGroupFinished:v20];
}

void sub_100119F84(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = sub_10001267C("octagon");
  CFTypeRef v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = objc_claimAutoreleasedReturnValue([WeakRetained error]);
    id v5 = (void *)v4;
    id v6 = @"no error";
    if (v4) {
      id v6 = (const __CFString *)v4;
    }
    int v7 = 138412290;
    __int128 v8 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Finishing an update TLKs operation with %@",  (uint8_t *)&v7,  0xCu);
  }
}

void sub_10011A064(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewKeySets]);
  CFTypeRef v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) pendingTLKShares]);
  [WeakRetained proceedWithKeys:v2 pendingTLKShares:v3];
}

void sub_10011AB34(_Unwind_Exception *a1)
{
}

void sub_10011ABF8(_Unwind_Exception *a1)
{
}

void sub_10011AF04(_Unwind_Exception *a1)
{
}

void sub_10011B594(id a1)
{
  uint64_t v1 = objc_alloc_init(&OBJC_CLASS___SecMetrics);
  uint64_t v2 = (void *)qword_1002DEBE8;
  qword_1002DEBE8 = (uint64_t)v1;
}

void sub_10011B5BC(uint64_t a1)
{
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v2 = *(void *)(a1 + 32);
    int v3 = 138412290;
    uint64_t v4 = v2;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "metrics URL is: %@",  (uint8_t *)&v3,  0xCu);
  }

void sub_10011B894(_Unwind_Exception *a1)
{
}

void sub_10011BA18(_Unwind_Exception *a1)
{
}

void sub_10011BF80(_Unwind_Exception *a1)
{
}

void sub_10011BF9C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  __int128 v7 = 0u;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "dependencies", 0));
  id v3 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v8;
    do
    {
      id v6 = 0LL;
      do
      {
        if (*(void *)v8 != v5) {
          objc_enumerationMutation(v2);
        }
        [WeakRetained removeDependency:*(void *)(*((void *)&v7 + 1) + 8 * (void)v6)];
        id v6 = (char *)v6 + 1;
      }

      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
    }

    while (v4);
  }
}

BOOL sub_10011C098(id a1, id a2, unint64_t a3, BOOL *a4)
{
  return objc_msgSend(a2, "isFinished", a3, a4) ^ 1;
}

void sub_10011D5F4(id a1)
{
}

void sub_10011D63C(id a1, const char *a2)
{
}

void sub_10011D644(id a1, const char *a2)
{
}

void sub_10011D64C(id a1, const char *a2)
{
}

void sub_10011D868(_Unwind_Exception *a1)
{
}

uint64_t sub_10011D9B8(uint64_t a1)
{
  unsigned int v2 = [*(id *)(a1 + 32) isCancelled];
  uint64_t v40 = a1;
  id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 zoneID]);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v4 zoneName]);
  id v6 = sub_1000AA6AC(@"ckkscurrent", v5);
  __int128 v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);

  log = (NSMutableArray *)v7;
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v8)
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "CKKSDeleteCurrentItemPointersOperation cancelled, quitting",  buf,  2u);
    }

    uint64_t v9 = 0LL;
  }

  else
  {
    if (v8)
    {
      __int128 v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v40 + 32) identifiers]);
      *(_DWORD *)__int128 buf = 134217984;
      id v52 = [v10 count];
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Deleting current item pointers (%lu)",  buf,  0xCu);
    }

    log = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    __int128 v49 = 0u;
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v46 = 0u;
    id obj = (id)objc_claimAutoreleasedReturnValue([*(id *)(v40 + 32) identifiers]);
    id v11 = [obj countByEnumeratingWithState:&v46 objects:v50 count:16];
    if (v11)
    {
      uint64_t v12 = *(void *)v47;
      do
      {
        for (CFIndex i = 0LL; i != v11; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v47 != v12) {
            objc_enumerationMutation(obj);
          }
          uint64_t v14 = *(void *)(*((void *)&v46 + 1) + 8LL * (void)i);
          uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v40 + 32) accessGroup]);
          char v16 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@-%@",  v15,  v14));

          uint32_t v17 = objc_alloc(&OBJC_CLASS___CKRecordID);
          CFArrayRef v18 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v40 + 32) viewState]);
          CFTypeRef v19 = (void *)objc_claimAutoreleasedReturnValue([v18 zoneID]);
          uint64_t v20 = -[CKRecordID initWithRecordName:zoneID:](v17, "initWithRecordName:zoneID:", v16, v19);

          -[NSMutableArray addObject:](log, "addObject:", v20);
        }

        id v11 = [obj countByEnumeratingWithState:&v46 objects:v50 count:16];
      }

      while (v11);
    }

    int v21 = objc_alloc_init(&OBJC_CLASS___NSBlockOperation);
    -[NSBlockOperation setName:](v21, "setName:", @"deleteCurrentItemPointers-modifyRecordsComplete");
    [*(id *)(v40 + 32) dependOnBeforeGroupFinished:v21];
    id v22 = -[CKModifyRecordsOperation initWithRecordsToSave:recordIDsToDelete:]( objc_alloc(&OBJC_CLASS___CKModifyRecordsOperation),  "initWithRecordsToSave:recordIDsToDelete:",  0LL,  log);
    [*(id *)(v40 + 32) setModifyRecordsOperation:v22];

    int v23 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v40 + 32) modifyRecordsOperation]);
    [v23 setAtomic:1];

    CFTypeRef v24 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v40 + 32) modifyRecordsOperation]);
    CFTypeRef v25 = (void *)objc_claimAutoreleasedReturnValue([v24 configuration]);
    [v25 setIsCloudKitSupportOperation:1];

    CFTypeRef v26 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v40 + 32) modifyRecordsOperation]);
    [v26 setQualityOfService:25];

    char v27 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v40 + 32) ckoperationGroup]);
    int v28 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v40 + 32) modifyRecordsOperation]);
    [v28 setGroup:v27];

    v44[0] = _NSConcreteStackBlock;
    v44[1] = 3221225472LL;
    v44[2] = sub_10011DEF8;
    v44[3] = &unk_10028FF50;
    objc_copyWeak(&v45, (id *)(v40 + 40));
    os_signpost_id_t v29 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v40 + 32) modifyRecordsOperation]);
    [v29 setPerRecordDeleteBlock:v44];

    v41[0] = _NSConcreteStackBlock;
    v41[1] = 3221225472LL;
    v41[2] = sub_10011E084;
    v41[3] = &unk_10028FFA0;
    objc_copyWeak(&v43, (id *)(v40 + 40));
    __int16 v30 = v21;
    uint64_t v42 = v30;
    uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v40 + 32) modifyRecordsOperation]);
    [v31 setModifyRecordsCompletionBlock:v41];

    __int16 v32 = *(void **)(v40 + 32);
    BOOL v33 = (void *)objc_claimAutoreleasedReturnValue([v32 modifyRecordsOperation]);
    [v32 dependOnBeforeGroupFinished:v33];

    int v34 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v40 + 32) deps]);
    BOOL v35 = (void *)objc_claimAutoreleasedReturnValue([v34 ckdatabase]);
    int v36 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v40 + 32) modifyRecordsOperation]);
    [v35 addOperation:v36];

    objc_destroyWeak(&v43);
    objc_destroyWeak(&v45);

    uint64_t v9 = 1LL;
  }

  return v9;
}

void sub_10011DEC8(_Unwind_Exception *a1)
{
}

void sub_10011DEF8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  BOOL v8 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained viewState]);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 zoneID]);
  __int128 v10 = (void *)objc_claimAutoreleasedReturnValue([v9 zoneName]);
  id v11 = sub_1000AA6AC(@"ckkscurrent", v10);
  uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);

  if (v6)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      int v14 = 138412546;
      id v15 = v6;
      __int16 v16 = 2112;
      id v17 = v5;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "error on row: %@ %@", (uint8_t *)&v14, 0x16u);
    }
  }

  else if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    CFTypeID v13 = (void *)objc_claimAutoreleasedReturnValue([v5 recordName]);
    int v14 = 138412290;
    id v15 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Current pointer delete successful for %@",  (uint8_t *)&v14,  0xCu);
  }
}

void sub_10011E084(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v11 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained deps]);
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 databaseProvider]);

  if (v9)
  {
    CFTypeID v13 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained viewState]);
    int v14 = (void *)objc_claimAutoreleasedReturnValue([v13 zoneID]);
    id v15 = (void *)objc_claimAutoreleasedReturnValue([v14 zoneName]);
    id v16 = sub_1000AA6AC(@"ckkscurrent", v15);
    id v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);

    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "CloudKit returned an error: %@",  (uint8_t *)&buf,  0xCu);
    }

    [WeakRetained setError:v9];
    CFArrayRef v18 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationQueue]);
    [v18 addOperation:*(void *)(a1 + 32)];
  }

  else
  {
    *(void *)&__int128 buf = 0LL;
    *((void *)&buf + 1) = &buf;
    uint64_t v25 = 0x3032000000LL;
    CFTypeRef v26 = sub_10011E2EC;
    char v27 = sub_10011E2FC;
    id v28 = 0LL;
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472LL;
    v20[2] = sub_10011E304;
    v20[3] = &unk_10028FF78;
    id v21 = v8;
    id v22 = WeakRetained;
    p___int128 buf = &buf;
    [v12 dispatchSyncWithSQLTransaction:v20];
    [WeakRetained setError:*(void *)(*((void *)&buf + 1) + 40)];
    CFTypeRef v19 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationQueue]);
    [v19 addOperation:*(void *)(a1 + 32)];

    _Block_object_dispose(&buf, 8);
  }
}

void sub_10011E2CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_10011E2EC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10011E2FC(uint64_t a1)
{
}

uint64_t sub_10011E304(uint64_t a1)
{
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v25 objects:v33 count:16];
  if (v3)
  {
    id v5 = v3;
    uint64_t v6 = *(void *)v26;
    *(void *)&__int128 v4 = 138412546LL;
    __int128 v23 = v4;
    do
    {
      id v7 = 0LL;
      do
      {
        if (*(void *)v26 != v6) {
          objc_enumerationMutation(v2);
        }
        id v8 = *(void **)(*((void *)&v25 + 1) + 8LL * (void)v7);
        id v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "deps", v23));
        __int128 v10 = (void *)objc_claimAutoreleasedReturnValue([v9 contextID]);
        uint64_t v11 = *(void *)(*(void *)(a1 + 48) + 8LL);
        id obj = *(id *)(v11 + 40);
        unsigned __int8 v12 = +[CKKSCurrentItemPointer intransactionRecordDeleted:contextID:resync:error:]( &OBJC_CLASS___CKKSCurrentItemPointer,  "intransactionRecordDeleted:contextID:resync:error:",  v8,  v10,  0LL,  &obj);
        objc_storeStrong((id *)(v11 + 40), obj);

        if ((v12 & 1) == 0)
        {
          CFTypeID v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) viewState]);
          int v14 = (void *)objc_claimAutoreleasedReturnValue([v13 zoneID]);
          id v15 = (void *)objc_claimAutoreleasedReturnValue([v14 zoneName]);
          id v16 = sub_1000AA6AC(@"ckkscurrent", v15);
          id v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);

          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            CFArrayRef v18 = (void *)objc_claimAutoreleasedReturnValue([v8 recordName]);
            uint64_t v19 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
            *(_DWORD *)__int128 buf = v23;
            __int16 v30 = v18;
            __int16 v31 = 2112;
            uint64_t v32 = v19;
            _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "Couldn't delete current item pointer for %@ from database: %@",  buf,  0x16u);
          }

          [*(id *)(a1 + 40) setError:*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)];
        }

        uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) viewState]);
        id v21 = (void *)objc_claimAutoreleasedReturnValue([v20 notifyViewChangedScheduler]);
        [v21 trigger];

        id v7 = (char *)v7 + 1;
      }

      while (v5 != v7);
      id v5 = [v2 countByEnumeratingWithState:&v25 objects:v33 count:16];
    }

    while (v5);
  }

  return 1LL;
}

uint64_t sub_10011ECE0(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
    return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
  }
  while (2)
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0LL;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1LL || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v9 = v5++ >= 9;
      if (v9)
      {
        unint64_t v6 = 0LL;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0LL;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    switch((v6 >> 3))
    {
      case 1u:
        uint64_t String = PBReaderReadString(a2);
        uint64_t v13 = objc_claimAutoreleasedReturnValue(String);
        uint64_t v14 = 24LL;
        goto LABEL_29;
      case 2u:
        char v16 = 0;
        unsigned int v17 = 0;
        uint64_t v18 = 0LL;
        *(_BYTE *)(a1 + 40) |= 1u;
        while (2)
        {
          unint64_t v19 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v19 == -1LL || v19 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }

          else
          {
            char v20 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v19);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v19 + 1;
            v18 |= (unint64_t)(v20 & 0x7F) << v16;
            if (v20 < 0)
            {
              v16 += 7;
              BOOL v9 = v17++ >= 9;
              if (v9)
              {
                uint64_t v18 = 0LL;
                goto LABEL_36;
              }

              continue;
            }
          }

          break;
        }

        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0LL;
        }
LABEL_36:
        *(void *)(a1 + _Block_object_dispose(va, 8) = v18;
        goto LABEL_37;
      case 3u:
        uint64_t v21 = PBReaderReadString(a2);
        uint64_t v13 = objc_claimAutoreleasedReturnValue(v21);
        uint64_t v14 = 16LL;
LABEL_29:
        id v22 = *(void **)(a1 + v14);
        *(void *)(a1 + v14) = v13;

        goto LABEL_37;
      case 4u:
        __int128 v23 = objc_alloc_init(&OBJC_CLASS___SECC2MPError);
        objc_storeStrong((id *)(a1 + 32), v23);
        v24[0] = 0xAAAAAAAAAAAAAAAALL;
        v24[1] = 0xAAAAAAAAAAAAAAAALL;
        if (PBReaderPlaceMark(a2, v24) && (sub_10011ECE0(v23, a2) & 1) != 0)
        {
          PBReaderRecallMark(a2, v24);

LABEL_37:
          if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
          }
          continue;
        }

        return 0LL;
      default:
        uint64_t result = PBReaderSkipValueWithTag(a2);
        if (!(_DWORD)result) {
          return result;
        }
        goto LABEL_37;
    }
  }

uint64_t sub_10011EFB8( const void *a1, uint64_t a2, const void *a3, unsigned int a4, const UInt8 *a5, _DWORD *a6, __CFData *a7, uint64_t a8, uint64_t a9, __CFString **a10)
{
  unsigned int v17 = (void **)sub_100003144(0LL, 0LL);
  uint64_t v54 = v17;
  CFDataRef theData = 0LL;
  int v53 = 0LL;
  uint64_t v50 = 0LL;
  int v51 = 0LL;
  if (!v17) {
    return sub_1000194E0(-108, a10, @"ks_crypt_diversify: failed to create aks_params");
  }
  uint64_t v18 = v17;
  sub_100003344(v17, 15, a8, a9);
  sub_10000343C(v18, &v51, (size_t *)&v50);
  *(void *)__int128 v48 = 0LL;
  rsize_t __n = 0LL;
  if (CFEqual(a1, @"oe"))
  {
    uint64_t v19 = a2;
    int v20 = a2;
    uint64_t v21 = a3;
    uint64_t v22 = sub_10000349C(v20, (int)a3, 0, (uint64_t)v51, v50, &v53);
    if (!(_DWORD)v22)
    {
      uint64_t v22 = sub_1000043C8((uint64_t)v53, (uint64_t)v51, v50, (uint64_t)a5, a4, v48, &__n);
      if (!(_DWORD)v22)
      {
        CFTypeRef cf = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
        __int128 v23 = (const UInt8 *)sub_1000046C8((uint64_t *)v53, &cf);
        CFTypeRef v24 = a10;
        if (v23)
        {
          if (!sub_10011F44C(*(UInt8 **)v48, __n, v23, (CFIndex)cf, a7))
          {
            if (v51) {
              free(v51);
            }
            sub_100003440(&v54);
            id v43 = a3;
            uint64_t v44 = v19;
            uint64_t v42 = (uint64_t)"encrypt";
            uint64_t v38 = @"ks_crypt_diversify: failed to '%s' item (class %d, bag: %d) Item can't be encrypted due to merge failed, so drop the item.";
            goto LABEL_54;
          }

          *a6 = (_DWORD)a3;
        }

        goto LABEL_17;
      }
    }

    uint64_t v37 = v22;
    CFTypeRef v24 = a10;
  }

  else
  {
    uint64_t v19 = a2;
    if (CFEqual(a1, @"od") || CFEqual(a1, @"odel"))
    {
      CFIndex v26 = a4;
      CFTypeRef v24 = a10;
      if ((sub_10011F598(a2, a5, v26, (uint64_t *)&v53, (CFTypeRef *)&theData, a10) & 1) == 0)
      {
        if (v51) {
          free(v51);
        }
        sub_100003440(&v54);
        uint64_t v42 = a2;
        uint64_t v38 = @"ks_crypt_diversify: failed to create ref key with blob because bad data (bag: %d)";
        goto LABEL_54;
      }

      uint64_t v21 = a3;
      __int128 v27 = v53;
      uint64_t v29 = v50;
      __int128 v28 = v51;
      BytePtr = CFDataGetBytePtr(theData);
      CFIndex Length = CFDataGetLength(theData);
      uint64_t v32 = sub_100004548((uint64_t)v27, (uint64_t)v28, v29, (uint64_t)BytePtr, Length, v48, &__n);
      if (!(_DWORD)v32)
      {
        CFTypeRef cf = 0LL;
        sub_100019634(0LL, (CFBooleanRef *)&cf, (CFTypeRef *)a10, *(const UInt8 **)v48, *(void *)v48 + __n);
        BOOL v33 = (const __CFData *)cf;
        CFTypeID v34 = CFGetTypeID(cf);
        if (v34 == CFDataGetTypeID())
        {
          CFDataSetLength(a7, 0LL);
          BOOL v35 = CFDataGetBytePtr(v33);
          CFIndex v36 = CFDataGetLength(v33);
          CFDataAppendBytes(a7, v35, v36);
        }

        if (v33) {
          CFRelease(v33);
        }
LABEL_17:
        uint64_t v37 = 0LL;
        goto LABEL_18;
      }

      uint64_t v37 = v32;
    }

    else
    {
      uint64_t v37 = 3758097090LL;
      CFTypeRef v24 = a10;
      uint64_t v21 = a3;
    }
  }

BOOL sub_10011F44C(UInt8 *bytes, CFIndex length, const UInt8 *a3, CFIndex a4, __CFData *a5)
{
  CFDataRef v8 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, bytes, length, kCFAllocatorNull);
  CFDataRef v9 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, a3, a4, kCFAllocatorNull);
  CFDataRef v17 = v9;
  if (v8) {
    BOOL v18 = v9 == 0LL;
  }
  else {
    BOOL v18 = 1;
  }
  if (!v18)
  {
    uint64_t v22 = (const __CFString *)sub_100107FA8( kCFAllocatorDefault,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  (uint64_t)@"d1",  (uint64_t)v8);
    CFDataSetLength(a5, 0LL);
    CFIndex v26 = sub_100019F48(v22, 0LL, v23, v24, v25);
    BOOL v19 = (BOOL)v26;
    if (v26)
    {
      BytePtr = CFDataGetBytePtr(v26);
      CFIndex v28 = CFDataGetLength((CFDataRef)v19);
      CFDataAppendBytes(a5, BytePtr, v28);
      CFRelease((CFTypeRef)v19);
      BOOL v19 = CFDataGetLength(a5) > 0;
    }

    CFRelease(v22);
LABEL_13:
    CFRelease(v8);
    BOOL v20 = v19;
    if (!v17) {
      return v20;
    }
    goto LABEL_8;
  }

  BOOL v19 = 0LL;
  BOOL v20 = 0LL;
  if (v8) {
    goto LABEL_13;
  }
  if (v9) {
LABEL_8:
  }
    CFRelease(v17);
  return v20;
}

uint64_t sub_10011F598(uint64_t a1, const UInt8 *a2, CFIndex a3, uint64_t *a4, CFTypeRef *a5, __CFString **a6)
{
  CFTypeRef v26 = 0LL;
  CFTypeRef cf = 0LL;
  uint64_t v25 = 0LL;
  int v11 = &a2[a3];
  int v12 = sub_100019634(0LL, (CFBooleanRef *)&cf, 0LL, a2, (uint64_t)&a2[a3]);
  if (!v12 || v12 != v11)
  {
    sub_1000194E0(-26275, a6, @"encrypted_data_from_blob: NULL 'blob data'");
    CFDataRef v15 = 0LL;
    uint64_t v16 = 0LL;
    CFTypeRef v13 = cf;
    if (!cf) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }

  CFTypeRef v13 = cf;
  CFTypeID v14 = CFGetTypeID(cf);
  if (v14 != CFDictionaryGetTypeID())
  {
    CFTypeID v18 = CFGetTypeID(v13);
    CFStringRef v19 = CFCopyTypeIDDescription(v18);
    BOOL v20 = (__CFString *)CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"encrypted_data_from_blob: Bad object type %@ for 'blob data'",  v19);
    sub_1000194E0(-26276, a6, @"%@", v20);
    sub_10001BB24(v20, 0x53C00002u);
    if (v19) {
      CFRelease(v19);
    }
    if (v20) {
      CFRelease(v20);
    }
    CFDataRef v15 = 0LL;
LABEL_18:
    uint64_t v16 = 0LL;
    if (!v13) {
      goto LABEL_8;
    }
LABEL_7:
    CFRelease(v13);
    goto LABEL_8;
  }

  if ((sub_10011F7C4((const __CFDictionary *)v13, (CFTypeRef *)&v25, &v26) & 1) != 0)
  {
    CFDataRef v15 = v25;
  }

  else
  {
    CFDataRef v15 = CFDataCreate(kCFAllocatorDefault, v11, a3);
    CFTypeRef v26 = CFRetain(v15);
  }

  if (!v15)
  {
    sub_1000194E0(-26275, a6, @"encrypted_data_from_blob: failed to decode 'encrypted data'");
    goto LABEL_18;
  }

  uint64_t v21 = (const __CFData *)v26;
  if (!v26)
  {
    sub_1000194E0(-26275, a6, @"encrypted_data_from_blob: failed to decode 'key data'");
    goto LABEL_18;
  }

  BytePtr = CFDataGetBytePtr((CFDataRef)v26);
  size_t Length = CFDataGetLength(v21);
  uint64_t v24 = sub_1000038F8(a1, BytePtr, Length, a4);
  if ((_DWORD)v24)
  {
    sub_1000194E0(-26275, a6, @"aks_ref_key: failed to create ref key with blob: %x (bag: %d)", v24, a1);
    goto LABEL_18;
  }

  if (a5) {
    *a5 = CFRetain(v15);
  }
  uint64_t v16 = 1LL;
  if (v13) {
    goto LABEL_7;
  }
LABEL_8:
  if (v26) {
    CFRelease(v26);
  }
  if (v15) {
    CFRelease(v15);
  }
  return v16;
}

uint64_t sub_10011F7C4(const __CFDictionary *a1, CFTypeRef *a2, CFTypeRef *a3)
{
  signed int Value = CFDictionaryGetValue(a1, @"d1");
  unint64_t v7 = CFDictionaryGetValue(a1, @"d2");
  if (Value) {
    BOOL v8 = v7 == 0LL;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8) {
    return 0LL;
  }
  CFDataRef v9 = v7;
  CFTypeID TypeID = CFDataGetTypeID();
  if (TypeID != CFGetTypeID(Value)) {
    return 0LL;
  }
  CFTypeID v11 = CFDataGetTypeID();
  if (v11 != CFGetTypeID(v9)) {
    return 0LL;
  }
  *a2 = CFRetain(Value);
  *a3 = CFRetain(v9);
  return 1LL;
}

BOOL sub_10011F87C( const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, const void *a6, _DWORD *a7, CFDataRef theData, char a9, __CFString **a10)
{
  int v18 = CFDataGetLength(theData);
  length[0] = v18;
  if (CFEqual(a1, @"oe"))
  {
    MutableBytePtr = CFDataGetMutableBytePtr(theData);
    if (a9)
    {
      size_t v34 = v18;
      uint64_t v20 = sub_100005AA8(a2, a6, a5, MutableBytePtr, &v34);
      if ((_DWORD)v20)
      {
        uint64_t v21 = (os_log_s *)sub_10001267C("SecError");
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          length[1] = 67109120;
          length[2] = v20;
          _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "ks_crypt: aks_kc_backup_wrap_key returned %d",  (uint8_t *)&length[1],  8u);
        }
      }

      else
      {
        length[0] = v34;
        if (a7) {
          *a7 = a4;
        }
      }

      goto LABEL_20;
    }

    uint64_t v24 = sub_1000054DC(a6, a5, a4, a2, MutableBytePtr, length, a7);
LABEL_19:
    uint64_t v20 = v24;
    goto LABEL_20;
  }

  if (!CFEqual(a1, @"od"))
  {
    if (!CFEqual(a1, @"odel"))
    {
      uint64_t v20 = 3758097090LL;
      goto LABEL_37;
    }

    uint64_t v25 = CFDataGetMutableBytePtr(theData);
    CFTypeRef v26 = a6;
    int v27 = a5;
    int v28 = a4;
    int v29 = a2;
    goto LABEL_18;
  }

  uint64_t v22 = CFDataGetMutableBytePtr(theData);
  if (!a3)
  {
    CFTypeRef v26 = a6;
    int v27 = a5;
    int v28 = a4;
    int v29 = a2;
    uint64_t v25 = v22;
LABEL_18:
    uint64_t v24 = sub_100005644(v26, v27, v28, v29, v25, length);
    goto LABEL_19;
  }

  size_t v34 = v18;
  uint64_t v23 = (os_log_s *)sub_10001267C("ks_crypt");
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(length[1]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "have a backup_keypair, attempting to use",  (uint8_t *)&length[1],  2u);
  }

  uint64_t v20 = sub_100005990(a3, a6, a5, v22, &v34);
  if (!(_DWORD)v20) {
    length[0] = v34;
  }
LABEL_20:
  if ((int)v20 > -536870161)
  {
    switch((_DWORD)v20)
    {
      case 0xE00002F0:
        return sub_1000194E0( -25291,  a10,  @"ks_crypt: %x failed to '%@' item (class %d, bag: %d) No key available for class.",  3758097136LL,  a1,  a4,  a2);
      case 0xE007C013:
        return sub_1000194E0( -26275,  a10,  @"ks_crypt: %x failed to '%@' item (class %d, bag: %d) Item can't be decrypted on this device, ever, so drop the item.",  v20,  a1,  a4,  a2);
      case 0:
        CFDataSetLength(theData, length[0]);
        return 1LL;
    }

    goto LABEL_37;
  }

  if ((_DWORD)v20 == -536870212) {
    return sub_1000194E0( -26275,  a10,  @"ks_crypt: %x failed to '%@' item (class %d, bag: %d) Item can't be decrypted on this device, ever, so drop the item.",  v20,  a1,  a4,  a2);
  }
  if ((_DWORD)v20 != -536870207 && (_DWORD)v20 != -536870174)
  {
LABEL_37:
    if (!CFEqual(a1, @"od") && !CFEqual(a1, @"odel")) {
      return sub_1000194E0(-25291, a10, @"ks_crypt: %x failed to '%@' item (class %d, bag: %d)", v20, a1, a4, a2);
    }
    size_t v34 = 0LL;
    *(void *)&length[1] = 0LL;
    int v33 = sub_10011F598(a2, (const UInt8 *)a6, a5, (uint64_t *)&v34, (CFTypeRef *)&length[1], a10);
    if (*(void *)&length[1]) {
      CFRelease(*(CFTypeRef *)&length[1]);
    }
    sub_100003848((uint64_t *)&v34);
    if (!v33) {
      return sub_1000194E0(-25291, a10, @"ks_crypt: %x failed to '%@' item (class %d, bag: %d)", v20, a1, a4, a2);
    }
    return sub_1000194E0( -26275,  a10,  @"ks_crypt: %x failed to '%@' item (class %d, bag: %d) Item can't be decrypted on this device, ever, so drop the item.",  v20,  a1,  a4,  a2);
  }

  BOOL v30 = (_DWORD)a4 == 10 || (_DWORD)a4 == 7;
  __int16 v31 = "";
  if (v30) {
    __int16 v31 = " (hibernation?)";
  }
  return sub_1000194E0( -25308,  a10,  @"ks_crypt: %x failed to '%@' item (class %d, bag: %d) Access to item attempted while keychain is locked%s.",  v20,  a1,  a4,  a2,  v31);
}

void sub_10011FC80(CFErrorRef *a1, uint64_t a2)
{
  if (a1)
  {
    char v4 = *a1;
    if (!v4) {
      goto LABEL_10;
    }
    if (CFErrorGetCode(v4) != -25330) {
      return;
    }
    if (*a1)
    {
      unsigned int v5 = CFErrorCopyUserInfo(*a1);
      MutableCFArrayRef Copy = CFDictionaryCreateMutableCopy(0LL, 0LL, v5);
      CFRelease(v5);
      CFErrorRef v7 = *a1;
      if (*a1)
      {
        *a1 = 0LL;
        CFRelease(v7);
      }

      if (a2) {
        goto LABEL_8;
      }
    }

    else
    {
LABEL_10:
      MutableCFArrayRef Copy = CFDictionaryCreateMutable( 0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      if (a2)
      {
LABEL_8:
        uint64_t valuePtr = -25330LL;
        CFNumberRef v8 = CFNumberCreate(0LL, kCFNumberCFIndexType, &valuePtr);
        signed int Value = (const __CFArray *)CFDictionaryGetValue(MutableCopy, v8);
        if (Value) {
          CFMutableArrayRef Mutable = CFArrayCreateMutableCopy(0LL, 0LL, Value);
        }
        else {
          CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, 0LL, &kCFTypeArrayCallBacks);
        }
        uint64_t v20 = Mutable;
        CFArrayRef v21 = sub_10011FE1C((uint64_t)Mutable, v11, v12, v13, v14, v15, v16, v17, a2);
        CFArrayAppendValue(v20, v21);
        CFRelease(v21);
        CFDictionarySetValue(MutableCopy, v8, v20);
        CFRelease(v8);
        CFRelease(v20);
        int v18 = kCFErrorDomainOSStatus;
        CFStringRef v19 = MutableCopy;
        goto LABEL_14;
      }
    }

    int v18 = kCFErrorDomainOSStatus;
    CFStringRef v19 = 0LL;
LABEL_14:
    *a1 = CFErrorCreate(0LL, v18, -25330LL, v19);
    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
  }

CFArrayRef sub_10011FE1C( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v18 = &a9;
  CFIndex v9 = -1LL;
  do
  {
    int v10 = v18++;
    ++v9;
  }

  while (*v10);
  CFStringRef v19 = (const __CFNull **)&a9;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0LL, v9, &kCFTypeArrayCallBacks);
  if (!Mutable) {
    return 0LL;
  }
  for (CFIndex i = Mutable; v9; --v9)
  {
    uint64_t v13 = v19++;
    uint64_t v14 = *v13;
    if (v14) {
      CFNullRef v15 = v14;
    }
    else {
      CFNullRef v15 = kCFNull;
    }
    CFArrayAppendValue(i, v15);
  }

  CFArrayRef Copy = CFArrayCreateCopy(0LL, i);
  CFRelease(i);
  return Copy;
}

void sub_10011FEEC( uint64_t a1, CFTypeRef cf1, uint64_t a3, uint64_t a4, uint64_t a5, const __CFData *a6, __CFString **a7)
{
  if (CFEqual(cf1, @"od"))
  {
    uint64_t v14 = "decrypt";
  }

  else if (CFEqual(cf1, @"oe"))
  {
    uint64_t v14 = "encrypt";
  }

  else
  {
    uint64_t v14 = "";
  }

  int v15 = CFEqual(cf1, @"odel");
  uint64_t v16 = "delete";
  if (!v15) {
    uint64_t v16 = v14;
  }
  if ((int)a1 <= -536870161)
  {
    switch((_DWORD)a1)
    {
      case 0xE00002BC:
LABEL_19:
        sub_1000194E0( -26275,  a7,  @"aks_ref_key: %x failed to '%s' item (class %d, bag: %d) Item can't be decrypted on this device, ever, so drop the item.",  a1,  v16,  a4,  a3);
        return;
      case 0xE00002CE:
        goto LABEL_20;
      case 0xE00002E2:
        sub_1000194E0( -25308,  a7,  @"aks_ref_key: %x failed to '%s' item (class %d, bag: %d) Access to item attempted while keychain is locked.",  3758097122LL,  v16,  a4,  a3);
        return;
    }

uint64_t sub_10012013C( uint64_t a1, const __CFData *a2, __CFData *a3, const __CFData *a4, CFDataRef theData, uint64_t a6, __CFString **a7)
{
  CFIndex Length = theData;
  uint64_t v32 = 0LL;
  int v33 = 0LL;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    CFIndex Length = (const __CFData *)CFDataGetLength(Length);
  }

  else
  {
    BytePtr = 0LL;
  }

  size_t v30 = 0LL;
  uint64_t v31 = 0LL;
  int v15 = (const void *)SecAccessControlCopyData(a6);
  if (a4)
  {
    uint64_t v16 = CFDataGetBytePtr(a4);
    int v17 = CFDataGetLength(a4);
    sub_100003008((uint64_t)BytePtr, (uint64_t)Length, 0LL, 0LL, (uint64_t)v16, v17, &v33, &v31);
    int v18 = v33;
    uint64_t v19 = v31;
    uint64_t v20 = (UInt8 *)CFDataGetBytePtr(a2);
    size_t v21 = CFDataGetLength(a2);
    uint64_t v22 = sub_1000039BC(a1, (uint64_t)v18, v19, v20, v21, &v32, &v30);
    if ((_DWORD)v22)
    {
      sub_10011FEEC(v22, @"od", 0LL, 0LL, (uint64_t)v15, a4, a7);
    }

    else if (v32)
    {
      CFTypeRef cf = 0LL;
      sub_100019634(kCFAllocatorDefault, (CFBooleanRef *)&cf, 0LL, (const UInt8 *)v32, (uint64_t)v32 + v30);
      uint64_t v23 = (const __CFData *)cf;
      if (cf)
      {
        CFTypeID v24 = CFGetTypeID(cf);
        if (v24 == CFDataGetTypeID())
        {
          CFDataSetLength(a3, 0LL);
          uint64_t v25 = CFDataGetBytePtr(v23);
          CFIndex v26 = CFDataGetLength(v23);
          CFDataAppendBytes(a3, v25, v26);
          CFRelease(v23);
          uint64_t v27 = 1LL;
          goto LABEL_13;
        }

        CFRelease(v23);
        sub_1000194E0( -26275,  a7,  @"ks_crypt_acl: %x failed to '%s' item, Item can't be decrypted due to wrong data, so drop the item.",  0LL,  "decrypt");
      }

      else
      {
        sub_1000194E0( -26275,  a7,  @"ks_crypt_acl: %x failed to '%s' item, Item can't be decrypted due to failed decode der, so drop the item.",  0LL,  "decrypt");
      }
    }

    else
    {
      sub_1000194E0( -26275,  a7,  @"ks_crypt_acl: %x failed to '%s' item, Item can't be decrypted due to invalid der data, so drop the item.",  0LL,  "decrypt");
    }
  }

  else
  {
    sub_10011FC80((CFErrorRef *)a7, 0LL);
  }

  uint64_t v27 = 0LL;
LABEL_13:
  if (v33) {
    free(v33);
  }
  if (v32) {
    free(v32);
  }
  if (v15) {
    CFRelease(v15);
  }
  return v27;
}

uint64_t sub_100120398(uint64_t a1, const __CFData *a2, const __CFData *Length, uint64_t a4, CFErrorRef *a5)
{
  size_t v21 = 0LL;
  Constraint = (const __CFBoolean *)SecAccessControlGetConstraint(a4, @"odel");
  else {
    BOOL v11 = 1;
  }
  if (v11)
  {
LABEL_7:
    uint64_t v12 = 0LL;
LABEL_15:
    uint64_t v15 = 1LL;
    goto LABEL_16;
  }

void sub_100120510(id a1)
{
  int v4 = -1;
  if (sub_100005788(0, &v4))
  {
    int v1 = MKBGetDeviceLockState(0LL);
    id v2 = (os_log_s *)sub_10001267C("aks");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 67109120;
      int v6 = v1;
      _os_log_debug_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "AppleKeyStore lock state: %d", buf, 8u);
    }
  }

  byte_1002DEC00 = 1;
  id v3 = (os_log_s *)sub_10001267C("aks");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "using hwaes key", buf, 2u);
  }

BOOL sub_100120628(const __CFData *cf, const __CFData *a2, int *a3, CFTypeRef *a4)
{
  if (cf && (CFTypeID v8 = CFGetTypeID(cf), v8 == CFDataGetTypeID()))
  {
    BytePtr = CFDataGetBytePtr(cf);
    int Length = CFDataGetLength(cf);
    int v11 = sub_1000050A4(BytePtr, Length, a3);
    if (v11)
    {
      return sub_1000190E4(v11, a4, @"aks_load_bag failed: %@", cf);
    }

    else if (a2 {
           && (int v13 = *a3,
    }
               uint64_t v14 = CFDataGetBytePtr(a2),
               int v15 = CFDataGetLength(a2),
               (int v16 = sub_100004FA8(v13, (uint64_t)v14, v15)) != 0))
    {
      int v17 = v16;
      sub_1000051BC(*a3);
      return sub_1000190E4(v17, a4, @"aks_unlock_bag failed");
    }

    else
    {
      return 1LL;
    }
  }

  else
  {
    if (a4) {
      sub_1000194E0(-50, (__CFString **)a4, @"object %@ is not a data", cf);
    }
    return 0LL;
  }

BOOL sub_100120750(int a1, CFTypeRef *a2)
{
  int v3 = sub_1000051BC(a1);
  return !v3 || sub_1000190E4(v3, a2, @"aks_unload_bag failed");
}

CFMutableArrayRef sub_100120790()
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v1 = Mutable;
  if (qword_1002DE708)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000LL;
    block[2] = sub_100011BD8;
    block[3] = &unk_100282EB8;
    block[4] = Mutable;
    if (qword_1002DE728 != -1) {
      dispatch_once(&qword_1002DE728, &stru_100282F38);
    }
    dispatch_sync((dispatch_queue_t)qword_1002DE720, block);
  }

  return v1;
}

BOOL sub_100120848(const __CFString *a1, __CFString **a2)
{
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFStringGetTypeID())
    {
      sub_1000124F8(a1, 3);
      return 1LL;
    }

    CFTypeID v5 = CFGetTypeID(a1);
    if (v5 == CFDictionaryGetTypeID())
    {
      sub_100011EB4((const __CFDictionary *)a1, 3);
      return 1LL;
    }
  }

  return sub_1000194E0(-50, a2, @"Unsupported CFType");
}

id sub_1001208E0(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = sub_1001C41CC(a1, a2);
  CFTypeID v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  int v6 = v5;
  if (v5)
  {
    id v7 = v5;
    CFTypeID v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "circle_transport"));

    if (v8)
    {
      CFIndex v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "circle_transport"));
      id v10 = [v9 kvssendDebugInfo:@"Scope" debug:a1 err:a2];
    }

    else
    {
      id v10 = 0LL;
    }
  }

  else
  {
    id v10 = 0LL;
  }

  return v10;
}

void sub_100120984(id a1, NSError *a2)
{
  id v2 = sub_10001267C("keychainitemupgrade");
  int v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFTypeID v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "kicking off keychain item upgrade", v4, 2u);
  }
}

LABEL_75:
            if (!v105)
            {
LABEL_77:

              goto LABEL_78;
            }

              __int128 v64 = (void *)objc_claimAutoreleasedReturnValue([v46 zoneID]);
              uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue([v64 zoneName]);
              uint64_t v66 = sub_1000AA6AC(@"ckks", v65);
              uint64_t v67 = (os_log_s *)objc_claimAutoreleasedReturnValue(v66);

              if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v106 = 67109376;
                *(_DWORD *)int64_t v107 = 1;
                *(_WORD *)&v107[4] = 1024;
                *(_DWORD *)&v107[6] = 1;
                BOOL v68 = "skipping syncing update of tombstone item (%d, %d)";
                BOOL v69 = v67;
                char v70 = 14;
LABEL_83:
                _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, v68, v106, v70);
              }

  uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  self->_timestampTcpStart));
  [v3 setObject:v42 forKey:@"timestamp_tcp_start"];

  uint64_t v19 = self->_has;
  if ((*(_WORD *)&v19 & 0x8000) == 0)
  {
LABEL_38:
    if ((*(_WORD *)&v19 & 0x4000) == 0) {
      goto LABEL_39;
    }
    goto LABEL_77;
  }

  PBDataWriterWriteUint64Field(v20, self->_timestampTcpStart, 206LL);
  uint64_t v14 = self->_has;
  if ((*(_WORD *)&v14 & 0x8000) == 0)
  {
LABEL_38:
    if ((*(_WORD *)&v14 & 0x4000) == 0) {
      goto LABEL_39;
    }
    goto LABEL_77;
  }

  v4[17] = self->_timestampTcpStart;
  *((_DWORD *)v4 + 70) |= 0x10000u;
  id v7 = self->_has;
  if ((*(_WORD *)&v7 & 0x8000) == 0)
  {
LABEL_38:
    if ((*(_WORD *)&v7 & 0x4000) == 0) {
      goto LABEL_39;
    }
    goto LABEL_77;
  }

LABEL_76:
            goto LABEL_77;
          }

  id v43 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  self->_timestampTcpEnd));
  [v3 setObject:v43 forKey:@"timestamp_tcp_end"];

  uint64_t v19 = self->_has;
  if ((*(_WORD *)&v19 & 0x4000) == 0)
  {
LABEL_39:
    if ((*(_WORD *)&v19 & 0x800) == 0) {
      goto LABEL_40;
    }
    goto LABEL_78;
  }

  PBDataWriterWriteUint64Field(v20, self->_timestampTcpEnd, 207LL);
  uint64_t v14 = self->_has;
  if ((*(_WORD *)&v14 & 0x4000) == 0)
  {
LABEL_39:
    if ((*(_WORD *)&v14 & 0x800) == 0) {
      goto LABEL_40;
    }
    goto LABEL_78;
  }

  uint8_t v4[16] = self->_timestampTcpEnd;
  *((_DWORD *)v4 + 70) |= 0x8000u;
  id v7 = self->_has;
  if ((*(_WORD *)&v7 & 0x4000) == 0)
  {
LABEL_39:
    if ((*(_WORD *)&v7 & 0x800) == 0) {
      goto LABEL_40;
    }
    goto LABEL_78;
  }

  self->_timestampC2Now = v5[7];
  *(_DWORD *)&self->_has |= 0x40u;
  id v10 = *((_DWORD *)v5 + 70);
  if ((v10 & 0x200) == 0)
  {
LABEL_47:
    if ((v10 & 0x100) == 0) {
      goto LABEL_48;
    }
    goto LABEL_78;
  }

uint64_t sub_100126A7C(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0LL;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1LL || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v9 = v5++ >= 9;
      if (v9)
      {
        unint64_t v6 = 0LL;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0LL;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    unint64_t v12 = v6 >> 3;
    if ((int)(v6 >> 3) > 100)
    {
      if ((_DWORD)v12 == 101)
      {
        char v23 = 0;
        unsigned int v24 = 0;
        uint64_t v25 = 0LL;
        *(_BYTE *)(a1 + 36) |= 2u;
        while (1)
        {
          unint64_t v26 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v26 == -1LL || v26 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v27 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v26);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v26 + 1;
          v25 |= (unint64_t)(v27 & 0x7F) << v23;
          if ((v27 & 0x80) == 0) {
            goto LABEL_46;
          }
          v23 += 7;
          BOOL v9 = v24++ >= 9;
          if (v9)
          {
            uint64_t v25 = 0LL;
            goto LABEL_48;
          }
        }

        *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_46:
        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v25 = 0LL;
        }
LABEL_48:
        *(_BYTE *)(a1 + 32) = v25 != 0;
      }

      else
      {
        if ((_DWORD)v12 != 201)
        {
LABEL_39:
          uint64_t result = PBReaderSkipValueWithTag(a2);
          if (!(_DWORD)result) {
            return result;
          }
          continue;
        }

        char v16 = 0;
        unsigned int v17 = 0;
        uint64_t v18 = 0LL;
        *(_BYTE *)(a1 + 36) |= 1u;
        while (1)
        {
          unint64_t v19 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v19 == -1LL || v19 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v20 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v19);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v19 + 1;
          v18 |= (unint64_t)(v20 & 0x7F) << v16;
          if ((v20 & 0x80) == 0) {
            goto LABEL_42;
          }
          v16 += 7;
          BOOL v9 = v17++ >= 9;
          if (v9)
          {
            LODWORD(v1_Block_object_dispose(va, 8) = 0;
            goto LABEL_44;
          }
        }

        *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_42:
        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v1_Block_object_dispose(va, 8) = 0;
        }
LABEL_44:
        *(_DWORD *)(a1 + _Block_object_dispose(va, 8) = v18;
      }
    }

    else
    {
      if ((_DWORD)v12 == 1)
      {
        uint64_t String = PBReaderReadString(a2);
        uint64_t v14 = objc_claimAutoreleasedReturnValue(String);
        uint64_t v15 = 16LL;
      }

      else
      {
        if ((_DWORD)v12 != 2) {
          goto LABEL_39;
        }
        uint64_t v13 = PBReaderReadString(a2);
        uint64_t v14 = objc_claimAutoreleasedReturnValue(v13);
        uint64_t v15 = 24LL;
      }

      uint64_t v22 = *(void **)(a1 + v15);
      *(void *)(a1 + v15) = v14;
    }
  }

  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_100127228( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
}

void sub_1001274F8(_Unwind_Exception *a1)
{
}

void sub_1001277AC(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  int v11 = WeakRetained;
  if (v9)
  {
    unint64_t v12 = sub_10001267C("SecError");
    uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = 138412290;
      id v17 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "octagon: Error preparing voucher: %@",  (uint8_t *)&v16,  0xCu);
    }

    [v11 setError:v9];
  }

  else
  {
    [WeakRetained setVoucher:v7];
    [v11 setVoucherSig:v8];
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v11 intendedState]);
    [v11 setNextState:v14];
  }

  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v11 finishedOp]);
  [v11 runBeforeGroupFinished:v15];
}

void sub_10012790C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) error]);
  BOOL v3 = v2 == 0LL;

  uint64_t v4 = *(void *)(a1 + 40);
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) error]);
  +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:]( &OBJC_CLASS___SecurityAnalyticsReporterRTC,  "sendMetricWithEvent:success:error:",  v4,  v3,  v5);

  unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewKeySets]);
  [WeakRetained proceedWithKeys:v6];
}

uint64_t sub_100127DE8(uint64_t a1)
{
  uint64_t v1 = (id *)(a1 + 32);
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
  BOOL v3 = (void *)objc_claimAutoreleasedReturnValue([*v1 contextID]);
  id v45 = 0LL;
  int v33 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSCurrentItemPointer allInZone:contextID:error:]( &OBJC_CLASS___CKKSCurrentItemPointer,  "allInZone:contextID:error:",  v2,  v3,  &v45));
  id v34 = v45;

  if (v34)
  {
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "zoneID", v33));
    unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue([v4 zoneName]);
    id v6 = sub_1000AA6AC(@"ckksfixup", v5);
    id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);

    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = v34;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "Couldn't fetch current item pointers: %@",  buf,  0xCu);
    }

    uint64_t v8 = 0LL;
  }

  else
  {
    CFIndex v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
    __int128 v43 = 0u;
    __int128 v44 = 0u;
    __int128 v41 = 0u;
    __int128 v42 = 0u;
    id obj = v33;
    id v9 = [obj countByEnumeratingWithState:&v41 objects:v49 count:16];
    if (v9)
    {
      uint64_t v10 = *(void *)v42;
      do
      {
        for (CFIndex i = 0LL; i != v9; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v42 != v10) {
            objc_enumerationMutation(obj);
          }
          unint64_t v12 = *(void **)(*((void *)&v41 + 1) + 8LL * (void)i);
          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "storedCKRecord", v33));
          uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v13 recordID]);

          uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
          int v16 = (void *)objc_claimAutoreleasedReturnValue([v15 zoneName]);
          id v17 = sub_1000AA6AC(@"ckksfixup", v16);
          uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);

          if (v14)
          {
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 138412546;
              *(void *)&uint8_t buf[4] = v14;
              __int16 v47 = 2112;
              __int128 v48 = v12;
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Re-fetching %@ for %@", buf, 0x16u);
            }

            [v36 addObject:v14];
          }

          else
          {
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 138412290;
              *(void *)&uint8_t buf[4] = v12;
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "No record ID for stored %@", buf, 0xCu);
            }
          }
        }

        id v9 = [obj countByEnumeratingWithState:&v41 objects:v49 count:16];
      }

      while (v9);
    }

    if (![v36 count])
    {
      unint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
      char v20 = (void *)objc_claimAutoreleasedReturnValue([v19 zoneName]);
      id v21 = sub_1000AA6AC(@"ckksfixup", v20);
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);

      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "No existing CIPs; fixup complete", buf, 2u);
      }
    }

    *(void *)__int128 buf = 0xAAAAAAAAAAAAAAAALL;
    objc_initWeak((id *)buf, *(id *)(a1 + 40));
    char v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation named:withBlock:]( &OBJC_CLASS___NSBlockOperation,  "named:withBlock:",  @"fetch-records-operation-complete",  &stru_100290068));
    unsigned int v24 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) deps]);
    uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v24 cloudKitClassDependencies]);
    id v26 = objc_msgSend(objc_msgSend(v25, "fetchRecordsOperationClass"), "alloc");
    char v27 = (void *)objc_claimAutoreleasedReturnValue([v36 allObjects]);
    id v28 = [v26 initWithRecordIDs:v27];

    v38[0] = _NSConcreteStackBlock;
    v38[1] = 3221225472LL;
    v38[2] = sub_100128370;
    v38[3] = &unk_100290280;
    objc_copyWeak(&v40, (id *)buf);
    v38[4] = *(void *)(a1 + 32);
    id v29 = v23;
    id v39 = v29;
    [v28 setFetchRecordsCompletionBlock:v38];
    size_t v30 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) deps]);
    uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v30 ckdatabase]);
    [v31 addOperation:v28];

    [*(id *)(a1 + 40) dependOnBeforeGroupFinished:v28];
    [*(id *)(a1 + 40) dependOnBeforeGroupFinished:v29];

    objc_destroyWeak(&v40);
    objc_destroyWeak((id *)buf);
    uint64_t v8 = 1LL;
    id v7 = (os_log_s *)v36;
  }

  return v8;
}

void sub_100128330( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, id location)
{
}

void sub_100128370(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained deps]);
  id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 databaseProvider]);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472LL;
  v14[2] = sub_100128464;
  v14[3] = &unk_100290090;
  uint64_t v10 = *(void *)(a1 + 32);
  int v11 = *(void **)(a1 + 40);
  id v15 = v6;
  uint64_t v16 = v10;
  id v17 = WeakRetained;
  id v18 = v5;
  id v19 = v11;
  id v12 = v5;
  id v13 = v6;
  [v9 dispatchSyncWithSQLTransaction:v14];
}

uint64_t sub_100128464(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 zoneName]);
  id v5 = sub_1000AA6AC(@"ckksfixup", v4);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);

  if (v2)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v7 = *(void **)(a1 + 32);
      *(_DWORD *)__int128 buf = 138412290;
      BOOL v68 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "Finished record fetch with error: %@",  buf,  0xCu);
    }

    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) userInfo]);
    id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue([v8 objectForKeyedSubscript:CKPartialErrorsByItemIDKey]);

    id v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) domain]);
    if (objc_msgSend(v9, "isEqualToString:") && objc_msgSend(*(id *)(a1 + 32), "code") == (id)2)
    {

      if (v6)
      {
        __int128 v64 = 0u;
        __int128 v65 = 0u;
        __int128 v62 = 0u;
        __int128 v63 = 0u;
        id obj = (id)objc_claimAutoreleasedReturnValue(-[os_log_s keyEnumerator](v6, "keyEnumerator"));
        id v10 = [obj countByEnumeratingWithState:&v62 objects:v71 count:16];
        if (!v10) {
          goto LABEL_24;
        }
        id v12 = v10;
        uint64_t v13 = *(void *)v63;
        *(void *)&__int128 v11 = 138412290LL;
        __int128 v54 = v11;
        while (1)
        {
          for (CFIndex i = 0LL; i != v12; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v63 != v13) {
              objc_enumerationMutation(obj);
            }
            id v15 = *(void **)(*((void *)&v62 + 1) + 8LL * (void)i);
            uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", v15, v54));
            id v17 = v16;
            if (v16)
            {
              id v18 = (void *)objc_claimAutoreleasedReturnValue([v16 domain]);
              if ([v18 isEqualToString:CKErrorDomain])
              {
                id v19 = [v17 code];

                if (v19 == (id)11)
                {
                  char v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
                  id v21 = (void *)objc_claimAutoreleasedReturnValue([v20 zoneName]);
                  id v22 = sub_1000AA6AC(@"ckksfixup", v21);
                  char v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);

                  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)__int128 buf = v54;
                    BOOL v68 = v15;
                    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_ERROR,  "CloudKit believes %@ no longer exists",  buf,  0xCu);
                  }

                  unsigned int v24 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) deps]);
                  [v24 intransactionCKRecordDeleted:v15 recordType:@"currentitem" resync:1];

                  goto LABEL_22;
                }
              }

              else
              {
              }
            }

            uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
            id v26 = (void *)objc_claimAutoreleasedReturnValue([v25 zoneName]);
            id v27 = sub_1000AA6AC(@"ckksfixup", v26);
            id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);

            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            {
              id v29 = *(void **)(a1 + 32);
              *(_DWORD *)__int128 buf = 138412546;
              BOOL v68 = v15;
              __int16 v69 = 2112;
              id v70 = v29;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Unknown error for %@: %@", buf, 0x16u);
            }

            [*(id *)(a1 + 48) setError:*(void *)(a1 + 32)];
LABEL_22:
          }

          id v12 = [obj countByEnumeratingWithState:&v62 objects:v71 count:16];
          if (!v12)
          {
LABEL_24:

            goto LABEL_29;
          }
        }
      }
    }

    else
    {
    }

    [*(id *)(a1 + 48) setError:*(void *)(a1 + 32)];
  }

  else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Finished record fetch successfully", buf, 2u);
  }

uint64_t sub_100128F38(uint64_t a1)
{
  id location = (id)0xAAAAAAAAAAAAAAAALL;
  objc_initWeak(&location, *(id *)(a1 + 32));
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSBlockOperation named:withBlock:]( &OBJC_CLASS___NSBlockOperation,  "named:withBlock:",  @"fetch-records-operation-complete",  &stru_1002900B0));
  BOOL v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSPredicate predicateWithValue:](&OBJC_CLASS___NSPredicate, "predicateWithValue:", 1LL));
  uint64_t v4 = -[CKQuery initWithRecordType:predicate:]( objc_alloc(&OBJC_CLASS___CKQuery),  "initWithRecordType:predicate:",  @"tlkshare",  v3);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) deps]);
  id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 cloudKitClassDependencies]);
  id v7 = objc_msgSend(objc_msgSend(objc_msgSend(v6, "queryOperationClass"), "alloc"), "initWithQuery:", v4);

  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
  [v7 setZoneID:v8];

  [v7 setDesiredKeys:0];
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  v20[2] = sub_1001291B8;
  v20[3] = &unk_1002900D8;
  objc_copyWeak(&v21, &location);
  void v20[4] = *(void *)(a1 + 40);
  [v7 setRecordFetchedBlock:v20];
  uint64_t v13 = _NSConcreteStackBlock;
  uint64_t v14 = 3221225472LL;
  id v15 = sub_10012927C;
  uint64_t v16 = &unk_100290128;
  objc_copyWeak(&v19, &location);
  uint64_t v17 = *(void *)(a1 + 40);
  id v9 = v2;
  id v18 = v9;
  [v7 setQueryCompletionBlock:&v13];
  id v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "deps", v13, v14, v15, v16, v17));
  __int128 v11 = (void *)objc_claimAutoreleasedReturnValue([v10 ckdatabase]);
  [v11 addOperation:v7];

  [*(id *)(a1 + 32) dependOnBeforeGroupFinished:v7];
  [*(id *)(a1 + 32) dependOnBeforeGroupFinished:v9];

  objc_destroyWeak(&v19);
  objc_destroyWeak(&v21);

  objc_destroyWeak(&location);
  return 1LL;
}

void sub_100129174( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, id location)
{
}

void sub_1001291B8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v5 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained deps]);
  id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 databaseProvider]);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  v8[2] = sub_10012965C;
  v8[3] = &unk_100290208;
  v8[4] = *(void *)(a1 + 32);
  id v9 = v3;
  id v10 = WeakRetained;
  id v7 = v3;
  [v6 dispatchSyncWithSQLTransaction:v8];
}

void sub_10012927C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained deps]);
  id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 databaseProvider]);
  uint64_t v13 = _NSConcreteStackBlock;
  uint64_t v14 = 3221225472LL;
  id v15 = sub_10012936C;
  uint64_t v16 = &unk_100290100;
  uint64_t v10 = *(void *)(a1 + 32);
  id v17 = v6;
  uint64_t v18 = v10;
  id v19 = WeakRetained;
  id v20 = v5;
  id v11 = v5;
  id v12 = v6;
  [v9 dispatchSyncWithSQLTransaction:&v13];

  objc_msgSend(WeakRetained, "runBeforeGroupFinished:", *(void *)(a1 + 40), v13, v14, v15, v16);
}

uint64_t sub_10012936C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 zoneName]);
  id v5 = sub_1000AA6AC(@"ckksfixup", v4);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);

  if (v2)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v7 = *(void **)(a1 + 32);
      *(_DWORD *)__int128 buf = 138412290;
      unsigned int v24 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "Couldn't fetch all TLKShare records: %@",  buf,  0xCu);
    }

    [*(id *)(a1 + 48) setError:*(void *)(a1 + 32)];
    return 0LL;
  }

  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = *(void **)(a1 + 56);
      *(_DWORD *)__int128 buf = 138412290;
      unsigned int v24 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Successfully fetched TLKShare records (%@)",  buf,  0xCu);
    }

    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) deps]);
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 contextID]);
    id v12 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v12 zoneName]);
    id v22 = 0LL;
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSZoneStateEntry fromDatabase:zoneName:error:]( &OBJC_CLASS___CKKSZoneStateEntry,  "fromDatabase:zoneName:error:",  v11,  v13,  &v22));
    id v15 = v22;

    [v14 setLastFixup:2];
    id v21 = v15;
    [v14 saveToDatabase:&v21];
    id v16 = v21;

    id v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v17 zoneName]);
    id v19 = sub_1000AA6AC(@"ckksfixup", v18);
    id v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);

    if (v16)
    {
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412546;
        unsigned int v24 = v14;
        __int16 v25 = 2112;
        id v26 = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_ERROR,  "Couldn't save CKKSZoneStateEntry(%@): %@",  buf,  0x16u);
      }
    }

    else
    {
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Updated zone fixup state to CKKSFixupFetchTLKShares",  buf,  2u);
      }

      id v20 = (os_log_s *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) intendedState]);
      [*(id *)(a1 + 48) setNextState:v20];
    }

    return 1LL;
  }

uint64_t sub_10012965C(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 zoneName]);
  id v4 = sub_1000AA6AC(@"ckksfixup", v3);
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);

  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 40);
    int v9 = 138412290;
    uint64_t v10 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Recieved tlk share record from query: %@",  (uint8_t *)&v9,  0xCu);
  }

  id v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) deps]);
  [v7 intransactionCKRecordChanged:*(void *)(a1 + 40) resync:1];

  return 1LL;
}

void sub_100129A2C(_Unwind_Exception *a1)
{
}

void sub_100129B44(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) error]);

  if (v3)
  {
    id v4 = sub_1000AA6AC(@"ckksfixup", 0LL);
    id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) error]);
      *(_DWORD *)__int128 buf = 138412290;
      id v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Couldn't perform a reload: %@", buf, 0xCu);
    }

    id v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) error]);
    [WeakRetained setError:v7];
  }

  else
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained deps]);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 databaseProvider]);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    void v9[2] = sub_100129CB0;
    v9[3] = &unk_100290F80;
    v9[4] = WeakRetained;
    [v8 dispatchSyncWithSQLTransaction:v9];
  }
}

uint64_t sub_100129CB0(uint64_t a1)
{
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) deps]);
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([v1 activeManagedViews]);

  id obj = v2;
  id v26 = [v2 countByEnumeratingWithState:&v30 objects:v38 count:16];
  if (v26)
  {
    uint64_t v25 = *(void *)v31;
    *(void *)&__int128 v3 = 138412546LL;
    __int128 v23 = v3;
    do
    {
      for (CFIndex i = 0LL; i != v26; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v31 != v25) {
          objc_enumerationMutation(obj);
        }
        id v5 = *(void **)(*((void *)&v30 + 1) + 8LL * (void)i);
        uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "zoneID", v23));
        id v7 = (void *)objc_claimAutoreleasedReturnValue([v6 zoneName]);
        id v8 = sub_1000AA6AC(@"ckksfixup", v7);
        int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);

        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v10 = [*(id *)(a1 + 32) fixupNumber];
          *(_DWORD *)__int128 buf = 67109120;
          LODWORD(v35) = v10;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Successfully performed a reload fixup. New fixup number is %d",  buf,  8u);
        }

        id v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) deps]);
        id v12 = (void *)objc_claimAutoreleasedReturnValue([v11 contextID]);
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v5 zoneID]);
        uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v13 zoneName]);
        id v29 = 0LL;
        id v15 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSZoneStateEntry fromDatabase:zoneName:error:]( &OBJC_CLASS___CKKSZoneStateEntry,  "fromDatabase:zoneName:error:",  v12,  v14,  &v29));
        id v16 = v29;

        objc_msgSend(v15, "setLastFixup:", objc_msgSend(*(id *)(a1 + 32), "fixupNumber"));
        id v28 = v16;
        [v15 saveToDatabase:&v28];
        id v17 = v28;

        uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v5 zoneID]);
        id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 zoneName]);
        id v20 = sub_1000AA6AC(@"ckksfixup", v19);
        id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);

        if (v17)
        {
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = v23;
            BOOL v35 = v15;
            __int16 v36 = 2112;
            id v37 = v17;
            _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_ERROR,  "Couldn't save CKKSZoneStateEntry(%@): %@",  buf,  0x16u);
          }
        }

        else
        {
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Updated zone fixup state to CKKSFixupLocalReload",  buf,  2u);
          }

          id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) intendedState]);
          [*(id *)(a1 + 32) setNextState:v21];
        }
      }

      id v26 = [obj countByEnumeratingWithState:&v30 objects:v38 count:16];
    }

    while (v26);
  }

  return 1LL;
}

uint64_t sub_10012A380(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
  id v51 = 0LL;
  __int128 v3 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSDeviceStateEntry allInZone:error:]( &OBJC_CLASS___CKKSDeviceStateEntry,  "allInZone:error:",  v2,  &v51));
  id v4 = v51;

  if (v4)
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 zoneName]);
    id v7 = sub_1000AA6AC(@"ckksfixup", v6);
    id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);

    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      id v53 = v4;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Unable to fetch all CDSEs: %@", buf, 0xCu);
    }

    [*(id *)(a1 + 40) setError:v4];
    uint64_t v9 = 0LL;
  }

  else
  {
    __int128 v49 = 0u;
    __int128 v50 = 0u;
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v43 = v3;
    id v10 = v3;
    id v11 = [v10 countByEnumeratingWithState:&v47 objects:v56 count:16];
    if (v11)
    {
      id v12 = v11;
      uint64_t v13 = *(void *)v48;
      while (2)
      {
        for (CFIndex i = 0LL; i != v12; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v48 != v13) {
            objc_enumerationMutation(v10);
          }
          id v15 = *(void **)(*((void *)&v47 + 1) + 8LL * (void)i);
          id v16 = (void *)objc_claimAutoreleasedReturnValue([v15 storedCKRecord]);
          if (v16)
          {
            [v15 setFromCKRecord:v16];
            id v46 = 0LL;
            [v15 saveToDatabase:&v46];
            id v17 = v46;
            if (v17)
            {
              id v4 = v17;
              __int16 v36 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
              id v37 = (void *)objc_claimAutoreleasedReturnValue([v36 zoneName]);
              id v38 = sub_1000AA6AC(@"ckksfixup", v37);
              id v39 = (os_log_s *)objc_claimAutoreleasedReturnValue(v38);

              if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)__int128 buf = 138412290;
                id v53 = v4;
                _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "Unable to save CDSE: %@", buf, 0xCu);
              }

              [*(id *)(a1 + 40) setError:v4];
              uint64_t v9 = 0LL;
              __int128 v3 = v43;
              goto LABEL_31;
            }
          }

          else
          {
            uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
            id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 zoneName]);
            id v20 = sub_1000AA6AC(@"ckksfixup", v19);
            id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);

            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 138412290;
              id v53 = v15;
              _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "Saved CDSE has no stored record: %@",  buf,  0xCu);
            }
          }
        }

        id v12 = [v10 countByEnumeratingWithState:&v47 objects:v56 count:16];
        if (v12) {
          continue;
        }
        break;
      }
    }

    id v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
    __int128 v23 = (void *)objc_claimAutoreleasedReturnValue([v22 zoneName]);
    id v24 = sub_1000AA6AC(@"ckksfixup", v23);
    uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);

    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Successfully performed a ResaveDeviceState fixup",  buf,  2u);
    }

    id v26 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) deps]);
    id v27 = (void *)objc_claimAutoreleasedReturnValue([v26 contextID]);
    id v28 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
    id v29 = (void *)objc_claimAutoreleasedReturnValue([v28 zoneName]);
    id v45 = 0LL;
    __int128 v30 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSZoneStateEntry fromDatabase:zoneName:error:]( &OBJC_CLASS___CKKSZoneStateEntry,  "fromDatabase:zoneName:error:",  v27,  v29,  &v45));
    id v31 = v45;

    [v30 setLastFixup:4];
    id v44 = v31;
    [v30 saveToDatabase:&v44];
    id v4 = v44;

    __int128 v32 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
    __int128 v33 = (void *)objc_claimAutoreleasedReturnValue([v32 zoneName]);
    id v34 = sub_1000AA6AC(@"ckksfixup", v33);
    BOOL v35 = (os_log_s *)objc_claimAutoreleasedReturnValue(v34);

    if (v4)
    {
      __int128 v3 = v43;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412546;
        id v53 = v30;
        __int16 v54 = 2112;
        id v55 = v4;
        _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_ERROR,  "Couldn't save CKKSZoneStateEntry(%@): %@",  buf,  0x16u);
      }

      [*(id *)(a1 + 40) setError:v4];
      uint64_t v9 = 0LL;
    }

    else
    {
      __int128 v3 = v43;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "Updated zone fixup state to CKKSFixupResaveDeviceStateEntries",  buf,  2u);
      }

      __int128 v41 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) intendedState]);
      [*(id *)(a1 + 40) setNextState:v41];

      uint64_t v9 = 1LL;
    }
  }

void sub_10012BFE0(id a1)
{
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  [v1 addObject:@"idms_level"];
  [v1 addObject:@"preapproved"];
  [v1 addObject:@"tlk_upload_needed"];
  [v1 addObject:@"policy_check_needed"];
  [v1 addObject:@"ckks_views_changed"];
  [v1 addObject:@"recd_push"];
  [v1 addObject:@"account_available"];
  [v1 addObject:@"cdp_enabled"];
  [v1 addObject:@"attempt_sos_upgrade"];
  [v1 addObject:@"attempt_machine_id_list"];
  [v1 addObject:@"unlocked"];
  [v1 addObject:@"attempt_sos_update_preapprovals"];
  [v1 addObject:@"attempt_sos_consistency"];
  [v1 addObject:@"se_id_changed"];
  [v1 addObject:@"attempt_ucv_upgrade"];
  [v1 addObject:@"check_on_rtc_metrics"];
  [v1 addObject:@"pending_network_availablility"];
  [v1 addObject:@"check_trust_state"];
  [v1 addObject:@"apple_account_signed_out"];
  uint64_t v2 = (void *)qword_1002DEC80;
  qword_1002DEC80 = (uint64_t)v1;
}

void sub_10012C144(uint64_t a1)
{
  id v4 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) OctagonStateMap]);
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue([v4 allKeys]);
  uint64_t v2 = objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", v1));
  __int128 v3 = (void *)qword_1002DEC70;
  qword_1002DEC70 = v2;
}

void sub_10012C1B0(id a1)
{
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  [v1 addObject:@"Ready"];
  [v1 addObject:@"ReadyUpdated"];
  uint64_t v2 = (void *)qword_1002DEC60;
  qword_1002DEC60 = (uint64_t)v1;
}

void sub_10012C204(id a1)
{
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  [v1 addObject:@"NoAccount"];
  [v1 addObject:@"NoAccountDoReset"];
  [v1 addObject:@"Initializing"];
  [v1 addObject:@"DetermineiCloudAccountState"];
  [v1 addObject:@"WaitingForCloudKitAccount"];
  [v1 addObject:@"CloudKitNewlyAvailable"];
  [v1 addObject:@"WaitForCDPCapableSecurityLevel"];
  [v1 addObject:@"WaitForCDP"];
  [v1 addObject:@"Untrusted"];
  uint64_t v2 = (void *)qword_1002DEC50;
  qword_1002DEC50 = (uint64_t)v1;
}

void sub_10012C2C8(id a1)
{
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  [v1 addObject:@"Ready"];
  [v1 addObject:@"Error"];
  [v1 addObject:@"Untrusted"];
  [v1 addObject:@"WaitForCDPCapableSecurityLevel"];
  [v1 addObject:@"WaitForUnlock"];
  [v1 addObject:@"WaitForCDP"];
  uint64_t v2 = (void *)qword_1002DEC40;
  qword_1002DEC40 = (uint64_t)v1;
}

void sub_10012C35C(uint64_t a1)
{
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) OctagonStateMap]);
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([v1 allKeys]);
  __int128 v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet setWithArray:](&OBJC_CLASS___NSMutableSet, "setWithArray:", v2));

  [v3 removeObject:@"NoAccount"];
  [v3 removeObject:@"NoAccountDoReset"];
  [v3 removeObject:@"Initializing"];
  [v3 removeObject:@"DetermineiCloudAccountState"];
  [v3 removeObject:@"WaitingForCloudKitAccount"];
  [v3 removeObject:@"CloudKitNewlyAvailable"];
  [v3 removeObject:@"WaitForCDPCapableSecurityLevel"];
  [v3 removeObject:@"LocalReset"];
  [v3 removeObject:@"LocalResetClearLocalContextState"];
  [v3 removeObject:@"WaitForClassCUnlock"];
  id v4 = (void *)qword_1002DEC30;
  qword_1002DEC30 = (uint64_t)v3;
}

void sub_10012C468(uint64_t a1)
{
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v16 = a1;
  __int128 v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) stateInit]);
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  id v4 = [v3 countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v18;
    do
    {
      for (CFIndex i = 0LL; i != v5; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v18 != v6) {
          objc_enumerationMutation(v3);
        }
        id v8 = *(void **)(*((void *)&v17 + 1) + 8LL * (void)i);
        uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 objectAtIndexedSubscript:0]);
        id v10 = (void *)objc_claimAutoreleasedReturnValue([v8 objectAtIndexedSubscript:1]);
        uint64_t v11 = objc_opt_class(&OBJC_CLASS___NSString);
        if ((objc_opt_isKindOfClass(v9, v11) & 1) == 0)
        {
          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](&OBJC_CLASS___NSAssertionHandler, "currentHandler"));
          [v13 handleFailureInMethod:*(void *)(v16 + 40) object:*(void *)(v16 + 32) file:@"OTStates.m" lineNumber:321 description:@"stateName should be string"];
        }

        uint64_t v12 = objc_opt_class(&OBJC_CLASS___NSNumber);
        if ((objc_opt_isKindOfClass(v10, v12) & 1) == 0)
        {
          uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](&OBJC_CLASS___NSAssertionHandler, "currentHandler"));
          [v14 handleFailureInMethod:*(void *)(v16 + 40) object:*(void *)(v16 + 32) file:@"OTStates.m" lineNumber:322 description:@"stateNum should be number"];
        }

        -[NSMutableDictionary setObject:forKeyedSubscript:](v2, "setObject:forKeyedSubscript:", v9, v10);
      }

      id v5 = [v3 countByEnumeratingWithState:&v17 objects:v21 count:16];
    }

    while (v5);
  }

  id v15 = (void *)qword_1002DEC20;
  qword_1002DEC20 = (uint64_t)v2;
}

void sub_10012C67C(uint64_t a1)
{
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v16 = a1;
  __int128 v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) stateInit]);
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  id v4 = [v3 countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v18;
    do
    {
      for (CFIndex i = 0LL; i != v5; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v18 != v6) {
          objc_enumerationMutation(v3);
        }
        id v8 = *(void **)(*((void *)&v17 + 1) + 8LL * (void)i);
        uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 objectAtIndexedSubscript:0]);
        id v10 = (void *)objc_claimAutoreleasedReturnValue([v8 objectAtIndexedSubscript:1]);
        uint64_t v11 = objc_opt_class(&OBJC_CLASS___NSString);
        if ((objc_opt_isKindOfClass(v9, v11) & 1) == 0)
        {
          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](&OBJC_CLASS___NSAssertionHandler, "currentHandler"));
          [v13 handleFailureInMethod:*(void *)(v16 + 40) object:*(void *)(v16 + 32) file:@"OTStates.m" lineNumber:302 description:@"stateName should be string"];
        }

        uint64_t v12 = objc_opt_class(&OBJC_CLASS___NSNumber);
        if ((objc_opt_isKindOfClass(v10, v12) & 1) == 0)
        {
          uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](&OBJC_CLASS___NSAssertionHandler, "currentHandler"));
          [v14 handleFailureInMethod:*(void *)(v16 + 40) object:*(void *)(v16 + 32) file:@"OTStates.m" lineNumber:303 description:@"stateNum should be number"];
        }

        -[NSMutableDictionary setObject:forKeyedSubscript:](v2, "setObject:forKeyedSubscript:", v10, v9);
      }

      id v5 = [v3 countByEnumeratingWithState:&v17 objects:v21 count:16];
    }

    while (v5);
  }

  id v15 = (void *)qword_1002DEC10;
  qword_1002DEC10 = (uint64_t)v2;
}

void sub_10012CB80( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

void sub_10012CCA8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v5 = sub_10001267C("octagon");
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v7)
    {
      id v8 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained deps]);
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 containerName]);
      id v10 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained deps]);
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v10 contextID]);
      int v13 = 138412802;
      uint64_t v14 = v9;
      __int16 v15 = 2112;
      uint64_t v16 = v11;
      __int16 v17 = 2112;
      id v18 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Unable to remove peers for (%@,%@): %@",  (uint8_t *)&v13,  0x20u);
    }

    [WeakRetained setError:v3];
  }

  else
  {
    if (v7)
    {
      LOWORD(v13) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Successfully removed peers",  (uint8_t *)&v13,  2u);
    }
  }

  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained finishedOp]);
  [WeakRetained runBeforeGroupFinished:v12];
}

CFMutableDataRef sub_10012CE44(const __CFData *a1, uint64_t a2)
{
  uint64_t v4 = sub_1001110DC(0LL);
  uint64_t v5 = sub_100101A94(v4);
  id v7 = 0LL;
  if (!a1 || !v5) {
    goto LABEL_20;
  }
  id v8 = sub_1001C41CC(v5, v6);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
  if (!v9)
  {
    id v7 = 0LL;
    goto LABEL_20;
  }

  id v7 = v9;
  if (![v7 peerPublicKey])
  {
    SOSErrorCreate(1032LL, a2, 0LL, @"No identity to get key from");

    goto LABEL_20;
  }

  id v10 = (const void *)SecKeyCopyMatchingPrivateKey([v7 peerPublicKey], a2);

  if (!v10)
  {
LABEL_20:

    return 0LL;
  }

  uint64_t v11 = SecOTRFullIdentityCreateFromSecKeyRefSOS(kCFAllocatorDefault, v10, a2);
  if (!v11)
  {

    CFRelease(v10);
    return 0LL;
  }

  uint64_t v12 = (const void *)v11;
  CFRelease(v10);
  CFStringRef v13 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, a1, 0x8000100u);
  if (v13)
  {
    CFStringRef v15 = v13;
    uint64_t v16 = sub_1001C41CC((uint64_t)v13, v14);
    __int16 v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
    id v18 = v17;
    if (v17)
    {
      __int128 v19 = (void *)objc_claimAutoreleasedReturnValue([v17 trust]);
      id v20 = [v19 copyPublicKeyForPeer:v15 err:a2];

      id v21 = (const void *)SecOTRPublicIdentityCreateFromSecKeyRef(kCFAllocatorDefault, v20, a2);
      if (v21)
      {
        if (v20) {
          CFRelease(v20);
        }
        id v20 = (id)SecOTRSessionCreateFromID(kCFAllocatorDefault, v12, v21);
        CFMutableDataRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0LL);
        SecOTRSAppendSerialization(v20, Mutable);
        if (v20)
        {
          CFRelease(v20);
          id v20 = 0LL;
        }

        goto LABEL_14;
      }
    }

    else
    {
      id v21 = 0LL;
      id v20 = 0LL;
    }

    CFMutableDataRef Mutable = 0LL;
LABEL_14:
    CFRelease(v15);

    if (v20) {
      CFRelease(v20);
    }
    if (v21) {
      CFRelease(v21);
    }
    goto LABEL_18;
  }

  CFMutableDataRef Mutable = 0LL;
LABEL_18:
  CFRelease(v12);
  return Mutable;
}

BOOL sub_10012D03C(uint64_t a1, uint64_t a2, CFMutableDataRef *a3, CFMutableDataRef *a4, _BYTE *a5)
{
  uint64_t v9 = (const void *)SecOTRSessionCreateFromData(kCFAllocatorDefault, a1);
  if (v9)
  {
    CFMutableDataRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0LL);
    if (a2) {
      SecOTRSProcessPacket(v9, a2, Mutable);
    }
    else {
      SecOTRSAppendStartPacket(v9, Mutable);
    }
    CFMutableDataRef v11 = CFDataCreateMutable(kCFAllocatorDefault, 0LL);
    SecOTRSAppendSerialization(v9, v11);
    *a3 = v11;
    *a4 = Mutable;
    *a5 = SecOTRSGetIsReadyForMessages(v9);
    CFRelease(v9);
  }

  return v9 != 0LL;
}

LABEL_44:
  return v13;
}

  optionsQualityOfService = self->_optionsQualityOfService;
  if (optionsQualityOfService) {
    [v3 setObject:optionsQualityOfService forKey:@"options_quality_of_service"];
  }
  id v22 = self->_has;
  if ((*(_DWORD *)&v22 & 0x8000000) != 0)
  {
    __int128 v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", self->_optionsOutOfProcess));
    [v3 setObject:v48 forKey:@"options_out_of_process"];

    id v22 = self->_has;
    if ((*(_DWORD *)&v22 & 0x10000000) == 0)
    {
LABEL_48:
      if ((*(_DWORD *)&v22 & 0x1000000) == 0) {
        goto LABEL_49;
      }
      goto LABEL_84;
    }
  }

  else if ((*(_DWORD *)&v22 & 0x10000000) == 0)
  {
    goto LABEL_48;
  }

  __int128 v49 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  self->_optionsOutOfProcessForceDiscretionary));
  [v3 setObject:v49 forKey:@"options_out_of_process_force_discretionary"];

  id v22 = self->_has;
  if ((*(_DWORD *)&v22 & 0x1000000) == 0)
  {
LABEL_49:
    if ((*(_DWORD *)&v22 & 0x2000000) == 0) {
      goto LABEL_50;
    }
    goto LABEL_85;
  }

  if (self->_optionsQualityOfService)
  {
    objc_msgSend(v10, "setOptionsQualityOfService:");
    uint64_t v4 = v10;
  }

  id v8 = self->_has;
  if ((*(_DWORD *)&v8 & 0x8000000) != 0)
  {
    *((_BYTE *)v4 + 276) = self->_optionsOutOfProcess;
    *((_DWORD *)v4 + 70) |= 0x8000000u;
    id v8 = self->_has;
    if ((*(_DWORD *)&v8 & 0x10000000) == 0)
    {
LABEL_48:
      if ((*(_DWORD *)&v8 & 0x1000000) == 0) {
        goto LABEL_49;
      }
      goto LABEL_84;
    }
  }

  else if ((*(_DWORD *)&v8 & 0x10000000) == 0)
  {
    goto LABEL_48;
  }

  *((_BYTE *)v4 + 277) = self->_optionsOutOfProcessForceDiscretionary;
  *((_DWORD *)v4 + 70) |= 0x10000000u;
  id v8 = self->_has;
  if ((*(_DWORD *)&v8 & 0x1000000) == 0)
  {
LABEL_49:
    if ((*(_DWORD *)&v8 & 0x2000000) == 0) {
      goto LABEL_50;
    }
    goto LABEL_85;
  }

  id v26 = 0LL;
  if ((*(_WORD *)&v5 & 0x4000) != 0)
  {
LABEL_33:
    uint64_t v25 = 2654435761u * self->_timestampSslStart;
    if ((*(_WORD *)&v5 & 0x800) != 0) {
      goto LABEL_34;
    }
    goto LABEL_46;
  }

uint64_t sub_10012FB34(_BYTE *a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0LL;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1LL || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v9 = v5++ >= 9;
      if (v9)
      {
        unint64_t v6 = 0LL;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0LL;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    unint64_t v12 = v6 >> 3;
    if ((int)(v6 >> 3) <= 300)
    {
      if ((int)v12 <= 200)
      {
        if ((_DWORD)v12 == 102)
        {
          uint64_t String = PBReaderReadString(a2);
          uint64_t v28 = objc_claimAutoreleasedReturnValue(String);
          uint64_t v29 = 56LL;
        }

        else
        {
          if ((_DWORD)v12 != 103)
          {
LABEL_77:
            uint64_t result = PBReaderSkipValueWithTag(a2);
            if (!(_DWORD)result) {
              return result;
            }
            continue;
          }

          uint64_t v27 = PBReaderReadString(a2);
          uint64_t v28 = objc_claimAutoreleasedReturnValue(v27);
          uint64_t v29 = 40LL;
        }

        goto LABEL_76;
      }

      if ((_DWORD)v12 == 201)
      {
        uint64_t v35 = PBReaderReadString(a2);
        uint64_t v28 = objc_claimAutoreleasedReturnValue(v35);
        uint64_t v29 = 64LL;
LABEL_76:
        __int128 v42 = *(void **)&a1[v29];
        *(void *)&a1[v29] = v28;

        continue;
      }

      if ((_DWORD)v12 == 202)
      {
        uint64_t v36 = PBReaderReadString(a2);
        uint64_t v28 = objc_claimAutoreleasedReturnValue(v36);
        uint64_t v29 = 72LL;
        goto LABEL_76;
      }

      if ((_DWORD)v12 != 203) {
        goto LABEL_77;
      }
      char v18 = 0;
      unsigned int v19 = 0;
      uint64_t v20 = 0LL;
      a1[92] |= 0x10u;
      while (1)
      {
        unint64_t v21 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v21 == -1LL || v21 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v22 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v21);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v21 + 1;
        v20 |= (unint64_t)(v22 & 0x7F) << v18;
        if ((v22 & 0x80) == 0) {
          goto LABEL_84;
        }
        v18 += 7;
        BOOL v9 = v19++ >= 9;
        if (v9)
        {
          uint64_t v20 = 0LL;
          goto LABEL_86;
        }
      }

      *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_84:
      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        uint64_t v20 = 0LL;
      }
LABEL_86:
      a1[88] = v20 != 0;
    }

    else
    {
      if ((int)v12 > 400)
      {
        if ((_DWORD)v12 != 401)
        {
          if ((_DWORD)v12 == 402)
          {
            char v37 = 0;
            unsigned int v38 = 0;
            uint64_t v15 = 0LL;
            a1[92] |= 1u;
            while (1)
            {
              unint64_t v39 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v39 == -1LL || v39 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
                break;
              }
              char v40 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v39);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v39 + 1;
              v15 |= (unint64_t)(v40 & 0x7F) << v37;
              if ((v40 & 0x80) == 0) {
                goto LABEL_96;
              }
              v37 += 7;
              BOOL v9 = v38++ >= 9;
              if (v9)
              {
                uint64_t v15 = 0LL;
                goto LABEL_98;
              }
            }

            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_96:
            if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
              uint64_t v15 = 0LL;
            }
LABEL_98:
            uint64_t v44 = 8LL;
          }

          else
          {
            if ((_DWORD)v12 != 403) {
              goto LABEL_77;
            }
            char v23 = 0;
            unsigned int v24 = 0;
            uint64_t v15 = 0LL;
            a1[92] |= 2u;
            while (1)
            {
              unint64_t v25 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v25 == -1LL || v25 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
                break;
              }
              char v26 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v25);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v25 + 1;
              v15 |= (unint64_t)(v26 & 0x7F) << v23;
              if ((v26 & 0x80) == 0) {
                goto LABEL_88;
              }
              v23 += 7;
              BOOL v9 = v24++ >= 9;
              if (v9)
              {
                uint64_t v15 = 0LL;
                goto LABEL_90;
              }
            }

            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_88:
            if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
              uint64_t v15 = 0LL;
            }
LABEL_90:
            uint64_t v44 = 16LL;
          }

          goto LABEL_99;
        }

        __int128 v30 = objc_alloc_init(&OBJC_CLASS___SECC2MPCloudKitOperationInfo);
        [a1 addClientOperation:v30];
        unint64_t v45 = 0xAAAAAAAAAAAAAAAALL;
        unint64_t v46 = 0xAAAAAAAAAAAAAAAALL;
        if (!PBReaderPlaceMark(a2, &v45) || (sub_100126A7C((uint64_t)v30, a2) & 1) == 0)
        {
LABEL_102:

          return 0LL;
        }
      }

      else
      {
        if ((_DWORD)v12 != 301)
        {
          if ((_DWORD)v12 == 302)
          {
            char v31 = 0;
            unsigned int v32 = 0;
            uint64_t v15 = 0LL;
            a1[92] |= 4u;
            while (1)
            {
              unint64_t v33 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v33 == -1LL || v33 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
                break;
              }
              char v34 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v33);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v33 + 1;
              v15 |= (unint64_t)(v34 & 0x7F) << v31;
              if ((v34 & 0x80) == 0) {
                goto LABEL_92;
              }
              v31 += 7;
              BOOL v9 = v32++ >= 9;
              if (v9)
              {
                uint64_t v15 = 0LL;
                goto LABEL_94;
              }
            }

            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_92:
            if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
              uint64_t v15 = 0LL;
            }
LABEL_94:
            uint64_t v44 = 24LL;
          }

          else
          {
            if ((_DWORD)v12 != 303) {
              goto LABEL_77;
            }
            char v13 = 0;
            unsigned int v14 = 0;
            uint64_t v15 = 0LL;
            a1[92] |= 8u;
            while (1)
            {
              unint64_t v16 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v16 == -1LL || v16 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
                break;
              }
              char v17 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v16);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v16 + 1;
              v15 |= (unint64_t)(v17 & 0x7F) << v13;
              if ((v17 & 0x80) == 0) {
                goto LABEL_80;
              }
              v13 += 7;
              BOOL v9 = v14++ >= 9;
              if (v9)
              {
                uint64_t v15 = 0LL;
                goto LABEL_82;
              }
            }

            *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_80:
            if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
              uint64_t v15 = 0LL;
            }
LABEL_82:
            uint64_t v44 = 32LL;
          }

LABEL_99:
          *(void *)&a1[v44] = v15;
          continue;
        }

        __int128 v30 = objc_alloc_init(&OBJC_CLASS___SECC2MPCloudKitOperationGroupInfo);
        [a1 addOperationGroup:v30];
        unint64_t v45 = 0xAAAAAAAAAAAAAAAALL;
        unint64_t v46 = 0xAAAAAAAAAAAAAAAALL;
      }

      PBReaderRecallMark(a2, &v45);
    }
  }

  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_1001304BC(_Unwind_Exception *a1)
{
}

void sub_1001307B4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_100130D40( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100130FD8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100130FE8(uint64_t a1)
{
}

uint64_t sub_100130FF0(uint64_t a1, uint64_t a2)
{
  uint64_t v29 = 0LL;
  uint64_t v4 = sub_1000F8790(*(const __CFDictionary **)(a1 + 32), 0LL, 1LL, 0LL, &v29);
  if (v29) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (v5)
  {
    unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) viewState]);
    unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v6 zoneID]);
    char v8 = (void *)objc_claimAutoreleasedReturnValue([v7 zoneName]);
    id v9 = sub_1000AA6AC(@"ckkscurrent", v8);
    int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);

    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      char v31 = v29;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_ERROR,  "couldn't create query for item persistentRef: %@",  buf,  0xCu);
    }

    uint64_t v11 = v29;
    unint64_t v12 = @"couldn't create query for new item pref";
  }

  else
  {
    uint64_t v13 = (const void **)v4;
    v28[0] = _NSConcreteStackBlock;
    v28[1] = 3221225472LL;
    v28[2] = sub_100131344;
    v28[3] = &unk_1002902A8;
    v28[4] = *(void *)(a1 + 56);
    if (sub_100105F8C(v4, 0LL, a2, &v29, (uint64_t)v28))
    {
      if ((sub_1000F8150(v13, (CFErrorRef *)&v29) & 1) != 0) {
        return 1LL;
      }
      uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) viewState]);
      unint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v20 zoneID]);
      char v22 = (void *)objc_claimAutoreleasedReturnValue([v21 zoneName]);
      id v23 = sub_1000AA6AC(@"ckkscurrent", v22);
      unsigned int v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);

      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        char v31 = v29;
        _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_ERROR,  "couldn't destroy query for item pref: %@",  buf,  0xCu);
      }

      uint64_t v11 = v29;
      unint64_t v12 = @"couldn't destroy query for item pref";
    }

    else
    {
      sub_1000F8150(v13, 0LL);
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) viewState]);
      uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v15 zoneID]);
      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v16 zoneName]);
      id v18 = sub_1000AA6AC(@"ckkscurrent", v17);
      unsigned int v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);

      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        char v31 = v29;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "couldn't run query for item pref: %@",  buf,  0xCu);
      }

      uint64_t v11 = v29;
      unint64_t v12 = @"couldn't run query for new item pref";
    }
  }

  uint64_t v25 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:underlying:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:underlying:",  @"CKKSErrorDomain",  -50LL,  v12,  v11));
  uint64_t v26 = *(void *)(*(void *)(a1 + 48) + 8LL);
  uint64_t v27 = *(void **)(v26 + 40);
  *(void *)(v26 + 40) = v25;

  return 0LL;
}

CFTypeRef sub_100131344(CFTypeRef result, CFTypeRef cf)
{
  uint64_t v3 = (uint64_t)result;
  if (cf) {
    uint64_t result = CFRetain(cf);
  }
  *(void *)(*(void *)(*(void *)(v3 + 32) + 8LL) + 24LL) = cf;
  return result;
}

void sub_10013137C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  char v8 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained deps]);
  id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 databaseProvider]);

  if (v6)
  {
    int v10 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained viewState]);
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v10 zoneID]);
    unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 zoneName]);
    id v13 = sub_1000AA6AC(@"ckkscurrent", v12);
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);

    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      id v22 = v6;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "fetch returned an error: %@", buf, 0xCu);
    }

    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationQueue]);
    [v15 addOperation:*(void *)(a1 + 32)];
  }

  else
  {
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472LL;
    v17[2] = sub_100131564;
    v17[3] = &unk_100290208;
    id v18 = v5;
    id v19 = *(id *)(a1 + 40);
    id v20 = WeakRetained;
    [v9 dispatchSyncWithSQLTransaction:v17];
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationQueue]);
    [v16 addOperation:*(void *)(a1 + 32)];

    uint64_t v15 = v18;
  }
}

uint64_t sub_100131564(id *a1)
{
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  id obj = a1[4];
  id v2 = [obj countByEnumeratingWithState:&v27 objects:v35 count:16];
  if (v2)
  {
    id v4 = v2;
    uint64_t v5 = *(void *)v28;
    *(void *)&__int128 v3 = 138412546LL;
    __int128 v23 = v3;
    do
    {
      id v6 = 0LL;
      id v24 = v4;
      do
      {
        if (*(void *)v28 != v5) {
          objc_enumerationMutation(obj);
        }
        unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( a1[4],  "objectForKeyedSubscript:",  *(void *)(*((void *)&v27 + 1) + 8 * (void)v6),  v23));
        if ([a1[5] matchesCKRecord:v7 checkServerFields:0])
        {
          uint64_t v8 = v5;
          [a1[5] setFromCKRecord:v7];
          id v9 = a1[5];
          id v26 = 0LL;
          unsigned int v10 = [v9 saveToDatabase:&v26];
          uint64_t v11 = (os_log_s *)v26;
          unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([a1[6] viewState]);
          id v13 = (void *)objc_claimAutoreleasedReturnValue([v12 zoneID]);
          uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v13 zoneName]);
          id v15 = sub_1000AA6AC(@"ckkscurrent", v14);
          uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);

          if (!v10 || v11)
          {
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = v23;
              unsigned int v32 = v7;
              __int16 v33 = 2112;
              char v34 = v11;
              _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "couldn't save updated CKRecord to database: %@ %@",  buf,  0x16u);
            }
          }

          else
          {
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
            {
              id v21 = a1[5];
              *(_DWORD *)__int128 buf = 138412290;
              unsigned int v32 = v21;
              _os_log_debug_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEBUG,  "CKKSMirrorEntry updated: %@",  buf,  0xCu);
            }

            uint64_t v11 = v16;
          }

          uint64_t v5 = v8;
          id v4 = v24;
        }

        else
        {
          uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([a1[6] viewState]);
          id v18 = (void *)objc_claimAutoreleasedReturnValue([v17 zoneID]);
          id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 zoneName]);
          id v20 = sub_1000AA6AC(@"ckkscurrent", v19);
          uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);

          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 138412290;
            unsigned int v32 = v7;
            _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_ERROR,  "fetched non-matching record %@",  buf,  0xCu);
          }
        }

        id v6 = (char *)v6 + 1;
      }

      while (v4 != v6);
      id v4 = [obj countByEnumeratingWithState:&v27 objects:v35 count:16];
    }

    while (v4);
  }

  return 1LL;
}

uint64_t sub_10013186C(uint64_t a1)
{
  if (![*(id *)(a1 + 32) isCancelled])
  {
    v211 = 0LL;
    unint64_t v7 = *(void **)(a1 + 32);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 newerItemPersistentRef]);
    id v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) accessGroup]);
    id v210 = 0LL;
    id v10 = [v7 _onqueueFindSecDbItem:v8 accessGroup:v9 error:&v210];
    id v6 = (__CFString *)v210;
    [*(id *)(a1 + 32) setNewItem:v10];

    id v11 = [*(id *)(a1 + 32) newItem];
    unint64_t v12 = *(void **)(a1 + 32);
    if (!v11 || v6)
    {
      char v37 = (void *)objc_claimAutoreleasedReturnValue([v12 viewState]);
      unsigned int v38 = (void *)objc_claimAutoreleasedReturnValue([v37 zoneID]);
      unint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([v38 zoneName]);
      id v40 = sub_1000AA6AC(@"ckkscurrent", v39);
      __int128 v41 = (os_log_s *)objc_claimAutoreleasedReturnValue(v40);

      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v213 = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "Couldn't fetch new item, quitting: %@",  buf,  0xCu);
      }

      [*(id *)(a1 + 32) setError:v6];
      goto LABEL_25;
    }

    id v13 = (void **)[v12 newItem];
    uint64_t v14 = sub_1000E6D50(v13[2], 7LL, &v211);
    id v15 = (__CFString *)sub_1000E705C(v13, v14, &v211);
    uint64_t v16 = v15;
    if (!v15
      || (CFRetain(v15), v211)
      || (uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) newerItemSHA1]),
          unsigned __int8 v18 = -[__CFString isEqual:](v16, "isEqual:", v17),
          v17,
          (v18 & 1) == 0))
    {
      __int128 v43 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
      uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue([v43 zoneID]);
      unint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v44 zoneName]);
      id v46 = sub_1000AA6AC(@"ckkscurrent", v45);
      __int128 v47 = (os_log_s *)objc_claimAutoreleasedReturnValue(v46);

      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        __int128 v48 = (__CFString *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) newerItemSHA1]);
        *(_DWORD *)__int128 buf = 138412546;
        uint64_t v213 = v16;
        __int16 v214 = 2112;
        v215 = v48;
        _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "Hash mismatch for new item: %@ vs %@",  buf,  0x16u);
      }

      id v20 = v211;
      __int128 v49 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:underlying:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:underlying:",  @"CKKSErrorDomain",  14LL,  @"New item has changed; hashes mismatch. Refetch and try again.",
                        v211));
      [*(id *)(a1 + 32) setError:v49];

      goto LABEL_29;
    }

    id v19 = (__CFString *)sub_1000E705C([*(id *)(a1 + 32) newItem], (uint64_t)&off_1002905E8, &v211);
    id v20 = v19;
    if (v19)
    {
      CFRetain(v19);
      id v21 = *(void **)(a1 + 32);
      if (!v211)
      {
        id v22 = (void *)objc_claimAutoreleasedReturnValue([v21 oldItemPersistentRef]);

        if (v22)
        {
          __int128 v23 = *(void **)(a1 + 32);
          id v24 = (void *)objc_claimAutoreleasedReturnValue([v23 oldItemPersistentRef]);
          uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) accessGroup]);
          id v209 = 0LL;
          id v26 = [v23 _onqueueFindSecDbItem:v24 accessGroup:v25 error:&v209];
          id v6 = (__CFString *)v209;
          [*(id *)(a1 + 32) setOldItem:v26];

          id v27 = [*(id *)(a1 + 32) oldItem];
          __int128 v28 = *(void **)(a1 + 32);
          if (!v27 || v6)
          {
            int v75 = (void *)objc_claimAutoreleasedReturnValue([v28 viewState]);
            int v76 = (void *)objc_claimAutoreleasedReturnValue([v75 zoneID]);
            char v77 = (void *)objc_claimAutoreleasedReturnValue([v76 zoneName]);
            id v78 = sub_1000AA6AC(@"ckkscurrent", v77);
            int v79 = (os_log_s *)objc_claimAutoreleasedReturnValue(v78);

            if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 138412290;
              uint64_t v213 = v6;
              _os_log_impl( (void *)&_mh_execute_header,  v79,  OS_LOG_TYPE_DEFAULT,  "Couldn't fetch old item, quitting: %@",  buf,  0xCu);
            }

            [*(id *)(a1 + 32) setError:v6];
            goto LABEL_30;
          }

          CFTypeRef cf = (__CFString *)sub_1000E9CBC((void **)[v28 oldItem], &v211);
          if (!cf
            || (CFRetain(cf), v211)
            || (__int128 v29 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) oldItemSHA1]),
                unsigned __int8 v30 = -[__CFString isEqual:](cf, "isEqual:", v29),
                v29,
                (v30 & 1) == 0))
          {
            int64_t v80 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
            uint64_t v81 = (void *)objc_claimAutoreleasedReturnValue([v80 zoneID]);
            unint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([v81 zoneName]);
            id v83 = sub_1000AA6AC(@"ckkscurrent", v82);
            uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue(v83);

            if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v85 = (__CFString *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) oldItemSHA1]);
              *(_DWORD *)__int128 buf = 138412546;
              uint64_t v213 = cf;
              __int16 v214 = 2112;
              v215 = v85;
              _os_log_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_DEFAULT,  "Hash mismatch for old item: %@ vs %@",  buf,  0x16u);
            }

            uint64_t v86 = v211;
            v87 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:underlying:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:underlying:",  @"CKKSErrorDomain",  14LL,  @"Old item has changed; hashes mismatch. Refetch and try again.",
                              v211));
            [*(id *)(a1 + 32) setError:v87];

            goto LABEL_29;
          }

          v192 = (__CFString *)sub_1000E705C([*(id *)(a1 + 32) oldItem], (uint64_t)&off_1002905E8, &v211);
          if (!v192 || (CFRetain(v192), v211))
          {
            char v31 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
            unsigned int v32 = (void *)objc_claimAutoreleasedReturnValue([v31 zoneID]);
            __int16 v33 = (void *)objc_claimAutoreleasedReturnValue([v32 zoneName]);
            id v34 = sub_1000AA6AC(@"ckkscurrent", v33);
            uint64_t v35 = (os_log_s *)objc_claimAutoreleasedReturnValue(v34);

            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 138412290;
              uint64_t v213 = v211;
              _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_ERROR,  "Error fetching UUID for old item: %@",  buf,  0xCu);
            }

            uint64_t v36 = v211;
            [*(id *)(a1 + 32) setError:v211];

LABEL_29:
            id v6 = 0LL;
LABEL_30:
            uint64_t v42 = 0LL;
LABEL_31:

            goto LABEL_32;
          }
        }

        else
        {
          v192 = 0LL;
          CFTypeRef cf = 0LL;
        }

        id v57 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
        __int128 v58 = (void *)objc_claimAutoreleasedReturnValue([v57 zoneID]);
        __int128 v59 = (void *)objc_claimAutoreleasedReturnValue([v58 zoneName]);
        id v60 = sub_1000AA6AC(@"ckkscurrent", v59);
        __int128 v61 = (os_log_s *)objc_claimAutoreleasedReturnValue(v60);

        if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
        {
          __int128 v62 = (__CFString *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) currentPointerIdentifier]);
          *(_DWORD *)__int128 buf = 138412802;
          uint64_t v213 = v62;
          __int16 v214 = 2112;
          v215 = v20;
          __int16 v216 = 2112;
          v217 = v192;
          _os_log_impl( (void *)&_mh_execute_header,  v61,  OS_LOG_TYPE_DEFAULT,  "Setting current pointer for %@ to %@ (from %@)",  buf,  0x20u);
        }

        __int128 v63 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) currentPointerIdentifier]);
        __int128 v64 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
        __int128 v65 = (void *)objc_claimAutoreleasedReturnValue([v64 contextID]);
        uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
        uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue([v66 zoneID]);
        id v208 = 0LL;
        v191 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSCurrentItemPointer tryFromDatabase:contextID:state:zoneID:error:]( &OBJC_CLASS___CKKSCurrentItemPointer,  "tryFromDatabase:contextID:state:zoneID:error:",  v63,  v65,  @"remote",  v67,  &v208));
        id v6 = (__CFString *)v208;

        if (v191)
        {
          BOOL v68 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Update to current item pointer is pending."));
          __int16 v69 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  @"CKKSErrorDomain",  12LL,  v68));
          [*(id *)(a1 + 32) setError:v69];

          id v70 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
          uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue([v70 zoneID]);
          char v72 = (void *)objc_claimAutoreleasedReturnValue([v71 zoneName]);
          id v73 = sub_1000AA6AC(@"ckkscurrent", v72);
          oslog = (os_log_s *)objc_claimAutoreleasedReturnValue(v73);

          if (os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
          {
            uint64_t v74 = (__CFString *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) error]);
            *(_DWORD *)__int128 buf = 138412290;
            uint64_t v213 = v74;
            _os_log_impl( (void *)&_mh_execute_header,  oslog,  OS_LOG_TYPE_ERROR,  "Attempt to set a new current item pointer when one exists: %@",  buf,  0xCu);
          }

          uint64_t v42 = 0LL;
          goto LABEL_97;
        }

        uint64_t v187 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) currentPointerIdentifier]);
        v88 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
        int v89 = (void *)objc_claimAutoreleasedReturnValue([v88 contextID]);
        int v90 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
        uint64_t v91 = (void *)objc_claimAutoreleasedReturnValue([v90 zoneID]);
        v207 = v6;
        oslog = (os_log_s *)objc_claimAutoreleasedReturnValue( +[CKKSCurrentItemPointer tryFromDatabase:contextID:state:zoneID:error:]( &OBJC_CLASS___CKKSCurrentItemPointer,  "tryFromDatabase:contextID:state:zoneID:error:",  v187,  v89,  @"local",  v91,  &v207));
        v189 = v207;

        if (oslog)
        {
          if (v192)
          {
            v92 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s currentItemUUID](oslog, "currentItemUUID"));
            unsigned __int8 v93 = [v92 isEqualToString:v192];

            if ((v93 & 1) == 0)
            {
              uint64_t v94 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
              v95 = (void *)objc_claimAutoreleasedReturnValue([v94 zoneID]);
              v96 = (void *)objc_claimAutoreleasedReturnValue([v95 zoneName]);
              id v97 = sub_1000AA6AC(@"ckkscurrent", v96);
              v98 = (os_log_s *)objc_claimAutoreleasedReturnValue(v97);

              if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)__int128 buf = 138412546;
                uint64_t v213 = (__CFString *)oslog;
                __int16 v214 = 2112;
                v215 = v192;
                _os_log_impl( (void *)&_mh_execute_header,  v98,  OS_LOG_TYPE_DEFAULT,  "current item pointer(%@) doesn't match user-supplied UUID (%@); rejecting change of current",
                  buf,
                  0x16u);
              }

              v188 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Current pointer(%@) does not match user-supplied %@, aborting",  oslog,  v192));
              uint64_t v99 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  @"CKKSErrorDomain",  14LL,  v188));
              [*(id *)(a1 + 32) setError:v99];

LABEL_64:
              uint64_t v42 = 0LL;
LABEL_96:

              id v6 = v189;
LABEL_97:

              goto LABEL_31;
            }
          }

          else
          {
            v106 = *(void **)(a1 + 32);
            int64_t v107 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s currentItemUUID](oslog, "currentItemUUID"));
            uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) accessGroup]);
            id v109 = [v106 _onqueueFindSecDbItemWithUUID:v107 accessGroup:v108 error:0];

            if (v109)
            {
              CFRelease(v109);
              uint64_t v110 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
              uint64_t v111 = (void *)objc_claimAutoreleasedReturnValue([v110 zoneID]);
              uint64_t v112 = (void *)objc_claimAutoreleasedReturnValue([v111 zoneName]);
              id v113 = sub_1000AA6AC(@"ckkscurrent", v112);
              unsigned int v114 = (os_log_s *)objc_claimAutoreleasedReturnValue(v113);

              if (os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)__int128 buf = 138412290;
                uint64_t v213 = (__CFString *)oslog;
                _os_log_impl( (void *)&_mh_execute_header,  v114,  OS_LOG_TYPE_DEFAULT,  "no user-supplied UUID and current item pointer(%@) is not dangling; rejecting change of current",
                  buf,
                  0xCu);
              }

              v188 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"No user-supplied UUID and current pointer(%@) is not dangling, aborting",  oslog));
              v115 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  @"CKKSErrorDomain",  14LL,  v188));
              [*(id *)(a1 + 32) setError:v115];

              goto LABEL_64;
            }
          }

          -[os_log_s setCurrentItemUUID:](oslog, "setCurrentItemUUID:", v20);
        }

        else
        {
          if (v192)
          {
            uint64_t v100 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
            uint64_t v101 = (void *)objc_claimAutoreleasedReturnValue([v100 zoneID]);
            v102 = (void *)objc_claimAutoreleasedReturnValue([v101 zoneName]);
            id v103 = sub_1000AA6AC(@"ckkscurrent", v102);
            BOOL v104 = (os_log_s *)objc_claimAutoreleasedReturnValue(v103);

            if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
            {
              BOOL v105 = (__CFString *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) currentPointerIdentifier]);
              *(_DWORD *)__int128 buf = 138412290;
              uint64_t v213 = v105;
              _os_log_impl( (void *)&_mh_execute_header,  v104,  OS_LOG_TYPE_DEFAULT,  "Requested to update a current item pointer but one doesn't exist at %@; rejecting change of current",
                buf,
                0xCu);
            }

            oslog = (os_log_s *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Current pointer(%@) does not match given value of '%@', aborting",  0LL,  v192));
            v188 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  @"CKKSErrorDomain",  14LL,  oslog));
            [*(id *)(a1 + 32) setError:v188];
            goto LABEL_64;
          }

          osloga = objc_alloc(&OBJC_CLASS___CKKSCurrentItemPointer);
          uint64_t v116 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) currentPointerIdentifier]);
          v117 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
          v118 = (void *)objc_claimAutoreleasedReturnValue([v117 contextID]);
          v119 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
          v120 = (void *)objc_claimAutoreleasedReturnValue([v119 zoneID]);
          oslog = -[CKKSCurrentItemPointer initForIdentifier:contextID:currentItemUUID:state:zoneID:encodedCKRecord:]( osloga,  "initForIdentifier:contextID:currentItemUUID:state:zoneID:encodedCKRecord:",  v116,  v118,  v20,  @"local",  v120,  0LL);

          int v121 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
          uint64_t v122 = (void *)objc_claimAutoreleasedReturnValue([v121 zoneID]);
          uint64_t v123 = (void *)objc_claimAutoreleasedReturnValue([v122 zoneName]);
          id v124 = sub_1000AA6AC(@"ckkscurrent", v123);
          char v125 = (os_log_s *)objc_claimAutoreleasedReturnValue(v124);

          if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138412290;
            uint64_t v213 = (__CFString *)oslog;
            _os_log_impl( (void *)&_mh_execute_header,  v125,  OS_LOG_TYPE_DEFAULT,  "Creating a new current item pointer: %@",  buf,  0xCu);
          }
        }

        v126 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) deps]);
        uint64_t v127 = (void *)objc_claimAutoreleasedReturnValue([v126 contextID]);
        uint64_t v128 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
        uint64_t v129 = (void *)objc_claimAutoreleasedReturnValue([v128 zoneID]);
        v206 = v189;
        v188 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSSQLDatabaseObject allUUIDsWithContextID:zoneID:error:]( &OBJC_CLASS___CKKSOutgoingQueueEntry,  "allUUIDsWithContextID:zoneID:error:",  v127,  v129,  &v206));
        CFMutableStringRef v185 = v206;

        uint64_t v130 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) deps]);
        uint64_t v131 = (void *)objc_claimAutoreleasedReturnValue([v130 contextID]);
        v132 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
        v133 = (void *)objc_claimAutoreleasedReturnValue([v132 zoneID]);
        CFMutableStringRef v205 = v185;
        v184 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSSQLDatabaseObject allUUIDsWithContextID:zoneID:error:]( &OBJC_CLASS___CKKSIncomingQueueEntry,  "allUUIDsWithContextID:zoneID:error:",  v131,  v133,  &v205));
        uint64_t v134 = v205;

        if (([v188 containsObject:v20] & 1) != 0
          || [v184 containsObject:v20])
        {
          v135 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"New item(%@) is being synced; can't set current pointer.",
                             v20));
          uint64_t v136 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  @"CKKSErrorDomain",  13LL,  v135));
        }

        else
        {
          uint64_t v136 = (uint64_t)v134;
        }

        if (v192)
        {
          uint32_t v137 = (void *)v136;
          if ((objc_msgSend(v188, "containsObject:") & 1) != 0
            || [v184 containsObject:v192])
          {
            v138 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Old item(%@) is being synced; can't set current pointer.",
                               v192));
            uint64_t v136 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  @"CKKSErrorDomain",  13LL,  v138));
          }
        }

        if (v136)
        {
          v189 = (__CFString *)v136;
          uint64_t v139 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
          v140 = (void *)objc_claimAutoreleasedReturnValue([v139 zoneID]);
          uint64_t v141 = (void *)objc_claimAutoreleasedReturnValue([v140 zoneName]);
          id v142 = sub_1000AA6AC(@"ckkscurrent", v141);
          unsigned int v143 = (os_log_s *)objc_claimAutoreleasedReturnValue(v142);

          if (os_log_type_enabled(v143, OS_LOG_TYPE_ERROR))
          {
            unsigned int v144 = (__CFString *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) currentPointerIdentifier]);
            *(_DWORD *)__int128 buf = 138412546;
            uint64_t v213 = v144;
            __int16 v214 = 2112;
            v215 = v189;
            _os_log_impl( (void *)&_mh_execute_header,  v143,  OS_LOG_TYPE_ERROR,  "Error attempting to update current item pointer %@: %@",  buf,  0x16u);
          }

          [*(id *)(a1 + 32) setError:v189];
          uint64_t v42 = 0LL;
        }

        else
        {
          v145 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s currentItemUUID](oslog, "currentItemUUID"));
          v146 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) deps]);
          unsigned int v147 = (void *)objc_claimAutoreleasedReturnValue([v146 contextID]);
          v148 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
          uint64_t v149 = (void *)objc_claimAutoreleasedReturnValue([v148 zoneID]);
          id v204 = 0LL;
          v186 = (__CFString *)objc_claimAutoreleasedReturnValue( +[CKKSMirrorEntry fromDatabase:contextID:zoneID:error:]( &OBJC_CLASS___CKKSMirrorEntry,  "fromDatabase:contextID:zoneID:error:",  v145,  v147,  v149,  &v204));
          id v182 = v204;

          if (v186) {
            BOOL v150 = v182 == 0LL;
          }
          else {
            BOOL v150 = 0;
          }
          int v151 = !v150;
          uint64_t v152 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
          v153 = (void *)objc_claimAutoreleasedReturnValue([v152 zoneID]);
          BOOL v154 = (void *)objc_claimAutoreleasedReturnValue([v153 zoneName]);
          id v155 = sub_1000AA6AC(@"ckkscurrent", v154);
          unsigned int v156 = (os_log_s *)objc_claimAutoreleasedReturnValue(v155);

          if (v151)
          {
            if (os_log_type_enabled(v156, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 138412546;
              uint64_t v213 = (__CFString *)oslog;
              __int16 v214 = 2112;
              v215 = v186;
              _os_log_impl( (void *)&_mh_execute_header,  v156,  OS_LOG_TYPE_ERROR,  "Error attempting to set a current item pointer to an item that isn't synced: %@ %@",  buf,  0x16u);
            }

            v157 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s currentItemUUID](oslog, "currentItemUUID"));
            uint64_t v158 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"No synced item matching (%@); can't set current pointer.",
                               v157));
            v189 = (__CFString *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:underlying:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:underlying:",  @"CKKSErrorDomain",  -25300LL,  v158,  v182));

            [*(id *)(a1 + 32) setError:v189];
            uint64_t v42 = 0LL;
          }

          else
          {
            if (os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 138412290;
              uint64_t v213 = (__CFString *)oslog;
              _os_log_impl( (void *)&_mh_execute_header,  v156,  OS_LOG_TYPE_DEFAULT,  "Saving new current item pointer %@",  buf,  0xCu);
            }

            unsigned int v159 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
            v160 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
            uint64_t v161 = (void *)objc_claimAutoreleasedReturnValue([v160 zoneID]);
            v183 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s CKRecordWithZoneID:](oslog, "CKRecordWithZoneID:", v161));

            v162 = (void *)objc_claimAutoreleasedReturnValue([v183 recordID]);
            -[NSMutableDictionary setObject:forKeyedSubscript:](v159, "setObject:forKeyedSubscript:", v183, v162);

            v190 = objc_alloc_init(&OBJC_CLASS___NSBlockOperation);
            -[NSBlockOperation setName:](v190, "setName:", @"updateCurrentItemPointer-modifyRecordsComplete");
            [*(id *)(a1 + 32) dependOnBeforeGroupFinished:v190];
            v163 = objc_alloc(&OBJC_CLASS___CKModifyRecordsOperation);
            v164 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary allValues](v159, "allValues"));
            v165 = -[CKModifyRecordsOperation initWithRecordsToSave:recordIDsToDelete:]( v163,  "initWithRecordsToSave:recordIDsToDelete:",  v164,  0LL);
            [*(id *)(a1 + 32) setModifyRecordsOperation:v165];

            v166 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) modifyRecordsOperation]);
            [v166 setAtomic:1];

            v167 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) modifyRecordsOperation]);
            uint64_t v168 = (void *)objc_claimAutoreleasedReturnValue([v167 configuration]);
            [v168 setIsCloudKitSupportOperation:1];

            v169 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) modifyRecordsOperation]);
            [v169 setQualityOfService:25];

            uint64_t v170 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) modifyRecordsOperation]);
            [v170 setSavePolicy:0];

            v171 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) ckoperationGroup]);
            v172 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) modifyRecordsOperation]);
            [v172 setGroup:v171];

            v202[0] = _NSConcreteStackBlock;
            v202[1] = 3221225472LL;
            v202[2] = sub_100133108;
            v202[3] = &unk_1002901E0;
            objc_copyWeak(&v203, (id *)(a1 + 40));
            v173 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) modifyRecordsOperation]);
            [v173 setPerRecordSaveBlock:v202];

            v196[0] = _NSConcreteStackBlock;
            v196[1] = 3221225472LL;
            v196[2] = sub_1001332B0;
            v196[3] = &unk_1002910A8;
            objc_copyWeak(&v201, (id *)(a1 + 40));
            v174 = v159;
            v197 = v174;
            v175 = v190;
            uint64_t v198 = v175;
            char v199 = oslog;
            timeval v200 = v186;
            CFMutableStringRef v176 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) modifyRecordsOperation]);
            [v176 setModifyRecordsCompletionBlock:v196];

            CFMutableArrayRef v177 = *(void **)(a1 + 32);
            v178 = (void *)objc_claimAutoreleasedReturnValue([v177 modifyRecordsOperation]);
            [v177 dependOnBeforeGroupFinished:v178];

            uint64_t v179 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) deps]);
            v180 = (void *)objc_claimAutoreleasedReturnValue([v179 ckdatabase]);
            v181 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) modifyRecordsOperation]);
            [v180 addOperation:v181];

            objc_destroyWeak(&v201);
            objc_destroyWeak(&v203);

            v189 = 0LL;
            uint64_t v42 = 1LL;
          }
        }

        goto LABEL_96;
      }
    }

    else
    {
      id v21 = *(void **)(a1 + 32);
    }

    id v51 = (void *)objc_claimAutoreleasedReturnValue([v21 viewState]);
    id v52 = (void *)objc_claimAutoreleasedReturnValue([v51 zoneID]);
    id v53 = (void *)objc_claimAutoreleasedReturnValue([v52 zoneName]);
    id v54 = sub_1000AA6AC(@"ckkscurrent", v53);
    id v55 = (os_log_s *)objc_claimAutoreleasedReturnValue(v54);

    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v213 = v211;
      _os_log_impl( (void *)&_mh_execute_header,  v55,  OS_LOG_TYPE_ERROR,  "Error fetching UUID for new item: %@",  buf,  0xCu);
    }

    id v56 = v211;
    [*(id *)(a1 + 32) setError:v211];

    goto LABEL_29;
  }

  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewState]);
  __int128 v3 = (void *)objc_claimAutoreleasedReturnValue([v2 zoneID]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 zoneName]);
  id v5 = sub_1000AA6AC(@"ckkscurrent", v4);
  id v6 = (__CFString *)objc_claimAutoreleasedReturnValue(v5);

  if (os_log_type_enabled((os_log_t)v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)v6,  OS_LOG_TYPE_DEFAULT,  "CKKSUpdateCurrentItemPointerOperation cancelled, quitting",  buf,  2u);
  }

void sub_1001330D8(_Unwind_Exception *a1)
{
}

void sub_100133108(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v11 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained viewState]);
  unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 zoneID]);
  id v13 = (void *)objc_claimAutoreleasedReturnValue([v12 zoneName]);
  id v14 = sub_1000AA6AC(@"ckkscurrent", v13);
  id v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);

  if (v9)
  {
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      int v17 = 138412546;
      id v18 = v9;
      __int16 v19 = 2112;
      id v20 = v7;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "error on row: %@ %@", (uint8_t *)&v17, 0x16u);
    }
  }

  else if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v7 recordName]);
    int v17 = 138412546;
    id v18 = v16;
    __int16 v19 = 2112;
    id v20 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Current pointer upload successful for %@: %@",  (uint8_t *)&v17,  0x16u);
  }
}

void sub_1001332B0(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  id v11 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained deps]);
  unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 databaseProvider]);

  if (v9)
  {
    id v13 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained viewState]);
    id v14 = (void *)objc_claimAutoreleasedReturnValue([v13 zoneID]);
    id v15 = (void *)objc_claimAutoreleasedReturnValue([v14 zoneName]);
    id v16 = sub_1000AA6AC(@"ckkscurrent", v15);
    int v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);

    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "CloudKit returned an error: %@",  (uint8_t *)&buf,  0xCu);
    }

    [WeakRetained setError:v9];
    v27[0] = _NSConcreteStackBlock;
    v27[1] = 3221225472LL;
    v27[2] = sub_1001335B0;
    v27[3] = &unk_100290208;
    v27[4] = WeakRetained;
    id v28 = v9;
    id v29 = *(id *)(a1 + 32);
    [v12 dispatchSyncWithSQLTransaction:v27];
    id v18 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationQueue]);
    [v18 addOperation:*(void *)(a1 + 40)];
  }

  else
  {
    *(void *)&__int128 buf = 0LL;
    *((void *)&buf + 1) = &buf;
    uint64_t v31 = 0x3032000000LL;
    unsigned int v32 = sub_100130FD8;
    __int16 v33 = sub_100130FE8;
    id v34 = 0LL;
    v22[0] = _NSConcreteStackBlock;
    v22[1] = 3221225472LL;
    v22[2] = sub_1001335F0;
    v22[3] = &unk_100290230;
    id v23 = v7;
    id v19 = *(id *)(a1 + 48);
    id v25 = WeakRetained;
    p___int128 buf = &buf;
    id v24 = v19;
    [v12 dispatchSyncWithSQLTransaction:v22];
    uint64_t v20 = *(void *)(*((void *)&buf + 1) + 40LL);
    if (!v20)
    {
      [WeakRetained _fetchAndUpdateMirrorEntry:*(void *)(a1 + 56)];
      uint64_t v20 = *(void *)(*((void *)&buf + 1) + 40LL);
    }

    [WeakRetained setError:v20];
    id v21 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationQueue]);
    [v21 addOperation:*(void *)(a1 + 40)];

    _Block_object_dispose(&buf, 8);
  }
}

void sub_100133590( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

id sub_1001335B0(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) deps]);
  id v3 = [v2 intransactionCKWriteFailed:*(void *)(a1 + 40) attemptedRecordsChanged:*(void *)(a1 + 48)];

  return v3;
}

uint64_t sub_1001335F0(uint64_t a1)
{
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v32 objects:v40 count:16];
  if (v3)
  {
    id v5 = v3;
    uint64_t v6 = *(void *)v33;
    *(void *)&__int128 v4 = 138412290LL;
    __int128 v30 = v4;
    do
    {
      for (CFIndex i = 0LL; i != v5; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v33 != v6) {
          objc_enumerationMutation(v2);
        }
        id v8 = *(void **)(*((void *)&v32 + 1) + 8LL * (void)i);
        id v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "recordType", v30));
        unsigned int v10 = [v9 isEqualToString:@"currentitem"];

        if (v10)
        {
          if ([*(id *)(a1 + 40) matchesCKRecord:v8])
          {
            [*(id *)(a1 + 40) setStoredCKRecord:v8];
            id v11 = *(void **)(a1 + 40);
            uint64_t v12 = *(void *)(*(void *)(a1 + 56) + 8LL);
            id obj = *(id *)(v12 + 40);
            [v11 saveToDatabase:&obj];
            objc_storeStrong((id *)(v12 + 40), obj);
            if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL)) {
              goto LABEL_15;
            }
            id v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) viewState]);
            id v14 = (void *)objc_claimAutoreleasedReturnValue([v13 zoneID]);
            id v15 = (void *)objc_claimAutoreleasedReturnValue([v14 zoneName]);
            id v16 = sub_1000AA6AC(@"ckkscurrent", v15);
            int v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);

            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            {
              id v18 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
              *(_DWORD *)__int128 buf = v30;
              char v37 = v18;
              id v19 = v17;
              uint64_t v20 = "Couldn't save new current pointer to database: %@";
              uint32_t v21 = 12;
              goto LABEL_13;
            }
          }

          else
          {
            id v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) viewState]);
            id v23 = (void *)objc_claimAutoreleasedReturnValue([v22 zoneID]);
            id v24 = (void *)objc_claimAutoreleasedReturnValue([v23 zoneName]);
            id v25 = sub_1000AA6AC(@"ckkscurrent", v24);
            int v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v25);

            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            {
              uint64_t v26 = *(void *)(a1 + 40);
              *(_DWORD *)__int128 buf = 138412546;
              char v37 = v8;
              __int16 v38 = 2112;
              uint64_t v39 = v26;
              id v19 = v17;
              uint64_t v20 = "CloudKit record does not match saved record, ignoring: %@ %@";
              uint32_t v21 = 22;
LABEL_13:
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, v20, buf, v21);
            }
          }
        }

void sub_100133EA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
}

void sub_100134020(uint64_t a1)
{
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) deps]);
  id v2 = (void *)objc_claimAutoreleasedReturnValue([v1 activeManagedViews]);

  id obj = v2;
  id v3 = [v2 countByEnumeratingWithState:&v29 objects:v35 count:16];
  if (v3)
  {
    id v5 = v3;
    uint64_t v6 = *(void *)v30;
    *(void *)&__int128 v4 = 138412290LL;
    __int128 v26 = v4;
    do
    {
      for (CFIndex i = 0LL; i != v5; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v30 != v6) {
          objc_enumerationMutation(obj);
        }
        id v8 = *(void **)(*((void *)&v29 + 1) + 8LL * (void)i);
        id v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "zoneID", v26));
        unsigned int v10 = (void *)objc_claimAutoreleasedReturnValue([v8 contextID]);
        id v11 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSCurrentKeySet loadForZone:contextID:]( &OBJC_CLASS___CKKSCurrentKeySet,  "loadForZone:contextID:",  v9,  v10));

        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 currentTLKPointer]);
        if (v12)
        {
          id v13 = *(void **)(a1 + 40);
          id v14 = (void *)objc_claimAutoreleasedReturnValue([v8 zoneID]);
          [v13 setObject:v11 forKeyedSubscript:v14];
        }

        else
        {
          id v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) previousPendingKeySets]);
          id v16 = (void *)objc_claimAutoreleasedReturnValue([v8 zoneID]);
          id v14 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:v16]);

          if (v14
            && (int v17 = (void *)objc_claimAutoreleasedReturnValue([v14 zoneID]),
                id v18 = (void *)objc_claimAutoreleasedReturnValue([v8 zoneID]),
                unsigned int v19 = [v17 isEqual:v18],
                v18,
                v17,
                v19))
          {
            uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v8 zoneID]);
            uint32_t v21 = (void *)objc_claimAutoreleasedReturnValue([v20 zoneName]);
            id v22 = sub_1000AA6AC(@"ckkstlk", v21);
            id v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);

            if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = v26;
              __int128 v34 = v14;
              _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Using prevously-generated proposed keyset: %@",  buf,  0xCu);
            }

            id v24 = *(void **)(a1 + 40);
            id v25 = (void *)objc_claimAutoreleasedReturnValue([v8 zoneID]);
            [v24 setObject:v14 forKeyedSubscript:v25];
          }

          else
          {
            [*(id *)(a1 + 48) addObject:v8];
          }
        }
      }

      id v5 = [obj countByEnumeratingWithState:&v29 objects:v35 count:16];
    }

    while (v5);
  }
}

uint64_t sub_100134318(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 zoneName]);
  id v4 = sub_1000AA6AC(@"ckkstlk", v3);
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);

  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Generating new TLK", buf, 2u);
  }

  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) contextID]);
  id v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
  id v196 = 0LL;
  id v8 = (CKKSCurrentKeySet *)objc_claimAutoreleasedReturnValue( +[CKKSKey currentKeyForClass:contextID:zoneID:error:]( &OBJC_CLASS___CKKSKey,  "currentKeyForClass:contextID:zoneID:error:",  @"tlk",  v6,  v7,  &v196));
  id v9 = (CKKSCurrentKeySet *)v196;

  if (v9)
  {
    unsigned int v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 zoneName]);
    id v12 = sub_1000AA6AC(@"ckkstlk", v11);
    id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);

    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      timeval v200 = v9;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "couldn't load the current TLK: %@", buf, 0xCu);
    }
  }

  id v14 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) contextID]);
  id v195 = 0LL;
  id v15 =  -[CKKSCurrentKeySet ensureKeyLoadedForContextID:cache:error:]( v8,  "ensureKeyLoadedForContextID:cache:error:",  v14,  0LL,  &v195);
  id v16 = (CKKSCurrentKeySet *)v195;

  int v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
  id v18 = (void *)objc_claimAutoreleasedReturnValue([v17 zoneName]);
  id v19 = sub_1000AA6AC(@"ckkstlk", v18);
  uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);

  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412546;
    timeval v200 = v8;
    __int16 v201 = 2112;
    v202 = v16;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Old TLK is: %@ %@", buf, 0x16u);
  }

  if (!v16)
  {
    id v194 = 0LL;
    __int128 v31 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAESSIVKey randomKey:](&OBJC_CLASS___CKKSAESSIVKey, "randomKey:", &v194));
    id v32 = v194;
    __int128 v33 = objc_alloc(&OBJC_CLASS___CKKSKey);
    __int128 v34 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) contextID]);
    __int128 v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
    uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v35 UUIDString]);
    uint64_t v172 = a1;
    char v37 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
    __int16 v38 = -[CKKSKey initSelfWrappedWithAESKey:contextID:uuid:keyclass:state:zoneID:encodedCKRecord:currentkey:]( v33,  "initSelfWrappedWithAESKey:contextID:uuid:keyclass:state:zoneID:encodedCKRecord:currentkey:",  v31,  v34,  v36,  @"tlk",  @"local",  v37,  0LL,  1LL);

    uint64_t v39 = v38;
    id v193 = v32;
    v173 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSCurrentKeySet getKeychainBackedKey:](v38, "getKeychainBackedKey:", &v193));
    __int128 v30 = (CKKSCurrentKeySet *)v193;

    if (!v38 || !v31 || !v173 || v30)
    {
      __int128 v50 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v172 + 32) zoneID]);
      id v51 = (void *)objc_claimAutoreleasedReturnValue([v50 zoneName]);
      id v52 = sub_1000AA6AC(@"ckkstlk", v51);
      id v53 = (os_log_s *)objc_claimAutoreleasedReturnValue(v52);

      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        timeval v200 = v30;
        _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "Couldn't create new TLK: %@", buf, 0xCu);
      }

      [*(id *)(v172 + 40) setNextState:@"error"];
      [*(id *)(v172 + 40) setError:v30];
      uint64_t v49 = 0LL;
      goto LABEL_50;
    }

    v167 = v9;
    id v192 = 0LL;
    id v40 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSKey randomKeyWrappedByParent:keyclass:error:]( &OBJC_CLASS___CKKSKey,  "randomKeyWrappedByParent:keyclass:error:",  v38,  @"classA",  &v192));
    id v41 = v192;
    id v191 = v41;
    uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSKey randomKeyWrappedByParent:keyclass:error:]( &OBJC_CLASS___CKKSKey,  "randomKeyWrappedByParent:keyclass:error:",  v38,  @"classC",  &v191));
    __int128 v43 = (CKKSCurrentKeySet *)v191;

    if (v43)
    {
      uint64_t v44 = v43;
      unint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v172 + 32) zoneID]);
      id v46 = (void *)objc_claimAutoreleasedReturnValue([v45 zoneName]);
      id v47 = sub_1000AA6AC(@"ckkstlk", v46);
      __int128 v48 = (os_log_s *)objc_claimAutoreleasedReturnValue(v47);

      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        timeval v200 = v44;
        _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_ERROR,  "couldn't make new key hierarchy: %@",  buf,  0xCu);
      }

      [*(id *)(v172 + 40) setError:v44];
      [*(id *)(v172 + 40) setNextState:@"error"];

      __int128 v30 = v44;
      uint64_t v49 = 0LL;
      id v9 = v167;
      goto LABEL_50;
    }

    v160 = v31;
    id v54 = v40;
    id v55 = v42;
    uint64_t v56 = v172;
    id v57 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v172 + 32) contextID]);
    uint64_t v168 = v39;
    __int128 v58 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSCurrentKeySet uuid](v39, "uuid"));
    __int128 v59 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v172 + 32) zoneID]);
    id v190 = 0LL;
    v163 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSCurrentKeyPointer forKeyClass:contextID:withKeyUUID:zoneID:error:]( &OBJC_CLASS___CKKSCurrentKeyPointer,  "forKeyClass:contextID:withKeyUUID:zoneID:error:",  @"tlk",  v57,  v58,  v59,  &v190));
    id v60 = v190;

    __int128 v61 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v172 + 32) contextID]);
    v165 = v54;
    __int128 v62 = (void *)objc_claimAutoreleasedReturnValue([v54 uuid]);
    __int128 v63 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v172 + 32) zoneID]);
    id v189 = v60;
    v162 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSCurrentKeyPointer forKeyClass:contextID:withKeyUUID:zoneID:error:]( &OBJC_CLASS___CKKSCurrentKeyPointer,  "forKeyClass:contextID:withKeyUUID:zoneID:error:",  @"classA",  v61,  v62,  v63,  &v189));
    id v64 = v189;

    __int128 v65 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v172 + 32) contextID]);
    v164 = v55;
    uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue([v55 uuid]);
    uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v172 + 32) zoneID]);
    id v188 = v64;
    uint64_t v68 = objc_claimAutoreleasedReturnValue( +[CKKSCurrentKeyPointer forKeyClass:contextID:withKeyUUID:zoneID:error:]( &OBJC_CLASS___CKKSCurrentKeyPointer,  "forKeyClass:contextID:withKeyUUID:zoneID:error:",  @"classC",  v65,  v66,  v67,  &v188));
    __int16 v69 = (CKKSCurrentKeySet *)v188;

    __int128 v30 = v69;
    uint64_t v161 = (void *)v68;
    if (v69)
    {
      id v70 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v172 + 32) zoneID]);
      uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue([v70 zoneName]);
      id v72 = sub_1000AA6AC(@"ckkstlk", v71);
      id v73 = (os_log_s *)objc_claimAutoreleasedReturnValue(v72);

      if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        timeval v200 = v30;
        _os_log_impl( (void *)&_mh_execute_header,  v73,  OS_LOG_TYPE_ERROR,  "couldn't make current key records: %@",  buf,  0xCu);
      }

      [*(id *)(v172 + 40) setNextState:@"error"];
      [*(id *)(v172 + 40) setError:v30];
      uint64_t v49 = 0LL;
      __int128 v31 = v160;
      uint64_t v39 = v168;
      goto LABEL_48;
    }

    id v74 = -[CKKSCurrentKeySet copy](v8, "copy");
    uint64_t v39 = v168;
    if (v74)
    {
      int v75 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSCurrentKeySet contextID](v8, "contextID"));
      id v187 = 0LL;
      id v76 = [v74 ensureKeyLoadedForContextID:v75 cache:0 error:&v187];
      char v77 = (CKKSCurrentKeySet *)v187;

      if (v77)
      {
        id v78 = v74;
        int v79 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v172 + 40) deps]);
        int64_t v80 = (void *)objc_claimAutoreleasedReturnValue([v79 lockStateTracker]);
        unsigned int v81 = [v80 isLockedError:v77];

        unint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v172 + 32) zoneID]);
        id v83 = (void *)objc_claimAutoreleasedReturnValue([v82 zoneName]);
        id v84 = sub_1000AA6AC(@"ckkstlk", v83);
        uint64_t v85 = (os_log_s *)objc_claimAutoreleasedReturnValue(v84);

        BOOL v86 = os_log_type_enabled(v85, OS_LOG_TYPE_ERROR);
        __int128 v30 = v77;
        if (v81)
        {
          if (v86)
          {
            *(_DWORD *)__int128 buf = 138412290;
            timeval v200 = v77;
            _os_log_impl( (void *)&_mh_execute_header,  v85,  OS_LOG_TYPE_ERROR,  "Couldn't unwrap TLK due to lock state. Entering a waiting state; %@",
              buf,
              0xCu);
          }

          *(_BYTE *)(*(void *)(*(void *)(v172 + 64) + 8LL) + 24LL) = 1;
        }

        else
        {
          if (v86)
          {
            *(_DWORD *)__int128 buf = 138412290;
            timeval v200 = v77;
            _os_log_impl( (void *)&_mh_execute_header,  v85,  OS_LOG_TYPE_ERROR,  "couldn't unwrap TLK, aborting new TLK operation: %@",  buf,  0xCu);
          }

          [*(id *)(v172 + 40) setNextState:@"error"];
        }

        [*(id *)(v172 + 40) setError:v77];

LABEL_47:
        uint64_t v49 = 0LL;
        __int128 v31 = v160;
LABEL_48:
        uint64_t v94 = v164;
        unsigned __int8 v93 = v165;
LABEL_49:

LABEL_50:
        goto LABEL_51;
      }

      id v186 = 0LL;
      [v74 wrapUnder:v168 error:&v186];
      v87 = (CKKSCurrentKeySet *)v186;
      if (v87)
      {
        __int128 v30 = v87;
        v88 = v74;
        int v89 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v172 + 32) zoneID]);
        int v90 = (void *)objc_claimAutoreleasedReturnValue([v89 zoneName]);
        id v91 = sub_1000AA6AC(@"ckkstlk", v90);
        v92 = (os_log_s *)objc_claimAutoreleasedReturnValue(v91);

        if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 138412290;
          timeval v200 = v30;
          _os_log_impl( (void *)&_mh_execute_header,  v92,  OS_LOG_TYPE_ERROR,  "couldn't wrap oldTLK, aborting new TLK operation: %@",  buf,  0xCu);
        }

        [*(id *)(v172 + 40) setNextState:@"error"];
        [*(id *)(v172 + 40) setError:v30];

        goto LABEL_47;
      }

      [v74 setCurrentkey:0];
      uint64_t v68 = (uint64_t)v161;
    }

    BOOL v154 = v74;
    v96 = objc_alloc(&OBJC_CLASS___CKKSCurrentKeySet);
    id v97 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSCurrentKeySet zoneID](v168, "zoneID"));
    v98 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSCurrentKeySet contextID](v168, "contextID"));
    uint64_t v99 = -[CKKSCurrentKeySet initWithZoneID:contextID:](v96, "initWithZoneID:contextID:", v97, v98);

    -[CKKSCurrentKeySet setTlk:](v99, "setTlk:", v168);
    -[CKKSCurrentKeySet setClassA:](v99, "setClassA:", v54);
    -[CKKSCurrentKeySet setClassC:](v99, "setClassC:", v164);
    -[CKKSCurrentKeySet setCurrentTLKPointer:](v99, "setCurrentTLKPointer:", v163);
    -[CKKSCurrentKeySet setCurrentClassAPointer:](v99, "setCurrentClassAPointer:", v162);
    -[CKKSCurrentKeySet setCurrentClassCPointer:](v99, "setCurrentClassCPointer:", v68);
    -[CKKSCurrentKeySet setProposed:](v99, "setProposed:", 1LL);
    uint64_t v100 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v172 + 32) zoneID]);
    uint64_t v101 = (void *)objc_claimAutoreleasedReturnValue([v100 zoneName]);
    id v102 = sub_1000AA6AC(@"ckkstlk", v101);
    id v103 = (os_log_s *)objc_claimAutoreleasedReturnValue(v102);

    if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      timeval v200 = v99;
      _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "Saving new keys %@ to keychain", buf, 0xCu);
    }

    id v185 = 0LL;
    -[CKKSCurrentKeySet saveKeyMaterialToKeychain:](v168, "saveKeyMaterialToKeychain:", &v185);
    id v104 = v185;
    id v184 = v104;
    [v54 saveKeyMaterialToKeychain:&v184];
    id v105 = v184;

    id v183 = v105;
    [v164 saveKeyMaterialToKeychain:&v183];
    v106 = (CKKSCurrentKeySet *)v183;

    id v155 = v99;
    if (v106)
    {
      int64_t v107 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v172 + 40) deps]);
      uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue([v107 lockStateTracker]);
      unsigned int v109 = [v108 isLockedError:v106];

      uint64_t v110 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v172 + 32) zoneID]);
      uint64_t v111 = (void *)objc_claimAutoreleasedReturnValue([v110 zoneName]);
      id v112 = sub_1000AA6AC(@"ckkstlk", v111);
      id v113 = (os_log_s *)objc_claimAutoreleasedReturnValue(v112);

      BOOL v114 = os_log_type_enabled(v113, OS_LOG_TYPE_ERROR);
      __int128 v30 = v106;
      if (v109)
      {
        if (v114)
        {
          *(_DWORD *)__int128 buf = 138412290;
          timeval v200 = v106;
          _os_log_impl( (void *)&_mh_execute_header,  v113,  OS_LOG_TYPE_ERROR,  "Couldn't save new key material to keychain due to lock state. Entering a waiting state; %@",
            buf,
            0xCu);
        }

        *(_BYTE *)(*(void *)(*(void *)(v172 + 64) + 8LL) + 24LL) = 1;
      }

      else
      {
        if (v114)
        {
          *(_DWORD *)__int128 buf = 138412290;
          timeval v200 = v106;
          _os_log_impl( (void *)&_mh_execute_header,  v113,  OS_LOG_TYPE_ERROR,  "couldn't save new key material to keychain; aborting new TLK operation: %@",
            buf,
            0xCu);
        }

        [*(id *)(v172 + 40) setNextState:@"error"];
      }

      [*(id *)(v172 + 40) setError:v106];
      uint64_t v49 = 0LL;
LABEL_100:
      __int128 v31 = v160;
      uint64_t v94 = v164;
      unsigned __int8 v93 = v165;

      goto LABEL_49;
    }

    v115 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
    __int128 v179 = 0u;
    __int128 v180 = 0u;
    __int128 v181 = 0u;
    __int128 v182 = 0u;
    id obj = *(id *)(v172 + 48);
    id v159 = [obj countByEnumeratingWithState:&v179 objects:v198 count:16];
    __int128 v30 = 0LL;
    if (!v159)
    {
LABEL_91:

      uint64_t v149 = (void *)objc_claimAutoreleasedReturnValue([v115 allObjects]);
      -[CKKSCurrentKeySet setPendingTLKShares:](v155, "setPendingTLKShares:", v149);

      BOOL v150 = *(void **)(v56 + 56);
      int v151 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSCurrentKeySet zoneID](v39, "zoneID"));
      [v150 setObject:v155 forKeyedSubscript:v151];
      uint64_t v49 = 1LL;
LABEL_99:

      goto LABEL_100;
    }

    uint64_t v158 = *(void *)v180;
    v157 = v8;
    v171 = v115;
LABEL_62:
    id v116 = 0LL;
    while (1)
    {
      if (*(void *)v180 != v158) {
        objc_enumerationMutation(obj);
      }
      v117 = v30;
      v166 = (char *)v116;
      v118 = *(CKKSCurrentKeySet **)(*((void *)&v179 + 1) + 8LL * (void)v116);
      v119 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSCurrentKeySet currentSelfPeers](v118, "currentSelfPeers"));
      uint64_t v120 = objc_claimAutoreleasedReturnValue([v119 currentSelf]);
      if (!v120) {
        break;
      }
      int v121 = (void *)v120;
      uint64_t v122 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSCurrentKeySet currentSelfPeersError](v118, "currentSelfPeersError"));

      if (v122) {
        goto LABEL_82;
      }
      __int128 v177 = 0u;
      __int128 v178 = 0u;
      __int128 v175 = 0u;
      __int128 v176 = 0u;
      uint64_t v170 = v118;
      id v169 = (id)objc_claimAutoreleasedReturnValue(-[CKKSCurrentKeySet currentTrustedPeers](v118, "currentTrustedPeers"));
      id v123 = [v169 countByEnumeratingWithState:&v175 objects:v197 count:16];
      if (v123)
      {
        id v124 = v123;
        uint64_t v125 = *(void *)v176;
        do
        {
          for (CFIndex i = 0LL; i != v124; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v176 != v125) {
              objc_enumerationMutation(v169);
            }
            uint64_t v127 = *(CKKSCurrentKeySet **)(*((void *)&v175 + 1) + 8LL * (void)i);
            uint64_t v128 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSCurrentKeySet publicEncryptionKey](v127, "publicEncryptionKey"));

            uint64_t v129 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v56 + 32) zoneID]);
            uint64_t v130 = (void *)objc_claimAutoreleasedReturnValue([v129 zoneName]);
            id v131 = sub_1000AA6AC(@"ckkstlk", v130);
            v132 = (os_log_s *)objc_claimAutoreleasedReturnValue(v131);

            BOOL v133 = os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT);
            if (v128)
            {
              if (v133)
              {
                *(_DWORD *)__int128 buf = 138412546;
                timeval v200 = v168;
                __int16 v201 = 2112;
                v202 = v127;
                _os_log_impl( (void *)&_mh_execute_header,  v132,  OS_LOG_TYPE_DEFAULT,  "Generating TLK(%@) share for %@",  buf,  0x16u);
              }

              uint64_t v134 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v56 + 32) contextID]);
              v135 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSCurrentKeySet currentSelfPeers](v170, "currentSelfPeers"));
              uint64_t v136 = (void *)objc_claimAutoreleasedReturnValue([v135 currentSelf]);
              v174 = v117;
              v132 = (os_log_s *)objc_claimAutoreleasedReturnValue( +[CKKSTLKShareRecord share:contextID:as:to:epoch:poisoned:error:]( &OBJC_CLASS___CKKSTLKShareRecord,  "share:contextID:as:to:epoch:poisoned:error:",  v173,  v134,  v136,  v127,  -1LL,  0LL,  &v174));
              uint32_t v137 = v174;

              uint64_t v56 = v172;
              [v171 addObject:v132];
              v117 = v137;
            }

            else if (v133)
            {
              *(_DWORD *)__int128 buf = 138412290;
              timeval v200 = v127;
              _os_log_impl( (void *)&_mh_execute_header,  v132,  OS_LOG_TYPE_DEFAULT,  "No need to make TLK for %@; they don't have any encryption keys",
                buf,
                0xCu);
            }
          }

          id v124 = [v169 countByEnumeratingWithState:&v175 objects:v197 count:16];
        }

        while (v124);
        id v8 = v157;
        v138 = v166;
        id v9 = v167;
        __int128 v30 = v117;
        v115 = v171;
        uint64_t v39 = v168;
        uint64_t v139 = (os_log_s *)v169;
        goto LABEL_87;
      }

      __int128 v30 = v117;
      v115 = v171;
      v138 = v166;
      uint64_t v139 = (os_log_s *)v169;
LABEL_86:
      id v8 = v157;
LABEL_87:

      id v116 = v138 + 1;
      if (v116 == v159)
      {
        id v148 = [obj countByEnumeratingWithState:&v179 objects:v198 count:16];
        id v159 = v148;
        if (v148) {
          goto LABEL_62;
        }
        goto LABEL_91;
      }
    }

LABEL_82:
    v140 = v118;
    unsigned int v141 = -[CKKSCurrentKeySet essential](v118, "essential");
    id v142 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v56 + 32) zoneID]);
    unsigned int v143 = (void *)objc_claimAutoreleasedReturnValue([v142 zoneName]);
    id v144 = sub_1000AA6AC(@"ckkstlk", v143);
    v145 = (os_log_s *)objc_claimAutoreleasedReturnValue(v144);

    v146 = v145;
    BOOL v147 = os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT);
    v138 = v166;
    if (v141)
    {
      uint64_t v39 = v168;
      __int128 v30 = v117;
      v115 = v171;
      if (v147)
      {
        uint64_t v152 = (CKKSCurrentKeySet *)objc_claimAutoreleasedReturnValue(-[CKKSCurrentKeySet currentSelfPeersError](v140, "currentSelfPeersError"));
        *(_DWORD *)__int128 buf = 138412546;
        timeval v200 = v168;
        __int16 v201 = 2112;
        v202 = v152;
        _os_log_impl( (void *)&_mh_execute_header,  v146,  OS_LOG_TYPE_DEFAULT,  "Fatal error: unable to generate TLK shares for (%@): %@",  buf,  0x16u);
      }

      v153 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSCurrentKeySet currentSelfPeersError](v140, "currentSelfPeersError"));
      [*(id *)(v56 + 40) setError:v153];

      [*(id *)(v56 + 40) setNextState:@"error"];
      uint64_t v49 = 0LL;
      int v151 = obj;
      id v8 = v157;
      goto LABEL_99;
    }

    uint64_t v39 = v168;
    __int128 v30 = v117;
    v115 = v171;
    if (v147)
    {
      *(_DWORD *)__int128 buf = 138412546;
      timeval v200 = v168;
      __int16 v201 = 2112;
      v202 = v140;
      uint64_t v139 = v146;
      _os_log_impl( (void *)&_mh_execute_header,  v146,  OS_LOG_TYPE_DEFAULT,  "Unable to generate TLK shares for (%@): %@",  buf,  0x16u);
    }

    else
    {
      uint64_t v139 = v146;
    }

    goto LABEL_86;
  }

  uint32_t v21 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) deps]);
  id v22 = (void *)objc_claimAutoreleasedReturnValue([v21 lockStateTracker]);
  id v23 = v16;
  unsigned int v24 = [v22 isLockedError:v16];

  id v25 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
  __int128 v26 = (void *)objc_claimAutoreleasedReturnValue([v25 zoneName]);
  id v27 = sub_1000AA6AC(@"ckkstlk", v26);
  id v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);

  BOOL v29 = os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
  __int128 v30 = v23;
  if (v24)
  {
    if (v29)
    {
      *(_DWORD *)__int128 buf = 138412290;
      timeval v200 = v23;
      _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "Couldn't fetch and unwrap old TLK due to lock state. Entering a waiting state; %@",
        buf,
        0xCu);
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) = 1;
  }

  else
  {
    if (v29)
    {
      *(_DWORD *)__int128 buf = 138412290;
      timeval v200 = v23;
      _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_ERROR,  "Couldn't fetch and unwrap old TLK: %@",  buf,  0xCu);
    }

    [*(id *)(a1 + 40) setNextState:@"error"];
  }

  [*(id *)(a1 + 40) setError:v23];
  uint64_t v39 = 0LL;
  uint64_t v49 = 0LL;
LABEL_51:

  return v49;
}

id sub_100135F60(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (*(_BYTE *)(a1 + 40)) {
    uint64_t v5 = 2LL;
  }
  else {
    uint64_t v5 = 1LL;
  }
  [v3 setIcloudAccountState:v5];
  [v4 setAltDSID:*(void *)(a1 + 32)];
  return v4;
}

OTAccountMetadataClassC *__cdecl sub_100135FA8(id a1, OTAccountMetadataClassC *a2)
{
  id v2 = a2;
  -[OTAccountMetadataClassC setIcloudAccountState:](v2, "setIcloudAccountState:", 1LL);
  -[OTAccountMetadataClassC setAltDSID:](v2, "setAltDSID:", 0LL);
  return v2;
}

void sub_1001361E0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

LABEL_49:
  id v55 = (void *)objc_claimAutoreleasedReturnValue(-[OctagonCheckTrustStateOperation deps](self, "deps"));
  uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue([v55 stateHolder]);
  v98[0] = _NSConcreteStackBlock;
  v98[1] = 3221225472LL;
  v98[2] = sub_100136EAC;
  v98[3] = &unk_100291520;
  uint64_t v99 = v12;
  id v97 = 0LL;
  id v57 = [v56 persistAccountChanges:v98 error:&v97];
  __int128 v58 = v97;

  if (v57 && !v58)
  {
    __int128 v59 = sub_10001267C("octagon-consistency");
    id v60 = (os_log_s *)objc_claimAutoreleasedReturnValue(v59);
    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "Saved new account metadata", buf, 2u);
    }

    goto LABEL_54;
  }

  unint64_t v82 = (void *)objc_claimAutoreleasedReturnValue(-[OctagonCheckTrustStateOperation deps](self, "deps"));
  id v83 = (void *)objc_claimAutoreleasedReturnValue([v82 lockStateTracker]);
  id v84 = [v83 isLockedError:v58];

  uint64_t v85 = sub_10001267C("SecError");
  BOOL v86 = (os_log_s *)objc_claimAutoreleasedReturnValue(v85);
  v87 = os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT);
  if (v84)
  {
    if (v87)
    {
      *(_DWORD *)__int128 buf = 138412290;
      id v102 = v58;
      _os_log_impl( (void *)&_mh_execute_header,  v86,  OS_LOG_TYPE_DEFAULT,  "octagon-consistency: Unable to save new account state due to lock state: %@",  buf,  0xCu);
    }

    v88 = &off_100290390;
  }

  else
  {
    if (v87)
    {
      *(_DWORD *)__int128 buf = 138412290;
      id v102 = v58;
      _os_log_impl( (void *)&_mh_execute_header,  v86,  OS_LOG_TYPE_DEFAULT,  "octagon-consistency: Unable to save new account state. Erroring: %@",  buf,  0xCu);
    }

    -[CKKSResultOperation setError:](self, "setError:", v58);
    v88 = &off_100290360;
  }

  -[OctagonCheckTrustStateOperation setNextState:](self, "setNextState:", *v88);
  uint64_t v94 = (void *)objc_claimAutoreleasedReturnValue(-[OctagonCheckTrustStateOperation finishedOp](self, "finishedOp"));
  -[CKKSGroupOperation runBeforeGroupFinished:](self, "runBeforeGroupFinished:", v94);

LABEL_94:
}

  uint32_t v21 = 0LL;
LABEL_50:
  id v19 = -[NSString hash](self->_optionsQualityOfService, "hash");
  uint64_t v6 = self->_has;
  if ((*(_DWORD *)&v6 & 0x8000000) != 0)
  {
    id v7 = 2654435761LL * self->_optionsOutOfProcess;
    if ((*(_DWORD *)&v6 & 0x10000000) != 0)
    {
LABEL_52:
      id v8 = 2654435761LL * self->_optionsOutOfProcessForceDiscretionary;
      if ((*(_DWORD *)&v6 & 0x1000000) != 0) {
        goto LABEL_53;
      }
      goto LABEL_59;
    }
  }

  else
  {
    id v7 = 0LL;
    if ((*(_DWORD *)&v6 & 0x10000000) != 0) {
      goto LABEL_52;
    }
  }

  id v8 = 0LL;
  if ((*(_DWORD *)&v6 & 0x1000000) != 0)
  {
LABEL_53:
    id v9 = 2654435761LL * self->_optionsAllowExpensiveAccess;
    if ((*(_DWORD *)&v6 & 0x2000000) != 0) {
      goto LABEL_54;
    }
    goto LABEL_60;
  }

          uint64_t v20 = 0;
          if (!MutableCopy) {
            goto LABEL_27;
          }
          goto LABEL_26;
        }

        id v15 = sub_10001267C("V2update");
        id v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Updating PeerInfo to V2 within SOSAccountUpdateViewSets",  buf,  2u);
        }
      }

      sub_1000130AC(MutableCopy, (uint64_t)&stru_100292508);
      sub_1000130AC(a5, (uint64_t)&stru_100292528);
      if (sub_1001A88B0(v8, MutableCopy, 1))
      {
        if (sub_1001A88B0(v8, a5, 2))
        {
          int v17 = IsCurrent ^ 1;
          if (MutableCopy) {
            v17 |= SOSViewSetEnable(v13, MutableCopy);
          }
          if (a5)
          {
          }

          else if (!v17)
          {
            goto LABEL_25;
          }

          if (SOSFullPeerInfoUpdateToThisPeer(v10, v13, 0LL))
          {
            id v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "circle_transport"));
            v36[0] = _NSConcreteStackBlock;
            v36[1] = 3221225472LL;
            v36[2] = sub_1001A8940;
            _OWORD v36[3] = &unk_100293E88;
            v36[4] = self;
            id v19 = -[SOSAccountTrustClassic modifyCircle:err:action:](self, "modifyCircle:err:action:", v18, 0LL, v36);

            if (v19) {
              sub_1001957A4(v8);
            }
          }

id sub_100136EAC(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_msgSend(v3, "setTrustState:", objc_msgSend(*(id *)(a1 + 32), "trustState"));
  id v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) peerID]);
  [v3 setPeerID:v4];

  return v3;
}

void sub_100136F08(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v11 = WeakRetained;
  if (v8 && v7 && !v9)
  {
    [WeakRetained afterTPHTrustState:v7 trustedPeers:v8];
  }

  else
  {
    id v12 = sub_10001267C("SecError");
    id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = 138412290;
      id v16 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "octagon: TPH was unable to determine current peer state: %@",  (uint8_t *)&v15,  0xCu);
    }

    [v11 setError:v9];
    [v11 setNextState:@"Error"];
    id v14 = (void *)objc_claimAutoreleasedReturnValue([v11 finishedOp]);
    [v11 runBeforeGroupFinished:v14];
  }
}

void sub_1001382A0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
}

void sub_100138468( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_100138BE8(uint64_t a1)
{
  char v2 = [*(id *)(a1 + 32) queueIsLocked] ^ 1;
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(21LL, 0LL);
  id v4 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(global_queue);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100138C94;
  void v5[3] = &unk_100290408;
  id v6 = *(id *)(a1 + 40);
  char v7 = v2;
  dispatch_async(v4, v5);
}

id sub_100138C94(uint64_t a1)
{
  return [*(id *)(a1 + 32) lockStateChangeNotification:*(unsigned __int8 *)(a1 + 40)];
}

id sub_100138CA4(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) queueIsLocked];
  return result;
}

id sub_100138CDC(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onqueueRecheck];
}

id sub_100138CE4(uint64_t a1)
{
  return [*(id *)(a1 + 32) lockStateChangeNotification:*(unsigned __int8 *)(a1 + 40)];
}

void sub_100138CF4(id a1)
{
  id v1 = sub_1000AA6AC(@"ckks", 0LL);
  char v2 = (os_log_s *)objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)id v3 = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Keybag unlocked", v3, 2u);
  }
}

uint64_t sub_100138D68(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100138D78(uint64_t a1)
{
}

void sub_100138D80(uint64_t a1)
{
  if ([*(id *)(a1 + 32) queueIsLocked])
  {
    uint64_t v2 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) lastUnlockedTime]);
    uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
    id v4 = *(void **)(v3 + 40);
    *(void *)(v3 + 40) = v2;
  }

  else
  {
    uint64_t v5 = objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
    uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8LL);
    char v7 = *(void **)(v6 + 40);
    *(void *)(v6 + 40) = v5;

    [*(id *)(a1 + 32) setLastUnlockedTime:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40)];
  }

uint64_t sub_100138E00(uint64_t result)
{
  *(_BYTE *)(*(void *)(*(void *)(result + 40) + 8LL) + 24LL) = *(_BYTE *)(*(void *)(result + 32) + 8LL);
  return result;
}

void sub_100138E14(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained _onqueueRecheck];
}

void sub_100138E40(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained _onqueueRecheck];
}

void sub_100138EAC(id a1)
{
  id v1 = objc_alloc(&OBJC_CLASS___CKKSLockStateTracker);
  id v4 = objc_alloc_init(&OBJC_CLASS___CKKSActualLockStateProvider);
  uint64_t v2 = -[CKKSLockStateTracker initWithProvider:](v1, "initWithProvider:", v4);
  uint64_t v3 = (void *)qword_1002DEC98;
  qword_1002DEC98 = (uint64_t)v2;
}

void sub_100139140(id a1)
{
  id v3 = (id)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
  uint64_t v1 = objc_claimAutoreleasedReturnValue([v3 UUIDString]);
  uint64_t v2 = (void *)qword_1002DECC0;
  qword_1002DECC0 = v1;
}

id sub_100139188()
{
  if (qword_1002DECB8 != -1) {
    dispatch_once(&qword_1002DECB8, &stru_100290448);
  }
  return (id)qword_1002DECB0;
}

void sub_1001391C8(id a1)
{
  id v3 = (id)objc_claimAutoreleasedReturnValue(+[NSBundle mainBundle](&OBJC_CLASS___NSBundle, "mainBundle"));
  uint64_t v1 = objc_claimAutoreleasedReturnValue([v3 infoDictionary]);
  uint64_t v2 = (void *)qword_1002DECB0;
  qword_1002DECB0 = v1;
}

id sub_100139210(void *a1)
{
  uint64_t v1 = qword_1002DECD0;
  id v2 = a1;
  if (v1 != -1) {
    dispatch_once(&qword_1002DECD0, &stru_100290488);
  }
  id v3 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1002DECA8 objectForKeyedSubscript:v2]);

  return v3;
}

void sub_100139278(id a1)
{
  uint64_t v1 = -[NSMutableDictionary initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableDictionary), "initWithCapacity:", 0LL);
  id v2 = (void *)qword_1002DECA8;
  qword_1002DECA8 = (uint64_t)v1;

  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  *(void *)&__int128 buf = @"UniqueDeviceID";
  *((void *)&buf + 1) = @"BuildVersion";
  id v16 = @"ProductName";
  int v17 = @"ProductType";
  id v18 = @"ProductVersion";
  id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &buf, 5LL));
  id v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v11;
    do
    {
      for (CFIndex i = 0LL; i != v5; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v11 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(void *)(*((void *)&v10 + 1) + 8LL * (void)i);
        id v9 = (void *)MGCopyAnswer(v8, 0LL);
        if (v9)
        {
          [(id)qword_1002DECA8 setObject:v9 forKeyedSubscript:v8];
        }

        else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v8;
          _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)&_os_log_default,  OS_LOG_TYPE_DEFAULT,  "Error getting %@ from MobileGestalt",  (uint8_t *)&buf,  0xCu);
        }
      }

      id v5 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }

    while (v5);
  }
}

void sub_10013AF60( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, id *location)
{
}

void sub_10013B274(_Unwind_Exception *a1)
{
}

void sub_10013B5D8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *location, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, id a21)
{
}

void sub_10013BAC4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *location, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, id a23)
{
}

LABEL_138:
    uint64_t v20 = objc_claimAutoreleasedReturnValue( +[OctagonStateTransitionOperation named:entering:]( &OBJC_CLASS___OctagonStateTransitionOperation,  "named:entering:",  @"fetch-requested",  @"begin_fetch"));
    goto LABEL_34;
  }

  if ([v8 isEqualToString:@"begin_fetch"])
  {
    [v9 _onqueueRemoveFlag:@"fetch_complete"];
    if ([v9 _onqueueContains:@"new_priority_views"]
      && (id)-[CKKSKeychainView trustStatus](self, "trustStatus") == (id)1)
    {
      [v9 _onqueueRemoveFlag:@"new_priority_views"];
      -[CKKSKeychainView _onqueuePrioritizePriorityViews](self, "_onqueuePrioritizePriorityViews");
    }

    id location = (id)0xAAAAAAAAAAAAAAAALL;
    objc_initWeak(&location, self);
    uint64_t v94 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
    v95 = (void *)objc_claimAutoreleasedReturnValue([v94 currentFetchReasons]);
    v215 = [v95 copy];

    v96 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
    id v97 = (void *)objc_claimAutoreleasedReturnValue([v96 currentFetchReasons]);
    [v97 removeAllObjects];

    v98 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView zoneChangeFetcher](self, "zoneChangeFetcher"));
    __int16 v214 = (void *)objc_claimAutoreleasedReturnValue([v98 requestSuccessfulFetchForManyReasons:v215]);

    v231[0] = _NSConcreteStackBlock;
    v231[1] = 3221225472LL;
    v231[2] = sub_100155E2C;
    v231[3] = &unk_100291A38;
    uint64_t v213 = &v232;
    objc_copyWeak(&v232, &location);
    __int16 v216 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSResultOperation named:withBlock:]( &OBJC_CLASS___CKKSResultOperation,  "named:withBlock:",  @"post-fetch",  v231));
    [v216 addDependency:v214];
    -[CKKSKeychainView scheduleOperation:](self, "scheduleOperation:", v216);
    uint64_t v99 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
    uint64_t v100 = (void *)objc_claimAutoreleasedReturnValue([v99 currentFetchReasons]);
    v219 = [v100 containsObject:@"keyhierarchy"];

    v229 = 0u;
    v230 = 0u;
    v227 = 0u;
    v228 = 0u;
    uint64_t v101 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
    id obj = (id)objc_claimAutoreleasedReturnValue([v101 views]);

    id v102 = [obj countByEnumeratingWithState:&v227 objects:v244 count:16];
    if (v102)
    {
      v218 = *(void *)v228;
      do
      {
        for (j = 0LL; j != v102; j = (char *)j + 1)
        {
          if (*(void *)v228 != v218) {
            objc_enumerationMutation(obj);
          }
          id v104 = *(void **)(*((void *)&v227 + 1) + 8LL * (void)j);
          id v105 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v104, "zoneName", v213));
          v106 = sub_1000AA6AC(@"fetch", v105);
          int64_t v107 = (os_log_s *)objc_claimAutoreleasedReturnValue(v106);

          if (os_log_type_enabled(v107, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138412546;
            *(void *)&uint8_t buf[4] = v104;
            v242 = 1024;
            v243 = v219;
            _os_log_impl( (void *)&_mh_execute_header,  v107,  OS_LOG_TYPE_DEFAULT,  "Current state is %@, khf: %d",  buf,  0x12u);
          }

          if ((v219 & 1) == 0)
          {
            uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue([v104 viewKeyHierarchyState]);
            unsigned int v109 = [v108 isEqualToString:@"ready"];

            if ((v109 & 1) != 0) {
              continue;
            }
          }

          [v104 setViewKeyHierarchyState:@"fetching"];
        }

        id v102 = [obj countByEnumeratingWithState:&v227 objects:v244 count:16];
      }

      while (v102);
    }

    uint64_t v110 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
    uint64_t v111 = (void *)objc_claimAutoreleasedReturnValue([v110 overallLaunch]);
    [v111 addEvent:@"begin-fetch"];

    id v18 = (CKKSLocalResetOperation *)objc_claimAutoreleasedReturnValue( +[OctagonStateTransitionOperation named:entering:]( &OBJC_CLASS___OctagonStateTransitionOperation,  "named:entering:",  @"waiting-for-fetch",  @"fetching"));
    objc_destroyWeak(v213);

    objc_destroyWeak(&location);
    goto LABEL_35;
  }

  if ([v8 isEqualToString:@"fetching"])
  {
    if ([v9 _onqueueContains:@"fetch_complete"])
    {
      [v9 _onqueueRemoveFlag:@"fetch_complete"];
      uint64_t v20 = objc_claimAutoreleasedReturnValue( +[OctagonStateTransitionOperation named:entering:]( &OBJC_CLASS___OctagonStateTransitionOperation,  "named:entering:",  @"fetch-complete",  @"fetchcomplete"));
      goto LABEL_34;
    }

    if ([v9 _onqueueContains:@"new_priority_views"]
      && (id)-[CKKSKeychainView trustStatus](self, "trustStatus") == (id)1)
    {
      [v9 _onqueueRemoveFlag:@"new_priority_views"];
      -[CKKSKeychainView _onqueuePrioritizePriorityViews](self, "_onqueuePrioritizePriorityViews");
    }

    goto LABEL_52;
  }

  if ([v8 isEqualToString:@"fetchcomplete"])
  {
    v119 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
    uint64_t v120 = (void *)objc_claimAutoreleasedReturnValue([v119 overallLaunch]);
    [v120 addEvent:@"fetch-complete"];

    uint64_t v20 = objc_claimAutoreleasedReturnValue( +[OctagonStateTransitionOperation named:entering:]( &OBJC_CLASS___OctagonStateTransitionOperation,  "named:entering:",  @"post-fetch-process",  @"process_key_hierarchy"));
    goto LABEL_34;
  }

  if ([v8 isEqualToString:@"process_key_hierarchy"])
  {
    if ([v9 _onqueueContains:@"fetch_requested"])
    {
      [v9 _onqueueRemoveFlag:@"fetch_requested"];
      uint64_t v125 = sub_1000AA6AC(@"ckkskey", 0LL);
      v118 = (os_log_s *)objc_claimAutoreleasedReturnValue(v125);
      if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v118,  OS_LOG_TYPE_DEFAULT,  "Kicking off a fetch based on request",  buf,  2u);
      }

      goto LABEL_138;
    }

    [v9 _onqueueRemoveFlag:@"key_process_requested"];
    v126 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
    [v126 setStateForActiveCKKSManagedViews:@"process_key_hierarchy"];

    uint64_t v127 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
    [v127 setStateForActiveExternallyManagedViews:@"ready"];

    uint64_t v128 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
    uint64_t v129 = (void *)objc_claimAutoreleasedReturnValue([v128 overallLaunch]);
    [v129 addEvent:@"process_key_hierarchy"];

    uint64_t v130 = objc_alloc(&OBJC_CLASS___CKKSProcessReceivedKeysOperation);
    id v131 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
    v132 = -[CKKSProcessReceivedKeysOperation initWithDependencies:allowFullRefetchResult:intendedState:errorState:]( v130,  "initWithDependencies:allowFullRefetchResult:intendedState:errorState:",  v131,  -[CKKSKeychainView keyStateMachineRefetched](self, "keyStateMachineRefetched") ^ 1,  @"check_zone_hierarchies",  @"error");
LABEL_159:
    id v18 = (CKKSLocalResetOperation *)v132;

    goto LABEL_35;
  }

  if ([v8 isEqualToString:@"check_zone_hierarchies"])
  {
    if (-[CKKSKeychainView anyViewsInState:](self, "anyViewsInState:", @"unhealthy"))
    {
      uint64_t v20 = objc_claimAutoreleasedReturnValue( +[OctagonStateTransitionOperation named:entering:]( &OBJC_CLASS___OctagonStateTransitionOperation,  "named:entering:",  @"unhealthy",  @"unhealthy"));
      goto LABEL_34;
    }

    if (-[CKKSKeychainView anyViewsInState:](self, "anyViewsInState:", @"tlkmissing"))
    {
      uint64_t v20 = objc_claimAutoreleasedReturnValue( +[OctagonStateTransitionOperation named:entering:]( &OBJC_CLASS___OctagonStateTransitionOperation,  "named:entering:",  @"tlk-missing",  @"tlkmissing"));
      goto LABEL_34;
    }

    if (-[CKKSKeychainView anyViewsInState:](self, "anyViewsInState:", @"newtlksfailed"))
    {
      v140 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
      unsigned int v141 = (void *)objc_claimAutoreleasedReturnValue([v140 currentFetchReasons]);
      [v141 addObject:@"conflict"];

      uint64_t v20 = objc_claimAutoreleasedReturnValue( +[OctagonStateTransitionOperation named:entering:]( &OBJC_CLASS___OctagonStateTransitionOperation,  "named:entering:",  @"newtlks-failed",  @"begin_fetch"));
      goto LABEL_34;
    }

    if (-[CKKSKeychainView anyViewsInState:](self, "anyViewsInState:", @"waitfortrust"))
    {
      v145 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
      v146 = (void *)objc_claimAutoreleasedReturnValue([v145 allViews]);
      BOOL v147 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
      id v148 = (void *)objc_claimAutoreleasedReturnValue([v147 views]);
      uint64_t v149 = [v146 isEqualToSet:v148];

      if ((v149 & 1) == 0)
      {
        *(void *)__int128 buf = 0xAAAAAAAAAAAAAAAALL;
        objc_initWeak((id *)buf, self);
        v225[0] = _NSConcreteStackBlock;
        v225[1] = 3221225472LL;
        v225[2] = sub_100155E78;
        v225[3] = &unk_100291A88;
        objc_copyWeak(&v226, (id *)buf);
        id v18 = (CKKSLocalResetOperation *)objc_claimAutoreleasedReturnValue( +[OctagonStateTransitionOperation named:intending:errorState:withBlockTakingSelf:]( &OBJC_CLASS___OctagonStateTransitionOperation,  "named:intending:errorState:withBlockTakingSelf:",  @"handle-all-views-trust-loss",  @"initializing",  @"initializing",  v225));
        objc_destroyWeak(&v226);
        objc_destroyWeak((id *)buf);
        goto LABEL_35;
      }

      uint64_t v20 = objc_claimAutoreleasedReturnValue( +[OctagonStateTransitionOperation named:entering:]( &OBJC_CLASS___OctagonStateTransitionOperation,  "named:entering:",  @"no-trust",  @"lose_trust"));
      goto LABEL_34;
    }

    if (-[CKKSKeychainView anyViewsInState:](self, "anyViewsInState:", @"needrefetch"))
    {
      id v131 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView viewsInState:](self, "viewsInState:", @"needrefetch"));
      id v155 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
      [v155 operateOnSelectViews:v131];

      v132 = (CKKSProcessReceivedKeysOperation *)objc_claimAutoreleasedReturnValue( +[OctagonStateTransitionOperation named:entering:]( &OBJC_CLASS___OctagonStateTransitionOperation,  "named:entering:",  @"reset-views",  @"needrefetch"));
      goto LABEL_159;
    }

    if (-[CKKSKeychainView anyViewsInState:](self, "anyViewsInState:", @"waitforunlock"))
    {
      v163 = -[OctagonPendingFlag initWithFlag:conditions:]( objc_alloc(&OBJC_CLASS___OctagonPendingFlag),  "initWithFlag:conditions:",  @"device_unlocked",  1LL);
      [v10 _onqueueHandlePendingFlagLater:v163];
    }

    if (-[CKKSKeychainView anyViewsInState:](self, "anyViewsInState:", @"waitfortlkcreation"))
    {
      v164 = sub_1000AA6AC(@"ckkskey", 0LL);
      v165 = (os_log_s *)objc_claimAutoreleasedReturnValue(v164);
      if (os_log_type_enabled(v165, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "Requesting TLK upload", buf, 2u);
      }

      v166 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView suggestTLKUpload](self, "suggestTLKUpload"));
      [v166 trigger];
    }

    v220 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
    v223 = 0u;
    v224 = 0u;
    v221 = 0u;
    v222 = 0u;
    v167 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
    uint64_t v168 = (void *)objc_claimAutoreleasedReturnValue([v167 views]);

    id v169 = [v168 countByEnumeratingWithState:&v221 objects:v240 count:16];
    if (v169)
    {
      uint64_t v170 = *(void *)v222;
      do
      {
        for (k = 0LL; k != v169; k = (char *)k + 1)
        {
          if (*(void *)v222 != v170) {
            objc_enumerationMutation(v168);
          }
          uint64_t v172 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v221 + 1) + 8 * (void)k) viewKeyHierarchyState]);
          [v220 addObject:v172];
        }

        id v169 = [v168 countByEnumeratingWithState:&v221 objects:v240 count:16];
      }

      while (v169);
    }

    v173 = sub_100098524();
    v174 = (void *)objc_claimAutoreleasedReturnValue(v173);
    __int128 v175 = [v220 isSubsetOfSet:v174];

    if ((v175 & 1) == 0)
    {
      __int128 v176 = sub_1000AA6AC(@"ckks", 0LL);
      __int128 v177 = (os_log_s *)objc_claimAutoreleasedReturnValue(v176);
      if (os_log_type_enabled(v177, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        *(void *)&uint8_t buf[4] = v220;
        _os_log_impl((void *)&_mh_execute_header, v177, OS_LOG_TYPE_DEFAULT, "Misbehaving key states: %@", buf, 0xCu);
      }
    }

    if ([v9 _onqueueContains:@"key_set"])
    {
      [v9 _onqueueRemoveFlag:@"key_set"];
      __int128 v178 = objc_alloc(&OBJC_CLASS___CKKSNewTLKOperation);
      __int128 v179 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
      __int128 v180 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView lastNewTLKOperation](self, "lastNewTLKOperation"));
      __int128 v181 = (void *)objc_claimAutoreleasedReturnValue([v180 keysets]);
      id v18 = -[CKKSNewTLKOperation initWithDependencies:rollTLKIfPresent:preexistingPendingKeySets:intendedState:errorState:]( v178,  "initWithDependencies:rollTLKIfPresent:preexistingPendingKeySets:intendedState:errorState:",  v179,  0LL,  v181,  @"check_zone_hierarchies",  @"error");

      -[CKKSKeychainView setLastNewTLKOperation:](self, "setLastNewTLKOperation:", v18);
    }

    else
    {
      id v18 = (CKKSLocalResetOperation *)objc_claimAutoreleasedReturnValue( +[OctagonStateTransitionOperation named:entering:]( &OBJC_CLASS___OctagonStateTransitionOperation,  "named:entering:",  @"heal-tlk-shares",  @"heal_tlk_shares"));
    }
  }

  else
  {
    if ([v8 isEqualToString:@"tlkmissing"])
    {
      uint64_t v20 = objc_claimAutoreleasedReturnValue(-[CKKSKeychainView tlkMissingOperation:](self, "tlkMissingOperation:", @"check_zone_hierarchies"));
      goto LABEL_34;
    }

    if ([v8 isEqualToString:@"heal_tlk_shares"])
    {
      id v46 = objc_alloc(&OBJC_CLASS___CKKSHealTLKSharesOperation);
      __int128 v43 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
      id v47 = @"process_incoming_queue";
      __int128 v48 = @"healtlksharesfailed";
LABEL_46:
      id v18 = -[CKKSLocalResetOperation initWithDependencies:intendedState:errorState:]( v46,  "initWithDependencies:intendedState:errorState:",  v43,  v47,  v48);
      goto LABEL_42;
    }

    if ([v8 isEqualToString:@"needrefetch"])
    {
      id v142 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView zoneName](self, "zoneName"));
      unsigned int v143 = sub_1000AA6AC(@"ckkskey", v142);
      id v144 = (os_log_s *)objc_claimAutoreleasedReturnValue(v143);

      if (os_log_type_enabled(v144, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v144,  OS_LOG_TYPE_DEFAULT,  "Starting a key hierarchy full refetch",  buf,  2u);
      }

      -[CKKSKeychainView setKeyStateMachineRefetched:](self, "setKeyStateMachineRefetched:", 1LL);
      -[CKKSKeychainView setKeyStateFullRefetchRequested:](self, "setKeyStateFullRefetchRequested:", 0LL);
      uint64_t v20 = objc_claimAutoreleasedReturnValue( +[OctagonStateTransitionOperation named:entering:]( &OBJC_CLASS___OctagonStateTransitionOperation,  "named:entering:",  @"fetch-complete",  @"resetlocal"));
      goto LABEL_34;
    }

    if ([v8 isEqualToString:@"healtlksharesfailed"])
    {
      BOOL v150 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView zoneName](self, "zoneName"));
      int v151 = sub_1000AA6AC(@"ckkskey", v150);
      uint64_t v152 = (os_log_s *)objc_claimAutoreleasedReturnValue(v151);

      if (os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v152,  OS_LOG_TYPE_DEFAULT,  "Creating new TLK shares didn't work. Attempting to refetch!",  buf,  2u);
      }

      v153 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
      BOOL v154 = (void *)objc_claimAutoreleasedReturnValue([v153 currentFetchReasons]);
      [v154 addObject:@"conflict"];

      uint64_t v20 = objc_claimAutoreleasedReturnValue( +[OctagonStateTransitionOperation named:entering:]( &OBJC_CLASS___OctagonStateTransitionOperation,  "named:entering:",  @"heal-tlks-failed",  @"begin_fetch"));
      goto LABEL_34;
    }

    if ([v8 isEqualToString:@"unhealthy"])
    {
      unsigned int v156 = (id)-[CKKSKeychainView trustStatus](self, "trustStatus") == (id)1;
      v157 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView zoneName](self, "zoneName"));
      uint64_t v158 = sub_1000AA6AC(@"ckkskey", v157);
      id v159 = (os_log_s *)objc_claimAutoreleasedReturnValue(v158);

      v160 = os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT);
      if (!v156)
      {
        if (v160)
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v159,  OS_LOG_TYPE_DEFAULT,  "Looks like the key hierarchy is unhealthy, but we're untrusted.",  buf,  2u);
        }

        uint64_t v20 = objc_claimAutoreleasedReturnValue( +[OctagonStateTransitionOperation named:entering:]( &OBJC_CLASS___OctagonStateTransitionOperation,  "named:entering:",  @"unhealthy-lacking-trust",  @"lose_trust"));
        goto LABEL_34;
      }

      if (v160)
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v159,  OS_LOG_TYPE_DEFAULT,  "Looks like the key hierarchy is unhealthy. Launching fix.",  buf,  2u);
      }

      uint64_t v161 = objc_alloc(&OBJC_CLASS___CKKSHealKeyHierarchyOperation);
      v162 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
      id v18 = -[CKKSHealKeyHierarchyOperation initWithDependencies:allowFullRefetchResult:intending:errorState:]( v161,  "initWithDependencies:allowFullRefetchResult:intending:errorState:",  v162,  -[CKKSKeychainView keyStateMachineRefetched](self, "keyStateMachineRefetched") ^ 1,  @"check_zone_hierarchies",  @"error");
    }

    else
    {
      if (![v8 isEqualToString:@"process_incoming_queue"])
      {
        if ([v8 isEqualToString:@"class_a_incoming_items_remaining"])
        {
          uint64_t v20 = objc_claimAutoreleasedReturnValue( +[OctagonStateTransitionOperation named:entering:]( &OBJC_CLASS___OctagonStateTransitionOperation,  "named:entering:",  @"iqo-errored",  @"become_ready"));
          goto LABEL_34;
        }

        if ([v8 isEqualToString:@"scan_local_items"])
        {
          [v9 _onqueueRemoveFlag:@"dropped_items"];
          id v194 = objc_alloc(&OBJC_CLASS___CKKSScanLocalItemsOperation);
          id v195 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
          id v18 = -[CKKSScanLocalItemsOperation initWithDependencies:intending:errorState:ckoperationGroup:]( v194,  "initWithDependencies:intending:errorState:ckoperationGroup:",  v195,  @"become_ready",  @"error",  0LL);

          -[CKKSKeychainView setInitiatedLocalScan:](self, "setInitiatedLocalScan:", 1LL);
          goto LABEL_35;
        }

        if ([v8 isEqualToString:@"reencrypt_outgoing_items"])
        {
          id v196 = objc_alloc(&OBJC_CLASS___CKKSReencryptOutgoingItemsOperation);
          v197 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
          id v18 = -[CKKSReencryptOutgoingItemsOperation initWithDependencies:intendedState:errorState:holdOperation:]( v196,  "initWithDependencies:intendedState:errorState:holdOperation:",  v197,  @"become_ready",  @"error",  0LL);

          -[CKKSKeychainView setLastReencryptOutgoingItemsOperation:]( self,  "setLastReencryptOutgoingItemsOperation:",  v18);
          goto LABEL_35;
        }

        if ([v8 isEqualToString:@"process_outgoing_queue"])
        {
          [v9 _onqueueRemoveFlag:@"process_outgoing_queue"];
          id v209 = objc_alloc(&OBJC_CLASS___CKKSOutgoingQueueOperation);
          id v210 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
          id v18 = -[CKKSOutgoingQueueOperation initWithDependencies:intending:ckErrorState:errorState:]( v209,  "initWithDependencies:intending:ckErrorState:errorState:",  v210,  @"become_ready",  @"process_outgoing_queue_failed",  @"initialized");

          v211 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView holdOutgoingQueueOperation](self, "holdOutgoingQueueOperation"));
          -[CKKSLocalResetOperation addNullableDependency:](v18, "addNullableDependency:", v211);

          CFMutableStringRef v212 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView outgoingQueueOperations](self, "outgoingQueueOperations"));
          -[CKKSLocalResetOperation linearDependencies:](v18, "linearDependencies:", v212);

          -[CKKSKeychainView setLastOutgoingQueueOperation:](self, "setLastOutgoingQueueOperation:", v18);
          goto LABEL_35;
        }

        if ([v8 isEqualToString:@"process_outgoing_queue_failed"])
        {
          uint64_t v20 = objc_claimAutoreleasedReturnValue( +[OctagonStateTransitionOperation named:entering:]( &OBJC_CLASS___OctagonStateTransitionOperation,  "named:entering:",  @"oqo-failure",  @"become_ready"));
          goto LABEL_34;
        }

        goto LABEL_52;
      }

      [v9 _onqueueRemoveFlag:@"process_incoming_queue"];
      __int128 v182 = [v9 _onqueueContains:@"policy_fresh"];
      [v9 _onqueueRemoveFlag:@"policy_fresh"];
      if ((_DWORD)v182)
      {
        id v183 = sub_1000AA6AC(@"ckksincoming", 0LL);
        id v184 = (os_log_s *)objc_claimAutoreleasedReturnValue(v183);
        if (os_log_type_enabled(v184, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v184,  OS_LOG_TYPE_DEFAULT,  "Going to process the incoming queue with a fresh policy",  buf,  2u);
        }
      }

      id v185 = objc_alloc(&OBJC_CLASS___CKKSIncomingQueueOperation);
      id v186 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView operationDependencies](self, "operationDependencies"));
      id v18 = -[CKKSIncomingQueueOperation initWithDependencies:intending:pendingClassAItemsRemainingState:errorState:handleMismatchedViewItems:]( v185,  "initWithDependencies:intending:pendingClassAItemsRemainingState:errorState:handleMismatchedViewItems:",  v186,  @"become_ready",  @"class_a_incoming_items_remaining",  @"become_ready",  v182);

      id v187 = (void *)objc_claimAutoreleasedReturnValue( -[CKKSKeychainView resultsOfNextIncomingQueueOperationOperation]( self,  "resultsOfNextIncomingQueueOperationOperation"));
      if (v187)
      {
        id v188 = (void *)objc_claimAutoreleasedReturnValue( -[CKKSKeychainView resultsOfNextIncomingQueueOperationOperation]( self,  "resultsOfNextIncomingQueueOperationOperation"));
        [v188 addSuccessDependency:v18];

        id v189 = (void *)objc_claimAutoreleasedReturnValue( -[CKKSKeychainView resultsOfNextIncomingQueueOperationOperation]( self,  "resultsOfNextIncomingQueueOperationOperation"));
        -[CKKSKeychainView scheduleOperation:](self, "scheduleOperation:", v189);

        -[CKKSKeychainView setResultsOfNextIncomingQueueOperationOperation:]( self,  "setResultsOfNextIncomingQueueOperationOperation:",  0LL);
      }

      -[CKKSKeychainView setLastIncomingQueueOperation:](self, "setLastIncomingQueueOperation:", v18);
      id v190 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKeychainView holdIncomingQueueOperation](self, "holdIncomingQueueOperation"));
      -[CKKSLocalResetOperation addNullableDependency:](v18, "addNullableDependency:", v190);
    }
  }

void sub_10013E7D4(_Unwind_Exception *a1)
{
}

void sub_10013E93C(_Unwind_Exception *a1)
{
}

void sub_10013EA3C(_Unwind_Exception *a1)
{
}

void sub_10013F388(_Unwind_Exception *a1)
{
}

LABEL_100:
              _Block_object_dispose(buf, 8);
              id v51 = v34;
              goto LABEL_101;
            }

void sub_100140CB0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, char a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
}

void sub_100141C80( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id *location, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, id a23)
{
}

void sub_100142454( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, id location)
{
}

void sub_100142C04( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, id location)
{
}

void sub_100143F18( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void sub_100144130( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_100144294(_Unwind_Exception *a1)
{
}

void sub_100144588( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
}

void sub_1001452A8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, id location)
{
}

void sub_1001455C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10014582C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_100145954( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_1001460A8(_Unwind_Exception *a1)
{
}

void sub_100147408( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33)
{
}

void sub_100147880(_Unwind_Exception *a1)
{
}

void sub_100147CA4(_Unwind_Exception *a1)
{
}

void sub_1001480FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_100148880( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_100148F68(_Unwind_Exception *a1)
{
}

void sub_100149604( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

void sub_100149AC4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100149D94( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
}

void sub_10014B060(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = (id)objc_claimAutoreleasedReturnValue([a2 description]);
  [v2 addObject:v3];
}

void sub_10014B0A4(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = (id)objc_claimAutoreleasedReturnValue([a2 description]);
  [v2 addObject:v3];
}

void sub_10014B0E8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v3 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  id v4 = (void *)v3;
  if (!*(_BYTE *)(a1 + 56))
  {
    id v113 = (void *)v3;
    id v5 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained accountTracker]);
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 ckdeviceIDInitialized]);
    [v6 wait:1000000000];

    char v7 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained accountTracker]);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 ckdeviceID]);

    id v9 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained accountTracker]);
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 ckdeviceIDError]);

    __int128 v11 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](&OBJC_CLASS___CKKSAnalytics, "logger"));
    id v104 = (void *)objc_claimAutoreleasedReturnValue([v11 datePropertyForKey:@"lastCKKSPush"]);

    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationQueue]);
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v13 operations]);
    id v15 = [v14 copy];

    __int128 v120 = 0u;
    __int128 v121 = 0u;
    __int128 v118 = 0u;
    __int128 v119 = 0u;
    id v16 = v15;
    id v17 = [v16 countByEnumeratingWithState:&v118 objects:v124 count:16];
    if (v17)
    {
      id v18 = v17;
      uint64_t v19 = *(void *)v119;
      do
      {
        for (CFIndex i = 0LL; i != v18; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v119 != v19) {
            objc_enumerationMutation(v16);
          }
          uint32_t v21 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v118 + 1) + 8 * (void)i) description]);
          [v12 addObject:v21];
        }

        id v18 = [v16 countByEnumeratingWithState:&v118 objects:v124 count:16];
      }

      while (v18);
    }

    v123[0] = @"global";
    v122[0] = @"view";
    v122[1] = @"reachability";
    id v112 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained reachabilityTracker]);
    unsigned int v22 = [v112 currentReachability];
    id v23 = @"no-network";
    if (v22) {
      id v23 = @"network";
    }
    v123[1] = v23;
    v122[2] = @"activeAccount";
    unsigned int v24 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
    id v25 = (void *)objc_claimAutoreleasedReturnValue([v24 activeAccount]);
    __int128 v26 = (void *)objc_claimAutoreleasedReturnValue([v25 description]);

    if (v26) {
      id v27 = v26;
    }
    else {
      id v27 = (id)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    }
    id v28 = v27;

    v123[2] = v28;
    v122[3] = @"ckdeviceID";
    id v29 = v8;
    __int128 v30 = v29;
    if (v29) {
      id v31 = v29;
    }
    else {
      id v31 = (id)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    }
    id v32 = v31;

    v123[3] = v32;
    v122[4] = @"ckdeviceIDError";
    id v33 = v10;
    __int128 v34 = v33;
    uint64_t v111 = v30;
    if (v33) {
      id v35 = v33;
    }
    else {
      id v35 = (id)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    }
    id v36 = v35;
    unsigned int v109 = v34;

    int64_t v107 = v36;
    v123[4] = v36;
    v122[5] = @"lockstatetracker";
    char v37 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained lockStateTracker]);
    __int16 v38 = (void *)objc_claimAutoreleasedReturnValue([v37 description]);

    uint64_t v108 = v32;
    if (v38) {
      id v39 = v38;
    }
    else {
      id v39 = (id)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    }
    id v40 = v39;

    v106 = v40;
    v123[5] = v40;
    v122[6] = @"cloudkitRetryAfter";
    id v41 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
    uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v41 cloudkitRetryAfter]);
    __int128 v43 = (void *)objc_claimAutoreleasedReturnValue([v42 description]);

    if (v43) {
      id v44 = v43;
    }
    else {
      id v44 = (id)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    }
    id v45 = v44;

    v123[6] = v45;
    v122[7] = @"lastCKKSPush";
    id v46 = v104;
    id v47 = v46;
    uint64_t v110 = v28;
    if (v46) {
      id v48 = v46;
    }
    else {
      id v48 = (id)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    }
    id v49 = v48;
    id v105 = v47;

    id v102 = v49;
    v123[7] = v49;
    v122[8] = @"policy";
    __int128 v50 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained syncingPolicy]);
    id v51 = (void *)objc_claimAutoreleasedReturnValue([v50 description]);

    if (v51) {
      id v52 = v51;
    }
    else {
      id v52 = (id)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    }
    id v53 = v52;

    v123[8] = v53;
    v123[9] = @"yes";
    v122[9] = @"viewsFromPolicy";
    v122[10] = @"ckaccountstatus";
    uint64_t v101 = v53;
    if ([WeakRetained accountStatus])
    {
      if ([WeakRetained accountStatus] == (id)1)
      {
        id v54 = @"logged in";
      }

      else if ([WeakRetained accountStatus] == (id)2)
      {
        id v54 = @"restricted";
      }

      else
      {
        id v55 = [WeakRetained accountStatus];
        id v54 = @"unknown";
        if (v55 == (id)3) {
          id v54 = @"logged out";
        }
      }
    }

    else
    {
      id v54 = @"could not determine";
    }

    v123[10] = v54;
    v122[11] = @"accounttracker";
    uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained accountTracker]);
    id v57 = (void *)objc_claimAutoreleasedReturnValue([v56 description]);

    if (v57) {
      id v58 = v57;
    }
    else {
      id v58 = (id)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    }
    id v59 = v58;

    uint64_t v100 = v59;
    v123[11] = v59;
    v122[12] = @"fetcher";
    id v60 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained zoneChangeFetcher]);
    __int128 v61 = (void *)objc_claimAutoreleasedReturnValue([v60 description]);

    if (v61) {
      id v62 = v61;
    }
    else {
      id v62 = (id)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    }
    id v63 = v62;

    uint64_t v99 = v63;
    v123[12] = v63;
    v122[13] = @"ckksstate";
    id v64 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained stateMachine]);
    __int128 v65 = (void *)objc_claimAutoreleasedReturnValue([v64 currentState]);

    if (v65) {
      id v66 = v65;
    }
    else {
      id v66 = (id)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    }
    id v67 = v66;

    v98 = v67;
    v123[13] = v67;
    v122[14] = @"lastIncomingQueueOperation";
    uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained lastIncomingQueueOperation]);
    __int16 v69 = (void *)objc_claimAutoreleasedReturnValue([v68 description]);

    if (v69) {
      id v70 = v69;
    }
    else {
      id v70 = (id)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    }
    id v71 = v70;

    id v97 = v71;
    v123[14] = v71;
    v122[15] = @"lastNewTLKOperation";
    id v72 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained lastNewTLKOperation]);
    id v73 = (void *)objc_claimAutoreleasedReturnValue([v72 description]);

    if (v73) {
      id v74 = v73;
    }
    else {
      id v74 = (id)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    }
    id v75 = v74;

    v96 = v75;
    v123[15] = v75;
    v122[16] = @"lastOutgoingQueueOperation";
    id v76 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained lastOutgoingQueueOperation]);
    char v77 = (void *)objc_claimAutoreleasedReturnValue([v76 description]);

    if (v77) {
      id v78 = v77;
    }
    else {
      id v78 = (id)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    }
    int v79 = v78;

    v123[16] = v79;
    v122[17] = @"lastProcessReceivedKeysOperation";
    int64_t v80 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained lastProcessReceivedKeysOperation]);
    unsigned int v81 = (void *)objc_claimAutoreleasedReturnValue([v80 description]);

    id v103 = v45;
    if (v81) {
      id v82 = v81;
    }
    else {
      id v82 = (id)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    }
    id v83 = v82;

    v123[17] = v83;
    v122[18] = @"lastReencryptOutgoingItemsOperation";
    id v84 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained lastReencryptOutgoingItemsOperation]);
    uint64_t v85 = (void *)objc_claimAutoreleasedReturnValue([v84 description]);

    if (v85) {
      id v86 = v85;
    }
    else {
      id v86 = (id)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    }
    v87 = v86;

    v123[18] = v87;
    v122[19] = @"launchSequence";
    v88 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
    int v89 = (void *)objc_claimAutoreleasedReturnValue([v88 overallLaunch]);
    int v90 = (void *)objc_claimAutoreleasedReturnValue([v89 eventsByTime]);

    if (v90) {
      id v91 = v90;
    }
    else {
      id v91 = (id)objc_claimAutoreleasedReturnValue(+[NSNull null](&OBJC_CLASS___NSNull, "null"));
    }
    v92 = v91;

    v122[20] = @"operationQueue";
    v123[19] = v92;
    v123[20] = v12;
    unsigned __int8 v93 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v123,  v122,  21LL));

    id v4 = v113;
    [v113 addObject:v93];
  }

  v114[0] = _NSConcreteStackBlock;
  v114[1] = 3221225472LL;
  v114[2] = sub_10014BAA4;
  v114[3] = &unk_1002908B8;
  v114[4] = WeakRetained;
  id v94 = *(id *)(a1 + 32);
  char v117 = *(_BYTE *)(a1 + 56);
  id v115 = v94;
  id v116 = v4;
  id v95 = v4;
  [WeakRetained dispatchSyncWithReadOnlySQLTransaction:v114];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
}

void sub_10014BAA4(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v44 = 0u;
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 allViews]);

  id v5 = [v4 countByEnumeratingWithState:&v41 objects:v49 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v42;
    do
    {
      for (CFIndex i = 0LL; i != v6; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v42 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void *)(*((void *)&v41 + 1) + 8LL * (void)i);
        uint64_t v10 = *(void **)(a1 + 40);
        if (v10)
        {
          __int128 v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v41 + 1) + 8 * (void)i) zoneName]);
          unsigned int v12 = [v10 isEqualToString:v11];

          if (!v12) {
            continue;
          }
        }

        [v2 addObject:v9];
      }

      id v6 = [v4 countByEnumeratingWithState:&v41 objects:v49 count:16];
    }

    while (v6);
  }

  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSSortDescriptor sortDescriptorWithKey:ascending:]( &OBJC_CLASS___NSSortDescriptor,  "sortDescriptorWithKey:ascending:",  @"zoneName",  1LL));
  id v48 = v13;
  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v48, 1LL));
  __int128 v34 = v2;
  id v15 = (void *)objc_claimAutoreleasedReturnValue([v2 sortedArrayUsingDescriptors:v14]);

  __int128 v39 = 0u;
  __int128 v40 = 0u;
  __int128 v37 = 0u;
  __int128 v38 = 0u;
  id obj = v15;
  id v16 = [obj countByEnumeratingWithState:&v37 objects:v47 count:16];
  if (v16)
  {
    id v17 = v16;
    uint64_t v36 = *(void *)v38;
    do
    {
      for (j = 0LL; j != v17; j = (char *)j + 1)
      {
        if (*(void *)v38 != v36) {
          objc_enumerationMutation(obj);
        }
        uint64_t v19 = *(void **)(*((void *)&v37 + 1) + 8LL * (void)j);
        uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v19 zoneID]);
        uint32_t v21 = (void *)objc_claimAutoreleasedReturnValue([v20 zoneName]);
        id v22 = sub_1000AA6AC(@"ckks", v21);
        id v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);

        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          id v46 = v19;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Building status for %@", buf, 0xCu);
        }

        unsigned int v24 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
        id v25 = (void *)objc_claimAutoreleasedReturnValue([v24 contextID]);
        __int128 v26 = (void *)objc_claimAutoreleasedReturnValue([v19 zoneName]);
        id v27 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSZoneStateEntry contextID:zoneName:]( &OBJC_CLASS___CKKSZoneStateEntry,  "contextID:zoneName:",  v25,  v26));

        id v28 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) fastStatus:v19 zoneStateEntry:v27]);
        if (!*(_BYTE *)(a1 + 56))
        {
          id v29 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) intransactionSlowStatus:v19]);
          id v30 = [v28 mutableCopy];
          [v30 addEntriesFromDictionary:v29];

          id v28 = v30;
        }

        id v31 = (void *)objc_claimAutoreleasedReturnValue([v19 zoneName]);
        id v32 = sub_1000AA6AC(@"ckks", v31);
        id v33 = (os_log_s *)objc_claimAutoreleasedReturnValue(v32);

        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)__int128 buf = 138412290;
          id v46 = v28;
          _os_log_debug_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEBUG, "Status is %@", buf, 0xCu);
        }

        if (v28) {
          [*(id *)(a1 + 48) addObject:v28];
        }
      }

      id v17 = [obj countByEnumeratingWithState:&v37 objects:v47 count:16];
    }

    while (v17);
  }
}

uint64_t sub_10014BED0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10014BEE0(uint64_t a1)
{
}

void sub_10014BEE8(uint64_t a1)
{
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v2 allViews]);

  uint64_t v4 = a1;
  id v5 = [v3 countByEnumeratingWithState:&v38 objects:v44 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v39;
    p_superclass = &OBJC_CLASS___CKKSProcessReceivedKeysOperation.superclass;
    uint64_t v34 = *(void *)v39;
    id v35 = v3;
    do
    {
      uint64_t v9 = 0LL;
      id v36 = v6;
      do
      {
        if (*(void *)v39 != v7) {
          objc_enumerationMutation(v3);
        }
        uint64_t v10 = *(void **)(*((void *)&v38 + 1) + 8LL * (void)v9);
        __int128 v11 = (void *)objc_claimAutoreleasedReturnValue([v10 zoneID]);
        unsigned int v12 = (void *)objc_claimAutoreleasedReturnValue([v10 contextID]);
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([p_superclass + 44 loadForZone:v11 contextID:v12]);

        uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v13 error]);
        if (v14)
        {
          id v15 = (void *)objc_claimAutoreleasedReturnValue([v10 zoneID]);
          id v16 = (void *)objc_claimAutoreleasedReturnValue([v15 zoneName]);
          id v17 = sub_1000AA6AC(@"ckks", v16);
          id v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);

          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v13 error]);
            *(_DWORD *)__int128 buf = 138412290;
            __int128 v43 = v19;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "error loading keyset: %@", buf, 0xCu);
          }

          uint64_t v20 = objc_claimAutoreleasedReturnValue([v13 error]);
          uint64_t v21 = *(void *)(*(void *)(v4 + 48) + 8LL);
          id v22 = *(void **)(v21 + 40);
          *(void *)(v21 + 40) = v20;
        }

        else
        {
          id v23 = (void *)objc_claimAutoreleasedReturnValue([v13 currentTLKPointer]);
          unsigned int v24 = (void *)objc_claimAutoreleasedReturnValue([v23 currentKeyUUID]);

          if (!v24) {
            goto LABEL_17;
          }
          uint64_t v25 = *(void *)(v4 + 40);
          __int128 v26 = (void *)objc_claimAutoreleasedReturnValue([v10 contextID]);
          id v27 = (void *)objc_claimAutoreleasedReturnValue([v13 currentTLKPointer]);
          id v28 = (void *)objc_claimAutoreleasedReturnValue([v27 currentKeyUUID]);
          id v29 = (void *)objc_claimAutoreleasedReturnValue([v10 zoneID]);
          uint64_t v30 = v4;
          uint64_t v31 = *(void *)(*(void *)(v4 + 48) + 8LL);
          id obj = *(id *)(v31 + 40);
          id v22 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSTLKShareRecord allFor:contextID:keyUUID:zoneID:error:]( &OBJC_CLASS___CKKSTLKShareRecord,  "allFor:contextID:keyUUID:zoneID:error:",  v25,  v26,  v28,  v29,  &obj));
          objc_storeStrong((id *)(v31 + 40), obj);

          if (v22)
          {
            uint64_t v4 = v30;
            if (!*(void *)(*(void *)(*(void *)(v30 + 48) + 8LL) + 40LL))
            {
              id v32 = *(void **)(*(void *)(*(void *)(v30 + 56) + 8LL) + 40LL);
              id v33 = (void *)objc_claimAutoreleasedReturnValue([v10 zoneName]);
              [v32 addObject:v33];

              uint64_t v4 = v30;
            }
          }

          else
          {
            uint64_t v4 = v30;
          }

          uint64_t v7 = v34;
          uint64_t v3 = v35;
          p_superclass = (__objc2_class **)(&OBJC_CLASS___CKKSProcessReceivedKeysOperation + 8);
          id v6 = v36;
        }

LABEL_17:
        uint64_t v9 = (char *)v9 + 1;
      }

      while (v6 != v9);
      id v6 = [v3 countByEnumeratingWithState:&v38 objects:v44 count:16];
    }

    while (v6);
  }
}

void sub_10014C254(uint64_t a1)
{
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "operationDependencies", 0));
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v2 allCKKSManagedViews]);

  id v4 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v13;
    while (2)
    {
      for (CFIndex i = 0LL; i != v5; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v13 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(void **)(*((void *)&v12 + 1) + 8LL * (void)i);
        uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 zoneID]);
        uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 zoneName]);
        unsigned int v11 = [v10 isEqualToString:*(void *)(a1 + 40)];

        if (v11)
        {
          objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL), v8);
          goto LABEL_11;
        }
      }

      id v5 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }

id sub_10014C3B0(uint64_t a1)
{
  return [*(id *)(a1 + 32) setHalted:1];
}

void sub_10014C3BC(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSSQLDatabaseObject all:](&OBJC_CLASS___CKKSOutgoingQueueEntry, "all:", *(void *)(a1 + 40)));
  if (v2)
  {
    id v5 = v2;
    BOOL v3 = [v2 count] == 0;
    uint64_t v2 = v5;
    char v4 = v3;
  }

  else
  {
    char v4 = 0;
  }

  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = v4;
}

uint64_t sub_10014C420(uint64_t a1)
{
  uint64_t v1 = a1;
  if (([*(id *)(a1 + 32) _onQueueZoneIsReadyForFetching:*(void *)(a1 + 40)] & 1) == 0)
  {
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 40) zoneName]);
    id v7 = sub_1000AA6AC(@"ckksfetch", v6);
    char v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);

    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      id v5 = "Zone is inactive; cancelling fetch";
      goto LABEL_7;
    }

LABEL_107:
      goto LABEL_108;
    }

LABEL_71:
    id v84 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) zoneName]);
    id v85 = sub_1000AA6AC(@"ckksfetch", v84);
    id v86 = (os_log_s *)objc_claimAutoreleasedReturnValue(v85);

    if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
    {
      v87 = *(os_log_s **)(v1 + 40);
      *(_DWORD *)__int128 buf = 138412290;
      v174 = v87;
      _os_log_impl( (void *)&_mh_execute_header,  v86,  OS_LOG_TYPE_DEFAULT,  "Requesting incoming processing for %@",  buf,  0xCu);
    }

    __int128 v152 = 0u;
    __int128 v153 = 0u;
    __int128 v150 = 0u;
    __int128 v151 = 0u;
    v88 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) operationDependencies]);
    int v89 = (os_log_s *)objc_claimAutoreleasedReturnValue([v88 readyAndSyncingViews]);

    obja = v89;
    id v139 = -[os_log_s countByEnumeratingWithState:objects:count:]( v89,  "countByEnumeratingWithState:objects:count:",  &v150,  v184,  16LL);
    if (v139)
    {
      BOOL v133 = v4;
      uint64_t v137 = *(void *)v151;
      do
      {
        for (m = 0LL; m != v139; m = (char *)m + 1)
        {
          if (*(void *)v151 != v137) {
            objc_enumerationMutation(obja);
          }
          id v91 = *(void **)(*((void *)&v150 + 1) + 8LL * (void)m);
          v92 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v141 + 32) operationDependencies]);
          unsigned __int8 v93 = (void *)objc_claimAutoreleasedReturnValue([v92 contextID]);
          id v94 = (void *)objc_claimAutoreleasedReturnValue([v91 zoneID]);
          id v95 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSIncomingQueueEntry countNewEntriesByKeyWithContextID:zoneID:error:]( &OBJC_CLASS___CKKSIncomingQueueEntry,  "countNewEntriesByKeyWithContextID:zoneID:error:",  v93,  v94,  0LL));

          __int128 v148 = 0u;
          __int128 v149 = 0u;
          __int128 v146 = 0u;
          __int128 v147 = 0u;
          id v144 = v95;
          id v96 = [v144 countByEnumeratingWithState:&v146 objects:v183 count:16];
          if (v96)
          {
            id v97 = v96;
            v140 = m;
            uint64_t v98 = *(void *)v147;
            while (2)
            {
              for (n = 0LL; n != v97; n = (char *)n + 1)
              {
                if (*(void *)v147 != v98) {
                  objc_enumerationMutation(v144);
                }
                uint64_t v100 = *(os_log_s **)(*((void *)&v146 + 1) + 8LL * (void)n);
                uint64_t v101 = (void *)objc_claimAutoreleasedReturnValue([v91 contextID]);
                id v102 = (void *)objc_claimAutoreleasedReturnValue([v91 zoneID]);
                id v145 = 0LL;
                id v103 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSKey fromDatabase:contextID:zoneID:error:]( &OBJC_CLASS___CKKSKey,  "fromDatabase:contextID:zoneID:error:",  v100,  v101,  v102,  &v145));
                id v104 = v145;

                if (v103) {
                  BOOL v105 = v104 == 0LL;
                }
                else {
                  BOOL v105 = 0;
                }
                if (v105)
                {
                  uint64_t v110 = (void *)objc_claimAutoreleasedReturnValue([v103 keyclass]);
                  unsigned int v111 = [v110 isEqualToString:@"classC"];

                  if (v111)
                  {

                    int v112 = 1;
                    goto LABEL_95;
                  }
                }

                else
                {
                  v106 = (void *)objc_claimAutoreleasedReturnValue([v91 zoneID]);
                  int64_t v107 = (void *)objc_claimAutoreleasedReturnValue([v106 zoneName]);
                  id v108 = sub_1000AA6AC(@"ckksfetch", v107);
                  unsigned int v109 = (os_log_s *)objc_claimAutoreleasedReturnValue(v108);

                  if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)__int128 buf = 138412546;
                    v174 = v100;
                    __int16 v175 = 2112;
                    id v176 = v104;
                    _os_log_impl( (void *)&_mh_execute_header,  v109,  OS_LOG_TYPE_ERROR,  "Unable to load key for %@: %@",  buf,  0x16u);
                  }
                }
              }

              id v97 = [v144 countByEnumeratingWithState:&v146 objects:v183 count:16];
              if (v97) {
                continue;
              }
              break;
            }

            int v112 = 0;
LABEL_95:
            m = v140;
          }

          else
          {
            int v112 = 0;
          }

          id v113 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v141 + 32) lockStateTracker]);
          unsigned int v114 = [v113 isLocked];

          if (v114)
          {
            if (v112)
            {
              uint64_t v1 = v141;
              id v115 = (OctagonPendingFlag *)objc_claimAutoreleasedReturnValue([*(id *)(v141 + 32) stateMachine]);
              -[OctagonPendingFlag _onqueueHandleFlag:](v115, "_onqueueHandleFlag:", @"process_incoming_queue");
            }

            else
            {
              id v116 = (void *)objc_claimAutoreleasedReturnValue([v91 zoneID]);
              char v117 = (void *)objc_claimAutoreleasedReturnValue([v116 zoneName]);
              id v118 = sub_1000AA6AC(@"ckksfetch", v117);
              __int128 v119 = (os_log_s *)objc_claimAutoreleasedReturnValue(v118);

              if (os_log_type_enabled(v119, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)__int128 buf = 0;
                _os_log_impl( (void *)&_mh_execute_header,  v119,  OS_LOG_TYPE_DEFAULT,  "Have incoming classA items needing processing, but device is locked",  buf,  2u);
              }

              id v115 = -[OctagonPendingFlag initWithFlag:conditions:]( objc_alloc(&OBJC_CLASS___OctagonPendingFlag),  "initWithFlag:conditions:",  @"process_incoming_queue",  1LL);
              uint64_t v1 = v141;
              __int128 v120 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v141 + 32) stateMachine]);
              [v120 _onqueueHandlePendingFlagLater:v115];
            }
          }

          else
          {
            id v115 = (OctagonPendingFlag *)objc_claimAutoreleasedReturnValue([*(id *)(v141 + 32) stateMachine]);
            -[OctagonPendingFlag _onqueueHandleFlag:](v115, "_onqueueHandleFlag:", @"process_incoming_queue");
            uint64_t v1 = v141;
          }
        }

        id v139 = -[os_log_s countByEnumeratingWithState:objects:count:]( obja,  "countByEnumeratingWithState:objects:count:",  &v150,  v184,  16LL);
      }

      while (v139);
      char v4 = v133;
    }

    goto LABEL_107;
  }

  if (!*(_BYTE *)(v1 + 73)) {
    goto LABEL_71;
  }
LABEL_108:
  __int128 v121 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 40) zoneName]);
  id v122 = sub_1000AA6AC(@"ckksfetch", v121);
  id v123 = (os_log_s *)objc_claimAutoreleasedReturnValue(v122);

  if (os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT))
  {
    id v124 = (os_log_s *)[*(id *)(v1 + 48) count];
    id v125 = [*(id *)(v1 + 56) count];
    uint64_t v126 = *(unsigned __int8 *)(v1 + 73);
    int v127 = *(unsigned __int8 *)(v1 + 72);
    uint64_t v128 = *(void *)(v1 + 64);
    *(_DWORD *)__int128 buf = 134219010;
    v174 = v124;
    __int16 v175 = 2048;
    id v176 = v125;
    __int16 v177 = 2048;
    uint64_t v178 = v126;
    __int16 v179 = 1024;
    int v180 = v127;
    __int16 v181 = 2112;
    uint64_t v182 = v128;
    _os_log_impl( (void *)&_mh_execute_header,  v123,  OS_LOG_TYPE_DEFAULT,  "Finished processing changes: changed=%lu deleted=%lu moreComing=%lu resync=%u changeToken=%@",  buf,  0x30u);
  }

  uint64_t v8 = 1LL;
LABEL_111:

  return v8;
}

void sub_10014D428(uint64_t a1)
{
  if ([*(id *)(a1 + 32) _onQueueZoneIsReadyForFetching:*(void *)(a1 + 40)])
  {
    [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setParticipateInFetch:1];
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
    id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 contextID]);
    char v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneName]);
    id v5 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSZoneStateEntry contextID:zoneName:]( &OBJC_CLASS___CKKSZoneStateEntry,  "contextID:zoneName:",  v3,  v4));

    if (v5)
    {
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 getChangeToken]);
      [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setChangeToken:v6];
    }

    else
    {
      id v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneName]);
      id v11 = sub_1000AA6AC(@"ckksfetch", v10);
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);

      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        __int128 v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneName]);
        int v14 = 138412290;
        __int128 v15 = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_ERROR,  "couldn't fetch zone change token for %@",  (uint8_t *)&v14,  0xCu);
      }

      id v5 = 0LL;
    }
  }

  else
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneName]);
    id v8 = sub_1000AA6AC(@"ckksfetch", v7);
    id v5 = (void *)objc_claimAutoreleasedReturnValue(v8);

    if (os_log_type_enabled((os_log_t)v5, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = *(void **)(a1 + 40);
      int v14 = 138412290;
      __int128 v15 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)v5,  OS_LOG_TYPE_DEFAULT,  "skipping fetch for %@; zone is not ready",
        (uint8_t *)&v14,
        0xCu);
    }
  }
}

id sub_10014D63C(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) _onQueueZoneIsReadyForFetching:*(void *)(a1 + 40)];
  *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = (_BYTE)result;
  return result;
}

void sub_10014D670(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained cloudKitClassDependencies]);
  id v3 = [v2 notifierClass];
  char v4 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"com.apple.security.view-change.%@",  *(void *)(a1 + 32)));
  [v3 post:v4];

  id v5 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained cloudKitClassDependencies]);
  id v6 = [v5 notifierClass];
  id v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "com.apple.security.keychainchanged"));
  [v6 post:v7];

  if (([*(id *)(a1 + 32) isEqualToString:@"Manatee"] & 1) != 0
    || ([*(id *)(a1 + 32) isEqualToString:@"Engram"] & 1) != 0
    || ([*(id *)(a1 + 32) isEqualToString:@"ApplePay"] & 1) != 0
    || ([*(id *)(a1 + 32) isEqualToString:@"Home"] & 1) != 0
    || [*(id *)(a1 + 32) isEqualToString:@"LimitedPeersAllowed"])
  {
    id v8 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained cloudKitClassDependencies]);
    objc_msgSend(objc_msgSend(v8, "notifierClass"), "post:", @"com.apple.security.view-change.PCS");
  }
}

void sub_10014D7CC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v3 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained cloudKitClassDependencies]);
  char v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(objc_msgSend(v3, "nsdistributednotificationCenterClass"), "defaultCenter"));

  id v5 = @"unknown";
  if (*(void *)(a1 + 32)) {
    id v5 = *(const __CFString **)(a1 + 32);
  }
  id v10 = @"view";
  id v11 = v5;
  id v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v11,  &v10,  1LL));
  [v4 postNotificationName:@"com.apple.security.view-become-ready" object:0 userInfo:v6 options:0];

  id v7 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained cloudKitClassDependencies]);
  id v8 = [v7 notifierClass];
  id v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"com.apple.security.view-ready.%@",  *(void *)(a1 + 32)));
  [v8 post:v9];
}

void sub_10014D910(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  id v94 = (void *)objc_claimAutoreleasedReturnValue([v2 syncingPolicy]);

  id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) operationDependencies]);
  char v4 = (void *)objc_claimAutoreleasedReturnValue([v3 allViews]);
  id v5 = [v4 mutableCopy];

  v92 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  __int128 v112 = 0u;
  __int128 v113 = 0u;
  __int128 v114 = 0u;
  __int128 v115 = 0u;
  id obj = v5;
  id v6 = [obj countByEnumeratingWithState:&v112 objects:v127 count:16];
  uint64_t v99 = v1;
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v113;
    do
    {
      for (CFIndex i = 0LL; i != v7; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v113 != v8) {
          objc_enumerationMutation(obj);
        }
        id v10 = *(void **)(*((void *)&v112 + 1) + 8LL * (void)i);
        id v11 = *(void **)(v1 + 40);
        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v10 zoneID]);
        __int128 v13 = (void *)objc_claimAutoreleasedReturnValue([v12 zoneName]);
        LODWORD(v11) = [v11 containsObject:v13];

        if ((_DWORD)v11)
        {
          int v14 = (void *)objc_claimAutoreleasedReturnValue([v10 zoneID]);
          __int128 v15 = (void *)objc_claimAutoreleasedReturnValue([v14 zoneName]);
          unsigned int v16 = [v94 isSyncingEnabledForView:v15];

          id v17 = *(void **)(v1 + 48);
          id v18 = (void *)objc_claimAutoreleasedReturnValue([v10 zoneID]);
          uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v18 zoneName]);
          unsigned int v20 = [v17 isSyncingEnabledForView:v19];

          uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v10 zoneID]);
          id v22 = (void *)objc_claimAutoreleasedReturnValue([v21 zoneName]);
          id v23 = sub_1000AA6AC(@"ckks", v22);
          unsigned int v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);

          uint64_t v1 = v99;
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v10 zoneID]);
            uint64_t v26 = objc_claimAutoreleasedReturnValue([v25 zoneName]);
            id v27 = (void *)v26;
            uint64_t v28 = *(void *)(v99 + 48);
            id v29 = @"paused";
            if (v20) {
              uint64_t v30 = @"enabled";
            }
            else {
              uint64_t v30 = @"paused";
            }
            *(_DWORD *)__int128 buf = 138413058;
            if (v16) {
              id v29 = @"enabled";
            }
            uint64_t v120 = v26;
            __int16 v121 = 2112;
            id v122 = v30;
            __int16 v123 = 2112;
            id v124 = v29;
            __int16 v125 = 2112;
            uint64_t v126 = v28;
            _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Syncing for %@ is now %@ (used to be %@) (policy: %@)",  buf,  0x2Au);
          }
        }

        else
        {
          uint64_t v31 = *(void **)(v1 + 56);
          id v32 = (void *)objc_claimAutoreleasedReturnValue([v10 zoneID]);
          id v33 = (void *)objc_claimAutoreleasedReturnValue([v32 zoneName]);
          LOBYTE(v31) = [v31 containsObject:v33];

          if ((v31 & 1) == 0)
          {
            id v34 = sub_1000AA6AC(@"ckks-policy", 0LL);
            id v35 = (os_log_s *)objc_claimAutoreleasedReturnValue(v34);
            if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
            {
              int v36 = (void *)objc_claimAutoreleasedReturnValue([v10 zoneID]);
              __int128 v37 = (void *)objc_claimAutoreleasedReturnValue([v36 zoneName]);
              *(_DWORD *)__int128 buf = 138412290;
              uint64_t v120 = (uint64_t)v37;
              _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Stopping old view %@", buf, 0xCu);
            }

            [v92 addObject:v10];
            *(_BYTE *)(*(void *)(*(void *)(v1 + 64) + 8LL) + 24LL) = 1;
          }
        }
      }

      id v7 = [obj countByEnumeratingWithState:&v112 objects:v127 count:16];
    }

    while (v7);
  }

  id v38 = obj;

  [obj minusSet:v92];
  __int128 v39 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 40) setByAddingObjectsFromSet:*(void *)(v1 + 56)]);
  __int128 v108 = 0u;
  __int128 v109 = 0u;
  __int128 v110 = 0u;
  __int128 v111 = 0u;
  id v95 = v39;
  id v97 = [v39 countByEnumeratingWithState:&v108 objects:v118 count:16];
  if (!v97)
  {
    unsigned int v81 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) operationDependencies]);
    [v81 applyNewSyncingPolicy:*(void *)(v1 + 48) viewStates:obj];

    id v78 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) stateMachine]);
    int v79 = v78;
    int64_t v80 = @"check_queues";
    goto LABEL_61;
  }

  char v93 = 0;
  uint64_t v96 = *(void *)v109;
  do
  {
    for (j = 0LL; j != v97; j = (char *)j + 1)
    {
      if (*(void *)v109 != v96) {
        objc_enumerationMutation(v95);
      }
      uint64_t v41 = *(void *)(*((void *)&v108 + 1) + 8LL * (void)j);
      __int128 v104 = 0u;
      __int128 v105 = 0u;
      __int128 v106 = 0u;
      __int128 v107 = 0u;
      id v42 = v38;
      id v43 = [v42 countByEnumeratingWithState:&v104 objects:v117 count:16];
      if (v43)
      {
        id v44 = v43;
        uint64_t v45 = *(void *)v105;
LABEL_28:
        uint64_t v46 = 0LL;
        while (1)
        {
          if (*(void *)v105 != v45) {
            objc_enumerationMutation(v42);
          }
          id v47 = *(void **)(*((void *)&v104 + 1) + 8 * v46);
          id v48 = (void *)objc_claimAutoreleasedReturnValue([v47 zoneID]);
          id v49 = (void *)objc_claimAutoreleasedReturnValue([v48 zoneName]);
          unsigned __int8 v50 = [v49 isEqualToString:v41];

          if ((v50 & 1) != 0) {
            break;
          }
          if (v44 == (id)++v46)
          {
            id v44 = [v42 countByEnumeratingWithState:&v104 objects:v117 count:16];
            if (v44) {
              goto LABEL_28;
            }
            goto LABEL_34;
          }
        }

        id v51 = v47;

        if (!v51) {
          goto LABEL_37;
        }
        id v38 = obj;
        uint64_t v1 = v99;
      }

      else
      {
LABEL_34:

LABEL_37:
        id v52 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v99 + 32) operationDependencies]);
        id v53 = (void *)objc_claimAutoreleasedReturnValue([v52 contextID]);
        id v54 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSZoneStateEntry contextID:zoneName:]( &OBJC_CLASS___CKKSZoneStateEntry,  "contextID:zoneName:",  v53,  v41));

        id v55 = [*(id *)(v99 + 40) containsObject:v41];
        uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue([v54 getChangeToken]);

        id v57 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v99 + 48) priorityViews]);
        id v58 = [v57 containsObject:v41];

        id v59 = *(void **)(v99 + 32);
        id v60 = (void *)objc_claimAutoreleasedReturnValue([v54 contextID]);
        id v51 = (__CFString *)objc_claimAutoreleasedReturnValue( [v59 createViewState:v41 contextID:v60 zoneIsNew:v56 == 0 priorityView:v58 ckksManagedView:v55]);

        [v42 addObject:v51];
        uint64_t v61 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString zoneID](v51, "zoneID"));
        id v62 = (void *)objc_claimAutoreleasedReturnValue([v61 zoneName]);
        id v63 = sub_1000AA6AC(@"ckks", v62);
        id v64 = (os_log_s *)objc_claimAutoreleasedReturnValue(v63);

        if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
        {
          __int128 v65 = @"normal";
          if ((_DWORD)v58) {
            __int128 v65 = @"priority";
          }
          *(_DWORD *)__int128 buf = 138412802;
          uint64_t v120 = (uint64_t)v65;
          id v66 = @"externally-managed";
          if ((_DWORD)v55) {
            id v66 = @"CKKS";
          }
          __int16 v121 = 2112;
          id v122 = v66;
          __int16 v123 = 2112;
          id v124 = v51;
          _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "Created %@ %@ view %@", buf, 0x20u);
        }

        if (v56) {
          int v67 = 0;
        }
        else {
          int v67 = (int)v58;
        }
        id v38 = obj;
        uint64_t v1 = v99;
        if (v67 == 1)
        {
          uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString zoneID](v51, "zoneID"));
          id v69 = (void *)objc_claimAutoreleasedReturnValue([v68 zoneName]);
          id v70 = sub_1000AA6AC(@"ckks", v69);
          id v71 = (os_log_s *)objc_claimAutoreleasedReturnValue(v70);

          if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_DEFAULT,  "Initializing a priority view for the first time",  buf,  2u);
          }

          char v93 = 1;
        }

        if ((_DWORD)v58 && [v54 moreRecordsInCloudKit])
        {
          id v72 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString zoneID](v51, "zoneID"));
          id v73 = (void *)objc_claimAutoreleasedReturnValue([v72 zoneName]);
          id v74 = sub_1000AA6AC(@"ckks", v73);
          id v75 = (os_log_s *)objc_claimAutoreleasedReturnValue(v74);

          if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v75,  OS_LOG_TYPE_DEFAULT,  "A priority view has more records in CloudKit; treating as new",
              buf,
              2u);
          }

          char v93 = 1;
        }

        *(_BYTE *)(*(void *)(*(void *)(v99 + 72) + 8LL) + 24LL) = 1;
      }
    }

    id v97 = [v95 countByEnumeratingWithState:&v108 objects:v118 count:16];
  }

  while (v97);
  id v76 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) operationDependencies]);
  [v76 applyNewSyncingPolicy:*(void *)(v1 + 48) viewStates:v38];

  char v77 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) stateMachine]);
  [v77 _onqueueHandleFlag:@"check_queues"];

  if ((v93 & 1) != 0)
  {
    [*(id *)(v1 + 32) onqueueCreatePriorityViewsProcessedWatcher];
    id v78 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) stateMachine]);
    int v79 = v78;
    int64_t v80 = @"new_priority_views";
LABEL_61:
    [v78 _onqueueHandleFlag:v80];
  }

  if (*(_BYTE *)(*(void *)(*(void *)(v1 + 72) + 8LL) + 24LL) && *(_BYTE *)(v1 + 80))
  {
    id v82 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) stateMachine]);
    [v82 _onqueueHandleFlag:@"key_process_requested"];
  }

  __int128 v102 = 0u;
  __int128 v103 = 0u;
  __int128 v100 = 0u;
  __int128 v101 = 0u;
  id v83 = v38;
  id v84 = [v83 countByEnumeratingWithState:&v100 objects:v116 count:16];
  if (v84)
  {
    id v85 = v84;
    uint64_t v86 = *(void *)v101;
    do
    {
      for (k = 0LL; k != v85; k = (char *)k + 1)
      {
        if (*(void *)v101 != v86) {
          objc_enumerationMutation(v83);
        }
        v88 = *(void **)(*((void *)&v100 + 1) + 8LL * (void)k);
        int v89 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) zoneChangeFetcher]);
        uint64_t v90 = *(void *)(v1 + 32);
        id v91 = (void *)objc_claimAutoreleasedReturnValue([v88 zoneID]);
        [v89 registerClient:v90 zoneID:v91];
      }

      id v85 = [v83 countByEnumeratingWithState:&v100 objects:v116 count:16];
    }

    while (v85);
  }
}

void sub_10014E31C(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneName]);
  id v3 = sub_1000AA6AC(@"ckkstrust", v2);
  char v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);

  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v10 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Ending trusted operation", v10, 2u);
  }

  id v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  [v5 setPeerProviders:&__NSArray0__struct];

  [*(id *)(a1 + 32) setSuggestTLKUpload:0];
  [*(id *)(a1 + 32) setTrustStatus:3];
  id v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) trustStatusKnown]);
  [v6 fulfill];

  id v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) stateMachine]);
  [v7 _onqueueHandleFlag:@"trusted_operation_end"];

  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 overallLaunch]);
  [v9 addEvent:@"trust-loss"];
}

void sub_10014E450(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneName]);
  id v3 = sub_1000AA6AC(@"ckkstrust", v2);
  char v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);

  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Beginning trusted operation", buf, 2u);
  }

  uint64_t v5 = *(void *)(a1 + 40);
  id v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  [v6 setPeerProviders:v5];

  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  [v8 setRequestPolicyCheck:v7];

  id v9 = [*(id *)(a1 + 32) trustStatus];
  [*(id *)(a1 + 32) setSuggestTLKUpload:*(void *)(a1 + 56)];
  [*(id *)(a1 + 32) setTrustStatus:1];
  id v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) trustStatusKnown]);
  [v10 fulfill];

  id v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) stateMachine]);
  [v11 _onqueueHandleFlag:@"trusted_operation_begin"];

  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) stateMachine]);
  [v12 _onqueueHandleFlag:@"key_process_requested"];

  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "operationDependencies", 0));
  int v14 = (void *)objc_claimAutoreleasedReturnValue([v13 allCKKSManagedViews]);

  id v15 = [v14 countByEnumeratingWithState:&v27 objects:v32 count:16];
  if (v15)
  {
    id v16 = v15;
    uint64_t v17 = *(void *)v28;
    do
    {
      id v18 = 0LL;
      do
      {
        if (*(void *)v28 != v17) {
          objc_enumerationMutation(v14);
        }
        uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v27 + 1) + 8 * (void)v18) launch]);
        [v19 addEvent:@"trust"];

        id v18 = (char *)v18 + 1;
      }

      while (v16 != v18);
      id v16 = [v14 countByEnumeratingWithState:&v27 objects:v32 count:16];
    }

    while (v16);
  }

  unsigned int v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v20 overallLaunch]);
  [v21 addEvent:@"trust"];

  if (v9 == (id)3)
  {
    id v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneName]);
    id v23 = sub_1000AA6AC(@"ckkstrust", v22);
    unsigned int v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);

    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Moving from an untrusted status; we need to process incoming queue and scan for any new items",
        buf,
        2u);
    }

    uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) stateMachine]);
    [v25 _onqueueHandleFlag:@"process_incoming_queue"];

    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) stateMachine]);
    [v26 _onqueueHandleFlag:@"dropped_items"];

    [*(id *)(a1 + 32) onqueueCreatePriorityViewsProcessedWatcher];
  }

void sub_10014E788(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneName]);
  id v3 = sub_1000AA6AC(@"ckkszone", v2);
  char v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);

  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)id v9 = 0;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "received a notification of CK logout",  v9,  2u);
  }

  [*(id *)(a1 + 32) setAccountStatus:3];
  uint64_t v5 = objc_alloc(&OBJC_CLASS___CKKSCondition);
  id v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) loggedIn]);
  id v7 = -[CKKSCondition initToChain:](v5, "initToChain:", v6);
  [*(id *)(a1 + 32) setLoggedIn:v7];

  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) loggedOut]);
  [v8 fulfill];
}

void sub_10014E888(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneName]);
  id v3 = sub_1000AA6AC(@"ckkszone", v2);
  char v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);

  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)id v9 = 0;
    _os_log_debug_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEBUG,  "received a notification of CK login",  v9,  2u);
  }

  [*(id *)(a1 + 32) setAccountStatus:1];
  uint64_t v5 = objc_alloc(&OBJC_CLASS___CKKSCondition);
  id v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) loggedOut]);
  id v7 = -[CKKSCondition initToChain:](v5, "initToChain:", v6);
  [*(id *)(a1 + 32) setLoggedOut:v7];

  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) loggedIn]);
  [v8 fulfill];
}

void sub_10014E988(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v3 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained zoneName]);
  id v4 = sub_1000AA6AC(@"ckkszone", v3);
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);

  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    int v7 = 138412290;
    uint64_t v8 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&v7, 0xCu);
  }
}

void sub_10014EA64(id *a1)
{
  id WeakRetained = objc_loadWeakRetained(a1 + 6);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_10014EAF8;
  v3[3] = &unk_100291608;
  id v4 = a1[4];
  id v5 = a1[5];
  [WeakRetained dispatchSyncWithReadOnlySQLTransaction:v3];
}

void sub_10014EAF8(uint64_t a1)
{
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  id obj = *(id *)(a1 + 32);
  id v3 = [obj countByEnumeratingWithState:&v16 objects:v24 count:16];
  if (v3)
  {
    id v4 = v3;
    id v5 = 0LL;
    uint64_t v6 = *(void *)v17;
    while (2)
    {
      int v7 = 0LL;
      uint64_t v8 = v5;
      do
      {
        if (*(void *)v17 != v6) {
          objc_enumerationMutation(obj);
        }
        uint64_t v9 = *(void *)(*((void *)&v16 + 1) + 8LL * (void)v7);
        id v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectForKeyedSubscript:v9]);
        id v15 = v8;
        id v11 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSMirrorEntry pcsMirrorKeysForService:matchingKeys:error:]( &OBJC_CLASS___CKKSMirrorEntry,  "pcsMirrorKeysForService:matchingKeys:error:",  v9,  v10,  &v15));
        id v5 = v15;

        if (!v11)
        {
          id v12 = sub_1000AA6AC(@"ckks", 0LL);
          __int128 v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138412546;
            uint64_t v21 = v9;
            __int16 v22 = 2112;
            id v23 = v5;
            _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Error getting PCS key hash for service %@: %@",  buf,  0x16u);
          }

          uint64_t v2 = 0LL;
          goto LABEL_14;
        }

        -[NSMutableDictionary setObject:forKeyedSubscript:](v2, "setObject:forKeyedSubscript:", v11, v9);

        int v7 = (char *)v7 + 1;
        uint64_t v8 = v5;
      }

      while (v4 != v7);
      id v4 = [obj countByEnumeratingWithState:&v16 objects:v24 count:16];
      if (v4) {
        continue;
      }
      break;
    }
  }

  else
  {
    id v5 = 0LL;
  }

void sub_10014ED10(uint64_t a1)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [*(id *)(a1 + 32) havoc];
  id v2 = sub_1000AA6AC(@"havoc", 0LL);
  id v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v4 = [*(id *)(a1 + 32) havoc];
    id v5 = @"OFF";
    if (v4) {
      id v5 = @"ON";
    }
    int v6 = 138412290;
    int v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Havoc is now %@", (uint8_t *)&v6, 0xCu);
  }
}

void sub_10014EE04(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) accountStatus];
  id v3 = *(void **)(a1 + 32);
  if (v2 == (id)1)
  {
    unsigned int v4 = (void *)objc_claimAutoreleasedReturnValue([v3 operationDependencies]);
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 syncingPolicy]);

    if (v5)
    {
      if ([*(id *)(a1 + 32) trustStatus] == (id)1) {
        goto LABEL_11;
      }
      int v6 = @"No iCloud Keychain Trust";
      uint64_t v7 = 52LL;
    }

    else
    {
      int v6 = @"Syncing policy not yet loaded";
      uint64_t v7 = 56LL;
    }
  }

  else if ([v3 accountStatus])
  {
    int v6 = @"User is not signed into iCloud.";
    uint64_t v7 = 10LL;
  }

  else
  {
    int v6 = @"iCloud account status unknown.";
    uint64_t v7 = 64LL;
  }

  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  @"CKKSErrorDomain",  v7,  v6));
  if (v8)
  {
    v30[0] = _NSConcreteStackBlock;
    v30[1] = 3221225472LL;
    v30[2] = sub_10014F190;
    v30[3] = &unk_100290518;
    id v31 = v8;
    uint64_t v9 = v8;
    uint64_t v10 = objc_claimAutoreleasedReturnValue( +[CKKSResultOperation named:withBlockTakingSelf:]( &OBJC_CLASS___CKKSResultOperation,  "named:withBlockTakingSelf:",  @"rpcWaitForPriorityViewProcessing-fail",  v30));
    uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8LL);
    id v12 = *(void **)(v11 + 40);
    *(void *)(v11 + 40) = v10;

    __int128 v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationQueue]);
    [v13 addOperation:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40)];

    goto LABEL_21;
  }

void sub_10014F190(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = sub_1000AA6AC(@"ckksrpc", 0LL);
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    int v7 = 138412290;
    uint64_t v8 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Returning failure for waitForPriorityViews: %@",  (uint8_t *)&v7,  0xCu);
  }

  [v3 setError:*(void *)(a1 + 32)];
}

id sub_10014F264(uint64_t a1, void *a2)
{
  return [a2 setError:*(void *)(a1 + 32)];
}

void sub_10014F270(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 currentFetchReasons]);
  [v3 addObject:*(void *)(a1 + 40)];

  id v4 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) stateMachine]);
  [v4 _onqueueHandleFlag:@"fetch_requested"];
}

void sub_10014F2E8(id *a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(a1 + 6);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([a1[4] result]);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 error]);

  if (v6)
  {
    id v7 = sub_1000AA6AC(@"ckksrpc", 0LL);
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      int v14 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "rpcFetchAndProcess failed: %@", buf, 0xCu);
    }

    [v3 setError:v6];
  }

  else
  {
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    void v9[2] = sub_10014F454;
    v9[3] = &unk_100290578;
    id v10 = a1[5];
    id v11 = WeakRetained;
    id v12 = v3;
    [WeakRetained dispatchSyncWithReadOnlySQLTransaction:v9];
  }
}

void sub_10014F454(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  if (v2) {
    id v3 = v2;
  }
  else {
    id v3 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) viewList]);
  }
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  id v4 = v3;
  id v5 = [v4 countByEnumeratingWithState:&v19 objects:v25 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v20;
    while (2)
    {
      for (CFIndex i = 0LL; i != v6; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v20 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(a1 + 40) viewStateForName:*(void *)(*((void *)&v19 + 1) + 8 * (void)i)]);
        id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 zoneID]);
        id v11 = (void *)objc_claimAutoreleasedReturnValue([v9 contextID]);
        id v12 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSCurrentKeySet loadForZone:contextID:]( &OBJC_CLASS___CKKSCurrentKeySet,  "loadForZone:contextID:",  v10,  v11));

        __int128 v13 = (void *)objc_claimAutoreleasedReturnValue([v12 tlk]);
        if (!v13)
        {
          int v14 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneName]);
          id v15 = sub_1000AA6AC(@"ckks", v14);
          __int128 v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);

          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138412290;
            id v24 = v9;
            _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "No local TLKs for %@; failing a fetch rpc",
              buf,
              0xCu);
          }

          id v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"No local keys for %@; processing queue will fail",
                            v9));
          __int128 v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  @"CKKSErrorDomain",  53LL,  v17));
          [*(id *)(a1 + 48) setError:v18];

          goto LABEL_16;
        }
      }

      id v6 = [v4 countByEnumeratingWithState:&v19 objects:v25 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }

id sub_10014F6B8(uint64_t a1, void *a2)
{
  return [a2 setError:*(void *)(a1 + 32)];
}

void sub_10014F6C4(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 currentFetchReasons]);
  [v3 addObject:*(void *)(a1 + 40)];

  id v4 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) stateMachine]);
  [v4 _onqueueHandleFlag:@"fetch_requested"];
}

void sub_10014F73C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) result]);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 error]);

  id v6 = sub_1000AA6AC(@"ckksrpc", 0LL);
  uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v8)
    {
      int v9 = 138412290;
      id v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "rpcFetch failed: %@", (uint8_t *)&v9, 0xCu);
    }

    [v3 setError:v5];
  }

  else
  {
    if (v8)
    {
      LOWORD(v9) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "rpcFetch succeeded", (uint8_t *)&v9, 2u);
    }
  }
}

void sub_10014F868(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) stateMachine]);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 currentState]);
  unsigned int v4 = [v3 isEqualToString:@"loggedout"];

  if (v4)
  {
    uint64_t v5 = objc_claimAutoreleasedReturnValue( +[CKKSResultOperation named:withBlockTakingSelf:]( &OBJC_CLASS___CKKSResultOperation,  "named:withBlockTakingSelf:",  @"fail",  &stru_100290720));
    uint64_t v6 = *(void *)(*(void *)(a1 + 48) + 8LL);
    uint64_t v7 = *(void **)(v6 + 40);
    *(void *)(v6 + 40) = v5;
  }

  BOOL v8 = *(void **)(a1 + 40);
  if (v8) {
    id v9 = v8;
  }
  else {
    id v9 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) viewList]);
  }
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  id v10 = v9;
  id v11 = [v10 countByEnumeratingWithState:&v29 objects:v33 count:16];
  if (!v11) {
    goto LABEL_22;
  }
  id v12 = v11;
  uint64_t v13 = *(void *)v30;
  while (2)
  {
    for (CFIndex i = 0LL; i != v12; CFIndex i = (char *)i + 1)
    {
      if (*(void *)v30 != v13) {
        objc_enumerationMutation(v10);
      }
      id v15 = (id)objc_claimAutoreleasedReturnValue( [*(id *)(a1 + 32) viewStateForName:*(void *)(*((void *)&v29 + 1) + 8 * (void)i)]);
      __int128 v16 = (void *)objc_claimAutoreleasedReturnValue([v15 viewKeyHierarchyState]);
      unsigned int v17 = [v16 isEqualToString:@"waitfortlk"];

      if (v17)
      {
        __int128 v20 = &stru_100290740;
LABEL_19:
        uint64_t v21 = objc_claimAutoreleasedReturnValue( +[CKKSResultOperation named:withBlockTakingSelf:]( &OBJC_CLASS___CKKSResultOperation,  "named:withBlockTakingSelf:",  @"fail",  v20));
        uint64_t v22 = *(void *)(*(void *)(a1 + 48) + 8LL);
        uint64_t v23 = *(void **)(v22 + 40);
        *(void *)(v22 + 40) = v21;
LABEL_21:

        goto LABEL_22;
      }

      __int128 v18 = (void *)objc_claimAutoreleasedReturnValue([v15 viewKeyHierarchyState]);
      unsigned int v19 = [v18 isEqualToString:@"waitfortrust"];

      if (v19)
      {
        __int128 v20 = &stru_100290760;
        goto LABEL_19;
      }

      if (([v15 ckksManagedView] & 1) == 0)
      {
        v27[0] = _NSConcreteStackBlock;
        v27[1] = 3221225472LL;
        v27[2] = sub_10014FB38;
        v27[3] = &unk_100290518;
        id v15 = v15;
        id v28 = v15;
        uint64_t v24 = objc_claimAutoreleasedReturnValue( +[CKKSResultOperation named:withBlockTakingSelf:]( &OBJC_CLASS___CKKSResultOperation,  "named:withBlockTakingSelf:",  @"fail",  v27));
        uint64_t v25 = *(void *)(*(void *)(a1 + 48) + 8LL);
        uint64_t v26 = *(void **)(v25 + 40);
        *(void *)(v25 + 40) = v24;

        uint64_t v23 = v28;
        goto LABEL_21;
      }
    }

    id v12 = [v10 countByEnumeratingWithState:&v29 objects:v33 count:16];
    if (v12) {
      continue;
    }
    break;
  }

id sub_10014FB28(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onqueueProcessOutgoingQueue:*(void *)(a1 + 40) priorityRush:0];
}

void sub_10014FB38(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = a2;
  id v6 = (id)objc_claimAutoreleasedReturnValue([v2 zoneName]);
  unsigned int v4 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Cannot push view %@; is externally managed",
                   v6));
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  @"CKKSErrorDomain",  63LL,  v4));
  [v3 setError:v5];
}

void sub_10014FBE0(id a1, CKKSResultOperation *a2)
{
  id v2 = a2;
  id v3 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  @"CKKSErrorDomain",  52LL,  @"No trust; push will not succeed."));
  -[CKKSResultOperation setError:](v2, "setError:", v3);
}

void sub_10014FC48(id a1, CKKSResultOperation *a2)
{
  id v2 = a2;
  id v3 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  @"CKKSErrorDomain",  53LL,  @"No TLKs for this view; push will not succeed."));
  -[CKKSResultOperation setError:](v2, "setError:", v3);
}

void sub_10014FCB0(id a1, CKKSResultOperation *a2)
{
  id v2 = a2;
  id v3 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  @"CKKSErrorDomain",  10LL,  @"No CloudKit account; push will not succeed."));
  -[CKKSResultOperation setError:](v2, "setError:", v3);
}

void sub_10014FD18(uint64_t a1)
{
  id v5 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  uint64_t v2 = objc_claimAutoreleasedReturnValue([v5 viewsInState:@"waitfortlkcreation"]);
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  unsigned int v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

uint64_t sub_10014FD74(uint64_t a1)
{
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v12;
    do
    {
      id v6 = 0LL;
      do
      {
        if (*(void *)v12 != v5) {
          objc_enumerationMutation(v2);
        }
        uint64_t v7 = *(void *)(*((void *)&v11 + 1) + 8LL * (void)v6);
        BOOL v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "operationDependencies", (void)v11));
        [v8 intransactionCKRecordChanged:v7 resync:0];

        id v6 = (char *)v6 + 1;
      }

      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }

    while (v4);
  }

  id v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) stateMachine]);
  [v9 _onqueueHandleFlag:@"key_process_requested"];

  return 1LL;
}

void sub_10014FEA8(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 currentFetchReasons]);
  [v3 addObject:@"keyset"];

  id v4 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) stateMachine]);
  [v4 _onqueueHandleFlag:@"fetch_requested"];
}

void sub_10014FF24(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 operationDependencies]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 keysetProviderOperations]);
  uint64_t v5 = objc_claimAutoreleasedReturnValue([v2 findFirstPendingOperation:v4]);
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v5;

  if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL))
  {
    BOOL v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
    __int128 v59 = 0u;
    __int128 v60 = 0u;
    __int128 v61 = 0u;
    __int128 v62 = 0u;
    id v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
    id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 allCKKSManagedViews]);

    id v11 = [v10 countByEnumeratingWithState:&v59 objects:v68 count:16];
    if (v11)
    {
      id v12 = v11;
      uint64_t v13 = *(void *)v60;
      do
      {
        for (CFIndex i = 0LL; i != v12; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v60 != v13) {
            objc_enumerationMutation(v10);
          }
          id v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v59 + 1) + 8 * (void)i) zoneID]);
          [v8 addObject:v15];
        }

        id v12 = [v10 countByEnumeratingWithState:&v59 objects:v68 count:16];
      }

      while (v12);
    }

    __int128 v16 = -[CKKSProvideKeySetOperation initWithIntendedZoneIDs:]( objc_alloc(&OBJC_CLASS___CKKSProvideKeySetOperation),  "initWithIntendedZoneIDs:",  v8);
    uint64_t v17 = *(void *)(*(void *)(a1 + 40) + 8LL);
    __int128 v18 = *(void **)(v17 + 40);
    *(void *)(v17 + 40) = v16;

    unsigned int v19 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
    __int128 v20 = (void *)objc_claimAutoreleasedReturnValue([v19 keysetProviderOperations]);
    [v20 addObject:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40)];

    [*(id *)(a1 + 32) scheduleOperationWithoutDependencies:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40)];
  }

  uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  __int128 v55 = 0u;
  __int128 v56 = 0u;
  __int128 v57 = 0u;
  __int128 v58 = 0u;
  uint64_t v51 = a1;
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v22 allCKKSManagedViews]);

  id obj = v23;
  id v54 = [v23 countByEnumeratingWithState:&v55 objects:v67 count:16];
  if (v54)
  {
    uint64_t v24 = *(void *)v56;
LABEL_12:
    uint64_t v25 = 0LL;
    while (1)
    {
      if (*(void *)v56 != v24) {
        objc_enumerationMutation(obj);
      }
      uint64_t v26 = *(void **)(*((void *)&v55 + 1) + 8 * v25);
      uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v26 zoneID]);
      id v28 = (void *)objc_claimAutoreleasedReturnValue([v26 contextID]);
      __int128 v29 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSCurrentKeySet loadForZone:contextID:]( &OBJC_CLASS___CKKSCurrentKeySet,  "loadForZone:contextID:",  v27,  v28));

      __int128 v30 = (void *)objc_claimAutoreleasedReturnValue([v29 currentTLKPointer]);
      uint64_t v31 = objc_claimAutoreleasedReturnValue([v30 currentKeyUUID]);
      if (!v31)
      {

LABEL_29:
        uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v26 zoneID]);
        uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([v45 zoneName]);
        id v47 = sub_1000AA6AC(@"ckks", v46);
        id v48 = (os_log_s *)objc_claimAutoreleasedReturnValue(v47);

        if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
        {
          id v49 = (void *)objc_claimAutoreleasedReturnValue([v26 zoneID]);
          *(_DWORD *)__int128 buf = 138412546;
          id v64 = v49;
          __int16 v65 = 2112;
          id v66 = v29;
          _os_log_impl( (void *)&_mh_execute_header,  v48,  OS_LOG_TYPE_DEFAULT,  "No current keyset for %@ (%@)",  buf,  0x16u);
        }

        unsigned __int8 v50 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v51 + 32) stateMachine]);
        [v50 _onqueueHandleFlag:@"key_set"];

        goto LABEL_32;
      }

      __int128 v32 = (void *)v31;
      id v33 = (void *)objc_claimAutoreleasedReturnValue([v29 tlk]);
      id v34 = (void *)objc_claimAutoreleasedReturnValue([v33 uuid]);
      if (!v34)
      {
        uint64_t v35 = v24;
        int v36 = v21;
        __int128 v37 = (void *)objc_claimAutoreleasedReturnValue([v26 viewKeyHierarchyState]);
        if (([v37 isEqualToString:@"waitfortrust"] & 1) == 0)
        {
          id v43 = (void *)objc_claimAutoreleasedReturnValue([v26 viewKeyHierarchyState]);
          unsigned __int8 v52 = [v43 isEqualToString:@"waitfortlk"];

          uint64_t v21 = v36;
          uint64_t v24 = v35;
          if ((v52 & 1) == 0) {
            goto LABEL_29;
          }
          goto LABEL_20;
        }

        uint64_t v21 = v36;
        uint64_t v24 = v35;
      }

LABEL_20:
      id v38 = (void *)objc_claimAutoreleasedReturnValue([v26 zoneID]);
      __int128 v39 = (void *)objc_claimAutoreleasedReturnValue([v38 zoneName]);
      id v40 = sub_1000AA6AC(@"ckks", v39);
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue(v40);

      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        id v64 = v29;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Already have keyset %@", buf, 0xCu);
      }

      id v42 = (void *)objc_claimAutoreleasedReturnValue([v26 zoneID]);
      [v21 setObject:v29 forKeyedSubscript:v42];

      if (v54 == (id)++v25)
      {
        id v44 = [obj countByEnumeratingWithState:&v55 objects:v67 count:16];
        id v54 = v44;
        if (v44) {
          goto LABEL_12;
        }
        break;
      }
    }
  }

  [*(id *)(*(void *)(*(void *)(v51 + 40) + 8) + 40) provideKeySets:v21];
LABEL_32:
}

void sub_1001504C0(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (!v9)
  {
    uint64_t v45 = a1;
    id v47 = v7;
    uint64_t v13 = objc_alloc_init(&OBJC_CLASS___CKKSMemoryKeyCache);
    __int128 v14 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
    id v15 = (void *)objc_claimAutoreleasedReturnValue([v14 contextID]);
    -[CKKSMemoryKeyCache populateWithRecords:contextID:](v13, "populateWithRecords:contextID:", v8, v15);

    id v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
    __int128 v16 = v13;
    id v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
    __int128 v59 = 0u;
    __int128 v60 = 0u;
    __int128 v61 = 0u;
    __int128 v62 = 0u;
    id v46 = v8;
    id obj = v8;
    id v17 = [obj countByEnumeratingWithState:&v59 objects:v63 count:16];
    unsigned __int8 v50 = v13;
    if (!v17) {
      goto LABEL_23;
    }
    id v18 = v17;
    uint64_t v19 = *(void *)v60;
    while (1)
    {
      __int128 v20 = 0LL;
      do
      {
        if (*(void *)v60 != v19) {
          objc_enumerationMutation(obj);
        }
        uint64_t v21 = *(void *)(*((void *)&v59 + 1) + 8LL * (void)v20);
        uint64_t v22 = objc_alloc(&OBJC_CLASS___CKKSKey);
        uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
        uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v23 contextID]);
        uint64_t v25 = -[CKKSCKRecordHolder initWithCKRecord:contextID:](v22, "initWithCKRecord:contextID:", v21, v24);

        uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
        uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v26 contextID]);
        id v58 = 0LL;
        id v28 = (void *)objc_claimAutoreleasedReturnValue( -[CKKSKey ensureKeyLoadedForContextID:cache:error:]( v25,  "ensureKeyLoadedForContextID:cache:error:",  v27,  v16,  &v58));
        id v29 = v58;

        if (!v28)
        {
          if (v29)
          {
            id v30 = sub_1000AA6AC(@"ckks-oob", 0LL);
            uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)__int128 buf = 138412290;
              id v65 = v29;
              _os_log_debug_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEBUG,  "Could not find key material in keychain: %@",  buf,  0xCu);
            }
          }

          __int128 v32 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKey keyclass](v25, "keyclass", v45));
          if ([v32 isEqual:@"tlk"])
          {
            id v33 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKey parentKeyUUID](v25, "parentKeyUUID"));
            id v34 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKey uuid](v25, "uuid"));
            unsigned __int8 v35 = [v33 isEqualToString:v34];

            int v36 = v48;
            if ((v35 & 1) != 0) {
              goto LABEL_20;
            }
          }

          else
          {
          }

          int v36 = v49;
LABEL_20:
          [v36 addObject:v25];
          __int128 v16 = v50;
        }

        __int128 v20 = (char *)v20 + 1;
      }

      while (v18 != v20);
      id v18 = [obj countByEnumeratingWithState:&v59 objects:v63 count:16];
      if (!v18)
      {
LABEL_23:

        if ([v48 count])
        {
          __int128 v37 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained cuttlefishAdapter]);
          uint64_t v38 = *(void *)(v45 + 32);
          __int128 v39 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained accountTracker]);
          id v40 = (void *)objc_claimAutoreleasedReturnValue([v39 octagonPeerID]);
          uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
          id v42 = (void *)objc_claimAutoreleasedReturnValue([v41 contextID]);
          v52[0] = _NSConcreteStackBlock;
          v52[1] = 3221225472LL;
          v52[2] = sub_1001509EC;
          v52[3] = &unk_1002906B8;
          id v57 = *(id *)(v45 + 40);
          v52[4] = WeakRetained;
          id v53 = v50;
          id v54 = v48;
          id v43 = v48;
          id v44 = v49;
          id v55 = v49;
          id v7 = v47;
          id v56 = v47;
          [v37 fetchRecoverableTLKShares:v38 peerID:v40 contextID:v42 reply:v52];

          __int128 v16 = v50;
          id v9 = 0LL;
        }

        else
        {
          id v7 = v47;
          [WeakRetained decryptPCSIdentities:v47 cache:v16 complete:*(void *)(v45 + 40)];
          id v9 = 0LL;
          id v43 = v48;
          id v44 = v49;
        }

        id v8 = v46;
        goto LABEL_27;
      }
    }
  }

  id v11 = sub_1000AA6AC(@"ckks-oob", 0LL);
  id v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 138412290;
    id v65 = v9;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "error getting pcs identities: %@", buf, 0xCu);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
LABEL_27:
}

void sub_1001509EC(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = v5;
  if (a2 && !v5)
  {
    id v7 = *(void **)(a1 + 32);
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t v9 = *(void *)(a1 + 48);
    id v25 = 0LL;
    unsigned int v10 = [v7 unwrapTLKAndSaveToCache:v8 tlks:v9 tlkShares:a2 error:&v25];
    id v11 = v25;
    id v12 = v11;
    if (!v10 || v11)
    {
      id v20 = sub_1000AA6AC(@"ckks-oob", 0LL);
      uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v27 = v12;
        uint64_t v22 = "Errored unwrapping TLK Shares, quitting: %@";
LABEL_15:
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, v22, buf, 0xCu);
      }
    }

    else
    {
      uint64_t v13 = *(void **)(a1 + 32);
      uint64_t v14 = *(void *)(a1 + 40);
      uint64_t v15 = *(void *)(a1 + 56);
      id v24 = 0LL;
      unsigned int v16 = [v13 unwrapKeysAndSaveToCache:v14 syncKeys:v15 error:&v24];
      id v17 = v24;
      id v12 = v17;
      if (v16 && !v17)
      {
        [*(id *)(a1 + 32) decryptPCSIdentities:*(void *)(a1 + 64) cache:*(void *)(a1 + 40) complete:*(void *)(a1 + 72)];
        goto LABEL_17;
      }

      id v23 = sub_1000AA6AC(@"ckks-oob", 0LL);
      uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v27 = v12;
        uint64_t v22 = "Errored unwrapping sync keys, quitting: %@";
        goto LABEL_15;
      }
    }

    (*(void (**)(void))(*(void *)(a1 + 72) + 16LL))();
    goto LABEL_17;
  }

  id v18 = sub_1000AA6AC(@"ckks-oob", 0LL);
  uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 138412290;
    uint64_t v27 = v6;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Errored fetching TLK shares: %@", buf, 0xCu);
  }

  (*(void (**)(void))(*(void *)(a1 + 72) + 16LL))();
LABEL_17:
}

void sub_100150BF8(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (!v9)
  {
    uint64_t v45 = a1;
    id v47 = v7;
    uint64_t v13 = objc_alloc_init(&OBJC_CLASS___CKKSMemoryKeyCache);
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v14 contextID]);
    -[CKKSMemoryKeyCache populateWithRecords:contextID:](v13, "populateWithRecords:contextID:", v8, v15);

    id v49 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
    unsigned int v16 = v13;
    id v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
    __int128 v59 = 0u;
    __int128 v60 = 0u;
    __int128 v61 = 0u;
    __int128 v62 = 0u;
    id v46 = v8;
    id obj = v8;
    id v17 = [obj countByEnumeratingWithState:&v59 objects:v63 count:16];
    unsigned __int8 v50 = v13;
    if (!v17) {
      goto LABEL_23;
    }
    id v18 = v17;
    uint64_t v19 = *(void *)v60;
    while (1)
    {
      id v20 = 0LL;
      do
      {
        if (*(void *)v60 != v19) {
          objc_enumerationMutation(obj);
        }
        uint64_t v21 = *(void *)(*((void *)&v59 + 1) + 8LL * (void)v20);
        uint64_t v22 = objc_alloc(&OBJC_CLASS___CKKSKey);
        id v23 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
        id v24 = (void *)objc_claimAutoreleasedReturnValue([v23 contextID]);
        id v25 = -[CKKSCKRecordHolder initWithCKRecord:contextID:](v22, "initWithCKRecord:contextID:", v21, v24);

        uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
        uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v26 contextID]);
        id v58 = 0LL;
        id v28 = (void *)objc_claimAutoreleasedReturnValue( -[CKKSKey ensureKeyLoadedForContextID:cache:error:]( v25,  "ensureKeyLoadedForContextID:cache:error:",  v27,  v16,  &v58));
        id v29 = v58;

        if (!v28)
        {
          if (v29)
          {
            id v30 = sub_1000AA6AC(@"ckks-oob", 0LL);
            uint64_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)__int128 buf = 138412290;
              id v65 = v29;
              _os_log_debug_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEBUG,  "Could not find key material in keychain: %@",  buf,  0xCu);
            }
          }

          __int128 v32 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKey keyclass](v25, "keyclass", v45));
          if ([v32 isEqual:@"tlk"])
          {
            id v33 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKey parentKeyUUID](v25, "parentKeyUUID"));
            id v34 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSKey uuid](v25, "uuid"));
            unsigned __int8 v35 = [v33 isEqualToString:v34];

            int v36 = v48;
            if ((v35 & 1) != 0) {
              goto LABEL_20;
            }
          }

          else
          {
          }

          int v36 = v49;
LABEL_20:
          [v36 addObject:v25];
          unsigned int v16 = v50;
        }

        id v20 = (char *)v20 + 1;
      }

      while (v18 != v20);
      id v18 = [obj countByEnumeratingWithState:&v59 objects:v63 count:16];
      if (!v18)
      {
LABEL_23:

        if ([v48 count])
        {
          __int128 v37 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained cuttlefishAdapter]);
          uint64_t v38 = *(void *)(v45 + 32);
          __int128 v39 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained accountTracker]);
          id v40 = (void *)objc_claimAutoreleasedReturnValue([v39 octagonPeerID]);
          uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
          id v42 = (void *)objc_claimAutoreleasedReturnValue([v41 contextID]);
          v52[0] = _NSConcreteStackBlock;
          v52[1] = 3221225472LL;
          v52[2] = sub_100151124;
          v52[3] = &unk_1002906B8;
          id v57 = *(id *)(v45 + 40);
          v52[4] = WeakRetained;
          id v53 = v50;
          id v54 = v48;
          id v43 = v48;
          id v44 = v49;
          id v55 = v49;
          id v7 = v47;
          id v56 = v47;
          [v37 fetchRecoverableTLKShares:v38 peerID:v40 contextID:v42 reply:v52];

          unsigned int v16 = v50;
          id v9 = 0LL;
        }

        else
        {
          id v7 = v47;
          [WeakRetained decryptCurrentItems:v47 cache:v16 complete:*(void *)(v45 + 40)];
          id v9 = 0LL;
          id v43 = v48;
          id v44 = v49;
        }

        id v8 = v46;
        goto LABEL_27;
      }
    }
  }

  id v11 = sub_1000AA6AC(@"ckks-oob", 0LL);
  id v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 138412290;
    id v65 = v9;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "error getting current items: %@", buf, 0xCu);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
LABEL_27:
}

void sub_100151124(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = v5;
  if (a2 && !v5)
  {
    id v7 = *(void **)(a1 + 32);
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t v9 = *(void *)(a1 + 48);
    id v23 = 0LL;
    [v7 unwrapTLKAndSaveToCache:v8 tlks:v9 tlkShares:a2 error:&v23];
    id v10 = v23;
    if (v10)
    {
      id v11 = v10;
      id v12 = sub_1000AA6AC(@"ckks-oob", 0LL);
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
      if (!os_log_type_enabled((os_log_t)v13, OS_LOG_TYPE_ERROR))
      {
LABEL_13:

        (*(void (**)(void))(*(void *)(a1 + 72) + 16LL))();
        goto LABEL_14;
      }

      *(_DWORD *)__int128 buf = 138412290;
      id v25 = v11;
      uint64_t v14 = "Errored unwrapping TLK Shares, quitting: %@";
    }

    else
    {
      id v17 = *(void **)(a1 + 32);
      uint64_t v18 = *(void *)(a1 + 40);
      uint64_t v19 = *(void *)(a1 + 56);
      id v22 = 0LL;
      [v17 unwrapKeysAndSaveToCache:v18 syncKeys:v19 error:&v22];
      id v20 = v22;
      if (!v20)
      {
        [*(id *)(a1 + 32) decryptCurrentItems:*(void *)(a1 + 64) cache:*(void *)(a1 + 40) complete:*(void *)(a1 + 72)];
        goto LABEL_14;
      }

      id v11 = v20;
      id v21 = sub_1000AA6AC(@"ckks-oob", 0LL);
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(v21);
      if (!os_log_type_enabled((os_log_t)v13, OS_LOG_TYPE_ERROR)) {
        goto LABEL_13;
      }
      *(_DWORD *)__int128 buf = 138412290;
      id v25 = v11;
      uint64_t v14 = "Errored unwrapping sync keys, quitting: %@";
    }

    _os_log_impl((void *)&_mh_execute_header, (os_log_t)v13, OS_LOG_TYPE_ERROR, v14, buf, 0xCu);
    goto LABEL_13;
  }

  id v15 = sub_1000AA6AC(@"ckks-oob", 0LL);
  unsigned int v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 138412290;
    id v25 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_ERROR,  "Errored fetching TLK shares, unable to decrypt identities: %@",  buf,  0xCu);
  }

  (*(void (**)(void))(*(void *)(a1 + 72) + 16LL))();
LABEL_14:
}

void sub_100151320(id *a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([a1[4] error]);

  if (v2)
  {
    id v3 = (void *)objc_claimAutoreleasedReturnValue([a1[5] zoneName]);
    id v4 = sub_1000AA6AC(@"ckkscurrent", v3);
    id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([a1[4] error]);
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Rejecting current item pointer get since fetch failed: %@",  (uint8_t *)&buf,  0xCu);
    }

    id v7 = (void (**)(id, void, id))a1[10];
    id WeakRetained = (id)objc_claimAutoreleasedReturnValue([a1[4] error]);
    v7[2](v7, 0LL, WeakRetained);
  }

  else
  {
    id WeakRetained = objc_loadWeakRetained(a1 + 11);
    *(void *)&__int128 buf = 0LL;
    *((void *)&buf + 1) = &buf;
    uint64_t v18 = 0x2020000000LL;
    char v19 = 0;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    void v9[2] = sub_10015157C;
    v9[3] = &unk_100290690;
    id v10 = a1[6];
    id v11 = a1[7];
    id v12 = WeakRetained;
    id v13 = a1[8];
    id v14 = a1[9];
    id v15 = a1[10];
    p___int128 buf = &buf;
    [WeakRetained dispatchSyncWithReadOnlySQLTransaction:v9];
    if (*(_BYTE *)(*((void *)&buf + 1) + 24LL)
      && ([WeakRetained firstManateeKeyFetched] & 1) == 0
      && [a1[8] isEqualToString:kSecAttrViewHintManatee])
    {
      [WeakRetained setFirstManateeKeyFetched:1];
      [WeakRetained sendMetricForFirstManateeAccess];
    }

    _Block_object_dispose(&buf, 8);
  }
}

void sub_10015155C(_Unwind_Exception *a1)
{
}

void sub_10015157C(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@-%@",  *(void *)(a1 + 32),  *(void *)(a1 + 40)));
  if (qword_1002DEB70 != -1) {
    dispatch_once(&qword_1002DEB70, &stru_10028EFA8);
  }
  if (byte_1002DEB68)
  {
    id v3 = sub_10001267C("ckkspersona");
    id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) personaAdapter]);
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 currentThreadPersonaUniqueString]);
      id v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) operationDependencies]);
      uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 activeAccount]);
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 personaUniqueString]);
      uint64_t v10 = *(void *)(a1 + 56);
      *(_DWORD *)__int128 buf = 138413058;
      __int128 v37 = v6;
      __int16 v38 = 2112;
      __int128 v39 = v9;
      __int16 v40 = 2112;
      uint64_t v41 = v2;
      __int16 v42 = 2112;
      uint64_t v43 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "getCurrentItemForAccessGroup: thread persona [%@/%@] this currentIdentifier [%@] viewhint [%@]",  buf,  0x2Au);
    }
  }

  id v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) operationDependencies]);
  id v12 = (void *)objc_claimAutoreleasedReturnValue([v11 contextID]);
  uint64_t v13 = *(void *)(a1 + 64);
  id v35 = 0LL;
  id v14 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSCurrentItemPointer fromDatabase:contextID:state:zoneID:error:]( &OBJC_CLASS___CKKSCurrentItemPointer,  "fromDatabase:contextID:state:zoneID:error:",  v2,  v12,  @"local",  v13,  &v35));
  id v15 = v35;

  if (!v14 || v15)
  {
    id v25 = (void *)objc_claimAutoreleasedReturnValue([v15 domain]);
    if ([v25 isEqualToString:@"securityd"])
    {
      id v26 = [v15 code];

      if (v26 == (id)-25300LL)
      {
        uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) zoneName]);
        id v28 = sub_1000AA6AC(@"ckkscurrent", v27);
        id v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);

        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)__int128 buf = 138412290;
          __int128 v37 = v2;
          _os_log_debug_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEBUG,  "No current item pointer for %@",  buf,  0xCu);
        }

        id v30 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"No current item pointer found for %@",  v2));
        uint64_t v31 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  @"securityd",  -25300LL,  v30));

        id v15 = (id)v31;
LABEL_21:

        (*(void (**)(void))(*(void *)(a1 + 72) + 16LL))();
        goto LABEL_26;
      }
    }

    else
    {
    }

    __int128 v32 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) zoneName]);
    id v33 = sub_1000AA6AC(@"ckkscurrent", v32);
    id v30 = (void *)objc_claimAutoreleasedReturnValue(v33);

    if (os_log_type_enabled((os_log_t)v30, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      __int128 v37 = v2;
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)v30,  OS_LOG_TYPE_ERROR,  "No current item pointer for %@",  buf,  0xCu);
    }

    goto LABEL_21;
  }

  unsigned int v16 = (void *)objc_claimAutoreleasedReturnValue([v14 currentItemUUID]);

  id v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) zoneName]);
  id v18 = sub_1000AA6AC(@"ckkscurrent", v17);
  char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);

  if (v16)
  {
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      __int128 v37 = v14;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEBUG,  "Retrieved current item pointer: %@",  buf,  0xCu);
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL) = 1;
    id v20 = objc_alloc(&OBJC_CLASS___CKKSCurrentItemData);
    id v21 = (void *)objc_claimAutoreleasedReturnValue([v14 currentItemUUID]);
    id v22 = -[CKKSCurrentItemData initWithUUID:](v20, "initWithUUID:", v21);

    id v23 = (void *)objc_claimAutoreleasedReturnValue([v14 storedCKRecord]);
    id v24 = (void *)objc_claimAutoreleasedReturnValue([v23 modificationDate]);
    -[CKKSCurrentItemData setModificationDate:](v22, "setModificationDate:", v24);

    (*(void (**)(void, CKKSCurrentItemData *, void))(*(void *)(a1 + 72) + 16LL))( *(void *)(a1 + 72),  v22,  0LL);
  }

  else
  {
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      __int128 v37 = v14;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Current item pointer is empty %@", buf, 0xCu);
    }

    uint64_t v34 = *(void *)(a1 + 72);
    id v22 = (CKKSCurrentItemData *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  @"CKKSErrorDomain",  -67671LL,  @"Current item pointer is empty"));
    (*(void (**)(uint64_t, void, CKKSCurrentItemData *))(v34 + 16))(v34, 0LL, v22);
  }

  id v15 = 0LL;
LABEL_26:
}

void sub_100151AC8(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) error]);

  id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 zoneName]);
  id v5 = sub_1000AA6AC(@"ckkscurrent", v4);
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);

  if (v2)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) error]);
      int v10 = 138412290;
      id v11 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "Failed deleting current item pointers: %@",  (uint8_t *)&v10,  0xCu);
    }
  }

  else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v10) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Finished deleting current item pointers",  (uint8_t *)&v10,  2u);
  }

  uint64_t v8 = *(void *)(a1 + 48);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) error]);
  (*(void (**)(uint64_t, void *))(v8 + 16))(v8, v9);
}

void sub_100151C38(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) error]);

  id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 zoneName]);
  id v5 = sub_1000AA6AC(@"ckkscurrent", v4);
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);

  if (v2)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) currentPointerIdentifier]);
      uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) error]);
      int v11 = 138412546;
      id v12 = v7;
      __int16 v13 = 2112;
      id v14 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "Failed setting a current item pointer for %@ with %@",  (uint8_t *)&v11,  0x16u);

LABEL_6:
    }
  }

  else if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) currentPointerIdentifier]);
    int v11 = 138412290;
    id v12 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Finished setting a current item pointer for %@",  (uint8_t *)&v11,  0xCu);
    goto LABEL_6;
  }

  uint64_t v9 = *(void *)(a1 + 48);
  int v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) error]);
  (*(void (**)(uint64_t, void *))(v9 + 16))(v9, v10);
}

void sub_100151DE4(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 syncingPolicy]);

  if (v3)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  }

  else
  {
    id v4 = sub_1000AA6AC(@"ckks", 0LL);
    id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(void *)(a1 + 48);
      int v7 = 138477827;
      uint64_t v8 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "No policy configured. Skipping item: %{private}@",  (uint8_t *)&v7,  0xCu);
    }

    [*(id *)(a1 + 32) setItemModificationsBeforePolicyLoaded:1];
  }

uint64_t sub_100151EE4(uint64_t a1)
{
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) notifyViewChangedScheduler]);
  [v1 trigger];

  if ([*(id *)(a1 + 40) accountStatus] != (id)3)
  {
    uint64_t v129 = objc_alloc_init(&OBJC_CLASS___CKKSMemoryKeyCache);
    *(void *)__int128 buf = 0LL;
    __int128 v164 = buf;
    uint64_t v165 = 0x3032000000LL;
    __int128 v166 = sub_10014BED0;
    __int128 v167 = sub_10014BEE0;
    id v168 = 0LL;
    if (*(_BYTE *)(a1 + 96))
    {
      int v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) personaAdapter]);
      v157[0] = _NSConcreteStackBlock;
      v157[1] = 3221225472LL;
      v157[2] = sub_100152F94;
      v157[3] = &unk_100290618;
      uint64_t v12 = *(void *)(a1 + 64);
      id v160 = buf;
      uint64_t v162 = v12;
      __int16 v13 = v157;
      *(_OWORD *)uint64_t v130 = *(_OWORD *)(a1 + 32);
      id v14 = v130[0];
      int8x16_t v158 = vextq_s8(*(int8x16_t *)v130, *(int8x16_t *)v130, 8uLL);
      id v15 = v129;
      uint64_t v16 = *(void *)(a1 + 56);
      __int128 v159 = v15;
      uint64_t v161 = v16;
      [v11 performBlockWithPersonaIdentifier:0 block:v157];
    }

    else if (*(_BYTE *)(a1 + 97))
    {
      int v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) personaAdapter]);
      v151[0] = _NSConcreteStackBlock;
      v151[1] = 3221225472LL;
      v151[2] = sub_100153070;
      v151[3] = &unk_100290618;
      uint64_t v17 = *(void *)(a1 + 72);
      id v154 = buf;
      uint64_t v156 = v17;
      __int16 v13 = v151;
      *(_OWORD *)id v131 = *(_OWORD *)(a1 + 32);
      id v18 = v131[0];
      int8x16_t v152 = vextq_s8(*(int8x16_t *)v131, *(int8x16_t *)v131, 8uLL);
      char v19 = v129;
      uint64_t v20 = *(void *)(a1 + 56);
      __int128 v153 = v19;
      uint64_t v155 = v20;
      [v11 performBlockWithPersonaIdentifier:0 block:v151];
    }

    else
    {
      if (!*(_BYTE *)(a1 + 98))
      {
        __int128 v110 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
        __int128 v111 = (void *)objc_claimAutoreleasedReturnValue([v110 zoneName]);
        id v112 = sub_1000AA6AC(@"ckks", v111);
        uint64_t v68 = (os_log_s *)objc_claimAutoreleasedReturnValue(v112);

        if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
        {
          __int128 v113 = *(void **)(a1 + 64);
          __int128 v114 = *(void **)(a1 + 72);
          *(_DWORD *)__int128 v169 = 138478083;
          __int128 v170 = v113;
          __int16 v171 = 2113;
          __int128 v172 = v114;
          _os_log_impl( (void *)&_mh_execute_header,  v68,  OS_LOG_TYPE_ERROR,  "processKeychainEventItemAdded given garbage: %{private}@ %{private}@",  v169,  0x16u);
        }

        goto LABEL_43;
      }

      int v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) personaAdapter]);
      v145[0] = _NSConcreteStackBlock;
      v145[1] = 3221225472LL;
      v145[2] = sub_10015314C;
      v145[3] = &unk_100290618;
      uint64_t v21 = *(void *)(a1 + 64);
      __int128 v148 = buf;
      uint64_t v150 = v21;
      __int16 v13 = v145;
      *(_OWORD *)v132 = *(_OWORD *)(a1 + 32);
      id v22 = v132[0];
      int8x16_t v146 = vextq_s8(*(int8x16_t *)v132, *(int8x16_t *)v132, 8uLL);
      id v23 = v129;
      uint64_t v24 = *(void *)(a1 + 56);
      __int128 v147 = v23;
      uint64_t v149 = v24;
      [v11 performBlockWithPersonaIdentifier:0 block:v145];
    }

    id v25 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) operationDependencies]);
    id v26 = (void *)objc_claimAutoreleasedReturnValue([v25 syncingPolicy]);
    uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
    id v28 = (void *)objc_claimAutoreleasedReturnValue([v27 zoneName]);
    unsigned __int8 v29 = [v26 isSyncingEnabledForView:v28];

    if ((v29 & 1) == 0)
    {
      id v30 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSViewManager manager](&OBJC_CLASS___CKKSViewManager, "manager"));
      uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v164 + 5) uuid]);
      __int128 v32 = (void (**)(void, void, void))objc_claimAutoreleasedReturnValue([v30 claimCallbackForUUID:v31]);

      if (v32)
      {
        id v33 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  @"CKKSErrorDomain",  55LL,  @"View is paused; item is not expected to sync"));
        ((void (**)(void, void, void *))v32)[2](v32, 0LL, v33);
      }
    }

    uint64_t v34 = a1;
    if (*(void *)(a1 + 80)) {
      id v35 = @"keychain-api-use";
    }
    else {
      id v35 = @"sos-incoming-item";
    }
    uint64_t v36 = objc_claimAutoreleasedReturnValue(+[CKOperationGroup CKKSGroupWithName:](&OBJC_CLASS___CKOperationGroup, "CKKSGroupWithName:", v35));
    uint64_t v37 = *(void *)(*(void *)(a1 + 56) + 8LL);
    uint64_t v128 = (os_log_s *)v36;
    if (*(void *)(v37 + 40))
    {
      __int16 v38 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
      __int128 v39 = (void *)objc_claimAutoreleasedReturnValue([v38 zoneName]);
      id v40 = sub_1000AA6AC(@"ckks", v39);
      uint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue(v40);

      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        __int16 v42 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
        *(_DWORD *)__int128 v169 = 138412290;
        __int128 v170 = v42;
        _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_ERROR,  "Couldn't create outgoing queue entry: %@",  v169,  0xCu);
      }

      uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) stateMachine]);
      [v43 _onqueueHandleFlag:@"dropped_items"];

      id v44 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) domain]);
      if ([v44 isEqualToString:@"CKKSErrorDomain"])
      {
        BOOL v45 = [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) code] == (id)-25300;

        if (!v45)
        {
LABEL_42:
          uint64_t v68 = v128;
LABEL_43:

          _Block_object_dispose(buf, 8);
          goto LABEL_44;
        }

        id v46 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) stateMachine]);
        [v46 _onqueueHandleFlag:@"key_process_requested"];
        id v47 = v46;
LABEL_41:

        goto LABEL_42;
      }

void sub_100152F14( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
}

void sub_100152F94(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 contextID]);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v7 = *(void *)(*(void *)(a1 + 64) + 8LL);
  id obj = *(id *)(v7 + 40);
  uint64_t v8 = objc_claimAutoreleasedReturnValue( +[CKKSOutgoingQueueEntry withItem:action:contextID:zoneID:keyCache:error:]( &OBJC_CLASS___CKKSOutgoingQueueEntry,  "withItem:action:contextID:zoneID:keyCache:error:",  v2,  @"add",  v4,  v5,  v6,  &obj));
  objc_storeStrong((id *)(v7 + 40), obj);
  uint64_t v9 = *(void *)(*(void *)(a1 + 56) + 8LL);
  int v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v8;
}

void sub_100153070(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 contextID]);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v7 = *(void *)(*(void *)(a1 + 64) + 8LL);
  id obj = *(id *)(v7 + 40);
  uint64_t v8 = objc_claimAutoreleasedReturnValue( +[CKKSOutgoingQueueEntry withItem:action:contextID:zoneID:keyCache:error:]( &OBJC_CLASS___CKKSOutgoingQueueEntry,  "withItem:action:contextID:zoneID:keyCache:error:",  v2,  @"delete",  v4,  v5,  v6,  &obj));
  objc_storeStrong((id *)(v7 + 40), obj);
  uint64_t v9 = *(void *)(*(void *)(a1 + 56) + 8LL);
  int v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v8;
}

void sub_10015314C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 contextID]);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v7 = *(void *)(*(void *)(a1 + 64) + 8LL);
  id obj = *(id *)(v7 + 40);
  uint64_t v8 = objc_claimAutoreleasedReturnValue( +[CKKSOutgoingQueueEntry withItem:action:contextID:zoneID:keyCache:error:]( &OBJC_CLASS___CKKSOutgoingQueueEntry,  "withItem:action:contextID:zoneID:keyCache:error:",  v2,  @"modify",  v4,  v5,  v6,  &obj));
  objc_storeStrong((id *)(v7 + 40), obj);
  uint64_t v9 = *(void *)(*(void *)(a1 + 56) + 8LL);
  int v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v8;
}

void sub_100153228(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v5 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 currentTrustStates]);

  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 databaseProvider]);
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472LL;
  v16[2] = sub_10015340C;
  v16[3] = &unk_100290578;
  v16[4] = WeakRetained;
  id v10 = v6;
  id v17 = v10;
  id v11 = v7;
  id v18 = v11;
  [v9 dispatchSyncWithReadOnlySQLTransaction:v16];

  if ([v11 count])
  {
    id v12 = sub_1000AA6AC(@"ckkskey", 0LL);
    __int16 v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      id v20 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Resetting zones due to missing TLKs: %@",  buf,  0xCu);
    }

    id v14 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
    [v14 operateOnSelectViews:v11];

    id v15 = off_100290538;
  }

  else
  {
    id v15 = (__CFString **)(a1 + 32);
  }

  [v3 setNextState:*v15];
}

void sub_10015340C(uint64_t a1)
{
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([v1 activeManagedViews]);

  id v3 = [v2 countByEnumeratingWithState:&v33 objects:v39 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v34;
    do
    {
      uint64_t v6 = 0LL;
      do
      {
        if (*(void *)v34 != v5) {
          objc_enumerationMutation(v2);
        }
        uint64_t v7 = *(void **)(*((void *)&v33 + 1) + 8LL * (void)v6);
        uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 viewKeyHierarchyState]);
        unsigned int v9 = [v8 isEqualToString:@"tlkmissing"];

        if (v9)
        {
          id v10 = (void *)objc_claimAutoreleasedReturnValue([v7 zoneID]);
          id v11 = (void *)objc_claimAutoreleasedReturnValue([v7 contextID]);
          id v12 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSCurrentKeySet loadForZone:contextID:]( &OBJC_CLASS___CKKSCurrentKeySet,  "loadForZone:contextID:",  v10,  v11));

          __int16 v13 = (void *)objc_claimAutoreleasedReturnValue([v12 error]);
          if (v13)
          {
            id v14 = (void *)objc_claimAutoreleasedReturnValue([v7 zoneID]);
            id v15 = (void *)objc_claimAutoreleasedReturnValue([v14 zoneName]);
            id v16 = sub_1000AA6AC(@"ckkskey", v15);
            id v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);

            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            {
              id v18 = (void *)objc_claimAutoreleasedReturnValue([v12 error]);
              *(_DWORD *)__int128 buf = 138412290;
              __int16 v38 = v18;
              _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Unable to load keyset: %@", buf, 0xCu);
            }

            char v19 = @"error";
          }

          else
          {
            id v20 = (void *)objc_claimAutoreleasedReturnValue([v12 currentTLKPointer]);
            uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v20 currentKeyUUID]);

            if (v21)
            {
              if ([*(id *)(a1 + 32) trustStatus] == (id)1)
              {
                unsigned __int8 v22 = [*(id *)(a1 + 32) _onqueueOtherDevicesReportHavingTLKs:v12 trustStates:*(void *)(a1 + 40)];
                char v19 = @"waitfortlk";
                if ((v22 & 1) == 0)
                {
                  id v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "zoneID", @"waitfortlk"));
                  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v23 zoneName]);
                  id v25 = sub_1000AA6AC(@"ckkskey", v24);
                  id v26 = (os_log_s *)objc_claimAutoreleasedReturnValue(v25);

                  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)__int128 buf = 0;
                    _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "No other devices claim to have the TLK. Resetting zone...",  buf,  2u);
                  }

                  [*(id *)(a1 + 48) addObject:v7];
                  char v19 = @"resetzone";
                }
              }

              else
              {
                uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v7 zoneID]);
                id v28 = (void *)objc_claimAutoreleasedReturnValue([v27 zoneName]);
                id v29 = sub_1000AA6AC(@"ckkskey", v28);
                id v30 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);

                if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)__int128 buf = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "TLK is missing, but no trust is present.",  buf,  2u);
                }

                char v19 = @"waitfortrust";
              }
            }

            else
            {
              char v19 = @"waitfortlkcreation";
            }
          }

          [v7 setViewKeyHierarchyState:v19];
        }

        uint64_t v6 = (char *)v6 + 1;
      }

      while (v4 != v6);
      id v31 = [v2 countByEnumeratingWithState:&v33 objects:v39 count:16];
      id v4 = v31;
    }

    while (v31);
  }
}

void sub_1001537D8(uint64_t a1, void *a2)
{
  id v17 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if ([WeakRetained trustStatus] == (id)1)
  {
    [WeakRetained setTrustStatus:0];
    id v3 = objc_alloc_init(&OBJC_CLASS___CKKSCondition);
    [WeakRetained setTrustStatusKnown:v3];
  }

  __int128 v21 = 0u;
  __int128 v22 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  id v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "operationDependencies", a1, v17, 0));
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v4 views]);

  id v6 = [v5 countByEnumeratingWithState:&v19 objects:v23 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v20;
    do
    {
      for (CFIndex i = 0LL; i != v7; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v20 != v8) {
          objc_enumerationMutation(v5);
        }
        id v10 = *(void **)(*((void *)&v19 + 1) + 8LL * (void)i);
        id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 viewKeyHierarchyState]);
        unsigned int v12 = [v11 isEqualToString:@"ready"];

        if (v12) {
          [v10 setViewKeyHierarchyState:@"waitfortrust"];
        }
      }

      id v7 = [v5 countByEnumeratingWithState:&v19 objects:v23 count:16];
    }

    while (v7);
  }

  __int16 v13 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained priorityViewsProcessed]);
  id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  @"CKKSErrorDomain",  52LL,  @"Trust not present"));
  [v13 completeWithErrorIfPending:v14];

  [v18 setNextState:*(void *)(v16 + 32)];
}

void sub_1001539D8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472LL;
  v22[2] = sub_100153C2C;
  v22[3] = &unk_100290578;
  void v22[4] = WeakRetained;
  id v5 = v3;
  id v23 = v5;
  id v24 = *(id *)(a1 + 32);
  [WeakRetained dispatchSyncWithReadOnlySQLTransaction:v22];
  id v6 = (id)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
  if ([v6 sendMetric])
  {

    id v7 = (void *)objc_claimAutoreleasedReturnValue(+[OTManager manager](&OBJC_CLASS___OTManager, "manager"));
    id v8 = objc_alloc(&OBJC_CLASS___OTControlArguments);
    unsigned int v9 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
    id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 activeAccount]);
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 altDSID]);
    id v12 = [v8 initWithAltDSID:v11];
    id v21 = 0LL;
    unsigned int v13 = [v7 persistSendingMetricsPermitted:v12 sendingMetricsPermitted:0 error:&v21];
    id v6 = v21;

    if (!v13 || v6)
    {
      id v20 = sub_1000AA6AC(@"ckks", 0LL);
      id v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        id v26 = v6;
        uint64_t v16 = "Error persisting sendingMetricsPermitted value: %@";
        id v17 = v15;
        os_log_type_t v18 = OS_LOG_TYPE_ERROR;
        uint32_t v19 = 12;
        goto LABEL_8;
      }
    }

    else
    {
      id v14 = sub_10001267C("ckks");
      id v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        uint64_t v16 = "Successfully persisted state to disable metrics";
        id v17 = v15;
        os_log_type_t v18 = OS_LOG_TYPE_DEFAULT;
        uint32_t v19 = 2;
LABEL_8:
        _os_log_impl((void *)&_mh_execute_header, v17, v18, v16, buf, v19);
      }
    }
  }
}

void sub_100153C2C(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 readyAndSyncingViews]);

  __int128 v356 = 0u;
  __int128 v357 = 0u;
  __int128 v354 = 0u;
  __int128 v355 = 0u;
  id v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) operationDependencies]);
  id v5 = (NSDateComponents *)objc_claimAutoreleasedReturnValue([v4 views]);

  id v6 = v5;
  id v7 = -[NSDateComponents countByEnumeratingWithState:objects:count:]( v5,  "countByEnumeratingWithState:objects:count:",  &v354,  v371,  16LL);
  uint64_t v310 = v1;
  v306 = v3;
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v355;
    do
    {
      for (CFIndex i = 0LL; i != v8; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v355 != v9) {
          objc_enumerationMutation(v6);
        }
        id v11 = *(NSDateComponents **)(*((void *)&v354 + 1) + 8LL * (void)i);
        id v12 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) operationDependencies]);
        unsigned int v13 = (void *)objc_claimAutoreleasedReturnValue([v12 contextID]);
        id v14 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateComponents zoneName](v11, "zoneName"));
        id v15 = (__CFString *)objc_claimAutoreleasedReturnValue( +[CKKSZoneStateEntry contextID:zoneName:]( &OBJC_CLASS___CKKSZoneStateEntry,  "contextID:zoneName:",  v13,  v14));

        if (!-[__CFString ckzonecreated](v15, "ckzonecreated")
          || (-[__CFString ckzonesubscribed](v15, "ckzonesubscribed") & 1) == 0)
        {
          uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateComponents zoneID](v11, "zoneID"));
          id v69 = (void *)objc_claimAutoreleasedReturnValue([v68 zoneName]);
          id v70 = sub_1000AA6AC(@"ckkszone", v69);
          id v71 = (os_log_s *)objc_claimAutoreleasedReturnValue(v70);

          if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138412546;
            v368 = v11;
            __int16 v369 = 2112;
            v370 = v15;
            _os_log_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_DEFAULT,  "Zone does not yet exist: %@ %@",  buf,  0x16u);
          }

          [*(id *)(v310 + 40) setNextState:@"initializing"];
          id v3 = v306;
          goto LABEL_54;
        }

        uint64_t v1 = v310;
      }

      id v8 = -[NSDateComponents countByEnumeratingWithState:objects:count:]( v6,  "countByEnumeratingWithState:objects:count:",  &v354,  v371,  16LL);
      id v3 = v306;
    }

    while (v8);
  }

  __int128 v352 = 0u;
  __int128 v353 = 0u;
  __int128 v350 = 0u;
  __int128 v351 = 0u;
  uint64_t v16 = v3;
  id v17 = -[NSDateComponents countByEnumeratingWithState:objects:count:]( v16,  "countByEnumeratingWithState:objects:count:",  &v350,  v366,  16LL);
  if (v17)
  {
    p_superclass = &OBJC_CLASS___CKKSProcessReceivedKeysOperation.superclass;
    uint64_t v19 = *(void *)v351;
    v297 = v16;
    uint64_t v287 = *(void *)v351;
    do
    {
      uint64_t v20 = 0LL;
      id v289 = v17;
      do
      {
        if (*(void *)v351 != v19) {
          objc_enumerationMutation(v16);
        }
        uint64_t v294 = v20;
        id v21 = *(void **)(*((void *)&v350 + 1) + 8 * v20);
        __int128 v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) operationDependencies]);
        id v23 = (void *)objc_claimAutoreleasedReturnValue([v22 contextID]);
        id v24 = (void *)objc_claimAutoreleasedReturnValue([v21 zoneID]);
        id v349 = 0LL;
        id v25 = (NSDateComponents *)objc_claimAutoreleasedReturnValue( [p_superclass + 4 countNewEntriesByKeyWithContextID:v23 zoneID:v24 error:&v349]);
        id v300 = v349;

        if (-[NSDateComponents count](v25, "count"))
        {
          id v26 = (void *)objc_claimAutoreleasedReturnValue([v21 zoneID]);
          uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v26 zoneName]);
          id v28 = sub_1000AA6AC(@"ckksincoming", v27);
          id v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);

          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138412290;
            v368 = v25;
            _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "Incoming Queue item counts: %@",  buf,  0xCu);
          }
        }

        __int128 v347 = 0u;
        __int128 v348 = 0u;
        __int128 v345 = 0u;
        __int128 v346 = 0u;
        id v30 = v25;
        id v31 = -[NSDateComponents countByEnumeratingWithState:objects:count:]( v30,  "countByEnumeratingWithState:objects:count:",  &v345,  v365,  16LL);
        if (v31)
        {
          id v32 = v31;
          uint64_t v33 = *(void *)v346;
          id obj = v30;
          do
          {
            for (j = 0LL; j != v32; j = (char *)j + 1)
            {
              if (*(void *)v346 != v33) {
                objc_enumerationMutation(obj);
              }
              __int128 v35 = *(NSDateComponents **)(*((void *)&v345 + 1) + 8LL * (void)j);
              __int128 v36 = (void *)objc_claimAutoreleasedReturnValue([v21 contextID]);
              uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([v21 zoneID]);
              id v344 = 0LL;
              __int16 v38 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSKey fromDatabase:contextID:zoneID:error:]( &OBJC_CLASS___CKKSKey,  "fromDatabase:contextID:zoneID:error:",  v35,  v36,  v37,  &v344));
              __int128 v39 = (__CFString *)v344;

              if (v38) {
                BOOL v40 = v39 == 0LL;
              }
              else {
                BOOL v40 = 0;
              }
              if (v40)
              {
                BOOL v45 = (void *)objc_claimAutoreleasedReturnValue([v38 keyclass]);
                if (([v45 isEqualToString:@"classA"] & 1) == 0)
                {

LABEL_52:
                  [*(id *)(v310 + 40) setNextState:@"process_incoming_queue"];

                  id v3 = v306;
                  id v30 = obj;
                  id v56 = obj;
                  id v6 = v297;
LABEL_53:

                  goto LABEL_54;
                }

                id v46 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v310 + 32) lockStateTracker]);
                unsigned int v47 = [v46 isLocked];

                if (!v47) {
                  goto LABEL_52;
                }
                id v48 = (void *)objc_claimAutoreleasedReturnValue([v21 zoneID]);
                id v49 = (void *)objc_claimAutoreleasedReturnValue([v48 zoneName]);
                id v50 = sub_1000AA6AC(@"ckksincoming", v49);
                signed int v51 = (os_log_s *)objc_claimAutoreleasedReturnValue(v50);

                if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)__int128 buf = 0;
                  _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEFAULT,  "Have pending classA items for view, but device is locked",  buf,  2u);
                }

                id v44 = -[OctagonPendingFlag initWithFlag:conditions:]( objc_alloc(&OBJC_CLASS___OctagonPendingFlag),  "initWithFlag:conditions:",  @"check_queues",  1LL);
                id v52 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v310 + 32) stateMachine]);
                [v52 _onqueueHandlePendingFlagLater:v44];
              }

              else
              {
                uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v21 zoneID]);
                __int16 v42 = (void *)objc_claimAutoreleasedReturnValue([v41 zoneName]);
                id v43 = sub_1000AA6AC(@"ckksincoming", v42);
                id v44 = (OctagonPendingFlag *)objc_claimAutoreleasedReturnValue(v43);

                if (os_log_type_enabled((os_log_t)v44, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)__int128 buf = 138412546;
                  v368 = v35;
                  __int16 v369 = 2112;
                  v370 = v39;
                  _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)v44,  OS_LOG_TYPE_ERROR,  "Unable to load key for %@: %@",  buf,  0x16u);
                }
              }
            }

            id v30 = obj;
            id v32 = -[NSDateComponents countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v345,  v365,  16LL);
          }

          while (v32);
        }

        id v53 = (void *)objc_claimAutoreleasedReturnValue([v21 contextID]);
        id v54 = (void *)objc_claimAutoreleasedReturnValue([v21 zoneID]);
        id v343 = 0LL;
        uint64_t v55 = +[CKKSCurrentItemPointer countByState:contextID:zone:error:]( &OBJC_CLASS___CKKSCurrentItemPointer,  "countByState:contextID:zone:error:",  @"new",  v53,  v54,  &v343);
        id v56 = (NSDateComponents *)v343;

        if (v55 >= 1)
        {
          id v191 = (void *)objc_claimAutoreleasedReturnValue([v21 zoneID]);
          id v192 = (void *)objc_claimAutoreleasedReturnValue([v191 zoneName]);
          id v193 = sub_1000AA6AC(@"ckksincoming", v192);
          id v194 = (os_log_s *)objc_claimAutoreleasedReturnValue(v193);

          id v3 = v306;
          id v6 = v297;
          if (os_log_type_enabled(v194, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 67109120;
            LODWORD(v36_Block_object_dispose((const void *)(v1 - 80), 8) = v55;
            _os_log_impl( (void *)&_mh_execute_header,  v194,  OS_LOG_TYPE_DEFAULT,  "Incoming Queue CIP count: %d",  buf,  8u);
          }

          [*(id *)(v310 + 40) setNextState:@"process_incoming_queue"];
          goto LABEL_53;
        }

        id v57 = v30;
        id v3 = v306;
        uint64_t v1 = v310;
        uint64_t v16 = v297;
        if (v56)
        {
          id v58 = (void *)objc_claimAutoreleasedReturnValue([v21 zoneID]);
          id v59 = (void *)objc_claimAutoreleasedReturnValue([v58 zoneName]);
          id v60 = sub_1000AA6AC(@"ckksincoming", v59);
          __int128 v61 = (os_log_s *)objc_claimAutoreleasedReturnValue(v60);

          if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 138412290;
            v368 = v56;
            _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "Unable to count CIPs: %@", buf, 0xCu);
          }
        }

        uint64_t v20 = v294 + 1;
        p_superclass = (__objc2_class **)(&OBJC_CLASS___CKKSProcessReceivedKeysOperation + 8);
        uint64_t v19 = v287;
      }

      while ((id)(v294 + 1) != v289);
      id v17 = -[NSDateComponents countByEnumeratingWithState:objects:count:]( v297,  "countByEnumeratingWithState:objects:count:",  &v350,  v366,  16LL);
    }

    while (v17);
  }

  uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) operationDependencies]);
  id v63 = (void *)objc_claimAutoreleasedReturnValue([v62 allViews]);
  id v6 = (NSDateComponents *)[v63 mutableCopy];

  id v64 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) operationDependencies]);
  id v65 = (void *)objc_claimAutoreleasedReturnValue([v64 views]);
  -[NSDateComponents minusSet:](v6, "minusSet:", v65);

  if (-[NSDateComponents count](v6, "count"))
  {
    id v66 = sub_1000AA6AC(@"ckkszone", 0LL);
    int v67 = (os_log_s *)objc_claimAutoreleasedReturnValue(v66);
    if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      v368 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v67,  OS_LOG_TYPE_DEFAULT,  "Beginning again to include these views: %@",  buf,  0xCu);
    }

    [*(id *)(v1 + 40) setNextState:@"handle_all_views"];
    goto LABEL_54;
  }

  v283 = v6;
  id v72 = objc_alloc(&OBJC_CLASS___AAFAnalyticsEventSecurity);
  id v73 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 32) operationDependencies]);
  id v74 = (void *)objc_claimAutoreleasedReturnValue([v73 activeAccount]);
  id v75 = (void *)objc_claimAutoreleasedReturnValue([v74 altDSID]);
  uint64_t v76 = kSecurityRTCEventNameLocalSyncFinish;
  char v77 = v16;
  uint64_t v78 = kSecurityRTCEventCategoryAccountDataAccessRecovery;
  int v79 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v310 + 32) operationDependencies]);
  id v80 = [v79 sendMetric];
  uint64_t v81 = v76;
  uint64_t v82 = v310;
  uint64_t v282 = v78;
  id v83 = -[AAFAnalyticsEventSecurity initWithCKKSMetrics:altDSID:eventName:testsAreEnabled:category:sendMetric:]( v72,  "initWithCKKSMetrics:altDSID:eventName:testsAreEnabled:category:sendMetric:",  &__NSDictionary0__struct,  v75,  v81,  0LL,  v78,  v80);

  v284 = v83;
  +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:]( &OBJC_CLASS___SecurityAnalyticsReporterRTC,  "sendMetricWithEvent:success:error:",  v83,  1LL,  0LL);
  __int128 v341 = 0u;
  __int128 v342 = 0u;
  __int128 v339 = 0u;
  __int128 v340 = 0u;
  id v84 = v77;
  id v290 = -[NSDateComponents countByEnumeratingWithState:objects:count:]( v84,  "countByEnumeratingWithState:objects:count:",  &v339,  v364,  16LL);
  v285 = v84;
  if (v290)
  {
    uint64_t v292 = *(void *)v340;
    do
    {
      uint64_t v85 = 0LL;
      do
      {
        if (*(void *)v340 != v292) {
          objc_enumerationMutation(v84);
        }
        uint64_t v295 = v85;
        uint64_t v86 = *(NSDateComponents **)(*((void *)&v339 + 1) + 8 * v85);
        v87 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v82 + 32) operationDependencies]);
        id v88 = (void *)objc_claimAutoreleasedReturnValue([v87 contextID]);
        uint64_t v89 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateComponents zoneID](v86, "zoneID"));
        id v338 = 0LL;
        v298 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSOutgoingQueueEntry allInState:contextID:zoneID:error:]( &OBJC_CLASS___CKKSOutgoingQueueEntry,  "allInState:contextID:zoneID:error:",  @"reencrypt",  v88,  v89,  &v338));
        uint64_t v90 = (NSDateComponents *)v338;

        v301 = v90;
        if (v90)
        {
          id v91 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateComponents zoneID](v86, "zoneID"));
          id v92 = (void *)objc_claimAutoreleasedReturnValue([v91 zoneName]);
          id v93 = sub_1000AA6AC(@"ckks", v92);
          id v94 = (os_log_s *)objc_claimAutoreleasedReturnValue(v93);

          if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 138412290;
            v368 = v301;
            _os_log_impl( (void *)&_mh_execute_header,  v94,  OS_LOG_TYPE_ERROR,  "Couldn't count reencrypt OQEs, bad behavior ahead: %@",  buf,  0xCu);
          }
        }

        id v95 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateComponents viewKeyHierarchyState](v86, "viewKeyHierarchyState"));
        unsigned __int8 v96 = [v95 isEqualToString:@"ready"];

        if ((v96 & 1) != 0)
        {
          id v97 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v310 + 32) operationDependencies]);
          uint64_t v98 = (void *)objc_claimAutoreleasedReturnValue([v97 syncingPolicy]);
          uint64_t v99 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateComponents zoneID](v86, "zoneID"));
          __int128 v100 = (void *)objc_claimAutoreleasedReturnValue([v99 zoneName]);
          unsigned __int8 v101 = [v98 isSyncingEnabledForView:v100];

          if ((v101 & 1) != 0)
          {
            __int128 v102 = v298;
            uint64_t v82 = v310;
            if (![v298 count]) {
              goto LABEL_94;
            }
            __int128 v336 = 0u;
            __int128 v337 = 0u;
            __int128 v334 = 0u;
            __int128 v335 = 0u;
            obja = v298;
            id v103 = -[NSDateComponents countByEnumeratingWithState:objects:count:]( obja,  "countByEnumeratingWithState:objects:count:",  &v334,  v363,  16LL);
            if (v103)
            {
              id v104 = v103;
              uint64_t v302 = *(void *)v335;
              while (1)
              {
                for (k = 0LL; k != v104; k = (char *)k + 1)
                {
                  if (*(void *)v335 != v302) {
                    objc_enumerationMutation(obja);
                  }
                  id v106 = *(void **)(*((void *)&v334 + 1) + 8LL * (void)k);
                  __int128 v107 = (void *)objc_claimAutoreleasedReturnValue([v106 item]);
                  __int128 v108 = (void *)objc_claimAutoreleasedReturnValue([v107 parentKeyUUID]);
                  __int128 v109 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateComponents contextID](v86, "contextID"));
                  __int128 v110 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateComponents zoneID](v86, "zoneID"));
                  id v333 = 0LL;
                  __int128 v111 = (__CFString *)objc_claimAutoreleasedReturnValue( +[CKKSKey fromDatabase:contextID:zoneID:error:]( &OBJC_CLASS___CKKSKey,  "fromDatabase:contextID:zoneID:error:",  v108,  v109,  v110,  &v333));
                  id v112 = (__CFString *)v333;

                  __int128 v113 = v111;
                  if (v111) {
                    BOOL v114 = v112 == 0LL;
                  }
                  else {
                    BOOL v114 = 0;
                  }
                  if (v114)
                  {
                    __int16 v121 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString keyclass](v111, "keyclass"));
                    if (([v121 isEqualToString:@"classA"] & 1) == 0)
                    {

LABEL_113:
                      [*(id *)(v310 + 40) setNextState:@"reencrypt_outgoing_items"];
                      id v3 = v306;
                      uint64_t v161 = obja;
                      __int128 v153 = obja;
                      id v6 = v283;
                      uint64_t v162 = v285;
                      goto LABEL_210;
                    }

                    id v122 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v310 + 32) lockStateTracker]);
                    unsigned int v123 = [v122 isLocked];

                    if (!v123) {
                      goto LABEL_113;
                    }
                    id v124 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateComponents zoneID](v86, "zoneID"));
                    __int16 v125 = (void *)objc_claimAutoreleasedReturnValue([v124 zoneName]);
                    id v126 = sub_1000AA6AC(@"ckksoutgoing", v125);
                    id v127 = (os_log_s *)objc_claimAutoreleasedReturnValue(v126);

                    if (os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)__int128 buf = 0;
                      _os_log_impl( (void *)&_mh_execute_header,  v127,  OS_LOG_TYPE_DEFAULT,  "Have items needing re-encryption, but device is locked",  buf,  2u);
                    }

                    id v118 = -[OctagonPendingFlag initWithFlag:conditions:]( objc_alloc(&OBJC_CLASS___OctagonPendingFlag),  "initWithFlag:conditions:",  @"item_reencryption_needed",  1LL);
                    __int128 v119 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v310 + 32) stateMachine]);
                    [v119 _onqueueHandlePendingFlagLater:v118];
                  }

                  else
                  {
                    __int128 v115 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateComponents zoneID](v86, "zoneID"));
                    id v116 = (void *)objc_claimAutoreleasedReturnValue([v115 zoneName]);
                    id v117 = sub_1000AA6AC(@"ckksoutgoing", v116);
                    id v118 = (OctagonPendingFlag *)objc_claimAutoreleasedReturnValue(v117);

                    if (!os_log_type_enabled((os_log_t)v118, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_84;
                    }
                    __int128 v119 = (void *)objc_claimAutoreleasedReturnValue([v106 item]);
                    uint64_t v120 = (NSDateComponents *)objc_claimAutoreleasedReturnValue([v119 parentKeyUUID]);
                    *(_DWORD *)__int128 buf = 138412546;
                    v368 = v120;
                    __int16 v369 = 2112;
                    v370 = v112;
                    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)v118,  OS_LOG_TYPE_ERROR,  "Unable to load key for %@: %@",  buf,  0x16u);
                  }

LABEL_84:
                }

                id v104 = -[NSDateComponents countByEnumeratingWithState:objects:count:]( obja,  "countByEnumeratingWithState:objects:count:",  &v334,  v363,  16LL);
                if (!v104)
                {
                  uint64_t v128 = (os_log_s *)obja;
                  uint64_t v82 = v310;
                  id v84 = v285;
                  goto LABEL_89;
                }
              }
            }

            uint64_t v128 = (os_log_s *)obja;
          }

          else
          {
            v132 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateComponents zoneID](v86, "zoneID"));
            id v133 = (void *)objc_claimAutoreleasedReturnValue([v132 zoneName]);
            id v134 = sub_1000AA6AC(@"ckksincoming", v133);
            uint64_t v128 = (os_log_s *)objc_claimAutoreleasedReturnValue(v134);

            __int128 v102 = v298;
            if (os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int128 buf = 138412290;
              v368 = v86;
              _os_log_impl( (void *)&_mh_execute_header,  v128,  OS_LOG_TYPE_DEFAULT,  "Syncing disabled for (%@): skipping incoming queue processing",  buf,  0xCu);
            }

            uint64_t v82 = v310;
          }
        }

        else
        {
          uint64_t v129 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateComponents zoneID](v86, "zoneID"));
          uint64_t v130 = (void *)objc_claimAutoreleasedReturnValue([v129 zoneName]);
          id v131 = sub_1000AA6AC(@"ckksincoming", v130);
          uint64_t v128 = (os_log_s *)objc_claimAutoreleasedReturnValue(v131);

          uint64_t v82 = v310;
          if (os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138412290;
            v368 = v86;
            _os_log_impl( (void *)&_mh_execute_header,  v128,  OS_LOG_TYPE_DEFAULT,  "Zone not ready (%@): skipping reencryption",  buf,  0xCu);
          }

LABEL_89:
          __int128 v102 = v298;
        }

LABEL_94:
        uint64_t v85 = v295 + 1;
      }

      while ((id)(v295 + 1) != v290);
      id v135 = -[NSDateComponents countByEnumeratingWithState:objects:count:]( v84,  "countByEnumeratingWithState:objects:count:",  &v339,  v364,  16LL);
      id v3 = v306;
      id v290 = v135;
    }

    while (v135);
  }

  uint64_t v136 = objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
  id v137 = objc_alloc_init(&OBJC_CLASS___NSDateComponents);
  -[NSDateComponents setHour:](v137, "setHour:", -24LL);
  __int128 v138 = (void *)objc_claimAutoreleasedReturnValue(+[NSCalendar currentCalendar](&OBJC_CLASS___NSCalendar, "currentCalendar"));
  v301 = v137;
  v281 = (void *)v136;
  uint64_t v288 = objc_claimAutoreleasedReturnValue([v138 dateByAddingComponents:v137 toDate:v136 options:0]);

  __int128 v331 = 0u;
  __int128 v332 = 0u;
  __int128 v329 = 0u;
  __int128 v330 = 0u;
  __int128 v139 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v82 + 32) operationDependencies]);
  __int128 v140 = (NSDateComponents *)objc_claimAutoreleasedReturnValue([v139 views]);

  v291 = v140;
  id v141 = -[NSDateComponents countByEnumeratingWithState:objects:count:]( v140,  "countByEnumeratingWithState:objects:count:",  &v329,  v362,  16LL);
  if (v141)
  {
    id v142 = v141;
    id v143 = v3;
    id v144 = 0LL;
    id v145 = 0LL;
    uint64_t v303 = *(void *)v330;
    do
    {
      for (m = 0LL; m != v142; m = (char *)m + 1)
      {
        objb = v144;
        if (*(void *)v330 != v303) {
          objc_enumerationMutation(v291);
        }
        __int128 v147 = *(void **)(*((void *)&v329 + 1) + 8LL * (void)m);
        __int128 v148 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v82 + 32) operationDependencies]);
        uint64_t v149 = (void *)objc_claimAutoreleasedReturnValue([v148 contextID]);
        uint64_t v150 = (void *)objc_claimAutoreleasedReturnValue([v147 zoneName]);
        __int128 v151 = (__CFString *)objc_claimAutoreleasedReturnValue( +[CKKSZoneStateEntry contextID:zoneName:]( &OBJC_CLASS___CKKSZoneStateEntry,  "contextID:zoneName:",  v149,  v150));

        uint64_t v152 = objc_claimAutoreleasedReturnValue(-[__CFString lastFetchTime](v151, "lastFetchTime"));
        __int128 v153 = (void *)v288;
        if (!v152) {
          goto LABEL_138;
        }
        id v154 = (void *)v152;
        uint64_t v155 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString lastFetchTime](v151, "lastFetchTime"));
        if ([v155 compare:v288] == (id)-1)
        {

LABEL_138:
          id v195 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString lastFetchTime](v151, "lastFetchTime"));

          v286 = v151;
          if (v195)
          {
            unsigned int v196 = -[__CFString moreRecordsInCloudKit](v151, "moreRecordsInCloudKit");
            uint64_t v197 = v310;
            uint64_t v198 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v310 + 32) operationDependencies]);
            char v199 = (void *)objc_claimAutoreleasedReturnValue([v198 currentFetchReasons]);
            timeval v200 = &off_1002912A8;
            if (v196) {
              timeval v200 = off_1002912A0;
            }
          }

          else
          {
            uint64_t v197 = v310;
            uint64_t v198 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v310 + 32) operationDependencies]);
            char v199 = (void *)objc_claimAutoreleasedReturnValue([v198 currentFetchReasons]);
            timeval v200 = off_100291298;
          }

          uint64_t v162 = (NSDateComponents *)v281;
          id v3 = v143;
          [v199 addObject:*v200];

          __int16 v201 = (void *)objc_claimAutoreleasedReturnValue([v147 zoneID]);
          v202 = (void *)objc_claimAutoreleasedReturnValue([v201 zoneName]);
          id v203 = sub_1000AA6AC(@"ckksfetch", v202);
          id v204 = (os_log_s *)objc_claimAutoreleasedReturnValue(v203);

          if (os_log_type_enabled(v204, OS_LOG_TYPE_DEFAULT))
          {
            CFMutableStringRef v205 = (NSDateComponents *)objc_claimAutoreleasedReturnValue(-[__CFString lastFetchTime](v286, "lastFetchTime"));
            unsigned int v206 = -[__CFString moreRecordsInCloudKit](v286, "moreRecordsInCloudKit");
            v207 = @"complete";
            if (v206) {
              v207 = @"more coming";
            }
            *(_DWORD *)__int128 buf = 138412546;
            v368 = v205;
            __int16 v369 = 2112;
            v370 = v207;
            _os_log_impl( (void *)&_mh_execute_header,  v204,  OS_LOG_TYPE_DEFAULT,  "Fetch last occurred at %@ (%@); beginning a new one",
              buf,
              0x16u);
          }

          [*(id *)(v197 + 40) setNextState:@"begin_fetch"];
          id v6 = v283;
          __int128 v113 = v145;
          goto LABEL_209;
        }

        unsigned int v156 = -[__CFString moreRecordsInCloudKit](v151, "moreRecordsInCloudKit");

        if (v156) {
          goto LABEL_138;
        }
        if (!objb
          || (__int128 v157 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString lastFetchTime](v151, "lastFetchTime")),
              id v158 = -[NSDateComponents compare:](objb, "compare:", v157),
              v157,
              v158 == (id)1))
        {
          uint64_t v159 = objc_claimAutoreleasedReturnValue(-[__CFString lastFetchTime](v151, "lastFetchTime"));

          id v160 = v147;
          objb = (NSDateComponents *)v159;
          id v145 = v160;
        }

        uint64_t v82 = v310;

        id v144 = objb;
      }

      id v142 = -[NSDateComponents countByEnumeratingWithState:objects:count:]( v291,  "countByEnumeratingWithState:objects:count:",  &v329,  v362,  16LL);
    }

    while (v142);
  }

  else
  {
    id v144 = 0LL;
    id v145 = 0LL;
  }

  objb = v144;

  id v163 = sub_1000AA6AC(@"ckksfetch", 0LL);
  __int128 v164 = (os_log_s *)objc_claimAutoreleasedReturnValue(v163);
  if (os_log_type_enabled(v164, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412546;
    v368 = objb;
    __int16 v369 = 2112;
    v370 = v145;
    _os_log_impl( (void *)&_mh_execute_header,  v164,  OS_LOG_TYPE_DEFAULT,  "Fetch last occurred at %@ (for %@)",  buf,  0x16u);
  }

  v280 = v145;

  __int128 v327 = 0u;
  __int128 v328 = 0u;
  __int128 v325 = 0u;
  __int128 v326 = 0u;
  uint64_t v165 = v285;
  id v166 = -[NSDateComponents countByEnumeratingWithState:objects:count:]( v165,  "countByEnumeratingWithState:objects:count:",  &v325,  v361,  16LL);
  if (!v166)
  {
    v291 = 0LL;
    v286 = 0LL;
    goto LABEL_149;
  }

  id v167 = v166;
  v291 = 0LL;
  v286 = 0LL;
  uint64_t v168 = *(void *)v326;
LABEL_119:
  __int128 v169 = 0LL;
  while (1)
  {
    if (*(void *)v326 != v168) {
      objc_enumerationMutation(v165);
    }
    __int128 v170 = *(void **)(*((void *)&v325 + 1) + 8LL * (void)v169);
    __int16 v171 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v82 + 32) operationDependencies]);
    __int128 v172 = (void *)objc_claimAutoreleasedReturnValue([v171 contextID]);
    __int16 v173 = (void *)objc_claimAutoreleasedReturnValue([v170 zoneName]);
    id v174 = (id)objc_claimAutoreleasedReturnValue( +[CKKSZoneStateEntry contextID:zoneName:]( &OBJC_CLASS___CKKSZoneStateEntry,  "contextID:zoneName:",  v172,  v173));

    uint64_t v175 = objc_claimAutoreleasedReturnValue([v174 lastLocalKeychainScanTime]);
    if (!v175) {
      break;
    }
    id v176 = (void *)v175;
    __int16 v177 = (void *)objc_claimAutoreleasedReturnValue([v174 lastLocalKeychainScanTime]);
    id v178 = [v177 compare:v288];

    if (v178 == (id)-1LL) {
      break;
    }
    __int16 v179 = v291;
    if (!v291
      || (int v180 = (void *)objc_claimAutoreleasedReturnValue([v174 lastLocalKeychainScanTime]),
          id v181 = -[NSDateComponents compare:](v291, "compare:", v180),
          v180,
          BOOL v40 = v181 == (id)1,
          __int16 v179 = v291,
          v40))
    {
      uint64_t v182 = objc_claimAutoreleasedReturnValue([v174 lastLocalKeychainScanTime]);

      id v183 = v170;
      v291 = (NSDateComponents *)v182;
      v286 = v183;
    }

    __int128 v169 = (char *)v169 + 1;
    uint64_t v82 = v310;
    if (v167 == v169)
    {
      id v167 = -[NSDateComponents countByEnumeratingWithState:objects:count:]( v165,  "countByEnumeratingWithState:objects:count:",  &v325,  v361,  16LL);
      if (!v167)
      {
LABEL_149:

        id v208 = sub_1000AA6AC(@"ckksscan", 0LL);
        id v209 = (os_log_s *)objc_claimAutoreleasedReturnValue(v208);
        if (os_log_type_enabled(v209, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412546;
          v368 = v291;
          __int16 v369 = 2112;
          v370 = v286;
          _os_log_impl( (void *)&_mh_execute_header,  v209,  OS_LOG_TYPE_DEFAULT,  "CKKS scan last occurred at %@ (for %@)",  buf,  0x16u);
        }

        __int128 v323 = 0u;
        __int128 v324 = 0u;
        __int128 v321 = 0u;
        __int128 v322 = 0u;
        v304 = v165;
        id v210 = [v304 countByEnumeratingWithState:&v321 objects:v360 count:16];
        if (v210)
        {
          id v211 = v210;
          uint64_t v212 = *(void *)v322;
          do
          {
            uint64_t v213 = 0LL;
            do
            {
              if (*(void *)v322 != v212) {
                objc_enumerationMutation(v304);
              }
              __int16 v214 = *(void **)(*((void *)&v321 + 1) + 8LL * (void)v213);
              v215 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v82 + 32) operationDependencies]);
              __int16 v216 = (void *)objc_claimAutoreleasedReturnValue([v215 contextID]);
              v217 = (void *)objc_claimAutoreleasedReturnValue([v214 zoneID]);
              id v320 = 0LL;
              uint64_t v218 = +[CKKSOutgoingQueueEntry countByState:contextID:zoneID:error:]( &OBJC_CLASS___CKKSOutgoingQueueEntry,  "countByState:contextID:zoneID:error:",  @"new",  v216,  v217,  &v320);
              v219 = (NSDateComponents *)v320;

              if (v218 >= 1)
              {
                v220 = (void *)objc_claimAutoreleasedReturnValue([v214 zoneID]);
                v221 = (void *)objc_claimAutoreleasedReturnValue([v220 zoneName]);
                id v222 = sub_1000AA6AC(@"ckksoutgoing", v221);
                v223 = (os_log_s *)objc_claimAutoreleasedReturnValue(v222);

                if (os_log_type_enabled(v223, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)__int128 buf = 67109120;
                  LODWORD(v36_Block_object_dispose((const void *)(v1 - 80), 8) = v218;
                  _os_log_impl( (void *)&_mh_execute_header,  v223,  OS_LOG_TYPE_DEFAULT,  "Have %d outgoing items; scheduling upload",
                    buf,
                    8u);
                }

                v224 = -[OctagonPendingFlag initWithFlag:conditions:]( objc_alloc(&OBJC_CLASS___OctagonPendingFlag),  "initWithFlag:conditions:",  @"process_outgoing_queue",  2LL);
                uint64_t v82 = v310;
                v225 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v310 + 32) stateMachine]);
                [v225 _onqueueHandlePendingFlagLater:v224];

                v226 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v310 + 32) outgoingQueueOperationScheduler]);
                [v226 trigger];

LABEL_160:
                goto LABEL_161;
              }

              uint64_t v82 = v310;
              if (v219)
              {
                v227 = (void *)objc_claimAutoreleasedReturnValue([v214 zoneID]);
                v228 = (void *)objc_claimAutoreleasedReturnValue([v227 zoneName]);
                id v229 = sub_1000AA6AC(@"ckksoutgoing", v228);
                v224 = (OctagonPendingFlag *)objc_claimAutoreleasedReturnValue(v229);

                if (os_log_type_enabled((os_log_t)v224, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)__int128 buf = 138412290;
                  v368 = v219;
                  _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)v224,  OS_LOG_TYPE_DEFAULT,  "Error checking outgoing queue: %@",  buf,  0xCu);
                }

                goto LABEL_160;
              }

  self->_optionsAllowPowerNapScheduling = *((_BYTE *)v5 + 274);
  *(_DWORD *)&self->_has |= 0x2000000u;
  id v11 = *((_DWORD *)v5 + 70);
  if ((v11 & 0x200000) == 0)
  {
LABEL_63:
    if ((v11 & 0x400000) == 0) {
      goto LABEL_65;
    }
    goto LABEL_64;
  }

LABEL_161:
              uint64_t v213 = (char *)v213 + 1;
            }

            while (v211 != v213);
            id v230 = [v304 countByEnumeratingWithState:&v321 objects:v360 count:16];
            id v211 = v230;
          }

          while (v230);
        }

        __int128 v318 = 0u;
        __int128 v319 = 0u;
        __int128 v316 = 0u;
        __int128 v317 = 0u;
        v231 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v82 + 32) operationDependencies]);
        v232 = (void *)objc_claimAutoreleasedReturnValue([v231 allCKKSManagedViews]);

        id v233 = [v232 countByEnumeratingWithState:&v316 objects:v359 count:16];
        if (v233)
        {
          id v234 = v233;
          uint64_t v165 = 0LL;
          int64_t v235 = 0LL;
          uint64_t v236 = *(void *)v317;
          v296 = v232;
          uint64_t v293 = *(void *)v317;
          do
          {
            v237 = 0LL;
            id v305 = v234;
            do
            {
              if (*(void *)v317 != v236) {
                objc_enumerationMutation(v232);
              }
              v238 = *(void **)(*((void *)&v316 + 1) + 8LL * (void)v237);
              v239 = (void *)objc_claimAutoreleasedReturnValue([v238 launch]);
              unsigned __int8 v240 = [v239 launched];

              if ((v240 & 1) == 0)
              {
                if (!v165)
                {
                  v241 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v310 + 32) operationDependencies]);
                  v242 = (void *)objc_claimAutoreleasedReturnValue([v241 contextID]);
                  id v315 = 0LL;
                  uint64_t v165 = (NSDateComponents *)objc_claimAutoreleasedReturnValue( +[CKKSMirrorEntry countsByZoneNameWithContextID:error:]( &OBJC_CLASS___CKKSMirrorEntry,  "countsByZoneNameWithContextID:error:",  v242,  &v315));
                  v243 = (NSDateComponents *)v315;

                  if (v243)
                  {
                    v244 = (void *)objc_claimAutoreleasedReturnValue([v238 zoneID]);
                    v245 = (void *)objc_claimAutoreleasedReturnValue([v244 zoneName]);
                    id v246 = sub_1000AA6AC(@"launch", v245);
                    v247 = (os_log_s *)objc_claimAutoreleasedReturnValue(v246);

                    if (os_log_type_enabled(v247, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)__int128 buf = 138412290;
                      v368 = v243;
                      _os_log_impl( (void *)&_mh_execute_header,  v247,  OS_LOG_TYPE_ERROR,  "Unable to count mirror entries: %@",  buf,  0xCu);
                    }
                  }

                  v299 = v243;
                  __int128 v313 = 0u;
                  __int128 v314 = 0u;
                  __int128 v311 = 0u;
                  __int128 v312 = 0u;
                  v248 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateComponents allKeys](v165, "allKeys"));
                  id v249 = [v248 countByEnumeratingWithState:&v311 objects:v358 count:16];
                  if (v249)
                  {
                    id v250 = v249;
                    uint64_t v251 = *(void *)v312;
                    do
                    {
                      for (n = 0LL; n != v250; n = (char *)n + 1)
                      {
                        if (*(void *)v312 != v251) {
                          objc_enumerationMutation(v248);
                        }
                        v253 = (void *)objc_claimAutoreleasedReturnValue( -[NSDateComponents objectForKeyedSubscript:]( v165,  "objectForKeyedSubscript:",  *(void *)(*((void *)&v311 + 1) + 8LL * (void)n)));
                        v235 += (int64_t)[v253 longValue];
                      }

                      id v250 = [v248 countByEnumeratingWithState:&v311 objects:v358 count:16];
                    }

                    while (v250);
                  }

                  v232 = v296;
                  uint64_t v236 = v293;
                }

                v254 = (void *)objc_claimAutoreleasedReturnValue([v238 zoneName]);
                v255 = (void *)objc_claimAutoreleasedReturnValue(-[NSDateComponents objectForKeyedSubscript:](v165, "objectForKeyedSubscript:", v254));

                if (v255)
                {
                  int64_t v256 = (int64_t)[v255 longValue];
                  uint64_t v257 = 1LL;
                  if (v256 >= 11)
                  {
                    unint64_t v258 = v256;
                    do
                    {
                      int64_t v256 = v258 / 0xA;
                      v257 *= 10LL;
                      BOOL v259 = v258 > 0x6D;
                      v258 /= 0xAuLL;
                    }

                    while (v259);
                  }

                  v260 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithLongLong:",  v257 * v256));

                  v261 = (void *)objc_claimAutoreleasedReturnValue([v238 launch]);
                  [v261 addAttribute:@"zonesize" value:v260];

                  v262 = (void *)objc_claimAutoreleasedReturnValue([v238 launch]);
                  if (v235 < 11)
                  {
                    unint64_t v265 = v235;
                    uint64_t v263 = 1LL;
                    id v234 = v305;
                  }

                  else
                  {
                    uint64_t v263 = 1LL;
                    unint64_t v264 = v235;
                    id v234 = v305;
                    do
                    {
                      unint64_t v265 = v264 / 0xA;
                      v263 *= 10LL;
                      BOOL v259 = v264 > 0x6D;
                      v264 /= 0xAuLL;
                    }

                    while (v259);
                  }

                  v266 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithLongLong:",  v263 * v265));
                  [v262 addAttribute:@"totalsize" value:v266];
                }

                else
                {
                  id v234 = v305;
                }
              }

              v237 = (char *)v237 + 1;
            }

            while (v237 != v234);
            id v234 = [v232 countByEnumeratingWithState:&v316 objects:v359 count:16];
          }

          while (v234);

          if (v165)
          {
            uint64_t v82 = v310;
            v232 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v310 + 32) operationDependencies]);
            v267 = (void *)objc_claimAutoreleasedReturnValue([v232 overallLaunch]);
            v268 = &AAAccountClassPrimary_ptr;
            uint64_t v269 = 1LL;
            if (v235 >= 11)
            {
              unint64_t v270 = v235;
              do
              {
                int64_t v235 = v270 / 0xA;
                v269 *= 10LL;
                BOOL v259 = v270 > 0x6D;
                v270 /= 0xAuLL;
              }

              while (v259);
            }

            v271 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithLongLong:](&OBJC_CLASS___NSNumber, "numberWithLongLong:", v269 * v235));
            [v267 addAttribute:@"totalsize" value:v271];

LABEL_205:
            id v3 = v306;
          }

          else
          {
            id v3 = v306;
            uint64_t v82 = v310;
            v268 = &AAAccountClassPrimary_ptr;
          }

          id v272 = objc_alloc((Class)v268[212]);
          v273 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v82 + 32) operationDependencies]);
          v274 = (void *)objc_claimAutoreleasedReturnValue([v273 activeAccount]);
          v275 = (void *)objc_claimAutoreleasedReturnValue([v274 altDSID]);
          uint64_t v276 = kSecurityRTCEventNameContentSyncFinish;
          v277 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v310 + 32) operationDependencies]);
          id v278 = [v277 sendMetric];
          uint64_t v279 = v276;
          uint64_t v190 = v310;
          id v174 = [v272 initWithCKKSMetrics:&__NSDictionary0__struct altDSID:v275 eventName:v279 testsAreEnabled:0 category:v282 sendMetric:v278];

          +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:]( &OBJC_CLASS___SecurityAnalyticsReporterRTC,  "sendMetricWithEvent:success:error:",  v174,  1LL,  0LL);
          id v189 = (__CFString **)(v310 + 48);
          goto LABEL_208;
        }

        uint64_t v165 = 0LL;
        v268 = &AAAccountClassPrimary_ptr;
        goto LABEL_205;
      }

      goto LABEL_119;
    }
  }

  id v184 = (void *)objc_claimAutoreleasedReturnValue([v170 zoneID]);
  id v185 = (void *)objc_claimAutoreleasedReturnValue([v184 zoneName]);
  id v186 = sub_1000AA6AC(@"ckksscan", v185);
  id v187 = (os_log_s *)objc_claimAutoreleasedReturnValue(v186);

  if (os_log_type_enabled(v187, OS_LOG_TYPE_DEFAULT))
  {
    id v188 = (NSDateComponents *)objc_claimAutoreleasedReturnValue([v174 lastLocalKeychainScanTime]);
    *(_DWORD *)__int128 buf = 138412290;
    v368 = v188;
    _os_log_impl( (void *)&_mh_execute_header,  v187,  OS_LOG_TYPE_DEFAULT,  "CKKS scan last occurred at %@; beginning a new one",
      buf,
      0xCu);
  }

  id v189 = &off_100290568;
  id v3 = v306;
  uint64_t v190 = v310;
LABEL_208:
  id v6 = v283;
  uint64_t v162 = (NSDateComponents *)v281;
  [*(id *)(v190 + 40) setNextState:*v189];

  __int128 v113 = v280;
  __int128 v153 = (void *)v288;
LABEL_209:

  uint64_t v161 = objb;
LABEL_210:

LABEL_54:
}

  if (v138 == 5 && (v82 & 1) == 0)
  {
    id v94 = sub_1001D6420(Instance);
    id v95 = sub_10001267C("ring");
    unsigned __int8 v96 = (os_log_s *)objc_claimAutoreleasedReturnValue(v95);
    id v97 = os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT);
    if (v94)
    {
      if (v97)
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v96,  OS_LOG_TYPE_DEFAULT,  "Reset ring for recovery from remote peer",  buf,  2u);
      }

      uint64_t v99 = (const __CFData *)SOSRKNullKey(v98);
      __int128 v100 = (const void *)sub_1001B736C(kCFAllocatorDefault, v152, v99, v149);
      sub_1001ABFC4(v152, (uint64_t)v100, (CFTypeRef *)v149);
      goto LABEL_183;
    }

    if (v97)
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "normal ring recovery key harvest", buf, 2u);
    }

    sub_1001994C8((void *)Instance);
    if (sub_10019964C((void *)Instance, 0LL))
    {
      __int128 v110 = (const __CFData *)sub_1001ABCE8((void *)Instance, 0LL);
      if (v110)
      {
        __int128 v100 = (const void *)sub_1001B7724(kCFAllocatorDefault, v110, 0LL);
        sub_1001ABFC4(v152, (uint64_t)v100, (CFTypeRef *)v149);
LABEL_183:
        if (v100) {
          CFRelease(v100);
        }
        goto LABEL_185;
      }
    }

    sub_1001ABFC4(v152, 0LL, (CFTypeRef *)v149);
  }

void sub_100155C34(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
  [v2 operateOnAllViews];

  id v3 = sub_1000AA6AC(@"ckksview", 0LL);
  id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
    id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 views]);
    *(_DWORD *)__int128 buf = 138412290;
    __int128 v22 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Now operating on these views: %@", buf, 0xCu);
  }

  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  id v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "operationDependencies", 0));
  id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 allViews]);

  id v9 = [v8 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v9)
  {
    id v10 = v9;
    uint64_t v11 = *(void *)v17;
    do
    {
      id v12 = 0LL;
      do
      {
        if (*(void *)v17 != v11) {
          objc_enumerationMutation(v8);
        }
        unsigned int v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v16 + 1) + 8 * (void)v12) launch]);
        [v13 addEvent:@"priority-complete"];

        id v12 = (char *)v12 + 1;
      }

      while (v10 != v12);
      id v10 = [v8 countByEnumeratingWithState:&v16 objects:v20 count:16];
    }

    while (v10);
  }

  id v14 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
  id v15 = (void *)objc_claimAutoreleasedReturnValue([v14 overallLaunch]);
  [v15 addEvent:@"priority-complete"];
}

void sub_100155E2C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained stateMachine]);
  [v1 handleFlag:@"fetch_complete"];
}

void sub_100155E78(uint64_t a1, void *a2)
{
  uint64_t v2 = (id *)(a1 + 32);
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(v2);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
  [v5 operateOnAllViews];

  id v6 = sub_1000AA6AC(@"ckksview", 0LL);
  id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    id v8 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 views]);
    int v11 = 138412290;
    id v12 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "After trust failure, operating on these views: %@",  (uint8_t *)&v11,  0xCu);
  }

  id v10 = (void *)objc_claimAutoreleasedReturnValue([v3 intendedState]);
  [v3 setNextState:v10];
}

id sub_100155FA8(uint64_t a1, void *a2)
{
  return [a2 setError:*(void *)(a1 + 32)];
}

void sub_100155FB4(uint64_t a1, void *a2)
{
  id v3 = (id *)(a1 + 40);
  id v4 = a2;
  id WeakRetained = objc_loadWeakRetained(v3);
  id v6 = WeakRetained;
  if (*(void *)(a1 + 32))
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained zoneName]);
    id v8 = sub_1000AA6AC(@"ckksreset", v7);
    id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);

    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      id v10 = *(void **)(a1 + 32);
      int v23 = 138412290;
      id v24 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Restricting cloudkit zone reset to a view subset %@",  (uint8_t *)&v23,  0xCu);
    }

    int v11 = (void *)objc_claimAutoreleasedReturnValue([v6 operationDependencies]);
    id v12 = (void *)objc_claimAutoreleasedReturnValue([v11 viewStatesByNames:*(void *)(a1 + 32)]);
  }

  else
  {
    unsigned int v13 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
    id v12 = (void *)objc_claimAutoreleasedReturnValue([v13 activeManagedViews]);

    id v14 = (void *)objc_claimAutoreleasedReturnValue([v6 zoneName]);
    id v15 = sub_1000AA6AC(@"ckksreset", v14);
    int v11 = (void *)objc_claimAutoreleasedReturnValue(v15);

    if (os_log_type_enabled((os_log_t)v11, OS_LOG_TYPE_DEFAULT))
    {
      int v23 = 138412290;
      id v24 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)v11,  OS_LOG_TYPE_DEFAULT,  "Restricting cloudkit zone reset to active CKKS-managed subset %@",  (uint8_t *)&v23,  0xCu);
    }
  }

  __int128 v16 = (void *)objc_claimAutoreleasedReturnValue([v6 operationDependencies]);
  [v16 operateOnSelectViews:v12];

  __int128 v17 = (void *)objc_claimAutoreleasedReturnValue([v6 zoneName]);
  id v18 = sub_1000AA6AC(@"ckksreset", v17);
  __int128 v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);

  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v6 operationDependencies]);
    id v21 = (void *)objc_claimAutoreleasedReturnValue([v20 views]);
    int v23 = 138412290;
    id v24 = v21;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Beginning cloudkit zone reset for %@",  (uint8_t *)&v23,  0xCu);
  }

  __int128 v22 = (void *)objc_claimAutoreleasedReturnValue([v4 intendedState]);
  [v4 setNextState:v22];
}

void sub_100156244(uint64_t a1, void *a2)
{
  id v3 = (id *)(a1 + 40);
  id v4 = a2;
  id WeakRetained = objc_loadWeakRetained(v3);
  id v6 = WeakRetained;
  if (*(void *)(a1 + 32))
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained zoneName]);
    id v8 = sub_1000AA6AC(@"ckksreset", v7);
    id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);

    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      id v10 = *(void **)(a1 + 32);
      int v20 = 138412290;
      id v21 = v10;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Restricting local data reset to a view subset %@",  (uint8_t *)&v20,  0xCu);
    }

    int v11 = (void *)objc_claimAutoreleasedReturnValue([v6 operationDependencies]);
    id v12 = (void *)objc_claimAutoreleasedReturnValue([v11 viewStatesByNames:*(void *)(a1 + 32)]);

    unsigned int v13 = (void *)objc_claimAutoreleasedReturnValue([v6 operationDependencies]);
    [v13 operateOnSelectViews:v12];
  }

  id v14 = (void *)objc_claimAutoreleasedReturnValue([v6 zoneName]);
  id v15 = sub_1000AA6AC(@"ckksreset", v14);
  __int128 v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);

  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    __int128 v17 = (void *)objc_claimAutoreleasedReturnValue([v6 operationDependencies]);
    id v18 = (void *)objc_claimAutoreleasedReturnValue([v17 views]);
    int v20 = 138412290;
    id v21 = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Beginning local data reset for %@",  (uint8_t *)&v20,  0xCu);
  }

  __int128 v19 = (void *)objc_claimAutoreleasedReturnValue([v4 intendedState]);
  [v4 setNextState:v19];
}

void sub_100156440(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  v6[2] = sub_1001564CC;
  v6[3] = &unk_1002904C8;
  void v6[4] = WeakRetained;
  id v7 = v3;
  id v5 = v3;
  [WeakRetained dispatchSyncWithSQLTransaction:v6];
}

uint64_t sub_1001564CC(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  __int128 v118 = 0u;
  __int128 v119 = 0u;
  __int128 v120 = 0u;
  __int128 v121 = 0u;
  uint64_t v104 = a1;
  id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationDependencies]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 views]);

  id v5 = [v4 countByEnumeratingWithState:&v118 objects:v127 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v119;
    do
    {
      for (CFIndex i = 0LL; i != v6; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v119 != v7) {
          objc_enumerationMutation(v4);
        }
        id v9 = *(void **)(*((void *)&v118 + 1) + 8LL * (void)i);
        id v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v104 + 32) operationDependencies]);
        int v11 = (void *)objc_claimAutoreleasedReturnValue([v10 contextID]);
        id v12 = (void *)objc_claimAutoreleasedReturnValue([v9 zoneID]);
        unsigned int v13 = (void *)objc_claimAutoreleasedReturnValue([v12 zoneName]);
        id v14 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSZoneStateEntry contextID:zoneName:]( &OBJC_CLASS___CKKSZoneStateEntry,  "contextID:zoneName:",  v11,  v13));

        [v2 addObject:v14];
      }

      id v6 = [v4 countByEnumeratingWithState:&v118 objects:v127 count:16];
    }

    while (v6);
  }

  __int128 v116 = 0u;
  __int128 v117 = 0u;
  __int128 v114 = 0u;
  __int128 v115 = 0u;
  id v15 = v2;
  id v16 = [v15 countByEnumeratingWithState:&v114 objects:v126 count:16];
  if (v16)
  {
    id v17 = v16;
    char v18 = 0;
    int v101 = 0;
    uint64_t v19 = *(void *)v115;
    do
    {
      for (j = 0LL; j != v17; j = (char *)j + 1)
      {
        if (*(void *)v115 != v19) {
          objc_enumerationMutation(v15);
        }
        id v21 = *(void **)(*((void *)&v114 + 1) + 8LL * (void)j);
        if (([v21 ckzonecreated] & 1) == 0)
        {
          __int128 v35 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v104 + 32) zoneName]);
          id v36 = sub_1000AA6AC(@"ckks", v35);
          uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue(v36);

          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138412290;
            id v125 = v21;
            _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "Zone does not exist(%@); going to restart operation",
              buf,
              0xCu);
          }

          [*(id *)(v104 + 40) setNextState:@"initializing"];
          goto LABEL_83;
        }

        __int128 v22 = (void *)objc_claimAutoreleasedReturnValue([v21 getChangeToken]);
        BOOL v23 = v22 == 0LL;

        if ([v21 moreRecordsInCloudKit])
        {
          id v24 = v15;
          id v25 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v104 + 32) zoneName]);
          id v26 = sub_1000AA6AC(@"ckks", v25);
          uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);

          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "CloudKit reports there's more records to fetch!",  buf,  2u);
          }

          int v101 = 1;
          id v15 = v24;
        }

        v18 |= v23;
      }

      id v17 = [v15 countByEnumeratingWithState:&v114 objects:v126 count:16];
    }

    while (v17);

    if ((v18 & 1) != 0)
    {
      id v28 = (void *)objc_claimAutoreleasedReturnValue( +[CKOperationGroup CKKSGroupWithName:]( &OBJC_CLASS___CKOperationGroup,  "CKKSGroupWithName:",  @"initial-setup"));
      id v29 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v104 + 32) operationDependencies]);
      [v29 setCkoperationGroup:v28];

      id v30 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v104 + 32) zoneName]);
      id v31 = sub_1000AA6AC(@"ckks", v30);
      id v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v31);

      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v32,  OS_LOG_TYPE_DEFAULT,  "No existing change token; going to try to match local items with CloudKit ones.",
          buf,
          2u);
      }

      uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v104 + 32) operationDependencies]);
      __int128 v34 = (void *)objc_claimAutoreleasedReturnValue([v33 currentFetchReasons]);
      [v34 addObject:@"initialfetch"];

      [*(id *)(v104 + 40) setNextState:@"begin_fetch"];
      goto LABEL_83;
    }
  }

  else
  {

    int v101 = 0;
  }

  __int128 v112 = 0u;
  __int128 v113 = 0u;
  __int128 v110 = 0u;
  __int128 v111 = 0u;
  id v38 = v15;
  id v39 = [v38 countByEnumeratingWithState:&v110 objects:v123 count:16];
  if (v39)
  {
    id v40 = v39;
    uint64_t v41 = *(void *)v111;
    unint64_t v42 = 5LL;
    do
    {
      for (k = 0LL; k != v40; k = (char *)k + 1)
      {
        if (*(void *)v111 != v41) {
          objc_enumerationMutation(v38);
        }
        id v44 = *(void **)(*((void *)&v110 + 1) + 8LL * (void)k);
      }

      id v40 = [v38 countByEnumeratingWithState:&v110 objects:v123 count:16];
    }

    while (v40);
  }

  else
  {
    unint64_t v42 = 5LL;
  }

  BOOL v45 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSFixups fixupOperation:](&OBJC_CLASS___CKKSFixups, "fixupOperation:", v42));
  id v46 = *(void **)(v104 + 32);
  if (v45)
  {
    unsigned int v47 = (void *)objc_claimAutoreleasedReturnValue([v46 zoneName]);
    id v48 = sub_1000AA6AC(@"ckksfixup", v47);
    id v49 = (os_log_s *)objc_claimAutoreleasedReturnValue(v48);

    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      id v50 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v104 + 32) lastFixupOperation]);
      *(_DWORD *)__int128 buf = 138412290;
      id v125 = v50;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "We have a fixup to perform: %@", buf, 0xCu);
    }

    [*(id *)(v104 + 40) setNextState:v45];
    goto LABEL_82;
  }

  id v109 = 0LL;
  [v46 _onqueueResetAllInflightOQE:&v109];
  id v51 = v109;
  if (v51)
  {
    id v52 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v104 + 32) zoneName]);
    id v53 = sub_1000AA6AC(@"ckks", v52);
    id v54 = (os_log_s *)objc_claimAutoreleasedReturnValue(v53);

    if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      id v125 = v51;
      _os_log_impl( (void *)&_mh_execute_header,  v54,  OS_LOG_TYPE_ERROR,  "Couldn't reset in-flight OQEs, bad behavior ahead: %@",  buf,  0xCu);
    }
  }

  id v99 = v51;
  id v100 = v15;
  uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue( +[CKOperationGroup CKKSGroupWithName:]( &OBJC_CLASS___CKOperationGroup,  "CKKSGroupWithName:",  @"restart-setup"));
  id v56 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v104 + 32) operationDependencies]);
  [v56 setCkoperationGroup:v55];

  id v57 = (void *)objc_claimAutoreleasedReturnValue( +[CKOperationGroup CKKSGroupWithName:]( &OBJC_CLASS___CKOperationGroup,  "CKKSGroupWithName:",  @"restart-setup"));
  id v58 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v104 + 32) operationDependencies]);
  [v58 setCurrentOutgoingQueueOperationGroup:v57];

  __int128 v107 = 0u;
  __int128 v108 = 0u;
  __int128 v105 = 0u;
  __int128 v106 = 0u;
  id v59 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v104 + 32) operationDependencies]);
  id v60 = (void *)objc_claimAutoreleasedReturnValue([v59 activeManagedViews]);

  id v102 = v60;
  id v61 = [v60 countByEnumeratingWithState:&v105 objects:v122 count:16];
  if (!v61)
  {
    LODWORD(v63) = 0;
    goto LABEL_74;
  }

  id v62 = v61;
  uint64_t v63 = 0LL;
  id obj = *(id *)v106;
  do
  {
    for (m = 0LL; m != v62; m = (char *)m + 1)
    {
      if (*(id *)v106 != obj) {
        objc_enumerationMutation(v102);
      }
      id v65 = *(void **)(*((void *)&v105 + 1) + 8LL * (void)m);
      id v66 = (void *)objc_claimAutoreleasedReturnValue([v65 zoneID]);
      int v67 = (void *)objc_claimAutoreleasedReturnValue([v65 contextID]);
      uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSCurrentKeySet loadForZone:contextID:]( &OBJC_CLASS___CKKSCurrentKeySet,  "loadForZone:contextID:",  v66,  v67));

      uint64_t v69 = objc_claimAutoreleasedReturnValue([v68 error]);
      if (v69)
      {
        id v70 = (void *)v69;
        id v71 = (void *)objc_claimAutoreleasedReturnValue([v68 error]);
        id v72 = (void *)objc_claimAutoreleasedReturnValue([v71 domain]);
        if ([v72 isEqual:@"securityd"])
        {
          uint64_t v73 = v63;
          id v74 = (void *)objc_claimAutoreleasedReturnValue([v68 error]);
          id v75 = [v74 code];

          uint64_t v63 = v73;
          if (v75 == (id)-25300LL) {
            goto LABEL_60;
          }
        }

        else
        {
        }

        uint64_t v76 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v104 + 32) zoneName]);
        id v77 = sub_1000AA6AC(@"ckkskey", v76);
        uint64_t v78 = (os_log_s *)objc_claimAutoreleasedReturnValue(v77);

        if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
        {
          int v79 = (void *)objc_claimAutoreleasedReturnValue([v68 error]);
          *(_DWORD *)__int128 buf = 138412290;
          id v125 = v79;
          _os_log_impl( (void *)&_mh_execute_header,  v78,  OS_LOG_TYPE_ERROR,  "Error examining existing key hierarchy: %@",  buf,  0xCu);
        }
      }

LABEL_60:
      uint64_t v80 = objc_claimAutoreleasedReturnValue([v68 tlk]);
      if (v80)
      {
        uint64_t v81 = (void *)v80;
        uint64_t v82 = objc_claimAutoreleasedReturnValue([v68 classA]);
        if (v82)
        {
          id v83 = (void *)v82;
          uint64_t v84 = objc_claimAutoreleasedReturnValue([v68 classC]);
          if (v84)
          {
            uint64_t v85 = (void *)v84;
            uint64_t v86 = (void *)objc_claimAutoreleasedReturnValue([v68 error]);

            if (!v86) {
              goto LABEL_70;
            }
            goto LABEL_67;
          }
        }
      }

  id v10 = 0LL;
  if ((*(_DWORD *)&v6 & 0x200000) == 0) {
    goto LABEL_61;
  }
LABEL_55:
  int v11 = 2654435761LL * self->_optionsTimeoutIntervalForRequest;
  if ((*(_DWORD *)&v6 & 0x400000) != 0)
  {
LABEL_56:
    id v12 = 2654435761LL * self->_optionsTimeoutIntervalForResource;
    goto LABEL_63;
  }

        CFRelease(v22);
        goto LABEL_61;
      }
    }

    else if (!v24)
    {
      goto LABEL_59;
    }

    CFRelease(v19);
    goto LABEL_59;
  }

void sub_100156FCC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained stateMachine]);
  [v1 handleFlag:@"oqo_token"];
}

void sub_100157018(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained stateMachine]);
  [v1 handleFlag:@"oqo_token"];
}

size_t sub_100157064(void *a1, const __CFString *a2, uint64_t a3, __CFString **a4, uint64_t a5)
{
  if (!a2) {
    return sub_1000194E0(-50, a4, @"object for key %s is NULL", "status");
  }
  size_t result = sub_100019A68(a2, (CFTypeRef *)a4, a3, (uint64_t)a4, a5);
  if (result)
  {
    size_t v10 = result;
    int v11 = (UInt8 *)malloc(result);
    unint64_t v12 = (unint64_t)&v11[v10];
    unsigned int v13 = (const void *)sub_100019C44(a2, (CFTypeRef *)a4, a3, v11, v12);
    if (v13 && v12 > (unint64_t)v13)
    {
      xpc_dictionary_set_data(a1, "status", v13, v12 - (void)v13);
      free(v11);
      return 1LL;
    }

    else
    {
      free(v11);
      return 0LL;
    }
  }

  return result;
}

void sub_100157140(void *a1, const char *a2, CFDataRef theData, __CFString **a4)
{
  if (theData)
  {
    if (CFDataGetLength(theData) < 0)
    {
      sub_1000194E0(-50, a4, @"no data for key %s", a2);
    }

    else
    {
      BytePtr = CFDataGetBytePtr(theData);
      size_t Length = CFDataGetLength(theData);
      xpc_dictionary_set_data(a1, a2, BytePtr, Length);
    }
  }

  else
  {
    sub_1000194E0(-50, a4, @"data for key %s is NULL", a2);
  }

void sub_1001571E8(uint64_t a1, const __CFString *a2, __CFString **a3)
{
  if (a2)
  {
    v4[0] = 0LL;
    v4[1] = v4;
    v4[2] = 0x2000000000LL;
    char v5 = 1;
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 0x40000000LL;
    v3[2] = sub_1001572C4;
    v3[3] = &unk_100290930;
    void v3[4] = v4;
    v3[5] = a1;
    v3[6] = "status";
    v3[7] = a3;
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000LL;
    v6[2] = sub_1000134E4;
    v6[3] = &unk_100283030;
    void v6[4] = v3;
    sub_10001337C(a2, (uint64_t)v6);
    _Block_object_dispose(v4, 8);
  }

  else
  {
    sub_1000194E0(-50, a3, @"string for key %s is NULL", "status");
  }

void sub_1001572C4(uint64_t a1, char *string)
{
  if (string) {
    xpc_dictionary_set_string(*(xpc_object_t *)(a1 + 40), *(const char **)(a1 + 48), string);
  }
  else {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = sub_1000194E0( -50,  *(__CFString ***)(a1 + 56),  @"failed to convert string for key %s to utf8",  *(void *)(a1 + 48));
  }
}

uint64_t sub_100157330(void *a1)
{
  uint64_t v1 = xpc_dictionary_dup_fd(a1, "fileDescriptor");
  if ((v1 & 0x80000000) != 0) {
    sub_1000194E0(-50, 0LL, @"missing fd for key %s", "fileDescriptor");
  }
  return v1;
}

const void *sub_100157384(void *a1, const char *a2, __CFString **a3)
{
  CFTypeRef v5 = sub_100157454(a1, a2, a3);
  id v6 = v5;
  if (v5 && (CFTypeID v7 = CFGetTypeID(v5), v7 == CFSetGetTypeID()))
  {
    CFRetain(v6);
    id v8 = v6;
  }

  else
  {
    if (a3) {
      sub_1000194E0(-50, a3, @"object %@ is not a set", v6);
    }
    if (!v6) {
      return 0LL;
    }
    CFTypeID v9 = CFGetTypeID(v6);
    CFStringRef v10 = CFCopyTypeIDDescription(v9);
    sub_1000194E0(-50, a3, @"object for key %s not set but %@", a2, v10);
    if (v10) {
      CFRelease(v10);
    }
    id v8 = 0LL;
  }

  CFRelease(v6);
  return v8;
}

CFTypeRef sub_100157454(void *a1, const char *a2, __CFString **a3)
{
  size_t length = 0LL;
  CFTypeRef cf = 0LL;
  data = (const UInt8 *)xpc_dictionary_get_data(a1, a2, &length);
  if (data)
  {
    id v6 = data;
    CFTypeID v7 = (unsigned __int8 *)&data[length];
    id v8 = (const __CFAllocator *)SecCFAllocatorZeroize();
    if (sub_100019634(v8, (CFBooleanRef *)&cf, (CFTypeRef *)a3, v6, (uint64_t)v7) == v7)
    {
      CFTypeRef v12 = cf;
    }

    else
    {
      CFTypeID v9 = (__CFString *)CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"trailing garbage after der decoded object for key %s",  a2);
      sub_1000194E0(-50, a3, @"%@", v9);
      if (a3)
      {
        CFStringRef v10 = (os_log_s *)sub_10001267C("SecError");
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          int v11 = *a3;
          *(_DWORD *)__int128 buf = 138412290;
          id v17 = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "xpc: %@", buf, 0xCu);
        }
      }

      sub_10001BB24(v9, 0x53C00002u);
      if (v9) {
        CFRelease(v9);
      }
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef v12 = 0LL;
    }

    cc_clear(length, v6);
  }

  else
  {
    sub_1000194E0(-50, a3, @"no object for key %s", a2);
    return 0LL;
  }

  return v12;
}

const void *sub_1001575E4(void *a1, const char *a2, __CFString **a3)
{
  CFTypeRef v5 = sub_100157454(a1, a2, a3);
  id v6 = v5;
  if (v5)
  {
    CFTypeID v7 = CFGetTypeID(v5);
    if (v7 != CFArrayGetTypeID())
    {
      CFStringRef v8 = CFCopyTypeIDDescription(v7);
      sub_1000194E0(-50, a3, @"object for key %s not array but %@", a2, v8);
      if (v8) {
        CFRelease(v8);
      }
      CFRelease(v6);
      return 0LL;
    }
  }

  return v6;
}

CFDataRef sub_100157678(void *a1, const char *a2, __CFString **a3)
{
  size_t length = 0LL;
  data = (const UInt8 *)xpc_dictionary_get_data(a1, a2, &length);
  if (data)
  {
    if ((length & 0x8000000000000000LL) != 0)
    {
      sub_1000194E0(-50, a3, @"too large data for key %s", a2);
    }

    else
    {
      CFDataRef result = CFDataCreate(kCFAllocatorDefault, data, length);
      if (result) {
        return result;
      }
      sub_1000194E0(-50, a3, @"failed to create data for key %s", a2);
    }
  }

  else
  {
    sub_1000194E0(-50, a3, @"no data for key %s", a2);
  }

  return 0LL;
}

BOOL sub_100157704(void *a1, const char *a2, void *a3, __CFString **a4)
{
  size_t length = 0LL;
  data = (void *)xpc_dictionary_get_data(a1, a2, &length);
  if (data)
  {
    data = sub_100157678(a1, a2, a4);
    BOOL v9 = data != 0LL;
  }

  else
  {
    BOOL v9 = 1LL;
  }

  *a3 = data;
  return v9;
}

const void *sub_100157774(void *a1, const char *a2, __CFString **a3)
{
  CFTypeRef v5 = sub_100157454(a1, a2, a3);
  id v6 = v5;
  if (v5)
  {
    CFTypeID v7 = CFGetTypeID(v5);
    if (v7 != CFDictionaryGetTypeID())
    {
      CFStringRef v8 = CFCopyTypeIDDescription(v7);
      sub_1000194E0(-50, a3, @"object for key %s not dictionary but %@", a2, v8);
      if (v8) {
        CFRelease(v8);
      }
      CFRelease(v6);
      return 0LL;
    }
  }

  return v6;
}

BOOL sub_100157808(void *a1, void *a2, __CFString **a3)
{
  value = xpc_dictionary_get_value(a1, "backup");
  if (value)
  {
    value = (void *)sub_100157774(a1, "backup", a3);
    BOOL v7 = value != 0LL;
  }

  else
  {
    BOOL v7 = 1LL;
  }

  *a2 = value;
  return v7;
}

CFStringRef sub_100157870(void *a1, const char *a2, __CFString **a3)
{
  string = xpc_dictionary_get_string(a1, a2);
  if (string)
  {
    id v6 = string;
    CFStringRef result = CFStringCreateWithCString(kCFAllocatorDefault, string, 0x8000100u);
    if (result) {
      return result;
    }
    sub_1000194E0(-108, a3, @"object for key %s failed to convert %s to CFString", a2, v6);
  }

  else
  {
    sub_1000194E0(-50, a3, @"object for key %s not string", a2);
  }

  return 0LL;
}

BOOL sub_1001578FC(void *a1, const char *a2, void *a3, __CFString **a4)
{
  value = xpc_dictionary_get_value(a1, a2);
  if (value)
  {
    value = (void *)sub_100157870(a1, a2, a4);
    BOOL v9 = value != 0LL;
  }

  else
  {
    BOOL v9 = 1LL;
  }

  *a3 = value;
  return v9;
}

void sub_100158334(_Unwind_Exception *a1)
{
}

void sub_100158404(_Unwind_Exception *a1)
{
}

void sub_100158C70( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
}

LABEL_97:
  id v184 = v118;
  v132 = (void *)objc_claimAutoreleasedReturnValue(-[CKKSProcessReceivedKeysOperation deps](self, "deps"));
  id v133 = (void *)objc_claimAutoreleasedReturnValue([v132 savedTLKNotifier]);

  id v134 = (void *)objc_claimAutoreleasedReturnValue([v187 zoneID]);
  id v135 = (void *)objc_claimAutoreleasedReturnValue([v134 zoneName]);
  uint64_t v136 = sub_1000AA6AC(@"ckkstlk", v135);
  id v137 = (os_log_s *)objc_claimAutoreleasedReturnValue(v136);

  if (os_log_type_enabled(v137, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412290;
    v228 = v133;
    _os_log_impl( (void *)&_mh_execute_header,  v137,  OS_LOG_TYPE_DEFAULT,  "triggering new TLK notification: %@",  buf,  0xCu);
  }

  [v133 trigger];
  __int128 v138 = (void *)objc_claimAutoreleasedReturnValue([v187 zoneID]);
  __int128 v139 = (void *)objc_claimAutoreleasedReturnValue([v138 zoneName]);
  __int128 v140 = sub_1000AA6AC(@"ckkskey", v139);
  id v141 = (os_log_s *)objc_claimAutoreleasedReturnValue(v140);

  if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v141, OS_LOG_TYPE_DEFAULT, "Accepted new key hierarchy", buf, 2u);
  }

  int v79 = @"ready";
  id v142 = @"ready";

  id v61 = v176;
  id v26 = v49;
  __int128 v22 = v186;
  CFStringRef v8 = v187;
  uint64_t v27 = v191;
  id v32 = v196;
LABEL_144:
  uint64_t v81 = v197;

  int v20 = v184;
LABEL_57:

  return v79;
}

uint64_t sub_10015AFC4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10015AFD4(uint64_t a1)
{
}

uint64_t sub_10015AFDC(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) deps]);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 contextID]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
  id v61 = 0LL;
  CFTypeRef v5 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSKey remoteKeysForContextID:zoneID:error:]( &OBJC_CLASS___CKKSKey,  "remoteKeysForContextID:zoneID:error:",  v3,  v4,  &v61));
  id v6 = v61;

  if (v5) {
    BOOL v7 = v6 == 0LL;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7)
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) += [v5 count];
    if ([v5 count])
    {
      id v15 = *(void **)(a1 + 32);
      uint64_t v16 = *(void *)(a1 + 40);
      uint64_t v17 = *(void *)(a1 + 56);
      uint64_t v18 = *(void *)(*(void *)(a1 + 88) + 8LL);
      id obj = *(id *)(v18 + 40);
      uint64_t v19 = objc_claimAutoreleasedReturnValue([v15 processRemoteKeys:v5 viewState:v16 currentTrustStates:v17 error:&obj]);
      objc_storeStrong((id *)(v18 + 40), obj);
      uint64_t v20 = *(void *)(*(void *)(a1 + 80) + 8LL);
      id v21 = *(void **)(v20 + 40);
      *(void *)(v20 + 40) = v19;

      __int128 v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
      BOOL v23 = (void *)objc_claimAutoreleasedReturnValue([v22 zoneName]);
      id v24 = sub_1000AA6AC(@"ckkskey", v23);
      id v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);

      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        id v26 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8LL) + 40LL);
        uint64_t v27 = *(void *)(*(void *)(*(void *)(a1 + 88) + 8LL) + 40LL);
        *(_DWORD *)__int128 buf = 138412546;
        id v65 = v26;
        __int16 v66 = 2112;
        uint64_t v67 = v27;
        _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "After remote key processing, Key hierarchy is '%@' (error: %@)",  buf,  0x16u);
      }

      if (![*(id *)(*(void *)(*(void *)(a1 + 80) + 8) + 40) isEqualToString:@"ready"])
      {
        uint64_t v14 = 1LL;
        goto LABEL_29;
      }
    }

    id v28 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) deps]);
    id v29 = (void *)objc_claimAutoreleasedReturnValue([v28 contextID]);
    id v30 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
    id v59 = 0LL;
    unsigned __int8 v31 = +[CKKSIncomingQueueEntry allIQEsHaveValidUnwrappingKeysInContextID:zoneID:error:]( &OBJC_CLASS___CKKSIncomingQueueEntry,  "allIQEsHaveValidUnwrappingKeysInContextID:zoneID:error:",  v29,  v30,  &v59);
    id v32 = v59;

    if (v32)
    {
      uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
      __int128 v34 = (void *)objc_claimAutoreleasedReturnValue([v33 zoneName]);
      id v35 = sub_1000AA6AC(@"ckkskey", v34);
      id v36 = (os_log_s *)objc_claimAutoreleasedReturnValue(v35);

      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        id v65 = v32;
        uint64_t v37 = "Unable to determine if all IQEs have parent keys: %@";
        id v38 = v36;
        os_log_type_t v39 = OS_LOG_TYPE_ERROR;
        uint32_t v40 = 12;
LABEL_15:
        _os_log_impl((void *)&_mh_execute_header, v38, v39, v37, buf, v40);
      }
    }

    else
    {
      if ((v31 & 1) != 0)
      {
LABEL_25:
        id v50 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
        id v51 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) deps]);
        id v52 = (void *)objc_claimAutoreleasedReturnValue([v51 contextID]);
        uint64_t v53 = objc_claimAutoreleasedReturnValue( +[CKKSCurrentKeySet loadForZone:contextID:]( &OBJC_CLASS___CKKSCurrentKeySet,  "loadForZone:contextID:",  v50,  v52));
        uint64_t v54 = *(void *)(*(void *)(a1 + 96) + 8LL);
        uint64_t v55 = *(void **)(v54 + 40);
        *(void *)(v54 + 40) = v53;

        if ([*(id *)(*(void *)(*(void *)(a1 + 80) + 8) + 40) isEqualToString:@"error"])
        {
          id v56 = *(void **)(a1 + 48);
          id v57 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) error]);
          [v56 populateUnderlyingErrorsStartingWithRootError:v57];

          uint64_t v14 = 0LL;
          *(_BYTE *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) = 0;
        }

        else
        {
          uint64_t v14 = 1LL;
        }

        goto LABEL_29;
      }

      unsigned int v41 = [*(id *)(a1 + 32) allowFullRefetchResult];
      unint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
      id v43 = (void *)objc_claimAutoreleasedReturnValue([v42 zoneName]);
      id v44 = sub_1000AA6AC(@"ckkskey", v43);
      id v36 = (os_log_s *)objc_claimAutoreleasedReturnValue(v44);

      BOOL v45 = os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT);
      if (v41)
      {
        if (v45)
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "We have some item that encrypts to a non-existent key. This is exceptional; requesting full refetch",
            buf,
            2u);
        }

        id v46 = *(void **)(a1 + 48);
        uint64_t v62 = kSecurityRTCFieldFullRefetchNeeded;
        uint64_t v63 = &__kCFBooleanTrue;
        unsigned int v47 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v63,  &v62,  1LL));
        [v46 addMetrics:v47];

        uint64_t v48 = *(void *)(*(void *)(a1 + 80) + 8LL);
        id v49 = @"needrefetch";
        id v36 = *(os_log_s **)(v48 + 40);
        *(void *)(v48 + 40) = @"needrefetch";
        goto LABEL_24;
      }

      if (v45)
      {
        *(_WORD *)__int128 buf = 0;
        uint64_t v37 = "We have some item that encrypts to a non-existent key, but we cannot request a refetch! Possible inifinite-loop ahead";
        id v38 = v36;
        os_log_type_t v39 = OS_LOG_TYPE_DEFAULT;
        uint32_t v40 = 2;
        goto LABEL_15;
      }
    }

void sub_10015E8C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

uint64_t sub_10015E8E4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10015E8F4(uint64_t a1)
{
}

void sub_10015E8FC(uint64_t a1, void *a2)
{
  id v6 = (id)objc_claimAutoreleasedReturnValue([a2 objectForKeyedSubscript:@"count(rowid)"]);
  uint64_t v3 = objc_claimAutoreleasedReturnValue([v6 asNSNumberInteger]);
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
  CFTypeRef v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

void sub_10015F060( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

id sub_10015F2E0(uint64_t a1)
{
  return [*(id *)(a1 + 32) setReadyNotificationArmed:1];
}

void sub_10015F2EC(uint64_t a1)
{
  if ([*(id *)(a1 + 32) readyNotificationArmed])
  {
    [*(id *)(a1 + 32) setReadyNotificationArmed:0];
    id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) notifyViewReadyScheduler]);
    [v2 trigger];
  }

uint64_t sub_10015F350(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10015F360(uint64_t a1)
{
}

void sub_10015F368(uint64_t a1)
{
  id v5 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) mutableStateConditions]);
  id v2 = [v5 copy];
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_10015F3B8(uint64_t a1)
{
  if (([*(id *)(a1 + 32) isEqualToString:*(void *)(*(void *)(a1 + 40) + 16)] & 1) == 0)
  {
    id v2 = *(void **)(a1 + 40);
    if (v2[2])
    {
      uint64_t v3 = objc_alloc_init(&OBJC_CLASS___CKKSCondition);
      uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) mutableStateConditions]);
      [v4 setObject:v3 forKeyedSubscript:*(void *)(*(void *)(a1 + 40) + 16)];

      id v2 = *(void **)(a1 + 40);
    }

    id v5 = (void *)objc_claimAutoreleasedReturnValue([v2 allowableStates]);
    unsigned __int8 v6 = [v5 containsObject:*(void *)(a1 + 32)];

    if ((v6 & 1) == 0)
    {
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](&OBJC_CLASS___NSAssertionHandler, "currentHandler"));
      [v19 handleFailureInMethod:*(void *)(a1 + 48), *(void *)(a1 + 40), @"CKKSKeychainViewState.m", 123, @"state machine tried to enter unknown state %@", *(void *)(a1 + 32) object file lineNumber description];
    }

    objc_storeStrong((id *)(*(void *)(a1 + 40) + 16LL), *(id *)(a1 + 32));
    BOOL v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
    CFStringRef v8 = (void *)objc_claimAutoreleasedReturnValue([v7 zoneName]);
    id v9 = sub_1000AA6AC(@"ckks-view-state", v8);
    id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);

    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(a1 + 32);
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v21 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Zone is entering %@", buf, 0xCu);
    }

    CFTypeRef v12 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) launch]);
    [v12 addEvent:*(void *)(a1 + 32)];

    if (*(void *)(a1 + 32))
    {
      unsigned int v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) mutableStateConditions]);
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v13 objectForKeyedSubscript:*(void *)(a1 + 32)]);
      [v14 fulfill];

      if ([*(id *)(a1 + 32) isEqualToString:@"ready"])
      {
        id v15 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](&OBJC_CLASS___CKKSAnalytics, "logger"));
        uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
        uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
        uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v17 zoneName]);
        [v15 setDateProperty:v16 forKey:@"lastKSR" zoneName:v18];
      }
    }
  }

void sub_10015F630(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v5 = objc_alloc_init(&OBJC_CLASS___CKKSCondition);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) mutableStateConditions]);
  [v4 setObject:v5 forKeyedSubscript:v3];
}

void sub_10015FCF4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id *location, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, id a30)
{
}

LABEL_81:
LABEL_82:
  unsigned int v13 = v132;
LABEL_83:

  _Block_object_dispose(&v171, 8);
}

                _Block_object_dispose(&v181, 8);
                _Block_object_dispose(buf, 8);

                goto LABEL_82;
              }

              uint64_t v55 = objc_claimAutoreleasedReturnValue([v169 pendingTLKShares]);
              id v56 = (void *)v55;
              if (v55) {
                id v57 = (void *)v55;
              }
              else {
                id v57 = &__NSArray0__struct;
              }
              id v58 = (void *)objc_claimAutoreleasedReturnValue([v49 arrayByAddingObjectsFromArray:v57]);

              uint64_t v159 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
              id v174 = 0u;
              uint64_t v175 = 0u;
              __int128 v172 = 0u;
              __int16 v173 = 0u;
              uint64_t v165 = v58;
              id v59 = [v165 countByEnumeratingWithState:&v172 objects:v197 count:16];
              if (!v59)
              {

LABEL_76:
                __int128 v115 = (void *)objc_claimAutoreleasedReturnValue([v169 tlk]);
                __int128 v116 = (void *)objc_claimAutoreleasedReturnValue([v115 zoneName]);
                __int128 v117 = sub_1000AA6AC(@"ckksshare", v116);
                __int128 v118 = (os_log_s *)objc_claimAutoreleasedReturnValue(v117);

                if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
                {
                  __int128 v119 = (void *)objc_claimAutoreleasedReturnValue([v169 tlk]);
                  __int128 v120 = (void *)objc_claimAutoreleasedReturnValue([v119 uuid]);
                  *(_DWORD *)id v191 = 138412802;
                  id v192 = v170;
                  id v193 = 2112;
                  id v194 = v120;
                  id v195 = 2112;
                  unsigned int v196 = v159;
                  _os_log_impl( (void *)&_mh_execute_header,  v118,  OS_LOG_TYPE_DEFAULT,  "Peer %@ is shared %@ via insufficient shares: %@",  v191,  0x20u);
                }

                __int128 v121 = (void *)objc_claimAutoreleasedReturnValue([v170 publicEncryptionKey]);
                if (v121) {
                  [v156 addObject:v170];
                }
LABEL_80:

                uint64_t v53 = (os_log_s *)v165;
                goto LABEL_81;
              }

              id v158 = 0;
              id v167 = *(void *)v173;
              while (2)
              {
                id v60 = 0LL;
                uint64_t v168 = v59;
LABEL_37:
                if (*(void *)v173 != v167) {
                  objc_enumerationMutation(v165);
                }
                id v61 = *(void **)(*((void *)&v172 + 1) + 8 * v60);
                uint64_t v62 = objc_autoreleasePoolPush();
                uint64_t v63 = (void *)objc_claimAutoreleasedReturnValue([v61 share]);
                id v64 = (void *)objc_claimAutoreleasedReturnValue([v63 receiverPeerID]);
                id v65 = (void *)objc_claimAutoreleasedReturnValue([v170 peerID]);
                __int16 v66 = [v64 isEqualToString:v65];

                if ((v66 & 1) != 0)
                {
                  uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue([v61 senderPeerID]);
                  uint64_t v68 = [v67 hasPrefix:@"spid-"];

                  if (!v68) {
                    goto LABEL_43;
                  }
                  uint64_t v69 = (void *)objc_claimAutoreleasedReturnValue([v166 currentTrustedPeers]);
                  __int16 v171 = 0LL;
                  id v70 = [v61 signatureVerifiesWithPeerSet:v69 error:&v171];
                  id v71 = v171;

                  if (v70)
                  {

LABEL_43:
                    id v71 = (id)objc_claimAutoreleasedReturnValue([v61 tlkUUID]);
                    id v72 = (void *)objc_claimAutoreleasedReturnValue([v169 tlk]);
                    uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue([v72 uuid]);
                    if ([v71 isEqualToString:v73])
                    {
                      id v74 = (void *)objc_claimAutoreleasedReturnValue([v166 currentTrustedPeerIDs]);
                      id v75 = (void *)objc_claimAutoreleasedReturnValue([v61 senderPeerID]);
                      uint64_t v76 = [v74 containsObject:v75];

                      if (!v76)
                      {
                        unsigned __int8 v96 = 0;
                        goto LABEL_62;
                      }

                      id v77 = (void *)objc_claimAutoreleasedReturnValue([v170 peerID]);
                      uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue([v166 currentSelfPeers]);
                      int v79 = (void *)objc_claimAutoreleasedReturnValue([v78 currentSelf]);
                      uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue([v79 peerID]);
                      uint64_t v81 = [v77 isEqualToString:v80];

                      if (v81)
                      {
                        uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([v166 currentSelfPeers]);
                        id v83 = (void *)objc_claimAutoreleasedReturnValue([v82 currentSelf]);
                        uint64_t v84 = (void *)objc_claimAutoreleasedReturnValue([v83 publicEncryptionKey]);
                        id v71 = (id)objc_claimAutoreleasedReturnValue([v84 keyData]);

                        uint64_t v85 = (void *)objc_claimAutoreleasedReturnValue([v61 senderPeerID]);
                        uint64_t v86 = (void *)objc_claimAutoreleasedReturnValue([v166 currentSelfPeers]);
                        v87 = (void *)objc_claimAutoreleasedReturnValue([v86 currentSelf]);
                        id v88 = (void *)objc_claimAutoreleasedReturnValue([v87 peerID]);
                        if ([v85 isEqualToString:v88])
                        {
                          id v89 = (void *)objc_claimAutoreleasedReturnValue([v61 share]);
                          uint64_t v90 = (void *)objc_claimAutoreleasedReturnValue([v89 receiverPublicEncryptionKeySPKI]);
                          __int128 v157 = [v90 isEqual:v71];

                          if (v157)
                          {
                            id v91 = (void *)objc_claimAutoreleasedReturnValue([v169 tlk]);
                            id v92 = (void *)objc_claimAutoreleasedReturnValue([v91 zoneName]);
                            id v93 = sub_1000AA6AC(@"ckksshare", v92);
                            id v72 = (void *)objc_claimAutoreleasedReturnValue(v93);

                            if (os_log_type_enabled((os_log_t)v72, OS_LOG_TYPE_DEFAULT))
                            {
                              id v94 = (void *)objc_claimAutoreleasedReturnValue([v169 tlk]);
                              id v95 = (void *)objc_claimAutoreleasedReturnValue([v94 uuid]);
                              *(_DWORD *)id v191 = 138412802;
                              id v192 = v170;
                              id v193 = 2112;
                              id v194 = v95;
                              id v195 = 2112;
                              unsigned int v196 = v61;
                              _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)v72,  OS_LOG_TYPE_DEFAULT,  "Local peer %@ is shared %@ via self: %@",  v191,  0x20u);
                            }

                            goto LABEL_59;
                          }
                        }

                        else
                        {
                        }

                        [v159 addObject:v61];
LABEL_71:
                        unsigned __int8 v96 = 0;
LABEL_61:

LABEL_62:
                        objc_autoreleasePoolPop(v62);
                        if (v96 != 5 && v96) {
                          goto LABEL_73;
                        }
                        if (v168 == (id)++v60)
                        {
                          id v59 = [v165 countByEnumeratingWithState:&v172 objects:v197 count:16];
                          if (!v59)
                          {
LABEL_73:

                            if ((v158 & 1) != 0) {
                              goto LABEL_80;
                            }
                            goto LABEL_76;
                          }

                          continue;
                        }

                        goto LABEL_37;
                      }

                      id v100 = (void *)objc_claimAutoreleasedReturnValue([v170 publicEncryptionKey]);
                      id v71 = (id)objc_claimAutoreleasedReturnValue([v100 keyData]);

                      int v101 = (void *)objc_claimAutoreleasedReturnValue([v61 share]);
                      id v102 = (void *)objc_claimAutoreleasedReturnValue([v101 receiverPublicEncryptionKeySPKI]);
                      id v103 = [v102 isEqual:v71];

                      if (!v103)
                      {
                        id v109 = (void *)objc_claimAutoreleasedReturnValue([v169 tlk]);
                        __int128 v110 = (void *)objc_claimAutoreleasedReturnValue([v109 zoneName]);
                        __int128 v111 = sub_1000AA6AC(@"ckksshare", v110);
                        __int128 v112 = (os_log_s *)objc_claimAutoreleasedReturnValue(v111);

                        if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
                        {
                          __int128 v113 = (void *)objc_claimAutoreleasedReturnValue([v169 tlk]);
                          __int128 v114 = (void *)objc_claimAutoreleasedReturnValue([v113 uuid]);
                          *(_DWORD *)id v191 = 138412802;
                          id v192 = v170;
                          id v193 = 2112;
                          id v194 = v114;
                          id v195 = 2112;
                          unsigned int v196 = v61;
                          _os_log_impl( (void *)&_mh_execute_header,  v112,  OS_LOG_TYPE_DEFAULT,  "Peer %@ has a share for %@, but to old keys: %@",  v191,  0x20u);
                        }

                        [v159 addObject:v61];
                        goto LABEL_71;
                      }

                      uint64_t v104 = (void *)objc_claimAutoreleasedReturnValue([v169 tlk]);
                      __int128 v105 = (void *)objc_claimAutoreleasedReturnValue([v104 zoneName]);
                      __int128 v106 = sub_1000AA6AC(@"ckksshare", v105);
                      id v72 = (void *)objc_claimAutoreleasedReturnValue(v106);

                      if (os_log_type_enabled((os_log_t)v72, OS_LOG_TYPE_DEFAULT))
                      {
                        __int128 v107 = (void *)objc_claimAutoreleasedReturnValue([v169 tlk]);
                        __int128 v108 = (void *)objc_claimAutoreleasedReturnValue([v107 uuid]);
                        *(_DWORD *)id v191 = 138412802;
                        id v192 = v170;
                        id v193 = 2112;
                        id v194 = v108;
                        id v195 = 2112;
                        unsigned int v196 = v61;
                        _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)v72,  OS_LOG_TYPE_DEFAULT,  "Peer %@ is shared %@ via trusted %@",  v191,  0x20u);
                      }

  self->_timestampSslStart = v5[15];
  *(_DWORD *)&self->_has |= 0x4000u;
  id v10 = *((_DWORD *)v5 + 70);
  if ((v10 & 0x800) == 0)
  {
LABEL_52:
    if ((v10 & 0x400) == 0) {
      goto LABEL_53;
    }
    goto LABEL_83;
  }

void sub_100160F0C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id *location, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, id a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
}

uint64_t sub_10016144C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10016145C(uint64_t a1)
{
}

void sub_100161464(uint64_t a1)
{
  id v6 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) contextID]);
  uint64_t v3 = objc_claimAutoreleasedReturnValue(+[CKKSCurrentKeySet loadForZone:contextID:](&OBJC_CLASS___CKKSCurrentKeySet, "loadForZone:contextID:", v6, v2));
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

char *sub_1001614E8(uint64_t a1)
{
  CFStringRef result = (char *)[*(id *)(a1 + 32) count];
  if ((unint64_t)&result[-*(void *)(a1 + 56)] <= 0x3E8) {
    return (char *)+[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:]( &OBJC_CLASS___SecurityAnalyticsReporterRTC,  "sendMetricWithEvent:success:error:",  *(void *)(a1 + 40),  *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL),  0LL);
  }
  return result;
}

void sub_100161540(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  CFStringRef v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
  id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 zoneName]);
  id v10 = sub_1000AA6AC(@"ckksshare", v9);
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);

  if (v7)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v13 = 138412546;
      id v14 = v6;
      __int16 v15 = 2112;
      id v16 = v7;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "error on row: %@ %@", (uint8_t *)&v13, 0x16u);
    }
  }

  else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    CFTypeRef v12 = (void *)objc_claimAutoreleasedReturnValue([v6 recordName]);
    int v13 = 138412290;
    id v14 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Successfully completed upload for record %@",  (uint8_t *)&v13,  0xCu);
  }
}

void sub_1001616A8(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 80));
  id v9 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained deps]);
  id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 databaseProvider]);
  id v14 = _NSConcreteStackBlock;
  uint64_t v15 = 3221225472LL;
  id v16 = sub_1001617E8;
  uint64_t v17 = &unk_100290EE0;
  id v18 = v7;
  id v19 = *(id *)(a1 + 32);
  id v20 = v6;
  id v21 = WeakRetained;
  __int128 v24 = *(_OWORD *)(a1 + 64);
  id v22 = *(id *)(a1 + 40);
  id v23 = *(id *)(a1 + 48);
  id v11 = v6;
  id v12 = v7;
  [v10 dispatchSyncWithSQLTransaction:&v14];

  int v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "operationQueue", v14, v15, v16, v17));
  [v13 addOperation:*(void *)(a1 + 56)];
}

uint64_t sub_1001617E8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 zoneName]);
  id v5 = sub_1000AA6AC(@"ckksshare", v4);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);

  if (v2)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v7 = *(CKKSTLKShareRecord **)(a1 + 32);
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v33 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_ERROR,  "Completed TLK Share heal operation with error: %@",  buf,  0xCu);
    }

    [*(id *)(a1 + 64) populateUnderlyingErrorsStartingWithRootError:*(void *)(a1 + 32)];
    CFStringRef v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 56) deps]);
    [v8 intransactionCKWriteFailed:*(void *)(a1 + 32) attemptedRecordsChanged:*(void *)(a1 + 72)];

    [*(id *)(a1 + 56) setCloudkitWriteFailures:1];
  }

  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Completed TLK Share heal operation with success",  buf,  2u);
    }

    *(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) += [*(id *)(a1 + 48) count];
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    id obj = *(id *)(a1 + 48);
    id v9 = [obj countByEnumeratingWithState:&v28 objects:v34 count:16];
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = *(void *)v29;
      while (2)
      {
        for (CFIndex i = 0LL; i != v10; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v29 != v11) {
            objc_enumerationMutation(obj);
          }
          uint64_t v13 = *(void *)(*((void *)&v28 + 1) + 8LL * (void)i);
          id v14 = objc_alloc(&OBJC_CLASS___CKKSTLKShareRecord);
          uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 56) deps]);
          id v16 = (void *)objc_claimAutoreleasedReturnValue([v15 contextID]);
          uint64_t v17 = -[CKKSCKRecordHolder initWithCKRecord:contextID:](v14, "initWithCKRecord:contextID:", v13, v16);

          id v27 = 0LL;
          LODWORD(v16) = -[CKKSSQLDatabaseObject saveToDatabase:](v17, "saveToDatabase:", &v27);
          id v18 = (CKKSTLKShareRecord *)v27;
          id v19 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
          id v20 = (void *)objc_claimAutoreleasedReturnValue([v19 zoneName]);
          id v21 = sub_1000AA6AC(@"ckksshare", v20);
          id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);

          if ((_DWORD)v16) {
            BOOL v23 = v18 == 0LL;
          }
          else {
            BOOL v23 = 0;
          }
          if (!v23)
          {
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 138412290;
              uint64_t v33 = v18;
              _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_ERROR,  "Couldn't save new TLKShare record to database: %@",  buf,  0xCu);
            }

            [*(id *)(a1 + 40) setViewKeyHierarchyState:@"error"];
            *(_BYTE *)(*(void *)(*(void *)(a1 + 88) + 8LL) + 24LL) = 0;
            [*(id *)(a1 + 64) populateUnderlyingErrorsStartingWithRootError:v18];

            goto LABEL_25;
          }

          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138412290;
            uint64_t v33 = v17;
            _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Successfully completed upload for %@",  buf,  0xCu);
          }
        }

        id v10 = [obj countByEnumeratingWithState:&v28 objects:v34 count:16];
        if (v10) {
          continue;
        }
        break;
      }
    }

    id v18 = 0LL;
LABEL_25:
  }

  return 1LL;
}

void sub_100161B80(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained deps]);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 overallLaunch]);
  [v4 addEvent:@"heal-tlk-shares-complete"];

  if ([WeakRetained failedDueToEssentialTrustState])
  {
    id v5 = @"lose_trust";
LABEL_7:
    [WeakRetained setNextState:v5];
    goto LABEL_8;
  }

  if ([WeakRetained cloudkitWriteFailures])
  {
    id v6 = sub_1000AA6AC(@"ckksheal", 0LL);
    id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v13 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Due to write failures, we'll retry later",  v13,  2u);
    }

    id v5 = @"healtlksharesfailed";
    goto LABEL_7;
  }

  id v10 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained intendedState]);
  [WeakRetained setNextState:v10];

  if (![WeakRetained failedDueToLockState])
  {
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v9 = 1LL;
    goto LABEL_9;
  }

  uint64_t v11 = *(void **)(a1 + 32);
  uint64_t v14 = kSecurityRTCFieldIsLocked;
  uint64_t v15 = &__kCFBooleanFalse;
  id v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v15,  &v14,  1LL));
  [v11 addMetrics:v12];

LABEL_8:
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = 0LL;
LABEL_9:
  +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:]( &OBJC_CLASS___SecurityAnalyticsReporterRTC,  "sendMetricWithEvent:success:error:",  v8,  v9,  0LL);
}

void sub_1001638F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
}

void sub_100163964(uint64_t a1)
{
  __int128 context = objc_autoreleasePoolPush();
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) peerID]);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) tlk]);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 contextID]);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) tlk]);
  id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 uuid]);
  id v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) tlk]);
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 zoneID]);
  uint64_t v9 = *(void *)(*(void *)(a1 + 56) + 8LL);
  id obj = *(id *)(v9 + 40);
  uint64_t v10 = objc_claimAutoreleasedReturnValue( +[CKKSTLKShareRecord allFor:contextID:keyUUID:zoneID:error:]( &OBJC_CLASS___CKKSTLKShareRecord,  "allFor:contextID:keyUUID:zoneID:error:",  v2,  v4,  v6,  v8,  &obj));
  objc_storeStrong((id *)(v9 + 40), obj);
  uint64_t v11 = *(void *)(*(void *)(a1 + 48) + 8LL);
  id v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = v10;

  objc_autoreleasePoolPop(context);
}

void sub_100163D50( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_100163DD8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_100164100( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_100164120(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_100164C68( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_100164C84(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100164C94(uint64_t a1)
{
}

void sub_100164C9C(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([a3 userInfo]);
  id obj = (id)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:@"CKRetryAfter"]);

  id v5 = obj;
  if (obj)
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
    if (!*(void *)(v6 + 40))
    {
LABEL_5:
      objc_storeStrong((id *)(v6 + 40), obj);
      id v5 = obj;
      goto LABEL_6;
    }

    [obj doubleValue];
    double v8 = v7;
    [*(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) doubleValue];
    id v5 = obj;
    if (v8 < v9)
    {
      uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
      goto LABEL_5;
    }
  }

uint64_t sub_100164FEC(uint64_t a1)
{
  uint64_t v1 = a1;
  if ([*(id *)(a1 + 32) isCancelled])
  {
    id v2 = sub_1000AA6AC(@"ckksreencrypt", 0LL);
    uint64_t v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "CKKSReencryptOutgoingItemsOperation cancelled, quitting",  buf,  2u);
    }

LABEL_73:
  uint32_t v40 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  self->_timestampDnsStart));
  [v3 setObject:v40 forKey:@"timestamp_dns_start"];

  id v19 = self->_has;
  if ((*(_WORD *)&v19 & 0x100) == 0)
  {
LABEL_36:
    if ((*(_DWORD *)&v19 & 0x10000) == 0) {
      goto LABEL_37;
    }
    goto LABEL_75;
  }

  PBDataWriterWriteUint64Field(v20, self->_timestampDnsStart, 204LL);
  uint64_t v14 = self->_has;
  if ((*(_WORD *)&v14 & 0x100) == 0)
  {
LABEL_36:
    if ((*(_DWORD *)&v14 & 0x10000) == 0) {
      goto LABEL_37;
    }
    goto LABEL_75;
  }

  v4[10] = self->_timestampDnsStart;
  *((_DWORD *)v4 + 70) |= 0x200u;
  double v7 = self->_has;
  if ((*(_WORD *)&v7 & 0x100) == 0)
  {
LABEL_36:
    if ((*(_DWORD *)&v7 & 0x10000) == 0) {
      goto LABEL_37;
    }
    goto LABEL_75;
  }

LABEL_86:
  id v52 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  self->_optionsTimeoutIntervalForRequest));
  [v3 setObject:v52 forKey:@"options_timeout_interval_for_request"];

  if ((*(_DWORD *)&self->_has & 0x400000) != 0)
  {
LABEL_52:
    BOOL v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  self->_optionsTimeoutIntervalForResource));
    [v3 setObject:v23 forKey:@"options_timeout_interval_for_resource"];
  }

  PBDataWriterWriteUint32Field(v20, self->_optionsTimeoutIntervalForRequest, 306LL);
  if ((*(_DWORD *)&self->_has & 0x400000) != 0) {
LABEL_52:
  }
    PBDataWriterWriteUint32Field(v20, self->_optionsTimeoutIntervalForResource, 307LL);
LABEL_53:
  optionsSourceApplicationBundleIdentifier = self->_optionsSourceApplicationBundleIdentifier;
  if (optionsSourceApplicationBundleIdentifier) {
    PBDataWriterWriteStringField(v20, optionsSourceApplicationBundleIdentifier, 308LL);
  }
  optionsSourceApplicationSecondaryIdentifier = self->_optionsSourceApplicationSecondaryIdentifier;
  if (optionsSourceApplicationSecondaryIdentifier) {
    PBDataWriterWriteStringField(v20, optionsSourceApplicationSecondaryIdentifier, 309LL);
  }
  id v19 = self->_has;
  if ((*(_DWORD *)&v19 & 0x4000000) != 0)
  {
    PBDataWriterWriteBOOLField(v20, self->_optionsAppleIdContext, 310LL);
    id v19 = self->_has;
  }

  if ((*(_DWORD *)&v19 & 0x20000000) != 0) {
    PBDataWriterWriteBOOLField(v20, self->_optionsTlsPinningRequired, 311LL);
  }
}

  *((_DWORD *)v4 + 66) = self->_optionsTimeoutIntervalForRequest;
  *((_DWORD *)v4 + 70) |= 0x200000u;
  if ((*(_DWORD *)&self->_has & 0x400000) != 0)
  {
LABEL_52:
    *((_DWORD *)v4 + 67) = self->_optionsTimeoutIntervalForResource;
    *((_DWORD *)v4 + 70) |= 0x400000u;
  }

  unsigned int v41 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v41);
  }

LABEL_53:
  optionsSourceApplicationBundleIdentifier = self->_optionsSourceApplicationBundleIdentifier;
  if (optionsSourceApplicationBundleIdentifier) {
    [v3 setObject:optionsSourceApplicationBundleIdentifier forKey:@"options_source_application_bundle_identifier"];
  }
  optionsSourceApplicationSecondaryIdentifier = self->_optionsSourceApplicationSecondaryIdentifier;
  if (optionsSourceApplicationSecondaryIdentifier) {
    [v3 setObject:optionsSourceApplicationSecondaryIdentifier forKey:@"options_source_application_secondary_identifier"];
  }
  id v26 = self->_has;
  if ((*(_DWORD *)&v26 & 0x4000000) != 0)
  {
    id v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", self->_optionsAppleIdContext));
    [v3 setObject:v27 forKey:@"options_apple_id_context"];

    id v26 = self->_has;
  }

  if ((*(_DWORD *)&v26 & 0x20000000) != 0)
  {
    __int128 v28 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  self->_optionsTlsPinningRequired));
    [v3 setObject:v28 forKey:@"options_tls_pinning_required"];
  }

  __int128 v29 = v3;

  return v29;
}

  if (self->_optionsSourceApplicationBundleIdentifier)
  {
    objc_msgSend(v10, "setOptionsSourceApplicationBundleIdentifier:");
    uint64_t v4 = v10;
  }

  if (self->_optionsSourceApplicationSecondaryIdentifier)
  {
    objc_msgSend(v10, "setOptionsSourceApplicationSecondaryIdentifier:");
    uint64_t v4 = v10;
  }

  unsigned __int8 v9 = self->_has;
  if ((*(_DWORD *)&v9 & 0x4000000) != 0)
  {
    *((_BYTE *)v4 + 275) = self->_optionsAppleIdContext;
    *((_DWORD *)v4 + 70) |= 0x4000000u;
    unsigned __int8 v9 = self->_has;
  }

  if ((*(_DWORD *)&v9 & 0x20000000) != 0)
  {
    *((_BYTE *)v4 + 27_Block_object_dispose(va, 8) = self->_optionsTlsPinningRequired;
    *((_DWORD *)v4 + 70) |= 0x20000000u;
  }
}

  v6[17] = self->_timestampTcpStart;
  *((_DWORD *)v6 + 70) |= 0x10000u;
  id v25 = self->_has;
  if ((*(_WORD *)&v25 & 0x8000) == 0)
  {
LABEL_22:
    if ((*(_WORD *)&v25 & 0x4000) == 0) {
      goto LABEL_23;
    }
    goto LABEL_55;
  }

LABEL_64:
  *((_DWORD *)v6 + 66) = self->_optionsTimeoutIntervalForRequest;
  *((_DWORD *)v6 + 70) |= 0x200000u;
  if ((*(_DWORD *)&self->_has & 0x400000) != 0)
  {
LABEL_34:
    *((_DWORD *)v6 + 67) = self->_optionsTimeoutIntervalForResource;
    *((_DWORD *)v6 + 70) |= 0x400000u;
  }

  id v44 = -[SOSAccountTrust fullPeerInfo](self, "fullPeerInfo") != 0LL;

  return v44;
}

LABEL_193:
    BOOL v23 = 0;
    goto LABEL_194;
  }

  BOOL v23 = (v22 & 0x20000000) == 0;
LABEL_194:

  return v23;
}

LABEL_82:
  self->_timestampRequestStart = v5[12];
  *(_DWORD *)&self->_has |= 0x800u;
  uint64_t v10 = *((_DWORD *)v5 + 70);
  if ((v10 & 0x400) == 0)
  {
LABEL_53:
    if ((v10 & 0x2000) == 0) {
      goto LABEL_54;
    }
    goto LABEL_84;
  }

LABEL_90:
  self->_optionsTimeoutIntervalForRequest = *((_DWORD *)v5 + 66);
  *(_DWORD *)&self->_has |= 0x200000u;
  if ((v5[35] & 0x400000) != 0)
  {
LABEL_64:
    self->_optionsTimeoutIntervalForResource = *((_DWORD *)v5 + 67);
    *(_DWORD *)&self->_has |= 0x400000u;
  }

LABEL_65:
  if (v5[31])
  {
    -[SECC2MPNetworkEvent setOptionsSourceApplicationBundleIdentifier:]( self,  "setOptionsSourceApplicationBundleIdentifier:");
    id v5 = v13;
  }

  if (v5[32])
  {
    -[SECC2MPNetworkEvent setOptionsSourceApplicationSecondaryIdentifier:]( self,  "setOptionsSourceApplicationSecondaryIdentifier:");
    id v5 = v13;
  }

  id v12 = *((_DWORD *)v5 + 70);
  if ((v12 & 0x4000000) != 0)
  {
    self->_optionsAppleIdContext = *((_BYTE *)v5 + 275);
    *(_DWORD *)&self->_has |= 0x4000000u;
    id v12 = *((_DWORD *)v5 + 70);
  }

  if ((v12 & 0x20000000) != 0)
  {
    self->_optionsTlsPinningRequired = *((_BYTE *)v5 + 278);
    *(_DWORD *)&self->_has |= 0x20000000u;
  }
}

uint64_t sub_10016A928(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
    return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
  }
  uint64_t v4 = &OBJC_IVAR___SECC2MPMetric__networkEvent;
  id v5 = &OBJC_IVAR___SECC2MPMetric__networkEvent;
  uint64_t v6 = &OBJC_IVAR___SECC2MPMetric__networkEvent;
  while (1)
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v7 = 0;
    unsigned int v8 = 0;
    unint64_t v9 = 0LL;
    while (1)
    {
      unint64_t v10 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v10 == -1LL || v10 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v11 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v10);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v10 + 1;
      v9 |= (unint64_t)(v11 & 0x7F) << v7;
      if ((v11 & 0x80) == 0) {
        goto LABEL_12;
      }
      v7 += 7;
      BOOL v12 = v8++ >= 9;
      if (v12)
      {
        unint64_t v9 = 0LL;
        int v13 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_14;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_12:
    int v13 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v9 = 0LL;
    }
LABEL_14:
    if (v13 || (v9 & 7) == 4) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    unint64_t v15 = v9 >> 3;
    switch((_DWORD)v15)
    {
      case 1:
        char v29 = 0;
        unsigned int v30 = 0;
        uint64_t v18 = 0LL;
        *(_DWORD *)(a1 + v4[681]) |= 0x20000u;
        while (1)
        {
          unint64_t v31 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v31 == -1LL || v31 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v32 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v31);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v31 + 1;
          v18 |= (unint64_t)(v32 & 0x7F) << v29;
          if ((v32 & 0x80) == 0) {
            goto LABEL_63;
          }
          v29 += 7;
          BOOL v12 = v30++ >= 9;
          if (v12)
          {
            uint64_t v18 = 0LL;
            goto LABEL_65;
          }
        }

        *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_63:
        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0LL;
        }
LABEL_65:
        uint64_t v38 = v5[682];
        break;
      case 2:
        char v33 = 0;
        unsigned int v34 = 0;
        uint64_t v18 = 0LL;
        *(_DWORD *)(a1 + v4[681]) |= 8u;
        while (1)
        {
          unint64_t v35 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v35 == -1LL || v35 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v36 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v35);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v35 + 1;
          v18 |= (unint64_t)(v36 & 0x7F) << v33;
          if ((v36 & 0x80) == 0) {
            goto LABEL_67;
          }
          v33 += 7;
          BOOL v12 = v34++ >= 9;
          if (v12)
          {
            uint64_t v18 = 0LL;
            goto LABEL_69;
          }
        }

        *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_67:
        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0LL;
        }
LABEL_69:
        uint64_t v38 = v6[683];
        break;
      case 3:
        char v21 = 0;
        unsigned int v22 = 0;
        uint64_t v18 = 0LL;
        *(_DWORD *)(a1 + v4[681]) |= 0x10u;
        while (1)
        {
          unint64_t v23 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v23 == -1LL || v23 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v24 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v23);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v23 + 1;
          v18 |= (unint64_t)(v24 & 0x7F) << v21;
          if ((v24 & 0x80) == 0) {
            goto LABEL_59;
          }
          v21 += 7;
          BOOL v12 = v22++ >= 9;
          if (v12)
          {
            uint64_t v18 = 0LL;
            goto LABEL_61;
          }
        }

        *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_59:
        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0LL;
        }
LABEL_61:
        uint64_t v38 = 40LL;
        break;
      default:
LABEL_56:
        uint64_t result = PBReaderSkipValueWithTag(a2);
        if (!(_DWORD)result) {
          return result;
        }
        goto LABEL_71;
    }

LABEL_70:
    *(void *)(a1 + v3_Block_object_dispose(va, 8) = v18;
LABEL_71:
    if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
  }

  switch((int)v15)
  {
    case 'e':
      uint64_t String = PBReaderReadString(a2);
      uint64_t v26 = objc_claimAutoreleasedReturnValue(String);
      uint64_t v27 = 232LL;
      goto LABEL_252;
    case 'f':
      uint64_t v83 = PBReaderReadString(a2);
      uint64_t v26 = objc_claimAutoreleasedReturnValue(v83);
      uint64_t v27 = 168LL;
      goto LABEL_252;
    case 'g':
      uint64_t v84 = PBReaderReadString(a2);
      uint64_t v26 = objc_claimAutoreleasedReturnValue(v84);
      uint64_t v27 = 200LL;
      goto LABEL_252;
    case 'h':
      uint64_t v85 = PBReaderReadString(a2);
      uint64_t v26 = objc_claimAutoreleasedReturnValue(v85);
      uint64_t v27 = 152LL;
      goto LABEL_252;
    case 'i':
      char v86 = 0;
      unsigned int v87 = 0;
      uint64_t v88 = 0LL;
      *(_DWORD *)(a1 + v4[681]) |= 0x800000u;
      while (2)
      {
        unint64_t v89 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v89 == -1LL || v89 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
        }

        else
        {
          char v90 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v89);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v89 + 1;
          v88 |= (unint64_t)(v90 & 0x7F) << v86;
          if (v90 < 0)
          {
            v86 += 7;
            BOOL v12 = v87++ >= 9;
            if (v12)
            {
              uint64_t v88 = 0LL;
              goto LABEL_318;
            }

            continue;
          }
        }

        break;
      }

      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        uint64_t v88 = 0LL;
      }
LABEL_318:
      BOOL v164 = v88 != 0;
      uint64_t v165 = 272LL;
      goto LABEL_376;
    case 'j':
      uint64_t v91 = PBReaderReadString(a2);
      uint64_t v26 = objc_claimAutoreleasedReturnValue(v91);
      uint64_t v27 = 176LL;
      goto LABEL_252;
    case 'k':
      uint64_t v92 = PBReaderReadString(a2);
      uint64_t v26 = objc_claimAutoreleasedReturnValue(v92);
      uint64_t v27 = 192LL;
      goto LABEL_252;
    case 'l':
      char v93 = 0;
      unsigned int v94 = 0;
      uint64_t v95 = 0LL;
      *(_DWORD *)(a1 + v4[681]) |= 0x80000u;
      while (2)
      {
        unint64_t v96 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v96 == -1LL || v96 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
        }

        else
        {
          char v97 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v96);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v96 + 1;
          v95 |= (unint64_t)(v97 & 0x7F) << v93;
          if (v97 < 0)
          {
            v93 += 7;
            BOOL v12 = v94++ >= 9;
            if (v12)
            {
              LODWORD(v95) = 0;
              goto LABEL_322;
            }

            continue;
          }
        }

        break;
      }

      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        LODWORD(v95) = 0;
      }
LABEL_322:
      uint64_t v166 = 208LL;
      goto LABEL_367;
    case 'm':
      char v98 = 0;
      unsigned int v99 = 0;
      uint64_t v18 = 0LL;
      *(_DWORD *)(a1 + v4[681]) |= 1u;
      while (2)
      {
        unint64_t v100 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v100 == -1LL || v100 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
        }

        else
        {
          char v101 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v100);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v100 + 1;
          v18 |= (unint64_t)(v101 & 0x7F) << v98;
          if (v101 < 0)
          {
            v98 += 7;
            BOOL v12 = v99++ >= 9;
            if (v12)
            {
              uint64_t v18 = 0LL;
              goto LABEL_326;
            }

            continue;
          }
        }

        break;
      }

      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        uint64_t v18 = 0LL;
      }
LABEL_326:
      uint64_t v38 = 8LL;
      goto LABEL_70;
    case 'n':
      char v102 = 0;
      unsigned int v103 = 0;
      uint64_t v95 = 0LL;
      *(_DWORD *)(a1 + v4[681]) |= 0x100000u;
      while (2)
      {
        unint64_t v104 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v104 == -1LL || v104 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
        }

        else
        {
          char v105 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v104);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v104 + 1;
          v95 |= (unint64_t)(v105 & 0x7F) << v102;
          if (v105 < 0)
          {
            v102 += 7;
            BOOL v12 = v103++ >= 9;
            if (v12)
            {
              LODWORD(v95) = 0;
              goto LABEL_330;
            }

            continue;
          }
        }

        break;
      }

      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        LODWORD(v95) = 0;
      }
LABEL_330:
      uint64_t v166 = 224LL;
      goto LABEL_367;
    case 'o':
      char v106 = 0;
      unsigned int v107 = 0;
      uint64_t v18 = 0LL;
      *(_DWORD *)(a1 + v4[681]) |= 2u;
      while (2)
      {
        unint64_t v108 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v108 == -1LL || v108 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
        }

        else
        {
          char v109 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v108);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v108 + 1;
          v18 |= (unint64_t)(v109 & 0x7F) << v106;
          if (v109 < 0)
          {
            v106 += 7;
            BOOL v12 = v107++ >= 9;
            if (v12)
            {
              uint64_t v18 = 0LL;
              goto LABEL_334;
            }

            continue;
          }
        }

        break;
      }

      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        uint64_t v18 = 0LL;
      }
LABEL_334:
      uint64_t v38 = 16LL;
      goto LABEL_70;
    case 'p':
      char v110 = 0;
      unsigned int v111 = 0;
      uint64_t v95 = 0LL;
      *(_DWORD *)(a1 + v4[681]) |= 0x40000u;
      while (2)
      {
        unint64_t v112 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v112 == -1LL || v112 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
        }

        else
        {
          char v113 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v112);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v112 + 1;
          v95 |= (unint64_t)(v113 & 0x7F) << v110;
          if (v113 < 0)
          {
            v110 += 7;
            BOOL v12 = v111++ >= 9;
            if (v12)
            {
              LODWORD(v95) = 0;
              goto LABEL_338;
            }

            continue;
          }
        }

        break;
      }

      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        LODWORD(v95) = 0;
      }
LABEL_338:
      uint64_t v166 = 184LL;
      goto LABEL_367;
    case 'q':
      __int128 v114 = v4;
      __int128 v115 = v6;
      __int128 v116 = v5;
      id v117 = objc_alloc_init(&OBJC_CLASS___SECC2MPError);
      objc_storeStrong((id *)(a1 + 160), v117);
      v167[0] = 0xAAAAAAAAAAAAAAAALL;
      v167[1] = 0xAAAAAAAAAAAAAAAALL;
      if (PBReaderPlaceMark(a2, v167) && (sub_10011ECE0((uint64_t)v117, a2) & 1) != 0)
      {
        PBReaderRecallMark(a2, v167);

        id v5 = v116;
        uint64_t v6 = v115;
        uint64_t v4 = v114;
        goto LABEL_71;
      }

      return 0LL;
    case 'r':
      char v118 = 0;
      unsigned int v119 = 0;
      uint64_t v18 = 0LL;
      *(_DWORD *)(a1 + v4[681]) |= 4u;
      while (2)
      {
        unint64_t v120 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v120 == -1LL || v120 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
        }

        else
        {
          char v121 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v120);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v120 + 1;
          v18 |= (unint64_t)(v121 & 0x7F) << v118;
          if (v121 < 0)
          {
            v118 += 7;
            BOOL v12 = v119++ >= 9;
            if (v12)
            {
              uint64_t v18 = 0LL;
              goto LABEL_342;
            }

            continue;
          }
        }

        break;
      }

      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        uint64_t v18 = 0LL;
      }
LABEL_342:
      uint64_t v38 = 24LL;
      goto LABEL_70;
    case 's':
      uint64_t v122 = PBReaderReadString(a2);
      uint64_t v26 = objc_claimAutoreleasedReturnValue(v122);
      uint64_t v27 = 216LL;
LABEL_252:
      id v153 = *(void **)(a1 + v27);
      *(void *)(a1 + v27) = v26;

      goto LABEL_71;
    default:
      switch((int)v15)
      {
        case 201:
          char v16 = 0;
          unsigned int v17 = 0;
          uint64_t v18 = 0LL;
          *(_DWORD *)(a1 + v4[681]) |= 0x20u;
          while (2)
          {
            unint64_t v19 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            if (v19 == -1LL || v19 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v20 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v19);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v19 + 1;
              v18 |= (unint64_t)(v20 & 0x7F) << v16;
              if (v20 < 0)
              {
                v16 += 7;
                BOOL v12 = v17++ >= 9;
                if (v12)
                {
                  uint64_t v18 = 0LL;
                  goto LABEL_270;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            uint64_t v18 = 0LL;
          }
LABEL_270:
          uint64_t v38 = 48LL;
          goto LABEL_70;
        case 202:
          char v39 = 0;
          unsigned int v40 = 0;
          uint64_t v18 = 0LL;
          *(_DWORD *)(a1 + v4[681]) |= 0x80u;
          while (2)
          {
            unint64_t v41 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            if (v41 == -1LL || v41 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v42 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v41);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v41 + 1;
              v18 |= (unint64_t)(v42 & 0x7F) << v39;
              if (v42 < 0)
              {
                v39 += 7;
                BOOL v12 = v40++ >= 9;
                if (v12)
                {
                  uint64_t v18 = 0LL;
                  goto LABEL_274;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            uint64_t v18 = 0LL;
          }
LABEL_274:
          uint64_t v38 = 64LL;
          goto LABEL_70;
        case 203:
          char v43 = 0;
          unsigned int v44 = 0;
          uint64_t v18 = 0LL;
          *(_DWORD *)(a1 + v4[681]) |= 0x40u;
          while (2)
          {
            unint64_t v45 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            if (v45 == -1LL || v45 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v46 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v45);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v45 + 1;
              v18 |= (unint64_t)(v46 & 0x7F) << v43;
              if (v46 < 0)
              {
                v43 += 7;
                BOOL v12 = v44++ >= 9;
                if (v12)
                {
                  uint64_t v18 = 0LL;
                  goto LABEL_278;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            uint64_t v18 = 0LL;
          }
LABEL_278:
          uint64_t v38 = 56LL;
          goto LABEL_70;
        case 204:
          char v47 = 0;
          unsigned int v48 = 0;
          uint64_t v18 = 0LL;
          *(_DWORD *)(a1 + v4[681]) |= 0x200u;
          while (2)
          {
            unint64_t v49 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            if (v49 == -1LL || v49 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v50 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v49);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v49 + 1;
              v18 |= (unint64_t)(v50 & 0x7F) << v47;
              if (v50 < 0)
              {
                v47 += 7;
                BOOL v12 = v48++ >= 9;
                if (v12)
                {
                  uint64_t v18 = 0LL;
                  goto LABEL_282;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            uint64_t v18 = 0LL;
          }
LABEL_282:
          uint64_t v38 = 80LL;
          goto LABEL_70;
        case 205:
          char v51 = 0;
          unsigned int v52 = 0;
          uint64_t v18 = 0LL;
          *(_DWORD *)(a1 + v4[681]) |= 0x100u;
          while (2)
          {
            unint64_t v53 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            if (v53 == -1LL || v53 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v54 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v53);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v53 + 1;
              v18 |= (unint64_t)(v54 & 0x7F) << v51;
              if (v54 < 0)
              {
                v51 += 7;
                BOOL v12 = v52++ >= 9;
                if (v12)
                {
                  uint64_t v18 = 0LL;
                  goto LABEL_286;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            uint64_t v18 = 0LL;
          }
LABEL_286:
          uint64_t v38 = 72LL;
          goto LABEL_70;
        case 206:
          char v55 = 0;
          unsigned int v56 = 0;
          uint64_t v18 = 0LL;
          *(_DWORD *)(a1 + v4[681]) |= 0x10000u;
          while (2)
          {
            unint64_t v57 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            if (v57 == -1LL || v57 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v58 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v57);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v57 + 1;
              v18 |= (unint64_t)(v58 & 0x7F) << v55;
              if (v58 < 0)
              {
                v55 += 7;
                BOOL v12 = v56++ >= 9;
                if (v12)
                {
                  uint64_t v18 = 0LL;
                  goto LABEL_290;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            uint64_t v18 = 0LL;
          }
LABEL_290:
          uint64_t v38 = 136LL;
          goto LABEL_70;
        case 207:
          char v59 = 0;
          unsigned int v60 = 0;
          uint64_t v18 = 0LL;
          *(_DWORD *)(a1 + v4[681]) |= 0x8000u;
          while (2)
          {
            unint64_t v61 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            if (v61 == -1LL || v61 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v62 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v61);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v61 + 1;
              v18 |= (unint64_t)(v62 & 0x7F) << v59;
              if (v62 < 0)
              {
                v59 += 7;
                BOOL v12 = v60++ >= 9;
                if (v12)
                {
                  uint64_t v18 = 0LL;
                  goto LABEL_294;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            uint64_t v18 = 0LL;
          }
LABEL_294:
          uint64_t v38 = 128LL;
          goto LABEL_70;
        case 208:
          char v63 = 0;
          unsigned int v64 = 0;
          uint64_t v18 = 0LL;
          *(_DWORD *)(a1 + v4[681]) |= 0x4000u;
          while (2)
          {
            unint64_t v65 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            if (v65 == -1LL || v65 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v66 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v65);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v65 + 1;
              v18 |= (unint64_t)(v66 & 0x7F) << v63;
              if (v66 < 0)
              {
                v63 += 7;
                BOOL v12 = v64++ >= 9;
                if (v12)
                {
                  uint64_t v18 = 0LL;
                  goto LABEL_298;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            uint64_t v18 = 0LL;
          }
LABEL_298:
          uint64_t v38 = 120LL;
          goto LABEL_70;
        case 209:
          char v67 = 0;
          unsigned int v68 = 0;
          uint64_t v18 = 0LL;
          *(_DWORD *)(a1 + v4[681]) |= 0x800u;
          while (2)
          {
            unint64_t v69 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            if (v69 == -1LL || v69 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v70 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v69);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v69 + 1;
              v18 |= (unint64_t)(v70 & 0x7F) << v67;
              if (v70 < 0)
              {
                v67 += 7;
                BOOL v12 = v68++ >= 9;
                if (v12)
                {
                  uint64_t v18 = 0LL;
                  goto LABEL_302;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            uint64_t v18 = 0LL;
          }
LABEL_302:
          uint64_t v38 = 96LL;
          goto LABEL_70;
        case 210:
          char v71 = 0;
          unsigned int v72 = 0;
          uint64_t v18 = 0LL;
          *(_DWORD *)(a1 + v4[681]) |= 0x400u;
          while (2)
          {
            unint64_t v73 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            if (v73 == -1LL || v73 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v74 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v73);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v73 + 1;
              v18 |= (unint64_t)(v74 & 0x7F) << v71;
              if (v74 < 0)
              {
                v71 += 7;
                BOOL v12 = v72++ >= 9;
                if (v12)
                {
                  uint64_t v18 = 0LL;
                  goto LABEL_306;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            uint64_t v18 = 0LL;
          }
LABEL_306:
          uint64_t v38 = 88LL;
          goto LABEL_70;
        case 211:
          char v75 = 0;
          unsigned int v76 = 0;
          uint64_t v18 = 0LL;
          *(_DWORD *)(a1 + v4[681]) |= 0x2000u;
          while (2)
          {
            unint64_t v77 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            if (v77 == -1LL || v77 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v78 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v77);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v77 + 1;
              v18 |= (unint64_t)(v78 & 0x7F) << v75;
              if (v78 < 0)
              {
                v75 += 7;
                BOOL v12 = v76++ >= 9;
                if (v12)
                {
                  uint64_t v18 = 0LL;
                  goto LABEL_310;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            uint64_t v18 = 0LL;
          }
LABEL_310:
          uint64_t v38 = 112LL;
          goto LABEL_70;
        case 212:
          char v79 = 0;
          unsigned int v80 = 0;
          uint64_t v18 = 0LL;
          *(_DWORD *)(a1 + v4[681]) |= 0x1000u;
          while (2)
          {
            unint64_t v81 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
            if (v81 == -1LL || v81 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
            {
              *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
            }

            else
            {
              char v82 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v81);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v81 + 1;
              v18 |= (unint64_t)(v82 & 0x7F) << v79;
              if (v82 < 0)
              {
                v79 += 7;
                BOOL v12 = v80++ >= 9;
                if (v12)
                {
                  uint64_t v18 = 0LL;
                  goto LABEL_314;
                }

                continue;
              }
            }

            break;
          }

          if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
            uint64_t v18 = 0LL;
          }
LABEL_314:
          uint64_t v38 = 104LL;
          goto LABEL_70;
        default:
          switch((int)v15)
          {
            case 301:
              uint64_t v28 = PBReaderReadString(a2);
              uint64_t v26 = objc_claimAutoreleasedReturnValue(v28);
              uint64_t v27 = 240LL;
              goto LABEL_252;
            case 302:
              char v123 = 0;
              unsigned int v124 = 0;
              uint64_t v125 = 0LL;
              *(_DWORD *)(a1 + v4[681]) |= 0x8000000u;
              while (2)
              {
                unint64_t v126 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
                if (v126 == -1LL || v126 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
                {
                  *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
                }

                else
                {
                  char v127 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v126);
                  *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v126 + 1;
                  v125 |= (unint64_t)(v127 & 0x7F) << v123;
                  if (v127 < 0)
                  {
                    v123 += 7;
                    BOOL v12 = v124++ >= 9;
                    if (v12)
                    {
                      uint64_t v125 = 0LL;
                      goto LABEL_346;
                    }

                    continue;
                  }
                }

                break;
              }

              if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
                uint64_t v125 = 0LL;
              }
LABEL_346:
              BOOL v164 = v125 != 0;
              uint64_t v165 = 276LL;
              goto LABEL_376;
            case 303:
              char v128 = 0;
              unsigned int v129 = 0;
              uint64_t v130 = 0LL;
              *(_DWORD *)(a1 + v4[681]) |= 0x10000000u;
              while (2)
              {
                unint64_t v131 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
                if (v131 == -1LL || v131 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
                {
                  *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
                }

                else
                {
                  char v132 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v131);
                  *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v131 + 1;
                  v130 |= (unint64_t)(v132 & 0x7F) << v128;
                  if (v132 < 0)
                  {
                    v128 += 7;
                    BOOL v12 = v129++ >= 9;
                    if (v12)
                    {
                      uint64_t v130 = 0LL;
                      goto LABEL_350;
                    }

                    continue;
                  }
                }

                break;
              }

              if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
                uint64_t v130 = 0LL;
              }
LABEL_350:
              BOOL v164 = v130 != 0;
              uint64_t v165 = 277LL;
              goto LABEL_376;
            case 304:
              char v133 = 0;
              unsigned int v134 = 0;
              uint64_t v135 = 0LL;
              *(_DWORD *)(a1 + v4[681]) |= 0x1000000u;
              while (2)
              {
                unint64_t v136 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
                if (v136 == -1LL || v136 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
                {
                  *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
                }

                else
                {
                  char v137 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v136);
                  *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v136 + 1;
                  v135 |= (unint64_t)(v137 & 0x7F) << v133;
                  if (v137 < 0)
                  {
                    v133 += 7;
                    BOOL v12 = v134++ >= 9;
                    if (v12)
                    {
                      uint64_t v135 = 0LL;
                      goto LABEL_354;
                    }

                    continue;
                  }
                }

                break;
              }

              if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
                uint64_t v135 = 0LL;
              }
LABEL_354:
              BOOL v164 = v135 != 0;
              uint64_t v165 = 273LL;
              goto LABEL_376;
            case 305:
              char v138 = 0;
              unsigned int v139 = 0;
              uint64_t v140 = 0LL;
              *(_DWORD *)(a1 + v4[681]) |= 0x2000000u;
              while (2)
              {
                unint64_t v141 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
                if (v141 == -1LL || v141 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
                {
                  *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
                }

                else
                {
                  char v142 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v141);
                  *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v141 + 1;
                  v140 |= (unint64_t)(v142 & 0x7F) << v138;
                  if (v142 < 0)
                  {
                    v138 += 7;
                    BOOL v12 = v139++ >= 9;
                    if (v12)
                    {
                      uint64_t v140 = 0LL;
                      goto LABEL_358;
                    }

                    continue;
                  }
                }

                break;
              }

              if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
                uint64_t v140 = 0LL;
              }
LABEL_358:
              BOOL v164 = v140 != 0;
              uint64_t v165 = 274LL;
              goto LABEL_376;
            case 306:
              char v143 = 0;
              unsigned int v144 = 0;
              uint64_t v95 = 0LL;
              *(_DWORD *)(a1 + v4[681]) |= 0x200000u;
              while (2)
              {
                unint64_t v145 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
                if (v145 == -1LL || v145 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
                {
                  *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
                }

                else
                {
                  char v146 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v145);
                  *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v145 + 1;
                  v95 |= (unint64_t)(v146 & 0x7F) << v143;
                  if (v146 < 0)
                  {
                    v143 += 7;
                    BOOL v12 = v144++ >= 9;
                    if (v12)
                    {
                      LODWORD(v95) = 0;
                      goto LABEL_362;
                    }

                    continue;
                  }
                }

                break;
              }

              if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
                LODWORD(v95) = 0;
              }
LABEL_362:
              uint64_t v166 = 264LL;
              goto LABEL_367;
            case 307:
              char v147 = 0;
              unsigned int v148 = 0;
              uint64_t v95 = 0LL;
              *(_DWORD *)(a1 + v4[681]) |= 0x400000u;
              while (2)
              {
                unint64_t v149 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
                if (v149 == -1LL || v149 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
                {
                  *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
                }

                else
                {
                  char v150 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v149);
                  *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v149 + 1;
                  v95 |= (unint64_t)(v150 & 0x7F) << v147;
                  if (v150 < 0)
                  {
                    v147 += 7;
                    BOOL v12 = v148++ >= 9;
                    if (v12)
                    {
                      LODWORD(v95) = 0;
                      goto LABEL_366;
                    }

                    continue;
                  }
                }

                break;
              }

              if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
                LODWORD(v95) = 0;
              }
LABEL_366:
              uint64_t v166 = 268LL;
LABEL_367:
              *(_DWORD *)(a1 + v166) = v95;
              goto LABEL_71;
            case 308:
              uint64_t v151 = PBReaderReadString(a2);
              uint64_t v26 = objc_claimAutoreleasedReturnValue(v151);
              uint64_t v27 = 248LL;
              goto LABEL_252;
            case 309:
              uint64_t v152 = PBReaderReadString(a2);
              uint64_t v26 = objc_claimAutoreleasedReturnValue(v152);
              uint64_t v27 = 256LL;
              goto LABEL_252;
            case 310:
              char v154 = 0;
              unsigned int v155 = 0;
              uint64_t v156 = 0LL;
              *(_DWORD *)(a1 + v4[681]) |= 0x4000000u;
              while (2)
              {
                unint64_t v157 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
                if (v157 == -1LL || v157 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
                {
                  *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
                }

                else
                {
                  char v158 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v157);
                  *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v157 + 1;
                  v156 |= (unint64_t)(v158 & 0x7F) << v154;
                  if (v158 < 0)
                  {
                    v154 += 7;
                    BOOL v12 = v155++ >= 9;
                    if (v12)
                    {
                      uint64_t v156 = 0LL;
                      goto LABEL_371;
                    }

                    continue;
                  }
                }

                break;
              }

              if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
                uint64_t v156 = 0LL;
              }
LABEL_371:
              BOOL v164 = v156 != 0;
              uint64_t v165 = 275LL;
              goto LABEL_376;
            case 311:
              char v159 = 0;
              unsigned int v160 = 0;
              uint64_t v161 = 0LL;
              *(_DWORD *)(a1 + v4[681]) |= 0x20000000u;
              break;
            default:
              goto LABEL_56;
          }

          break;
      }

      while (2)
      {
        unint64_t v162 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v162 == -1LL || v162 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
        }

        else
        {
          char v163 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v162);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v162 + 1;
          v161 |= (unint64_t)(v163 & 0x7F) << v159;
          if (v163 < 0)
          {
            v159 += 7;
            BOOL v12 = v160++ >= 9;
            if (v12)
            {
              uint64_t v161 = 0LL;
              goto LABEL_375;
            }

            continue;
          }
        }

        break;
      }

      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        uint64_t v161 = 0LL;
      }
LABEL_375:
      BOOL v164 = v161 != 0;
      uint64_t v165 = 278LL;
LABEL_376:
      *(_BYTE *)(a1 + v165) = v164;
      goto LABEL_71;
  }

void sub_10016C3C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10016C488( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10016C71C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_10016C80C(_Unwind_Exception *a1)
{
}

void sub_10016CBC4(_Unwind_Exception *a1)
{
}

void sub_10016CD34( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
}

void sub_10016D624(_Unwind_Exception *a1)
{
}

void sub_10016D78C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  uint64_t v3 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained octagonContainerMap]);
    [v4 setObject:*(void *)(a1 + 32) forKey:*(void *)(a1 + 40)];

    id v5 = (void *)objc_claimAutoreleasedReturnValue([v3 undeliveredCuttlefishUpdates]);
    unsigned int v6 = [v5 containsObject:*(void *)(a1 + 40)];

    if (v6)
    {
      char v7 = (void *)objc_claimAutoreleasedReturnValue([v3 undeliveredCuttlefishUpdates]);
      [v7 removeObject:*(void *)(a1 + 40)];

      id v8 = sub_1000AA6AC(@"octagonpush", 0LL);
      unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        uint64_t v11 = *(void *)(a1 + 40);
        uint64_t v10 = *(void *)(a1 + 48);
        uint64_t v12 = *(void *)(a1 + 32);
        int v15 = 138412802;
        uint64_t v16 = v10;
        __int16 v17 = 2112;
        uint64_t v18 = v11;
        __int16 v19 = 2112;
        uint64_t v20 = v12;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_ERROR,  "sending fake push to newly-registered cuttlefish receiver(%@-%@): %@",  (uint8_t *)&v15,  0x20u);
      }

      [*(id *)(a1 + 32) notifyContainerChange:0];
    }

    [*(id *)(a1 + 56) fulfill];
  }

  else
  {
    id v13 = sub_1000AA6AC(@"octagonpush", 0LL);
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v15) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_ERROR,  "received registration for released OctagonAPSReceiver",  (uint8_t *)&v15,  2u);
    }
  }
}

void sub_10016D934(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  id v3 = sub_1000AA6AC(@"octagonpush", 0LL);
  uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  id v5 = v4;
  if (WeakRetained)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(a1 + 32);
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v28 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Registering new CKKS push receiver: %@",  buf,  0xCu);
    }

    uint64_t v7 = *(void *)(a1 + 32);
    id v8 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained zoneUpdateReceiverDictionary]);
    [v8 setObject:v7 forKeyedSubscript:*(void *)(a1 + 40)];

    unint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained undeliveredUpdates]);
    uint64_t v10 = (os_log_s *)[v9 copy];

    id v22 = WeakRetained;
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained undeliveredUpdates]);
    [v11 removeAllObjects];

    __int128 v25 = 0u;
    __int128 v26 = 0u;
    __int128 v23 = 0u;
    __int128 v24 = 0u;
    char v21 = v10;
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s allObjects](v10, "allObjects"));
    id v13 = [v12 countByEnumeratingWithState:&v23 objects:v31 count:16];
    if (v13)
    {
      id v14 = v13;
      uint64_t v15 = *(void *)v24;
      do
      {
        for (CFIndex i = 0LL; i != v14; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v24 != v15) {
            objc_enumerationMutation(v12);
          }
          uint64_t v17 = *(void *)(*((void *)&v23 + 1) + 8LL * (void)i);
          id v18 = sub_1000AA6AC(@"octagonpush", 0LL);
          __int16 v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            uint64_t v20 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 138412546;
            uint64_t v28 = v17;
            __int16 v29 = 2112;
            uint64_t v30 = v20;
            _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "sending stored push(%@) to newly-registered receiver: %@",  buf,  0x16u);
          }

          [*(id *)(a1 + 32) notifyZoneChange:v17];
        }

        id v14 = [v12 countByEnumeratingWithState:&v23 objects:v31 count:16];
      }

      while (v14);
    }

    [*(id *)(a1 + 48) fulfill];
    id v5 = v21;
    id WeakRetained = v22;
  }

  else if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "received registration for released OctagonAPSReceiver",  buf,  2u);
  }
}

void sub_10016DBD8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v13 = WeakRetained;
    id v3 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained environmentMap]);
    id v4 = (id)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:*(void *)(a1 + 32)]);

    if (!v4)
    {
      id v5 = objc_msgSend(objc_msgSend(v13, "apsConnectionClass"), "alloc");
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v13 namedDelegatePort]);
      id v8 = (void *)objc_claimAutoreleasedReturnValue(+[OctagonAPSReceiver apsDeliveryQueue](&OBJC_CLASS___OctagonAPSReceiver, "apsDeliveryQueue"));
      id v4 = [v5 initWithEnvironmentName:v6 namedDelegatePort:v7 queue:v8];

      unint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v13 environmentMap]);
      [v9 setObject:v4 forKeyedSubscript:*(void *)(a1 + 32)];

      [v4 setDelegate:v13];
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( [@"com.apple.icloud-container." stringByAppendingString:@"com.apple.securityd"]);
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v13 cuttlefishPushTopics]);
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 arrayByAddingObject:v10]);
      [v4 setEnabledTopics:v12];
    }

    id WeakRetained = v13;
  }
}

void sub_10016DD20(uint64_t a1)
{
  id v2 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue( +[OctagonAPSReceiver apsDeliveryQueue]( &OBJC_CLASS___OctagonAPSReceiver,  "apsDeliveryQueue"));
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10016DDB8;
  block[3] = &unk_100291A38;
  objc_copyWeak(&v4, (id *)(a1 + 32));
  dispatch_async(v2, block);

  objc_destroyWeak(&v4);
}

void sub_10016DDB8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v5 = WeakRetained;
    id v2 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained undeliveredUpdates]);
    id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
    [v5 setUndeliveredUpdates:v3];

    id v4 = (void *)objc_claimAutoreleasedReturnValue([v5 undeliveredCuttlefishUpdates]);
    [v4 removeAllObjects];

    [v5 reportDroppedPushes:v2];
    id WeakRetained = v5;
  }
}

void sub_10016DE44(uint64_t a1)
{
  id v3 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) undeliveredUpdates]);
  if ([v3 count])
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  }

  else
  {
    id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) undeliveredCuttlefishUpdates]);
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [v2 count] != 0;
  }
}

uint64_t sub_10016DEC4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10016DED4(uint64_t a1)
{
}

void sub_10016DEDC(uint64_t a1)
{
  id v5 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) environmentMap]);
  uint64_t v2 = objc_claimAutoreleasedReturnValue([v5 allKeys]);
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_10016DFE4(_Unwind_Exception *a1)
{
}

void sub_10016E048( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_10016E0EC(id a1)
{
  dispatch_queue_attr_t v1 = dispatch_queue_attr_make_with_autorelease_frequency(0LL, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  id v4 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue(v1);
  dispatch_queue_t v2 = dispatch_queue_create("aps-callback-queue", v4);
  uint64_t v3 = (void *)qword_1002DECE0;
  qword_1002DECE0 = (uint64_t)v2;
}

void sub_10016E854( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, id location)
{
}

void sub_10016EB1C(_Unwind_Exception *a1)
{
}

void sub_10016EE68( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
}

void sub_10016EE90(id *a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(a1 + 7);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained databaseProvider]);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_10016EFB0;
  void v7[3] = &unk_1002911B0;
  id v8 = a1[4];
  id v6 = v3;
  id v9 = v6;
  id v10 = a1[5];
  id v11 = a1[6];
  objc_copyWeak(&v13, a1 + 7);
  id v12 = WeakRetained;
  [v5 dispatchSyncWithReadOnlySQLTransaction:v7];

  objc_destroyWeak(&v13);
}

void sub_10016EF9C(_Unwind_Exception *a1)
{
}

void sub_10016EFB0(id *a1)
{
  dispatch_queue_attr_t v1 = a1 + 4;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([a1[4] contextID]);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([*v1 zoneID]);
  id v125 = 0LL;
  unsigned int v99 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSCurrentKeyPointer tryFromDatabase:contextID:zoneID:error:]( &OBJC_CLASS___CKKSCurrentKeyPointer,  "tryFromDatabase:contextID:zoneID:error:",  @"tlk",  v2,  v3,  &v125));
  id v95 = v125;

  if (v99
    && ((id v4 = (void *)objc_claimAutoreleasedReturnValue([v99 currentKeyUUID])) != 0
      ? (BOOL v5 = v95 == 0LL)
      : (BOOL v5 = 0),
        v5 ? (int v6 = 0) : (int v6 = 1),
        v4,
        !v6))
  {
    char v98 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
    __int128 v123 = 0u;
    __int128 v124 = 0u;
    __int128 v121 = 0u;
    __int128 v122 = 0u;
    id obj = a1[6];
    id v11 = [obj countByEnumeratingWithState:&v121 objects:v131 count:16];
    if (v11)
    {
      uint64_t v12 = *(void *)v122;
      while (2)
      {
        for (CFIndex i = 0LL; i != v11; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v122 != v12) {
            objc_enumerationMutation(obj);
          }
          id v14 = *(void **)(*((void *)&v121 + 1) + 8LL * (void)i);
          uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([a1[4] zoneID]);
          uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([a1[4] contextID]);
          uint64_t v17 = (CKModifyRecordsOperation *)objc_claimAutoreleasedReturnValue([v14 makeTLKShareRecord:v15 contextID:v16]);

          id v18 = (void *)objc_claimAutoreleasedReturnValue(-[CKModifyRecordsOperation tlkUUID](v17, "tlkUUID"));
          __int16 v19 = (void *)objc_claimAutoreleasedReturnValue([v99 currentKeyUUID]);
          unsigned __int8 v20 = [v18 isEqualToString:v19];

          char v21 = (void *)objc_claimAutoreleasedReturnValue([a1[4] zoneID]);
          id v22 = v21;
          if ((v20 & 1) == 0)
          {
            char v79 = (void *)objc_claimAutoreleasedReturnValue([v21 zoneName]);
            id v80 = sub_1000AA6AC(@"ckks-se", v79);
            unint64_t v81 = (os_log_s *)objc_claimAutoreleasedReturnValue(v80);

            if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
            {
              char v82 = (void *)objc_claimAutoreleasedReturnValue([v99 currentKeyUUID]);
              *(_DWORD *)__int128 buf = 138412546;
              *(void *)uint64_t v130 = v82;
              *(_WORD *)&v130[8] = 2112;
              *(void *)&v130[10] = v14;
              _os_log_impl( (void *)&_mh_execute_header,  v81,  OS_LOG_TYPE_ERROR,  "TLKShare is not for the current TLK(%@): %@",  buf,  0x16u);
            }

            uint64_t v83 = (void *)objc_claimAutoreleasedReturnValue([v99 currentKeyUUID]);
            uint64_t v84 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"TLKShare is not for current TLK %@",  v83));
            uint64_t v85 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  @"CKKSErrorDomain",  61LL,  v84));
            [a1[5] setError:v85];

            goto LABEL_66;
          }

          __int128 v23 = (void *)objc_claimAutoreleasedReturnValue(-[CKModifyRecordsOperation CKRecordWithZoneID:](v17, "CKRecordWithZoneID:", v21));
          [v98 addObject:v23];
        }

        id v11 = [obj countByEnumeratingWithState:&v121 objects:v131 count:16];
        if (v11) {
          continue;
        }
        break;
      }
    }

    id obj = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
    __int128 v119 = 0u;
    __int128 v120 = 0u;
    __int128 v117 = 0u;
    __int128 v118 = 0u;
    uint64_t v92 = (CKModifyRecordsOperation *)a1[7];
    id v94 = -[CKModifyRecordsOperation countByEnumeratingWithState:objects:count:]( v92,  "countByEnumeratingWithState:objects:count:",  &v117,  v128,  16LL);
    if (v94)
    {
      uint64_t v93 = *(void *)v118;
      while (2)
      {
        uint64_t v24 = 0LL;
        do
        {
          if (*(void *)v118 != v93)
          {
            uint64_t v25 = v24;
            objc_enumerationMutation(v92);
            uint64_t v24 = v25;
          }

          uint64_t v96 = v24;
          char v97 = *(void **)(*((void *)&v117 + 1) + 8 * v24);
          __int128 v26 = (void *)objc_claimAutoreleasedReturnValue([a1[4] zoneID]);
          uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([a1[4] contextID]);
          char v101 = (void *)objc_claimAutoreleasedReturnValue([v97 makeTLKShareRecord:v26 contextID:v27]);

          uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v101 tlkUUID]);
          __int16 v29 = (void *)objc_claimAutoreleasedReturnValue([a1[4] contextID]);
          uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v101 share]);
          unint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v30 receiverPeerID]);
          char v32 = (void *)objc_claimAutoreleasedReturnValue([v101 share]);
          char v33 = (void *)objc_claimAutoreleasedReturnValue([v32 senderPeerID]);
          unsigned int v34 = (void *)objc_claimAutoreleasedReturnValue([a1[4] zoneID]);
          id v116 = 0LL;
          unint64_t v35 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSTLKShareRecord fromDatabase:contextID:receiverPeerID:senderPeerID:zoneID:error:]( &OBJC_CLASS___CKKSTLKShareRecord,  "fromDatabase:contextID:receiverPeerID:senderPeerID:zoneID:error:",  v28,  v29,  v31,  v33,  v34,  &v116));
          id v36 = v116;

          if (v35) {
            BOOL v37 = v36 == 0LL;
          }
          else {
            BOOL v37 = 0;
          }
          char v38 = v37;
          char v39 = (void *)objc_claimAutoreleasedReturnValue([a1[4] zoneID]);
          unsigned int v40 = v39;
          if ((v38 & 1) == 0)
          {
            char v86 = (void *)objc_claimAutoreleasedReturnValue([v39 zoneName]);
            id v87 = sub_1000AA6AC(@"ckks-se", v86);
            uint64_t v88 = (os_log_s *)objc_claimAutoreleasedReturnValue(v87);

            if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 138412546;
              *(void *)uint64_t v130 = v97;
              *(_WORD *)&v130[8] = 2112;
              *(void *)&v130[10] = v36;
              _os_log_impl( (void *)&_mh_execute_header,  v88,  OS_LOG_TYPE_ERROR,  "Unable to load TLKShare (to delete): %@ %@",  buf,  0x16u);
            }

            [a1[5] setError:v36];
            goto LABEL_65;
          }

          unint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v35 CKRecordWithZoneID:v39]);

          char v42 = (void *)objc_claimAutoreleasedReturnValue([v41 recordID]);
          [obj addObject:v42];

          uint64_t v24 = v96 + 1;
        }

        while (v94 != (id)(v96 + 1));
        id v94 = -[CKModifyRecordsOperation countByEnumeratingWithState:objects:count:]( v92,  "countByEnumeratingWithState:objects:count:",  &v117,  v128,  16LL);
        if (v94) {
          continue;
        }
        break;
      }
    }

    if ([v98 count] || objc_msgSend(obj, "count"))
    {
      uint64_t v92 = -[CKModifyRecordsOperation initWithRecordsToSave:recordIDsToDelete:]( objc_alloc(&OBJC_CLASS___CKModifyRecordsOperation),  "initWithRecordsToSave:recordIDsToDelete:",  v98,  obj);
      -[CKModifyRecordsOperation setAtomic:](v92, "setAtomic:", 1LL);
      char v43 = (void *)objc_claimAutoreleasedReturnValue(-[CKModifyRecordsOperation configuration](v92, "configuration"));
      [v43 setIsCloudKitSupportOperation:1];

      -[CKModifyRecordsOperation setSavePolicy:](v92, "setSavePolicy:", 0LL);
      unsigned int v44 = (void *)objc_claimAutoreleasedReturnValue([a1[4] zoneID]);
      unint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v44 zoneName]);
      id v46 = sub_1000AA6AC(@"ckks-se", v45);
      char v47 = (os_log_s *)objc_claimAutoreleasedReturnValue(v46);

      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v48 = -[CKModifyRecordsOperation qualityOfService](v92, "qualityOfService");
        unint64_t v49 = (void *)objc_claimAutoreleasedReturnValue(-[CKModifyRecordsOperation group](v92, "group"));
        *(_DWORD *)__int128 buf = 67109378;
        *(_DWORD *)uint64_t v130 = v48;
        *(_WORD *)&v130[4] = 2112;
        *(void *)&v130[6] = v49;
        _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "QoS: %d; operation group is %@",
          buf,
          0x12u);
      }

      char v50 = (void *)objc_claimAutoreleasedReturnValue([a1[4] zoneID]);
      char v51 = (void *)objc_claimAutoreleasedReturnValue([v50 zoneName]);
      id v52 = sub_1000AA6AC(@"ckks-se", v51);
      unint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue(v52);

      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v54 = [v98 count];
        unsigned int v55 = [obj count];
        *(_DWORD *)__int128 buf = 67109376;
        *(_DWORD *)uint64_t v130 = v54;
        *(_WORD *)&v130[4] = 1024;
        *(_DWORD *)&v130[6] = v55;
        _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_DEFAULT,  "Beginning upload for %d records, deleting %d records",  buf,  0xEu);
      }

      __int128 v114 = 0u;
      __int128 v115 = 0u;
      __int128 v112 = 0u;
      __int128 v113 = 0u;
      id v56 = v98;
      id v57 = [v56 countByEnumeratingWithState:&v112 objects:v127 count:16];
      if (v57)
      {
        uint64_t v58 = *(void *)v113;
        do
        {
          for (j = 0LL; j != v57; j = (char *)j + 1)
          {
            if (*(void *)v113 != v58) {
              objc_enumerationMutation(v56);
            }
            unsigned int v60 = *(void **)(*((void *)&v112 + 1) + 8LL * (void)j);
            unint64_t v61 = (void *)objc_claimAutoreleasedReturnValue([v60 recordID]);
            char v62 = (void *)objc_claimAutoreleasedReturnValue([v61 zoneID]);
            char v63 = (void *)objc_claimAutoreleasedReturnValue([v62 zoneName]);
            id v64 = sub_1000AA6AC(@"ckks-se", v63);
            unint64_t v65 = (os_log_s *)objc_claimAutoreleasedReturnValue(v64);

            if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
            {
              char v66 = (void *)objc_claimAutoreleasedReturnValue([v60 recordID]);
              *(_DWORD *)__int128 buf = 138412290;
              *(void *)uint64_t v130 = v66;
              _os_log_debug_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEBUG, "Record to save: %@", buf, 0xCu);
            }
          }

          id v57 = [v56 countByEnumeratingWithState:&v112 objects:v127 count:16];
        }

        while (v57);
      }

      __int128 v110 = 0u;
      __int128 v111 = 0u;
      __int128 v108 = 0u;
      __int128 v109 = 0u;
      id obj = obj;
      id v67 = [obj countByEnumeratingWithState:&v108 objects:v126 count:16];
      if (v67)
      {
        uint64_t v68 = *(void *)v109;
        do
        {
          for (k = 0LL; k != v67; k = (char *)k + 1)
          {
            if (*(void *)v109 != v68) {
              objc_enumerationMutation(obj);
            }
            char v70 = *(void **)(*((void *)&v108 + 1) + 8LL * (void)k);
            char v71 = (void *)objc_claimAutoreleasedReturnValue([v70 zoneID]);
            unsigned int v72 = (void *)objc_claimAutoreleasedReturnValue([v71 zoneName]);
            id v73 = sub_1000AA6AC(@"ckks-se", v72);
            char v74 = (os_log_s *)objc_claimAutoreleasedReturnValue(v73);

            if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)__int128 buf = 138412290;
              *(void *)uint64_t v130 = v70;
              _os_log_debug_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEBUG, "Record to delete: %@", buf, 0xCu);
            }
          }

          id v67 = [obj countByEnumeratingWithState:&v108 objects:v126 count:16];
        }

        while (v67);
      }

      -[CKModifyRecordsOperation setPerRecordSaveBlock:](v92, "setPerRecordSaveBlock:", &stru_100291140);
      char v75 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSResultOperation named:withBlock:]( &OBJC_CLASS___CKKSResultOperation,  "named:withBlock:",  @"wait-until-write-finished",  &stru_100291160));
      [a1[5] dependOnBeforeGroupFinished:v75];
      v103[0] = _NSConcreteStackBlock;
      v103[1] = 3221225472LL;
      v103[2] = sub_10016FCCC;
      v103[3] = &unk_100291188;
      objc_copyWeak(&v107, a1 + 9);
      id v104 = a1[4];
      id v105 = a1[5];
      id v76 = v75;
      id v106 = v76;
      -[CKModifyRecordsOperation setModifyRecordsCompletionBlock:](v92, "setModifyRecordsCompletionBlock:", v103);
      unint64_t v77 = (void *)objc_claimAutoreleasedReturnValue([a1[8] operationDependencies]);
      char v78 = (void *)objc_claimAutoreleasedReturnValue([v77 ckdatabase]);
      [v78 addOperation:v92];

      objc_destroyWeak(&v107);
LABEL_65:
      uint64_t v17 = v92;
    }

    else
    {
      unint64_t v89 = (void *)objc_claimAutoreleasedReturnValue([a1[4] zoneID]);
      char v90 = (void *)objc_claimAutoreleasedReturnValue([v89 zoneName]);
      id v91 = sub_1000AA6AC(@"ckks-se", v90);
      uint64_t v17 = (CKModifyRecordsOperation *)objc_claimAutoreleasedReturnValue(v91);

      if (os_log_type_enabled((os_log_t)v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)v17,  OS_LOG_TYPE_DEFAULT,  "Requested modifications are a no-op; claiming success",
          buf,
          2u);
      }
    }

void sub_10016FCAC(_Unwind_Exception *a1)
{
}

void sub_10016FCCC(id *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained(a1 + 7);
  id v11 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained databaseProvider]);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472LL;
  v15[2] = sub_10016FDF8;
  v15[3] = &unk_100291080;
  id v16 = v9;
  id v17 = a1[4];
  id v18 = a1[5];
  id v19 = a1[6];
  id v20 = v7;
  id v21 = WeakRetained;
  id v22 = v8;
  id v12 = v8;
  id v13 = v7;
  id v14 = v9;
  [v11 dispatchSyncWithSQLTransaction:v15];
}

uint64_t sub_10016FDF8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 zoneName]);
  id v5 = sub_1000AA6AC(@"ckks-se", v4);
  int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);

  if (v2)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v34 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "error proposing new TLK: %@", buf, 0xCu);
    }

    [*(id *)(a1 + 48) setError:*(void *)(a1 + 32)];
  }

  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Completed modifying TLK share records!",  buf,  2u);
    }

    __int128 v29 = 0u;
    __int128 v30 = 0u;
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    id v8 = *(id *)(a1 + 64);
    id v9 = [v8 countByEnumeratingWithState:&v27 objects:v32 count:16];
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = *(void *)v28;
      do
      {
        for (CFIndex i = 0LL; i != v10; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v28 != v11) {
            objc_enumerationMutation(v8);
          }
          uint64_t v13 = *(void *)(*((void *)&v27 + 1) + 8LL * (void)i);
          id v14 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 72) operationDependencies]);
          [v14 intransactionCKRecordChanged:v13 resync:0];
        }

        id v10 = [v8 countByEnumeratingWithState:&v27 objects:v32 count:16];
      }

      while (v10);
    }

    __int128 v25 = 0u;
    __int128 v26 = 0u;
    __int128 v23 = 0u;
    __int128 v24 = 0u;
    id v15 = *(id *)(a1 + 80);
    id v16 = [v15 countByEnumeratingWithState:&v23 objects:v31 count:16];
    if (v16)
    {
      id v17 = v16;
      uint64_t v18 = *(void *)v24;
      do
      {
        for (j = 0LL; j != v17; j = (char *)j + 1)
        {
          if (*(void *)v24 != v18) {
            objc_enumerationMutation(v15);
          }
          uint64_t v20 = *(void *)(*((void *)&v23 + 1) + 8LL * (void)j);
          id v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 72), "operationDependencies", (void)v23));
          [v21 intransactionCKRecordDeleted:v20 recordType:@"tlkshare" resync:0];
        }

        id v17 = [v15 countByEnumeratingWithState:&v23 objects:v31 count:16];
      }

      while (v17);
    }
  }

  objc_msgSend(*(id *)(a1 + 48), "runBeforeGroupFinished:", *(void *)(a1 + 56), (void)v23);
  return 1LL;
}

void sub_1001700A8(id a1, CKRecordID *a2, CKRecord *a3, NSError *a4)
{
  int v6 = a2;
  uint64_t v7 = a3;
  id v8 = a4;
  id v9 = (void *)objc_claimAutoreleasedReturnValue(-[CKRecordID zoneID](v6, "zoneID"));
  id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 zoneName]);
  id v11 = sub_1000AA6AC(@"ckks-se", v10);
  id v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);

  if (v8)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      int v15 = 138412546;
      id v16 = v8;
      __int16 v17 = 2112;
      uint64_t v18 = v7;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "error on row: %@ %@", (uint8_t *)&v15, 0x16u);
    }
  }

  else if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = (NSError *)objc_claimAutoreleasedReturnValue(-[CKRecordID recordName](v6, "recordName"));
    id v14 = (CKRecord *)objc_claimAutoreleasedReturnValue(-[CKRecord recordChangeTag](v7, "recordChangeTag"));
    int v15 = 138412546;
    id v16 = v13;
    __int16 v17 = 2112;
    uint64_t v18 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Record upload successful for %@ (%@)",  (uint8_t *)&v15,  0x16u);
  }
}

void sub_10017023C(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) contextID]);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneName]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSZoneStateEntry contextID:zoneName:]( &OBJC_CLASS___CKKSZoneStateEntry,  "contextID:zoneName:",  v2,  v3));

  id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 getChangeToken]);
  if (v5)
  {
    int v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) contextID]);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
    id v66 = 0LL;
    id v8 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSCurrentKeyPointer tryFromDatabase:contextID:zoneID:error:]( &OBJC_CLASS___CKKSCurrentKeyPointer,  "tryFromDatabase:contextID:zoneID:error:",  @"tlk",  v6,  v7,  &v66));
    id v9 = v66;

    if (v9)
    {
      id v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
      id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 zoneName]);
      id v12 = sub_1000AA6AC(@"ckks-se", v11);
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);

      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        id v69 = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_ERROR,  "Error loading TLK pointer for this zone: %@",  buf,  0xCu);
      }

      (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
    }

    else if (v8)
    {
      uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v8 currentKeyUUID]);
      id v19 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) contextID]);
      uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
      id v65 = 0LL;
      id v21 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSKey fromDatabaseAnyState:contextID:zoneID:error:]( &OBJC_CLASS___CKKSKey,  "fromDatabaseAnyState:contextID:zoneID:error:",  v18,  v19,  v20,  &v65));
      id v9 = v65;

      if (!v21 || v9)
      {
        id v46 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
        char v47 = (void *)objc_claimAutoreleasedReturnValue([v46 zoneName]);
        id v48 = sub_1000AA6AC(@"ckks-se", v47);
        unint64_t v49 = (os_log_s *)objc_claimAutoreleasedReturnValue(v48);

        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "No TLK for this zone", buf, 2u);
        }

        (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
      }

      else
      {
        id v22 = objc_alloc(&OBJC_CLASS___CKKSExternalKey);
        __int128 v23 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
        __int128 v24 = (void *)objc_claimAutoreleasedReturnValue([v23 zoneName]);
        uint64_t v58 = -[CKKSExternalKey initWithViewName:tlk:](v22, "initWithViewName:tlk:", v24, v21);

        __int128 v25 = (void *)objc_claimAutoreleasedReturnValue([v8 currentKeyUUID]);
        __int128 v26 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) contextID]);
        __int128 v27 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
        id v64 = 0LL;
        __int128 v28 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSTLKShareRecord allForUUID:contextID:zoneID:error:]( &OBJC_CLASS___CKKSTLKShareRecord,  "allForUUID:contextID:zoneID:error:",  v25,  v26,  v27,  &v64));
        id v9 = v64;

        if (!v28 || v9)
        {
          char v50 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
          char v51 = (void *)objc_claimAutoreleasedReturnValue([v50 zoneName]);
          id v52 = sub_1000AA6AC(@"ckks-se", v51);
          unint64_t v53 = (os_log_s *)objc_claimAutoreleasedReturnValue(v52);

          if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 138412290;
            id v69 = v9;
            _os_log_impl( (void *)&_mh_execute_header,  v53,  OS_LOG_TYPE_ERROR,  "Unable to load TLKShares for zone: %@",  buf,  0xCu);
          }

          (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
          unint64_t v41 = v58;
        }

        else
        {
          unsigned int v55 = v21;
          id v56 = v8;
          id v57 = v4;
          uint64_t v29 = a1;
          __int128 v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
          __int128 v60 = 0u;
          __int128 v61 = 0u;
          __int128 v62 = 0u;
          __int128 v63 = 0u;
          unsigned int v54 = v28;
          id obj = v28;
          id v31 = [obj countByEnumeratingWithState:&v60 objects:v67 count:16];
          if (v31)
          {
            id v32 = v31;
            uint64_t v33 = *(void *)v61;
            do
            {
              for (CFIndex i = 0LL; i != v32; CFIndex i = (char *)i + 1)
              {
                if (*(void *)v61 != v33) {
                  objc_enumerationMutation(obj);
                }
                unint64_t v35 = *(void **)(*((void *)&v60 + 1) + 8LL * (void)i);
                id v36 = objc_alloc(&OBJC_CLASS___CKKSExternalTLKShare);
                BOOL v37 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v29 + 32) zoneID]);
                char v38 = (void *)objc_claimAutoreleasedReturnValue([v37 zoneName]);
                char v39 = (void *)objc_claimAutoreleasedReturnValue([v35 share]);
                unsigned int v40 = -[CKKSExternalTLKShare initWithViewName:tlkShare:](v36, "initWithViewName:tlkShare:", v38, v39);

                [v30 addObject:v40];
              }

              id v32 = [obj countByEnumeratingWithState:&v60 objects:v67 count:16];
            }

            while (v32);
          }

          unint64_t v41 = v58;
          (*(void (**)(void))(*(void *)(v29 + 40) + 16LL))();

          id v8 = v56;
          id v4 = v57;
          id v21 = v55;
          id v9 = 0LL;
          __int128 v28 = v54;
        }
      }
    }

    else
    {
      char v42 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
      char v43 = (void *)objc_claimAutoreleasedReturnValue([v42 zoneName]);
      id v44 = sub_1000AA6AC(@"ckks-se", v43);
      unint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue(v44);

      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "No TLK pointer for this zone", buf, 2u);
      }

      (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
      id v9 = 0LL;
    }
  }

  else
  {
    id v9 = (id)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  @"CKKSErrorDomain",  66LL,  @"Initial fetch results not present; cannot provide accurate answer about TLK state"));
    id v14 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) zoneID]);
    int v15 = (void *)objc_claimAutoreleasedReturnValue([v14 zoneName]);
    id v16 = sub_1000AA6AC(@"ckks-se", v15);
    __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);

    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 138412290;
      id v69 = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_ERROR,  "Haven't successfully completed a fetch for this zone; returning %@",
        buf,
        0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
  }
}

void sub_100170970(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) error]);

  if (v3)
  {
    id v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 zoneName]);
    id v6 = sub_1000AA6AC(@"ckks-se", v5);
    uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);

    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      id v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) error]);
      int v11 = 138412290;
      id v12 = v8;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_ERROR,  "Error loading TLK pointer for this zone: %@",  (uint8_t *)&v11,  0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 48);
    id v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) error]);
    (*(void (**)(uint64_t, void, void, void, void *))(v9 + 16))(v9, 0LL, 0LL, 0LL, v10);
  }

  else
  {
    [WeakRetained loadKeys:*(void *)(a1 + 40) reply:*(void *)(a1 + 48)];
  }
}

void sub_100170AD8(id *a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(a1 + 9);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained databaseProvider]);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_100170C20;
  void v7[3] = &unk_1002910D0;
  id v8 = a1[4];
  id v9 = a1[5];
  id v6 = v3;
  id v10 = v6;
  id v11 = a1[6];
  id v14 = a1[8];
  id v12 = a1[7];
  objc_copyWeak(&v15, a1 + 9);
  id v13 = WeakRetained;
  [v5 dispatchSyncWithReadOnlySQLTransaction:v7];

  objc_destroyWeak(&v15);
}

void sub_100170C0C(_Unwind_Exception *a1)
{
}

void sub_100170C20(uint64_t a1)
{
  uint64_t v2 = (id *)(a1 + 40);
  id v3 = *(void **)(a1 + 32);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([*v2 contextID]);
  id v173 = 0LL;
  unsigned int v139 = (void *)objc_claimAutoreleasedReturnValue([v3 makeCKKSKey:v4 contextID:v5 error:&v173]);
  id v140 = v173;

  if (v139 && !v140)
  {
    id v6 = *(void **)(a1 + 32);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) contextID]);
    id v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
    id v172 = 0LL;
    char v138 = (void *)objc_claimAutoreleasedReturnValue([v6 makeFakeCKKSClassKey:@"classA" contextID:v7 zoneiD:v8 error:&v172]);
    id v9 = v172;

    id v10 = *(void **)(a1 + 32);
    id v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) contextID]);
    id v12 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
    id v171 = v9;
    char v137 = (void *)objc_claimAutoreleasedReturnValue([v10 makeFakeCKKSClassKey:@"classC" contextID:v11 zoneiD:v12 error:&v171]);
    id v140 = v171;

    if (!v138 || !v137)
    {
      __int128 v26 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
      __int128 v27 = (void *)objc_claimAutoreleasedReturnValue([v26 zoneName]);
      id v28 = sub_1000AA6AC(@"ckks-se", v27);
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);

      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        *(void *)id v176 = v140;
        _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_ERROR,  "Unable to make fake class keys: %@",  buf,  0xCu);
      }

      [*(id *)(a1 + 48) setError:v140];
      goto LABEL_80;
    }

    id v13 = *(void **)(a1 + 56);
    if (v13)
    {
      id v14 = (void *)objc_claimAutoreleasedReturnValue([v13 uuid]);
      id v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) contextID]);
      id v16 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
      id v170 = 0LL;
      char v143 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSKey fromDatabase:contextID:zoneID:error:]( &OBJC_CLASS___CKKSKey,  "fromDatabase:contextID:zoneID:error:",  v14,  v15,  v16,  &v170));
      id v136 = v170;

      if (!v143 || v136)
      {
        __int128 v115 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
        id v116 = (void *)objc_claimAutoreleasedReturnValue([v115 zoneName]);
        id v117 = sub_1000AA6AC(@"ckks-se", v116);
        __int128 v118 = (os_log_s *)objc_claimAutoreleasedReturnValue(v117);

        if (os_log_type_enabled(v118, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 138412290;
          *(void *)id v176 = v136;
          _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_ERROR, "Unable to load old TLK: %@", buf, 0xCu);
        }

        (*(void (**)(void))(*(void *)(a1 + 80) + 16LL))();
        goto LABEL_79;
      }

      __int16 v17 = *(void **)(a1 + 56);
      uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
      id v19 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) contextID]);
      id v169 = 0LL;
      id v136 = (id)objc_claimAutoreleasedReturnValue([v17 makeCKKSKey:v18 contextID:v19 error:&v169]);
      id v20 = v169;

      if (!v136 || v20)
      {
        __int128 v123 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
        __int128 v124 = (void *)objc_claimAutoreleasedReturnValue([v123 zoneName]);
        id v125 = sub_1000AA6AC(@"ckks-se", v124);
        unint64_t v126 = (os_log_s *)objc_claimAutoreleasedReturnValue(v125);

        if (os_log_type_enabled(v126, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 138412290;
          *(void *)id v176 = v20;
          _os_log_impl((void *)&_mh_execute_header, v126, OS_LOG_TYPE_ERROR, "Unable to convert old TLK: %@", buf, 0xCu);
        }

        [*(id *)(a1 + 48) setError:v20];
        goto LABEL_79;
      }

      id v21 = (void *)objc_claimAutoreleasedReturnValue([v143 storedCKRecord]);
      [v136 setStoredCKRecord:v21];
    }

    else
    {
      id v136 = 0LL;
    }

    char v143 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
    __int128 v167 = 0u;
    __int128 v168 = 0u;
    __int128 v165 = 0u;
    __int128 v166 = 0u;
    id v30 = *(id *)(a1 + 64);
    id v31 = [v30 countByEnumeratingWithState:&v165 objects:v179 count:16];
    if (v31)
    {
      uint64_t v32 = *(void *)v166;
      do
      {
        for (CFIndex i = 0LL; i != v31; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v166 != v32) {
            objc_enumerationMutation(v30);
          }
          uint64_t v34 = *(void **)(*((void *)&v165 + 1) + 8LL * (void)i);
          unint64_t v35 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
          id v36 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) contextID]);
          BOOL v37 = (void *)objc_claimAutoreleasedReturnValue([v34 makeTLKShareRecord:v35 contextID:v36]);

          [v143 addObject:v37];
        }

        id v31 = [v30 countByEnumeratingWithState:&v165 objects:v179 count:16];
      }

      while (v31);
    }

    char v38 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
    char v39 = (void *)objc_claimAutoreleasedReturnValue([v38 zoneName]);
    id v40 = sub_1000AA6AC(@"ckks-se", v39);
    unint64_t v41 = (os_log_s *)objc_claimAutoreleasedReturnValue(v40);

    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)id v176 = v139;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Trying to set TLK %@", buf, 0xCu);
    }

    char v42 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
    char v43 = (void *)objc_claimAutoreleasedReturnValue([v42 zoneName]);
    id v44 = sub_1000AA6AC(@"ckks-se", v43);
    unint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue(v44);

    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)id v176 = v136;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "Wrapped old TLK: %@", buf, 0xCu);
    }

    id v46 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
    char v47 = (void *)objc_claimAutoreleasedReturnValue([v46 zoneName]);
    id v48 = sub_1000AA6AC(@"ckks-se", v47);
    unint64_t v49 = (os_log_s *)objc_claimAutoreleasedReturnValue(v48);

    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)id v176 = v143;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "TLKShares: %@", buf, 0xCu);
    }

    char v50 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) contextID]);
    char v51 = (void *)objc_claimAutoreleasedReturnValue([v139 uuid]);
    id v52 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
    id v164 = 0LL;
    unsigned int v134 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSCurrentKeyPointer forKeyClass:contextID:withKeyUUID:zoneID:error:]( &OBJC_CLASS___CKKSCurrentKeyPointer,  "forKeyClass:contextID:withKeyUUID:zoneID:error:",  @"tlk",  v50,  v51,  v52,  &v164));
    id v135 = v164;

    if (!v134 || v135)
    {
      __int128 v119 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
      __int128 v120 = (void *)objc_claimAutoreleasedReturnValue([v119 zoneName]);
      id v121 = sub_1000AA6AC(@"ckks-se", v120);
      __int128 v122 = (os_log_s *)objc_claimAutoreleasedReturnValue(v121);

      if (os_log_type_enabled(v122, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 138412290;
        *(void *)id v176 = v135;
        _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_ERROR, "Unable to create CKP: %@", buf, 0xCu);
      }

      [*(id *)(a1 + 48) setError:v135];
    }

    else
    {
      unint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) contextID]);
      unsigned int v54 = (void *)objc_claimAutoreleasedReturnValue([v138 uuid]);
      unsigned int v55 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
      id v163 = 0LL;
      char v132 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSCurrentKeyPointer forKeyClass:contextID:withKeyUUID:zoneID:error:]( &OBJC_CLASS___CKKSCurrentKeyPointer,  "forKeyClass:contextID:withKeyUUID:zoneID:error:",  @"classA",  v53,  v54,  v55,  &v163));
      id v56 = v163;

      id v57 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) contextID]);
      uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue([v137 uuid]);
      char v59 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
      id v162 = v56;
      unint64_t v131 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSCurrentKeyPointer forKeyClass:contextID:withKeyUUID:zoneID:error:]( &OBJC_CLASS___CKKSCurrentKeyPointer,  "forKeyClass:contextID:withKeyUUID:zoneID:error:",  @"classC",  v57,  v58,  v59,  &v162));
      id v135 = v162;

      if (v132 && v131)
      {
        __int128 v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
        __int128 v61 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
        __int128 v62 = (void *)objc_claimAutoreleasedReturnValue([v139 CKRecordWithZoneID:v61]);
        [v60 addObject:v62];

        __int128 v63 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
        id v64 = (void *)objc_claimAutoreleasedReturnValue([v138 CKRecordWithZoneID:v63]);
        [v60 addObject:v64];

        id v65 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
        id v66 = (void *)objc_claimAutoreleasedReturnValue([v137 CKRecordWithZoneID:v65]);
        [v60 addObject:v66];

        id v67 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
        uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v134 CKRecordWithZoneID:v67]);
        [v60 addObject:v68];

        id v69 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
        char v70 = (void *)objc_claimAutoreleasedReturnValue([v132 CKRecordWithZoneID:v69]);
        [v60 addObject:v70];

        char v71 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
        unsigned int v72 = (void *)objc_claimAutoreleasedReturnValue([v131 CKRecordWithZoneID:v71]);
        [v60 addObject:v72];

        if (v136)
        {
          id v73 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
          char v74 = (void *)objc_claimAutoreleasedReturnValue([v136 CKRecordWithZoneID:v73]);
          [v60 addObject:v74];
        }

        __int128 v160 = 0u;
        __int128 v161 = 0u;
        __int128 v158 = 0u;
        __int128 v159 = 0u;
        id v75 = v143;
        id v76 = [v75 countByEnumeratingWithState:&v158 objects:v178 count:16];
        if (v76)
        {
          uint64_t v77 = *(void *)v159;
          do
          {
            for (j = 0LL; j != v76; j = (char *)j + 1)
            {
              if (*(void *)v159 != v77) {
                objc_enumerationMutation(v75);
              }
              char v79 = *(void **)(*((void *)&v158 + 1) + 8LL * (void)j);
              id v80 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID", v131));
              unint64_t v81 = (void *)objc_claimAutoreleasedReturnValue([v79 CKRecordWithZoneID:v80]);
              [v60 addObject:v81];
            }

            id v76 = [v75 countByEnumeratingWithState:&v158 objects:v178 count:16];
          }

          while (v76);
        }

        char v142 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
        __int128 v156 = 0u;
        __int128 v157 = 0u;
        __int128 v154 = 0u;
        __int128 v155 = 0u;
        id v82 = v60;
        id v83 = [v82 countByEnumeratingWithState:&v154 objects:v177 count:16];
        if (v83)
        {
          uint64_t v84 = *(void *)v155;
          do
          {
            for (k = 0LL; k != v83; k = (char *)k + 1)
            {
              if (*(void *)v155 != v84) {
                objc_enumerationMutation(v82);
              }
              char v86 = *(void **)(*((void *)&v154 + 1) + 8LL * (void)k);
              id v87 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v86, "recordID", v131));
              [v142 setObject:v86 forKeyedSubscript:v87];
            }

            id v83 = [v82 countByEnumeratingWithState:&v154 objects:v177 count:16];
          }

          while (v83);
        }

        char v133 = -[CKModifyRecordsOperation initWithRecordsToSave:recordIDsToDelete:]( objc_alloc(&OBJC_CLASS___CKModifyRecordsOperation),  "initWithRecordsToSave:recordIDsToDelete:",  v82,  &__NSArray0__struct);
        -[CKModifyRecordsOperation setAtomic:](v133, "setAtomic:", 1LL);
        uint64_t v88 = (void *)objc_claimAutoreleasedReturnValue(-[CKModifyRecordsOperation configuration](v133, "configuration"));
        [v88 setIsCloudKitSupportOperation:1];

        -[CKModifyRecordsOperation setSavePolicy:](v133, "setSavePolicy:", 0LL);
        unint64_t v89 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
        char v90 = (void *)objc_claimAutoreleasedReturnValue([v89 zoneName]);
        id v91 = sub_1000AA6AC(@"ckks-se", v90);
        uint64_t v92 = (os_log_s *)objc_claimAutoreleasedReturnValue(v91);

        if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v93 = -[CKModifyRecordsOperation qualityOfService](v133, "qualityOfService");
          id v94 = (void *)objc_claimAutoreleasedReturnValue(-[CKModifyRecordsOperation group](v133, "group"));
          *(_DWORD *)__int128 buf = 67109378;
          *(_DWORD *)id v176 = v93;
          *(_WORD *)&v176[4] = 2112;
          *(void *)&v176[6] = v94;
          _os_log_impl( (void *)&_mh_execute_header,  v92,  OS_LOG_TYPE_DEFAULT,  "QoS: %d; operation group is %@",
            buf,
            0x12u);
        }

        id v95 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
        uint64_t v96 = (void *)objc_claimAutoreleasedReturnValue([v95 zoneName]);
        id v97 = sub_1000AA6AC(@"ckks-se", v96);
        char v98 = (os_log_s *)objc_claimAutoreleasedReturnValue(v97);

        if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v99 = [v82 count];
          *(_DWORD *)__int128 buf = 67109120;
          *(_DWORD *)id v176 = v99;
          _os_log_impl( (void *)&_mh_execute_header,  v98,  OS_LOG_TYPE_DEFAULT,  "Beginning upload for %d records",  buf,  8u);
        }

        __int128 v152 = 0u;
        __int128 v153 = 0u;
        __int128 v150 = 0u;
        __int128 v151 = 0u;
        id obj = v82;
        id v100 = [obj countByEnumeratingWithState:&v150 objects:v174 count:16];
        if (v100)
        {
          uint64_t v101 = *(void *)v151;
          do
          {
            for (m = 0LL; m != v100; m = (char *)m + 1)
            {
              if (*(void *)v151 != v101) {
                objc_enumerationMutation(obj);
              }
              unsigned int v103 = *(void **)(*((void *)&v150 + 1) + 8LL * (void)m);
              id v104 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v103, "recordID", v131));
              id v105 = (void *)objc_claimAutoreleasedReturnValue([v104 zoneID]);
              id v106 = (void *)objc_claimAutoreleasedReturnValue([v105 zoneName]);
              id v107 = sub_1000AA6AC(@"ckks-se", v106);
              __int128 v108 = (os_log_s *)objc_claimAutoreleasedReturnValue(v107);

              if (os_log_type_enabled(v108, OS_LOG_TYPE_DEBUG))
              {
                __int128 v109 = (void *)objc_claimAutoreleasedReturnValue([v103 recordID]);
                *(_DWORD *)__int128 buf = 138412290;
                *(void *)id v176 = v109;
                _os_log_debug_impl( (void *)&_mh_execute_header,  v108,  OS_LOG_TYPE_DEBUG,  "Record to save: %@",  buf,  0xCu);
              }
            }

            id v100 = [obj countByEnumeratingWithState:&v150 objects:v174 count:16];
          }

          while (v100);
        }

        -[CKModifyRecordsOperation setPerRecordSaveBlock:](v133, "setPerRecordSaveBlock:", &stru_100291038);
        __int128 v110 = (void *)objc_claimAutoreleasedReturnValue( +[CKKSResultOperation named:withBlock:]( &OBJC_CLASS___CKKSResultOperation,  "named:withBlock:",  @"wait-until-write-finished",  &stru_100291058));
        [*(id *)(a1 + 48) dependOnBeforeGroupFinished:v110];
        v144[0] = _NSConcreteStackBlock;
        v144[1] = 3221225472LL;
        v144[2] = sub_100171E74;
        v144[3] = &unk_1002910A8;
        objc_copyWeak(&v149, (id *)(a1 + 88));
        id v145 = *(id *)(a1 + 40);
        id v111 = v142;
        id v146 = v111;
        id v147 = *(id *)(a1 + 48);
        id v112 = v110;
        id v148 = v112;
        -[CKModifyRecordsOperation setModifyRecordsCompletionBlock:](v133, "setModifyRecordsCompletionBlock:", v144);
        __int128 v113 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 72) operationDependencies]);
        __int128 v114 = (void *)objc_claimAutoreleasedReturnValue([v113 ckdatabase]);
        [v114 addOperation:v133];

        objc_destroyWeak(&v149);
      }

      else
      {
        char v127 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "zoneID", v131));
        char v128 = (void *)objc_claimAutoreleasedReturnValue([v127 zoneName]);
        id v129 = sub_1000AA6AC(@"ckks-se", v128);
        uint64_t v130 = (os_log_s *)objc_claimAutoreleasedReturnValue(v129);

        if (os_log_type_enabled(v130, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 138412290;
          *(void *)id v176 = v135;
          _os_log_impl( (void *)&_mh_execute_header,  v130,  OS_LOG_TYPE_ERROR,  "Unable to create class CKP: %@",  buf,  0xCu);
        }

        [*(id *)(a1 + 48) setError:v135];
      }
    }

LABEL_79:
LABEL_80:

    goto LABEL_81;
  }

  id v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
  __int128 v23 = (void *)objc_claimAutoreleasedReturnValue([v22 zoneName]);
  id v24 = sub_1000AA6AC(@"ckks-se", v23);
  __int128 v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);

  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)id v176 = v140;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Unable to make TLK: %@", buf, 0xCu);
  }

  [*(id *)(a1 + 48) setError:v140];
LABEL_81:
}

void sub_100171E54(_Unwind_Exception *a1)
{
}

void sub_100171E74(id *a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained(a1 + 8);
  id v9 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained databaseProvider]);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472LL;
  v12[2] = sub_100171F90;
  void v12[3] = &unk_100291080;
  id v13 = v7;
  id v14 = a1[4];
  id v15 = WeakRetained;
  id v16 = a1[5];
  id v17 = a1[6];
  id v18 = a1[7];
  id v19 = v6;
  id v10 = v6;
  id v11 = v7;
  [v9 dispatchSyncWithSQLTransaction:v12];
}

uint64_t sub_100171F90(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) zoneID]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 zoneName]);
  id v5 = sub_1000AA6AC(@"ckks-se", v4);
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);

  if (v2)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v23 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "error proposing new TLK: %@", buf, 0xCu);
    }

    id v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) operationDependencies]);
    [v8 intransactionCKWriteFailed:*(void *)(a1 + 32) attemptedRecordsChanged:*(void *)(a1 + 56)];

    [*(id *)(a1 + 64) setError:*(void *)(a1 + 32)];
  }

  else
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Completed uploading new TLK!", buf, 2u);
    }

    __int128 v19 = 0u;
    __int128 v20 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    id v9 = *(id *)(a1 + 80);
    id v10 = [v9 countByEnumeratingWithState:&v17 objects:v21 count:16];
    if (v10)
    {
      id v11 = v10;
      uint64_t v12 = *(void *)v18;
      do
      {
        for (CFIndex i = 0LL; i != v11; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v18 != v12) {
            objc_enumerationMutation(v9);
          }
          uint64_t v14 = *(void *)(*((void *)&v17 + 1) + 8LL * (void)i);
          id v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "operationDependencies", (void)v17));
          [v15 intransactionCKRecordChanged:v14 resync:0];
        }

        id v11 = [v9 countByEnumeratingWithState:&v17 objects:v21 count:16];
      }

      while (v11);
    }
  }

  objc_msgSend(*(id *)(a1 + 64), "runBeforeGroupFinished:", *(void *)(a1 + 72), (void)v17);
  return 1LL;
}

void sub_1001721A4(id a1, CKRecordID *a2, CKRecord *a3, NSError *a4)
{
  id v6 = a2;
  uint64_t v7 = a3;
  id v8 = a4;
  id v9 = (void *)objc_claimAutoreleasedReturnValue(-[CKRecordID zoneID](v6, "zoneID"));
  id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 zoneName]);
  id v11 = sub_1000AA6AC(@"ckks-se", v10);
  uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);

  if (v8)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      int v15 = 138412546;
      id v16 = v8;
      __int16 v17 = 2112;
      __int128 v18 = v6;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "error on row: %@ %@", (uint8_t *)&v15, 0x16u);
    }
  }

  else if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    id v13 = (NSError *)objc_claimAutoreleasedReturnValue(-[CKRecordID recordName](v6, "recordName"));
    uint64_t v14 = (CKRecordID *)objc_claimAutoreleasedReturnValue(-[CKRecord recordChangeTag](v7, "recordChangeTag"));
    int v15 = 138412546;
    id v16 = v13;
    __int16 v17 = 2112;
    __int128 v18 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Record upload successful for %@ (%@)",  (uint8_t *)&v15,  0x16u);
  }
}

void sub_100175594(id a1)
{
  dispatch_queue_attr_t v1 = sub_10001267C("engine");
  uint64_t v2 = (os_log_s *)objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "Performing keychain backup after unlock because backing up while locked failed",  buf,  2u);
  }

  id v5 = sub_1001C41CC(v3, v4);
  id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  uint64_t v7 = v6;
  if (v6)
  {
    [v6 performTransaction:&stru_100291240];
  }

  else
  {
    id v8 = sub_10001267C("ckks");
    id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v10 = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Failed to get account object", v10, 2u);
    }
  }
}

void sub_100175674(id a1, SOSAccountTransaction *a2)
{
  CFTypeRef cf = 0LL;
  CFMutableSetRef v2 = sub_100198588(a2, (uint64_t)&cf);
  if (v2)
  {
    uint64_t v3 = sub_10001267C("engine");
    uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_7;
    }
    *(_DWORD *)__int128 buf = 138412290;
    CFTypeRef v10 = v2;
    id v5 = "SOSEnsureBackup: SOS made a backup of views: %@";
  }

  else
  {
    id v6 = sub_10001267C("SecError");
    uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_7;
    }
    *(_DWORD *)__int128 buf = 138412290;
    CFTypeRef v10 = cf;
    id v5 = "engine: SOSEnsureBackup: encountered an error while making backup (%@)";
  }

  _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, buf, 0xCu);
LABEL_7:

  CFTypeRef v7 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v7);
  }
}

void sub_10017578C(id a1)
{
  dispatch_queue_attr_t v1 = objc_opt_new(&OBJC_CLASS___NSOperationQueue);
  CFMutableSetRef v2 = (void *)qword_1002DECF8;
  qword_1002DECF8 = (uint64_t)v1;

  uint64_t v3 = objc_claimAutoreleasedReturnValue(+[CKKSLockStateTracker globalTracker](&OBJC_CLASS___CKKSLockStateTracker, "globalTracker"));
  uint64_t v4 = (void *)qword_1002DED00;
  qword_1002DED00 = v3;
}

void sub_100177DD4(id a1)
{
  uint64_t v1 = CKAcceptableValueClasses(a1);
  CFMutableSetRef v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  uint64_t v3 = objc_claimAutoreleasedReturnValue(+[NSMutableSet setWithSet:](&OBJC_CLASS___NSMutableSet, "setWithSet:", v2));
  uint64_t v4 = (void *)qword_1002DED08;
  qword_1002DED08 = v3;

  id v5 = (void *)qword_1002DED08;
  id v6 = (id)objc_claimAutoreleasedReturnValue(+[SecXPCHelper safeErrorClasses](&OBJC_CLASS___SecXPCHelper, "safeErrorClasses"));
  [v5 unionSet:v6];
}

uint64_t sub_10017B2FC(_BYTE *a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    uint64_t v4 = &OBJC_IVAR___SECC2MPMetric__networkEvent;
    id v5 = &OBJC_IVAR___SECC2MPMetric__networkEvent;
    id v6 = &OBJC_IVAR___SECC2MPMetric__networkEvent;
    while (1)
    {
      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
      char v7 = 0;
      unsigned int v8 = 0;
      unint64_t v9 = 0LL;
      while (1)
      {
        unint64_t v10 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v10 == -1LL || v10 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v11 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v10);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v10 + 1;
        v9 |= (unint64_t)(v11 & 0x7F) << v7;
        if ((v11 & 0x80) == 0) {
          goto LABEL_12;
        }
        v7 += 7;
        BOOL v12 = v8++ >= 9;
        if (v12)
        {
          unint64_t v9 = 0LL;
          int v13 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
          goto LABEL_14;
        }
      }

      *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_12:
      int v13 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        unint64_t v9 = 0LL;
      }
LABEL_14:
      if (v13 || (v9 & 7) == 4) {
        return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
      unint64_t v15 = v9 >> 3;
      if ((int)(v9 >> 3) <= 200)
      {
        switch((int)v15)
        {
          case 'e':
            uint64_t String = PBReaderReadString(a2);
            uint64_t v17 = objc_claimAutoreleasedReturnValue(String);
            uint64_t v18 = v4[810];
            goto LABEL_44;
          case 'f':
            uint64_t v24 = PBReaderReadString(a2);
            uint64_t v17 = objc_claimAutoreleasedReturnValue(v24);
            uint64_t v18 = v5[811];
            goto LABEL_44;
          case 'g':
            uint64_t v25 = PBReaderReadString(a2);
            uint64_t v17 = objc_claimAutoreleasedReturnValue(v25);
            uint64_t v18 = v6[812];
            goto LABEL_44;
          case 'h':
            uint64_t v26 = PBReaderReadString(a2);
            uint64_t v17 = objc_claimAutoreleasedReturnValue(v26);
            uint64_t v18 = 40LL;
            goto LABEL_44;
          case 'i':
            char v27 = 0;
            unsigned int v28 = 0;
            uint64_t v29 = 0LL;
            a1[84] |= 1u;
            break;
          default:
            goto LABEL_47;
        }

        while (1)
        {
          unint64_t v30 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v30 == -1LL || v30 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v31 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v30);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v30 + 1;
          v29 |= (unint64_t)(v31 & 0x7F) << v27;
          if ((v31 & 0x80) == 0) {
            goto LABEL_50;
          }
          v27 += 7;
          BOOL v12 = v28++ >= 9;
          if (v12)
          {
            uint64_t v29 = 0LL;
            goto LABEL_52;
          }
        }

        *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_50:
        if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v29 = 0LL;
        }
LABEL_52:
        a1[80] = v29 != 0;
        goto LABEL_45;
      }

      if ((_DWORD)v15 == 203)
      {
        uint64_t v32 = PBReaderReadString(a2);
        uint64_t v17 = objc_claimAutoreleasedReturnValue(v32);
        uint64_t v18 = 24LL;
        goto LABEL_44;
      }

      if ((_DWORD)v15 == 301)
      {
        uint64_t v33 = PBReaderReadString(a2);
        uint64_t v17 = objc_claimAutoreleasedReturnValue(v33);
        uint64_t v18 = 72LL;
        goto LABEL_44;
      }

      if ((_DWORD)v15 != 302) {
        goto LABEL_47;
      }
      __int128 v19 = v6;
      __int128 v20 = v5;
      id v21 = v4;
      id v22 = objc_alloc_init(&OBJC_CLASS___SECC2MPInternalTestConfig);
      [a1 addInternalTestConfig:v22];
      v37[0] = 0xAAAAAAAAAAAAAAAALL;
      v37[1] = 0xAAAAAAAAAAAAAAAALL;
      if (!PBReaderPlaceMark(a2, v37) || !sub_1000C91B0((uint64_t)v22, a2))
      {

        return 0LL;
      }

      PBReaderRecallMark(a2, v37);

      uint64_t v4 = v21;
      id v5 = v20;
      id v6 = v19;
LABEL_45:
      if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
    }

    if ((_DWORD)v15 == 201)
    {
      uint64_t v34 = PBReaderReadString(a2);
      uint64_t v17 = objc_claimAutoreleasedReturnValue(v34);
      uint64_t v18 = 16LL;
      goto LABEL_44;
    }

    if ((_DWORD)v15 == 202)
    {
      uint64_t v23 = PBReaderReadString(a2);
      uint64_t v17 = objc_claimAutoreleasedReturnValue(v23);
      uint64_t v18 = 32LL;
LABEL_44:
      unint64_t v35 = *(void **)&a1[v18];
      *(void *)&a1[v18] = v17;

      goto LABEL_45;
    }

void sub_10017B804( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_10017B854(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  CFMutableSetRef v2 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v2 ckks]);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 zoneChangeFetcher]);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 inflightFetch]);
  [WeakRetained addNullableSuccessDependency:v5];

  id v6 = sub_10001267C("octagon-ckks");
  char v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
    unint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 ckks]);
    int v13 = 138412290;
    uint64_t v14 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Waiting for CKKS Priority view download for %@",  (uint8_t *)&v13,  0xCu);
  }

  unint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained operationDependencies]);
  char v11 = (void *)objc_claimAutoreleasedReturnValue([v10 ckks]);
  BOOL v12 = (void *)objc_claimAutoreleasedReturnValue([v11 rpcProcessIncomingQueue:0 errorOnClassAFailure:0]);
  [WeakRetained addSuccessDependency:v12];
}

uint64_t sub_10017BFFC(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0LL;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1LL || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v9 = v5++ >= 9;
      if (v9)
      {
        unint64_t v6 = 0LL;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }

    *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0LL;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    unint64_t v12 = v6 >> 3;
    if ((v6 >> 3) == 101)
    {
      char v16 = 0;
      unsigned int v17 = 0;
      uint64_t v18 = 0LL;
      *(_BYTE *)(a1 + 28) |= 1u;
      while (1)
      {
        unint64_t v19 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v19 == -1LL || v19 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v20 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v19);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v19 + 1;
        v18 |= (unint64_t)(v20 & 0x7F) << v16;
        if ((v20 & 0x80) == 0) {
          goto LABEL_33;
        }
        v16 += 7;
        BOOL v9 = v17++ >= 9;
        if (v9)
        {
          uint64_t v18 = 0LL;
          goto LABEL_35;
        }
      }

      *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_33:
      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        uint64_t v18 = 0LL;
      }
LABEL_35:
      *(_BYTE *)(a1 + 24) = v18 != 0;
    }

    else
    {
      if ((_DWORD)v12 == 2)
      {
        uint64_t String = PBReaderReadString(a2);
        uint64_t v14 = objc_claimAutoreleasedReturnValue(String);
        uint64_t v15 = 16LL;
      }

      else
      {
        if ((_DWORD)v12 != 1)
        {
          uint64_t result = PBReaderSkipValueWithTag(a2);
          if (!(_DWORD)result) {
            return result;
          }
          continue;
        }

        uint64_t v13 = PBReaderReadString(a2);
        uint64_t v14 = objc_claimAutoreleasedReturnValue(v13);
        uint64_t v15 = 8LL;
      }

      id v22 = *(void **)(a1 + v15);
      *(void *)(a1 + v15) = v14;
    }
  }

  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_10017C61C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_10017C7CC(_Unwind_Exception *a1)
{
}

void sub_10017C964(_Unwind_Exception *a1)
{
}

void sub_10017CD2C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
}

void sub_10017CE4C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_10017CF2C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_10017D688( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, id location)
{
}

id sub_10017DB04(uint64_t a1)
{
  return [*(id *)(a1 + 32) setHalted:1];
}

void sub_10017DB10(id *a1)
{
  id WeakRetained = objc_loadWeakRetained(a1 + 7);
  if (WeakRetained)
  {
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([a1[4] error]);

    if (v3)
    {
      id v4 = sub_1000AA6AC(@"ckksfetcher", 0LL);
      unsigned int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([a1[4] error]);
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v33 = v6;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_ERROR,  "Interrogating clients about fetch error: %@",  buf,  0xCu);
      }

      id v21 = WeakRetained;
      unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained strongClientMap]);
      __int128 v27 = 0u;
      __int128 v28 = 0u;
      __int128 v29 = 0u;
      __int128 v30 = 0u;
      char v8 = (void *)objc_claimAutoreleasedReturnValue([a1[4] fetchedZoneIDs]);
      id v9 = [v8 countByEnumeratingWithState:&v27 objects:v31 count:16];
      if (v9)
      {
        id v10 = v9;
        char v11 = 0;
        uint64_t v12 = *(void *)v28;
        do
        {
          for (CFIndex i = 0LL; i != v10; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v28 != v12) {
              objc_enumerationMutation(v8);
            }
            uint64_t v14 = *(void *)(*((void *)&v27 + 1) + 8LL * (void)i);
            uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKey:v14]);
            if (v15)
            {
              char v16 = (void *)objc_claimAutoreleasedReturnValue([a1[4] error]);
              char v11 = v11 & 1 | [v15 shouldRetryAfterFetchError:v16 zoneID:v14];
            }
          }

          id v10 = [v8 countByEnumeratingWithState:&v27 objects:v31 count:16];
        }

        while (v10);
      }

      else
      {
        char v11 = 0;
      }

      char v19 = v11 & 1;
      id WeakRetained = v21;
    }

    else
    {
      char v19 = 0;
    }

    char v20 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([WeakRetained queue]);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10017DE08;
    block[3] = &unk_1002912E0;
    void block[4] = WeakRetained;
    id v23 = a1[4];
    char v26 = v19;
    id v24 = a1[5];
    id v25 = a1[6];
    dispatch_sync(v20, block);
  }

  else
  {
    id v17 = sub_1000AA6AC(@"ckksfetcher", 0LL);
    uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_ERROR,  "Received a null self pointer; strange.",
        buf,
        2u);
    }
  }
}

void sub_10017DE08(uint64_t a1)
{
  CFMutableSetRef v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) error]);
  [*(id *)(a1 + 32) setLastCKFetchError:v2];

  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) error]);
  if (v3)
  {
    if (!*(_BYTE *)(a1 + 64))
    {
      id v18 = sub_1000AA6AC(@"ckksfetcher", 0LL);
      char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        char v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) error]);
        *(_DWORD *)__int128 buf = 138412290;
        double v35 = *(double *)&v20;
        _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_ERROR,  "All clients thought %@ is a fatal error. Not restarting fetch.",  buf,  0xCu);
      }

      goto LABEL_25;
    }

    id v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) error]);
    double v5 = CKRetryAfterSecondsForError();

    id v6 = sub_1000AA6AC(@"ckksfetcher", 0LL);
    unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v5 == 0.0)
    {
      if (v8)
      {
        id v21 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) error]);
        *(_DWORD *)__int128 buf = 138412290;
        double v35 = *(double *)&v21;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Fetch failed with error, restarting soon: %@",  buf,  0xCu);
      }
    }

    else
    {
      if (v8)
      {
        id v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) error]);
        *(_DWORD *)__int128 buf = 134218242;
        double v35 = v5;
        __int16 v36 = 2112;
        BOOL v37 = v9;
        _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Fetch failed with rate-limiting error, restarting in %.1f seconds: %@",  buf,  0x16u);
      }

      unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) fetchScheduler]);
      -[os_log_s waitUntil:](v7, "waitUntil:", (unint64_t)(v5 * 1000000000.0));
    }

    id v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) currentFetchReasons]);
    [v22 unionSet:*(void *)(a1 + 48)];

    id v23 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) apnsPushes]);
    [v23 unionSet:*(void *)(a1 + 56)];

    id v24 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) reachabilityTracker]);
    id v25 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) error]);
    unsigned int v26 = [v24 isNetworkError:v25];

    __int128 v27 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) currentFetchReasons]);
    __int128 v28 = v27;
    if (v26) {
      __int128 v29 = @"network";
    }
    else {
      __int128 v29 = @"fetchfailed";
    }
    [v27 addObject:v29];

    [*(id *)(a1 + 32) setNewRequests:1];
LABEL_24:
    char v19 = (os_log_s *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) fetchScheduler]);
    -[os_log_s trigger](v19, "trigger");
LABEL_25:

    return;
  }

  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  id v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "inflightFetchDependencies", 0));
  id v11 = [v10 countByEnumeratingWithState:&v30 objects:v38 count:16];
  if (v11)
  {
    id v12 = v11;
    uint64_t v13 = *(void *)v31;
    do
    {
      for (CFIndex i = 0LL; i != v12; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v31 != v13) {
          objc_enumerationMutation(v10);
        }
        uint64_t v15 = *(void *)(*((void *)&v30 + 1) + 8LL * (void)i);
        char v16 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) operationQueue]);
        [v16 addOperation:v15];
      }

      id v12 = [v10 countByEnumeratingWithState:&v30 objects:v38 count:16];
    }

    while (v12);
  }

  id v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) inflightFetchDependencies]);
  [v17 removeAllObjects];

  [*(id *)(a1 + 32) setCurrentFetch:0];
}

id sub_10017E1E0(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeCreateNewFetchOnQueue];
}

uint64_t sub_10017E1E8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10017E1F8(uint64_t a1)
{
}

void sub_10017E200(uint64_t a1)
{
  if (([*(id *)(a1 + 32) newRequests] & 1) != 0
    || (CFMutableSetRef v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) inflightFetchDependency]),
        v2,
        !v2))
  {
    uint64_t v3 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) successfulFetchDependency]);
  }

  else
  {
    uint64_t v3 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) inflightFetchDependency]);
  }

  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8LL);
  double v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

void sub_10017E26C(uint64_t a1)
{
  uint64_t v2 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) successfulFetchDependency]);
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8LL);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  [*(id *)(a1 + 32) setNewRequests:1];
  double v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) currentFetchReasons]);
  [v5 unionSet:*(void *)(a1 + 40)];

  id v6 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) fetchScheduler]);
  [v6 trigger];
}

void sub_10017E2F0(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) apnsPushes]);
    [v2 addObject:*(void *)(a1 + 32)];

    if ([*(id *)(a1 + 32) ckksPushTracingEnabled])
    {
      id v3 = sub_1000AA6AC(@"ckksfetch", 0LL);
      uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = *(void *)(a1 + 32);
        int v16 = 138412290;
        uint64_t v17 = v5;
        _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Submitting initial CKEventMetric due to notification %@",  (uint8_t *)&v16,  0xCu);
      }

      id v6 = [[CKEventMetric alloc] initWithEventName:@"APNSPushMetrics"];
      [v6 setIsPushTriggerFired:1];
      unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) ckksPushTracingUUID]);
      [v6 setObject:v7 forKeyedSubscript:@"push_token_uuid"];

      BOOL v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) ckksPushReceivedDate]);
      [v6 setObject:v8 forKeyedSubscript:@"push_received_date"];

      [v6 setObject:@"CKKS APNS Push Received" forKeyedSubscript:@"push_event_name"];
      if (*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL)) {
        id v9 = @"not-ready";
      }
      else {
        id v9 = @"ready";
      }
      [v6 setObject:v9 forKeyedSubscript:@"zones_status"];
      id v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) container]);
      [v10 submitEventMetric:v6];

      id v11 = -[SecEventMetric initWithEventName:]( objc_alloc(&OBJC_CLASS___SecEventMetric),  "initWithEventName:",  @"APNSPushMetrics");
      id v12 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) ckksPushTracingUUID]);
      -[SecEventMetric setObject:forKeyedSubscript:](v11, "setObject:forKeyedSubscript:", v12, @"push_token_uuid");

      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) ckksPushReceivedDate]);
      -[SecEventMetric setObject:forKeyedSubscript:]( v11,  "setObject:forKeyedSubscript:",  v13,  @"push_received_date");

      -[SecEventMetric setObject:forKeyedSubscript:]( v11,  "setObject:forKeyedSubscript:",  @"CKKS APNS Push Received-webtunnel",  @"push_event_name");
      if (*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL)) {
        uint64_t v14 = @"not-ready";
      }
      else {
        uint64_t v14 = @"ready";
      }
      [v6 setObject:v14 forKeyedSubscript:@"zones_status"];
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(+[SecMetrics managerObject](&OBJC_CLASS___SecMetrics, "managerObject"));
      [v15 submitEvent:v11];
    }
  }

void sub_10017E59C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained maybeCreateNewFetch];
}

void sub_10017E86C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
}

void sub_10017F0A0(uint64_t a1)
{
  uint64_t v2 = sub_10001267C("upgr-phase3");
  id v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "CKKSNFS triggered!", v7, 2u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v5 = -[OctagonPendingFlag initWithFlag:conditions:]( objc_alloc(&OBJC_CLASS___OctagonPendingFlag),  "initWithFlag:conditions:",  @"schedule_pref_upgrade",  1LL);
  id v6 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained stateMachine]);
  [v6 handlePendingFlag:v5];
}

void sub_10017F52C(_Unwind_Exception *a1)
{
}

void sub_10017F654(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a4;
  id v7 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v9 = (void *)objc_claimAutoreleasedReturnValue([v7 walrus]);
  id v10 = (void *)objc_claimAutoreleasedReturnValue([v7 webAccess]);

  id v11 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained settings]);
  id v12 = (void *)objc_claimAutoreleasedReturnValue([v11 walrus]);
  if (!v12)
  {

    goto LABEL_6;
  }

  uint64_t v13 = v12;
  if (v9)
  {
    unsigned int v14 = [v9 value];
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained settings]);
    int v16 = (void *)objc_claimAutoreleasedReturnValue([v15 walrus]);
    id v17 = v6;
    unsigned int v18 = [v16 enabled];

    BOOL v19 = v14 == v18;
    id v6 = v17;
    if (!v19) {
      goto LABEL_8;
    }
LABEL_6:
    char v20 = 0LL;
    goto LABEL_19;
  }

LABEL_8:
  id v21 = sub_10001267C("SecError");
  id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    id v23 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained settings]);
    id v24 = (void *)objc_claimAutoreleasedReturnValue([v23 walrus]);
    else {
      id v25 = @"OFF";
    }
    if (v9)
    {
      else {
        unsigned int v26 = @"OFF";
      }
    }

    else
    {
      unsigned int v26 = @"none";
    }

    *(_DWORD *)__int128 buf = 138412802;
    unsigned int v55 = v25;
    __int16 v56 = 2112;
    id v57 = v26;
    __int16 v58 = 2112;
    id v59 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "octagon: error setting walrus: Intended value: %@, final value: %@, error: %@",  buf,  0x20u);
  }

  char v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:underlying:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:underlying:",  @"com.apple.security.octagon",  51LL,  @"Failed to set walrus setting",  v6));
LABEL_19:
  __int128 v27 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained settings]);
  __int128 v28 = (void *)objc_claimAutoreleasedReturnValue([v27 webAccess]);
  if (!v28)
  {

    if (v20)
    {
LABEL_25:
      __int16 v36 = 0LL;
LABEL_40:
      [WeakRetained setError:v20];
      unint64_t v49 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained finishOp]);
      [WeakRetained runBeforeGroupFinished:v49];

      goto LABEL_44;
    }

void sub_10017FC98( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_1001805F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_1001807D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v15 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v13 - 128), 8);
  _Block_object_dispose((const void *)(v13 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_100180DF0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29, uint64_t a30, uint64_t a31, uint64_t a32, char a33)
{
}

uint64_t sub_100180EA0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100180EB0(uint64_t a1)
{
}

void sub_100180EB8(uint64_t a1)
{
  unsigned int v3 = +[SecDbKeychainMetadataKeyStore cachingEnabled](&OBJC_CLASS___SecDbKeychainMetadataKeyStore, "cachingEnabled");
  if (v3)
  {
    uint64_t v4 = *(void **)(*(void *)(a1 + 32) + 24LL);
    uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 80)));
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v1]);
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL), v5);
  if (v3)
  {
  }

  uint64_t v6 = *(void *)(a1 + 48);
  if (!*(void *)(*(void *)(v6 + 8) + 40LL))
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 64) + 8LL) + 24LL;
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472LL;
    v15[2] = sub_100181004;
    v15[3] = &unk_100291440;
    uint64_t v8 = *(void *)(a1 + 32);
    id v9 = *(void **)(a1 + 40);
    uint64_t v17 = v6;
    void v15[4] = v8;
    uint64_t v19 = *(void *)(a1 + 80);
    id v10 = v9;
    char v20 = *(_BYTE *)(a1 + 88);
    uint64_t v11 = *(void *)(a1 + 72);
    id v16 = v10;
    uint64_t v18 = v11;
    char v21 = v3;
    char v12 = sub_100110ECC(1, 0, 0LL, v7, (uint64_t)v15);
    uint64_t v13 = *(void *)(*(void *)(a1 + 56) + 8LL);
    if (*(_BYTE *)(v13 + 24)) {
      char v14 = v12;
    }
    else {
      char v14 = 0;
    }
    *(_BYTE *)(v13 + 24) = v14;
  }

BOOL sub_100181004(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 64);
  uint64_t v5 = *(unsigned int *)(a1 + 68);
  uint64_t v6 = *(void **)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 40);
  uint64_t v8 = *(unsigned __int8 *)(a1 + 72);
  uint64_t v9 = *(void *)(*(void *)(a1 + 56) + 8LL);
  id obj = *(id *)(v9 + 40);
  uint64_t v10 = objc_claimAutoreleasedReturnValue([v6 fetchKeyForClass:v4 fromDb:a2 keybag:v5 specifier:v7 allowWrites:v8 error:&obj]);
  objc_storeStrong((id *)(v9 + 40), obj);
  uint64_t v11 = *(void *)(*(void *)(a1 + 48) + 8LL);
  char v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = v10;

  if (!*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL))
  {
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) domain]);
    if ([v13 isEqualToString:kCFErrorDomainOSStatus])
    {
      id v14 = [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) code];

      if (v14 == (id)-25308LL)
      {
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472LL;
        block[2] = sub_100181504;
        block[3] = &unk_100292300;
        void block[4] = *(void *)(a1 + 56);
        if (qword_1002DED30 != -1) {
          dispatch_once(&qword_1002DED30, block);
        }
        dispatch_source_merge_data((dispatch_source_t)qword_1002DED28, 1uLL);
        return *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL) != 0LL;
      }
    }

    else
    {
    }
  }

  if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL))
  {
LABEL_9:
    uint64_t v15 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
    if (v15)
    {
      if (*(_BYTE *)(a1 + 73))
      {
        id v16 = *(void **)(*(void *)(a1 + 32) + 24LL);
        uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 64)));
        [v16 setObject:v15 forKeyedSubscript:v17];
      }
    }

    else
    {
      BOOL v37 = sub_10001267C("SecError");
      char v38 = (os_log_s *)objc_claimAutoreleasedReturnValue(v37);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v39 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
        *(_DWORD *)__int128 buf = 138412290;
        v55[0] = v39;
        _os_log_impl( (void *)&_mh_execute_header,  v38,  OS_LOG_TYPE_DEFAULT,  "SecDbMetadataKeyStore: scary error encountered: %@",  buf,  0xCu);
      }
    }

    return *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL) != 0LL;
  }

  if (*(_BYTE *)(a1 + 72))
  {
    uint64_t v18 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
    if (v18)
    {
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v18 domain]);
      if (([v19 isEqualToString:NSOSStatusErrorDomain] & 1) == 0)
      {

        goto LABEL_9;
      }

      id v20 = [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) code];

      if (v20 != (id)-26275LL) {
        goto LABEL_9;
      }
    }

    char v21 = sub_10001267C("SecWarning");
    id v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      id v23 = [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) code];
      *(_DWORD *)__int128 buf = 134217984;
      v55[0] = v23;
      _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "SecDbMetadataKeyStore: unable to use key (%ld), will attempt to create new one",  buf,  0xCu);
    }

    uint64_t v24 = *(void *)(*(void *)(a1 + 56) + 8LL);
    id v25 = *(void **)(v24 + 40);
    *(void *)(v24 + 40) = 0LL;

    uint64_t v26 = *(unsigned int *)(a1 + 64);
    uint64_t v27 = *(unsigned int *)(a1 + 68);
    __int128 v28 = *(void **)(a1 + 32);
    uint64_t v29 = *(void *)(a1 + 40);
    uint64_t v30 = *(void *)(*(void *)(a1 + 56) + 8LL);
    id v49 = *(id *)(v30 + 40);
    id v31 = [v28 newKeyForKeyclass:v26 withKeybag:v27 keySpecifier:v29 database:a2 error:&v49];
    objc_storeStrong((id *)(v30 + 40), v49);
    uint64_t v32 = *(void *)(*(void *)(a1 + 48) + 8LL);
    uint64_t v33 = *(void **)(v32 + 40);
    *(void *)(v32 + 40) = v31;

    if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL)) {
      return *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL) != 0LL;
    }
    uint64_t v34 = sub_10001267C("SecError");
    unsigned int v35 = (os_log_s *)objc_claimAutoreleasedReturnValue(v34);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v36 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
      *(_DWORD *)__int128 buf = 138412290;
      v55[0] = v36;
      _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "SecDbMetadataKeyStore: unable to create or save new key: %@",  buf,  0xCu);
    }
  }

  else
  {
    unint64_t v41 = sub_10001267C("SecWarning");
    id v42 = (os_log_s *)objc_claimAutoreleasedReturnValue(v41);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      int v43 = *(_DWORD *)(a1 + 64);
      uint64_t v44 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
      *(_DWORD *)__int128 buf = 67109378;
      LODWORD(v55[0]) = v43;
      WORD2(v55[0]) = 2112;
      *(void *)((char *)v55 + 6) = v44;
      _os_log_impl( (void *)&_mh_execute_header,  v42,  OS_LOG_TYPE_DEFAULT,  "SecDbMetadataKeyStore: Unable to load metadatakey for class %d from disk (%@) and not allowed to create new one",  buf,  0x12u);
    }

    if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL))
    {
      NSErrorUserInfoKey v52 = NSLocalizedDescriptionKey;
      unint64_t v53 = @"Unable to find a suitable metadata key and not permitted to create one";
      unint64_t v45 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v53,  &v52,  1LL));
      uint64_t v46 = objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  kCFErrorDomainOSStatus,  -26275LL,  v45));
      uint64_t v47 = *(void *)(*(void *)(a1 + 56) + 8LL);
      id v48 = *(void **)(v47 + 40);
      *(void *)(v47 + 40) = v46;
    }
  }

  return 0LL;
}

void sub_100181504(uint64_t a1)
{
  dispatch_source_t v2 = sub_10001A100("keychainlockedlogmessage", 1LL);
  unsigned int v3 = (void *)qword_1002DED28;
  qword_1002DED28 = (uint64_t)v2;

  uint64_t v4 = (dispatch_object_s *)qword_1002DED28;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 3221225472LL;
  aBlock[2] = sub_1001815A0;
  aBlock[3] = &unk_100292300;
  aBlock[4] = *(void *)(a1 + 32);
  __int128 context = dispatch_get_context((dispatch_object_t)qword_1002DED28);
  uint64_t context[2] = _Block_copy(aBlock);
  dispatch_activate(v4);
}

void sub_1001815A0(uint64_t a1)
{
  dispatch_source_t v2 = sub_10001267C("SecError");
  unsigned int v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    id v4 = [*(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) code];
    int v5 = 134217984;
    id v6 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "SecDbKeychainItemV7: cannot decrypt metadata key because the keychain is locked (%ld)",  (uint8_t *)&v5,  0xCu);
  }
}

uint64_t sub_100181658(uint64_t a1, sqlite3_stmt *a2)
{
  char v4 = sub_1000182E4( a2,  1LL,  (const __CFString *)+[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(a1 + 80)),  (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL));
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if (*(_BYTE *)(v5 + 24)) {
    char v6 = v4;
  }
  else {
    char v6 = 0;
  }
  *(_BYTE *)(v5 + 24) = v6;
  uint64_t v7 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  v13[2] = sub_100181730;
  v13[3] = &unk_1002913F0;
  uint64_t v8 = *(void *)(a1 + 64);
  uint64_t v9 = *(void *)(a1 + 72);
  uint64_t v15 = a2;
  uint64_t v16 = v9;
  __int128 v14 = *(_OWORD *)(a1 + 48);
  uint64_t result = sub_100015CD8(v8, a2, v7, (uint64_t)v13);
  uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if (*(_BYTE *)(v11 + 24)) {
    char v12 = result;
  }
  else {
    char v12 = 0;
  }
  *(_BYTE *)(v11 + 24) = v12;
  return result;
}

uint64_t sub_100181730(uint64_t a1)
{
  dispatch_source_t v2 = objc_alloc(&OBJC_CLASS___NSData);
  unsigned int v3 = sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 48), 0);
  char v4 = -[NSData initWithBytes:length:]( v2,  "initWithBytes:length:",  v3,  sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 48), 0));
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8LL);
  char v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;

  uint64_t result = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 48), 1);
  **(_DWORD **)(a1 + 56) = result;
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  return result;
}

uint64_t sub_1001817C8(uint64_t a1, sqlite3_stmt *a2)
{
  char v4 = sub_1000182E4( a2,  1LL,  (const __CFString *)+[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(a1 + 64)),  (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL));
  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8LL);
  if (*(_BYTE *)(v5 + 24)) {
    char v6 = v4;
  }
  else {
    char v6 = 0;
  }
  *(_BYTE *)(v5 + 24) = v6;
  char v7 = sub_1000182E4( a2,  2LL,  (const __CFString *)+[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  *(unsigned int *)(a1 + 68)),  (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL));
  uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8LL);
  if (*(_BYTE *)(v8 + 24)) {
    char v9 = v7;
  }
  else {
    char v9 = 0;
  }
  *(_BYTE *)(v8 + 24) = v9;
  BOOL v10 = sub_10001817C( a2, 3, [*(id *)(a1 + 32) bytes], (unint64_t)objc_msgSend(*(id *)(a1 + 32), "length"), (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24));
  uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8LL);
  if (*(_BYTE *)(v11 + 24)) {
    BOOL v12 = v10;
  }
  else {
    BOOL v12 = 0;
  }
  *(_BYTE *)(v11 + 24) = v12;
  uint64_t result = sub_100015CD8(*(void *)(a1 + 56), a2, (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL), 0LL);
  uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 8LL);
  if (*(_BYTE *)(v14 + 24)) {
    char v15 = result;
  }
  else {
    char v15 = 0;
  }
  *(_BYTE *)(v14 + 24) = v15;
  return result;
}

id sub_1001818F4(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onQueueDropAllKeys];
}

id sub_1001818FC(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onQueueDropClassAKeys];
}

void sub_100181904(uint64_t a1)
{
  CFTypeRef cf = 0LL;
  *(_DWORD *)__int128 buf = -1431655766;
  uint64_t v2 = sub_1000053C4(0, buf);
  if (sub_1000190E4(v2, &cf, @"aks_get_lock_state failed: %x", v2))
  {
    if ((buf[0] & 1) == 0) {
      return;
    }
  }

  else
  {
    unsigned int v3 = sub_10001267C("SecError");
    char v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v9 = cf;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "SecDbKeychainMetadataKeyStore: error getting lock state: %@",  buf,  0xCu);
    }

    CFTypeRef v5 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v5);
    }
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained _onQueueDropClassAKeys];
}

void sub_100181B44(uint64_t a1)
{
  uint64_t v2 = (void *)qword_1002DED18;
  if (!qword_1002DED18)
  {
    id v3 = [objc_alloc(*(Class *)(a1 + 40)) _init];
    char v4 = (void *)qword_1002DED18;
    qword_1002DED18 = (uint64_t)v3;

    uint64_t v2 = (void *)qword_1002DED18;
  }

  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL), v2);
}

void sub_100181B94(id a1)
{
  dispatch_queue_t v1 = dispatch_queue_create("metadata_store", 0LL);
  uint64_t v2 = (void *)qword_1002DED20;
  qword_1002DED20 = (uint64_t)v1;
}

void sub_100181BC0(id a1)
{
  dispatch_queue_t v1 = (void *)qword_1002DED18;
  if (qword_1002DED18)
  {
    [(id)qword_1002DED18 dropAllKeys];
    dispatch_queue_t v1 = (void *)qword_1002DED18;
  }

  qword_1002DED18 = 0LL;
}

void sub_1001821A8(_Unwind_Exception *a1)
{
}

void sub_10018245C(uint64_t a1, void *a2, void *a3)
{
  id v19 = a3;
  id v5 = a2;
  char v6 = objc_alloc_init(&OBJC_CLASS___SECC2MPGenericEventMetric);
  -[SECC2MPGenericEventMetric setKey:](v6, "setKey:", v5);

  char v7 = objc_alloc_init(&OBJC_CLASS___SECC2MPGenericEventMetricValue);
  -[SECC2MPGenericEventMetric setValue:](v6, "setValue:", v7);

  uint64_t v8 = objc_opt_class(&OBJC_CLASS___NSError);
  if ((objc_opt_isKindOfClass(v19, v8) & 1) != 0)
  {
    CFTypeRef v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) generateError:v19]);
    BOOL v10 = (void *)objc_claimAutoreleasedReturnValue(-[SECC2MPGenericEventMetric value](v6, "value"));
    [v10 setErrorValue:v9];
  }

  else
  {
    uint64_t v11 = objc_opt_class(&OBJC_CLASS___NSDate);
    if ((objc_opt_isKindOfClass(v19, v11) & 1) != 0)
    {
      BOOL v12 = *(void **)(a1 + 32);
      [v19 timeIntervalSinceReferenceDate];
      id v13 = objc_msgSend(v12, "convertTimeIntervalToServerTime:");
      CFTypeRef v9 = (void *)objc_claimAutoreleasedReturnValue(-[SECC2MPGenericEventMetric value](v6, "value"));
      [v9 setDateValue:v13];
    }

    else
    {
      uint64_t v14 = objc_opt_class(&OBJC_CLASS___NSNumber);
      if ((objc_opt_isKindOfClass(v19, v14) & 1) != 0)
      {
        [v19 doubleValue];
        double v16 = v15;
        CFTypeRef v9 = (void *)objc_claimAutoreleasedReturnValue(-[SECC2MPGenericEventMetric value](v6, "value"));
        [v9 setDoubleValue:v16];
      }

      else
      {
        uint64_t v17 = objc_opt_class(&OBJC_CLASS___NSString);
        if ((objc_opt_isKindOfClass(v19, v17) & 1) == 0) {
          goto LABEL_11;
        }
        CFTypeRef v9 = (void *)objc_claimAutoreleasedReturnValue(-[SECC2MPGenericEventMetric value](v6, "value"));
        [v9 setStringValue:v19];
      }
    }
  }

  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(-[SECC2MPGenericEventMetric value](v6, "value"));
  if (v18) {
    [*(id *)(a1 + 40) addMetric:v6];
  }
LABEL_11:
}

void sub_100182674(id a1)
{
  v4[0] = objc_opt_class(&OBJC_CLASS___NSString);
  v4[1] = objc_opt_class(&OBJC_CLASS___NSNumber);
  v4[2] = objc_opt_class(&OBJC_CLASS___NSDate);
  void v4[3] = objc_opt_class(&OBJC_CLASS___NSError);
  dispatch_queue_t v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v4, 4LL));
  uint64_t v2 = objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", v1));
  id v3 = (void *)qword_1002DED40;
  qword_1002DED40 = v2;
}

void sub_1001847F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_100184DE0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

void sub_100185284(_Unwind_Exception *a1)
{
}

void sub_100185390(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  id v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "monitors", 0));
  id v4 = [v3 countByEnumeratingWithState:&v8 objects:v12 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v9;
    do
    {
      char v7 = 0LL;
      do
      {
        if (*(void *)v9 != v6) {
          objc_enumerationMutation(v3);
        }
        [*(id *)(*((void *)&v8 + 1) + 8 * (void)v7) accountStateUpdated:*(void *)(a1 + 32) from:*(void *)(a1 + 40)];
        char v7 = (char *)v7 + 1;
      }

      while (v5 != v7);
      id v5 = [v3 countByEnumeratingWithState:&v8 objects:v12 count:16];
    }

    while (v5);
  }
}

id sub_100185498(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setSendingMetricsPermitted:*(unsigned int *)(a1 + 32)];
  return v3;
}

id sub_1001854C8(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setAttemptedJoin:*(unsigned int *)(a1 + 32)];
  return v3;
}

id sub_1001854F8(uint64_t a1, void *a2)
{
  id v3 = a2;
  [*(id *)(a1 + 32) timeIntervalSince1970];
  [v3 setLastHealthCheckup:(unint64_t)(v4 * 1000.0)];
  return v3;
}

uint64_t sub_100185540(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100185550(uint64_t a1)
{
}

void sub_100185558(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(*(void *)(a1 + 56) + 8LL);
  id obj = *(id *)(v3 + 40);
  uint64_t v4 = objc_claimAutoreleasedReturnValue([v2 _onqueueLoadOrCreateAccountMetadata:&obj]);
  objc_storeStrong((id *)(v3 + 40), obj);
  uint64_t v5 = *(void *)(*(void *)(a1 + 48) + 8LL);
  uint64_t v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;

  char v7 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
  if (v7)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    id v9 = [v7 copy];
    uint64_t v10 = (*(uint64_t (**)(uint64_t, id))(v8 + 16))(v8, v9);
    uint64_t v11 = objc_claimAutoreleasedReturnValue(v10);
    uint64_t v12 = *(void *)(*(void *)(a1 + 64) + 8LL);
    id v13 = *(void **)(v12 + 40);
    *(void *)(v12 + 40) = v11;

    uint64_t v14 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8LL) + 40LL);
    if (v14)
    {
      double v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) containerName]);
      double v16 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) contextID]);
      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) personaAdapter]);
      uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) activeAccount]);
      id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 personaUniqueString]);
      uint64_t v20 = *(void *)(*(void *)(a1 + 56) + 8LL);
      id v25 = *(id *)(v20 + 40);
      unsigned int v21 = [v14 saveToKeychainForContainer:v15 contextID:v16 personaAdapter:v17 personaUniqueString:v19 error:&v25];
      objc_storeStrong((id *)(v20 + 40), v25);

      uint64_t v22 = *(void *)(*(void *)(a1 + 72) + 8LL);
      if (!v21)
      {
        *(_BYTE *)(v22 + 24) = 0;
        uint64_t v23 = *(void *)(*(void *)(a1 + 64) + 8LL);
        uint64_t v24 = *(void **)(v23 + 40);
        *(void *)(v23 + 40) = 0LL;

        return;
      }
    }

    else
    {
      uint64_t v22 = *(void *)(*(void *)(a1 + 72) + 8LL);
    }

    *(_BYTE *)(v22 + 24) = 1;
  }

id sub_100185704(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setTrustState:*(unsigned int *)(a1 + 32)];
  return v3;
}

id sub_100185734(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setPeerID:*(void *)(a1 + 32)];
  return v3;
}

void sub_100185764(void *a1)
{
  uint64_t v2 = (void *)a1[4];
  uint64_t v3 = *(void *)(a1[6] + 8LL);
  id obj = *(id *)(v3 + 40);
  uint64_t v4 = objc_claimAutoreleasedReturnValue([v2 _onqueueLoadOrCreateAccountMetadata:&obj]);
  objc_storeStrong((id *)(v3 + 40), obj);
  uint64_t v5 = *(void *)(a1[5] + 8LL);
  uint64_t v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;
}

BOOL sub_1001863E8(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    while (1)
    {
      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
      char v4 = 0;
      unsigned int v5 = 0;
      unint64_t v6 = 0LL;
      while (1)
      {
        unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v7 == -1LL || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v8 = *(_BYTE *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
        v6 |= (unint64_t)(v8 & 0x7F) << v4;
        if ((v8 & 0x80) == 0) {
          goto LABEL_11;
        }
        v4 += 7;
        if (v5++ >= 9)
        {
          unint64_t v6 = 0LL;
          int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
          goto LABEL_13;
        }
      }

      *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
      int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
      if (*(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        unint64_t v6 = 0LL;
      }
LABEL_13:
      if (v10 || (v6 & 7) == 4) {
        return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
      switch((v6 >> 3))
      {
        case 'f':
          uint64_t String = PBReaderReadString(a2);
          uint64_t v13 = objc_claimAutoreleasedReturnValue(String);
          uint64_t v14 = 32LL;
          goto LABEL_24;
        case 'g':
          uint64_t v15 = PBReaderReadString(a2);
          uint64_t v13 = objc_claimAutoreleasedReturnValue(v15);
          uint64_t v14 = 8LL;
          goto LABEL_24;
        case 'h':
          uint64_t v16 = PBReaderReadString(a2);
          uint64_t v13 = objc_claimAutoreleasedReturnValue(v16);
          uint64_t v14 = 16LL;
          goto LABEL_24;
        case 'i':
          uint64_t v17 = PBReaderReadString(a2);
          uint64_t v13 = objc_claimAutoreleasedReturnValue(v17);
          uint64_t v14 = 24LL;
LABEL_24:
          uint64_t v18 = *(void **)(a1 + v14);
          *(void *)(a1 + v14) = v13;

          goto LABEL_25;
        default:
          if ((PBReaderSkipValueWithTag(a2) & 1) == 0) {
            return 0LL;
          }
LABEL_25:
          if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
          }
          break;
      }
    }
  }

  return *(_BYTE *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_100186858( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
}

void sub_100186954(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = sub_10001267C("octagon-ckks");
  uint64_t v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = objc_claimAutoreleasedReturnValue([WeakRetained error]);
    unsigned int v5 = (void *)v4;
    unint64_t v6 = @"no error";
    if (v4) {
      unint64_t v6 = (const __CFString *)v4;
    }
    int v7 = 138412290;
    char v8 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Finishing a ckks-local-reset operation with %@",  (uint8_t *)&v7,  0xCu);
  }
}

void sub_100186A34(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  unsigned int v5 = sub_10001267C("octagon-ckks");
  unint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = objc_claimAutoreleasedReturnValue([WeakRetained error]);
    char v8 = (void *)v7;
    id v9 = @"no error";
    if (v7) {
      id v9 = (const __CFString *)v7;
    }
    int v12 = 138412290;
    uint64_t v13 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Finished ckks-local-reset with %@",  (uint8_t *)&v12,  0xCu);
  }

  if (v3)
  {
    [WeakRetained setError:v3];
  }

  else
  {
    int v10 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained intendedState]);
    [WeakRetained setNextState:v10];
  }

  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained finishedOp]);
  [WeakRetained runBeforeGroupFinished:v11];
}

void sub_100187B04( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, id location)
{
}

void sub_100187D74(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSAnalytics logger](&OBJC_CLASS___CKKSAnalytics, "logger"));
  [v5 logResultForEvent:@"OctagonEventReset" hardFailure:1 result:v3];

  unint64_t v6 = sub_10001267C("octagon");
  uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (!v3)
  {
    if (v8)
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Successfully reset Octagon", buf, 2u);
    }

    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained deps]);
    int v12 = (void *)objc_claimAutoreleasedReturnValue([v11 stateHolder]);
    id v22 = 0LL;
    [v12 persistAccountChanges:&stru_1002915B8 error:&v22];
    id v13 = v22;

    uint64_t v14 = sub_10001267C("octagon");
    uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
    BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
    if (v13)
    {
      if (v16)
      {
        *(_DWORD *)__int128 buf = 138412290;
        id v24 = v13;
        uint64_t v17 = "Error resetting local account metadata state: %@";
        uint64_t v18 = v15;
        uint32_t v19 = 12;
LABEL_12:
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v17, buf, v19);
      }
    }

    else if (v16)
    {
      *(_WORD *)__int128 buf = 0;
      uint64_t v17 = "Successfully reset local account metadata state";
      uint64_t v18 = v15;
      uint32_t v19 = 2;
      goto LABEL_12;
    }

    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained intendedState]);
    [WeakRetained setNextState:v20];

    goto LABEL_14;
  }

  if (v8)
  {
    id v9 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained containerName]);
    int v10 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained contextID]);
    *(_DWORD *)__int128 buf = 138412802;
    id v24 = v9;
    __int16 v25 = 2112;
    uint64_t v26 = v10;
    __int16 v27 = 2112;
    id v28 = v3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Unable to reset for (%@,%@): %@", buf, 0x20u);
  }

  [WeakRetained setError:v3];
LABEL_14:
  unsigned int v21 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained finishedOp]);
  [WeakRetained runBeforeGroupFinished:v21];
}

OTAccountMetadataClassC *__cdecl sub_100188004(id a1, OTAccountMetadataClassC *a2)
{
  uint64_t v2 = a2;
  -[OTAccountMetadataClassC setTrustState:](v2, "setTrustState:", 0LL);
  -[OTAccountMetadataClassC setPeerID:](v2, "setPeerID:", 0LL);
  -[OTAccountMetadataClassC setSyncingPolicy:](v2, "setSyncingPolicy:", 0LL);
  -[OTAccountMetadataClassC setVoucher:](v2, "setVoucher:", 0LL);
  -[OTAccountMetadataClassC setVoucherSignature:](v2, "setVoucherSignature:", 0LL);
  -[OTAccountMetadataClassC setTlkSharesForVouchedIdentitys:](v2, "setTlkSharesForVouchedIdentitys:", 0LL);
  -[OTAccountMetadataClassC setIsInheritedAccount:](v2, "setIsInheritedAccount:", 0LL);
  -[OTAccountMetadataClassC setWarmedEscrowCache:](v2, "setWarmedEscrowCache:", 0LL);
  -[OTAccountMetadataClassC setWarnedTooManyPeers:](v2, "setWarnedTooManyPeers:", 0LL);
  return v2;
}

void sub_100189700( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_100189804( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

void sub_100189C34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
}

void sub_10018A058( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

void sub_10018A884( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10018BCE8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_10018C0B4(_Unwind_Exception *a1)
{
}

void sub_10018C2C0(_Unwind_Exception *a1)
{
}

void sub_10018C5AC(_Unwind_Exception *a1)
{
}

void sub_10018C67C(_Unwind_Exception *a1)
{
}

void sub_10018C754(_Unwind_Exception *a1)
{
}

NSMutableArray *__cdecl -[SOSAccount change_blocks](SOSAccount *self, SEL a2)
{
  return self->_change_blocks;
}

void -[SOSAccount setChange_blocks:](SOSAccount *self, SEL a2, id a3)
{
}

NSMutableDictionary *__cdecl -[SOSAccount waitForInitialSync_blocks](SOSAccount *self, SEL a2)
{
  return self->_waitForInitialSync_blocks;
}

void -[SOSAccount setWaitForInitialSync_blocks:](SOSAccount *self, SEL a2, id a3)
{
}

void sub_10018CD70(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v24 = 0LL;
  __int16 v25 = &v24;
  uint64_t v26 = 0x2020000000LL;
  char v27 = 0;
  uint64_t v20 = 0LL;
  unsigned int v21 = &v20;
  uint64_t v22 = 0x2020000000LL;
  uint64_t v23 = 0LL;
  v18[0] = 0LL;
  v18[1] = v18;
  v18[2] = 0x2020000000LL;
  char v19 = 0;
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained accountConfiguration]);
  unint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 storage]);

  [v6 setRingUpdateFlag:0];
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained accountConfiguration]);
  [v7 setStorage:v6];

  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472LL;
  v17[2] = sub_10018D008;
  v17[3] = &unk_100291AB0;
  void v17[4] = WeakRetained;
  v17[5] = &v24;
  void v17[6] = v18;
  void v17[7] = &v20;
  [WeakRetained performTransaction:v17];
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472LL;
  v16[2] = sub_10018D274;
  v16[3] = &unk_100293CA0;
  v16[4] = WeakRetained;
  [WeakRetained performTransaction:v16];
  BOOL v8 = v21;
  if (*((_BYTE *)v25 + 24))
  {
    uint64_t v9 = (const __CFSet *)v21[3];
    if (v9)
    {
      CFIndex Count = CFSetGetCount(v9);
      BOOL v8 = v21;
      if (Count)
      {
        uint64_t v11 = (const __CFSet *)v21[3];
        context[0] = _NSConcreteStackBlock;
        context[1] = 3221225472LL;
        uint64_t context[2] = sub_10018D280;
        context[3] = &unk_100291B00;
        context[4] = WeakRetained;
        context[5] = v18;
        CFSetApplyFunction(v11, (CFSetApplierFunction)sub_10018D314, context);
        BOOL v8 = v21;
      }
    }
  }

  uint64_t v12 = (const void *)v8[3];
  if (v12)
  {
    v8[3] = 0LL;
    CFRelease(v12);
  }

  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472LL;
  v14[2] = sub_10018D328;
  v14[3] = &unk_100293CA0;
  void v14[4] = WeakRetained;
  [WeakRetained performTransaction:v14];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  v13[2] = sub_10018D334;
  v13[3] = &unk_100293CA0;
  void v13[4] = WeakRetained;
  [WeakRetained performTransaction:v13];
  if ([WeakRetained forceSyncForRecoveryRing])
  {
    [WeakRetained performTransaction:&stru_100291B20];
    [WeakRetained setForceSyncForRecoveryRing:0];
  }

  [v3 setNextState:@"ready"];

  _Block_object_dispose(v18, 8);
  _Block_object_dispose(&v20, 8);
  _Block_object_dispose(&v24, 8);
}

void sub_10018CFD4(_Unwind_Exception *a1)
{
}

void sub_10018D008(uint64_t a1)
{
  if (![*(id *)(a1 + 32) accountKeyIsTrusted]
    || ![*(id *)(a1 + 32) isInCircle:0])
  {
    return;
  }

  [*(id *)(a1 + 32) _onQueueRecordRetiredPeersInCircle];
  sub_1001ACB4C(*(void **)(a1 + 32));
  uint64_t v26 = 0LL;
  id v2 = *(id *)(a1 + 32);
  if (![v2 isInCircle:0]
    || (uint64_t v3 = objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "backup_key"))) == 0)
  {
    LOBYTE(v6) = 0;
    goto LABEL_10;
  }

  uint64_t v4 = (void *)v3;
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "backup_key"));
  int v6 = SOSBSKBIsGoodBackupPublic(v5, &v26);

  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = (const void *)SOSPeerInfoCopyBackupKey([v2 peerInfo]);
  BOOL v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "backup_key"));
  uint64_t v9 = v8;
  if (v7 && v8)
  {
    LOBYTE(v6) = CFEqual(v7, v8) != 0;
  }

  else
  {
    LOBYTE(v6) = v7 == v8;

    if (!v7) {
      goto LABEL_10;
    }
  }

  CFRelease(v7);
LABEL_10:

  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = v6;
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL))
  {
    CFTypeRef cf = 0LL;
    uint64_t v18 = sub_100194C30(v10, v11, v12, v13, v14, v15, v16, v17);
    uint64_t v19 = SecItemDelete(v18);
    if (v18) {
      CFRelease(v18);
    }
    if ((_DWORD)v19 == -25300) {
      int v20 = 0;
    }
    else {
      int v20 = v19;
    }
    if (sub_1000194E0(v20, (__CFString **)&cf, @"Deleting V0 Keybag failed - %d", v19))
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
    }

    else
    {
      unsigned int v21 = sub_10001267C("SecError");
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFTypeRef v28 = cf;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Failed to delete v0 keybag: %@", buf, 0xCu);
      }
    }

    CFTypeRef v23 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v23);
    }

    if ([*(id *)(a1 + 32) peerInfo])
    {
      PermittedViews = (const __CFSet *)SOSPeerInfoGetPermittedViews([*(id *)(a1 + 32) peerInfo]);
      *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = CFSetCreateMutableCopy( kCFAllocatorDefault,  0LL,  PermittedViews);
    }
  }

id sub_10018D274(uint64_t a1)
{
  return [*(id *)(a1 + 32) setConsolidateKeyInterest:1];
}

id sub_10018D280(uint64_t a1, CFTypeRef cf)
{
  if (!cf || (v3 = cf, CFTypeID v4 = CFGetTypeID(cf), v4 != CFStringGetTypeID())) {
    CFTypeRef v3 = 0LL;
  }
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  v6[2] = sub_10018D658;
  v6[3] = &unk_100291AD8;
  void v6[6] = v3;
  return [*(id *)(a1 + 32) performTransaction:v6];
}

uint64_t sub_10018D314(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

id sub_10018D328(uint64_t a1)
{
  return [*(id *)(a1 + 32) setConsolidateKeyInterest:0];
}

void sub_10018D334(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFTypeRef cf = 0LL;
  CFTypeID v4 = sub_10001267C("rings");
  unsigned int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Flushing Rings to KVS", buf, 2u);
  }

  int v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "circle_transport"));
  unsigned __int8 v7 = [v6 flushChanges:&cf];

  if ((v7 & 1) == 0)
  {
    int v15 = sub_10001267C("circleOps");
    int v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v19 = cf;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "flush circles/rings failed %@", buf, 0xCu);
    }

    goto LABEL_10;
  }

  BOOL v8 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  objc_msgSend(v8, "setNeed_backup_peers_created_after_backup_key_set:", 1);

  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  int v10 = [v9 getPublicKeyStatusForKey:2 error:0];

  if (v10 >= 1)
  {
    int v11 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
    [v11 setPublicKeyStatus:3 forKey:2];
  }

  int v12 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  int v13 = [v12 getPublicKeyStatusForKey:1 error:0];

  if (v13 >= 1)
  {
    int v14 = (os_log_s *)objc_claimAutoreleasedReturnValue([v3 account]);
    -[os_log_s setPublicKeyStatus:forKey:](v14, "setPublicKeyStatus:forKey:", 3LL, 1LL);
LABEL_10:
  }

  CFTypeRef v16 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v16);
  }

  sub_1001A0098(*(void **)(a1 + 32));
}

void sub_10018D534(id a1, SOSAccountTransaction *a2)
{
  uint64_t v7 = 0LL;
  CFMutableSetRef v2 = sub_100198588(a2, (uint64_t)&v7);
  if (v7)
  {
    id v3 = sub_10001267C("SecError");
    CFTypeID v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v9 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "sos-register-recovery-public-key: Couldn't process sync with backup peers: %@",  buf,  0xCu);
    }
  }

  else
  {
    unsigned int v5 = sub_10001267C("sos-register-recovery-public-key");
    int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "telling CloudServices about recovery key change",  buf,  2u);
    }

    notify_post("com.apple.security.itembackup");
  }
}

id sub_10018D658(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) _onQueueEnsureInBackupRings:*(void *)(a1 + 48)];
  if ((_DWORD)result) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
  }
  return result;
}

void sub_10018D694(uint64_t a1, void *a2)
{
  CFMutableSetRef v2 = (id *)(a1 + 32);
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(v2);
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained accountConfiguration]);
  int v6 = (void *)objc_claimAutoreleasedReturnValue([v5 storage]);

  uint64_t v7 = sub_10001267C("sos-sm");
  BOOL v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v6 pendingBackupPeers]);
    LODWORD(v14) = 138412290;
    *(void *)((char *)&v14 + 4) = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "performing backup for %@",  (uint8_t *)&v14,  0xCu);
  }

  int v10 = (void *)objc_claimAutoreleasedReturnValue([v6 pendingBackupPeers]);
  id v11 = [v10 count];

  if (v11)
  {
    int v12 = (void *)objc_claimAutoreleasedReturnValue([v6 pendingBackupPeers]);
    *(void *)&__int128 v14 = _NSConcreteStackBlock;
    *((void *)&v14 + 1) = 3221225472LL;
    int v15 = sub_1001CE908;
    CFTypeRef v16 = &unk_1002935A8;
    int v17 = v12;
    _os_activity_initiate( (void *)&_mh_execute_header,  "CloudCircle SOSCCRequestSyncWithBackupPeerList",  OS_ACTIVITY_FLAG_DEFAULT,  &v14);

    [v6 clearPendingBackupPeers];
  }

  int v13 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained accountConfiguration]);
  [v13 setStorage:v6];

  [v3 setNextState:@"ready"];
}

void sub_10018D850(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  CFMutableSetRef v2 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained accountConfiguration]);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 storage]);

  [v3 setRingUpdateFlag:1];
  CFTypeID v4 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained accountConfiguration]);
  [v4 setStorage:v3];

  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained performRingUpdates]);
  [v5 trigger];

  int v6 = sub_10001267C("sos-sm");
  uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v8 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained performRingUpdates]);
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 nextFireTime]);
    int v10 = 138412290;
    id v11 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "trigger ring update at %@",  (uint8_t *)&v10,  0xCu);
  }
}

void sub_10018D998(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v3 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained accountConfiguration]);
  CFTypeID v4 = (void *)objc_claimAutoreleasedReturnValue([v3 storage]);

  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue([v4 pendingBackupPeers]);
  if (v5)
  {
    int v6 = *(void **)(a1 + 32);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v4 pendingBackupPeers]);
    [v6 addObjectsFromArray:v7];
  }

  BOOL v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) allObjects]);
  id v9 = [v8 mutableCopy];
  [v4 setPendingBackupPeers:v9];

  int v10 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained accountConfiguration]);
  [v10 setStorage:v4];

  id v11 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained performBackups]);
  [v11 trigger];

  int v12 = sub_10001267C("sos-sm");
  int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = *(void *)(a1 + 40);
    int v15 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained performBackups]);
    CFTypeRef v16 = (void *)objc_claimAutoreleasedReturnValue([v15 nextFireTime]);
    int v17 = 138412546;
    uint64_t v18 = v14;
    __int16 v19 = 2112;
    int v20 = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "trigger backup for peers: %@ at %@",  (uint8_t *)&v17,  0x16u);
  }
}

void sub_10018DB50(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained addBackupFlag];
}

void sub_10018DB7C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained addRingUpdateFlag];
}

void sub_10018DBA8(id a1)
{
  v4[0] = @"trigger_backup";
  v4[1] = @"trigger_ring_update";
  uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v4, 2LL));
  uint64_t v2 = objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", v1));
  id v3 = (void *)qword_1002DED70;
  qword_1002DED70 = v2;
}

void sub_10018DC50(id a1)
{
  v3[0] = @"ready";
  v3[1] = @"error";
  v4[0] = &off_1002ADFB0;
  v4[1] = &off_1002ADFC8;
  v3[2] = @"perform_backup";
  v3[3] = @"perform_ring_update";
  void v4[2] = &off_1002ADFE0;
  void v4[3] = &off_1002ADFF8;
  uint64_t v1 = objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v4,  v3,  4LL));
  uint64_t v2 = (void *)qword_1002DED60;
  qword_1002DED60 = v1;
}

uint64_t sub_10018DD10(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = 0LL;
  int v10 = &v9;
  uint64_t v11 = 0x2020000000LL;
  char v12 = 0;
  CFTypeID v4 = (const __CFSet *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) retirees]);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  v8[2] = sub_10018DDE4;
  v8[3] = &unk_1002918C8;
  uint64_t v5 = *(void *)(a1 + 48);
  v8[4] = *(void *)(a1 + 40);
  void v8[5] = &v9;
  void v8[6] = v5;
  v8[7] = a2;
  CFSetApplyFunction(v4, (CFSetApplierFunction)sub_10018D314, v8);

  uint64_t v6 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_10018DDCC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_10018DDE4(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == SOSPeerInfoGetTypeID())
    {
      if (SOSCircleUpdatePeerInfo(*(void *)(a1 + 56), cf))
      {
        *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 1;
        uint64_t v5 = sub_10001267C("retirement");
        uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = *(const void **)(a1 + 56);
          *(_DWORD *)__int128 buf = 138412546;
          CFTypeRef v16 = cf;
          __int16 v17 = 2112;
          CFTypeRef v18 = v7;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Updated retired peer %@ in %@",  buf,  0x16u);
        }

        CFTypeRef cfa = 0LL;
        BOOL v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) trust]);
        uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "kvs_message_transport"));
        int v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "circle_transport"));
        unsigned __int8 v11 = [v8 cleanupAfterPeer:v9 circleTransport:v10 seconds:86400 circle:*(void *)(a1 + 56) cleanupPeer:cf err:&cfa];

        if ((v11 & 1) == 0)
        {
          char v12 = sub_10001267C("SecError");
          int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138412546;
            CFTypeRef v16 = cf;
            __int16 v17 = 2112;
            CFTypeRef v18 = cfa;
            _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Error cleanup up after peer (%@): %@",  buf,  0x16u);
          }
        }

        if (cfa) {
          CFRelease(cfa);
        }
        *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
      }
    }
  }

id sub_10018DFDC(void *a1, uint64_t a2)
{
  id v3 = (void *)objc_claimAutoreleasedReturnValue([a1 trust]);
  CFTypeID v4 = (void *)objc_claimAutoreleasedReturnValue([v3 expansion]);

  if (v4)
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 expansion]);
    id v6 = [v5 objectForKey:a2];
  }

  else
  {
    id v6 = 0LL;
  }

  return v6;
}

void *sub_10018E050(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  CFTypeID v4 = sub_100195484(*(void **)(a1 + 32), *(const void **)(a1 + 40), a3);
  uint64_t v5 = sub_10001267C("backup");
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = "success";
    uint64_t v8 = *(void *)(a1 + 40);
    if (!v4) {
      uint64_t v7 = "failed";
    }
    int v10 = 138412546;
    uint64_t v11 = v8;
    __int16 v12 = 2080;
    int v13 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Reset backup ring %@ %s",  (uint8_t *)&v10,  0x16u);
  }

  return v4;
}

void sub_10018E13C(uint64_t a1, void *a2)
{
  id v3 = (id)objc_claimAutoreleasedReturnValue([a2 account]);
  CFTypeRef cf = 0LL;
  CFTypeID v4 = sub_10019BF14(v3, (uint64_t)&cf, &stru_100291FB8);
  uint64_t v5 = v4;
  CFTypeRef v6 = cf;
  if (cf) {
    CFTypeRef cf = 0LL;
  }
  if (v4)
  {
    if (CFArrayGetCount(v4))
    {
      sub_100191D4C(v3, v5, (uint64_t)&cf);
      CFTypeRef v7 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
        if (!v6 || (CFRelease(v6), (CFTypeRef v8 = cf) == 0LL))
        {
          CFTypeRef v6 = v7;
          goto LABEL_14;
        }

        CFTypeRef cf = 0LL;
        CFTypeRef v6 = v7;
        goto LABEL_12;
      }
    }

    else
    {
      CFTypeRef v8 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
LABEL_12:
        CFRelease(v8);
      }
    }

void sub_10018E254(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_10018E2CC;
  v3[3] = &unk_100291770;
  uint64_t v2 = *(void **)(a1 + 32);
  id v4 = *(id *)(a1 + 40);
  __int128 v5 = *(_OWORD *)(a1 + 48);
  [v2 performTransaction:v3];
}

void sub_10018E2CC(uint64_t a1, void *a2)
{
  id v7 = a2;
  if ([*(id *)(a1 + 32) count])
  {
    id v3 = (const __CFSet *)objc_claimAutoreleasedReturnValue(+[NSSet setWithArray:](&OBJC_CLASS___NSSet, "setWithArray:", *(void *)(a1 + 32)));
    id v4 = sub_1001981F8(v7, v3, *(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
    if (v4)
    {
      __int128 v5 = v4;
      id Count = (id)CFSetGetCount(v4);
      if (Count == -[__CFSet count](v3, "count")) {
        *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
      }
      CFRelease(v5);
    }
  }

  else
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = sub_10019865C( v7,  *(void *)(*(void *)(a1 + 40)
                                                                                              + 8LL)
                                                                                  + 24LL);
  }
}

void sub_10018E3A0()
{
  uint64_t v4 = 0LL;
  __int128 v5 = &v4;
  uint64_t v6 = 0x2020000000LL;
  v0 = (void (*)(void))off_1002DED50;
  id v7 = off_1002DED50;
  if (!off_1002DED50)
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472LL;
    v3[2] = sub_10018E4BC;
    v3[3] = &unk_100292300;
    void v3[4] = &v4;
    sub_10018E4BC(v3);
    v0 = (void (*)(void))v5[3];
  }

  _Block_object_dispose(&v4, 8);
  if (v0)
  {
    v0();
  }

  else
  {
    uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](&OBJC_CLASS___NSAssertionHandler, "currentHandler"));
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "BOOL soft_MetricsOverrideTestsAreEnabled(void)"));
    objc_msgSend( v1,  "handleFailureInFunction:file:lineNumber:description:",  v2,  @"SOSAccount.m",  94,  @"%s",  dlerror());

    __break(1u);
  }

void sub_10018E4A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void *sub_10018E4BC(void *a1)
{
  __int128 v5 = 0LL;
  if (!qword_1002DED58)
  {
    __int128 v6 = off_100291B40;
    uint64_t v7 = 0LL;
    qword_1002DED58 = _sl_dlopen(&v6, &v5);
  }

  uint64_t v2 = (void *)qword_1002DED58;
  if (!qword_1002DED58)
  {
    a1 = (void *)objc_claimAutoreleasedReturnValue(+[NSAssertionHandler currentHandler](&OBJC_CLASS___NSAssertionHandler, "currentHandler"));
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "void *KeychainCircleLibrary(void)"));
    objc_msgSend( a1,  "handleFailureInFunction:file:lineNumber:description:",  v2,  @"SOSAccount.m",  91,  @"%s",  v5);

    __break(1u);
    goto LABEL_7;
  }

  id v3 = v5;
  if (v5) {
LABEL_7:
  }
    free(v3);
  id result = dlsym(v2, "MetricsOverrideTestsAreEnabled");
  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = result;
  off_1002DED50 = *(_UNKNOWN **)(*(void *)(a1[4] + 8LL) + 24LL);
  return result;
}

void sub_10018E5F0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_alloc(&OBJC_CLASS___AAFAnalyticsEventSecurity);
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t v8 = kSecurityRTCEventNameInitiatorJoinsSOS;
  sub_10018E3A0();
  LOBYTE(v11) = *(_BYTE *)(a1 + 84);
  __int16 v12 = -[AAFAnalyticsEventSecurity initWithKeychainCircleMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:]( v4,  "initWithKeychainCircleMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:",  0LL,  v5,  v6,  v7,  v8,  v9,  v11,  kSecurityRTCEventCategoryAccountDataAccessRecovery);
  int v10 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);

  *(_BYTE *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) = sub_10018E708( v10,  *(const void **)(a1 + 56),  *(unsigned int *)(a1 + 80),  (void *)(*(void *)(*(void *)(a1 + 72) + 8LL)
                                                                                           + 24LL));

  +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:]( &OBJC_CLASS___SecurityAnalyticsReporterRTC,  "sendMetricWithEvent:success:error:",  v12,  *(void *)(a1 + 56) != 0LL,  *(void *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL));
}

id sub_10018E708(void *a1, const void *a2, uint64_t a3, void *a4)
{
  id v7 = a1;
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 trust]);
  CFTypeRef v40 = 0LL;
  CFTypeRef cf = 0LL;
  CFTypeRef v39 = 0LL;
  unsigned __int8 v38 = 0;
  uint64_t v9 = sub_10001267C("circleOps");
  int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Joining circles through piggyback (SOSAccountCopyCircleJoiningBlob)",  buf,  2u);
  }

  if (!a2 || (CFTypeID v11 = CFGetTypeID(a2), v11 != CFDataGetTypeID()))
  {
    __int16 v17 = sub_10001267C("circleOps");
    CFTypeRef v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      __int16 v19 = "Bad data blob: piggyback (SOSAccountCopyCircleJoiningBlob)";
      int v20 = v18;
      uint32_t v21 = 2;
LABEL_18:
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v19, buf, v21);
      goto LABEL_19;
    }

    goto LABEL_19;
  }

  id v12 = sub_100199708(v7, (uint64_t)a4);
  if (!v12)
  {
    uint64_t v22 = sub_10001267C("circleOps");
    CFTypeRef v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_20;
    }
    uint64_t v23 = *a4;
    *(_DWORD *)__int128 buf = 138412290;
    uint64_t v43 = v23;
    __int16 v19 = "Failed - no private credential %@: piggyback (SOSAccountCopyCircleJoiningBlob)";
    goto LABEL_17;
  }

  if ((SOSPiggyBackBlobCreateFromData(&cf, &v39, &v40, a2, a3, &v38, a4) & 1) == 0)
  {
    uint64_t v24 = sub_10001267C("circleOps");
    CFTypeRef v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v25 = *a4;
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v43 = v25;
      __int16 v19 = "Failed - decoding blob %@: piggyback (SOSAccountCopyCircleJoiningBlob)";
LABEL_17:
      int v20 = v18;
      uint32_t v21 = 12;
      goto LABEL_18;
    }

void sub_10018EABC(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  id v11 = a2;
  CFStringRef Copy = (CFStringRef)SOSCopyIDOfKey(a4, 0LL);
  if (!Copy) {
    CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, @"Unknown");
  }
  CFStringRef v13 = (CFStringRef)SOSCopyIDOfDataBuffer(a5, 0LL);
  if (!v13) {
    CFStringRef v13 = CFStringCreateCopy(kCFAllocatorDefault, @"No Signature");
  }
  uint64_t v14 = (const __CFString *)sub_10018DFDC(v11, (uint64_t)@"AccountName");
  int v15 = (void *)objc_claimAutoreleasedReturnValue([v11 trust]);

  BOOL v16 = (const void *)SOSCircleCopyHashString([v15 trustedCircle]);
  __int16 v17 = (const void *)SOSGenerationCountCopyDescription(a3);
  CFTypeRef v18 = sub_10001267C("circleOps");
  __int16 v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    int v20 = @"Unavailable";
    int v21 = 138413826;
    if (v14) {
      int v20 = v14;
    }
    uint64_t v22 = a1;
    __int16 v23 = 2112;
    uint64_t v24 = v20;
    __int16 v25 = 1024;
    int v26 = a6;
    __int16 v27 = 2112;
    CFTypeRef v28 = v17;
    __int16 v29 = 2112;
    CFStringRef v30 = Copy;
    __int16 v31 = 2112;
    CFStringRef v32 = v13;
    __int16 v33 = 2112;
    CFTypeRef v34 = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "%@: Joining blob for account: %@ for piggyback (V%d) gencount: %@  pubkey: %@ signatureID: %@  starting circle hash: %@",  (uint8_t *)&v21,  0x44u);
  }

  if (Copy) {
    CFRelease(Copy);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (v17) {
    CFRelease(v17);
  }
}

uint64_t sub_10018ECB4(uint64_t a1, uint64_t a2)
{
  return SOSCircleAcceptPeerFromHSA2( a2,  *(void *)(a1 + 40),  *(void *)(a1 + 48),  *(void *)(a1 + 56),  *(void *)(a1 + 64),  [*(id *)(a1 + 32) fullPeerInfo],  *(void *)(a1 + 72));
}

uint64_t sub_10018ED10(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10018ED20(uint64_t a1)
{
}

void sub_10018ED28(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_10018EDD8;
  v3[3] = &unk_1002916F8;
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v2 = *(void **)(a1 + 32);
  id v4 = *(id *)(a1 + 40);
  id v5 = *(id *)(a1 + 48);
  id v6 = *(id *)(a1 + 56);
  char v9 = *(_BYTE *)(a1 + 88);
  __int128 v8 = *(_OWORD *)(a1 + 72);
  [v2 performTransaction:v3];
}

void sub_10018EDD8(uint64_t a1, void *a2)
{
  id v6 = (id)objc_claimAutoreleasedReturnValue([a2 account]);
  uint64_t v3 = sub_10018EE40( v6,  *(void **)(a1 + 32),  *(void **)(a1 + 40),  *(void **)(a1 + 48),  *(_BYTE *)(a1 + 80),  *(void *)(a1 + 72),  (uint64_t *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL));
  uint64_t v4 = *(void *)(*(void *)(a1 + 56) + 8LL);
  id v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

uint64_t sub_10018EE40(void *a1, void *a2, void *a3, void *a4, char a5, uint64_t a6, uint64_t *a7)
{
  id v13 = a1;
  id v14 = a2;
  id v15 = a3;
  id v16 = a4;
  __int16 v17 = sub_10001267C("circleOps");
  CFTypeRef v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Making circle joining piggyback blob as sponsor (SOSAccountCopyCircleJoiningBlob)",  buf,  2u);
  }

  id v19 = [v13 getCircleStatus:a7];
  if (!(_DWORD)v19)
  {
    id v27 = sub_100199E38(v13, (uint64_t)a7);
    if (v27)
    {
      if (a6)
      {
        id v28 = v27;
        __int16 v29 = objc_alloc(&OBJC_CLASS___AAFAnalyticsEventSecurity);
        uint64_t v30 = kSecurityRTCEventNameVerifySOSApplication;
        sub_10018E3A0();
        LOBYTE(v4_Block_object_dispose(va, 8) = a5;
        uint64_t v24 = -[AAFAnalyticsEventSecurity initWithKeychainCircleMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:]( v29,  "initWithKeychainCircleMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:",  0LL,  v14,  v15,  v16,  v30,  v31,  v48,  kSecurityRTCEventCategoryAccountDataAccessRecovery);
        if ((SOSPeerInfoApplicationVerify(a6, v28, a7) & 1) == 0)
        {
          id v50 = v14;
          id v42 = sub_10001267C("circleOps");
          uint64_t v43 = (os_log_s *)objc_claimAutoreleasedReturnValue(v42);
          if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v43,  OS_LOG_TYPE_DEFAULT,  "Peer application wasn't signed with the correct userKey",  buf,  2u);
          }

          __int16 v33 = 0LL;
          GenSignatureWithPeerAdded = 0LL;
          CFTypeRef v39 = 0LL;
          BOOL v37 = 0LL;
          uint64_t v25 = 0LL;
          if (!a7) {
            goto LABEL_27;
          }
          goto LABEL_18;
        }

        +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:]( &OBJC_CLASS___SecurityAnalyticsReporterRTC,  "sendMetricWithEvent:success:error:",  v24,  1LL,  0LL);
        uint64_t v32 = SOSFullPeerInfoCopyDeviceKey([v13 fullPeerInfo], a7);
        if (v32)
        {
          __int16 v33 = (const void *)v32;
          id v50 = v14;
          CFTypeRef v34 = (void *)objc_claimAutoreleasedReturnValue([v13 trust]);
          id v35 = [v34 getCircle:a7];

          if (!v35 || (uint64_t v36 = SOSCircleCopyCircle(0LL, v35, a7)) == 0)
          {
            uint64_t v25 = 0LL;
            id v14 = v50;
            goto LABEL_34;
          }

          BOOL v37 = (const void *)v36;
          if (!SOSCirclePreGenerationSign(v36, v28, a7))
          {
            uint64_t v25 = 0LL;
            CFTypeRef v39 = 0LL;
            GenSignatureWithPeerAdded = 0LL;
            goto LABEL_28;
          }

          uint64_t Generation = SOSCircleGetGeneration(v37);
          CFTypeRef v39 = (const void *)SOSGenerationIncrementAndCreate(Generation);
          GenSignatureWithPeerAdded = (const void *)SOSCircleCopyNextGenSignatureWithPeerAdded(v37, a6, v33, a7);
          if (!GenSignatureWithPeerAdded)
          {
            uint64_t v25 = 0LL;
            goto LABEL_28;
          }

          sub_10018EABC( (uint64_t)@"Accepting",  v13,  (uint64_t)v39,  (uint64_t)v33,  (uint64_t)GenSignatureWithPeerAdded,  1);
          uint64_t v25 = SOSPiggyBackBlobCopyEncodedData(v39, v33, GenSignatureWithPeerAdded, a7);
          if (!a7)
          {
LABEL_27:
            id v49 = v16;
            id v44 = v15;
            unint64_t v45 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  kSOSErrorDomain,  12LL,  @"Peer application wasn't signed with the correct userKey"));
            +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:]( &OBJC_CLASS___SecurityAnalyticsReporterRTC,  "sendMetricWithEvent:success:error:",  v24,  0LL,  v45);

            id v15 = v44;
            id v16 = v49;
            if (!v37) {
              goto LABEL_29;
            }
            goto LABEL_28;
          }

id sub_10018F304(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_10018F35C;
  v3[3] = &unk_100293A18;
  uint64_t v1 = *(void **)(a1 + 32);
  void v3[4] = *(void *)(a1 + 40);
  return [v1 performTransaction:v3];
}

void sub_10018F35C(uint64_t a1, void *a2)
{
  id v7 = (id)objc_claimAutoreleasedReturnValue([a2 account]);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v7 trust]);
  uint64_t v4 = SOSCircleCopyHashString([v3 trustedCircle]);
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;
}

void sub_10018F3C0(uint64_t a1, void *a2)
{
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  uint64_t v4 = (const void *)sub_10018F458(v3, *(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);

  if (v4)
  {
    uint64_t v5 = SOSPeerInfoCopyEncodedData(v4, kCFAllocatorDefault, *(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8LL);
    id v7 = *(void **)(v6 + 40);
    *(void *)(v6 + 40) = v5;

    CFRelease(v4);
  }

uint64_t sub_10018F458(void *a1, uint64_t a2)
{
  id v3 = a1;
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 trust]);
  id v5 = sub_100199708(v3, a2);
  if (v5
    && (id v6 = v5, [v4 ensureFullPeerAvailable:v3 err:a2])
    && SOSFullPeerInfoPromoteToApplication([v4 fullPeerInfo], v6, a2))
  {
    uint64_t Copy = SOSPeerInfoCreateCopy(kCFAllocatorDefault, [v4 peerInfo], a2);
  }

  else
  {
    uint64_t Copy = 0LL;
  }

  return Copy;
}

uint64_t sub_10018F50C(uint64_t a1)
{
  id v19 = 0LL;
  if ([*(id *)(a1 + 32) syncWaitAndFlush:*(void *)(a1 + 40) flowID:*(void *)(a1 + 48) deviceSessionID:*(void *)(a1 + 56) canSendMetrics:*(unsigned __int8 *)(a1 + 80) error:&v19])
  {
    uint64_t v15 = 0LL;
    id v16 = &v15;
    uint64_t v17 = 0x2020000000LL;
    char v18 = 0;
    sleep(1u);
    uint64_t v2 = *(void **)(a1 + 32);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472LL;
    v10[2] = sub_10018F6F8;
    v10[3] = &unk_100291680;
    id v11 = *(id *)(a1 + 64);
    id v3 = *(id *)(a1 + 72);
    uint64_t v12 = *(void *)(a1 + 32);
    id v13 = v3;
    id v14 = &v15;
    [v2 performTransaction:v10];
    if (*((_BYTE *)v16 + 24))
    {
      CFTypeRef cf = 0LL;
      if (!sub_10018FA68((uint64_t)&cf))
      {
        uint64_t v4 = sub_10001267C("pairing");
        id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          CFTypeRef v21 = cf;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "failed final flush: %@", buf, 0xCu);
        }
      }

      CFTypeRef v6 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
        CFRelease(v6);
      }
    }

    _Block_object_dispose(&v15, 8);
  }

  else
  {
    (*(void (**)(void))(*(void *)(a1 + 72) + 16LL))();
    id v7 = v19;
    if (v19)
    {
      id v19 = 0LL;
      CFRelease(v7);
    }
  }

  return 1LL;
}

void sub_10018F6D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

void sub_10018F6F8(uint64_t a1)
{
  CFErrorRef error = 0LL;
  v22[0] = kSecAttrKeyClass;
  v22[1] = kSecAttrKeyType;
  v23[0] = kSecAttrKeyClassPrivate;
  v23[1] = kSecAttrKeyTypeEC;
  uint64_t v2 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v23,  v22,  2LL));
  SecKeyRef v3 = SecKeyCreateWithData(*(CFDataRef *)(a1 + 32), v2, &error);
  if (!v3)
  {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
    uint64_t v12 = sub_10001267C("pairing");
    id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_17;
    }
    *(_DWORD *)__int128 buf = 138412290;
    CFErrorRef v21 = error;
    id v14 = "SecKeyCreateWithData failed: %@";
    goto LABEL_16;
  }

  SecKeyRef v4 = v3;
  id v5 = *(id *)(a1 + 40);
  if ((sub_100199EA4(v5, (uint64_t)v4, (CFTypeRef *)&error) & 1) != 0)
  {
    sub_10019A160(v5, 0, (uint64_t)v4, (int)[v5 accountKeyIsTrusted]);
    sub_100199990(v5);
    CFTypeRef v6 = sub_10001267C("circleop");
    id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Setting account.key_interests_need_updating to true in SOSAccountTryUserPrivateKey",  buf,  2u);
    }

    objc_msgSend(v5, "setKey_interests_need_updating:", 1);
    __int128 v8 = sub_10001267C("circleOps");
    char v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Accepted provided user_private as credential",  buf,  2u);
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 1;
    int v10 = sub_10001267C("pairing");
    id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "SOSAccountTryUserPrivateKey succeeded",  buf,  2u);
    }

    CFRelease(v4);
    (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
    goto LABEL_19;
  }

  uint64_t v15 = sub_10001267C("circleOps");
  id v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Failed to accept provided user_private as credential",  buf,  2u);
  }

  CFRelease(v4);
  (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
  uint64_t v17 = sub_10001267C("pairing");
  id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412290;
    CFErrorRef v21 = error;
    id v14 = "SOSAccountTryUserPrivateKey failed: %@";
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v14, buf, 0xCu);
  }

BOOL sub_10018FA68(uint64_t a1)
{
  uint64_t v17 = 0LL;
  CFErrorRef v18 = &v17;
  uint64_t v19 = 0x2020000000LL;
  char v20 = 0;
  dispatch_semaphore_t v2 = dispatch_semaphore_create(0LL);
  SecKeyRef v3 = sub_10001267C("flush");
  SecKeyRef v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Starting", buf, 2u);
  }

  dispatch_queue_global_t global_queue = dispatch_get_global_queue(-2LL, 0LL);
  CFTypeRef v6 = (void *)objc_claimAutoreleasedReturnValue(global_queue);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  v13[2] = sub_10018FC64;
  v13[3] = &unk_1002939A0;
  uint64_t v15 = &v17;
  uint64_t v16 = a1;
  id v7 = v2;
  id v14 = v7;
  SOSCloudKeychainFlush(v6, v13);

  dispatch_semaphore_wait(v7, 0xFFFFFFFFFFFFFFFFLL);
  __int128 v8 = sub_10001267C("flush");
  char v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (*((_BYTE *)v18 + 24)) {
      int v10 = "Success";
    }
    else {
      int v10 = "Failure";
    }
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v22 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Returned %s", buf, 0xCu);
  }

  BOOL v11 = *((_BYTE *)v18 + 24) != 0;
  _Block_object_dispose(&v17, 8);
  return v11;
}

void sub_10018FC44( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_10018FC64(uint64_t a1, int a2, CFTypeRef cf)
{
  SecKeyRef v4 = *(CFTypeRef **)(a1 + 48);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = cf == 0LL;
  if (v4)
  {
    CFTypeRef v6 = *v4;
    if (*v4 != cf)
    {
      if (!cf || (CFRetain(cf), (CFTypeRef v6 = *v4) != 0LL)) {
        CFRelease(v6);
      }
      *SecKeyRef v4 = cf;
    }
  }

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_10018FCD0(uint64_t a1)
{
  dispatch_semaphore_t v2 = objc_alloc(&OBJC_CLASS___AAFAnalyticsEventSecurity);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = kSecurityRTCEventNameValidatedStashedAccountCredential;
  sub_10018E3A0();
  LOBYTE(v22) = *(_BYTE *)(a1 + 72);
  __int128 v8 = -[AAFAnalyticsEventSecurity initWithKeychainCircleMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:]( v2,  "initWithKeychainCircleMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:",  0LL,  v3,  v4,  v5,  v6,  v7,  v22,  kSecurityRTCEventCategoryAccountDataAccessRecovery);
  CFErrorRef error = 0LL;
  char v9 = sub_100199C8C((__CFString **)&error);
  if (v9)
  {
    int v10 = v9;
    SecKeyRef v11 = SecKeyCopyPublicKey(v9);
    if (v11)
    {
      SecKeyRef v12 = v11;
      id v13 = sub_10001267C("pairing");
      id v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        SecKeyRef v27 = v12;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "returning stash credential: %@", buf, 0xCu);
      }

      CFRelease(v12);
    }

    CFDataRef v15 = SecKeyCopyExternalRepresentation(v10, &error);
    CFRelease(v10);
    (*(void (**)(void))(*(void *)(a1 + 64) + 16LL))();
    CFErrorRef v16 = error;
    if (error)
    {
      CFErrorRef error = 0LL;
      CFRelease(v16);
    }

    uint64_t v24 = kSecurityRTCFieldNumberOfKeychainItemsCollected;
    uint64_t v25 = &off_1002ADF98;
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v25,  &v24,  1LL));
    -[AAFAnalyticsEventSecurity addMetrics:](v8, "addMetrics:", v17);

    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:]( &OBJC_CLASS___SecurityAnalyticsReporterRTC,  "sendMetricWithEvent:success:error:",  v8,  1LL,  0LL);
  }

  else
  {
    CFErrorRef v18 = sub_10001267C("pairing");
    uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "no stashed credential", buf, 2u);
    }

    uint64_t v28 = kSecurityRTCFieldNumberOfKeychainItemsCollected;
    __int16 v29 = &off_1002ADF80;
    char v20 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v29,  &v28,  1LL));
    -[AAFAnalyticsEventSecurity addMetrics:](v8, "addMetrics:", v20);

    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:]( &OBJC_CLASS___SecurityAnalyticsReporterRTC,  "sendMetricWithEvent:success:error:",  v8,  0LL,  error);
    (*(void (**)(void))(*(void *)(a1 + 64) + 16LL))();
    CFErrorRef v21 = error;
    if (error)
    {
      CFErrorRef error = 0LL;
      CFRelease(v21);
    }
  }
}

void sub_10018FF90(uint64_t a1)
{
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(-2LL, 0LL);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(global_queue);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  v10[2] = sub_1001900F4;
  v10[3] = &unk_1002939A0;
  uint64_t v12 = *(void *)(a1 + 48);
  __int128 v9 = *(_OWORD *)(a1 + 32);
  id v4 = (id)v9;
  __int128 v11 = v9;
  SOSCloudKeychainSynchronizeAndWait(v3, v10);

  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 32), 0xFFFFFFFFFFFFFFFFLL);
  uint64_t v5 = sub_10001267C("fresh");
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void **)(a1 + 48);
    if (*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL)) {
      __int128 v8 = "success";
    }
    else {
      __int128 v8 = "failure";
    }
    if (v7) {
      uint64_t v7 = (void *)*v7;
    }
    *(_DWORD *)__int128 buf = 136315394;
    id v14 = v8;
    __int16 v15 = 2112;
    CFErrorRef v16 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "EFP complete: %s %@", buf, 0x16u);
  }
}

uint64_t sub_1001900F4(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v5 = sub_10001267C("fresh");
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = 138412290;
    __int128 v11 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "EFP returned, callback error: %@",  (uint8_t *)&v10,  0xCu);
  }

  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a3 == 0LL;
  uint64_t v7 = *(const void ***)(a1 + 48);
  if (v7)
  {
    __int128 v8 = *v7;
    if (*v7 != a3)
    {
      if (!a3 || (CFRetain(a3), (__int128 v8 = *v7) != 0LL)) {
        CFRelease(v8);
      }
      *uint64_t v7 = a3;
    }
  }

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_1001901F4(uint64_t a1)
{
  CFTypeRef cf = 0LL;
  sub_10019A050(*(void **)(a1 + 32), (__CFString **)&cf);
  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
  CFTypeRef v2 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v2);
  }

void sub_10019024C(uint64_t a1)
{
  CFTypeRef cf = 0LL;
  SecKeyRef v2 = sub_100199C8C((__CFString **)&cf);
  if (v2)
  {
    SecKeyRef v3 = v2;
    id v4 = (void *)SecKeyCopySubjectPublicKeyInfo(v2);
    CFRelease(v3);
    (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
  }

  else
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
    CFTypeRef v5 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v5);
    }
  }

uint64_t sub_1001902DC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16LL))();
}

uint64_t sub_100190314(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_100190320(uint64_t a1)
{
  if ([*(id *)(a1 + 32) accountKeyIsTrusted]
    && [*(id *)(a1 + 32) accountKey])
  {
    uint64_t v2 = SecKeyCopySubjectPublicKeyInfo([*(id *)(a1 + 32) accountKey]);
    if (v2)
    {
      SecKeyRef v3 = (void *)v2;
      (*(void (**)(void, id, uint64_t, void))(*(void *)(a1 + 40) + 16))( *(void *)(a1 + 40),  [*(id *)(a1 + 32) accountKeyIsTrusted],  v2,  0);
    }

    else
    {
      CFStringRef v11 = kCFErrorDescriptionKey;
      uint64_t v12 = @"User public not available";
      uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v12,  &v11,  1LL));
      uint64_t v8 = *(void *)(a1 + 40);
      id v9 = [*(id *)(a1 + 32) accountKeyIsTrusted];
      int v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  kSOSErrorDomain,  2LL,  v7));
      (*(void (**)(uint64_t, id, void, void *))(v8 + 16))(v8, v9, 0LL, v10);

      SecKeyRef v3 = 0LL;
    }
  }

  else
  {
    CFStringRef v13 = kCFErrorDescriptionKey;
    id v14 = @"User public key not trusted";
    SecKeyRef v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v14,  &v13,  1LL));
    uint64_t v4 = *(void *)(a1 + 40);
    id v5 = [*(id *)(a1 + 32) accountKeyIsTrusted];
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  kSOSErrorDomain,  2LL,  v3));
    (*(void (**)(uint64_t, id, void, void *))(v4 + 16))(v4, v5, 0LL, v6);
  }
}

CFStringRef sub_100190528(void *a1)
{
  id result = (const __CFString *)sub_10018DFDC(a1, kSOSDSIDKey);
  if (result)
  {
    uint64_t v2 = result;
    CFTypeID v3 = CFGetTypeID(result);
    if (v3 == CFStringGetTypeID() && !CFEqual(v2, kCFNull))
    {
      if (CFStringCompare(v2, &stru_100294B48, 0LL)) {
        return v2;
      }
      else {
        return 0LL;
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

uint64_t sub_1001905A8(void *a1, uint64_t a2)
{
  id v3 = a1;
  uint64_t v4 = sub_100190528(v3);
  if (!v4)
  {
    uint64_t v8 = sub_10001267C("updates");
    id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138412290;
      uint64_t v12 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Setting dsid, current dsid is empty for this account: %@",  (uint8_t *)&v11,  0xCu);
    }

    sub_100190730(v3, a2);
    goto LABEL_10;
  }

  if (!a2) {
    goto LABEL_11;
  }
  id v5 = v4;
  if (CFStringCompare((CFStringRef)a2, v4, 0LL) == kCFCompareEqualTo)
  {
LABEL_10:
    a2 = 0LL;
    goto LABEL_11;
  }

  uint64_t v6 = sub_10001267C("updates");
  uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 138412546;
    uint64_t v12 = (uint64_t)v5;
    __int16 v13 = 2112;
    uint64_t v14 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Changing DSID from: %@ to %@",  (uint8_t *)&v11,  0x16u);
  }

  sub_10001BB24(@"DSID Change is unexpected", 0x53C00011u);
  sub_1001907A8(v3);
  sub_100190730(v3, a2);
  a2 = 1LL;
LABEL_11:

  return a2;
}

void sub_100190730(void *a1, uint64_t a2)
{
  uint64_t v3 = kSOSDSIDKey;
  id v4 = a1;
  sub_1001A93D0(v4, v3, a2, 0LL);
  id v5 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "circle_transport"));

  [v5 kvsSendOfficialDSID:a2 err:0];
}

void sub_1001907A8(void *a1)
{
  id v1 = a1;
  uint64_t v2 = sub_10001267C("accountChange");
  uint64_t v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Setting Account to New", buf, 2u);
  }

  int v11 = sub_100107FA8( kCFAllocatorDefault,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  (uint64_t)kSecClass,  (uint64_t)kSecClassGenericPassword);
  sub_100190C80(v11);
  if (v11) {
    CFRelease(v11);
  }
  uint64_t v19 = sub_100107FA8(kCFAllocatorDefault, v12, v13, v14, v15, v16, v17, v18, (uint64_t)kSecClass, (uint64_t)kSecClassKey);
  sub_100190C80(v19);
  if (v19) {
    CFRelease(v19);
  }
  SecKeyRef v27 = sub_100107FA8( kCFAllocatorDefault,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  (uint64_t)kSecClass,  (uint64_t)kSecClassGenericPassword);
  sub_100190C80(v27);
  if (v27) {
    CFRelease(v27);
  }
  id v35 = sub_100107FA8( kCFAllocatorDefault,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  (uint64_t)kSecClass,  (uint64_t)kSecClassGenericPassword);
  sub_100190C80(v35);
  if (v35) {
    CFRelease(v35);
  }
  uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "user_private_timer"));

  if (v36)
  {
    BOOL v37 = (dispatch_source_s *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "user_private_timer"));
    dispatch_source_cancel(v37);

    objc_msgSend(v1, "setUser_private_timer:", 0);
    xpc_transaction_end();
  }

  if (objc_msgSend(v1, "lock_notification_token") != -1)
  {
    notify_cancel((int)objc_msgSend(v1, "lock_notification_token"));
    objc_msgSend(v1, "setLock_notification_token:", 0xFFFFFFFFLL);
  }

  unsigned __int8 v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "key_transport"));
  sub_1001B5054(v38);

  CFTypeRef v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "kvs_message_transport"));
  sub_1001B4F14(v39);

  CFTypeRef v40 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "circle_transport"));
  sub_1001B4FCC(v40);

  objc_msgSend(v1, "setCircle_transport:", 0);
  objc_msgSend(v1, "setKvs_message_transport:", 0);
  objc_msgSend(v1, "set_password_tmp:", 0);
  objc_msgSend(v1, "setCircle_rings_retirements_need_attention:", 1);
  objc_msgSend(v1, "setEngine_peer_state_needs_repair:", 1);
  objc_msgSend(v1, "setKey_interests_need_updating:", 1);
  objc_msgSend(v1, "setNeed_backup_peers_created_after_backup_key_set:", 1);
  [v1 setAccountKeyIsTrusted:0];
  [v1 setAccountKeyDerivationParameters:0];
  [v1 setAccountPrivateKey:0];
  [v1 setAccountKey:0];
  [v1 setPreviousAccountKey:0];
  [v1 setPeerPublicKey:0];
  objc_msgSend(v1, "setBackup_key:", 0);
  [v1 setNotifyCircleChangeOnExit:1];
  [v1 setNotifyViewChangeOnExit:1];
  [v1 setNotifyBackupOnExit:1];
  [v1 setOctagonSigningFullKeyRef:0];
  [v1 setOctagonEncryptionFullKeyRef:0];
  [v1 setTrust:0];
  uint64_t v41 = objc_alloc(&OBJC_CLASS___SOSAccountTrustClassic);
  id v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
  uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  id v44 = -[SOSAccountTrustClassic initWithRetirees:fpi:circle:departureCode:peerExpansion:]( v41,  "initWithRetirees:fpi:circle:departureCode:peerExpansion:",  v42,  0LL,  0LL,  0LL,  v43);
  [v1 setTrust:v44];

  [v1 ensureFactoryCircles];
  CFStringRef v45 = sub_1001A9474(v1);
  if (v45) {
    CFRelease(v45);
  }
  uint64_t v46 = sub_10001267C("circleop");
  uint64_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue(v46);
  if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v48 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v47,  OS_LOG_TYPE_DEFAULT,  "Setting account.key_interests_need_updating to true in SOSAccountSetToNew",  v48,  2u);
  }

  objc_msgSend(v1, "setKey_interests_need_updating:", 1);
}

void sub_100190C80(const __CFDictionary *a1)
{
  OSStatus v1 = SecItemDelete(a1);
  if (v1)
  {
    OSStatus v2 = v1;
    uint64_t v3 = sub_10001267C("SecError");
    int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5[0] = 67109120;
      v5[1] = v2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "SecItemDelete: %d", (uint8_t *)v5, 8u);
    }
  }

SOSAccount *sub_100190D30(uint64_t a1, uint64_t a2)
{
  OSStatus v2 = -[SOSAccount initWithGestalt:factory:](objc_alloc(&OBJC_CLASS___SOSAccount), "initWithGestalt:factory:", a1, a2);
  uint64_t v3 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(-[SOSAccount queue](v2, "queue"));
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100190DD4;
  block[3] = &unk_1002927F0;
  int v4 = v2;
  int v7 = v4;
  dispatch_sync(v3, block);

  return v4;
}

id sub_100190DD4(uint64_t a1)
{
  OSStatus v2 = sub_10001267C("circleop");
  uint64_t v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v5 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Setting account.key_interests_need_updating to true in SOSAccountCreate",  v5,  2u);
  }

  return objc_msgSend(*(id *)(a1 + 32), "setKey_interests_need_updating:", 1);
}

void sub_100190E50(uint64_t a1, const void *a2)
{
  OSStatus v2 = a2;
  CFSetSetValue(*(CFMutableSetRef *)(a1 + 32), a2);
  CFTypeRef cf = 0LL;
  int v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) trust]);
  int v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "kvs_message_transport"));
  int v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "circle_transport"));
  LOBYTE(v2) = [v4 cleanupAfterPeer:v5 circleTransport:v6 seconds:86400 circle:*(void *)(a1 + 48) cleanupPeer:v2 err:&cf];

  if ((v2 & 1) == 0)
  {
    int v7 = sub_10001267C("retirement");
    int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v11 = cf;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Error cleaning up after peer, probably orphaned some stuff in KVS: (%@)  moving on",  buf,  0xCu);
    }
  }

  if (cf) {
    CFRelease(cf);
  }
}

uint64_t sub_100190F90(uint64_t result, CFTypeRef cf)
{
  if (cf)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID(cf);
    id result = SOSPeerInfoGetTypeID();
    if (v4 == result)
    {
      id result = SOSCircleUpdatePeerInfo(*(void *)(v3 + 40), cf);
      *(_BYTE *)(*(void *)(*(void *)(v3 + 32) + 8LL) + 24LL) = 1;
    }
  }

  return result;
}

void sub_100190FF0(void *a1, void *a2)
{
  id v3 = a1;
  id v6 = objc_retainBlock(a2);
  CFTypeID v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "change_blocks"));

  id v5 = objc_retainBlock(v6);
  [v4 addObject:v5];
}

BOOL sub_100191060(void *a1, uint64_t a2, CFTypeRef *a3)
{
  id v5 = a1;
  id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 trust]);
  id v7 = [v6 fullPeerInfo];
  int v8 = (__CFSet *)objc_claimAutoreleasedReturnValue([v6 retirees]);
  if (v7)
  {
    CFTypeRef cf = 0LL;
    int v9 = (const void *)SOSFullPeerInfoPromoteToRetiredAndCopy(v7, &cf);
    if (cf)
    {
      int v10 = sub_10001267C("SecError");
      CFTypeRef v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFTypeRef v35 = cf;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "SOSFullPeerInfoPromoteToRetiredAndCopy error: %@",  buf,  0xCu);
      }

      CFTypeRef v12 = cf;
      if (a3)
      {
        *a3 = cf;
      }

      else if (cf)
      {
        CFTypeRef cf = 0LL;
        CFRelease(v12);
      }
    }

    if (v9)
    {
      if (SOSCircleHasApplicant(a2, v9, 0LL))
      {
        SOSCircleWithdrawRequest(a2, v9, 0LL);
      }

      else if (SOSCircleHasPeer(a2, v9, 0LL) && SOSCircleUpdatePeerInfo(a2, v9))
      {
        CFTypeRef v32 = 0LL;
        int v15 = (void *)objc_claimAutoreleasedReturnValue([v5 trust]);
        int v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "kvs_message_transport"));
        int v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "circle_transport"));
        unsigned __int8 v18 = [v15 cleanupAfterPeer:v16 circleTransport:v17 seconds:86400 circle:a2 cleanupPeer:v9 err:&v32];

        if ((v18 & 1) == 0)
        {
          uint64_t v19 = sub_10001267C("SecError");
          int v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138412546;
            CFTypeRef v35 = v9;
            __int16 v36 = 2112;
            CFTypeRef v37 = v32;
            _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Error cleanup up after peer (%@): %@",  buf,  0x16u);
          }
        }

        if (v32) {
          CFRelease(v32);
        }
      }

      CFSetAddValue(v8, v9);
      [v6 setRetirees:v8];
      CFTypeRef v32 = 0LL;
      int v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "circle_transport"));
      unsigned __int8 v22 = [v21 postRetirement:SOSCircleGetName(a2) peer:v9 err:&v32];

      if ((v22 & 1) == 0)
      {
        int v23 = sub_10001267C("SecWarning");
        int v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          CFTypeRef v35 = v32;
          _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Couldn't post retirement (%@)",  buf,  0xCu);
        }
      }

      int v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "circle_transport"));
      unsigned __int8 v26 = [v25 flushChanges:&v32];

      if ((v26 & 1) == 0)
      {
        SecKeyRef v27 = sub_10001267C("SecWarning");
        int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          CFTypeRef v35 = v32;
          _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "Couldn't flush retirement data (%@)",  buf,  0xCu);
        }
      }

      CFTypeRef v29 = v32;
      if (v32)
      {
        CFTypeRef v32 = 0LL;
        CFRelease(v29);
      }
    }

    else
    {
      int v13 = sub_10001267C("SecError");
      int v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412546;
        CFTypeRef v35 = v7;
        __int16 v36 = 2112;
        CFTypeRef v37 = 0LL;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Create ticket failed for peer %@: %@",  buf,  0x16u);
      }
    }

    int v30 = (void *)objc_claimAutoreleasedReturnValue([v5 trust]);
    [v30 purgeIdentity];

    if (v9) {
      CFRelease(v9);
    }
  }

  return v7 != 0LL;
}

void sub_1001914AC(uint64_t a1, const void *a2)
{
  if (SOSPeerInfoIsCloudIdentity(a2))
  {
    CloudIdentity = (const void *)SOSFullPeerInfoCreateCloudIdentity(kCFAllocatorDefault, a2, 0LL);
    if (CloudIdentity) {
      CFRelease(CloudIdentity);
    }
    else {
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 32), a2);
    }
  }

uint64_t sub_100191514(void *a1, int a2, uint64_t a3)
{
  id v5 = a1;
  id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v6 trust]);
  id v8 = sub_100199708(v6, a3);
  if (!v8) {
    goto LABEL_45;
  }
  id v9 = v8;
  if ([v7 trustedCircle] && SOSCircleCountPeers(objc_msgSend(v7, "trustedCircle")))
  {
    if (([v6 accountInScriptBypassMode] & 1) == 0)
    {
      id v10 = [v7 trustedCircle];
      CFTypeRef v11 = (void *)objc_claimAutoreleasedReturnValue([v6 peerID]);
      LODWORD(v10) = SOSCircleHasPeerWithID(v10, v11, 0LL);

      if ((_DWORD)v10)
      {
        CFTypeRef v12 = sub_10001267C("circleops");
        int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "attempt to join a circle we're in - continuing.",  buf,  2u);
        }

        goto LABEL_43;
      }
    }

    if (SOSCircleVerify([v7 trustedCircle], objc_msgSend(v6, "accountKey"), 0))
    {
      if (([v6 accountInScriptBypassMode] & 1) == 0 && objc_msgSend(v7, "fullPeerInfo"))
      {
        id v18 = [v7 peerInfo];
        if (SOSCircleHasPeer([v7 trustedCircle], v18, 0))
        {
LABEL_43:
          uint64_t v17 = 1LL;
          goto LABEL_44;
        }

        SOSCircleRemoveRejectedPeer([v7 trustedCircle], v18, 0);
        if ((SOSCircleHasApplicant([v7 trustedCircle], v18, 0) & 1) == 0)
        {
          uint64_t v19 = sub_10001267C("SecError");
          int v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138412546;
            *(void *)&uint8_t buf[4] = SOSPeerInfoGetPeerID(v18);
            *(_WORD *)&_BYTE buf[12] = 2112;
            *(void *)&buf[14] = SOSCircleGetName([v7 trustedCircle]);
            _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Resetting my peer (ID: %@) for circle '%@' during application",  buf,  0x16u);
          }

          [v7 setFullPeerInfo:0];
        }
      }

      id v40 = v5;
      int v21 = (void *)objc_claimAutoreleasedReturnValue([v40 account]);
      unsigned __int8 v22 = (void *)objc_claimAutoreleasedReturnValue([v21 trust]);
      uint64_t v45 = 0LL;
      uint64_t v46 = &v45;
      uint64_t v47 = 0x2020000000LL;
      char v48 = 0;
      uint64_t v41 = 0LL;
      id v42 = &v41;
      uint64_t v43 = 0x2020000000LL;
      uint64_t v44 = 0LL;
      if ([v22 trustedCircle])
      {
        int v23 = (void *)objc_claimAutoreleasedReturnValue([v21 trust]);
        unsigned int v24 = [v23 ensureFullPeerAvailable:v21 err:a3];

        if (v24)
        {
          if ([v21 accountInScriptBypassMode])
          {
            int v25 = (void *)objc_claimAutoreleasedReturnValue([v21 trust]);
            [v25 setFullPeerInfo:0];

            unsigned __int8 v26 = (void *)objc_claimAutoreleasedReturnValue([v21 trust]);
            [v26 ensureFullPeerAvailable:v21 err:a3];
          }

          id v39 = [v22 fullPeerInfo];
          if (SOSCircleCountPeers([v22 trustedCircle])
            && (([v21 accountInScriptBypassMode] & 1) != 0
             || !sub_1001B2D9C(v21)))
          {
            sub_1001A164C(v21);
            if (a2)
            {
              uint64_t v32 = SOSCircleCopyiCloudFullPeerInfoRef([v22 trustedCircle], 0);
              v42[3] = v32;
            }

            int v33 = (void *)objc_claimAutoreleasedReturnValue([v21 trust]);
            int v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "circle_transport"));
            *(void *)__int128 buf = _NSConcreteStackBlock;
            *(void *)&uint8_t buf[8] = 3221225472LL;
            *(void *)&uint8_t buf[16] = sub_100191B84;
            id v50 = &unk_100291B60;
            unint64_t v53 = &v45;
            id v51 = v21;
            id v55 = v39;
            uint64_t v56 = a3;
            id v57 = v9;
            id v52 = v22;
            unsigned int v54 = &v41;
            [v33 modifyCircle:v34 err:a3 action:buf];

            if (a2)
            {
              AllCFAbsoluteTime Current = (const __CFSet *)SOSViewsGetAllCurrent();
              sub_1001A1CD0(v40, AllCurrent);
            }

            CFTypeRef v29 = v51;
          }

          else
          {
            SecKeyRef v27 = sub_10001267C("resetToOffering");
            int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)__int128 buf = 0;
              _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "Resetting circle to offering since there are no peers",  buf,  2u);
            }

            CFTypeRef v29 = (void *)objc_claimAutoreleasedReturnValue([v21 trust]);
            unsigned __int8 v30 = [v29 resetCircleToOffering:v40 userKey:v9 err:a3];
            *((_BYTE *)v46 + 24) = v30;
          }
        }
      }

      else
      {
        SOSCreateErrorWithFormat(1032LL, 0LL, a3, 0LL, @"Don't have circle when joining???");
      }

      __int16 v36 = (const void *)v42[3];
      if (v36)
      {
        v42[3] = 0LL;
        CFRelease(v36);
      }

      BOOL v37 = *((_BYTE *)v46 + 24) == 0;
      _Block_object_dispose(&v41, 8);
      _Block_object_dispose(&v45, 8);

      if (!v37)
      {
        [v7 setDepartureCode:1];
        goto LABEL_43;
      }

void sub_100191B54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100191B84(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 64);
  uint64_t v5 = *(void *)(a1 + 72);
  id v6 = sub_10018DFDC(*(void **)(a1 + 32), (uint64_t)@"EscrowRecord");
  *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = SOSFullPeerInfoReplaceEscrowRecords(v4, v6, v5);
  char v7 = SOSCircleRequestAdmission(a2, *(void *)(a1 + 80), *(void *)(a1 + 64), *(void *)(a1 + 72));
  uint64_t v8 = *(void *)(*(void *)(a1 + 48) + 8LL);
  if (*(_BYTE *)(v8 + 24)) {
    char v9 = v7;
  }
  else {
    char v9 = 0;
  }
  *(_BYTE *)(v8 + 24) = v9;
  [*(id *)(a1 + 40) setDepartureCode:1];
  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL)) {
    return 0LL;
  }
  uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL);
  if (!v10) {
    return 1LL;
  }
  CFTypeRef cf = 0LL;
  uint64_t PeerInfo = SOSFullPeerInfoGetPeerInfo(v10);
  uint64_t PeerID = SOSPeerInfoGetPeerID(PeerInfo);
  if (PeerID)
  {
    if (SOSCircleHasActivePeerWithID(a2, PeerID, &cf))
    {
      uint64_t v13 = *(void *)(a1 + 80);
      uint64_t v14 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL);
      uint64_t v15 = SOSFullPeerInfoGetPeerInfo(*(void *)(a1 + 64));
      SOSCircleAcceptRequest(a2, v13, v14, v15, &cf);
    }

    if (cf)
    {
      int v16 = sub_10001267C("SecError");
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFTypeRef v22 = cf;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Failed to join with cloud identity: %@",  buf,  0xCu);
      }

      CFTypeRef v18 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
        CFRelease(v18);
      }
    }
  }

  return *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) != 0;
}

uint64_t sub_100191D4C(void *a1, const __CFArray *a2, uint64_t a3)
{
  id v5 = a1;
  sub_100012EDC(a2, @"[", @"]", (uint64_t)&stru_1002917E0);
  id v6 = sub_100199708(v5, a3);
  if (!v6)
  {
    uint64_t v17 = sub_10001267C("circleOps");
    CFTypeRef v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Can't remove without userKey", buf, 2u);
    }

    goto LABEL_14;
  }

  id v7 = v6;
  id v8 = [v5 fullPeerInfo];
  id v9 = [v5 peerInfo];
  if (!v8 || (uint64_t v10 = v9) == 0LL)
  {
    uint64_t v19 = sub_10001267C("circleOps");
    int v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v20,  OS_LOG_TYPE_DEFAULT,  "Can't remove without being active peer",  buf,  2u);
    }

    SOSErrorCreate(1032LL, a3, 0LL, @"Can't remove without being active peer");
LABEL_14:
    uint64_t v16 = 0LL;
    goto LABEL_15;
  }

  MutableForSOSPeerInfosByIDWithArray = (const __CFSet *)CFSetCreateMutableForSOSPeerInfosByIDWithArray( kCFAllocatorDefault,  a2);
  if (MutableForSOSPeerInfosByIDWithArray)
  {
    CFTypeRef v12 = MutableForSOSPeerInfosByIDWithArray;
    BOOL v13 = CFSetContainsValue(MutableForSOSPeerInfosByIDWithArray, v10) != 0;
    CFSetRemoveValue(v12, v10);
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v5 trust]);
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "circle_transport"));
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472LL;
    void v24[2] = sub_100191FDC;
    v24[3] = &unk_100291808;
    unsigned __int8 v26 = v12;
    id v27 = v7;
    id v28 = v8;
    uint64_t v29 = a3;
    id v25 = v5;
    BOOL v30 = v13;
    uint64_t v16 = (uint64_t)[v14 modifyCircle:v15 err:a3 action:v24];

    if ((_DWORD)v16) {
      sub_1000130AC(v12, (uint64_t)&stru_100291828);
    }
    CFRelease(v12);
  }

  else
  {
    CFTypeRef v22 = sub_10001267C("circleOps");
    int v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "No peerSet to remove", buf, 2u);
    }

    uint64_t v16 = 1LL;
  }

uint64_t sub_100191FDC(uint64_t a1, uint64_t a2)
{
  if (!CFSetGetCount(*(CFSetRef *)(a1 + 40))
    || (uint64_t result = SOSCircleRemovePeers( a2,  *(void *)(a1 + 48),  *(void *)(a1 + 56),  *(void *)(a1 + 40),  *(void *)(a1 + 64)),  (_DWORD)result)
    && (uint64_t result = sub_10019969C(*(void **)(a1 + 32), *(void *)(a1 + 64)), (_DWORD)result))
  {
    if (*(_BYTE *)(a1 + 72))
    {
      id v5 = sub_10001267C("circleOps");
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id v7 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Leaving circle by client request (SOSAccountRemovePeersFromCircle)",  v7,  2u);
      }

      return sub_100191060(*(void **)(a1 + 32), a2, *(CFTypeRef **)(a1 + 64));
    }

    else
    {
      return 1LL;
    }
  }

  return result;
}

void sub_1001920A8(id a1, __CFString *a2)
{
  id v3 = sub_10001267C("circleOps");
  uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 138412290;
    id v6 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Removed Peers from circle %@",  (uint8_t *)&v5,  0xCu);
  }
}

void sub_100192150(id a1, __CFString *a2)
{
  id v3 = sub_10001267C("circleOps");
  uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 138412290;
    id v6 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Attempting to remove peer set %@",  (uint8_t *)&v5,  0xCu);
  }
}

void sub_1001921F8(uint64_t a1)
{
  OSStatus v2 = *(void **)(a1 + 32);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "circle_transport"));
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_100192290;
  void v7[3] = &unk_100292EF0;
  uint64_t v4 = *(void *)(a1 + 48);
  id v5 = *(id *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 48);
  id v8 = v5;
  uint64_t v9 = v6;
  [v2 modifyCircle:v3 err:v4 action:v7];
}

BOOL sub_100192290(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10001267C("circleOps");
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v7 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Leaving circle by client request (Bail)",  v7,  2u);
  }

  return sub_100191060(*(void **)(a1 + 32), a2, *(CFTypeRef **)(a1 + 40));
}

uint64_t sub_100192318(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = SOSCircleAcceptRequest(a2, a1[5], a3, a4, a1[6]);
  if ((_DWORD)result) {
    ++*(void *)(*(void *)(a1[4] + 8LL) + 24LL);
  }
  return result;
}

void sub_10019235C(void *a1, uint64_t a2, void *a3)
{
  id v5 = a1;
  id v6 = a3;
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v5 trust]);
  id v8 = [v7 peerInfo];
  CFTypeRef cf = 0LL;
  if ([v7 trustedCircle] && v8)
  {
    if (SOSCircleHasPeer([v7 trustedCircle], v8, &cf))
    {
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v5 trust]);
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "circle_transport"));
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472LL;
      v13[2] = sub_10019251C;
      v13[3] = &unk_100291BB0;
      uint64_t v16 = a2;
      id v15 = v6;
      id v14 = v7;
      [v9 modifyCircle:v10 err:0 action:v13];
    }

    if (cf)
    {
      CFTypeRef v11 = sub_10001267C("SecError");
      CFTypeRef v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFTypeRef v19 = cf;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Got error in SOSCircleHasPeer: %@",  buf,  0xCu);
      }

      if (cf) {
        CFRelease(cf);
      }
    }
  }
}

uint64_t sub_10019251C(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = 0LL;
  BOOL v13 = &v12;
  uint64_t v14 = 0x2020000000LL;
  char v15 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_100192620;
  void v7[3] = &unk_100291B88;
  uint64_t v11 = a2;
  id v3 = *(const __CFArray **)(a1 + 48);
  id v9 = *(id *)(a1 + 40);
  id v8 = *(id *)(a1 + 32);
  uint64_t v10 = &v12;
  uint64_t v4 = v7;
  v16.size_t length = CFArrayGetCount(v3);
  v16.id location = 0LL;
  CFArrayApplyFunction(v3, v16, (CFArrayApplierFunction)sub_10018D314, v4);

  uint64_t v5 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);
  return v5;
}

void sub_100192608( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_100192620(uint64_t result, CFTypeRef cf)
{
  if (cf)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID(cf);
    uint64_t result = SOSPeerInfoGetTypeID();
    if (v4 == result)
    {
      uint64_t result = SOSCircleHasApplicant(*(void *)(v3 + 56), cf, 0LL);
      if ((_DWORD)result)
      {
        uint64_t result = (*(uint64_t (**)(void, void, id, CFTypeRef))(*(void *)(v3 + 40) + 16))( *(void *)(v3 + 40),  *(void *)(v3 + 56),  [*(id *)(v3 + 32) fullPeerInfo],  cf);
        if ((_DWORD)result) {
          *(_BYTE *)(*(void *)(*(void *)(v3 + 48) + 8LL) + 24LL) = 1;
        }
      }
    }
  }

  return result;
}

uint64_t sub_1001926B0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = SOSCircleRejectRequest(a2, a3, a4, a1[6]);
  if ((v6 & 1) != 0)
  {
    uint64_t v7 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
    uint64_t v8 = (int)SOSCircleCountPeers(a2);
    if (v7 > v8) {
      uint64_t v8 = v7;
    }
    *(void *)(*(void *)(a1[5] + 8LL) + 24LL) = v8;
  }

  else
  {
    *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = 0;
  }

  return v6;
}

void sub_100192738(void *a1)
{
  id v1 = a1;
  OSStatus v2 = (void *)objc_claimAutoreleasedReturnValue([v1 trust]);
  uint64_t v3 = sub_10001267C("updates");
  CFTypeID v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Ensuring peer registration.", buf, 2u);
  }

  if (!v2)
  {
    BOOL v13 = sub_10001267C("updates");
    uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Failed to get trust object in Ensuring peer registration.",  buf,  2u);
    }

    goto LABEL_11;
  }

  if (![v1 getCircleStatus:0])
  {
    uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue([v1 trust]);
    id v6 = -[os_log_s fullPeerInfo](v5, "fullPeerInfo");
    id v7 = -[os_log_s trustedCircle](v5, "trustedCircle");
    uint64_t PeerInfo = SOSFullPeerInfoGetPeerInfo(v6);
    if (!PeerInfo)
    {
LABEL_11:

      goto LABEL_12;
    }

    int HasActivePeer = SOSCircleHasActivePeer(v7, PeerInfo, 0LL);

    if (HasActivePeer && [v1 SOSMonitorModeSOSIsActive])
    {
      uint64_t PeerID = SOSPeerInfoGetPeerID([v2 peerInfo]);
      id v11 = [v2 trustedCircle];
      id v12 = [v1 accountKey];
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 3221225472LL;
      v14[2] = sub_100192910;
      v14[3] = &unk_1002917C0;
      uint64_t v17 = PeerID;
      char v15 = (os_log_s *)v1;
      id v16 = v2;
      SOSCircleForEachValidSyncingPeer(v11, v12, v14);

      uint64_t v5 = v15;
      goto LABEL_11;
    }
  }

void sub_100192910(uint64_t a1, uint64_t a2)
{
  if ((SOSPeerInfoPeerIDEqual(a2, *(void *)(a1 + 48)) & 1) == 0)
  {
    CFTypeRef cf = 0LL;
    CFTypeID v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "kvs_message_transport"));
    id v5 = [v4 SOSTransportMessageGetEngine];
    id v6 = [*(id *)(a1 + 40) fullPeerInfo];
    if (-[OTSOSActualAdapter sosEnabled]_0((uint64_t)v6, v7))
    {
      uint64_t v16 = 0LL;
      uint64_t v17 = &v16;
      uint64_t v18 = 0x2020000000LL;
      char v19 = 1;
      uint64_t PeerID = SOSPeerInfoGetPeerID(a2);
      *(void *)__int128 buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3221225472LL;
      *(void *)&uint8_t buf[16] = sub_1000CC948;
      CFTypeRef v21 = &unk_100285718;
      CFTypeRef v22 = &v16;
      id v23 = v5;
      uint64_t v24 = PeerID;
      id v25 = v6;
      uint64_t v26 = a2;
      p_CFTypeRef cf = &cf;
      char v9 = sub_1000CCE88((uint64_t)v5, PeerID, (uint64_t)&cf, buf);
      char v10 = *((_BYTE *)v17 + 24) ? v9 : 0;
      *((_BYTE *)v17 + 24) = v10;
      _Block_object_dispose(&v16, 8);
    }

    else
    {
      SOSCCSetSOSDisabledError(&cf);
    }

    if (cf)
    {
      id v11 = sub_10001267C("updates");
      id v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        id v13 = [*(id *)(a1 + 40) fullPeerInfo];
        *(_DWORD *)__int128 buf = 138412802;
        *(void *)&uint8_t buf[4] = a2;
        *(_WORD *)&_BYTE buf[12] = 2112;
        *(void *)&buf[14] = v13;
        *(_WORD *)&buf[22] = 2112;
        CFTypeRef v21 = cf;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "can't initialize transport for peer %@ with %@ (%@)",  buf,  0x20u);
      }

      CFTypeRef v14 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
        CFRelease(v14);
      }
    }
  }

void sub_100192AE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
}

uint64_t sub_100192B08(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    id v5 = sub_10001267C("SecError");
    id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      uint64_t v9 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "SOSCloudKeychainPutObjectsInCloud returned error: %@",  (uint8_t *)&v8,  0xCu);
    }
  }

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_100192BC8(void *a1, uint64_t *a2)
{
  id v50 = a1;
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(-2LL, 0LL);
  id v4 = (id)objc_claimAutoreleasedReturnValue(global_queue);
  id v55 = 0LL;
  uint64_t v56 = (uint64_t)&v55;
  uint64_t v57 = 0x2020000000LL;
  __int16 v58 = 0LL;
  dispatch_semaphore_t v5 = dispatch_semaphore_create(0LL);
  dispatch_time_t v6 = dispatch_time(0LL, 30000000000LL);
  uint64_t v51 = 0LL;
  id v52 = &v51;
  uint64_t v53 = 0x2020000000LL;
  uint64_t v54 = 0LL;
  *(void *)__int128 context = _NSConcreteStackBlock;
  *(void *)&context[8] = 3221225472LL;
  *(void *)&context[16] = sub_10019330C;
  __int128 v61 = &unk_100291BD8;
  __int128 v63 = &v51;
  id v64 = &v55;
  uint64_t v7 = v5;
  id v62 = v7;
  int v8 = objc_retainBlock(context);
  SOSCloudKeychainGetAllObjectsFromCloud(v4, v8);
  dispatch_semaphore_wait(v7, v6);
  uint64_t v9 = v52;
  char v10 = (const void *)v52[3];
  if (v10)
  {
    if (!a2 || (CFRetain((CFTypeRef)v52[3]), *a2 = (uint64_t)v10, uint64_t v9 = v52, (v10 = (const void *)v52[3]) != 0LL))
    {
      v9[3] = 0LL;
      CFRelease(v10);
    }
  }

  id v11 = *(const __CFDictionary **)(v56 + 24);

  _Block_object_dispose(&v51, 8);
  _Block_object_dispose(&v55, 8);

  if (v11)
  {
    id v12 = v50;
    CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
    CFTypeRef v14 = (void *)objc_claimAutoreleasedReturnValue([v12 trust]);
    id v15 = [v14 trustedCircle];
    id v16 = sub_100199E38(v12, 0LL);

    *(void *)__int128 context = _NSConcreteStackBlock;
    *(void *)&context[8] = 3221225472LL;
    *(void *)&context[16] = sub_100193444;
    __int128 v61 = &unk_100292840;
    id v62 = Mutable;
    SOSCircleForEachActiveValidPeer(v15, v16, context);

    id v17 = v12;
    CFMutableSetRef v18 = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
    char v19 = (void *)objc_claimAutoreleasedReturnValue([v17 trust]);

    id v20 = [v19 trustedCircle];
    *(void *)__int128 context = _NSConcreteStackBlock;
    *(void *)&context[8] = 3221225472LL;
    *(void *)&context[16] = sub_100193470;
    __int128 v61 = &unk_100292840;
    id v62 = v18;
    SOSCircleForEachRetiredPeer(v20, context);

    CFTypeRef v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
    CFTypeRef v22 = v21;
    if (Mutable && v18)
    {
      *(void *)__int128 context = _NSConcreteStackBlock;
      *(void *)&context[8] = 3221225472LL;
      *(void *)&context[16] = sub_100193624;
      __int128 v61 = &unk_100291918;
      __int128 v63 = v18;
      id v64 = (void ***)Mutable;
      id v62 = v21;
      CFDictionaryApplyFunction(v11, (CFDictionaryApplierFunction)sub_100193768, context);
    }

    else if (!Mutable)
    {
LABEL_16:
      if (v18) {
        CFRelease(v18);
      }
      id v28 = sub_10001267C("key-cleanup");
      uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        CFIndex Count = CFDictionaryGetCount(v11);
        id v31 = [v22 count];
        *(_DWORD *)__int128 context = 134218240;
        *(void *)&context[4] = Count;
        *(_WORD *)&context[12] = 2048;
        *(void *)&context[14] = v31;
        _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "total keys: %lu, cleaning up %lu",  context,  0x16u);
      }

      uint64_t v32 = sub_10001267C("key-cleanup");
      int v33 = (os_log_s *)objc_claimAutoreleasedReturnValue(v32);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 context = 138412290;
        *(void *)&context[4] = v22;
        _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "message keys that we should remove! %@",  context,  0xCu);
      }

      id v26 = v22;
      id v34 = v4;
      CFStringRef v35 = sub_1001A9474(v17);
      dispatch_semaphore_t v36 = dispatch_semaphore_create(0LL);
      dispatch_time_t v37 = dispatch_time(0LL, 30000000000LL);
      *(void *)__int128 context = _NSConcreteStackBlock;
      *(void *)&context[8] = 3221225472LL;
      *(void *)&context[16] = sub_10019349C;
      __int128 v61 = &unk_100292D28;
      unsigned __int8 v38 = v36;
      id v62 = v38;
      id v39 = objc_retainBlock(context);
      SOSCloudKeychainRemoveKeys(v26, v35, v34, v39);

      dispatch_semaphore_wait(v38, v37);
      if (v35) {
        CFRelease(v35);
      }

      id v40 = v17;
      uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
      id v42 = (void *)objc_claimAutoreleasedReturnValue([v40 settings]);

      [v42 setObject:v41 forKey:@"lastKVSCleanup"];
      uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
      Mutableuint64_t Copy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0LL, @"[");
      double Current = CFAbsoluteTimeGetCurrent();
      *(void *)__int128 context = _NSConcreteStackBlock;
      *(void *)&context[8] = 3221225472LL;
      *(void *)&context[16] = sub_10019355C;
      __int128 v61 = &unk_1002931B8;
      id v62 = MutableCopy;
      sub_100013840((uint64_t)context, Current);
      CFStringAppend(MutableCopy, @"]");
      [v43 setObject:MutableCopy forKey:kSOSKVSLastCleanupTimestampKey];
      if (MutableCopy) {
        CFRelease(MutableCopy);
      }
      dispatch_semaphore_t v46 = dispatch_semaphore_create(0LL);
      dispatch_time_t v47 = dispatch_time(0LL, 30000000000LL);
      id v55 = _NSConcreteStackBlock;
      uint64_t v56 = 3221225472LL;
      uint64_t v57 = (uint64_t)sub_100193564;
      __int16 v58 = &unk_100292D28;
      dispatch_semaphore_t v59 = v46;
      char v48 = v46;
      id v49 = objc_retainBlock(&v55);
      SOSCloudKeychainPutObjectsInCloud(v43, v34, v49);
      dispatch_semaphore_wait(v48, v47);

      CFRelease(v11);
LABEL_27:

      goto LABEL_28;
    }

    CFRelease(Mutable);
    goto LABEL_16;
  }

  id v23 = sub_10001267C("key-cleanup");
  uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 context = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "KVS data returned is nil, cleanup complete",  context,  2u);
  }

  if (a2)
  {
    id v25 = sub_10001267C("SecError");
    id v26 = (id)objc_claimAutoreleasedReturnValue(v25);
    if (os_log_type_enabled((os_log_t)v26, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = *a2;
      *(_DWORD *)__int128 context = 138412290;
      *(void *)&context[4] = v27;
      _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)v26,  OS_LOG_TYPE_DEFAULT,  "key-cleanup: SOSAccountCopyObjectsFromCloud hit an error: %@",  context,  0xCu);
    }

    goto LABEL_27;
  }

void sub_1001932D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10019330C(uint64_t a1, CFTypeRef cf, const void *a3)
{
  if (a3)
  {
    uint64_t v6 = sub_10001267C("SecError");
    uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 138412290;
      id v13 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "SOSCloudKeychainGetObjectsFromCloud returned error: %@",  (uint8_t *)&v12,  0xCu);
    }

    CFRetain(a3);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a3;
  }

  if (!cf) {
    goto LABEL_8;
  }
  CFTypeID v8 = CFGetTypeID(cf);
  if (v8 == CFNullGetTypeID())
  {
    CFRelease(cf);
LABEL_8:
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 0LL;
    return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
  }

  uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8LL);
  if (*(CFTypeRef *)(v9 + 24) != cf)
  {
    CFRetain(cf);
    char v10 = *(const void **)(v9 + 24);
    if (v10) {
      CFRelease(v10);
    }
    *(void *)(v9 + 24) = cf;
  }

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_100193444(uint64_t a1, uint64_t a2)
{
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(a2);
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 32), PeerID);
}

void sub_100193470(uint64_t a1, uint64_t a2)
{
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(a2);
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 32), PeerID);
}

uint64_t sub_10019349C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v5 = sub_10001267C("SecError");
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      uint64_t v9 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "SOSCloudKeychainRemoveKeys returned error: %@",  (uint8_t *)&v8,  0xCu);
    }
  }

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_10019355C(uint64_t a1, const __CFString *a2)
{
}

uint64_t sub_100193564(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v5 = sub_10001267C("SecError");
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      uint64_t v9 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "SOSCloudKeychainPutObjectsInCloud returned error: %@",  (uint8_t *)&v8,  0xCu);
    }
  }

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_100193624(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      uint64_t KeyType = SOSKVSKeyGetKeyType(cf);
      if ((_DWORD)KeyType == 1)
      {
        CFTypeRef cfa = 0LL;
        value = 0LL;
        SOSKVSKeyParse(KeyType, cf, 0LL, 0LL, 0LL, 0LL, &value, &cfa);
        if (!value
          || !CFSetContainsValue(*(CFSetRef *)(a1 + 48), value)
          || !cfa
          || !CFSetContainsValue(*(CFSetRef *)(a1 + 48), cfa))
        {
          [*(id *)(a1 + 32) addObject:cf];
        }

        uint64_t v7 = value;
        if (value)
        {
          value = 0LL;
          CFRelease(v7);
        }

        uint64_t v6 = cfa;
        if (cfa)
        {
          CFTypeRef cfa = 0LL;
          goto LABEL_21;
        }
      }

      else if ((_DWORD)KeyType == 4)
      {
        value = 0LL;
        SOSKVSKeyParse(KeyType, cf, 0LL, 0LL, 0LL, 0LL, &value, 0LL);
        if (!value
          || !CFSetContainsValue(*(CFSetRef *)(a1 + 40), value)
          && (!value || !CFSetContainsValue(*(CFSetRef *)(a1 + 48), value)))
        {
          [*(id *)(a1 + 32) addObject:cf];
        }

        uint64_t v6 = value;
        if (value)
        {
          value = 0LL;
LABEL_21:
          CFRelease(v6);
        }
      }
    }
  }

uint64_t sub_100193768(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_100193780(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  id v6 = a2;
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(+[CKKSViewManager manager](&OBJC_CLASS___CKKSViewManager, "manager"));
  id v44 = 0LL;
  int v8 = (void *)objc_claimAutoreleasedReturnValue([v7 currentTLKsFilteredByPolicy:a3 error:&v44]);
  id v9 = v44;

  if (v9)
  {
    char v10 = sub_10001267C("piggy");
    id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      id v57 = v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "unable to fetch TLKs: %@", buf, 0xCu);
    }
  }

  else
  {
    id v34 = 0LL;
    id v37 = v5;
    id v40 = v5;
    CFStringRef v35 = v8;
    id v12 = v8;
    id v36 = v6;
    id v39 = v6;
    __int128 v46 = 0u;
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v49 = 0u;
    id obj = v12;
    id v13 = [v12 countByEnumeratingWithState:&v46 objects:buf count:16];
    if (v13)
    {
      id v14 = v13;
      uint64_t v15 = *(void *)v47;
      id v16 = "piggy";
      uint64_t v38 = *(void *)v47;
      do
      {
        id v17 = 0LL;
        id v41 = v14;
        do
        {
          if (*(void *)v47 != v15) {
            objc_enumerationMutation(obj);
          }
          CFMutableSetRef v18 = *(void **)(*((void *)&v46 + 1) + 8LL * (void)v17);
          id v45 = 0LL;
          char v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "ensureKeyLoadedFromKeychain:", &v45, v34));
          id v20 = v45;
          CFTypeRef v21 = v20;
          if (v19) {
            BOOL v22 = v20 == 0LL;
          }
          else {
            BOOL v22 = 0;
          }
          if (v22)
          {
            id v43 = v20;
            v50[0] = kSecValueData;
            id v25 = (void *)objc_claimAutoreleasedReturnValue([v19 keyMaterial]);
            v51[0] = v25;
            v50[1] = kSecAttrServer;
            id v26 = (void *)objc_claimAutoreleasedReturnValue([v18 zoneID]);
            uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v26 zoneName]);
            v51[1] = v27;
            v50[2] = kSecAttrAccount;
            id v28 = v16;
            uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v18 uuid]);
            v51[2] = v29;
            BOOL v30 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v51,  v50,  3LL));
            id v24 = [v30 mutableCopy];

            id v16 = v28;
            [v24 setObject:&__kCFBooleanTrue forKeyedSubscript:@"auth"];
            id v31 = sub_10001267C(v28);
            uint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v31);
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)id v52 = 138412290;
              uint64_t v53 = v18;
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "sending TLK %@", v52, 0xCu);
            }

            [v40 addObject:v24];
            int v33 = (void *)objc_claimAutoreleasedReturnValue([v18 uuid]);
            [v39 addObject:v33];

            uint64_t v15 = v38;
            id v14 = v41;
            CFTypeRef v21 = v43;
          }

          else
          {
            id v23 = sub_10001267C(v16);
            id v24 = (id)objc_claimAutoreleasedReturnValue(v23);
            if (os_log_type_enabled((os_log_t)v24, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)id v52 = 138412546;
              uint64_t v53 = v18;
              __int16 v54 = 2112;
              id v55 = v21;
              _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)v24,  OS_LOG_TYPE_DEFAULT,  "Failed to load TLK %@: %@",  v52,  0x16u);
            }
          }

          id v17 = (char *)v17 + 1;
        }

        while (v14 != v17);
        id v14 = [obj countByEnumeratingWithState:&v46 objects:buf count:16];
      }

      while (v14);
    }

    id v6 = v36;
    id v5 = v37;
    id v9 = v34;
    int v8 = v35;
  }
}

void sub_100193BBC(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  v8[2] = sub_100193C64;
  v8[3] = &unk_100291C00;
  char v11 = 0;
  id v9 = a3;
  id v10 = v5;
  id v6 = v5;
  id v7 = v9;
  [a2 enumerateObjectsUsingBlock:v8];
}

void sub_100193C64(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFTypeID v4 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:kSecAttrPath]);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:kSecAttrAccount]);
  uint64_t v6 = objc_claimAutoreleasedReturnValue([v3 objectForKey:kSecAttrServer]);
  id v7 = (void *)v6;
  if (v4) {
    BOOL v8 = v5 == 0LL;
  }
  else {
    BOOL v8 = 1;
  }
  BOOL v9 = v8 || v6 == 0;
  if (!v9
    && (([v4 isEqualToString:v5] & 1) != 0 || *(_BYTE *)(a1 + 48))
    && ([*(id *)(a1 + 32) containsObject:v5] & 1) == 0)
  {
    id v10 = (void *)objc_claimAutoreleasedReturnValue([v3 objectForKey:kSecValueData]);
    char v11 = -[NSData initWithBase64EncodedData:options:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBase64EncodedData:options:",  v10,  0LL);
    if (v11)
    {
      id v12 = v11;
      id v17 = v10;
      id v13 = sub_10001267C("piggy");
      id v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412546;
        CFTypeRef v21 = v7;
        __int16 v22 = 2112;
        id v23 = v5;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "fetched TLK %@ with name %@", buf, 0x16u);
      }

      v18[0] = kSecValueData;
      v18[1] = kSecAttrServer;
      v19[0] = v12;
      v19[1] = v7;
      v18[2] = kSecAttrAccount;
      v19[2] = v5;
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v19,  v18,  3LL));
      id v16 = [v15 mutableCopy];

      if (*(_BYTE *)(a1 + 48)) {
        [v16 setObject:&__kCFBooleanTrue forKeyedSubscript:@"auth"];
      }
      [*(id *)(a1 + 40) addObject:v16];
      [*(id *)(a1 + 32) addObject:v5];
    }

    else
    {
    }
  }
}

int64_t sub_100193EB0(id a1, NSDictionary *a2, NSDictionary *a3)
{
  CFTypeID v4 = a3;
  id v5 = a2;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", kSecAttrServer));
  unsigned int v7 = sub_100193FA4(v6);

  BOOL v8 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", @"auth"));
  if (v8) {
    v7 |= 0x3E8u;
  }
  BOOL v9 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v4, "objectForKeyedSubscript:", kSecAttrServer));
  unsigned int v10 = sub_100193FA4(v9);

  char v11 = (void *)objc_claimAutoreleasedReturnValue(-[NSDictionary objectForKeyedSubscript:](v4, "objectForKeyedSubscript:", @"auth"));
  unsigned int v12 = v10 | 0x3E8;
  if (!v11) {
    unsigned int v12 = v10;
  }
  BOOL v13 = v7 > v12;
  int64_t v14 = v7 < v12;
  if (v13) {
    return -1LL;
  }
  else {
    return v14;
  }
}

uint64_t sub_100193FA4(void *a1)
{
  id v1 = a1;
  if ([v1 isEqualToString:@"Manatee"])
  {
    uint64_t v2 = 5LL;
  }

  else if ([v1 isEqualToString:@"Engram"])
  {
    uint64_t v2 = 4LL;
  }

  else if ([v1 isEqualToString:@"AutoUnlock"])
  {
    uint64_t v2 = 3LL;
  }

  else if ([v1 isEqualToString:@"Health"])
  {
    uint64_t v2 = 2LL;
  }

  else
  {
    uint64_t v2 = 0LL;
  }

  return v2;
}

uint64_t sub_100194038(void *a1)
{
  id v1 = a1;
  if ([v1 isEqualToString:@"Manatee"])
  {
    uint64_t v2 = 1LL;
  }

  else if ([v1 isEqualToString:@"Engram"])
  {
    uint64_t v2 = 2LL;
  }

  else if ([v1 isEqualToString:@"AutoUnlock"])
  {
    uint64_t v2 = 3LL;
  }

  else if ([v1 isEqualToString:@"Health"])
  {
    uint64_t v2 = 4LL;
  }

  else
  {
    uint64_t v2 = 0LL;
  }

  return v2;
}

uint64_t sub_1001940CC(void *a1, uint64_t a2, uint64_t a3)
{
  id v5 = a1;
  id v6 = [v5 length];
  id v7 = [v5 length];
  id v8 = v5;
  id v9 = [v8 bytes];

  uint64_t v10 = ccder_encode_body(v7, v9, a2, a3);
  return ccder_encode_tl(4LL, v6, a2, v10);
}

uint64_t sub_100194154(void *a1, uint64_t a2, uint64_t a3)
{
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  id v5 = a1;
  id v6 = [v5 countByEnumeratingWithState:&v14 objects:v18 count:16];
  uint64_t v7 = a3;
  if (v6)
  {
    id v8 = v6;
    uint64_t v9 = *(void *)v15;
    uint64_t v7 = a3;
    while (2)
    {
      uint64_t v10 = 0LL;
      do
      {
        if (*(void *)v15 != v9) {
          objc_enumerationMutation(v5);
        }
        uint64_t v11 = ccder_encode_body( objc_msgSend(*(id *)(*((void *)&v14 + 1) + 8 * (void)v10), "length", (void)v14), objc_msgSend(*(id *)(*((void *)&v14 + 1) + 8 * (void)v10), "bytes"), a2, v7);
        if (!v11)
        {

          uint64_t v12 = 0LL;
          goto LABEL_11;
        }

        uint64_t v7 = v11;
        uint64_t v10 = (char *)v10 + 1;
      }

      while (v8 != v10);
      id v8 = [v5 countByEnumeratingWithState:&v14 objects:v18 count:16];
      if (v8) {
        continue;
      }
      break;
    }
  }

  uint64_t v12 = ccder_encode_constructed_tl(0x2000000000000010LL, a3, a2, v7);
LABEL_11:

  return v12;
}

void sub_1001942BC(uint64_t a1, const void *a2)
{
}

void sub_1001942FC(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = sub_10001267C("accountLogState");
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_BYTE *)(a1 + 32)) {
      int v6 = 73;
    }
    else {
      int v6 = 105;
    }
    BOOL v7 = *(_BYTE *)(a1 + 33) == 0;
    v9[0] = 67109634;
    if (v7) {
      int v8 = 98;
    }
    else {
      int v8 = 66;
    }
    v9[1] = v6;
    __int16 v10 = 1024;
    int v11 = v8;
    __int16 v12 = 2112;
    uint64_t v13 = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Sync: %c%c PeerViews: %@", (uint8_t *)v9, 0x18u);
  }
}

void sub_1001943F0(id a1, __CFString *a2)
{
  id v3 = sub_10001267C("accountLogState");
  CFTypeID v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 138412290;
    int v6 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "outstanding views: %@", (uint8_t *)&v5, 0xCu);
  }
}

void sub_100194498(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int IsSessionInAwaitingState = SecOTRSessionIsSessionInAwaitingState(*(void *)(a3 + 24));
  BOOL v7 = sub_10001267C("otrtimer");
  int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (IsSessionInAwaitingState)
  {
    if (v9)
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "coder is in awaiting state, restarting coder",  buf,  2u);
    }

    id v57 = 0LL;
    sub_1001A9D20(a3);
    if (sub_1001A9A98(a3, &v57) == 3)
    {
      __int16 v10 = sub_10001267C("SecError");
      int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFTypeRef v60 = v57;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Attempt to recover coder failed to restart: %@",  buf,  0xCu);
      }
    }

    else
    {
      __int16 v12 = sub_10001267C("otrtimer");
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "coder restarted!", buf, 2u);
      }

      uint64_t v14 = *(void *)(a1 + 40);
      if (-[OTSOSActualAdapter sosEnabled]_0(v15, v16)) {
        *(_BYTE *)(v14 + 105) = 1;
      }
      *(_BYTE *)(a2 + 4_Block_object_dispose(va, 8) = 1;
      sub_1001CE868(*(void *)(a2 + 16), v17, v18, v19, v20, v21, v22, v23);
    }

    id v24 = *(void **)(a1 + 32);
    id v25 = *(id *)(a2 + 16);
    id v26 = v24;
    id v27 = sub_10018DFDC(v26, (uint64_t)@"NegotiationRetryCount");
    id v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
    if (!v28) {
      id v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
    }
    uint64_t v29 = (NSNumber *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "objectForKey:", v25, v57));
    BOOL v30 = objc_alloc(&OBJC_CLASS___NSNumber);
    if (v29)
    {
      id v31 = -[NSNumber initWithInt:](v30, "initWithInt:", -[NSNumber intValue](v29, "intValue") + 1);
      [v28 setObject:v31 forKey:v25];
      uint64_t v32 = sub_10001267C("otr");
      int v33 = (os_log_s *)objc_claimAutoreleasedReturnValue(v32);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v34 = -[NSNumber intValue](v31, "intValue");
        *(_DWORD *)__int128 buf = 67109120;
        LODWORD(v60) = v34;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "OTR negotiation retry count: %d", buf, 8u);
      }
    }

    else
    {
      uint64_t v29 = -[NSNumber initWithInt:](v30, "initWithInt:", 1LL);
      [v28 setObject:v29 forKey:v25];
    }

    sub_1001A93D0(v26, (uint64_t)@"NegotiationRetryCount", (uint64_t)v28, 0LL);

    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a2 + 104), *(const void **)(a2 + 16));
    CFStringRef v35 = *(void **)(a2 + 16);
    id v36 = *(id *)(a1 + 32);
    id v37 = v35;
    CFTypeRef cf = 0LL;
    uint64_t v38 = (__CFDictionary *)sub_10018DFDC(v36, (uint64_t)@"PeerNegotiationTimeouts");
    if (!v38 || (id v39 = v38, v40 = CFGetTypeID(v38), v40 != CFDictionaryGetTypeID()))
    {
      __int128 v46 = sub_10001267C("otrtimer");
      id v42 = (os_log_s *)objc_claimAutoreleasedReturnValue(v46);
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_33;
      }
      *(_WORD *)__int128 buf = 0;
      id v43 = "timeout dictionary doesn't exist";
      id v44 = v42;
      uint32_t v45 = 2;
      goto LABEL_32;
    }

    if (CFDictionaryGetValue(v39, v37))
    {
      CFDictionaryRemoveValue(v39, v37);
      sub_1001A93D0(v36, (uint64_t)@"PeerNegotiationTimeouts", (uint64_t)v39, &cf);
      if (!cf)
      {
LABEL_35:

        __int128 v48 = *(void **)(a1 + 32);
        __int128 v49 = *(void **)(a2 + 16);
        id v50 = v48;
        id v51 = v49;
        id v52 = sub_10018DFDC(v50, (uint64_t)@"kSOSAccountPeerLastSentTimestamp");
        uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(v52);
        __int16 v54 = v53;
        if (v53)
        {
          id v55 = (void *)objc_claimAutoreleasedReturnValue([v53 objectForKey:v51]);
          if (v55)
          {
            [v54 removeObjectForKey:v51];
            sub_1001A93D0(v50, (uint64_t)@"kSOSAccountPeerLastSentTimestamp", (uint64_t)v54, 0LL);
          }
        }

        return;
      }

      id v41 = sub_10001267C("otrtimer");
      id v42 = (os_log_s *)objc_claimAutoreleasedReturnValue(v41);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFTypeRef v60 = cf;
        id v43 = "SOSAccountSetValue threw an error for key kSOSAccountPeerNegotiationTimeouts: %@";
LABEL_29:
        id v44 = v42;
        uint32_t v45 = 12;
LABEL_32:
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, v43, buf, v45);
      }
    }

    else
    {
      uint64_t v56 = sub_10001267C("otrtimer");
      id v42 = (os_log_s *)objc_claimAutoreleasedReturnValue(v56);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFTypeRef v60 = v37;
        id v43 = "timeout for peerid: %@, doesn't exist";
        goto LABEL_29;
      }
    }

void sub_1001949DC(uint64_t a1, uint64_t a2)
{
  id v4 = *(id *)(a2 + 16);
  id v5 = *(id *)(a2 + 96);
  uint64_t v20 = 0LL;
  int v6 = (void *)objc_claimAutoreleasedReturnValue([v5 accessGroupToNextMessageToSend]);
  BOOL v7 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKey:*(void *)(a1 + 32)]);

  if (v7)
  {
    int v8 = sub_10001267C("ratelimit");
    BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412546;
      uint64_t v22 = v7;
      __int16 v23 = 2112;
      id v24 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "SOSPeerRateLimiter timer went off! sending:%@ \n to peer:%@",  buf,  0x16u);
    }

    __int16 v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), "kvs_message_transport"));
    int v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), "kvs_message_transport"));
    unsigned int v12 = [v10 SOSTransportMessageSendMessage:v11 id:v4 messageToSend:v7 err:&v20];

    if (v12) {
      BOOL v13 = v20 == 0LL;
    }
    else {
      BOOL v13 = 0;
    }
    if (!v13)
    {
      uint64_t v14 = sub_10001267C("ratelimit");
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v22 = v20;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "could not send message: %@", buf, 0xCu);
      }
    }
  }

  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v5 accessGroupRateLimitState]);
  uint64_t v17 = -[NSNumber initWithLong:](objc_alloc(&OBJC_CLASS___NSNumber), "initWithLong:", 1LL);
  [v16 setObject:v17 forKey:*(void *)(a1 + 32)];

  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v5 accessGroupToTimer]);
  [v18 removeObjectForKey:*(void *)(a1 + 32)];

  uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v5 accessGroupToNextMessageToSend]);
  [v19 removeObjectForKey:*(void *)(a1 + 32)];
}

CFDictionaryRef sub_100194C30(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return sub_100107FA8( kCFAllocatorDefault,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t)kSecClass,  (uint64_t)kSecClassGenericPassword);
}

uint64_t sub_100194CF8(void *a1, uint64_t a2, const void **a3, void *a4)
{
  id v7 = a1;
  id v8 = a4;
  CFStringRef v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%@-tomb", a2);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  v13[2] = sub_100194DDC;
  v13[3] = &unk_100292890;
  id v10 = v7;
  id v14 = v10;
  uint64_t v11 = sub_10019D758(v10, (uint64_t)v9, a3, v13, v8);

  if (v9) {
    CFRelease(v9);
  }

  return v11;
}

uint64_t sub_100194DDC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) peerID]);
  uint64_t v6 = sub_1001ABB38(a2, (uint64_t)v5, 1u, a3);

  return v6;
}

uint64_t sub_100194E34(void *a1, uint64_t a2)
{
  id v3 = a1;
  uint64_t MutableForSOSPeerInfosByID = CFSetCreateMutableForSOSPeerInfosByID(kCFAllocatorDefault);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v3 trust]);
  id v6 = [v5 getCircle:0];

  if (v6)
  {
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472LL;
    v8[2] = sub_100194EF8;
    v8[3] = &unk_100292FD0;
    void v8[4] = a2;
    void v8[5] = MutableForSOSPeerInfosByID;
    SOSCircleForEachValidPeer(v6, [v3 accountKey], v8);
  }

  return MutableForSOSPeerInfosByID;
}

void sub_100194EF8(uint64_t a1, const void *a2)
{
}

uint64_t sub_100194F3C(uint64_t a1, CFTypeRef cf2)
{
  if (cf2 && kSOSViewKeychainV0)
  {
    if (CFEqual(kSOSViewKeychainV0, cf2)) {
      return 0LL;
    }
  }

  else if ((CFTypeRef)kSOSViewKeychainV0 == cf2)
  {
    return 0LL;
  }

  return 0LL;
}

uint64_t sub_100194FAC(void *a1, const void *a2, uint64_t a3, const void **a4)
{
  id v7 = a1;
  CFMutableSetRef Mutable = CFSetCreateMutable(0LL, 0LL, &kCFTypeSetCallBacks);
  if (sub_1000195D0((uint64_t)Mutable, a4, @"No backup view set created"))
  {
    CFSetAddValue(Mutable, a2);
    v22[0] = _NSConcreteStackBlock;
    v22[1] = 3221225472LL;
    void v22[2] = sub_100195230;
    v22[3] = &unk_100291DD0;
    id v23 = v7;
    id v24 = a2;
    id v25 = Mutable;
    uint64_t v26 = a3;
    uint64_t v9 = sub_100194CF8(v23, (uint64_t)a2, a4, v22);
    uint64_t v10 = v9;
    if (a4 && (_DWORD)v9 && *a4)
    {
      uint64_t v11 = sub_10001267C("SecError");
      unsigned int v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v13 = *a4;
        *(_DWORD *)__int128 buf = 138412290;
        id v28 = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Got Success and Error (dropping error): %@",  buf,  0xCu);
      }

      id v14 = *a4;
      if (*a4)
      {
        *a4 = 0LL;
        CFRelease(v14);
      }
    }

    if ((v10 & 1) == 0)
    {
      uint64_t v15 = sub_10001267C("backupring");
      uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        if (a4) {
          uint64_t v17 = (const __CFString *)*a4;
        }
        else {
          uint64_t v17 = @"No error space.";
        }
        *(_DWORD *)__int128 buf = 138412546;
        id v28 = a2;
        __int16 v29 = 2112;
        BOOL v30 = v17;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Got error setting keybag for backup view '%@': %@",  buf,  0x16u);
      }
    }

    if (Mutable) {
      CFRelease(Mutable);
    }
    uint64_t v19 = (os_log_s *)v23;
  }

  else
  {
    uint64_t v18 = sub_10001267C("backupring");
    uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      if (a4) {
        uint64_t v20 = (const __CFString *)*a4;
      }
      else {
        uint64_t v20 = @"No error space.";
      }
      *(_DWORD *)__int128 buf = 138412546;
      id v28 = a2;
      __int16 v29 = 2112;
      BOOL v30 = v20;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "Got error setting keybag for backup view '%@': %@",  buf,  0x16u);
    }

    uint64_t v10 = 0LL;
  }

  return v10;
}

void *sub_100195230(uint64_t a1, void *a2, uint64_t a3)
{
  id v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) trust]);
  id v7 = (const __CFSet *)[v6 copyPeerSetForView:*(void *)(a1 + 40)];

  CFMutableSetRef Mutable = CFSetCreateMutable(0LL, 0LL, &kCFTypeSetCallBacks);
  sub_1001D5D24((uint64_t)a2, Mutable);
  context[0] = _NSConcreteStackBlock;
  context[1] = 0x40000000LL;
  uint64_t context[2] = sub_1001D5E3C;
  context[3] = &unk_100293BB8;
  context[4] = a2;
  CFSetApplyFunction(v7, (CFSetApplierFunction)sub_1001D5AD8, context);
  int v9 = sub_1001ABE6C( a2,  (uint64_t)[*(id *)(a1 + 32) fullPeerInfo],  *(const void **)(a1 + 48),  *(void *)(a1 + 56),  a3);
  uint64_t v10 = 0LL;
  if (a2 && v9)
  {
    CFRetain(a2);
    uint64_t v10 = a2;
  }

  if (v7) {
    CFRelease(v7);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v10;
}

uint64_t sub_100195344(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_100195358(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      CFStringRef v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%@-tomb", cf);
      (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
      if (v5) {
        CFRelease(v5);
      }
    }
  }

void sub_1001953F4(void *a1, void *a2)
{
  id context = a2;
  id v3 = [a1 peerInfo];
  if (v3)
  {
    PermittedViews = (const __CFSet *)SOSPeerInfoGetPermittedViews(v3);
    Mutableuint64_t Copy = CFSetCreateMutableCopy(kCFAllocatorDefault, 0LL, PermittedViews);
    CFSetRemoveValue(MutableCopy, kSOSViewKeychainV0);
    CFSetApplyFunction(MutableCopy, (CFSetApplierFunction)sub_100195344, context);
    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
  }
}

void *sub_100195484(void *a1, const void *a2, CFTypeRef *a3)
{
  id v5 = a1;
  id v6 = v5;
  id v7 = 0LL;
  if (v5)
  {
    if (a2)
    {
      id v8 = (void *)objc_claimAutoreleasedReturnValue([v5 trust]);
      id v7 = [v8 peerInfo];

      if (v7)
      {
        if (SOSPeerInfoHasBackupKey(v7)
          && SOSPeerInfoIsEnabledView(v7, a2)
          && (CFStringRef v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%@-tomb", a2)) != 0LL)
        {
          CFStringRef v10 = v9;
          uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v6 peerID]);
          id v7 = (void *)sub_1001ABB38((uint64_t)v10, (uint64_t)v11, 1u, (uint64_t)a3);

          CFRelease(v10);
          CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
          uint64_t MutableForSOSPeerInfosByID = (const void *)CFSetCreateMutableForSOSPeerInfosByID(kCFAllocatorDefault);
          id v14 = (void *)objc_claimAutoreleasedReturnValue([v6 trust]);
          v20[0] = _NSConcreteStackBlock;
          v20[1] = 3221225472LL;
          v20[2] = sub_10019575C;
          v20[3] = &unk_100292FD0;
          void v20[4] = Mutable;
          void v20[5] = MutableForSOSPeerInfosByID;
          SOSCircleForEachBackupCapablePeerForView( [v14 trustedCircle],  objc_msgSend(v6, "accountKey"),  a2,  v20);

          uint64_t v15 = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
          CFSetAddValue(v15, a2);
          uint64_t v16 = sub_1001AC124(kCFAllocatorDefault, v6, 0LL);
          if (v16)
          {
            uint64_t v17 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
            CFDictionaryAddValue(v17, bskbRkbgPrefix, v16);
            uint64_t v18 = (const void *)SOSBackupSliceKeyBagCreateWithAdditionalKeys( kCFAllocatorDefault,  MutableForSOSPeerInfosByID,  v17,  a3);
            if (v17) {
              CFRelease(v17);
            }
          }

          else
          {
            uint64_t v18 = (const void *)SOSBackupSliceKeyBagCreate(kCFAllocatorDefault, MutableForSOSPeerInfosByID, a3);
          }

          if (v18)
          {
            sub_1001D5D24((uint64_t)v7, Mutable);
            sub_1001ABE6C(v7, (uint64_t)[v6 fullPeerInfo], v15, (uint64_t)v18, (uint64_t)a3);
            sub_100197264((uint64_t)v7, (uint64_t)[v6 fullPeerInfo], v15, a3);
          }

          else if (v7)
          {
            CFRelease(v7);
            id v7 = 0LL;
          }

          if (v15) {
            CFRelease(v15);
          }
          if (Mutable) {
            CFRelease(Mutable);
          }
          if (MutableForSOSPeerInfosByID) {
            CFRelease(MutableForSOSPeerInfosByID);
          }
          if (v18) {
            CFRelease(v18);
          }
          if (v16) {
            CFRelease(v16);
          }
        }

        else
        {
          id v7 = 0LL;
        }
      }
    }
  }

  return v7;
}

void sub_10019575C(uint64_t a1, const void *a2)
{
  CFTypeID v4 = *(__CFSet **)(a1 + 32);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(a2);
  CFSetAddValue(v4, PeerID);
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 40), a2);
}

void sub_1001957A4(void *a1)
{
  id v1 = a1;
  uint64_t v2 = sub_10001267C("backup");
  id v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Updating Backup Rings", buf, 2u);
  }

  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_100195880;
  void v5[3] = &unk_100291D08;
  id v6 = v1;
  id v4 = v1;
  sub_1001953F4(v4, v5);
  [v4 setPublicKeyStatus:2 forKey:1];
  objc_msgSend(v4, "setCircle_rings_retirements_need_attention:", 1);
}

void sub_100195880(uint64_t a1, uint64_t a2)
{
  CFTypeRef cf = 0LL;
  id v3 = *(void **)(a1 + 32);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_100195998;
  void v7[3] = &unk_100291CE0;
  id v8 = v3;
  uint64_t v9 = a2;
  sub_100194CF8(v8, a2, &cf, v7);
  if (cf)
  {
    id v4 = sub_10001267C("ring");
    id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v12 = cf;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Error during SOSAccountProcessBackupRings (%@)",  buf,  0xCu);
    }

    CFTypeRef v6 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v6);
    }
  }
}

void *sub_100195998(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  return sub_100195484(*(void **)(a1 + 32), *(const void **)(a1 + 40), a3);
}

void sub_1001959A4(uint64_t a1, const void *a2)
{
  id v4 = *(__CFSet **)(a1 + 32);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(a2);
  CFSetAddValue(v4, PeerID);
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 40), a2);
}

uint64_t sub_1001959EC(void *a1, const __CFData *a2, uint64_t a3)
{
  id v5 = a1;
  uint64_t v14 = 0LL;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x3032000000LL;
  uint64_t v17 = sub_100195BA0;
  uint64_t v18 = sub_100195BB0;
  id v19 = (id)0xAAAAAAAAAAAAAAAALL;
  id v19 = (id)objc_claimAutoreleasedReturnValue([v5 account]);
  if (a2)
  {
    CFDataRef Copy = CFDataCreateCopy(kCFAllocatorDefault, a2);
    objc_msgSend((id)v15[5], "setBackup_key:", Copy);
  }

  else
  {
    objc_msgSend((id)v15[5], "setBackup_key:", 0);
  }

  id v7 = (void *)v15[5];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472LL;
  v13[2] = sub_100195BB8;
  v13[3] = &unk_100291D30;
  void v13[4] = &v14;
  void v13[5] = a2;
  uint64_t v8 = sub_10019BC50(v7, (uint64_t)@"Backup public key", a3, v13);
  if ((_DWORD)v8)
  {
    [(id)v15[5] setPublicKeyStatus:1 forKey:1];
    uint64_t v9 = sub_10001267C("devRecovery");
    CFStringRef v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFTypeRef v12 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Processing backup rings since we got a BackupKey",  v12,  2u);
    }

    sub_1001957A4((void *)v15[5]);
  }

  _Block_object_dispose(&v14, 8);

  return v8;
}

void sub_100195B84( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_100195BA0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100195BB0(uint64_t a1)
{
}

uint64_t sub_100195BB8(uint64_t a1, uint64_t a2)
{
  id v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), "backup_key"));

  if (v4)
  {
    id v5 = (const void *)SOSCopyIDOfDataBufferWithLength(*(void *)(a1 + 40), 8LL, 0LL);
    CFTypeRef v6 = sub_10001267C("backup");
    id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = 138412290;
      uint64_t v14 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Setting peerInfo backupKey to %@",  (uint8_t *)&v13,  0xCu);
    }

    if (v5) {
      CFRelease(v5);
    }
    SOSPeerInfoV2DictionarySetValue(a2, sBackupKeyKey, *(void *)(a1 + 40));
  }

  else
  {
    uint64_t v8 = sub_10001267C("backup");
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v13) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Setting peerInfo backupKey to NULL",  (uint8_t *)&v13,  2u);
    }

    SOSPeerInfoV2DictionaryRemoveValue(a2, sBackupKeyKey);
  }

  CFStringRef v10 = sub_10001267C("backup");
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v13) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Changed BackupKey for PeerInfo",  (uint8_t *)&v13,  2u);
  }

  return 1LL;
}

void sub_100195D78(uint64_t a1, const void *a2, const void *a3)
{
}

uint64_t sub_100195D80(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t sub_100195D98(uint64_t a1, const void *a2)
{
  uint64_t result = sub_100194FAC(*(void **)(a1 + 32), a2, *(void *)(a1 + 48), *(const void ***)(a1 + 56));
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8LL);
  if (*(_BYTE *)(v4 + 24)) {
    char v5 = result;
  }
  else {
    char v5 = 0;
  }
  *(_BYTE *)(v4 + 24) = v5;
  return result;
}

void sub_100195DD8(uint64_t a1, const void *a2)
{
  if (sub_100194F3C(*(void *)(a1 + 48), a2))
  {
    uint64_t v4 = (const __CFSet *)sub_100194E34(*(void **)(a1 + 32), (uint64_t)a2);
    char v5 = *(uint64_t **)(a1 + 56);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
    id context = _NSConcreteStackBlock;
    uint64_t v21 = 3221225472LL;
    uint64_t v22 = (void (*)(void ***, const void *))sub_100195FF4;
    id v23 = &unk_100292FB0;
    id v24 = v5;
    CFMutableArrayRef v25 = Mutable;
    CFSetApplyFunction(v4, (CFSetApplierFunction)sub_100195344, &context);
    id v7 = *(void **)(a1 + 32);
    uint64_t v8 = *(const void ***)(a1 + 64);
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472LL;
    uint64_t v16 = sub_10019606C;
    uint64_t v17 = &unk_100291C90;
    id v18 = v7;
    id v19 = a2;
    id v9 = v18;
    CFStringRef v10 = v15;
    uint64_t v27 = 0LL;
    id v28 = &v27;
    uint64_t v29 = 0x2020000000LL;
    uint64_t v30 = 0LL;
    id context = _NSConcreteStackBlock;
    uint64_t v21 = 3221225472LL;
    uint64_t v22 = (void (*)(void ***, const void *))sub_100196080;
    id v23 = &unk_100291DA8;
    id v24 = &v27;
    CFMutableArrayRef v25 = Mutable;
    uint64_t v26 = v8;
    uint64_t v11 = &context;
    CFTypeRef v12 = (const void *)sub_100194E34(v9, (uint64_t)a2);
    v22(v11, v12);

    if (v12) {
      CFRelease(v12);
    }
    uint64_t v13 = v28[3];
    if (v13)
    {
      v16((uint64_t)v10, v28[3], v8);
      uint64_t v14 = (const void *)v28[3];
      if (v14)
      {
        v28[3] = 0LL;
        CFRelease(v14);
      }
    }

    _Block_object_dispose(&v27, 8);

    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = v13 != 0;
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (v4) {
      CFRelease(v4);
    }
  }

void sub_100195FD8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_100195FF4(uint64_t a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  void v4[2] = sub_100196298;
  void v4[3] = &unk_100292FB0;
  id v3 = *(const __CFArray **)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  void v4[4] = a2;
  void v4[5] = v2;
  v5.size_t length = CFArrayGetCount(v3);
  v5.id location = 0LL;
  CFArrayApplyFunction(v3, v5, (CFArrayApplierFunction)sub_100195344, v4);
}

uint64_t sub_10019606C(uint64_t a1, uint64_t a2, const void **a3)
{
  return sub_100194FAC(*(void **)(a1 + 32), *(const void **)(a1 + 40), a2, a3);
}

void sub_100196080(void *a1, CFSetRef theSet)
{
  CFIndex Count = CFSetGetCount(theSet);
  MutableCFDataRef Copy = CFSetCreateMutableCopy(kCFAllocatorDefault, Count, theSet);
  CFTypeRef v6 = (const __CFArray *)a1[5];
  context[0] = _NSConcreteStackBlock;
  context[1] = 3221225472LL;
  uint64_t context[2] = sub_100196158;
  context[3] = &unk_100293EA8;
  context[4] = MutableCopy;
  v8.size_t length = CFArrayGetCount(v6);
  v8.id location = 0LL;
  CFArrayApplyFunction(v6, v8, (CFArrayApplierFunction)sub_100195344, context);
  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = SOSBackupSliceKeyBagCreate(kCFAllocatorDefault, MutableCopy, a1[6]);
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
}

void sub_100196158(uint64_t a1, CFTypeRef cf)
{
  if (cf && (CFTypeID v4 = CFGetTypeID(cf), v4 == SOSPeerInfoGetTypeID()))
  {
    uint64_t PeerID = SOSPeerInfoGetPeerID(cf);
    CFTypeRef v6 = *(const __CFSet **)(a1 + 32);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    _DWORD v9[2] = sub_100196244;
    v9[3] = &unk_100292FB0;
    void v9[4] = PeerID;
    void v9[5] = v6;
    CFSetApplyFunction(v6, (CFSetApplierFunction)sub_100195344, v9);
  }

  else
  {
    id v7 = sub_10001267C("SecError");
    CFRange v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Peer list contains a non-peerInfo element",  buf,  2u);
    }
  }

void sub_100196244(uint64_t a1, const void *a2)
{
  uint64_t PeerID = (const __CFString *)SOSPeerInfoGetPeerID(a2);
  if (PeerID)
  {
    CFRange v5 = *(const __CFString **)(a1 + 32);
    if (v5)
    {
      if (CFStringCompare(PeerID, v5, 0LL) == kCFCompareEqualTo) {
        CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 40), a2);
      }
    }
  }

void sub_100196298(uint64_t a1, uint64_t a2)
{
  uint64_t PeerID = (const __CFString *)SOSPeerInfoGetPeerID(a2);
  CFTypeID v4 = (const __CFString *)SOSPeerInfoGetPeerID(*(void *)(a1 + 32));
  if (PeerID && v4 && CFStringCompare(v4, PeerID, 0LL) == kCFCompareEqualTo) {
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), *(const void **)(a1 + 32));
  }
}

void sub_1001962F0(void *a1)
{
  id v1 = a1;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([v1 account]);
  if (([v2 isInCircle:0] & 1) == 0)
  {
    id v18 = sub_10001267C("backup");
    id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v20 = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Not currently in circle", v20, 2u);
    }

    goto LABEL_22;
  }

  id v3 = (const void *)SOSPeerInfoCopyBackupKey([v2 peerInfo]);
  CFTypeID v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "backup_key"));

  if (!v4)
  {
    if (!v3) {
      goto LABEL_22;
    }
    sub_1001959EC(v1, 0LL, 0LL);
    goto LABEL_21;
  }

  CFRange v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "backup_key"));
  char v6 = SOSBSKBIsGoodBackupPublic(v5, 0LL);

  if ((v6 & 1) != 0)
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "backup_key"));
    CFRange v8 = v7;
    if (!v3 || !v7)
    {

      if (v3 == v8) {
        goto LABEL_20;
      }
      goto LABEL_14;
    }

    int v9 = CFEqual(v3, v7);

    if (!v9)
    {
LABEL_14:
      CFTypeRef v12 = sub_10001267C("backupkey");
      uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v20 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Account backup key and peerinforef backup key don't match.  Using account backup key.",  v20,  2u);
      }

      uint64_t v14 = (const __CFData *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "backup_key"));
      char v15 = sub_1001959EC(v1, v14, 0LL);

      if ((v15 & 1) == 0)
      {
        uint64_t v16 = sub_10001267C("backupkey");
        uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t v20 = 138412290;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Failed to setup backup public key in peerInfo from account: %@",  v20,  0xCu);
        }
      }

      goto LABEL_20;
    }

void sub_1001965A8(uint64_t a1, CFDataRef theData)
{
  uint64_t v2 = theData;
  if (theData)
  {
    uint64_t v23 = 0LL;
    id v24 = &v23;
    uint64_t v25 = 0x2020000000LL;
    uint64_t v26 = 0LL;
    uint64_t v21 = 0LL;
    uint64_t v22 = 0LL;
    uint64_t v19 = 0LL;
    uint64_t v20 = 0LL;
    BytePtr = CFDataGetBytePtr(theData);
    CFIndex Length = CFDataGetLength(v2);
    if ((const UInt8 *)sub_100196890(&v22, (uint64_t *)&v21, &v20, &v19, (uint64_t)BytePtr, (uint64_t)&BytePtr[Length]) == &BytePtr[Length])
    {
      *(void *)__int128 buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3221225472LL;
      *(void *)&uint8_t buf[16] = sub_1001969D0;
      id v28 = &unk_100291DF8;
      char v6 = v21;
      uint64_t v29 = &v23;
      uint64_t v30 = v20;
      uint64_t v31 = v19;
      id v7 = buf;
      CFRange v8 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v6, 4LL, kCFAllocatorNull);
      int v9 = v7;
      CFStringRef v10 = v9;
      if (v8)
      {
        CFIndex v11 = CFDataGetLength(v8);
        CFMutableArrayRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * v11);
        uint64_t v13 = CFDataGetBytePtr(v8);
        CFIndex v14 = CFDataGetLength(v8);
        if (v14 >= 1)
        {
          do
          {
            unsigned int v15 = *v13++;
            CFStringAppendFormat(Mutable, 0LL, @"%02X", v15);
            --v14;
          }

          while (v14);
        }

        (*(void (**)(void *, __CFString *))&buf[16])(v10, Mutable);
        CFRelease(Mutable);

        CFRelease(v8);
      }

      else
      {
        (*(void (**)(_BYTE *, const __CFString *))&buf[16])(v9, @"(null)");
        CFRelease(@"(null)");
      }

      uint64_t v2 = (const __CFData *)v24[3];
    }

    else
    {
      uint64_t v2 = 0LL;
    }

    _Block_object_dispose(&v23, 8);
  }

  uint64_t v16 = sub_10001267C("circleOps");
  uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
  BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v18)
    {
      *(_DWORD *)__int128 buf = 138412546;
      *(void *)&uint8_t buf[4] = a1;
      *(_WORD *)&_BYTE buf[12] = 2112;
      *(void *)&buf[14] = v2;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%@ %@]", buf, 0x16u);
    }

    CFRelease(v2);
  }

  else
  {
    if (v18)
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "failed to decode pbkdf2 params", buf, 2u);
    }
  }

void sub_100196868( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

size_t sub_100196890(void *a1, uint64_t *a2, void *a3, void *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v24 = 0LL;
  uint64_t v11 = ccder_decode_constructed_tl(0x2000000000000010LL, &v24, a5, a6);
  if (v24 == a6) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0LL;
  }
  uint64_t v23 = 0LL;
  uint64_t v13 = ccder_decode_tl(4LL, &v23, v12, v24);
  uint64_t v21 = 0LL;
  uint64_t v22 = 0LL;
  uint64_t v14 = ccder_decode_uint64(&v22, v13 + v23, v24);
  if (HIDWORD(v22)) {
    uint64_t v15 = 0LL;
  }
  else {
    uint64_t v15 = v14;
  }
  uint64_t v16 = ccder_decode_uint64(&v21, v15, v24);
  if (HIDWORD(v21)) {
    uint64_t v17 = 0LL;
  }
  else {
    uint64_t v17 = v16;
  }
  uint64_t v25 = 0LL;
  BOOL v18 = (const void *)ccder_decode_tl(6LL, &v25, v17, v24);
  if (CSSMOID_PKCS5_HMAC_SHA1.Length != v25) {
    return 0LL;
  }
  uint64_t v19 = v18;
  if (memcmp(CSSMOID_PKCS5_HMAC_SHA1.Data, v18, CSSMOID_PKCS5_HMAC_SHA1.Length) || !v19) {
    return 0LL;
  }
  if (a2) {
    *a2 = v13;
  }
  if (a1) {
    *a1 = v23;
  }
  size_t result = (size_t)v19 + CSSMOID_PKCS5_HMAC_SHA1.Length;
  if (a3) {
    *a3 = v22;
  }
  if (a4) {
    *a4 = v21;
  }
  return result;
}

CFStringRef sub_1001969D0(void *a1, uint64_t a2)
{
  CFStringRef result = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"<Params: iter: %zd, size: %zd, salt: %@>",  a1[5],  a1[6],  a2);
  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) = result;
  return result;
}

uint64_t sub_100196A28(const __CFData *a1, CFDataRef theData, uint64_t a3)
{
  uint64_t v30 = 0LL;
  unint64_t v31 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v28 = 0LL;
  unint64_t v29 = 0LL;
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  if (!sub_100196890(&v31, &v30, &v29, &v28, (uint64_t)BytePtr, (uint64_t)&BytePtr[Length]))
  {
    int v9 = @"Bad paramter encoding, got: %@";
    *(void *)&__int128 v25 = theData;
    uint64_t v10 = 1029LL;
LABEL_8:
    SOSCreateErrorWithFormat(v10, 0LL, a3, 0LL, v9);
    return 0LL;
  }

  unint64_t v8 = v28;
  if (v28 != 256)
  {
    int v9 = @"Key size not supported, requested %zd.";
    goto LABEL_7;
  }

  unint64_t v8 = v31;
  if (v31 <= 3)
  {
    int v9 = @"Salt length not supported, requested %zd.";
LABEL_7:
    *(void *)&__int128 v25 = v8;
    uint64_t v10 = 1041LL;
    goto LABEL_8;
  }

  unint64_t v8 = v29;
  if (v29 >> 4 <= 0xC34)
  {
    int v9 = @"Too few iterations, params suggested %zd.";
    goto LABEL_7;
  }

  uint64_t v12 = CFDataGetBytePtr(a1);
  CFIndex v13 = CFDataGetLength(a1);
  uint64_t cp = ccec_get_cp(v28);
  __chkstk_darwin(cp);
  uint64_t v16 = &v26[-v15];
  unint64_t v17 = 0LL;
  do
  {
    BOOL v18 = &v16[v17 / 8];
    *BOOL v18 = 0xAAAAAAAAAAAAAAAALL;
    v18[1] = 0xAAAAAAAAAAAAAAAALL;
    v17 += 16LL;
  }

  while (v15 != v17);
  sub_1001965A8((uint64_t)@"SOSUserKeygen generating key for:", theData);
  uint64_t v20 = __chkstk_darwin(v19);
  *(void *)&__int128 v21 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v26[-32] = v21;
  __int128 v25 = v21;
  *(_OWORD *)&v26[-64] = v21;
  *(_OWORD *)&v26[-48] = v21;
  *(_OWORD *)&v26[-96] = v21;
  *(_OWORD *)&v26[-80] = v21;
  *(_OWORD *)&v26[-128] = v21;
  *(_OWORD *)&v26[-112] = v21;
  uint64_t v22 = ccsha256_di(v20);
  ccpbkdf2_hmac(v22, v13, v12, v31, v30, v29, 128LL, &v26[-128]);
  int v27 = 0;
  uint64_t v23 = ccrng(&v27);
  if (v23)
  {
    int key_deterministic = ccec_generate_key_deterministic(cp, 128LL, &v26[-128], v23, 4LL, v16);
    cc_clear(128LL, &v26[-128]);
    if (!key_deterministic) {
      return sub_100196C9C(v16);
    }
  }

  SOSCreateError(1028LL, @"Keygen failed", 0LL, a3);
  return 0LL;
}

uint64_t sub_100196C9C(void *a1)
{
  uint64_t v2 = cczp_bitlen(*a1);
  unint64_t v3 = 3 * ((unint64_t)(v2 + 7) >> 3) + 1;
  __chkstk_darwin(v2);
  CFRange v5 = (const UInt8 *)&v17 - v4;
  memset((char *)&v17 - v4, 170, v3);
  ccec_x963_export(1LL, v5, a1);
  CFDataRef v6 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v5, v3, kCFAllocatorNull);
  CFDictionaryRef v14 = sub_100107FA8(kCFAllocatorDefault, v7, v8, v9, v10, v11, v12, v13, (uint64_t)kSecValueData, (uint64_t)v6);
  uint64_t v15 = SecKeyCreateFromAttributeDictionary();
  CFRelease(v14);
  CFRelease(v6);
  cc_clear(v3, v5);
  return v15;
}

uint64_t sub_100196E10(const void *a1, const void *a2, uint64_t a3)
{
  uint64_t v4 = sub_1001D5FDC(a1, 1, a3);
  uint64_t v5 = v4;
  if (v4 && a2) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v4 + 16), @"LastModifier", a2);
  }
  return v5;
}

uint64_t sub_100196E58( uint64_t a1, const __CFSet *a2, uint64_t a3, uint64_t a4, uint64_t a5, const void *a6, uint64_t a7, uint64_t a8)
{
  if (a6)
  {
    if (sub_1001D5B70(*(const __CFDictionary **)(a4 + 24), a3))
    {
      SOSCreateError(1039LL, @"Bad generation", 0LL, a8);
      return 1LL;
    }

    else if (sub_1001D6420(a4))
    {
      return 0LL;
    }

    else
    {
      if (a1)
      {
        uint64_t PeerInfo = SOSFullPeerInfoGetPeerInfo(a1);
        uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(PeerInfo);
        uint64_t v17 = (const __CFSet *)sub_1001D5C8C(a4);
        uint64_t v34 = 0LL;
        CFStringRef v35 = &v34;
        uint64_t v36 = 0x2020000000LL;
        LOBYTE(v37) = 1;
        id context = _NSConcreteStackBlock;
        uint64_t v26 = 3221225472LL;
        int v27 = sub_10019715C;
        unint64_t v28 = &unk_100292A88;
        unint64_t v29 = &v34;
        uint64_t PermittedViews = SOSPeerInfoGetPermittedViews(PeerInfo);
        CFSetApplyFunction(v17, (CFSetApplierFunction)sub_100197190, &context);
        BOOL v18 = *((_BYTE *)v35 + 24) != 0;
        _Block_object_dispose(&v34, 8);
        BOOL v19 = sub_1001D5D68(a4, PeerID);
      }

      else
      {
        BOOL v19 = 0;
        BOOL v18 = 0;
      }

      if (v18 || !v19) {
        int v20 = 0;
      }
      else {
        int v20 = 11;
      }
      if (!v18 || v19) {
        int v21 = v20;
      }
      else {
        int v21 = 10;
      }
      if (v21 == 11)
      {
        SOSCreateError(1039LL, @"Improper inclusion of this peer", 0LL, a8);
        return 11LL;
      }

      else if (v21 == 10)
      {
        SOSCreateError(1039LL, @"Improper exclusion of this peer", 0LL, a8);
        return 10LL;
      }

      else
      {
        uint64_t v22 = sub_1001D5C8C(a4);
        if (!v22) {
          return 9LL;
        }
        uint64_t v34 = 0LL;
        CFStringRef v35 = &v34;
        uint64_t v36 = 0x2020000000LL;
        LOBYTE(v37) = 1;
        id context = _NSConcreteStackBlock;
        uint64_t v26 = 3221225472LL;
        int v27 = sub_1001971A4;
        unint64_t v28 = &unk_100291DF8;
        uint64_t PermittedViews = (uint64_t)a2;
        unint64_t v31 = v22;
        unint64_t v29 = &v34;
        sub_1001D5F24(a4, (uint64_t)&context);
        int v23 = *((unsigned __int8 *)v35 + 24);
        _Block_object_dispose(&v34, 8);
        if (v23)
        {
          uint64_t v34 = 0LL;
          CFStringRef v35 = &v34;
          uint64_t v36 = 0x2000000000LL;
          int v37 = 4;
          id context = _NSConcreteStackBlock;
          uint64_t v26 = 0x40000000LL;
          int v27 = sub_1001B36B0;
          unint64_t v28 = &unk_100292C10;
          unint64_t v31 = a6;
          uint64_t v32 = a8;
          uint64_t v33 = a7;
          unint64_t v29 = &v34;
          uint64_t PermittedViews = a4;
          CFSetApplyFunction(a2, (CFSetApplierFunction)sub_1001B3814, &context);
          uint64_t v14 = *((unsigned int *)v35 + 6);
          _Block_object_dispose(&v34, 8);
        }

        else
        {
          return 9LL;
        }
      }
    }
  }

  else
  {
    SOSCreateError(2LL, @"Concordance with no public key - need to validate application", 0LL, a8);
    return 3LL;
  }

  return v14;
}

void sub_100197144( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t sub_10019715C(uint64_t a1, const void *a2)
{
  uint64_t result = CFSetContainsValue(*(CFSetRef *)(a1 + 40), a2);
  if (!(_DWORD)result) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
  }
  return result;
}

uint64_t sub_100197190(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_1001971A4(void *a1)
{
  uint64_t v2 = SOSPeerInfoSetFindByID(a1[5]);
  if (v2)
  {
    unint64_t v3 = (const __CFSet *)a1[6];
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472LL;
    void v4[2] = sub_100197230;
    void v4[3] = &unk_100292A88;
    void v4[4] = a1[4];
    void v4[5] = v2;
    CFSetApplyFunction(v3, (CFSetApplierFunction)sub_100197190, v4);
  }

  else
  {
    *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = 0;
  }

uint64_t sub_100197230(uint64_t a1, uint64_t a2)
{
  uint64_t result = SOSPeerInfoIsViewPermitted(*(void *)(a1 + 40), a2);
  if ((result & 1) == 0) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 0;
  }
  return result;
}

void sub_100197264(uint64_t a1, uint64_t a2, const void *a3, CFTypeRef *a4)
{
  uint64_t PeerInfo = SOSFullPeerInfoGetPeerInfo(a2);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(PeerInfo);
  uint64_t v10 = SOSFullPeerInfoCopyDeviceKey(a2, a4);
  int v11 = (__SecKey *)v10;
  if (v10 && PeerID)
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"LastModifier", PeerID);
    if (sub_1001D5CE0(a1, a3)) {
      sub_1001D6800(a1, v11, a4);
    }
  }

  else if (!v10)
  {
    return;
  }

  CFRelease(v11);
}

void sub_100197318(void *a1, uint64_t a2)
{
  unint64_t v3 = (const __CFDictionary *)sub_10018DFDC(a1, (uint64_t)@"PeerNegotiationTimeouts");
  if (!v3 || (v4 = v3, CFTypeID v5 = CFGetTypeID(v3), v5 != CFDictionaryGetTypeID()))
  {
    int v11 = sub_10001267C("otrtimer");
    int v8 = (void *)objc_claimAutoreleasedReturnValue(v11);
    if (!os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_DEFAULT))
    {
LABEL_10:

      int64_t v10 = 0LL;
      goto LABEL_11;
    }

    *(_WORD *)__int128 buf = 0;
LABEL_9:
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)v8,  OS_LOG_TYPE_DEFAULT,  "deadline value not available yet",  buf,  2u);
    goto LABEL_10;
  }

  signed int Value = (void *)CFDictionaryGetValue(v4, *(const void **)(a2 + 16));
  int v7 = sub_10001267C("otrtimer");
  int v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  BOOL v9 = os_log_type_enabled((os_log_t)v8, OS_LOG_TYPE_DEFAULT);
  if (!Value)
  {
    if (!v9) {
      goto LABEL_10;
    }
    *(_WORD *)__int128 buf = 0;
    goto LABEL_9;
  }

  if (v9)
  {
    *(_DWORD *)__int128 buf = 67109120;
    LODWORD(v23) = [Value intValue];
    _os_log_impl( (void *)&_mh_execute_header,  (os_log_t)v8,  OS_LOG_TYPE_DEFAULT,  "decided to wait %d before restarting negotiation",  buf,  8u);
  }

  int64_t v10 = 1000000000 * (int)[Value intValue];
LABEL_11:
  uint64_t v12 = *(void *)(a2 + 16);
  if (v12) {
    CFRetain(*(CFTypeRef *)(a2 + 16));
  }
  int v13 = sub_10001267C("otrtimer");
  uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412290;
    uint64_t v23 = a2;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "setting timer for peer: %@", buf, 0xCu);
  }

  uint64_t v15 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, &_dispatch_main_q);
  dispatch_time_t v16 = dispatch_time(0LL, v10);
  dispatch_source_set_timer(v15, v16, 0xFFFFFFFFFFFFFFFFLL, 0LL);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_1001975F4;
  handler[3] = &unk_1002935A8;
  handler[4] = v12;
  dispatch_source_set_event_handler(v15, handler);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472LL;
  v20[2] = sub_100197734;
  v20[3] = &unk_1002935A8;
  void v20[4] = v12;
  dispatch_source_set_cancel_handler(v15, v20);
  dispatch_resume(v15);
  uint64_t v17 = v15;
  BOOL v18 = *(NSMutableDictionary **)(a2 + 104);
  if (!v18) {
    BOOL v18 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  }
  -[NSMutableDictionary setObject:forKey:](v18, "setObject:forKey:", v17, *(void *)(a2 + 16));
  BOOL v19 = v18;
  *(void *)(a2 + 104) = v19;
}

void sub_1001975F4(uint64_t a1)
{
  uint64_t v2 = sub_10001267C("otrtimer");
  unint64_t v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "otrTimerFired fired", (uint8_t *)v6, 2u);
  }

  void v6[4] = *(void *)(a1 + 32);
  CFTypeRef v7 = 0LL;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  v6[2] = sub_1001D353C;
  v6[3] = &unk_100293338;
  sub_1001C7358(&v7, v6);
  if (v7)
  {
    uint64_t v4 = sub_10001267C("SecError");
    CFTypeID v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v9 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "error resetting otr negotation: %@",  buf,  0xCu);
    }
  }

void sub_100197734(uint64_t a1)
{
  id v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t sub_100197744(void *a1, uint64_t a2)
{
  id v3 = a1;
  id v4 = [v3 accountKey];
  CFTypeID v5 = (void *)objc_claimAutoreleasedReturnValue([v3 accountKeyDerivationParameters]);
  uint64_t v6 = sub_10019885C(v4, a2);
  uint64_t v7 = der_sizeof_data_or_null(v5, a2);
  CFIndex v8 = ccder_sizeof(0x2000000000000010LL, v7 + v6);

  CFMutableArrayRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0LL);
  CFDataSetLength(Mutable, v8);
  id v10 = [v3 accountKey];
  int v11 = (void *)objc_claimAutoreleasedReturnValue([v3 accountKeyDerivationParameters]);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  int v13 = CFDataGetMutableBytePtr(Mutable);
  uint64_t v14 = &v13[CFDataGetLength(Mutable)];
  uint64_t v15 = der_encode_data_or_null(v11, a2, MutableBytePtr, v14);
  uint64_t v16 = sub_1001988B4(v10, a2, (uint64_t)MutableBytePtr, v15);
  uint64_t v17 = ccder_encode_constructed_tl(0x2000000000000010LL, v14, MutableBytePtr, v16);

  if (v17)
  {
    BOOL v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "key_transport"));
    BOOL v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "key_transport"));
    unsigned __int8 v20 = [v18 SOSTransportKeyParameterPublishCloudParameters:v19 data:Mutable err:a2];

    if ((v20 & 1) != 0)
    {
      uint64_t v21 = 1LL;
      if (!Mutable) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }

    SOSCreateErrorWithFormat(1027LL, 0LL, a2, 0LL, @"update parameters key failed [%@]");
  }

  else
  {
    SOSCreateError(1025LL, @"Encoding parameters failed", 0LL, a2);
  }

  uint64_t v21 = 0LL;
  if (Mutable) {
LABEL_8:
  }
    CFRelease(Mutable);
LABEL_9:

  return v21;
}

BOOL sub_100197924(void *a1, CFDataRef theData, uint64_t a3)
{
  BytePtr = CFDataGetBytePtr(theData);
  uint64_t v7 = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  ccder_decode_sequence_tl(&v12, BytePtr, &v7[Length]);
  sub_100198924((uint64_t)kCFAllocatorDefault, a1);
  uint64_t v9 = der_decode_data_or_null(kCFAllocatorDefault, a3);
  id v10 = CFDataGetBytePtr(theData);
  return v9 == (void)&v10[CFDataGetLength(theData)];
}

void sub_100197A04(void *a1)
{
  if (dword_1002DED80 > 0)
  {
    --dword_1002DED80;
    return;
  }

  id v18 = (id)objc_claimAutoreleasedReturnValue([a1 account]);
  if (sub_100197C6C(v18, 0LL))
  {
    id v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "kvs_message_transport"));
    id v2 = [v1 SOSTransportMessageGetEngine];

    if (!-[OTSOSActualAdapter sosEnabled]_0(v3, v4))
    {
LABEL_17:
      dword_1002DED80 = 20;
      goto LABEL_18;
    }

    CFTypeRef cf = 0LL;
    CFTypeID v5 = sub_10001267C("engineLogState");
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Start", buf, 2u);
    }

    if (v2)
    {
      uint64_t v7 = sub_1000D56F4((uint64_t)v2, (uint64_t)&cf);
      if (v7)
      {
        CFIndex v8 = (const void *)v7;
        SOSCCForEachEngineStateAsStringFromArray(v7, &stru_100285968);
LABEL_10:
        CFTypeRef v9 = cf;
        if (cf)
        {
          CFTypeRef cf = 0LL;
          CFRelease(v9);
        }

        if (v8) {
          CFRelease(v8);
        }
        id v10 = sub_10001267C("engineLogState");
        int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Finish", buf, 2u);
        }

        goto LABEL_17;
      }

      uint64_t v17 = sub_10001267C("engineLogState");
      int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFTypeRef v21 = cf;
        uint64_t v14 = "No engine peers: %@\n";
        uint64_t v15 = v13;
        uint32_t v16 = 12;
        goto LABEL_23;
      }
    }

    else
    {
      unint64_t v12 = sub_10001267C("engineLogState");
      int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        uint64_t v14 = "No Engine Available";
        uint64_t v15 = v13;
        uint32_t v16 = 2;
LABEL_23:
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v14, buf, v16);
      }
    }

    CFIndex v8 = 0LL;
    goto LABEL_10;
  }

id sub_100197C6C(void *a1, uint64_t a2)
{
  id v2 = [a1 isInCircle:a2];
  if ((v2 & 1) == 0)
  {
    uint64_t v3 = sub_10001267C("account-sync");
    uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Not performing requested sync operation: not in circle yet",  v6,  2u);
    }
  }

  return v2;
}

CFMutableSetRef sub_100197CEC(void *a1, const __CFSet *a2)
{
  id v3 = a1;
  CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
  CFTypeID v5 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  unsigned int v6 = sub_100197C6C(v5, 0LL);

  if (v6)
  {
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472LL;
    v8[2] = sub_100197DC4;
    v8[3] = &unk_100292230;
    id v9 = v3;
    CFMutableSetRef v10 = Mutable;
    CFSetApplyFunction(a2, (CFSetApplierFunction)sub_1001981E4, v8);
  }

  return Mutable;
}

void sub_100197DC4(uint64_t a1, CFTypeRef cf)
{
  if (!cf || (v2 = cf, CFTypeID v4 = CFGetTypeID(cf), v4 != CFStringGetTypeID()))
  {
    CFTypeRef v2 = 0LL;
    CFTypeRef cfa = 0LL;
    goto LABEL_10;
  }

  CFTypeRef cfa = 0LL;
  id v5 = *(id *)(a1 + 32);
  CFTypeRef v29 = 0LL;
  unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
  if ((sub_100197C6C(v6, (uint64_t)&cfa) & 1) == 0)
  {

    goto LABEL_10;
  }

  uint64_t v7 = sub_10001267C("account-sync");
  CFIndex v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)&uint8_t buf[4] = v2;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Syncing with KVS capable peer: %@", buf, 0xCu);
  }

  CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
  CFSetAddValue(Mutable, v2);
  CFMutableSetRef v10 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
  *(void *)__int128 buf = 0LL;
  int v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "kvs_message_transport"));
  unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "kvs_message_transport"));
  unsigned __int8 v13 = [v11 SOSTransportMessageSyncWithPeers:v12 p:Mutable err:buf];

  if ((v13 & 1) != 0)
  {
    LODWORD(v14) = 1;
    goto LABEL_31;
  }

  uint64_t v14 = *(__CFError **)buf;
  if (!*(void *)buf) {
    goto LABEL_31;
  }
  if (CFErrorGetCode(*(CFErrorRef *)buf) == 1032)
  {
    CFErrorDomain Domain = CFErrorGetDomain(v14);
    if (Domain && kSOSErrorDomain)
    {
      if (!CFEqual(Domain, kSOSErrorDomain)) {
        goto LABEL_27;
      }
LABEL_24:
      uint64_t v22 = sub_10001267C("account-sync");
      uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v30 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Arming account to update SOSEngine with current trusted peers",  v30,  2u);
      }

      objc_msgSend(v10, "setEngine_peer_state_needs_repair:", 1);
      goto LABEL_27;
    }

    if (Domain == (CFErrorDomain)kSOSErrorDomain) {
      goto LABEL_24;
    }
  }

uint64_t sub_1001981E4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

CFMutableSetRef sub_1001981F8(void *a1, const __CFSet *a2, uint64_t a3)
{
  id v5 = a1;
  unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
  if ((sub_100197C6C(v6, a3) & 1) != 0)
  {
    CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
    CFIndex v8 = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
    id v9 = [v6 peerInfo];
    if (v9)
    {
      uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(v9);
      MutableCFDataRef Copy = CFSetCreateMutableCopy(kCFAllocatorDefault, 0LL, a2);
      CFSetRemoveValue(MutableCopy, PeerID);
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 3221225472LL;
      v14[2] = sub_1001983C0;
      v14[3] = &unk_100293E20;
      id v15 = v6;
      uint32_t v16 = v8;
      CFMutableSetRef v17 = Mutable;
      CFSetApplyFunction(MutableCopy, (CFSetApplierFunction)sub_1001981E4, v14);
      unint64_t v12 = sub_100197CEC(v5, v8);
      context[0] = _NSConcreteStackBlock;
      context[1] = 3221225472LL;
      uint64_t context[2] = sub_100198580;
      context[3] = &unk_100293EA8;
      context[4] = Mutable;
      CFSetApplyFunction(v12, (CFSetApplierFunction)sub_1001981E4, context);
      if (v12) {
        CFRelease(v12);
      }
      sub_100197A04(v5);
      if (MutableCopy) {
        CFRelease(MutableCopy);
      }
      if (v8) {
        CFRelease(v8);
      }
    }

    else if (v8)
    {
      CFRelease(v8);
    }
  }

  else
  {
    CFMutableSetRef Mutable = CFSetCreateMutableCopy(kCFAllocatorDefault, 0LL, a2);
  }

  return Mutable;
}

void sub_1001983C0(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v2 = cf;
  CFTypeRef cfa = 0LL;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 != CFStringGetTypeID())
    {
      sub_1000194E0(-50, (__CFString **)&cfa, @"object %@ is not a string", v2);
      CFTypeRef v2 = 0LL;
    }
  }

  else
  {
    sub_1000194E0(-50, (__CFString **)&cfa, @"object %@ is not a string", 0LL);
  }

  id v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) trust]);
  id v6 = [v5 trustedCircle];
  if (v2)
  {
    id v7 = v6;
    uint64_t v8 = SOSCircleCopyPeerWithID(v6, v2, 0LL);
    if (v8)
    {
      id v9 = (const void *)v8;
      int HasValidSyncingPeer = SOSCircleHasValidSyncingPeer(v7, v8, [*(id *)(a1 + 32) accountKey], 0);
      uint64_t v11 = 48LL;
      if (HasValidSyncingPeer) {
        uint64_t v11 = 40LL;
      }
      CFSetAddValue(*(CFMutableSetRef *)(a1 + v11), v2);
      CFRelease(v9);
    }

    else
    {
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 48), v2);
    }
  }

  if (cfa)
  {
    unint64_t v12 = sub_10001267C("account-sync");
    unsigned __int8 v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412546;
      CFTypeRef v17 = v2;
      __int16 v18 = 2112;
      CFTypeRef v19 = cfa;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Skipped peer ID: %@ due to %@", buf, 0x16u);
    }

    CFTypeRef v14 = cfa;
    if (cfa)
    {
      CFTypeRef cfa = 0LL;
      CFRelease(v14);
    }
  }
}

void sub_100198580(uint64_t a1, const void *a2)
{
}

CFMutableSetRef sub_100198588(void *a1, uint64_t a2)
{
  id v3 = a1;
  CFTypeID v4 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  if (sub_100197C6C(v4, a2))
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
    id v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "kvs_message_transport"));
    id v7 = [v6 SOSTransportMessageGetEngine];

    uint64_t v8 = (void *)sub_1000D53AC((uint64_t)v7, a2);
    id v9 = -[NSSet initWithArray:](objc_alloc(&OBJC_CLASS___NSSet), "initWithArray:", v8);
    CFMutableSetRef v10 = sub_1000D3638((uint64_t)v7, (uint64_t)v9, 1, a2);
  }

  else
  {
    CFMutableSetRef v10 = 0LL;
  }

  return v10;
}

id sub_10019865C(void *a1, uint64_t a2)
{
  id v3 = a1;
  CFTypeID v4 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 trust]);
  id v6 = sub_100197C6C(v4, a2);
  if ((_DWORD)v6)
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
    id v8 = [v5 trustedCircle];
    id v9 = [v4 accountKey];
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472LL;
    v12[2] = sub_100198768;
    void v12[3] = &unk_1002925E0;
    id v13 = v7;
    id v10 = v7;
    SOSCircleForEachValidSyncingPeer(v8, v9, v12);
    [v3 requestSyncWithPeers:v10];
  }

  return v6;
}

id sub_100198768(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) addObject:SOSPeerInfoGetPeerID(a2)];
}

uint64_t sub_100198794(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v12 = a3;
  uint64_t v8 = ccder_decode_tag(&v11, a3, a4);
  uint64_t result = 0LL;
  if (v8 && a1)
  {
    if (v11 == 5)
    {
      if (a3)
      {
        uint64_t v13 = 0LL;
        uint64_t result = ccder_decode_tl(5LL, &v13, a3, a4);
        if (v13) {
          BOOL v10 = 1;
        }
        else {
          BOOL v10 = result == 0;
        }
        if (v10) {
          return 0LL;
        }
      }

      else
      {
        return 0LL;
      }
    }

    else
    {
      *a1 = SOSFullPeerInfoCreateFromDER(kCFAllocatorDefault, a2, &v12, a4);
      return v12;
    }
  }

  return result;
}

uint64_t sub_10019885C(CFTypeRef a1, uint64_t a2)
{
  CFTypeRef cf = 0LL;
  if (a1)
  {
    SecKeyCopyPublicBytes(a1, &cf);
    a1 = cf;
  }

  uint64_t v3 = der_sizeof_data_or_null(a1, a2);
  CFTypeRef v4 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v4);
  }

  return v3;
}

uint64_t sub_1001988B4(CFTypeRef a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef cf = 0LL;
  if (a1)
  {
    SecKeyCopyPublicBytes(a1, &cf);
    a1 = cf;
  }

  uint64_t v7 = der_encode_data_or_null(a1, a2, a3, a4);
  CFTypeRef v8 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v8);
  }

  return v7;
}

uint64_t sub_100198924(uint64_t a1, void *a2)
{
  CFTypeRef cf = 0LL;
  uint64_t v4 = der_decode_data_or_null(a1, &cf);
  uint64_t v5 = v4;
  CFTypeRef v6 = cf;
  if (a2 && v4 && cf)
  {
    *a2 = SecKeyCreateFromPublicData(a1, 3LL, cf);
    CFTypeRef v6 = cf;
  }

  if (v6)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v6);
  }

  return v5;
}

uint64_t sub_1001993FC(const void *a1, const void *a2, uint64_t a3)
{
  uint64_t v4 = sub_1001D5FDC(a1, 5, a3);
  uint64_t v5 = v4;
  if (v4 && a2) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v4 + 16), @"LastModifier", a2);
  }
  return v5;
}

uint64_t sub_100199444(void *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  CFTypeRef v8 = sub_1001B75A8(a3, a4);
  if (!v8) {
    return 0LL;
  }
  id v9 = v8;
  uint64_t v10 = sub_1001ABC40(a1, (uint64_t)v8, a2, (uint64_t)a4);
  CFRelease(v9);
  return v10;
}

void sub_1001994C8(void *a1)
{
  if (!a1)
  {
    id v1 = sub_10001267C("SecError");
    CFTypeRef v2 = (os_log_s *)objc_claimAutoreleasedReturnValue(v1);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_18;
    }
    __int16 v13 = 0;
    uint64_t v3 = "no ring passed in";
    uint64_t v4 = (uint8_t *)&v13;
LABEL_17:
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, v3, v4, 2u);
    goto LABEL_18;
  }

  if (!a1[2])
  {
    uint64_t v5 = sub_10001267C("SecError");
    CFTypeRef v2 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_18;
    }
    __int16 v12 = 0;
    uint64_t v3 = "ring has no unSignedInformation";
    uint64_t v4 = (uint8_t *)&v12;
    goto LABEL_17;
  }

  if (!a1[3])
  {
    CFTypeRef v6 = sub_10001267C("SecError");
    CFTypeRef v2 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_18;
    }
    __int16 v11 = 0;
    uint64_t v3 = "ring has no signedInformation";
    uint64_t v4 = (uint8_t *)&v11;
    goto LABEL_17;
  }

  if (!a1[4])
  {
    uint64_t v7 = sub_10001267C("SecError");
    CFTypeRef v2 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_18;
    }
    __int16 v10 = 0;
    uint64_t v3 = "ring has no signatures";
    uint64_t v4 = (uint8_t *)&v10;
    goto LABEL_17;
  }

  if (!a1[5])
  {
    CFTypeRef v8 = sub_10001267C("SecError");
    CFTypeRef v2 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v9 = 0;
      uint64_t v3 = "ring has no data";
      uint64_t v4 = (uint8_t *)&v9;
      goto LABEL_17;
    }

BOOL sub_10019964C(void *a1, uint64_t a2)
{
  int v3 = sub_1001D5AEC(a1);
  if (v3 != 5) {
    SOSCreateError(1040LL, @"Not recovery ring type", 0LL, a2);
  }
  return v3 == 5;
}

BOOL sub_10019969C(void *a1, uint64_t a2)
{
  id v3 = a1;
  id v4 = sub_100199708(v3, a2);
  if (v4)
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 trust]);
    [v5 generationSignatureUpdateWith:v3 key:v4];
  }

  return v4 != 0LL;
}

id sub_100199708(void *a1, uint64_t a2)
{
  id v3 = a1;
  if (![v3 accountPrivateKey]) {
    SOSCreateError(1LL, @"Private Key not available - failed to prompt user recently", 0LL, a2);
  }
  id v4 = [v3 accountPrivateKey];

  return v4;
}

void sub_100199760(void *a1)
{
  id v1 = a1;
  CFTypeRef v2 = sub_10001267C("circleOps");
  id v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Purging private account credential", v7, 2u);
  }

  if ([v1 accountPrivateKey]) {
    [v1 setAccountPrivateKey:0];
  }
  id v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "_password_tmp"));

  if (v4) {
    objc_msgSend(v1, "set_password_tmp:", 0);
  }
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "user_private_timer"));

  if (v5)
  {
    CFTypeRef v6 = (dispatch_source_s *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "user_private_timer"));
    dispatch_source_cancel(v6);

    objc_msgSend(v1, "setUser_private_timer:", 0);
    xpc_transaction_end();
  }

  if (objc_msgSend(v1, "lock_notification_token") != -1)
  {
    notify_cancel((int)objc_msgSend(v1, "lock_notification_token"));
    objc_msgSend(v1, "setLock_notification_token:", 0xFFFFFFFFLL);
  }
}

void sub_10019987C(void *a1)
{
  id v1 = a1;
  CFTypeRef v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "user_private_timer"));

  if (v2)
  {
    dispatch_time_t v3 = dispatch_time(0LL, 600000000000LL);
    id v4 = sub_10001267C("keygen");
    uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 134217984;
      uint64_t v8 = 10LL;
      _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Setting private credential purge time to %lld minutes",  (uint8_t *)&v7,  0xCu);
    }

    CFTypeRef v6 = (dispatch_source_s *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "user_private_timer"));
    dispatch_source_set_timer(v6, v3, 0xFFFFFFFFFFFFFFFFLL, 0x12A05F200uLL);
  }
}

void sub_100199990(void *a1)
{
  CFDataRef v1 = SecKeyCopyExternalRepresentation((SecKeyRef)[a1 accountPrivateKey], 0);
  CFDataRef v2 = v1;
  if (v1)
  {
    v23[0] = kSecClass;
    v23[1] = kSecAttrAccount;
    v24[0] = kSecClassInternetPassword;
    v24[1] = @"SOSUserCredential";
    void v23[2] = kSecAttrIsInvisible;
    void v23[3] = kSecAttrAccessible;
    void v24[2] = &__kCFBooleanTrue;
    v24[3] = kSecAttrAccessibleWhenUnlocked;
    uint64_t v3 = kSecAttrSysBound;
    v23[4] = kSecAttrAccessGroup;
    void v23[5] = kSecAttrSysBound;
    void v24[4] = @"com.apple.security.sos-usercredential";
    v24[5] = &off_1002AE010;
    v23[6] = kSecValueData;
    v24[6] = v1;
    id v4 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v24,  v23,  7LL));
    OSStatus v5 = SecItemAdd(v4, 0LL);
    if (v5)
    {
      OSStatus v6 = v5;
      if (v5 != -25299)
      {
        uint32_t v16 = sub_10001267C("circleOps");
        __int16 v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          int v17 = 67109120;
          OSStatus v18 = v6;
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Failed to add user private key to keychain: %d",  (uint8_t *)&v17,  8u);
        }

        int v7 = v4;
        goto LABEL_14;
      }

      v21[0] = kSecClass;
      v21[1] = kSecAttrAccount;
      v22[0] = kSecClassInternetPassword;
      v22[1] = @"SOSUserCredential";
      v21[2] = kSecAttrAccessGroup;
      v21[3] = kSecUseDataProtectionKeychain;
      void v22[2] = @"com.apple.security.sos-usercredential";
      v22[3] = &__kCFBooleanTrue;
      int v7 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v22,  v21,  4LL));

      v19[0] = kSecValueData;
      v19[1] = v3;
      v20[0] = v2;
      v20[1] = &off_1002AE010;
      OSStatus v8 = SecItemUpdate( v7,  (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v20,  v19,  2LL));
      if (v8)
      {
        OSStatus v9 = v8;
        __int16 v10 = sub_10001267C("circleOps");
        __int16 v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          int v17 = 67109120;
          OSStatus v18 = v9;
          __int16 v12 = "Failed to update user private key to keychain: %d";
          __int16 v13 = v11;
          uint32_t v14 = 8;
LABEL_10:
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v17, v14);
          goto LABEL_14;
        }

        goto LABEL_14;
      }
    }

    else
    {
      int v7 = v4;
    }

    id v15 = sub_10001267C("circleOps");
    __int16 v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v17) = 0;
      __int16 v12 = "Stored user private key stashed local keychain";
      __int16 v13 = v11;
      uint32_t v14 = 2;
      goto LABEL_10;
    }

SecKeyRef sub_100199C8C(__CFString **a1)
{
  CFTypeRef result = 0LL;
  v11[0] = kSecClass;
  v11[1] = kSecAttrAccount;
  v12[0] = kSecClassInternetPassword;
  v12[1] = @"SOSUserCredential";
  v11[2] = kSecAttrAccessGroup;
  v11[3] = kSecReturnData;
  v12[2] = @"com.apple.security.sos-usercredential";
  void v12[3] = &__kCFBooleanTrue;
  void v11[4] = kSecMatchLimit;
  void v12[4] = kSecMatchLimitOne;
  CFDataRef v2 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v12,  v11,  5LL));
  uint64_t v3 = SecItemCopyMatching(v2, &result);
  if ((_DWORD)v3)
  {
    sub_1000194E0(v3, a1, @"Failed fetching account credential: %d", v3);
    SecKeyRef v4 = 0LL;
  }

  else
  {
    v9[0] = kSecAttrKeyClass;
    v9[1] = kSecAttrKeyType;
    v10[0] = kSecAttrKeyClassPrivate;
    v10[1] = kSecAttrKeyTypeEC;
    OSStatus v5 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v10,  v9,  2LL));
    SecKeyRef v4 = SecKeyCreateWithData((CFDataRef)result, v5, (CFErrorRef *)a1);
    CFTypeRef v6 = result;
    if (result)
    {
      CFTypeRef result = 0LL;
      CFRelease(v6);
    }
  }

  return v4;
}

id sub_100199E38(void *a1, uint64_t a2)
{
  id v3 = a1;
  if ([v3 accountKey] && (objc_msgSend(v3, "accountKeyIsTrusted") & 1) != 0)
  {
    id v4 = [v3 accountKey];
  }

  else
  {
    SOSCreateError( 2LL,  @"Public Key isn't available. The iCloud Password must be provided to the syncing subsystem to repair this.",  0LL,  a2);
    id v4 = 0LL;
  }

  return v4;
}

uint64_t sub_100199EA4(void *a1, uint64_t a2, CFTypeRef *a3)
{
  id v5 = a1;
  id PublicFromPrivate = (id)SecKeyCreatePublicFromPrivate(a2);
  id v7 = [v5 accountKey];
  if (PublicFromPrivate && v7)
  {
    if (CFEqual(v7, PublicFromPrivate))
    {
      uint64_t v8 = 1LL;
LABEL_19:
      CFRelease(PublicFromPrivate);
      goto LABEL_20;
    }
  }

  else if (v7 == PublicFromPrivate)
  {
    uint64_t v8 = 1LL;
    if (!PublicFromPrivate) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }

  CFTypeRef cf = 0LL;
  OSStatus v9 = (const void *)SOSCopyIDOfKey([v5 accountKey], 0);
  __int16 v10 = (const void *)SOSCopyIDOfKey(PublicFromPrivate, 0LL);
  SOSCreateErrorWithFormat( 3LL,  0LL,  &cf,  0LL,  @"Password generated pubkey doesn't match - candidate: %@  known: %@");
  __int16 v11 = sub_10001267C("circleop");
  __int16 v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412546;
    int v17 = v10;
    __int16 v18 = 2112;
    CFTypeRef v19 = v9;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Password generated pubkey doesn't match - candidate: %@  known: %@",  buf,  0x16u);
  }

  CFTypeRef v13 = cf;
  if (a3)
  {
    *a3 = cf;
    CFTypeRef cf = 0LL;
  }

  else if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v13);
  }

  if (v9) {
    CFRelease(v9);
  }
  if (v10) {
    CFRelease(v10);
  }
  uint64_t v8 = 0LL;
  if (PublicFromPrivate) {
    goto LABEL_19;
  }
LABEL_20:

  return v8;
}

uint64_t sub_10019A050(void *a1, __CFString **a2)
{
  id v3 = a1;
  if (![v3 accountKey])
  {
    uint64_t v8 = @"account public key missing, can't check stashed copy";
LABEL_10:
    SOSCreateError(3LL, v8, 0LL, a2);
LABEL_14:
    uint64_t v6 = 0LL;
    goto LABEL_7;
  }

  if (([v3 accountKeyIsTrusted] & 1) == 0)
  {
    uint64_t v8 = @"public key no not valid, can't check stashed copy";
    goto LABEL_10;
  }

  SecKeyRef v4 = sub_100199C8C(a2);
  if (!v4)
  {
    OSStatus v9 = sub_10001267C("circleOps");
    __int16 v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int16 v11 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Looked for a stashed private key, didn't find one",  v11,  2u);
    }

    goto LABEL_14;
  }

  SecKeyRef v5 = v4;
  uint64_t v6 = sub_100199EA4(v3, (uint64_t)v4, (CFTypeRef *)a2);
  if ((_DWORD)v6) {
    sub_10019A160(v3, 0LL, (uint64_t)v5, 1);
  }
  CFRelease(v5);
LABEL_7:

  return v6;
}

void sub_10019A160(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  id v7 = a1;
  if ((sub_10019B9B8(v7, a3) & 1) == 0)
  {
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 trust]);
    id v9 = [v8 fullPeerInfo];
    if (v9) {
      SOSFullPeerInfoUpgradeSignatures(v9, a3, 0LL);
    }
  }

  id v10 = v7;
  id PublicFromPrivate = (const void *)SecKeyCreatePublicFromPrivate(a3);
  if ([v10 accountKey]
    && [v10 accountKeyIsTrusted]
    && CFEqual(PublicFromPrivate, [v10 accountKey]))
  {
    if (PublicFromPrivate) {
      CFRelease(PublicFromPrivate);
    }
  }

  else
  {
    if (a4 && [v10 accountKey]) {
      objc_msgSend(v10, "setPreviousAccountKey:", objc_msgSend(v10, "accountKey"));
    }
    [v10 setAccountKey:PublicFromPrivate];
    [v10 setAccountKeyIsTrusted:1];
    if (![v10 previousAccountKey]) {
      objc_msgSend(v10, "setPreviousAccountKey:", objc_msgSend(v10, "accountKey"));
    }
    if (PublicFromPrivate) {
      CFRelease(PublicFromPrivate);
    }
    __int16 v12 = (const void *)SOSCopyIDOfKeyWithLength([v10 accountKey], 8, 0);
    CFTypeRef v13 = sub_10001267C("circleOps");
    uint32_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = 138412290;
      uint32_t v16 = v12;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "trusting new public key: %@",  (uint8_t *)&v15,  0xCu);
    }

    if (v12) {
      CFRelease(v12);
    }
    notify_post("com.apple.security.publickeyavailable");
  }

  sub_10019A368(v10, a3, a2);
  sub_1001A279C(v10);
}

void sub_10019A368(void *a1, uint64_t a2, uint64_t a3)
{
  id v5 = a1;
  if (a2)
  {
    uint64_t v6 = sub_10001267C("circleOps");
    id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "setting new private userKey", buf, 2u);
    }

    [v5 setAccountPrivateKey:a2];
    if (!a3)
    {
      uint64_t v8 = sub_10001267C("circleOps");
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "no userKey password to save", buf, 2u);
      }

      objc_msgSend(v5, "set_password_tmp:", 0);
      goto LABEL_14;
    }
  }

  else
  {
    id v10 = sub_10001267C("circleOps");
    __int16 v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Purging private entities for userKey",  buf,  2u);
    }

    sub_100199760(v5);
    if (!a3)
    {
      uint64_t v23 = sub_10001267C("circleOps");
      uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "SOSAccountSetPrivateCredential nothing to save",  buf,  2u);
      }

      goto LABEL_17;
    }
  }

  __int16 v12 = sub_10001267C("circleOps");
  CFTypeRef v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "temporarily caching userKey password", buf, 2u);
  }

  uint32_t v14 = -[NSData initWithData:](objc_alloc(&OBJC_CLASS___NSData), "initWithData:", a3);
  objc_msgSend(v5, "set_password_tmp:", v14);

LABEL_14:
  int v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "user_private_timer"));

  if (!v15)
  {
    xpc_transaction_begin();
    uint32_t v16 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([v5 queue]);
    dispatch_source_t v17 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v16);
    objc_msgSend(v5, "setUser_private_timer:", v17);

    __int16 v18 = (dispatch_source_s *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "user_private_timer"));
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_10019A6D0;
    handler[3] = &unk_1002927F0;
    id v19 = v5;
    id v28 = v19;
    dispatch_source_set_event_handler(v18, handler);

    *(_DWORD *)__int128 buf = -1431655766;
    CFTypeRef v20 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([v19 queue]);
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472LL;
    void v24[2] = sub_10019A748;
    v24[3] = &unk_100291E20;
    id v21 = v19;
    id v25 = v21;
    notify_register_dispatch("com.apple.mobile.keybagd.lock_status", (int *)buf, v20, v24);

    objc_msgSend(v21, "setLock_notification_token:", *(unsigned int *)buf);
    sub_10019987C(v21);
    uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(objc_msgSend(v21, "user_private_timer"));
    dispatch_resume((dispatch_object_t)v22);
LABEL_17:

    goto LABEL_18;
  }

  sub_10019987C(v5);
LABEL_18:
}

void sub_10019A6D0(uint64_t a1)
{
  CFDataRef v2 = sub_10001267C("keygen");
  id v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)SecKeyRef v4 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Timing out, purging private account credential",  v4,  2u);
  }

  sub_100199760(*(void **)(a1 + 32));
}

void sub_10019A748(uint64_t a1)
{
  CFTypeRef v5 = 0LL;
  *(_DWORD *)__int128 buf = -1431655766;
  uint64_t v2 = sub_1000053C4(0, buf);
  if (sub_1000190E4(v2, &v5, @"aks_get_lock_state failed: %x", v2))
  {
    if ((buf[0] & 1) != 0) {
      sub_100199760(*(void **)(a1 + 32));
    }
  }

  else
  {
    id v3 = sub_10001267C("SecError");
    SecKeyRef v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v7 = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Checking for locked after change failed: %@",  buf,  0xCu);
    }
  }

uint64_t sub_10019A838(void *a1, const __CFData *a2, CFTypeRef *a3)
{
  id v5 = a1;
  if ([v5 accountKey])
  {
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 accountKeyDerivationParameters]);

    if (v6)
    {
      CFTypeRef v7 = (const __CFData *)objc_claimAutoreleasedReturnValue([v5 accountKeyDerivationParameters]);
      uint64_t v8 = (const void *)sub_100196A28(a2, v7, (uint64_t)a3);

      if (v8)
      {
        if ((sub_100199EA4(v5, (uint64_t)v8, a3) & 1) != 0)
        {

          sub_10019A160(v5, (uint64_t)a2, (uint64_t)v8, (int)[v5 accountKeyIsTrusted]);
          CFRelease(v8);
          uint64_t v9 = 1LL;
          goto LABEL_23;
        }

        CFRelease(v8);
      }
    }
  }

  id v10 = (void *)objc_claimAutoreleasedReturnValue([v5 accountKeyDerivationParameters]);
  if (v10)
  {
    CFTypeRef v20 = 0LL;
    CFTypeRef cf = 0LL;
    __int16 v11 = (const __CFData *)objc_claimAutoreleasedReturnValue([v5 accountKeyDerivationParameters]);
    BOOL v12 = sub_100197924(&cf, v11, (uint64_t)&v20);

    if (v12)
    {
      sub_1001965A8((uint64_t)@"sosAccountValidatePasswordOrFail", (CFDataRef)v20);
    }

    else
    {
      CFTypeRef v13 = sub_10001267C("circleOps");
      uint32_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v23 = 0LL;
        _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Failed to retrieve cloud parameters - %@",  buf,  0xCu);
      }

      if (a3)
      {
        if (*a3) {
          CFRelease(*a3);
        }
        *a3 = 0LL;
      }
    }

    CFTypeRef v15 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v15);
    }

    CFTypeRef v16 = v20;
    if (v20)
    {
      CFTypeRef v20 = 0LL;
      CFRelease(v16);
    }
  }

  SOSCreateError(3LL, @"Could not create correct key with password.", 0LL, a3);
  dispatch_source_t v17 = sub_10001267C("circleOps");
  __int16 v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Failed to create correct key with password.  Caching for use with KeyParam refreshes",  buf,  2u);
  }

  sub_10019A368(v5, 0LL, (uint64_t)a2);
  uint64_t v9 = 0LL;
LABEL_23:

  return v9;
}

uint64_t sub_10019AAC0(void *a1, uint64_t a2, const __CFData *a3, CFTypeRef *a4)
{
  id v7 = a1;
  uint64_t v8 = sub_10019A838(v7, a3, a4);
  if ((_DWORD)v8)
  {
    sub_100199990(v7);
    sub_1001A93D0(v7, (uint64_t)@"AccountName", a2, 0LL);
  }

  uint64_t v9 = sub_10001267C("circleop");
  id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)BOOL v12 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Setting account.key_interests_need_updating to true in SOSAccountTryUserCredentials",  v12,  2u);
  }

  objc_msgSend(v7, "setKey_interests_need_updating:", 1);
  return v8;
}

uint64_t sub_10019AB90(const void *a1, const void *a2, uint64_t a3)
{
  uint64_t v4 = sub_1001D5FDC(a1, 0, a3);
  uint64_t v5 = v4;
  if (v4 && a2) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v4 + 16), @"LastModifier", a2);
  }
  return v5;
}

BOOL sub_10019ABD8(uint64_t a1, const void *a2)
{
  if (a2) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"LastModifier", a2);
  }
  return a2 != 0LL;
}

uint64_t sub_10019AC1C(uint64_t a1, __SecKey *a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t PeerInfo = SOSFullPeerInfoGetPeerInfo(a3);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(PeerInfo);
  id v10 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey(a3, a4);
  uint64_t v11 = 0LL;
  if (v10 && PeerID)
  {
    sub_1001D6480(a1);
    sub_1001D5EC0(a1, PeerID);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"LastModifier", PeerID);
    uint64_t v11 = sub_1001D6800(a1, v10, a4);
  }

  if (a2 && a1) {
    sub_1001D68E4(a1, a2, a4);
  }
  if (v10) {
    CFRelease(v10);
  }
  return v11;
}

uint64_t sub_10019ACE4(uint64_t a1, const void *a2)
{
  if (sub_1001D5D68(a1, a2)) {
    return 0LL;
  }
  if (sub_1001D5BBC(a1, a2)) {
    return 2LL;
  }
  if (sub_1001D5C08(a1, a2)) {
    return 3LL;
  }
  return 1LL;
}

uint64_t sub_10019AD44(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t PeerInfo = SOSFullPeerInfoGetPeerInfo(a3);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(PeerInfo);
  uint64_t v9 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey(a3, a4);
  if (sub_10019ACE4(a1, PeerID) != 1)
  {
    uint64_t v11 = sub_10001267C("ring");
    BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint32_t v14 = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Already associated with ring", v14, 2u);
    }

LABEL_8:
    uint64_t v10 = 0LL;
    uint64_t result = 0LL;
    if (!v9) {
      return result;
    }
    goto LABEL_9;
  }

  if (!v9 || !PeerID) {
    goto LABEL_8;
  }
  sub_1001D5EC0(a1, PeerID);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"LastModifier", PeerID);
  uint64_t v10 = sub_1001D6800(a1, v9, a4);
LABEL_9:
  CFRelease(v9);
  return v10;
}

uint64_t sub_10019AE50(uint64_t a1, __SecKey *a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t PeerInfo = SOSFullPeerInfoGetPeerInfo(a3);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(PeerInfo);
  if (sub_1001D5D68(a1, PeerID))
  {
    sub_1001D5570((void *)a1);
    signed int Value = (__CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"PeerIDs");
    if (!Value || (uint64_t v11 = Value, v12 = CFGetTypeID(Value), v12 != CFSetGetTypeID())) {
      uint64_t v11 = 0LL;
    }
    CFTypeRef v13 = v11;
LABEL_8:
    CFSetRemoveValue(v13, PeerID);
    if (!PeerID) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }

  if (sub_1001D5BBC(a1, PeerID))
  {
    sub_1001D5570((void *)a1);
    CFTypeRef v13 = (__CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"Applicants");
    goto LABEL_8;
  }

  if (!sub_1001D5C08(a1, PeerID))
  {
    SOSCreateError(1032LL, @"Not associated with Ring", 0LL, a4);
    return 0LL;
  }

  sub_1001D5C54(a1, PeerID);
  if (PeerID) {
LABEL_9:
  }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"LastModifier", PeerID);
LABEL_10:
  uint32_t v14 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey(a3, a4);
  sub_1001D6800(a1, v14, a4);
  if (a2 && a1) {
    sub_1001D68E4(a1, a2, a4);
  }
  if (v14) {
    CFRelease(v14);
  }
  return 1LL;
}

uint64_t sub_10019AFC4(uint64_t a1, __SecKey *a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t PeerInfo = SOSFullPeerInfoGetPeerInfo(a3);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(PeerInfo);
  uint64_t v10 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey(a3, a4);
  uint64_t v11 = 0LL;
  if (v10 && PeerID)
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"LastModifier", PeerID);
    uint64_t v11 = sub_1001D6800(a1, v10, a4);
  }

  if (a2 && a1) {
    sub_1001D68E4(a1, a2, a4);
  }
  if (v10) {
    CFRelease(v10);
  }
  return v11;
}

uint64_t sub_10019B078(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t PeerInfo = SOSFullPeerInfoGetPeerInfo(a2);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(PeerInfo);
  uint64_t v8 = SOSFullPeerInfoCopyDeviceKey(a2, a3);
  uint64_t v9 = (__SecKey *)v8;
  if (v8) {
    BOOL v10 = PeerID == 0LL;
  }
  else {
    BOOL v10 = 1;
  }
  uint64_t v11 = !v10;
  if (v10)
  {
    if (!v8) {
      return 0LL;
    }
  }

  else
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"LastModifier", PeerID);
    sub_1001D68E4(a1, v9, a3);
  }

  CFRelease(v9);
  return v11;
}

uint64_t sub_10019B11C(uint64_t a1, __SecKey *a2, const void *a3, uint64_t a4, CFTypeRef *a5)
{
  uint64_t PeerInfo = SOSFullPeerInfoGetPeerInfo(a4);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(PeerInfo);
  CFTypeID v12 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey(a4, a5);
  uint64_t v13 = 0LL;
  if (v12 && PeerID)
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"LastModifier", PeerID);
    sub_1001D5570((void *)a1);
    if (!a3)
    {
      uint64_t v13 = 0LL;
      if (!a2) {
        goto LABEL_8;
      }
      goto LABEL_6;
    }

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Payload", a3);
    uint64_t v13 = sub_1001D6800(a1, v12, a5);
  }

  if (!a2) {
    goto LABEL_8;
  }
LABEL_6:
  if (a1) {
    sub_1001D68E4(a1, a2, a5);
  }
LABEL_8:
  if (v12) {
    CFRelease(v12);
  }
  return v13;
}

const void *sub_10019B208(uint64_t a1)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"Payload");
}

void sub_10019B6B0(uint64_t a1, const void *a2)
{
  if (a2
    && (!SOSPeerInfoIsRetirementTicket(a2)
     || SOSPeerInfoRetireRetirementTicket(*(void *)(a1 + 32), a2)
     && (SOSCircleHasActivePeer(*(void *)(a1 + 40), a2, 0LL) & 1) == 0))
  {
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 48), a2);
  }

uint64_t sub_10019B718(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_10019B72C(uint64_t a1, const void *a2)
{
  uint64_t v4 = (__CFSet *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) retirees]);
  CFSetRemoveValue(v4, a2);
}

SecKeyRef sub_10019B778(int a1, uint64_t a2, uint64_t a3, uint64_t a4, CFErrorRef *a5)
{
  int valuePtr = a1;
  SecKeyRef privateKey = 0LL;
  CFNumberRef v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  CFDictionaryRef v14 = sub_100107FA8( kCFAllocatorDefault,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  (uint64_t)kSecAttrIsPermanent,  (uint64_t)kCFBooleanTrue);
  uint64_t v22 = sub_100107FA8( kCFAllocatorDefault,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  (uint64_t)kSecAttrKeyType,  (uint64_t)kSecAttrKeyTypeEC);
  if (v14) {
    CFRelease(v14);
  }
  if (v6) {
    CFRelease(v6);
  }
  OSStatus v23 = SecKeyGeneratePair(v22, 0LL, &privateKey);
  if (v22) {
    CFRelease(v22);
  }
  if (v23)
  {
    uint64_t v24 = sub_10001267C("SecError");
    id v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      uint64_t v30 = v23;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "status: %ld", buf, 0xCu);
    }

    if (a5 && !*a5) {
      *a5 = CFErrorCreate(kCFAllocatorDefault, kCFErrorDomainOSStatus, v23, 0LL);
    }
  }

  return privateKey;
}

uint64_t sub_10019B9B8(void *a1, uint64_t a2)
{
  id v3 = (void *)objc_claimAutoreleasedReturnValue([a1 trust]);
  id v4 = [v3 fullPeerInfo];
  if (v4)
  {
    id v5 = v4;
    id PublicFromPrivate = (const void *)SecKeyCreatePublicFromPrivate(a2);
    uint64_t PeerInfo = SOSFullPeerInfoGetPeerInfo(v5);
    uint64_t v8 = SOSPeerInfoApplicationVerify(PeerInfo, PublicFromPrivate, 0LL);
    if (PublicFromPrivate) {
      CFRelease(PublicFromPrivate);
    }
  }

  else
  {
    uint64_t v8 = 0LL;
  }

  return v8;
}

uint64_t sub_10019BA34(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a1;
  uint64_t v8 = a4;
  if (!v8[2](v8, [v7 fullPeerInfo], a3))
  {
    uint64_t v12 = 0LL;
    goto LABEL_8;
  }

  int v9 = (void *)objc_claimAutoreleasedReturnValue([v7 trust]);
  if (![v9 trustedCircle])
  {
    SOSCreateErrorWithFormat(1037LL, 0LL, 0LL, 0LL, @"No trusted circle");

LABEL_7:
    uint64_t v12 = 1LL;
    goto LABEL_8;
  }

  int v10 = (void *)objc_claimAutoreleasedReturnValue([v7 trust]);
  int v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "circle_transport"));
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472LL;
  v14[2] = sub_10019BB84;
  v14[3] = &unk_100292EF0;
  uint64_t v16 = a2;
  id v15 = v7;
  uint64_t v12 = (uint64_t)[v10 modifyCircle:v11 err:a3 action:v14];

LABEL_8:
  return v12;
}

uint64_t sub_10019BB84(uint64_t a1, uint64_t a2)
{
  id v4 = sub_10001267C("circleChange");
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 40);
    int v8 = 138412290;
    uint64_t v9 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Calling SOSCircleUpdatePeerInfo for %@",  (uint8_t *)&v8,  0xCu);
  }

  return SOSCircleUpdatePeerInfo(a2, [*(id *)(a1 + 32) peerInfo]);
}

uint64_t sub_10019BC50(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  void v10[2] = sub_10019BCE8;
  v10[3] = &unk_100291EB8;
  id v11 = a4;
  uint64_t v12 = a3;
  id v7 = v11;
  uint64_t v8 = sub_10019BA34(a1, a2, a3, v10);

  return v8;
}

uint64_t sub_10019BCE8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  void v10[2] = sub_10019BD78;
  v10[3] = &unk_100291E90;
  id v6 = *(id *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 40);
  id v11 = v6;
  uint64_t v12 = v7;
  uint64_t v8 = SOSFullPeerInfoUpdate(a2, a3, v10);

  return v8;
}

const void *sub_10019BD78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFDataRef Copy = (const void *)SOSPeerInfoCreateCopy(kCFAllocatorDefault, a2, a4);
  int v8 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  if (a3 && v8 && SOSPeerInfoSign(a3, Copy, a4))
  {
    uint64_t v9 = sub_10001267C("circleOp");
    int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Signed Peerinfo to update", buf, 2u);
    }
  }

  else
  {
    id v11 = sub_10001267C("circleOp");
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFDictionaryRef v14 = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Failed updating PeerInfo", v14, 2u);
    }

    if (Copy)
    {
      CFRelease(Copy);
      return 0LL;
    }
  }

  return Copy;
}

void sub_10019BEA0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_10019BFC4;
  void v5[3] = &unk_100291EE0;
  id v6 = *(id *)(a1 + 32);
  uint64_t v7 = a3;
  SOSCircleForEachPeer(a2, v5);
}

CFMutableArrayRef sub_10019BF14(void *a1, uint64_t a2, void *a3)
{
  id v5 = a1;
  id v6 = a3;
  if (sub_100199E38(v5, a2))
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
    int v8 = (void *)objc_claimAutoreleasedReturnValue([v5 trust]);
    v6[2](v6, [v8 trustedCircle], Mutable);
    CFArrayOfSOSPeerInfosSortByID(Mutable);
  }

  else
  {
    CFMutableArrayRef Mutable = 0LL;
  }

  return Mutable;
}

void sub_10019BFC4(uint64_t a1, uint64_t a2)
{
  if ((SOSPeerInfoApplicationVerify(a2, [*(id *)(a1 + 32) accountKey], 0) & 1) == 0) {
    sub_10019C014(*(__CFArray **)(a1 + 40), a2);
  }
}

void sub_10019C014(__CFArray *a1, uint64_t a2)
{
  CFDataRef Copy = (const void *)SOSPeerInfoCreateCopy(kCFAllocatorDefault, a2, 0LL);
  CFArrayAppendValue(a1, Copy);
  CFRelease(Copy);
}

void sub_10019C058(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_10019C0CC;
  void v5[3] = &unk_100291EE0;
  id v6 = *(id *)(a1 + 32);
  uint64_t v7 = a3;
  SOSCircleForEachPeer(a2, v5);
}

void sub_10019C0CC(uint64_t a1, uint64_t a2)
{
}

void sub_10019C11C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_10019C1A0;
  void v7[3] = &unk_100291F30;
  __int128 v6 = *(_OWORD *)(a1 + 32);
  id v5 = (id)v6;
  __int128 v8 = v6;
  uint64_t v9 = a3;
  SOSCircleForEachPeer(a2, v7);
}

void sub_10019C1A0(uint64_t a1, const void *a2)
{
  id v4 = *(const void **)(a1 + 40);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(a2);
  if (v4) {
    BOOL v6 = PeerID == 0LL;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if (v4 == PeerID) {
      return;
    }
  }

  else if (CFEqual(v4, PeerID))
  {
    return;
  }

  if (SOSPeerInfoApplicationVerify(a2, [*(id *)(a1 + 32) accountKey], 0))
  {
    if ((SOSPeerInfoIsRetirementTicket(a2) & 1) == 0) {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), a2);
    }
  }

void sub_10019C23C(id a1, __OpaqueSOSCircle *a2, __CFArray *a3)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_10019C290;
  v3[3] = &unk_100292840;
  void v3[4] = a3;
  SOSCircleForEachRetiredPeer(a2, v3);
}

void sub_10019C290(uint64_t a1, uint64_t a2)
{
}

void sub_10019C298(id a1, __OpaqueSOSCircle *a2, __CFArray *a3)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_10019C2EC;
  v3[3] = &unk_100292840;
  void v3[4] = a3;
  SOSCircleForEachPeer(a2, v3);
}

void sub_10019C2EC(uint64_t a1, uint64_t a2)
{
  if ((SOSPeerInfoVersionHasV2Data(a2) & 1) == 0) {
    sub_10019C014(*(__CFArray **)(a1 + 32), a2);
  }
}

void sub_10019C32C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_10019C3A0;
  void v5[3] = &unk_100291EE0;
  id v6 = *(id *)(a1 + 32);
  uint64_t v7 = a3;
  SOSCircleForEachPeer(a2, v5);
}

void sub_10019C3A0(uint64_t a1, uint64_t a2)
{
  if ((SOSPeerInfoVersionHasV2Data(a2) & 1) == 0)
  {
  }

void sub_10019C3FC(id a1, __OpaqueSOSCircle *a2, __CFArray *a3)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_10019C450;
  v3[3] = &unk_100292840;
  void v3[4] = a3;
  SOSCircleForEachApplicant(a2, v3);
}

void sub_10019C450(uint64_t a1, uint64_t a2)
{
}

void sub_10019C458(id a1, __OpaqueSOSCircle *a2, __CFArray *a3)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_10019C4AC;
  v3[3] = &unk_100292840;
  void v3[4] = a3;
  SOSCircleForEachPeer(a2, v3);
}

void sub_10019C4AC(uint64_t a1, uint64_t a2)
{
}

void sub_10019C4B4(id a1, __OpaqueSOSCircle *a2, __CFArray *a3)
{
}

void sub_10019C4C4(uint64_t a1, uint64_t a2)
{
  if (SOSPeerInfoApplicationVerify(a2, [*(id *)(a1 + 32) accountKey], 0))
  {
    id v4 = (const __CFSet *)SOSPeerInfoCopyEnabledViews(a2);
    uint64_t v5 = *(void *)(a1 + 40);
    context[0] = _NSConcreteStackBlock;
    context[1] = 3221225472LL;
    uint64_t context[2] = sub_10019C564;
    context[3] = &unk_100293EA8;
    context[4] = v5;
    CFSetApplyFunction(v4, (CFSetApplierFunction)sub_10019C56C, context);
    if (v4) {
      CFRelease(v4);
    }
  }

void sub_10019C564(uint64_t a1, const void *a2)
{
}

uint64_t sub_10019C56C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

id sub_10019C624(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) trust]);
  id v7 = [v6 encodeToDER:*(void *)(a1 + 32) err:*(void *)(a1 + 40) start:a3 end:a3 + a2];

  return v7;
}

LABEL_96:
    CFTypeRef v33 = 0LL;
    *a6 = (id)(id)v85;
    return v33;
  }

  __int128 v48 = v88;
  cf[0] = 0LL;
  __int128 v49 = (const char *)sub_1000126F8(kCFAllocatorDefault, (CFMutableDictionaryRef *)cf, &v85, (uint64_t)v10, (uint64_t)v88);
  *a3 = v49;
  if (!v49) {
    goto LABEL_95;
  }
  id v50 = cf[0];
  id v51 = sub_100190D30((uint64_t)cf[0], (uint64_t)a5);
  id v15 = (void *)objc_claimAutoreleasedReturnValue(v51);
  if (v50) {
    CFRelease(v50);
  }
  id v52 = (void *)objc_claimAutoreleasedReturnValue([v15 trust]);
  uint64_t v53 = (const void *)SOSCircleCreateFromDER(kCFAllocatorDefault, &v85, a3, v48);
  [v52 setTrustedCircle:v53];
  if (v53) {
    CFRelease(v53);
  }
  cf[0] = 0LL;
  *a3 = (const char *)sub_100198794(cf, (uint64_t)&v85, (uint64_t)*a3, (uint64_t)v48);
  [v52 setFullPeerInfo:cf[0]];
  __int16 v54 = cf[0];
  if (cf[0])
  {
    cf[0] = 0LL;
    CFRelease(v54);
  }

  cf[0] = (CFTypeRef)5;
  id v55 = (const char *)ccder_decode_uint64(cf, *a3, v48);
  *a3 = v55;
  buf[0] = -86;
  *a3 = (const char *)sub_100018C70((BOOL *)buf, (uint64_t)v55, (uint64_t)v48);
  [v15 setAccountKeyIsTrusted:buf[0]];
  context[0] = 0LL;
  *a3 = (const char *)sub_100198924((uint64_t)kCFAllocatorDefault, context);
  [v15 setAccountKey:context[0]];
  uint64_t v56 = context[0];
  if (context[0])
  {
    context[0] = 0LL;
    CFRelease(v56);
  }

  context[0] = 0LL;
  *a3 = (const char *)sub_100198924((uint64_t)kCFAllocatorDefault, context);
  [v15 setPreviousAccountKey:context[0]];
  id v57 = context[0];
  if (context[0])
  {
    context[0] = 0LL;
    CFRelease(v57);
  }

  context[0] = 0LL;
  *a3 = (const char *)der_decode_data_or_null(kCFAllocatorDefault, context);
  __int16 v58 = (void *)context[0];
  [v15 setAccountKeyDerivationParameters:context[0]];

  objc_msgSend( v52,  "setRetirees:",  SOSPeerInfoSetCreateFromArrayDER(kCFAllocatorDefault, &kSOSPeerSetCallbacks, &v85, a3, v48));
  context[0] = 0LL;
  dispatch_semaphore_t v59 = *a3;
  CFTypeRef v60 = sub_10001A6E4(kCFAllocatorDefault, (CFDataRef *)context, 0LL, (uint64_t)*a3, (uint64_t)v48);
  if (v60) {
    __int128 v61 = (const char *)v60;
  }
  else {
    __int128 v61 = v59;
  }
  *a3 = v61;
  id v62 = (void *)context[0];
  if (context[0])
  {
    objc_msgSend(v15, "setBackup_key:", context[0]);
  }

  [v52 setDepartureCode:LODWORD(cf[0])];
  if (*a3 && *a3 == v48)
  {
    __int128 v63 = v15;
  }

  else
  {
    SOSCreateError(1035LL, @"Didn't consume all bytes v7", v85, &v85);
    __int128 v63 = 0LL;
  }

  CFTypeRef v47 = (const __CFArray *)v63;

LABEL_91:
  if (!v47) {
    goto LABEL_95;
  }
LABEL_92:
  if (*a3 != v88)
  {
    id v69 = v85;
    char v70 = @"Extra data at the end of saved acount";
LABEL_94:
    SOSCreateError(1035LL, v70, v69, &v85);

    goto LABEL_95;
  }

  unsigned int v72 = -[__CFArray fullPeerInfo](v47, "fullPeerInfo");
  if (!v72)
  {
LABEL_102:
    if ((-[__CFArray ensureFactoryCircles](v47, "ensureFactoryCircles") & 1) != 0)
    {
      id v75 = -[__CFArray peerInfo](v47, "peerInfo");
      if (v75)
      {
        id v76 = v75;
        CFRetain(v75);
        CFRelease(v76);
      }

      v86[0] = _NSConcreteStackBlock;
      v86[1] = 3221225472LL;
      v86[2] = sub_10019D57C;
      v86[3] = &unk_100293CA0;
      uint64_t v77 = v47;
      id v87 = v77;
      -[__CFArray performTransaction:](v77, "performTransaction:", v86);
      char v78 = sub_1001A9474(v77);
      if (v78) {
        CFRelease(v78);
      }
      -[__CFArray sosEvaluateIfNeeded](v77, "sosEvaluateIfNeeded");
      char v79 = v87;
      CFTypeRef v33 = v77;

      goto LABEL_31;
    }

    id v69 = v85;
    char v70 = @"Cannot EnsureFactoryCircles";
    goto LABEL_94;
  }

  id v73 = v72;
  if ((SOSFullPeerInfoPrivKeyExists() & 1) != 0)
  {
    char v74 = (const void *)SOSFullPeerInfoCopyPubKey(v73, 0LL);
    -[__CFArray setPeerPublicKey:](v47, "setPeerPublicKey:", v74);
    if (v74) {
      CFRelease(v74);
    }
    goto LABEL_102;
  }

  id v80 = (void *)objc_claimAutoreleasedReturnValue(-[__CFArray key_transport](v47, "key_transport"));
  sub_1001B5054(v80);

  unint64_t v81 = (void *)objc_claimAutoreleasedReturnValue(-[__CFArray circle_transport](v47, "circle_transport"));
  sub_1001B4FCC(v81);

  id v82 = (void *)objc_claimAutoreleasedReturnValue(-[__CFArray kvs_message_transport](v47, "kvs_message_transport"));
  sub_1001B4F14(v82);

  id v83 = sub_10001267C("account");
  uint64_t v84 = (os_log_s *)objc_claimAutoreleasedReturnValue(v83);
  if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(cf[0]) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v84,  OS_LOG_TYPE_DEFAULT,  "No private key associated with my_identity, resetting",  (uint8_t *)cf,  2u);
  }

  if (a6) {
    goto LABEL_96;
  }
LABEL_30:
  CFTypeRef v33 = 0LL;
LABEL_31:
  uint64_t v34 = v85;
  if (v85)
  {
    uint64_t v85 = 0LL;
    CFRelease(v34);
  }

  return v33;
}

void sub_10019D350(uint64_t a1, int a2, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 == CFDataGetTypeID())
    {
      id v6 = (const void *)SOSPeerInfoCreateFromData(kCFAllocatorDefault, 0LL, cf);
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 32), v6);
      if (v6) {
        CFRelease(v6);
      }
    }
  }

uint64_t sub_10019D3D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_10019D3EC(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFDataGetTypeID())
    {
      CFTypeID v5 = 0LL;
      CFTypeRef ValueAtIndex = cf;
    }

    else
    {
      CFTypeID v11 = CFGetTypeID(cf);
      if (v11 != CFArrayGetTypeID()) {
        return;
      }
      CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, 0LL);
      CFTypeID v5 = CFArrayGetValueAtIndex((CFArrayRef)cf, 1LL);
      if (CFArrayGetCount((CFArrayRef)cf) != 2) {
        return;
      }
      if (!ValueAtIndex) {
        return;
      }
      CFTypeID v12 = CFGetTypeID(ValueAtIndex);
      if (v12 != CFDataGetTypeID()) {
        return;
      }
      if (!v5) {
        return;
      }
      CFTypeID v13 = CFGetTypeID(v5);
      if (v13 != CFDataGetTypeID()) {
        return;
      }
    }

    uint64_t v7 = SOSCircleCreateFromData(kCFAllocatorDefault, ValueAtIndex, *(void *)(a1 + 40));
    if (!v7) {
      return;
    }
    __int128 v8 = (const void *)v7;
    uint64_t v9 = *(const void **)(a1 + 48);
    Name = (const void *)SOSCircleGetName(v7);
    if (v9 && Name)
    {
      if (!CFEqual(v9, Name)) {
        goto LABEL_19;
      }
    }

    else if (v9 != Name)
    {
LABEL_19:
      CFRelease(v8);
      return;
    }

    [*(id *)(a1 + 32) setTrustedCircle:v8];
    CFRelease(v8);
    if (v5)
    {
      __int128 v8 = (const void *)SOSFullPeerInfoCreateFromData(kCFAllocatorDefault, v5, 0LL);
      [*(id *)(a1 + 32) setFullPeerInfo:v8];
      if (v8) {
        goto LABEL_19;
      }
    }
  }

uint64_t sub_10019D568(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

id sub_10019D57C(uint64_t a1)
{
  uint64_t v2 = sub_10001267C("circleop");
  id v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFTypeID v5 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Setting account.key_interests_need_updating to true in SOSAccountCreateFromDER",  v5,  2u);
  }

  return objc_msgSend(*(id *)(a1 + 32), "setKey_interests_need_updating:", 1);
}

id sub_10019D600(void *a1, const void *a2)
{
  id v3 = a1;
  id v4 = (id)objc_claimAutoreleasedReturnValue([v3 trust]);

  if (v4)
  {
    CFTypeID v5 = (void *)objc_claimAutoreleasedReturnValue([v3 trust]);
    id v4 = [v5 copyRing:a2 err:0];

    if (v4)
    {
      CFTypeID v6 = CFGetTypeID(v4);
      if (v6 != sub_1001D4F80())
      {
        uint64_t v7 = sub_10001267C("SecError");
        __int128 v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          int v12 = 138412290;
          id v13 = v4;
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Non ring in ring table: %@, purging!",  (uint8_t *)&v12,  0xCu);
        }

        uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v3 trust]);
        int v10 = (__CFDictionary *)[v9 getRings:0];

        if (v10) {
          CFDictionaryRemoveValue(v10, a2);
        }
        CFRelease(v4);
        id v4 = 0LL;
      }
    }
  }

  return v4;
}

uint64_t sub_10019D758(void *a1, uint64_t a2, const void **a3, void *a4, void *a5)
{
  id v9 = a1;
  int v10 = a4;
  CFTypeID v11 = a5;
  if (([v9 isInCircle:0] & 1) == 0)
  {
    SOSErrorCreate(1037LL, a3, 0LL, @"Not in circle, won't update ring");
LABEL_12:
    uint64_t v18 = 0LL;
    goto LABEL_13;
  }

  int v12 = (void *)objc_claimAutoreleasedReturnValue([v9 trust]);
  id v13 = [v12 copyRing:a2 err:a3];

  if (!v13)
  {
    id v13 = (id)v10[2](v10, a2, a3);
    if (!v13) {
      goto LABEL_12;
    }
  }

  uint64_t v14 = v11[2](v11, v13, a3);
  if (!v14)
  {
    CFRelease(v13);
    goto LABEL_12;
  }

  id v15 = (const void *)v14;
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v9 trust]);
  int v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "circle_transport"));
  uint64_t v18 = (uint64_t)objc_msgSend( v16,  "handleUpdateRing:prospectiveRing:transport:userPublicKey:writeUpdate:err:",  v9,  v15,  v17,  objc_msgSend(v9, "accountKey"),  1,  a3);

  CFRelease(v13);
  CFRelease(v15);
  if (a3 && (_DWORD)v18)
  {
    int v19 = *a3;
    if (*a3)
    {
      *a3 = 0LL;
      CFRelease(v19);
    }

    uint64_t v18 = 1LL;
  }

LABEL_109:
    if (!v102)
    {
      id v107 = 0;
      id v100 = v108;
      goto LABEL_115;
    }

    dword_1002DED98 = 0;
    id v112 = sub_10001267C("secdNotify");
    id v106 = (os_log_s *)objc_claimAutoreleasedReturnValue(v112);
    id v100 = v108;
    if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v106,  OS_LOG_TYPE_DEFAULT,  "Notified clients of kSOSCCCircleChangedNotification for userKey change",  (uint8_t *)&buf,  2u);
    }

    id v107 = 0;
    goto LABEL_113;
  }

  dword_1002DED98 = 0;
  id v105 = sub_10001267C("secdNotify");
  id v106 = (os_log_s *)objc_claimAutoreleasedReturnValue(v105);
  if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v106,  OS_LOG_TYPE_DEFAULT,  "Notified clients of kSOSCCCircleChangedNotification && kSOSCCViewMembershipChangedNotification for circle/view change",  (uint8_t *)&buf,  2u);
  }

  id v107 = 1;
LABEL_113:
  id v4 = 1;
LABEL_114:

LABEL_115:
  __int128 v113 = v101;
  if (!-[SOSAccountTransaction initialTrusted](self, "initialTrusted")
    || ((!-[SOSAccountTransaction initialInCircle](self, "initialInCircle") | v100) & 1) != 0
    || (__int128 v114 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](self, "account")),
        __int128 v115 = [v114 accountKeyIsTrusted],
        v114,
        (v115 & 1) != 0))
  {
    id v116 = v175;
    if (-[SOSAccountTransaction initialTrusted](self, "initialTrusted"))
    {
      if ((v4 & 1) == 0) {
        goto LABEL_140;
      }
LABEL_131:
      -[SOSAccountTransaction updateSOSCircleCachedStatus](self, "updateSOSCircleCachedStatus");
      __int128 v124 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](self, "account"));
      [v124 sosEvaluateIfNeeded];

      if ((v107 & 1) == 0) {
        goto LABEL_133;
      }
      goto LABEL_132;
    }
  }

  else
  {
    id v117 = sub_10001267C("userKeyTrust");
    __int128 v118 = (os_log_s *)objc_claimAutoreleasedReturnValue(v117);
    id v116 = v175;
    if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v118,  OS_LOG_TYPE_DEFAULT,  "No longer trust user public key - prompting for password.",  (uint8_t *)&buf,  2u);
    }

    notify_post("com.apple.security.publickeynotavailable");
    dword_1002DED98 = 0;
    if (-[SOSAccountTransaction initialTrusted](self, "initialTrusted")) {
      goto LABEL_131;
    }
    id v4 = 1;
  }

  __int128 v119 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](self, "account"));
  __int128 v120 = [v119 accountKeyIsTrusted] & v87;

  if (v120 == 1)
  {
    id v121 = sub_10001267C("userKeyTrust");
    __int128 v122 = (os_log_s *)objc_claimAutoreleasedReturnValue(v121);
    if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v122,  OS_LOG_TYPE_DEFAULT,  "UserKey is once again trusted and we're valid in circle.",  (uint8_t *)&buf,  2u);
    }

    -[SOSAccountTransaction updateSOSCircleCachedStatus](self, "updateSOSCircleCachedStatus");
    __int128 v123 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](self, "account"));
    [v123 sosEvaluateIfNeeded];

    goto LABEL_132;
  }

  if (v4) {
    goto LABEL_131;
  }
LABEL_140:
  if (v107) {
LABEL_132:
  }
    sub_10019F6C4(self->_account);
LABEL_133:
  id v125 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](self, "account"));
  unint64_t v126 = [v125 notifyBackupOnExit];

  if (v126)
  {
    notify_post("com.apple.security.itembackup");
    char v127 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](self, "account"));
    [v127 setNotifyBackupOnExit:0];
  }

  char v128 = dword_1002DED98;
  if (dword_1002DED98 <= 0)
  {
    id v173 = v113;
    id v129 = (id)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](self, "account"));
    uint64_t v130 = sub_10001267C("accountLogState");
    unint64_t v131 = (os_log_s *)objc_claimAutoreleasedReturnValue(v130);
    if (os_log_type_enabled(v131, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_DEFAULT, "Start", (uint8_t *)&buf, 2u);
    }

    char v132 = v129;
    char v133 = [v132 accountKey];
    unsigned int v134 = [v132 accountKeyIsTrusted];
    id v135 = [v132 accountPrivateKey];
    id v171 = SOSVisibleKeychainNotAllowed();
    id v136 = [v132 getCircleStatus:0];
    if ([v132 accountKey])
    {
      CFDataRef Copy = (CFStringRef)SOSCopyIDOfKeyWithLength([v132 accountKey], 8, 0);
      alloc = kCFAllocatorDefault;
    }

    else
    {
      alloc = kCFAllocatorDefault;
      CFDataRef Copy = CFStringCreateCopy(kCFAllocatorDefault, @"*No Key*");
    }

    if (v133) {
      char v138 = 85LL;
    }
    else {
      char v138 = 117LL;
    }
    if (v134) {
      unsigned int v139 = 84LL;
    }
    else {
      unsigned int v139 = 116LL;
    }
    if (v135) {
      id v140 = 73LL;
    }
    else {
      id v140 = 105LL;
    }
    if (v136 + 1 > 4) {
      unint64_t v141 = @"kSOSCCError";
    }
    else {
      unint64_t v141 = off_100291C60[v136 + 1];
    }
    char v142 = getuid();
    char v143 = geteuid();
    unsigned int v144 = objc_claimAutoreleasedReturnValue([v132 SOSMonitorModeSOSIsActiveDescription]);
    id v145 = (void *)v144;
    id v146 = "Unrestricted User Visible Views";
    if (v171) {
      id v146 = "User Visible Keychain Disallowed by Profile";
    }
    id v147 = CFStringCreateWithFormat( alloc,  0LL,  @"ACCOUNT: [keyStatus: %c%c%c hpub %@] [SOSCCStatus: %@] [UID: %d  EUID: %d] %@ %s",  v138,  v139,  v140,  Copy,  v141,  v142,  v143,  v144,  v146);

    if (Copy) {
      CFRelease(Copy);
    }

    id v148 = sub_10001267C("accountLogState");
    id v149 = (os_log_s *)objc_claimAutoreleasedReturnValue(v148);
    __int128 v113 = v173;
    id v116 = v175;
    if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v147;
      _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&buf, 0xCu);
    }

    if (v147) {
      CFRelease(v147);
    }
    __int128 v150 = (void *)objc_claimAutoreleasedReturnValue([v132 trust]);
    if ([v150 trustedCircle])
    {
      __int128 v151 = [v150 trustedCircle];
      __int128 v152 = [v132 accountKey];
      __int128 v153 = (os_log_s *)objc_claimAutoreleasedReturnValue([v132 peerID]);
      SOSCircleLogState("accountLogState", v151, v152, v153);
    }

    else
    {
      __int128 v154 = sub_10001267C("accountLogState");
      __int128 v153 = (os_log_s *)objc_claimAutoreleasedReturnValue(v154);
      if (os_log_type_enabled(v153, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v153, OS_LOG_TYPE_DEFAULT, "ACCOUNT: No Circle", (uint8_t *)&buf, 2u);
      }
    }

    __int128 v155 = (id)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](self, "account"));
    __int128 v156 = (void *)objc_claimAutoreleasedReturnValue([v155 trust]);
    __int128 v157 = [v156 isInCircleOnly:0];

    if (v157)
    {
      __int128 v158 = (const __CFSet *)[v155 peerInfo];
      __int128 v159 = sub_1001A19D8(v155, 2LL);
      __int128 v160 = sub_1001A19D8(v155, 5LL);
      if (v158) {
        __int128 v158 = (const __CFSet *)SOSPeerInfoCopyEnabledViews(v158);
      }
      *(void *)&__int128 buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 3221225472LL;
      id v178 = sub_1001942FC;
      __int16 v179 = &unk_1002919A0;
      LOBYTE(v180) = v159;
      BYTE1(v180) = v160;
      sub_1000130AC(v158, (uint64_t)&buf);
      if (v158) {
        CFRelease(v158);
      }
      __int128 v161 = sub_1001A1784(v155);
      sub_1001943F0(&stru_1002919C0, @"null");
      if (v161) {
        CFRelease(v161);
      }
      if (qword_1002DEB80 != -1) {
        dispatch_once(&qword_1002DEB80, &stru_10028EFC8);
      }
      if (byte_1002DEB78)
      {
        id v162 = sub_10001267C("accountLogState");
        id v163 = (os_log_s *)objc_claimAutoreleasedReturnValue(v162);
        if (os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT))
        {
          id v164 = [v155 sosCompatibilityMode];
          __int128 v165 = @"disabled";
          if (v164) {
            __int128 v165 = @"enabled";
          }
          *(_DWORD *)id v181 = 138412290;
          uint64_t v182 = v165;
          _os_log_impl((void *)&_mh_execute_header, v163, OS_LOG_TYPE_DEFAULT, "SOS CompatibilityMode: %@", v181, 0xCu);
        }
      }
    }

    __int128 v166 = sub_10001267C("accountLogState");
    __int128 v167 = (os_log_s *)objc_claimAutoreleasedReturnValue(v166);
    if (os_log_type_enabled(v167, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v181 = 0;
      _os_log_impl((void *)&_mh_execute_header, v167, OS_LOG_TYPE_DEFAULT, "Finish", v181, 2u);
    }

    char v128 = 200;
  }

  dword_1002DED98 = v128 - 1;
  if (v116) {
    CFRelease(v116);
  }
}

void sub_10019F59C(uint64_t a1, uint64_t a2)
{
  id v4 = sub_10001267C("acct-txn");
  CFTypeID v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uid_t v6 = getuid();
    else {
      uint64_t v7 = "non-member";
    }
    __int128 v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) account]);
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 SOSMonitorModeSOSIsActiveDescription]);
    v10[0] = 67109890;
    v10[1] = v6;
    __int16 v11 = 2080;
    int v12 = v7;
    __int16 v13 = 2112;
    uint64_t v14 = v9;
    __int16 v15 = 2112;
    uint64_t v16 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "UID: %d - Finished as:%s %@ v:%@",  (uint8_t *)v10,  0x26u);
  }
}

void sub_10019F6C4(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1 && [v1 peerInfo])
  {
    id v3 = (const __CFSet *)SOSPeerInfoCopyEnabledViews([v2 peerInfo]);
    if (sub_1001A19D8(v2, 2LL))
    {
      MutableCFDataRef Copy = v3;
    }

    else
    {
      uid_t v6 = (const __CFSet *)sub_10018DFDC(v2, (uint64_t)@"pendingEnableViews");
      if (!v6 || (uint64_t v7 = v6, v8 = CFGetTypeID(v6), v8 != CFSetGetTypeID())) {
        uint64_t v7 = 0LL;
      }
      id v9 = (const __CFSet *)sub_10018DFDC(v2, (uint64_t)@"pendingDisableViews");
      if (!v9 || (int v10 = v9, v11 = CFGetTypeID(v9), v11 != CFSetGetTypeID())) {
        int v10 = 0LL;
      }
      MutableCFDataRef Copy = CFSetCreateMutableCopy(kCFAllocatorDefault, 0LL, v3);
      id context = _NSConcreteStackBlock;
      p_id context = 3221225472LL;
      uint64_t v17 = (uint64_t)sub_1001A1A34;
      uint64_t v18 = &unk_100293EA8;
      CFMutableSetRef v19 = MutableCopy;
      CFSetApplyFunction(v7, (CFSetApplierFunction)sub_1001A1988, &context);
      id context = _NSConcreteStackBlock;
      p_id context = 3221225472LL;
      uint64_t v17 = (uint64_t)sub_1001A1A3C;
      uint64_t v18 = &unk_100293EA8;
      CFMutableSetRef v19 = MutableCopy;
      CFSetApplyFunction(v10, (CFSetApplierFunction)sub_1001A1988, &context);
      if (v3) {
        CFRelease(v3);
      }
      if (v7) {
        CFRelease(v7);
      }
      if (v10) {
        CFRelease(v10);
      }
    }
  }

  else
  {
    MutableCFDataRef Copy = 0LL;
  }

  id context = 0LL;
  p_id context = (uint64_t)&context;
  uint64_t v17 = 0x2020000000LL;
  uint64_t v18 = (void *)0xAAAAAAAAAAAAAAAALL;
  if ([v2 getCircleStatus:0] || !MutableCopy)
  {
    uint64_t v18 = 0LL;
    if (!MutableCopy) {
      goto LABEL_11;
    }
  }

  else
  {
    uint64_t v18 = (void *)SOSViewBitmaskFromSet(MutableCopy);
  }

  CFRelease(MutableCopy);
LABEL_11:
  if (*(void *)(p_context + 24) != qword_1002DEDA0)
  {
    qword_1002DEDA0 = *(void *)(p_context + 24);
    [v2 setNotifyViewChangeOnExit:1];
  }

  if ([v2 notifyViewChangeOnExit])
  {
    uint64_t v5 = kSOSCCViewMembershipChangedNotification;
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472LL;
    v12[2] = sub_10019F970;
    void v12[3] = &unk_100292140;
    uint64_t v14 = &context;
    id v13 = v2;
    SOSCachedNotificationOperation(v5, v12);
  }

  _Block_object_dispose(&context, 8);
}

void sub_10019F954( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
}

uint64_t sub_10019F970(uint64_t a1, int token, uint64_t a3)
{
  if ((_DWORD)a3 && !notify_set_state(token, *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL)))
  {
    notify_post(kSOSCCViewMembershipChangedNotification);
    [*(id *)(a1 + 32) setNotifyViewChangeOnExit:0];
  }

  return a3;
}

void sub_10019F9D0(uint64_t a1, uint64_t a2)
{
  id v4 = sub_10001267C("acct-txn");
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uid_t v6 = getuid();
    else {
      uint64_t v7 = "non-member";
    }
    CFTypeID v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) account]);
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 SOSMonitorModeSOSIsActiveDescription]);
    v10[0] = 67109890;
    v10[1] = v6;
    __int16 v11 = 2080;
    int v12 = v7;
    __int16 v13 = 2112;
    uint64_t v14 = v9;
    __int16 v15 = 2112;
    uint64_t v16 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "UID: %d - Starting as:%s %@ v:%@",  (uint8_t *)v10,  0x26u);
  }
}

uint64_t sub_10019FAF8(uint64_t a1, int token, uint64_t a3)
{
  if ((_DWORD)a3 && !notify_set_state(token, *(void *)(a1 + 40)))
  {
    [*(id *)(*(void *)(a1 + 32) + 16) setNotifyCircleChangeOnExit:0];
    uint64_t v5 = sub_10001267C("sosnotify");
    uid_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFTypeID v8 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "posting kSOSCCCircleChangedNotification",  v8,  2u);
    }

    notify_post(kSOSCCCircleChangedNotification);
  }

  return a3;
}

void sub_10019FBA8(id a1)
{
  id v1 = sub_10001267C("sosnotify");
  uint64_t v2 = (os_log_s *)objc_claimAutoreleasedReturnValue(v1);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 67109120;
    v3[1] = qword_1002DED88;
    _os_log_impl( (void *)&_mh_execute_header,  v2,  OS_LOG_TYPE_DEFAULT,  "initial last circle status is: %d",  (uint8_t *)v3,  8u);
  }
}

BOOL sub_10019FC6C(id a1, int a2, BOOL a3)
{
  uint64_t state64 = 0xAAAAAAAAAAAAAAAALL;
  if (!notify_get_state(a2, &state64) && (state64 & 0x8000000000000000LL) != 0) {
    qword_1002DED88 = state64;
  }
  return 1;
}

id sub_10019FE20()
{
  id v1 = v0;
  _BYTE *v0 = 1;
  id result = objc_msgSend( *(id *)(v2 + 32),  "performTransaction_Locked:action:",  *(unsigned __int8 *)(v2 + 48),  *(void *)(v2 + 40));
  *id v1 = 0;
  return result;
}

uint64_t sub_10019FF98(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t sub_10019FFA4(void *a1)
{
  id v1 = a1;
  uint64_t v5 = 0LL;
  uid_t v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  char v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  void v4[2] = sub_1001A0050;
  void v4[3] = &unk_100292168;
  void v4[4] = &v5;
  sub_1001BAFB0(v1, v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);

  return v2;
}

void sub_1001A0038( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1001A0050(uint64_t a1, uint64_t a2)
{
  uint64_t result = SOSPeerInfoIsEnabledView(a2, kSOSViewKeychainV0);
  if ((_DWORD)result) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }
  return result;
}

void sub_1001A0098(void *a1)
{
  id v1 = a1;
  uint64_t v2 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([v1 queue]);
  dispatch_assert_queue_V2(v2);

  id v3 = (void *)objc_claimAutoreleasedReturnValue([v1 trust]);
  id v4 = [v3 fullPeerInfo];
  id v5 = [v3 trustedCircle];
  uint64_t PeerInfo = SOSFullPeerInfoGetPeerInfo(v4);
  uint64_t PeerID = SOSPeerInfoGetPeerID(PeerInfo);
  if (!PeerID) {
    goto LABEL_4;
  }
  char v8 = (const __CFDictionary *)PeerID;
  CFMutableArrayRef v9 = 0LL;
  CFMutableArrayRef Mutable = 0LL;
  CFDictionaryRef v11 = 0LL;
  if (SOSPeerInfoApplicationVerify(PeerInfo, [v1 accountKey], 0))
  {
    if ((SOSPeerInfoIsRetirementTicket(PeerInfo) & 1) != 0)
    {
LABEL_4:
      CFMutableArrayRef v9 = 0LL;
      CFMutableArrayRef Mutable = 0LL;
      CFDictionaryRef v11 = 0LL;
      goto LABEL_5;
    }

    CFMutableArrayRef v9 = 0LL;
    CFMutableArrayRef Mutable = 0LL;
    CFDictionaryRef v11 = 0LL;
    uint64_t v24 = (const __CFSet *)SOSPeerInfoCopyEnabledViews(PeerInfo);
    uint64_t v61 = 0LL;
    id v62 = &v61;
    uint64_t v63 = 0x2020000000LL;
    char v64 = -86;
    char v64 = sub_10019FFA4(v1);
    int v25 = SOSPeerInfoSupportsCKKSForAll(PeerInfo);
    uint64_t v26 = sub_10001267C("engine-notify");
    int v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      id v28 = @"doesn't support";
      if (v25) {
        id v28 = @"supports";
      }
      *(_DWORD *)block = 138412546;
      *(void *)&void block[4] = v8;
      *(_WORD *)&block[12] = 2112;
      *(void *)&block[14] = v28;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Self peer(%@) %@ CKKS For All", block, 0x16u);
    }

    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
    CFMutableArrayRef v9 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
    v39[0] = _NSConcreteStackBlock;
    v39[1] = 3221225472LL;
    v39[2] = sub_1001A0750;
    v39[3] = &unk_100292190;
    id v29 = v1;
    CFMutableArrayRef v42 = Mutable;
    CFMutableArrayRef v43 = v9;
    id v44 = v24;
    id v40 = v29;
    id v41 = &v61;
    char v45 = v25;
    sub_1001BAFB0(v29, v39);
    id v30 = v29;
    if (sub_1001A19D8(v30, 2LL))
    {
      id v31 = [v30 peerInfo];
      if ((SOSPeerInfoV2DictionaryHasData(v31, sBackupKeyKey) & 1) != 0)
      {
        __int16 v32 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
        *(void *)block = _NSConcreteStackBlock;
        *(void *)&block[8] = 3221225472LL;
        *(void *)&block[16] = sub_1001A09E4;
        uint64_t v68 = &unk_100292230;
        CFTypeRef v33 = (os_log_s *)v30;
        id v69 = v33;
        uint64_t v70 = (uint64_t)v32;
        CFSetApplyFunction(v24, (CFSetApplierFunction)sub_1001A0BF4, block);
        id context = _NSConcreteStackBlock;
        uint64_t v47 = 3221225472LL;
        __int128 v48 = sub_1001A0C08;
        __int128 v49 = &unk_100293DA8;
        id v50 = v33;
        id v51 = Mutable;
        CFDictionaryApplyFunction(v32, (CFDictionaryApplierFunction)sub_1001A0E04, &context);
        if (v32) {
          CFRelease(v32);
        }

        uint64_t v34 = v69;
        goto LABEL_41;
      }

      int v37 = sub_10001267C("backup");
      uint64_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue(v37);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)block = 0;
        uint64_t v36 = "No key to backup to, we don't enable individual view backups";
        goto LABEL_40;
      }
    }

    else
    {
      CFStringRef v35 = sub_10001267C("backup");
      uint64_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue(v35);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)block = 0;
        uint64_t v36 = "Haven't finished initial backup syncing, not registering backup metas with engine";
LABEL_40:
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v36, block, 2u);
      }
    }

void sub_1001A0708( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, char a39)
{
}

void sub_1001A0750(uint64_t a1, uint64_t a2)
{
  if (SOSPeerInfoApplicationVerify(a2, [*(id *)(a1 + 32) accountKey], 0))
  {
    int IsRetirementTicket = SOSPeerInfoIsRetirementTicket(a2);
    uint64_t v5 = 48LL;
    if (IsRetirementTicket) {
      uint64_t v5 = 56LL;
    }
    uid_t v6 = (__CFArray **)(a1 + v5);
  }

  else
  {
    uid_t v6 = (__CFArray **)(a1 + 56);
  }

  uint64_t v7 = *v6;
  char v8 = (const __CFSet *)SOSPeerInfoCopyEnabledViews(a2);
  uint64_t v9 = *(void *)(a1 + 64);
  uint64_t v17 = 0LL;
  char v18 = &v17;
  uint64_t v19 = 0x2020000000LL;
  CFMutableSetRef Mutable = (CFMutableSetRef)0xAAAAAAAAAAAAAAAALL;
  CFMutableSetRef Mutable = CFSetCreateMutable(0LL, 0LL, &kCFTypeSetCallBacks);
  if (v8 && v9)
  {
    *(void *)&__int128 context = _NSConcreteStackBlock;
    *((void *)&context + 1) = 3221225472LL;
    uint64_t v22 = sub_1001A1150;
    OSStatus v23 = &unk_100292A88;
    uint64_t v24 = &v17;
    uint64_t v25 = v9;
    CFSetApplyFunction(v8, (CFSetApplierFunction)sub_1001A0BF4, &context);
  }

  int v10 = (__CFSet *)v18[3];
  _Block_object_dispose(&v17, 8);
  if (v8) {
    CFRelease(v8);
  }
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL)) {
    CFSetAddValue(v10, kSOSViewKeychainV0);
  }
  if (*(_BYTE *)(a1 + 72) && SOSPeerInfoSupportsCKKSForAll(a2))
  {
    CFDictionaryRef v11 = sub_10001267C("engine-notify");
    int v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t PeerID = SOSPeerInfoGetPeerID(a2);
      LODWORD(context) = 138412290;
      *(void *)((char *)&context + 4) = PeerID;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Peer %@ supports CKKS For All; ignoring in SOS syncing",
        (uint8_t *)&context,
        0xCu);
    }

    CFSetRemoveAllValues(v10);
  }

  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472LL;
  v16[2] = sub_1001A1198;
  v16[3] = &unk_1002931B8;
  v16[4] = a2;
  sub_1000130AC(v10, (uint64_t)v16);
  uint64_t v14 = (const __CFDictionary *)SOSPeerInfoGetPeerID(a2);
  CFDictionaryRef v15 = sub_1001ADE20(v14, (uint64_t)v10, 0LL);
  if (v10) {
    CFRelease(v10);
  }
  CFArrayAppendValue(v7, v15);
  if (v15) {
    CFRelease(v15);
  }
}

void sub_1001A09C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1001A09E4(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID() && (!kSOSViewKeychainV0 || !CFEqual(cf, kSOSViewKeychainV0)))
    {
      CFStringRef v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%@-tomb", cf);
      uid_t v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) trust]);
      uint64_t v7 = [v6 copyRing:v5 err:0];

      if (v7 && (CFTypeID v8 = CFGetTypeID(v7), v8 == sub_1001D4F80()) && sub_1001D5AEC(v7) == 1)
      {
        signed int Value = (__CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), v7);
        if (Value && (int v10 = Value, v11 = CFGetTypeID(Value), v11 == CFSetGetTypeID()))
        {
          CFSetAddValue(v10, v5);
        }

        else
        {
          CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
          CFSetAddValue(Mutable, v5);
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), v7, Mutable);
          if (Mutable) {
            CFRelease(Mutable);
          }
        }
      }

      else
      {
        int v12 = sub_10001267C("SecWarning");
        __int16 v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412802;
          CFStringRef v16 = v5;
          __int16 v17 = 2112;
          CFStringRef v18 = v5;
          __int16 v19 = 2112;
          int v20 = v7;
          _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "View '%@' not being backed up  ring %@:%@ not backup ring.",  buf,  0x20u);
        }
      }

      if (v5) {
        CFRelease(v5);
      }
      if (v7) {
        CFRelease(v7);
      }
    }
  }

uint64_t sub_1001A0BF4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_1001A0C08(uint64_t a1, const __CFDictionary **a2, const __CFSet *cf)
{
  if (!cf || (CFStringRef v5 = cf, v6 = CFGetTypeID(cf), v6 != CFSetGetTypeID())) {
    CFStringRef v5 = 0LL;
  }
  if (a2)
  {
    CFTypeID v7 = CFGetTypeID(a2);
    uint64_t v8 = sub_1001D4F80();
    if (v5)
    {
      if (v7 == v8)
      {
        if (sub_1001A199C(*(void **)(a1 + 32), v5))
        {
          v20[0] = _NSConcreteStackBlock;
          v20[1] = 3221225472LL;
          void v20[2] = sub_1001A0EE0;
          v20[3] = &unk_1002931B8;
          void v20[4] = a2;
          sub_1000130AC(v5, (uint64_t)v20);
          return;
        }

        CFTypeRef v19 = 0LL;
        uint64_t v9 = (const void *)sub_1001ABCE8(a2, 0LL);
        if (v9 && (uint64_t v10 = (uint64_t)v9, v11 = CFGetTypeID(v9), v11 == CFDataGetTypeID()))
        {
          int v12 = (const void *)SOSBackupSliceKeyBagCreateFromData(kCFAllocatorDefault, v10, &v19);
          if (v12)
          {
            __int16 v13 = (const __CFDictionary *)sub_1001D570C(a2[3]);
            CFDictionaryRef v14 = sub_1001ADE20(v13, (uint64_t)v5, v10);
            if (sub_1000195D0((uint64_t)v14, &v19, @"Didn't make peer meta for: %@", a2))
            {
              CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), v14);
              v18[0] = _NSConcreteStackBlock;
              v18[1] = 3221225472LL;
              v18[2] = sub_1001A0FAC;
              void v18[3] = &unk_100292250;
              v18[4] = a2;
              v18[5] = v10;
              CFDictionaryRef v15 = v18;
LABEL_14:
              sub_1000130AC(v5, (uint64_t)v15);
              if (v14) {
                CFRelease(v14);
              }
              if (v12) {
                CFRelease(v12);
              }
              CFTypeRef v16 = v19;
              if (v19)
              {
                CFTypeRef v19 = 0LL;
                CFRelease(v16);
              }

              return;
            }

uint64_t sub_1001A0E04(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_1001A0E1C(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = sub_10001267C("engine-notify");
  CFStringRef v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    int v7 = 138412546;
    uint64_t v8 = v6;
    __int16 v9 = 2112;
    uint64_t v10 = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "My Meta: %@: %@", (uint8_t *)&v7, 0x16u);
  }
}

void sub_1001A0EE0(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = sub_10001267C("engine-notify");
  CFStringRef v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = sub_1001D570C(*(const __CFDictionary **)(*(void *)(a1 + 32) + 24LL));
    int v7 = 138412546;
    uint64_t v8 = v6;
    __int16 v9 = 2112;
    uint64_t v10 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Not ready, no peer meta: R: %@ Vs: %@",  (uint8_t *)&v7,  0x16u);
  }
}

void sub_1001A0FAC(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = sub_10001267C("engine-notify");
  CFStringRef v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = sub_1001D570C(*(const __CFDictionary **)(*(void *)(a1 + 32) + 24LL));
    uint64_t v7 = *(void *)(a1 + 40);
    int v8 = 138412802;
    __int16 v9 = v6;
    __int16 v10 = 2112;
    uint64_t v11 = a2;
    __int16 v12 = 2112;
    uint64_t v13 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Backup peer meta: R: %@ Vs: %@ VD: %@",  (uint8_t *)&v8,  0x20u);
  }
}

void sub_1001A1084(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = sub_10001267C("SecError");
  CFStringRef v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void *)(a1 + 40);
    int v8 = 138412802;
    uint64_t v9 = v6;
    __int16 v10 = 2112;
    uint64_t v11 = a2;
    __int16 v12 = 2112;
    uint64_t v13 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Failed to register backup meta from %@ for views %@. Error (%@)",  (uint8_t *)&v8,  0x20u);
  }
}

void sub_1001A1150(uint64_t a1, const void *a2)
{
  if (CFSetContainsValue(*(CFSetRef *)(a1 + 40), a2)) {
    CFSetAddValue(*(CFMutableSetRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), a2);
  }
}

void sub_1001A1198(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = sub_10001267C("engine-notify");
  CFStringRef v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t PeerID = SOSPeerInfoGetPeerID(*(void *)(a1 + 32));
    int v7 = 138412546;
    uint64_t v8 = PeerID;
    __int16 v9 = 2112;
    uint64_t v10 = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Meta: %@: %@", (uint8_t *)&v7, 0x16u);
  }
}

void sub_1001A1260(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v7 = *(const __CFSet **)(a1 + 40);
  uint64_t v6 = *(const __CFSet **)(a1 + 48);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  _DWORD v10[2] = sub_1001A142C;
  v10[3] = &unk_1002921E0;
  id v8 = *(id *)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 56);
  id v11 = v8;
  uint64_t v12 = v9;
  uint64_t v13 = a2;
  uint64_t v14 = a3;
  sub_1001A12F8(v7, v6, v10);
}

void sub_1001A12F8(const __CFSet *a1, const __CFSet *a2, void *a3)
{
  CFStringRef v5 = a3;
  MutableCFDataRef Copy = CFSetCreateMutableCopy(kCFAllocatorDefault, 0LL, a2);
  CFMutableSetRef v7 = CFSetCreateMutableCopy(kCFAllocatorDefault, 0LL, a1);
  context[0] = _NSConcreteStackBlock;
  context[1] = 3221225472LL;
  uint64_t context[2] = sub_1001A141C;
  context[3] = &unk_100293EA8;
  context[4] = MutableCopy;
  CFSetApplyFunction(a1, (CFSetApplierFunction)sub_1001A0BF4, context);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  v8[2] = sub_1001A1424;
  v8[3] = &unk_100293EA8;
  void v8[4] = v7;
  CFSetApplyFunction(a2, (CFSetApplierFunction)sub_1001A0BF4, v8);
  v5[2](v5, MutableCopy, v7);

  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  if (v7) {
    CFRelease(v7);
  }
}

void sub_1001A141C(uint64_t a1, const void *a2)
{
}

void sub_1001A1424(uint64_t a1, const void *a2)
{
}

void sub_1001A142C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = (const __CFArray *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "change_blocks"));
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_1001A14EC;
  void v7[3] = &unk_1002921B8;
  id v8 = *(id *)(a1 + 32);
  __int128 v9 = *(_OWORD *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t v11 = a2;
  uint64_t v12 = a3;
  v13.size_t length = CFArrayGetCount(v6);
  v13.id location = 0LL;
  CFArrayApplyFunction(v6, v13, (CFArrayApplierFunction)sub_1001A0BF4, v7);
}

uint64_t sub_1001A14EC(void *a1, uint64_t a2)
{
  CFTypeID v4 = sub_10001267C("updates");
  CFStringRef v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFMutableSetRef v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "calling change block", v7, 2u);
  }

  return (*(uint64_t (**)(uint64_t, void, void, void, void, void, void))(a2 + 16))( a2,  a1[4],  a1[5],  a1[6],  a1[7],  a1[8],  a1[9]);
}

void sub_1001A1580(uint64_t a1, const void *a2, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFDataGetTypeID())
    {
      uint64_t v7 = SOSPeerInfoCreateFromData(0LL, *(void *)(a1 + 48), cf);
      if (v7)
      {
        id v8 = (const void *)v7;
        uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(v7);
        if (CFEqual(a2, PeerID))
        {
          if (SOSPeerInfoInspectRetirementTicket(v8, *(void *)(a1 + 48)))
          {
            uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) retirees]);
            [v10 addObject:v8];

            objc_msgSend(*(id *)(a1 + 40), "setCircle_rings_retirements_need_attention:", 1);
            CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 56), a2);
          }
        }

        CFRelease(v8);
      }
    }
  }

void sub_1001A164C(void *a1)
{
  id v1 = a1;
  if (v1)
  {
    uint64_t v5 = 0LL;
    CFTypeID v6 = &v5;
    uint64_t v7 = 0x2020000000LL;
    char v8 = 1;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_1001A1730;
    block[3] = &unk_100292300;
    void block[4] = &v5;
    if (qword_1002DEDA8 != -1) {
      dispatch_once(&qword_1002DEDA8, block);
    }
    int v2 = *((unsigned __int8 *)v6 + 24);
    _Block_object_dispose(&v5, 8);
    id v3 = (uint64_t *)&kCFBooleanFalse;
    if (v2) {
      id v3 = (uint64_t *)&kCFBooleanTrue;
    }
    sub_1001A93D0(v1, (uint64_t)@"unsynced", *v3, 0LL);
  }
}

void sub_1001A1730(uint64_t a1)
{
  int v2 = (const __CFSet *)SOSViewCopyViewSet(2LL);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = CFSetGetCount(v2) > 0;
  if (v2) {
    CFRelease(v2);
  }
}

CFMutableSetRef sub_1001A1784(void *a1)
{
  id v1 = a1;
  int v2 = (const __CFSet *)SOSViewCopyViewSet(0LL);
  CFMutableSetRef v3 = sub_1001A17DC(v1, v2);

  if (v2) {
    CFRelease(v2);
  }
  return v3;
}

CFMutableSetRef sub_1001A17DC(void *a1, const __CFSet *a2)
{
  id v3 = a1;
  id v4 = sub_10018DFDC(v3, (uint64_t)@"unsynced");
  unsigned int v5 = [v3 getCircleStatus:0];

  if (v5)
  {
    uint64_t v7 = kCFAllocatorDefault;
    return CFSetCreateMutableCopy(v7, 0LL, a2);
  }

  if (v4)
  {
    CFTypeID v6 = CFGetTypeID(v4);
    if (v6 == CFBooleanGetTypeID())
    {
      uint64_t v7 = kCFAllocatorDefault;
      if (CFBooleanGetValue((CFBooleanRef)v4)) {
        return CFSetCreateMutableCopy(v7, 0LL, a2);
      }
      goto LABEL_10;
    }

    CFTypeID v8 = CFGetTypeID(v4);
    if (v8 == CFSetGetTypeID())
    {
      uint64_t v7 = kCFAllocatorDefault;
      MutableCFDataRef Copy = CFSetCreateMutableCopy(kCFAllocatorDefault, 0LL, (CFSetRef)v4);
      CFSetRemoveAllValues(MutableCopy);
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472LL;
      v11[2] = sub_1001A1948;
      v11[3] = &unk_100292FB0;
      void v11[4] = a2;
      void v11[5] = MutableCopy;
      CFSetApplyFunction((CFSetRef)v4, (CFSetApplierFunction)sub_1001A1988, v11);
      if (!MutableCopy) {
        return CFSetCreateMutableCopy(v7, 0LL, a2);
      }
      return MutableCopy;
    }
  }

  uint64_t v7 = kCFAllocatorDefault;
LABEL_10:
  MutableCFDataRef Copy = CFSetCreateMutable(v7, 0LL, &kCFTypeSetCallBacks);
  if (!MutableCopy) {
    return CFSetCreateMutableCopy(v7, 0LL, a2);
  }
  return MutableCopy;
}

void sub_1001A1948(uint64_t a1, const void *a2)
{
  if (CFSetContainsValue(*(CFSetRef *)(a1 + 32), a2)) {
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 40), a2);
  }
}

uint64_t sub_1001A1988(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

BOOL sub_1001A199C(void *a1, const __CFSet *a2)
{
  int v2 = sub_1001A17DC(a1, a2);
  CFIndex Count = CFSetGetCount(v2);
  if (v2) {
    CFRelease(v2);
  }
  return Count != 0;
}

BOOL sub_1001A19D8(void *a1, uint64_t a2)
{
  id v3 = a1;
  id v4 = (const __CFSet *)SOSViewCopyViewSet(a2);
  BOOL v5 = sub_1001A199C(v3, v4);

  if (v4) {
    CFRelease(v4);
  }
  return !v5;
}

void sub_1001A1A34(uint64_t a1, const void *a2)
{
}

void sub_1001A1A3C(uint64_t a1, const void *a2)
{
}

BOOL sub_1001A1A44(uint64_t a1, BOOL a2, BOOL a3)
{
  BOOL v5 = (const __CFSet *)SOSViewCopyViewSet(a1);
  CFTypeID v6 = v5;
  if (!a2)
  {
    if (!v5) {
      return a2;
    }
    goto LABEL_10;
  }

  uint64_t v15 = 0LL;
  CFTypeRef v16 = &v15;
  uint64_t v17 = 0x2020000000LL;
  char v18 = 1;
  if (v5)
  {
    __int128 v9 = _NSConcreteStackBlock;
    uint64_t v10 = 3221225472LL;
    uint64_t v11 = sub_1001A1C90;
    uint64_t v12 = &unk_100292A88;
    CFRange v13 = &v15;
    BOOL v14 = a2;
    CFSetApplyFunction(v5, (CFSetApplierFunction)sub_1001A1988, &v9);
    int v7 = *((unsigned __int8 *)v16 + 24);
    _Block_object_dispose(&v15, 8);
    if (v7)
    {
      a2 = 0LL;
    }

    else
    {
      a2 = 1LL;
      if (a3)
      {
        uint64_t v15 = 0LL;
        CFTypeRef v16 = &v15;
        uint64_t v17 = 0x2020000000LL;
        char v18 = 1;
        __int128 v9 = _NSConcreteStackBlock;
        uint64_t v10 = 3221225472LL;
        uint64_t v11 = sub_1001A1C90;
        uint64_t v12 = &unk_100292A88;
        CFRange v13 = &v15;
        BOOL v14 = a3;
        CFSetApplyFunction(v6, (CFSetApplierFunction)sub_1001A1988, &v9);
        a2 = *((_BYTE *)v16 + 24) != 0;
        _Block_object_dispose(&v15, 8);
      }
    }

void sub_1001A1B94( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1001A1BB0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFTypeID v6 = sub_10001267C("updates");
  int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 138412290;
    uint64_t v10 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "calling in sync block [%@]",  (uint8_t *)&v9,  0xCu);
  }

  return (*(uint64_t (**)(uint64_t, void))(a3 + 16))(a3, *(void *)(a1 + 32));
}

uint64_t sub_1001A1C78(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t sub_1001A1C90(uint64_t a1, const void *a2)
{
  uint64_t result = CFSetContainsValue(*(CFSetRef *)(a1 + 40), a2);
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if ((_DWORD)result) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = *(_BYTE *)(v4 + 24) == 0;
  }
  char v6 = !v5;
  *(_BYTE *)(v4 + 24) = v6;
  return result;
}

void sub_1001A1CD0(void *a1, const __CFSet *a2)
{
  id v3 = a1;
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  unsigned int v5 = [v4 getCircleStatus:0];
  char v6 = (const __CFSet *)sub_10018DFDC(v4, (uint64_t)@"unsynced");
  CFSetRef v7 = v6;
  if (v6) {
    CFRetain(v6);
  }
  sub_1001A21E8(a2, &stru_100292270);
  if (!v5)
  {
    if (v7 == kCFBooleanTrue)
    {
      CFTypeID v8 = (const __CFSet *)SOSViewCopyViewSet(0LL);
      uint64_t v11 = kCFAllocatorDefault;
      CFSetRef Copy = CFSetCreateCopy(kCFAllocatorDefault, v8);
      if (v7) {
        CFRelease(v7);
      }
      uint64_t v15 = sub_10001267C("initial-sync");
      CFTypeRef v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "Pending views setting to all we can expect.",  buf,  2u);
      }

      if (!v8)
      {
        MutableCFSetRef Copy = 0LL;
        CFSetRef v7 = Copy;
        goto LABEL_35;
      }

      CFSetRef v7 = Copy;
    }

    else
    {
      if (!v7 || (CFTypeID v10 = CFGetTypeID(v7), v10 != CFSetGetTypeID()))
      {
        CFTypeID v8 = 0LL;
        MutableCFSetRef Copy = 0LL;
LABEL_35:
        sub_1001A21E8(MutableCopy, &stru_100292290);
        goto LABEL_36;
      }

      CFRetain(v7);
      uint64_t v11 = kCFAllocatorDefault;
      CFTypeID v8 = v7;
    }

    id v17 = v4;
    CFTypeRef cf = 0LL;
    p_CFTypeRef cf = &cf;
    uint64_t v27 = 0x2020000000LL;
    CFMutableSetRef Mutable = (CFMutableSetRef)0xAAAAAAAAAAAAAAAALL;
    CFMutableSetRef Mutable = CFSetCreateMutable(v11, 0LL, &kCFTypeSetCallBacks);
    *(void *)__int128 buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472LL;
    *(void *)&uint8_t buf[16] = sub_1001A2284;
    id v30 = &unk_100292608;
    id v31 = &cf;
    sub_1001BAFB0(v17, buf);
    char v18 = (CFTypeRef *)p_cf[3];
    _Block_object_dispose(&cf, 8);

    MutableCFSetRef Copy = CFSetCreateMutableCopy(v11, 0LL, v8);
    CFSetRemoveAllValues(MutableCopy);
    *(void *)__int128 buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472LL;
    *(void *)&uint8_t buf[16] = sub_1001A1948;
    id v30 = &unk_100292FB0;
    id v31 = v18;
    __int16 v32 = MutableCopy;
    CFSetApplyFunction(v8, (CFSetApplierFunction)sub_1001A1988, buf);
    if (a2)
    {
      *(void *)__int128 buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3221225472LL;
      *(void *)&uint8_t buf[16] = sub_1001A1A3C;
      id v30 = &unk_100293EA8;
      id v31 = (CFTypeRef *)MutableCopy;
      CFSetApplyFunction(a2, (CFSetApplierFunction)sub_1001A1988, buf);
    }

    if (v7 == MutableCopy)
    {
      CFTypeRef v19 = v7;
    }

    else
    {
      if (!MutableCopy)
      {
        CFRelease(v7);
        CFTypeRef v19 = 0LL;
        if (!v18) {
          goto LABEL_33;
        }
        goto LABEL_32;
      }

      CFRetain(MutableCopy);
      CFTypeRef v19 = MutableCopy;
      if (v7)
      {
        CFRelease(v7);
        CFTypeRef v19 = MutableCopy;
        if (!v18) {
          goto LABEL_33;
        }
        goto LABEL_32;
      }
    }

    if (!v18)
    {
LABEL_33:
      CFSetRef v7 = v19;
      goto LABEL_35;
    }

void sub_1001A21C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1001A21E8(const __CFSet *a1, void *a2)
{
  unsigned int v5 = a2;
  if (a1 && (CFTypeID v3 = CFGetTypeID(a1), v3 == CFSetGetTypeID()))
  {
    sub_1000130AC(a1, (uint64_t)v5);
  }

  else
  {
    CFStringRef v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%@", a1);
    v5[2](v5, v4);
    if (v4) {
      CFRelease(v4);
    }
  }
}

uint64_t sub_1001A2284(uint64_t a1, uint64_t a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1001A2388;
  v3[3] = &unk_100292350;
  void v3[4] = *(void *)(a1 + 32);
  return SOSPeerInfoWithEnabledViewSet(a2, v3);
}

void sub_1001A22E0(id a1, __CFString *a2)
{
  CFTypeID v3 = sub_10001267C("initial-sync");
  CFStringRef v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 138412290;
    char v6 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Unsynced: %@", (uint8_t *)&v5, 0xCu);
  }
}

void sub_1001A2388(uint64_t a1, CFSetRef theSet)
{
  uint64_t v2 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  context[0] = _NSConcreteStackBlock;
  context[1] = 3221225472LL;
  uint64_t context[2] = sub_1001A1A34;
  context[3] = &unk_100293EA8;
  context[4] = v2;
  CFSetApplyFunction(theSet, (CFSetApplierFunction)sub_1001A1988, context);
}

void sub_1001A23F4(id a1, __CFString *a2)
{
  CFTypeID v3 = sub_10001267C("initial-sync");
  CFStringRef v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 138412290;
    char v6 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Views in sync: %@", (uint8_t *)&v5, 0xCu);
  }
}

void sub_1001A249C(void *a1)
{
  id v1 = a1;
  if (([v1 isListeningForSync] & 1) == 0)
  {
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([v1 trust]);
    id v3 = objc_msgSend(v2, "getDataSourceEngine:", objc_msgSend(v1, "factory"));

    if (v3)
    {
      CFStringRef v4 = sub_10001267C("initial-sync");
      int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Setting up notifications to monitor in-sync",  buf,  2u);
      }

      char v6 = (void *)objc_claimAutoreleasedReturnValue([v1 queue]);
      sub_1000D294C((uint64_t)v3, v6);

      v10[0] = _NSConcreteStackBlock;
      v10[1] = 3221225472LL;
      _DWORD v10[2] = sub_1001A2618;
      v10[3] = &unk_1002922D8;
      CFSetRef v7 = (os_log_s *)v1;
      uint64_t v11 = v7;
      sub_1000D2894((uint64_t)v3, v10);
      -[os_log_s setIsListeningForSync:](v7, "setIsListeningForSync:", 1LL);
      CFTypeID v8 = v11;
    }

    else
    {
      int v9 = sub_10001267C("SecError");
      CFTypeID v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Couldn't find engine to setup notifications!!!",  buf,  2u);
      }
    }
  }
}

id sub_1001A2618(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v3 = *(void **)(a1 + 32);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_1001A266C;
  void v5[3] = &unk_1002922B0;
  void v5[4] = a2;
  void v5[5] = a3;
  return objc_msgSend(v3, "performTransaction_Locked:", v5);
}

void sub_1001A266C(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(const __CFSet **)(a1 + 40);
  id v4 = a2;
  int v5 = (void *)objc_claimAutoreleasedReturnValue([v4 account]);
  char v6 = sub_10001267C("initial-sync");
  CFSetRef v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 138412546;
    uint64_t v12 = v3;
    __int16 v13 = 2112;
    BOOL v14 = v2;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Peer %@ synced views: %@",  (uint8_t *)&v11,  0x16u);
  }

  CFTypeID v8 = (void *)objc_claimAutoreleasedReturnValue([v5 trust]);
  id v9 = [v8 trustedCircle];
  if (v9)
  {
    id v10 = v9;
    if ([v5 isInCircle:0])
    {
    }
  }
}

void sub_1001A279C(void *a1)
{
  id v1 = a1;
  id v2 = [v1 peerInfo];
  if (v2)
  {
    id v3 = v2;
    if ([v1 isInCircle:0])
    {
      if (sub_1001A19D8(v1, 2LL))
      {
        id v4 = (const void *)SOSViewCopyViewSet(3LL);
        if ((SOSPeerInfoVersionIsCurrent(v3) & 1) == 0)
        {
          int v5 = (const __CFSet *)SOSViewCopyViewSet(4LL);
          context[0] = _NSConcreteStackBlock;
          context[1] = 3221225472LL;
          uint64_t context[2] = sub_1001A1A34;
          context[3] = &unk_100293EA8;
          context[4] = v4;
          CFSetApplyFunction(v5, (CFSetApplierFunction)sub_1001A1988, context);
          if (v5) {
            CFRelease(v5);
          }
        }

        char v6 = (void *)objc_claimAutoreleasedReturnValue([v1 trust]);
        [v6 updateFullPeerInfo:v1 minimum:v4 excluded:SOSViewsGetV0ViewSet()];

        if (v4) {
          CFRelease(v4);
        }
      }
    }
  }
}

void sub_1001A302C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, char a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

void sub_1001A31D8(_Unwind_Exception *a1)
{
}

void sub_1001A3498( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1001A35F4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

LABEL_196:
  __int128 v155 = 0LL;
  __int128 v115 = sub_1001ABD80((void *)Instance);
  id v116 = sub_10001267C("ring");
  id v117 = (os_log_s *)objc_claimAutoreleasedReturnValue(v116);
  if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v117,  OS_LOG_TYPE_DEFAULT,  "Need to fix BSKB - this will prompt a gensign",  buf,  2u);
  }

  if (v70)
  {
    CFMutableSetRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    CFDictionaryAddValue(Mutable, bskbRkbgPrefix, v70);
    __int128 v119 = (const void *)SOSBackupSliceKeyBagCreateWithAdditionalKeys(kCFAllocatorDefault, v144, Mutable, v149);
    if (Mutable) {
      CFRelease(Mutable);
    }
  }

  else
  {
    __int128 v119 = (const void *)SOSBackupSliceKeyBagCreate(kCFAllocatorDefault, v144, v149);
  }

  __int128 v120 = sub_1001ABE6C((void *)Instance, (uint64_t)v20, v115, (uint64_t)v119, (uint64_t)&v155);
  if ((v120 & 1) == 0)
  {
    id v121 = sub_10001267C("ring");
    __int128 v122 = (os_log_s *)objc_claimAutoreleasedReturnValue(v121);
    if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = v155;
      _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_DEFAULT, "Couldn't fix BSKB (%@)", buf, 0xCu);
    }
  }

  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(Instance + 32));
  sub_1001ABB98((void *)Instance, (uint64_t)v20, (uint64_t)v149);
  __int128 v123 = v155;
  if (v155)
  {
    __int128 v155 = 0LL;
    CFRelease(v123);
  }

  if (v119) {
    CFRelease(v119);
  }
  char v74 = v120 ^ 1;
  id v75 = (const __CFDictionary **)Instance;
LABEL_211:
  if (v70) {
    CFRelease(v70);
  }
  if (v71) {
    CFRelease(v71);
  }
  if ((v74 & 1) != 0) {
    goto LABEL_216;
  }
LABEL_128:
  id v76 = SOSFullPeerInfoGetPeerInfo(v20);
  uint64_t v77 = (void *)SOSPeerInfoCopyPubKey(v76, 0LL);
  if (v77)
  {
    sub_1001994C8((void *)Instance);
    char v78 = sub_1001D5AEC((void *)Instance);
    if (v78 > 5 || (unint64_t)v78 - 5 >= 0xFFFFFFFFFFFFFFFDLL)
    {
      SOSCreateError(1040LL, @"Not valid ring type", 0LL, 0LL);
      CFRelease(v77);
    }

    else
    {
      char v79 = sub_1001D65E8(Instance, (__SecKey *)v77, 0LL);
      CFRelease(v77);
      if (v79)
      {
        id v80 = sub_10001267C("ring");
        unint64_t v81 = (os_log_s *)objc_claimAutoreleasedReturnValue(v80);
        if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "Already concur with newRing", buf, 2u);
        }

        goto LABEL_135;
      }
    }
  }

  __int128 v155 = 0LL;
  if (!v20) {
    goto LABEL_154;
  }
  sub_1001994C8((void *)Instance);
  unint64_t v89 = sub_1001D5AEC((void *)Instance);
  if (v89 > 5 || (unint64_t)v89 - 5 >= 0xFFFFFFFFFFFFFFFDLL)
  {
    SOSCreateError(1040LL, @"Not valid ring type", 0LL, &v155);
LABEL_154:
    unsigned int v93 = sub_10001267C("ring");
    uint64_t v92 = (os_log_s *)objc_claimAutoreleasedReturnValue(v93);
    if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = v155;
      _os_log_impl( (void *)&_mh_execute_header,  v92,  OS_LOG_TYPE_DEFAULT,  "Failed to concordance sign, error: %@",  buf,  0xCu);
    }

    __int16 v58 = 5;
    goto LABEL_157;
  }

  char v90 = off_100292810[v89][9];
  id v91 = sub_10001267C("ring");
  uint64_t v92 = (os_log_s *)objc_claimAutoreleasedReturnValue(v91);
  if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "concordance signed", buf, 2u);
  }

  __int16 v58 = 0;
  id v75 = (const __CFDictionary **)Instance;
LABEL_157:

  if (v155) {
    CFRelease(v155);
  }
LABEL_159:
  id v82 = v145;
  if (v58 == 3)
  {
    uint64_t v101 = sub_1001D5D68((uint64_t)v150, cf1);
    char v102 = sub_10001267C("ring");
    unsigned int v103 = (os_log_s *)objc_claimAutoreleasedReturnValue(v102);
    id v104 = os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT);
    if (v101)
    {
      if (v104)
      {
        *(_DWORD *)__int128 buf = 138412290;
        *(void *)&uint8_t buf[4] = Instance;
        _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "Rejecting: %@", buf, 0xCu);
      }

      id v105 = sub_10001267C("ring");
      id v106 = (os_log_s *)objc_claimAutoreleasedReturnValue(v105);
      if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        *(void *)&uint8_t buf[4] = v150;
        _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "   RePush: %@", buf, 0xCu);
      }

      id v107 = (const __CFDictionary **)v150;
      goto LABEL_218;
    }

    if (v104)
    {
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = Instance;
      _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "Rejecting: %@", buf, 0xCu);
    }

    __int128 v108 = sub_10001267C("ring");
    __int128 v109 = (os_log_s *)objc_claimAutoreleasedReturnValue(v108);
    if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_DEFAULT, "Have no old ring - would reset", buf, 2u);
    }

    goto LABEL_216;
  }

  if (v58)
  {
LABEL_216:
    CFTypeRef v19 = 0;
    goto LABEL_217;
  }

LABEL_185:
  if (v140 && sub_1001D5C08(Instance, cf1)) {
    sub_1001D5C54(Instance, cf1);
  }
  -[SOSAccountTrustClassic setRing:ringName:err:](self, "setRing:ringName:err:", Instance, v143, v149);
  objc_msgSend(v152, "setCircle_rings_retirements_need_attention:", 1);
  id v107 = (const __CFDictionary **)Instance;
  if ((v145 & 1) != 0) {
    goto LABEL_218;
  }
  CFTypeRef v19 = (v75 == 0LL) & ~v145;
LABEL_217:
  id v107 = v75;
  if (v75)
  {
LABEL_218:
    __int128 v124 = &unk_1002DEDB0;
    if (v15 == 1) {
      __int128 v124 = &unk_1002DEDB4;
    }
    ++*v124;
    id v125 = sub_10001267C("ring");
    unint64_t v126 = (os_log_s *)objc_claimAutoreleasedReturnValue(v125);
    if (os_log_type_enabled(v126, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136315394;
      *(void *)&uint8_t buf[4] = v139;
      *(_WORD *)&_BYTE buf[12] = 2112;
      *(void *)&buf[14] = v107;
      _os_log_impl((void *)&_mh_execute_header, v126, OS_LOG_TYPE_DEFAULT, "Pushing:[%s] %@", buf, 0x16u);
    }

    char v127 = (const void *)sub_1001A8D6C(v107, (CFTypeRef *)v149);
    if (v127) {
      char v128 = [v151 kvsRingPostRing:sub_1001D570C(v107[3]) ring:v127 err:v149];
    }
    else {
      char v128 = 0;
    }
    id v129 = sub_10001267C("ring");
    uint64_t v130 = (os_log_s *)objc_claimAutoreleasedReturnValue(v129);
    if (os_log_type_enabled(v130, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v130,  OS_LOG_TYPE_DEFAULT,  "Setting account.key_interests_need_updating to true in handleUpdateRing",  buf,  2u);
    }

    objc_msgSend(v152, "setKey_interests_need_updating:", 1);
    if (v127) {
      CFRelease(v127);
    }
    CFTypeRef v19 = v128 != 0;
  }

LABEL_230:
  if (cf) {
    CFRelease(cf);
  }
  if (v144) {
    CFRelease(v144);
  }
  if (v150) {
    CFRelease(v150);
  }
  if (Instance) {
    CFRelease((CFTypeRef)Instance);
  }
  if (v141) {
    CFRelease(v141);
  }
  if (v148) {
    CFRelease(v148);
  }
  if (v146) {
    CFRelease(v146);
  }
LABEL_244:

  return v19;
}

void sub_1001A4E14(_Unwind_Exception *a1)
{
}

void sub_1001A50B0(uint64_t a1, const void *a2)
{
  id v4 = *(__CFSet **)(a1 + 32);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(a2);
  CFSetAddValue(v4, PeerID);
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 40), a2);
}

void sub_1001A50F8(uint64_t a1, const void *a2)
{
  id v4 = *(__CFSet **)(a1 + 32);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(a2);
  CFSetAddValue(v4, PeerID);
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 40), a2);
}

uint64_t sub_1001A5140(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if (*(_BYTE *)(v3 + 24) && (!a3 || !a3[2] || !a3[3] || !a3[4] || !a3[5]))
  {
    *(_BYTE *)(v3 + 24) = 0;
    int v5 = sub_10001267C("ring");
    char v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      uint64_t v9 = a2;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Ring %@ not stable", (uint8_t *)&v8, 0xCu);
    }
  }

  return 0LL;
}

uint64_t sub_1001A5224(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = SOSCircleResetToEmpty(a2, *(void *)(a1 + 40));
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

uint64_t sub_1001A5268(uint64_t a1, const void *a2)
{
  return 0LL;
}

id sub_1001A5284(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 48) + 8LL);
  if (*(_BYTE *)(v2 + 24))
  {
    id result = [*(id *)(a1 + 32) resetRing:*(void *)(a1 + 40) ringName:a2 err:*(void *)(a1 + 56)];
    uint64_t v2 = *(void *)(*(void *)(a1 + 48) + 8LL);
  }

  else
  {
    id result = 0LL;
  }

  *(_BYTE *)(v2 + 24) = (_BYTE)result;
  return result;
}

uint64_t sub_1001A52D8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_1001A52EC(uint64_t a1, const void *a2, CFDataRef theData)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a2;
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = CFDataCreateCopy(kCFAllocatorDefault, theData);
  CFDictionaryAddValue( *(CFMutableDictionaryRef *)(a1 + 88),  a2,  *(const void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL));
  *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = sub_1001A902C( 0LL,  *(CFDataRef *)(*(void *)(*(void *)(a1 + 48) + 8LL)
                                                                               + 24LL));
  *(void *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  int v5 = *(const __CFDictionary ***)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL);
  if (v5)
  {
    *(void *)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL) = sub_1001A8D6C(v5, 0LL);
    CFDictionaryReplaceValue( *(CFMutableDictionaryRef *)(a1 + 88),  a2,  *(const void **)(*(void *)(*(void *)(a1 + 72) + 8LL) + 24LL));
    uint64_t v6 = *(void *)(*(void *)(a1 + 72) + 8LL);
    CFSetRef v7 = *(const void **)(v6 + 24);
    if (v7)
    {
      *(void *)(v6 + 24) = 0LL;
      CFRelease(v7);
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 80) + 8LL) + 24LL) = 1;
  }

  uint64_t v8 = *(void *)(*(void *)(a1 + 56) + 8LL);
  uint64_t v9 = *(const void **)(v8 + 24);
  if (v9)
  {
    *(void *)(v8 + 24) = 0LL;
    CFRelease(v9);
  }

  uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8LL);
  int v11 = *(const void **)(v10 + 24);
  if (v11)
  {
    *(void *)(v10 + 24) = 0LL;
    CFRelease(v11);
  }

  uint64_t v12 = *(void *)(*(void *)(a1 + 64) + 8LL);
  __int16 v13 = *(const void **)(v12 + 24);
  if (v13)
  {
    *(void *)(v12 + 24) = 0LL;
    CFRelease(v13);
  }

uint64_t sub_1001A5450(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t sub_1001A5468(uint64_t a1, uint64_t a2)
{
  id v4 = sub_10001267C("circleChange");
  int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFSetRef v7 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Calling SOSCircleUpdatePeerInfo for gestalt change",  v7,  2u);
  }

  return SOSCircleUpdatePeerInfo(a2, [*(id *)(a1 + 32) peerInfo]);
}

void sub_1001A54F8(uint64_t a1, const void *a2)
{
}

void sub_1001A5500(uint64_t a1, const void *a2)
{
}

uint64_t sub_1001A5508(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = *(const __CFData **)(a1 + 32);
  uint64_t v6 = a3;
  if (v5)
  {
    CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 32));
    BytePtr = CFDataGetBytePtr(v5);
    uint64_t v6 = ccder_encode_raw_octet_string(Length, BytePtr, a2, a3);
  }

  return ccder_encode_constructed_tl(0x2000000000000010LL, a3, a2, v6);
}

BOOL sub_1001A5578(FILE *a1, __CFString **a2, size_t capacity, uint64_t a4)
{
  CFMutableSetRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, capacity);
  CFDataSetLength(Mutable, capacity);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  uint64_t v10 = (*(uint64_t (**)(uint64_t, UInt8 *, UInt8 *))(a4 + 16))(a4, MutableBytePtr, &MutableBytePtr[capacity]);
  if (!v10)
  {
LABEL_7:
    BOOL v17 = 0LL;
    if (!Mutable) {
      return v17;
    }
    goto LABEL_4;
  }

  if (MutableBytePtr != (UInt8 *)v10)
  {
    sub_1000194E0(-1, a2, @"size mismatch der_end - der: %td", v10 - (void)MutableBytePtr);
    goto LABEL_7;
  }

  BOOL v11 = fwrite(MutableBytePtr, capacity, 1uLL, a1) != 1;
  BOOL v17 = sub_1000193E4(v11, (CFTypeRef *)a2, @"fwrite SOSBackupEventWrite", v12, v13, v14, v15, v16, v19);
  if (Mutable) {
LABEL_4:
  }
    CFRelease(Mutable);
  return v17;
}

BOOL sub_1001A566C(FILE *a1, CFDataRef theData, __CFString **a3)
{
  CFIndex Length = CFDataGetLength(theData);
  size_t v7 = ccder_sizeof_raw_octet_string(Length);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000LL;
  void v9[2] = sub_1001A56F0;
  v9[3] = &unk_100292480;
  void v9[4] = theData;
  void v9[5] = a3;
  return sub_1001A5578(a1, a3, v7, (uint64_t)v9);
}

uint64_t sub_1001A56F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = *(const __CFData **)(a1 + 32);
  CFIndex Length = CFDataGetLength(v5);
  BytePtr = CFDataGetBytePtr(v5);
  return ccder_encode_raw_octet_string(Length, BytePtr, a2, a3);
}

BOOL sub_1001A5740(FILE *a1, const __CFDictionary *a2, __CFString **a3)
{
  size_t v6 = sub_100012920(a2, 0LL);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = sub_1001A57C4;
  v8[3] = &unk_1002924A0;
  void v8[4] = a2;
  void v8[5] = a3;
  return sub_1001A5578(a1, a3, v6, (uint64_t)v8);
}

uint64_t sub_1001A57C4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100012A4C(*(const __CFDictionary **)(a1 + 32), *(CFTypeRef **)(a1 + 40), 0, a2, a3);
}

BOOL sub_1001A57DC(FILE *a1, uint64_t a2, __CFString **a3)
{
  size_t v6 = ccder_sizeof_uint64(a2);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000LL;
  void v9[2] = sub_1001A586C;
  v9[3] = &unk_1002924C0;
  void v9[4] = a2;
  void v9[5] = a3;
  BOOL v7 = sub_1001A5578(a1, a3, v6, (uint64_t)v9);
  fflush(a1);
  return v7;
}

uint64_t sub_1001A586C(uint64_t a1)
{
  return ccder_encode_uint64(*(void *)(a1 + 32));
}

void sub_1001A62C4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_1001A7A24( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1001A7E6C(uint64_t a1, uint64_t a2)
{
  id v4 = sub_10001267C("circleChange");
  int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)BOOL v7 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Calling SOSCircleUpdatePeerInfo for gestalt change",  v7,  2u);
  }

  return SOSCircleUpdatePeerInfo(a2, [*(id *)(a1 + 32) peerInfo]);
}

void sub_1001A7EFC(uint64_t a1, const void *a2)
{
  if (SOSPeerInfoIsCloudIdentity(a2))
  {
    CloudIdentity = (const void *)SOSFullPeerInfoCreateCloudIdentity(kCFAllocatorDefault, a2, 0LL);
    if (CloudIdentity) {
      CFRelease(CloudIdentity);
    }
    else {
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 32), a2);
    }
  }

uint64_t sub_1001A7F64(uint64_t a1, uint64_t a2)
{
  uint64_t result = SOSPeerInfoIsEnabledView(a2, kSOSViewKeychainV0);
  if ((_DWORD)result) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }
  return result;
}

id sub_1001A7FAC(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) addObject:SOSPeerInfoGetPeerID(a2)];
}

void sub_1001A7FD8(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef cfa = 0LL;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      uint64_t v5 = SOSCircleCopyPeerWithID([*(id *)(a1 + 32) trustedCircle], cf, 0);
      if (v5)
      {
        size_t v6 = (const void *)v5;
        int HasValidSyncingPeer = SOSCircleHasValidSyncingPeer( [*(id *)(a1 + 32) trustedCircle],  v5,  objc_msgSend(*(id *)(a1 + 40), "accountKey"),  0);
        uint64_t v8 = 56LL;
        if (HasValidSyncingPeer) {
          uint64_t v8 = 48LL;
        }
        CFSetAddValue(*(CFMutableSetRef *)(a1 + v8), cf);
        CFRelease(v6);
      }

      else
      {
        CFSetAddValue(*(CFMutableSetRef *)(a1 + 56), cf);
      }

      return;
    }

    sub_1000194E0(-50, (__CFString **)&cfa, @"object %@ is not a string", cf);
  }

  else
  {
    sub_1000194E0(-50, (__CFString **)&cfa, @"object %@ is not a string", 0LL);
  }

  if (cfa)
  {
    uint64_t v9 = sub_10001267C("sync-with-peers");
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412546;
      uint64_t v14 = 0LL;
      __int16 v15 = 2112;
      CFTypeRef v16 = cfa;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Skipped peer ID: %@ due to %@", buf, 0x16u);
    }

    CFTypeRef v11 = cfa;
    if (cfa)
    {
      CFTypeRef cfa = 0LL;
      CFRelease(v11);
    }
  }

uint64_t sub_1001A81B8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_1001A81CC(uint64_t a1, const void *a2)
{
}

void sub_1001A81D4(uint64_t a1, const void *a2)
{
  if ((SOSPeerInfoApplicationVerify(a2, *(void *)(a1 + 32), 0LL) & 1) == 0) {
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 40), a2);
  }
}

uint64_t sub_1001A821C(uint64_t a1, uint64_t a2)
{
  return SOSCircleWithdrawRequest(*(void *)(a1 + 32), a2, 0LL);
}

uint64_t sub_1001A8228(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = sub_10001267C("circleChange");
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 40);
    int v8 = 138412290;
    uint64_t v9 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Calling SOSCircleUpdatePeerInfo for %@",  (uint8_t *)&v8,  0xCu);
  }

  return SOSCircleUpdatePeerInfo(a2, [*(id *)(a1 + 32) peerInfo]);
}

uint64_t sub_1001A82F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  void v4[2] = sub_1001A8354;
  void v4[3] = &unk_100292570;
  __int128 v5 = *(_OWORD *)(a1 + 32);
  uint64_t v6 = a3;
  return SOSCircleForEachPeer(a2, v4);
}

void sub_1001A8354(uint64_t a1, const void *a2)
{
  CFTypeID v4 = *(const void **)(a1 + 32);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(a2);
  if (v4) {
    BOOL v6 = PeerID == 0LL;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if (v4 == PeerID) {
      return;
    }
  }

  else if (CFEqual(v4, PeerID))
  {
    return;
  }

  if (SOSPeerInfoApplicationVerify(a2, *(void *)(a1 + 40), 0LL))
  {
    if ((SOSPeerInfoIsRetirementTicket(a2) & 1) == 0) {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), a2);
    }
  }

void sub_1001A83E8(uint64_t a1, const void *a2)
{
}

void sub_1001A842C(uint64_t a1, const void *a2)
{
  uint64_t PermittedViews = (const __CFSet *)SOSPeerInfoGetPermittedViews(a2);
}

void sub_1001A8474(uint64_t a1, uint64_t a2, uint64_t a3, const __CFSet *a4, const __CFSet *a5)
{
  uint64_t Name = (const void *)SOSCircleGetName(a3);
  uint64_t v10 = *(const void **)(a1 + 48);
  if (Name && v10)
  {
    if (!CFEqual(Name, v10)) {
      return;
    }
  }

  else if (Name != v10)
  {
    return;
  }

  id v11 = [*(id *)(a1 + 32) peerInfo];
  uint64_t v12 = v11;
  if (v11) {
    uint64_t PeerID = SOSPeerInfoGetPeerID(v11);
  }
  else {
    uint64_t PeerID = 0LL;
  }
  CFMutableSetRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v15 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v16 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (SOSCircleHasPeer(a3, v12, 0LL))
  {
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472LL;
    void v19[2] = sub_1001A867C;
    void v19[3] = &unk_100292FD0;
    void v19[4] = Mutable;
    void v19[5] = PeerID;
    SOSCircleForEachPeer(a3, v19);
    context[0] = _NSConcreteStackBlock;
    context[1] = 3221225472LL;
    uint64_t context[2] = sub_1001A86E8;
    context[3] = &unk_100292FB0;
    context[4] = v15;
    void context[5] = PeerID;
    CFSetApplyFunction(a4, (CFSetApplierFunction)sub_1001A81B8, context);
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472LL;
    v17[2] = sub_1001A8754;
    v17[3] = &unk_100292FB0;
    void v17[4] = v16;
    v17[5] = PeerID;
    CFSetApplyFunction(a5, (CFSetApplierFunction)sub_1001A81B8, v17);
  }

  if (CFArrayGetCount(Mutable) || CFSetContainsValue(a5, v12)) {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v15) {
    CFRelease(v15);
  }
  if (v16) {
    CFRelease(v16);
  }
}

void sub_1001A867C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(__CFArray **)(a1 + 32);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(a2);
  __int128 v5 = PeerID;
  BOOL v6 = *(const void **)(a1 + 40);
  if (PeerID && v6)
  {
    if (CFEqual(PeerID, v6)) {
      return;
    }
LABEL_6:
    CFArrayAppendValue(v3, v5);
    return;
  }

  if (PeerID != v6) {
    goto LABEL_6;
  }
}

void sub_1001A86E8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(__CFArray **)(a1 + 32);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(a2);
  __int128 v5 = PeerID;
  BOOL v6 = *(const void **)(a1 + 40);
  if (PeerID && v6)
  {
    if (CFEqual(PeerID, v6)) {
      return;
    }
LABEL_6:
    CFArrayAppendValue(v3, v5);
    return;
  }

  if (PeerID != v6) {
    goto LABEL_6;
  }
}

void sub_1001A8754(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(__CFArray **)(a1 + 32);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(a2);
  __int128 v5 = PeerID;
  BOOL v6 = *(const void **)(a1 + 40);
  if (PeerID && v6)
  {
    if (CFEqual(PeerID, v6)) {
      return;
    }
LABEL_6:
    CFArrayAppendValue(v3, v5);
    return;
  }

  if (PeerID != v6) {
    goto LABEL_6;
  }
}

void sub_1001A87C0(uint64_t a1, const __CFSet *a2)
{
  if (a2)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472LL;
    _DWORD v5[2] = sub_1001A8B20;
    void v5[3] = &unk_1002931B8;
    void v5[4] = a1;
    sub_1000130AC(a2, (uint64_t)v5);
  }

  else
  {
    uint64_t v3 = sub_10001267C("circleChange");
    CFTypeID v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v7 = a1;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "No %@ list provided.", buf, 0xCu);
    }
  }

BOOL sub_1001A88B0(void *a1, __CFSet *a2, int a3)
{
  id v5 = a1;
  if (a2)
  {
    BOOL v6 = (const void *)kSOSViewKeychainV0;
    BOOL v7 = 1LL;
    if (CFSetContainsValue(a2, kSOSViewKeychainV0))
    {
      else {
        int v8 = 1;
      }
      BOOL v7 = v8 == a3;
      CFSetRemoveValue(a2, v6);
    }
  }

  else
  {
    BOOL v7 = 1LL;
  }

  return v7;
}

uint64_t sub_1001A8940(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = sub_10001267C("circleChange");
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)BOOL v7 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Calling SOSCircleUpdatePeerInfo for views or peerInfo change",  v7,  2u);
  }

  return SOSCircleUpdatePeerInfo(a2, [*(id *)(a1 + 32) peerInfo]);
}

void sub_1001A89D0(id a1, __CFString *a2)
{
  uint64_t v3 = sub_10001267C("viewChange");
  CFTypeID v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 138412290;
    BOOL v6 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Disabling %@", (uint8_t *)&v5, 0xCu);
  }
}

void sub_1001A8A78(id a1, __CFString *a2)
{
  uint64_t v3 = sub_10001267C("viewChange");
  CFTypeID v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 138412290;
    BOOL v6 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Enabling %@", (uint8_t *)&v5, 0xCu);
  }
}

void sub_1001A8B20(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = sub_10001267C("circleChange");
  int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    int v7 = 138412546;
    uint64_t v8 = v6;
    __int16 v9 = 2112;
    uint64_t v10 = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%@ list: %@", (uint8_t *)&v7, 0x16u);
  }
}

uint64_t sub_1001A8BE4(uint64_t a1, uint64_t a2)
{
  uint64_t result = SOSPeerInfoViewStatus([*(id *)(a1 + 32) peerInfo], a2, *(void *)(a1 + 56));
  uint64_t v4 = 40LL;
  if ((_DWORD)result == 1) {
    uint64_t v4 = 48LL;
  }
  *(_BYTE *)(*(void *)(*(void *)(a1 + v4) + 8LL) + 24LL) = 1;
  return result;
}

uint64_t sub_1001A8C38(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10001267C("circleChange");
  int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v7 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Calling SOSCircleUpdatePeerInfo for views change",  v7,  2u);
  }

  return SOSCircleUpdatePeerInfo(a2, [*(id *)(a1 + 32) peerInfo]);
}

uint64_t sub_1001A8CC8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10001267C("circleChange");
  int v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v7 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Calling SOSCircleUpdatePeerInfo for gestalt change",  v7,  2u);
  }

  return SOSCircleUpdatePeerInfo(a2, [*(id *)(a1 + 32) peerInfo]);
}

uint64_t sub_1001A8D6C(const __CFDictionary **a1, CFTypeRef *a2)
{
  if (!a1[2])
  {
    uint64_t v14 = (os_log_s *)sub_10001267C("SecError");
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_5;
    }
    *(_WORD *)__int128 buf = 0;
    CFMutableArrayRef v15 = "ring has no unSignedInformation";
LABEL_20:
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v15, buf, 2u);
    goto LABEL_5;
  }

  if (!a1[3])
  {
    uint64_t v14 = (os_log_s *)sub_10001267C("SecError");
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_5;
    }
    *(_WORD *)__int128 buf = 0;
    CFMutableArrayRef v15 = "ring has no signedInformation";
    goto LABEL_20;
  }

  if (!a1[4])
  {
    uint64_t v14 = (os_log_s *)sub_10001267C("SecError");
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_5;
    }
    *(_WORD *)__int128 buf = 0;
    CFMutableArrayRef v15 = "ring has no signatures";
    goto LABEL_20;
  }

  if (!a1[5])
  {
    uint64_t v14 = (os_log_s *)sub_10001267C("SecError");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      CFMutableArrayRef v15 = "ring has no data";
      goto LABEL_20;
    }
  }

uint64_t sub_1001A8F80(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(const __CFDictionary ***)(a1 + 32);
  uint64_t v5 = *(CFTypeRef **)(a1 + 40);
  uint64_t v6 = a3 + a2;
  uint64_t v7 = v4[2];
  uint64_t v8 = v4[3];
  uint64_t v9 = v4[4];
  uint64_t v10 = sub_100012A4C(v4[5], v5, 0, a3, a3 + a2);
  uint64_t v11 = sub_100012A4C(v9, v5, 0, a3, v10);
  uint64_t v12 = sub_100012A4C(v8, v5, 0, a3, v11);
  uint64_t v13 = sub_100012A4C(v7, v5, 0, a3, v12);
  return ccder_encode_constructed_tl(0x2000000000000010LL, v6, a3, v13);
}

void *sub_1001A902C(CFTypeRef *a1, CFDataRef theData)
{
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  uint64_t v6 = sub_1001D4F80();
  uint64_t Instance = _CFRuntimeCreateInstance(0LL, v6, 32LL, 0LL);
  CFDictionaryRef theDict = 0LL;
  uint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
  CFDictionaryRef v21 = 0LL;
  CFDictionaryRef v22 = 0LL;
  CFDictionaryRef v20 = 0LL;
  if (!Instance)
  {
    BOOL v17 = (os_log_s *)sub_10001267C("ring");
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)char v19 = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Unable to allocate ring", v19, 2u);
    }

    CFMutableArrayRef v15 = 0LL;
    goto LABEL_25;
  }

  uint64_t v8 = (void *)Instance;
  uint64_t v9 = &BytePtr[Length];
  uint64_t v10 = ccder_decode_constructed_tl(0x2000000000000010LL, &v24, BytePtr, v9);
  unint64_t v11 = sub_1000126F8(0LL, &theDict, a1, v10, v24);
  unint64_t v12 = sub_1000126F8(0LL, &v22, a1, v11, v24);
  unint64_t v13 = sub_1000126F8(0LL, &v21, a1, v12, v24);
  unint64_t v14 = sub_1000126F8(0LL, &v20, a1, v13, v24);
  if (v14)
  {
    if ((const UInt8 *)v14 == v9)
    {
      v8[2] = CFDictionaryCreateMutableCopy(0LL, 0LL, theDict);
      v8[3] = CFDictionaryCreateMutableCopy(0LL, 0LL, v22);
      void v8[4] = CFDictionaryCreateMutableCopy(0LL, 0LL, v21);
      CFMutableArrayRef v15 = 0LL;
      void v8[5] = CFDictionaryCreateMutableCopy(0LL, 0LL, v20);
      goto LABEL_5;
    }

    char v18 = (os_log_s *)sub_10001267C("ring");
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_24;
    }
    *(_WORD *)char v19 = 0;
    goto LABEL_23;
  }

  char v18 = (os_log_s *)sub_10001267C("ring");
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)char v19 = 0;
LABEL_23:
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Unable to decode DER", v19, 2u);
  }

BOOL sub_1001A9290(void *a1, uint64_t a2, CFTypeRef *a3)
{
  id v5 = a1;
  BOOL v6 = sub_1001A930C(v5, a3);
  if (v6)
  {
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v5 trust]);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 expansion]);
    [v8 removeObjectForKey:a2];
  }

  return v6;
}

BOOL sub_1001A930C(void *a1, CFTypeRef *a2)
{
  id v3 = a1;
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 trust]);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 expansion]);

  if (!v5)
  {
    BOOL v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v3 trust]);
    [v7 setExpansion:v6];
  }

  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v3 trust]);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 expansion]);
  BOOL v10 = sub_1000195D0((uint64_t)v9, a2, @"Can't Alloc Account Expansion dictionary");

  return v10;
}

BOOL sub_1001A93D0(void *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  id v7 = a1;
  uint64_t v8 = v7;
  if (a3)
  {
    if (sub_1001A930C(v7, a4))
    {
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 trust]);
      BOOL v10 = (void *)objc_claimAutoreleasedReturnValue([v9 expansion]);
      [v10 setObject:a3 forKey:a2];

      BOOL v11 = 1LL;
    }

    else
    {
      BOOL v11 = 0LL;
    }
  }

  else
  {
    BOOL v11 = sub_1001A9290(v7, a2, a4);
  }

  return v11;
}

CFStringRef sub_1001A9474(void *a1)
{
  id v1 = a1;
  uint64_t v2 = (const __CFString *)sub_10018DFDC(v1, (uint64_t)@"UUID");
  if (v2 && (v3 = v2, CFTypeID v4 = CFGetTypeID(v2), v4 == CFStringGetTypeID()))
  {
    CFRetain(v3);
  }

  else
  {
    id v5 = CFUUIDCreate(kCFAllocatorDefault);
    CFStringRef v3 = CFUUIDCreateString(kCFAllocatorDefault, v5);
    CFTypeRef cf = 0LL;
    if (!sub_1001A93D0(v1, (uint64_t)@"UUID", (uint64_t)v3, &cf))
    {
      BOOL v6 = sub_10001267C("SecError");
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412546;
        CFStringRef v12 = v3;
        __int16 v13 = 2112;
        CFTypeRef v14 = cf;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Failed to set UUID: %@ (%@)", buf, 0x16u);
      }
    }

    CFTypeRef v8 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v8);
    }

    if (v5) {
      CFRelease(v5);
    }
  }

  return v3;
}

uint64_t sub_1001A96C8()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_1001A9744;
  block[3] = &unk_1002926A8;
  void block[4] = &qword_1002DEDC0;
  if (qword_1002DEDB8 != -1) {
    dispatch_once(&qword_1002DEDB8, block);
  }
  return qword_1002DEDC0;
}

uint64_t sub_1001A9744(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass(&unk_100292648);
  **(void **)(a1 + 32) = result;
  return result;
}

void sub_1001A9774(void *a1)
{
  if (a1)
  {
    uint64_t v2 = (const void *)a1[3];
    if (v2)
    {
      a1[3] = 0LL;
      CFRelease(v2);
    }

    CFStringRef v3 = (const void *)a1[5];
    if (v3)
    {
      a1[5] = 0LL;
      CFRelease(v3);
    }

    CFTypeID v4 = (const void *)a1[6];
    if (v4)
    {
      a1[6] = 0LL;
      CFRelease(v4);
    }
  }

BOOL sub_1001A97CC(uint64_t a1, uint64_t a2)
{
  return CFStringCompare(*(CFStringRef *)(a1 + 16), *(CFStringRef *)(a2 + 16), 0LL) == kCFCompareEqualTo;
}

CFStringRef sub_1001A97F4(uint64_t a1)
{
  if (!a1) {
    return @"NULL";
  }
  uint64_t v11 = 0LL;
  CFStringRef v12 = &v11;
  uint64_t v13 = 0x2000000000LL;
  uint64_t v14 = 0LL;
  id v1 = *(const __CFData **)(a1 + 48);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000LL;
  _DWORD v10[2] = sub_1001A9944;
  v10[3] = &unk_1002926D0;
  void v10[4] = &v11;
  v10[5] = a1;
  if (v1)
  {
    CFIndex Length = CFDataGetLength(v1);
    CFMutableSetRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
    BytePtr = CFDataGetBytePtr(v1);
    CFIndex v5 = CFDataGetLength(v1);
    if (v5 >= 1)
    {
      CFIndex v6 = v5;
      do
      {
        unsigned int v7 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0LL, @"%02X", v7);
        --v6;
      }

      while (v6);
    }
  }

  else
  {
    CFMutableSetRef Mutable = @"(null)";
  }

  sub_1001A9944((uint64_t)v10, (uint64_t)Mutable);
  CFRelease(Mutable);
  uint64_t v8 = v12[3];
  _Block_object_dispose(&v11, 8);
  return (const __CFString *)v8;
}

CFStringRef sub_1001A9920(uint64_t a1)
{
  return sub_1001A97F4(a1);
}

CFStringRef sub_1001A9944(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(v3 + 24);
  CFIndex v5 = "W";
  if (!*(_BYTE *)(v3 + 32)) {
    CFIndex v5 = "w";
  }
  if (*(_BYTE *)(v3 + 56)) {
    CFIndex v6 = "O";
  }
  else {
    CFIndex v6 = "o";
  }
  CFStringRef result = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"<Coder %@ %@ %s%s>", v4, a2, v5, v6);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = result;
  return result;
}

CFMutableDataRef sub_1001A99D8(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a1 + 24))
  {
    SOSCreateErrorWithFormat(1040LL, 0LL, a2, 0LL, @"No session reference.");
    return 0LL;
  }

  CFMutableDataRef Mutable = CFDataCreateMutable(0LL, 0LL);
  if (!Mutable)
  {
    SOSCreateErrorWithFormat(1024LL, 0LL, a2, 0LL, @"Mutable Data allocation failed.");
    return Mutable;
  }

  if (SecOTRSAppendSerialization(*(void *)(a1 + 24), Mutable))
  {
    SOSCreateErrorWithFormat(1025LL, 0LL, a2, 0LL, @"Append Serialization failed.");
    CFRelease(Mutable);
    return 0LL;
  }

  return Mutable;
}

uint64_t sub_1001A9A98(uint64_t a1, void *a2)
{
  CFMutableDataRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
  CFIndex v5 = *(const void **)(a1 + 24);
  if (!v5)
  {
    CFStringAppend(Mutable, @"*** no otr session ***");
    CFMutableDataRef v7 = 0LL;
    CFStringRef v6 = 0LL;
    goto LABEL_16;
  }

  CFStringRef v6 = CFCopyDescription(v5);
  if (*(_BYTE *)(a1 + 32))
  {
    CFMutableArrayRef v16 = @"waiting for peer to send first data packet";
LABEL_32:
    CFStringAppend(Mutable, v16);
    CFMutableDataRef v7 = 0LL;
    goto LABEL_13;
  }

  if (SecOTRSGetIsReadyForMessages(*(void *)(a1 + 24)))
  {
    CFStringAppend(Mutable, @"otr session ready");
    uint64_t v10 = 0LL;
    CFMutableDataRef v7 = 0LL;
    goto LABEL_20;
  }

  if ((SecOTRSGetIsIdle(*(void *)(a1 + 24)) & 1) == 0)
  {
    CFMutableArrayRef v16 = @"otr negotiating already";
    goto LABEL_32;
  }

  CFMutableDataRef v7 = CFDataCreateMutable(kCFAllocatorDefault, 0LL);
  if (v7)
  {
    if (SecOTRSAppendStartPacket(*(void *)(a1 + 24), v7))
    {
      if (a2) {
        uint64_t v8 = *a2;
      }
      else {
        uint64_t v8 = 0LL;
      }
      SOSCreateErrorWithFormat(1025LL, v8, a2, 0LL, @"append start packet returned: %d");
      goto LABEL_16;
    }

    if (*(CFMutableDataRef *)(a1 + 40) != v7)
    {
      CFRetain(v7);
      uint64_t v9 = *(const void **)(a1 + 40);
      if (v9) {
        CFRelease(v9);
      }
      *(void *)(a1 + 40) = v7;
    }

void sub_1001A9D20(uint64_t a1)
{
  *(_BYTE *)(a1 + 32) = 0;
  uint64_t v2 = *(const void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 40) = 0LL;
    CFRelease(v2);
  }

  *(_BYTE *)(a1 + 56) = 0;
  uint64_t v3 = *(const void **)(a1 + 48);
  if (v3)
  {
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
    CFRelease(v3);
  }

  CFIndex v4 = *(void *)ccsha1_di();
  CFMutableDataRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0LL);
  CFDataSetLength(Mutable, v4);
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = Mutable;
}

uint64_t sub_1001A9DA4(uint64_t a1)
{
  if (!*(void *)(a1 + 24)) {
    return 0LL;
  }
  CFMutableDataRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0LL);
  if (SecOTRSAppendRestartPacket(*(void *)(a1 + 24), Mutable))
  {
    uint64_t v5 = 3LL;
    if (!Mutable) {
      return v5;
    }
    goto LABEL_11;
  }

  uint64_t v3 = (os_log_s *)sub_10001267C("coder");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 138412290;
    CFMutableDataRef v8 = Mutable;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Resending OTR Start %@", (uint8_t *)&v7, 0xCu);
  }

  CFMutableDataRef v4 = *(CFMutableDataRef *)(a1 + 40);
  if (v4 != Mutable)
  {
    if (!Mutable || (CFRetain(Mutable), (CFMutableDataRef v4 = *(CFMutableDataRef *)(a1 + 40)) != 0LL)) {
      CFRelease(v4);
    }
    *(void *)(a1 + 40) = Mutable;
  }

  uint64_t v5 = 1LL;
  if (Mutable) {
LABEL_11:
  }
    CFRelease(Mutable);
  return v5;
}

void sub_1001A9ECC(char **a1, __int128 *a2)
{
  if (a2)
  {
    CFMutableDataRef v4 = a1[1];
    uint64_t v5 = (unint64_t *)(a1 + 1);
    unint64_t v6 = (unint64_t)(v4 + 1);
    if (a1[2] >= v4 + 1)
    {
      uint64_t v9 = *a1;
    }

    else
    {
      if (v6 > 0x100000)
      {
        int v7 = (os_log_s *)sub_10001267C("manifest");
        if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        int v15 = 134217984;
        unint64_t v16 = v6;
        CFMutableDataRef v8 = "Requesting too much space for digest vectors: %ld";
LABEL_14:
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v15, 0xCu);
        return;
      }

      uint64_t v10 = 1048476LL;
      if (v6 < 0xFFF9C) {
        uint64_t v10 = v6;
      }
      uint64_t v11 = v10 + 100;
      size_t v12 = 20 * (v10 + 100);
      uint64_t v9 = (char *)reallocf(*a1, v12);
      *a1 = v9;
      if (!v9)
      {
        *uint64_t v5 = 0LL;
        v5[1] = 0LL;
        int v7 = (os_log_s *)sub_10001267C("manifest");
        if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        int v15 = 134217984;
        unint64_t v16 = v12;
        CFMutableDataRef v8 = "reallocf failed requesting space for digest vectors: %ld (bytes)";
        goto LABEL_14;
      }

      a1[2] = (char *)v11;
      CFMutableDataRef v4 = a1[1];
      unint64_t v6 = (unint64_t)(v4 + 1);
    }

    *uint64_t v5 = v6;
    uint64_t v13 = &v9[20 * (void)v4];
    __int128 v14 = *a2;
    *((_DWORD *)v13 + 4) = *((_DWORD *)a2 + 4);
    *(_OWORD *)uint64_t v13 = v14;
  }

void sub_1001AA048(char **a1)
{
  if (*((_BYTE *)a1 + 24))
  {
    uint64_t v2 = *a1;
    if (v2)
    {
      qsort(v2, (size_t)a1[1], 0x14uLL, (int (__cdecl *)(const void *, const void *))sub_1001AA1FC);
      *((_BYTE *)a1 + 24) = 0;
      uint64_t v3 = (uint64_t)a1[1];
      if ((unint64_t)v3 >= 2)
      {
        CFMutableDataRef v4 = *a1;
        if (*a1)
        {
          uint64_t v5 = v4 + 20;
          unint64_t v6 = (unint64_t)&v4[20 * v3];
          if (v3 >= 2)
          {
            int v7 = v4 + 20;
            CFMutableDataRef v8 = v4 + 20;
            while (1)
            {
              if (v4)
              {
                unint64_t v9 = bswap64(*(void *)v4);
                unint64_t v10 = bswap64(*(void *)v5);
                if (v9 == v10)
                {
                  unint64_t v9 = bswap64(*((void *)v4 + 1));
                  unint64_t v10 = bswap64(*((void *)v5 + 1));
                  if (v9 == v10)
                  {
                    unint64_t v9 = bswap32(*((_DWORD *)v4 + 4));
                    unint64_t v10 = bswap32(*((_DWORD *)v5 + 4));
                    if (v9 == v10)
                    {
                      int v11 = 0;
LABEL_17:
                      if (!v11)
                      {
                        size_t v12 = v4 + 20;
                        uint64_t v13 = v4 + 20 - v7;
                        if (v8 != v7) {
                          memmove(v8, v7, v4 + 20 - v7);
                        }
                        v8 += v13;
                        __int128 v14 = v5 + 20;
                        do
                        {
                          int v7 = (char *)v14;
                          BOOL v15 = *(void *)v12 == *v14 && *((void *)v12 + 1) == v14[1];
                          BOOL v16 = v15 && *((_DWORD *)v12 + 4) == (unint64_t)*((unsigned int *)v14 + 4);
                          __int128 v14 = (void *)((char *)v14 + 20);
                        }

                        while (v16);
                        uint64_t v5 = v7;
                        CFMutableDataRef v4 = v7;
                      }

                      goto LABEL_30;
                    }
                  }
                }

                if (v9 < v10) {
                  int v11 = -1;
                }
                else {
                  int v11 = 1;
                }
                if ((v11 & 0x80000000) == 0) {
                  goto LABEL_17;
                }
                CFMutableDataRef v4 = v5;
              }

uint64_t sub_1001AA1FC(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    unint64_t v2 = bswap64(*(void *)a1);
    unint64_t v3 = bswap64(*(void *)a2);
    if (v2 == v3
      && (v2 = bswap64(*(void *)(a1 + 8)), unint64_t v3 = bswap64(*(void *)(a2 + 8)), v2 == v3)
      && (v2 = bswap32(*(_DWORD *)(a1 + 16)), unint64_t v3 = bswap32(*(_DWORD *)(a2 + 16)), v2 == v3))
    {
      return 0LL;
    }

    else if (v2 < v3)
    {
      return 0xFFFFFFFFLL;
    }

    else
    {
      return 1LL;
    }
  }

  else if (a1)
  {
    return 0xFFFFFFFFLL;
  }

  else
  {
    return a2 != 0;
  }

unint64_t sub_1001AA278(unint64_t result, unint64_t a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v5 = (char **)result;
    unint64_t v6 = 0LL;
    for (CFIndex i = (__int128 *)a3; ; CFIndex i = (__int128 *)(a3 + 20 * result))
    {
      sub_1001A9ECC(v5, i);
      CFStringRef result = sub_1001AA2E8(a3, a2, v6);
      if (result >= a2) {
        break;
      }
      unint64_t v6 = result;
    }
  }

  return result;
}

unint64_t sub_1001AA2E8(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (a1 && a3 < a2)
  {
    uint64_t v3 = a1 + 20 * a3;
    uint64_t v4 = v3 + 20;
    while (a2 - 1 != a3)
    {
      ++a3;
      BOOL v6 = *(void *)v3 == *(void *)v4
        && *(void *)(v3 + 8) == *(void *)(v4 + 8)
        && *(_DWORD *)(v3 + 16) == (unint64_t)*(unsigned int *)(v4 + 16);
      v4 += 20LL;
      if (!v6) {
        return a3;
      }
    }

    return a2;
  }

  return a3;
}

unint64_t sub_1001AA344(uint64_t *a1, uint64_t a2, char **a3)
{
  unint64_t v6 = a1[1];
  if (v6 && *(void *)(a2 + 8))
  {
    unint64_t v7 = 0LL;
    unint64_t v8 = 0LL;
    while (1)
    {
      uint64_t v9 = *a1 + 20 * v7;
      uint64_t v10 = *(void *)a2;
      uint64_t v11 = *(void *)a2 + 20 * v8;
      if (*a1) {
        BOOL v12 = v10 == 0;
      }
      else {
        BOOL v12 = 1;
      }
      if (v12)
      {
        int v13 = v10 != 0;
        if (*a1) {
          goto LABEL_21;
        }
      }

      else
      {
        unint64_t v14 = bswap64(*(void *)v9);
        unint64_t v15 = bswap64(*(void *)v11);
        if (v14 == v15
          && (v14 = bswap64(*(void *)(v9 + 8)), unint64_t v15 = bswap64(*(void *)(v11 + 8)), v14 == v15)
          && (v14 = bswap32(*(_DWORD *)(v9 + 16)), unint64_t v15 = bswap32(*(_DWORD *)(v11 + 16)), v14 == v15))
        {
          int v13 = 0;
        }

        else if (v14 < v15)
        {
          int v13 = -1;
        }

        else
        {
          int v13 = 1;
        }
      }

      if (v13)
      {
        if ((v13 & 0x80000000) == 0)
        {
          sub_1001A9ECC(a3, (__int128 *)(*(void *)a2 + 20 * v8));
          unint64_t v8 = sub_1001AA2E8(*(void *)a2, *(void *)(a2 + 8), v8);
          unint64_t v6 = a1[1];
          goto LABEL_23;
        }

unint64_t sub_1001AA4E4( unint64_t result, unint64_t *a2, unint64_t a3, uint64_t *a4, char **a5)
{
  unint64_t v8 = a2[1];
  if (v8 > result)
  {
    unint64_t v10 = result;
    unint64_t v11 = a4[1];
    do
    {
      if (a3 >= v11) {
        break;
      }
      CFStringRef result = *a2;
      if (!*a2) {
        break;
      }
      uint64_t v12 = *a4;
      if (!*a4) {
        return result;
      }
      unint64_t v13 = result + 20 * v10;
      unint64_t v14 = v12 + 20 * a3;
      unint64_t v15 = bswap64(*(void *)v13);
      unint64_t v16 = bswap64(*(void *)v14);
      if (v15 != v16) {
        goto LABEL_10;
      }
      unint64_t v15 = bswap64(*(void *)(v13 + 8));
      unint64_t v16 = bswap64(*(void *)(v14 + 8));
      if (v15 == v16 && (unint64_t v15 = bswap32(*(_DWORD *)(v13 + 16)), v16 = bswap32(*(_DWORD *)(v14 + 16)), v15 == v16))
      {
        unint64_t v10 = sub_1001AA2E8(result, v8, v10);
        CFStringRef result = sub_1001AA2E8(v12, v11, a3);
        a3 = result;
      }

      else
      {
LABEL_10:
        int v17 = v15 < v16 ? -1 : 1;
        if (v17 < 0)
        {
          CFStringRef result = sub_1001AA2E8(result, v8, v10);
          unint64_t v10 = result;
        }

        else
        {
          sub_1001A9ECC(a5, (__int128 *)v14);
          unint64_t v11 = a4[1];
          CFStringRef result = sub_1001AA2E8(*a4, v11, a3);
          a3 = result;
          unint64_t v8 = a2[1];
        }
      }
    }

    while (v10 < v8);
  }

  if (*a4) {
    return sub_1001AA278((unint64_t)a5, a4[1] - a3, *a4 + 20 * a3);
  }
  return result;
}

unint64_t sub_1001AA664(uint64_t *a1, unint64_t *a2, uint64_t a3, char **a4)
{
  uint64_t v5 = a2;
  unint64_t v6 = a1;
  if (!a1[1])
  {
    unint64_t v9 = 0LL;
    unint64_t v8 = 0LL;
    unint64_t v7 = 0LL;
    goto LABEL_52;
  }

  unint64_t v7 = 0LL;
  unint64_t v8 = 0LL;
  unint64_t v9 = 0LL;
  do
  {
    if (v8 >= *(void *)(a3 + 8)) {
      break;
    }
    uint64_t v10 = *v6 + 20 * v9;
    uint64_t v11 = *(void *)a3;
    uint64_t v12 = *(void *)a3 + 20 * v8;
    if (*v6) {
      BOOL v13 = v11 == 0;
    }
    else {
      BOOL v13 = 1;
    }
    if (v13)
    {
      int v14 = v11 != 0;
      if (!*v6) {
        goto LABEL_20;
      }
      int v14 = -1;
    }

    else
    {
      unint64_t v15 = bswap64(*(void *)v10);
      unint64_t v16 = bswap64(*(void *)v12);
      if (v15 == v16)
      {
        unint64_t v15 = bswap64(*(void *)(v10 + 8));
        unint64_t v16 = bswap64(*(void *)(v12 + 8));
        if (v15 == v16)
        {
          unint64_t v15 = bswap32(*(_DWORD *)(v10 + 16));
          unint64_t v16 = bswap32(*(_DWORD *)(v12 + 16));
          if (v15 == v16)
          {
            int v14 = 0;
LABEL_20:
            int v30 = 0;
            goto LABEL_21;
          }
        }
      }

      if (v15 < v16) {
        int v14 = -1;
      }
      else {
        int v14 = 1;
      }
      if ((v14 & 0x80000000) == 0) {
        goto LABEL_20;
      }
    }

    int v30 = 1;
    uint64_t v12 = *v6 + 20 * v9;
LABEL_21:
    unint64_t v17 = v5[1];
    if (v7 >= v17) {
      goto LABEL_42;
    }
    uint64_t v18 = *v5;
    if (v12) {
      BOOL v19 = v18 == 0;
    }
    else {
      BOOL v19 = 1;
    }
    char v20 = !v19;
    while ((v20 & 1) != 0)
    {
      unint64_t v21 = v18 + 20 * v7;
      unint64_t v22 = bswap64(*(void *)v21);
      unint64_t v23 = bswap64(*(void *)v12);
      if (v22 == v23)
      {
        unint64_t v22 = bswap64(*(void *)(v21 + 8));
        unint64_t v23 = bswap64(*(void *)(v12 + 8));
        if (v22 == v23)
        {
          unint64_t v22 = bswap32(*(_DWORD *)(v21 + 16));
          unint64_t v23 = bswap32(*(_DWORD *)(v12 + 16));
          if (v22 == v23)
          {
            int v24 = 0;
            goto LABEL_41;
          }
        }
      }

      if (v22 < v23) {
        int v24 = -1;
      }
      else {
        int v24 = 1;
      }
      if ((v24 & 0x80000000) == 0) {
        goto LABEL_41;
      }
LABEL_39:
      unint64_t v7 = sub_1001AA2E8(v18, v17, v7);
      if (v7 >= v17) {
        goto LABEL_43;
      }
    }

    if (v18) {
      goto LABEL_39;
    }
    int v24 = v12 != 0;
LABEL_41:
    if (!v24)
    {
      unint64_t v7 = sub_1001AA2E8(v18, v17, v7);
      if (v14) {
        goto LABEL_44;
      }
LABEL_48:
      unint64_t v6 = a1;
      unint64_t v25 = a1[1];
      unint64_t v9 = sub_1001AA2E8(*a1, v25, v9);
      unint64_t v8 = sub_1001AA2E8(*(void *)a3, *(void *)(a3 + 8), v8);
      uint64_t v5 = a2;
      continue;
    }

uint64_t sub_1001AA920()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_1001AA99C;
  block[3] = &unk_1002927A0;
  void block[4] = &qword_1002DEDD0;
  if (qword_1002DEDC8 != -1) {
    dispatch_once(&qword_1002DEDC8, block);
  }
  return qword_1002DEDD0;
}

uint64_t sub_1001AA99C(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass(&unk_100292740);
  **(void **)(a1 + 32) = result;
  return result;
}

void sub_1001AA9CC(uint64_t a1)
{
  unint64_t v2 = *(const void **)(a1 + 16);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 24);
  if (v3) {
    CFRelease(v3);
  }
}

BOOL sub_1001AAA08(__CFData *a1, __CFData *a2)
{
  uint64_t v3 = sub_1001AABD0(a1);
  uint64_t v4 = sub_1001AABD0(a2);
  if (v3 && v4) {
    return CFEqual(v3, v4) != 0;
  }
  else {
    return v3 == v4;
  }
}

__CFString *sub_1001AAA5C(CFDataRef *a1)
{
  CFMutableDataRef Mutable = CFStringCreateMutable(0LL, 0LL);
  if (!a1)
  {
    unint64_t v6 = 0LL;
LABEL_6:
    CFStringAppendFormat(Mutable, 0LL, @"<[%zu]", v6);
    goto LABEL_7;
  }

  if ((unint64_t)CFDataGetLength(a1[3]) < 0xA0)
  {
    unint64_t v6 = CFDataGetLength(a1[3]) / 0x14uLL;
    goto LABEL_6;
  }

  uint64_t v3 = sub_1001AABD0((__CFData *)a1);
  BytePtr = CFDataGetBytePtr(v3);
  unint64_t Length = CFDataGetLength(a1[3]);
  CFStringAppendFormat( Mutable,  0LL,  @"<[%zu:%02X%02X%02X%02X]",  Length / 0x14,  *BytePtr,  BytePtr[1],  BytePtr[2],  BytePtr[3]);
LABEL_7:
  v9[0] = 0LL;
  v9[1] = v9;
  void v9[2] = 0x2000000000LL;
  v9[3] = 8LL;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000LL;
  v8[2] = sub_1001AAC40;
  v8[3] = &unk_1002927C8;
  void v8[4] = v9;
  void v8[5] = Mutable;
  sub_1001AACD0((uint64_t)a1, (uint64_t)v8);
  CFStringAppend(Mutable, @">");
  _Block_object_dispose(v9, 8);
  return Mutable;
}

__CFString *sub_1001AABAC(CFDataRef *a1)
{
  return sub_1001AAA5C(a1);
}

__CFData *sub_1001AABD0(__CFData *result)
{
  if (result)
  {
    id v1 = result;
    uint64_t result = (__CFData *)*((void *)result + 2);
    if (!result)
    {
      CFIndex Length = CFDataGetLength(*((CFDataRef *)v1 + 3));
      BytePtr = CFDataGetBytePtr(*((CFDataRef *)v1 + 3));
      uint64_t v4 = (CFIndex *)ccsha1_di();
      uint64_t result = sub_10001A2B4(kCFAllocatorDefault, v4, Length, (uint64_t)BytePtr);
      *((void *)v1 + 2) = result;
    }
  }

  return result;
}

void sub_1001AAC40(uint64_t a1, CFDataRef theData, _BYTE *a3)
{
  BytePtr = CFDataGetBytePtr(theData);
  CFStringAppendFormat( *(CFMutableStringRef *)(a1 + 40),  0LL,  @" %02X%02X%02X%02X",  *BytePtr,  BytePtr[1],  BytePtr[2],  BytePtr[3]);
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v7 = *(void *)(v6 + 24) - 1LL;
  *(void *)(v6 + 24) = v7;
  if (!v7)
  {
    CFStringAppend(*(CFMutableStringRef *)(a1 + 40), @"...");
    *a3 = 1;
  }

void sub_1001AACD0(uint64_t a1, uint64_t a2)
{
  char v11 = 0;
  if (a1)
  {
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 24));
    CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 24));
    if (Length >= 20)
    {
      uint64_t v6 = &BytePtr[Length];
      do
      {
        CFDataRef v7 = CFDataCreate(kCFAllocatorDefault, BytePtr, 20LL);
        if (v7)
        {
          CFDataRef v8 = v7;
          (*(void (**)(uint64_t, CFDataRef, char *))(a2 + 16))(a2, v7, &v11);
          CFRelease(v8);
        }

        unint64_t v9 = BytePtr + 40;
        BytePtr += 20;
        if (v11) {
          BOOL v10 = 1;
        }
        else {
          BOOL v10 = v9 > v6;
        }
      }

      while (!v10);
    }
  }

uint64_t sub_1001AAD88(const __CFData *a1, CFTypeRef *a2)
{
  uint64_t v4 = sub_1001AA920();
  uint64_t Instance = _CFRuntimeCreateInstance(kCFAllocatorDefault, v4, 48LL, 0LL);
  if (Instance)
  {
    if (a1) {
      CFDataRef Copy = CFDataCreateCopy(kCFAllocatorDefault, a1);
    }
    else {
      CFDataRef Copy = CFDataCreate(kCFAllocatorDefault, 0LL, 0LL);
    }
    *(void *)(Instance + 24) = Copy;
  }

  else
  {
    sub_1000194B4(2LL, @"com.apple.security.sos.manifest.error", 0LL, a2, v5, @"Failed to create manifest");
  }

  return Instance;
}

uint64_t sub_1001AAE28(UInt8 *bytes, CFIndex length, CFTypeRef *a3)
{
  uint64_t v4 = CFDataCreate(kCFAllocatorDefault, bytes, length);
  uint64_t v5 = sub_1001AAD88(v4, a3);
  if (v4) {
    CFRelease(v4);
  }
  return v5;
}

void *sub_1001AAE7C(uint64_t a1)
{
  if (!a1) {
    return &unk_1002DEDD8;
  }
  unint64_t Length = CFDataGetLength(*(CFDataRef *)(a1 + 24));
  *(void *)(a1 + 40) = Length / 0x14;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = Length / 0x14;
  *(void *)(a1 + 32) = CFDataGetBytePtr(*(CFDataRef *)(a1 + 24));
  uint64_t v3 = a1 + 32;
  *(_BYTE *)(v3 + 24) = 0;
  return (void *)v3;
}

uint64_t sub_1001AAED8(uint64_t a1, uint64_t a2, uint64_t *a3, const void **a4, CFTypeRef *a5)
{
  if (a1 && (unint64_t)CFDataGetLength(*(CFDataRef *)(a1 + 24)) > 0x13)
  {
    if (!a2 || (unint64_t)CFDataGetLength(*(CFDataRef *)(a2 + 24)) <= 0x13)
    {
      BOOL v10 = (const void *)sub_1001AAE28(0LL, 0LL, a5);
      if (a3)
      {
        CFRetain((CFTypeRef)a1);
        *a3 = a1;
      }

      if (a4)
      {
        unint64_t v15 = *a4;
        if (*a4 != v10)
        {
          if (!v10 || (CFRetain(v10), (unint64_t v15 = *a4) != 0LL)) {
            CFRelease(v15);
          }
          *a4 = v10;
        }
      }

      goto LABEL_16;
    }

    *(_OWORD *)uint64_t v34 = 0u;
    __int128 v35 = 0u;
    *(_OWORD *)__int16 v32 = 0u;
    __int128 v33 = 0u;
    unint64_t Length = CFDataGetLength(*(CFDataRef *)(a1 + 24));
    *(void *)(a1 + 40) = Length / 0x14;
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = Length / 0x14;
    *(void *)(a1 + 32) = CFDataGetBytePtr(*(CFDataRef *)(a1 + 24));
    *(_BYTE *)(a1 + 56) = 0;
    unint64_t v17 = CFDataGetLength(*(CFDataRef *)(a2 + 24));
    *(void *)(a2 + 40) = v17 / 0x14;
    *(void *)(a2 + 4_Block_object_dispose(va, 8) = v17 / 0x14;
    *(void *)(a2 + 32) = CFDataGetBytePtr(*(CFDataRef *)(a2 + 24));
    *(_BYTE *)(a2 + 56) = 0;
    unint64_t v18 = *(void *)(a1 + 40);
    if (v18)
    {
      unint64_t v19 = 0LL;
      unint64_t v20 = 0LL;
      while (1)
      {
        unint64_t v21 = *(void *)(a2 + 40);
        if (v19 >= v21) {
          goto LABEL_55;
        }
        uint64_t v22 = *(void *)(a1 + 32);
        unint64_t v23 = v22 + 20 * v20;
        uint64_t v24 = *(void *)(a2 + 32);
        unint64_t v25 = v24 + 20 * v19;
        if (v22) {
          BOOL v26 = v24 == 0;
        }
        else {
          BOOL v26 = 1;
        }
        if (v26)
        {
          int v27 = v24 != 0;
          if (v22) {
            goto LABEL_50;
          }
        }

        else
        {
          unint64_t v28 = bswap64(*(void *)v23);
          unint64_t v29 = bswap64(*(void *)v25);
          if (v28 == v29
            && (unint64_t v28 = bswap64(*(void *)(v23 + 8)), v29 = bswap64(*(void *)(v25 + 8)), v28 == v29)
            && (unint64_t v28 = bswap32(*(_DWORD *)(v23 + 16)), v29 = bswap32(*(_DWORD *)(v25 + 16)), v28 == v29))
          {
            int v27 = 0;
          }

          else if (v28 < v29)
          {
            int v27 = -1;
          }

          else
          {
            int v27 = 1;
          }
        }

        if (!v27)
        {
          unint64_t v20 = sub_1001AA2E8(v22, v18, v20);
          unint64_t v19 = sub_1001AA2E8(v24, v21, v19);
          goto LABEL_52;
        }

        if (v27 < 0)
        {
LABEL_50:
          sub_1001A9ECC((char **)v34, (__int128 *)v23);
          unint64_t v18 = *(void *)(a1 + 40);
          unint64_t v20 = sub_1001AA2E8(*(void *)(a1 + 32), v18, v20);
          goto LABEL_52;
        }

        sub_1001A9ECC((char **)v32, (__int128 *)(v24 + 20 * v19));
        unint64_t v19 = sub_1001AA2E8(*(void *)(a2 + 32), *(void *)(a2 + 40), v19);
        unint64_t v18 = *(void *)(a1 + 40);
LABEL_52:
        if (v20 >= v18) {
          goto LABEL_55;
        }
      }
    }

    unint64_t v20 = 0LL;
    unint64_t v19 = 0LL;
LABEL_55:
    sub_1001AA278((unint64_t)v34, v18 - v20, *(void *)(a1 + 32) + 20 * v20);
    sub_1001AA278((unint64_t)v32, *(void *)(a2 + 40) - v19, *(void *)(a2 + 32) + 20 * v19);
    if (a3)
    {
      uint64_t v30 = sub_1001AB230((uint64_t)v34, a5);
      *a3 = v30;
      uint64_t v13 = v30 != 0;
      if (a4) {
        goto LABEL_57;
      }
    }

    else
    {
      uint64_t v13 = 1LL;
      if (a4)
      {
LABEL_57:
        uint64_t v31 = sub_1001AB230((uint64_t)v32, a5);
        *a4 = (const void *)v31;
        if (v31) {
          uint64_t v13 = v13;
        }
        else {
          uint64_t v13 = 0LL;
        }
      }
    }

    free(v34[0]);
    v34[0] = 0LL;
    v34[1] = 0LL;
    BYTE8(v35) = 0;
    *(void *)&__int128 v35 = 0LL;
    free(v32[0]);
    return v13;
  }

  BOOL v10 = (const void *)sub_1001AAE28(0LL, 0LL, a5);
  if (a3)
  {
    char v11 = (const void *)*a3;
    if ((const void *)*a3 != v10)
    {
      *a3 = (uint64_t)v10;
    }
  }

  if (a4)
  {
    if (a2) {
      uint64_t v12 = (const void *)a2;
    }
    else {
      uint64_t v12 = v10;
    }
    if (v12) {
      CFRetain(v12);
    }
    *a4 = v12;
  }

uint64_t sub_1001AB230(uint64_t result, CFTypeRef *a2)
{
  if (result)
  {
    uint64_t v3 = result;
    if (*(_BYTE *)(result + 24)) {
      sub_1001AA048((char **)result);
    }
    return sub_1001AAE28(*(UInt8 **)v3, 20LL * *(void *)(v3 + 8), a2);
  }

  return result;
}

uint64_t sub_1001AB278(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  *(_OWORD *)uint64_t v12 = 0u;
  __int128 v13 = 0u;
  CFDataRef v7 = (uint64_t *)sub_1001AAE7C(a1);
  CFDataRef v8 = (unint64_t *)sub_1001AAE7C(a2);
  unint64_t v9 = sub_1001AAE7C(a3);
  sub_1001AA664(v7, v8, (uint64_t)v9, (char **)v12);
  uint64_t v10 = sub_1001AB230((uint64_t)v12, a4);
  free(v12[0]);
  return v10;
}

CFTypeRef sub_1001AB300(uint64_t a1, CFTypeRef cf, CFTypeRef *a3)
{
  if (a1 && (unint64_t)CFDataGetLength(*(CFDataRef *)(a1 + 24)) > 0x13)
  {
    *(_OWORD *)uint64_t v10 = 0u;
    __int128 v11 = 0u;
    unint64_t Length = CFDataGetLength(*(CFDataRef *)(a1 + 24));
    *(void *)(a1 + 40) = Length / 0x14;
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = Length / 0x14;
    *(void *)(a1 + 32) = CFDataGetBytePtr(*(CFDataRef *)(a1 + 24));
    uint64_t v7 = a1 + 32;
    *(_BYTE *)(v7 + 24) = 0;
    CFDataRef v8 = (uint64_t *)sub_1001AAE7C((uint64_t)cf);
    sub_1001AA4E4(0LL, (unint64_t *)v7, 0LL, v8, (char **)v10);
    CFTypeRef cf = (CFTypeRef)sub_1001AB230((uint64_t)v10, a3);
    free(v10[0]);
    return cf;
  }

  if (cf)
  {
    CFRetain(cf);
    return cf;
  }

  return (CFTypeRef)sub_1001AAE28(0LL, 0LL, a3);
}

uint64_t sub_1001AB3E8(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  *(_OWORD *)unint64_t v23 = 0u;
  __int128 v24 = 0u;
  uint64_t v5 = (uint64_t *)sub_1001AAE7C(a1);
  uint64_t v6 = (uint64_t *)sub_1001AAE7C(a2);
  unint64_t v7 = v5[1];
  if (v7)
  {
    CFDataRef v8 = v6;
    unint64_t v9 = 0LL;
    unint64_t v10 = 0LL;
    unint64_t v11 = v6[1];
    do
    {
      if (v9 >= v11) {
        break;
      }
      uint64_t v12 = *v5;
      uint64_t v13 = *v5 + 20 * v10;
      uint64_t v14 = *v8;
      if (*v5) {
        BOOL v15 = v14 == 0;
      }
      else {
        BOOL v15 = 1;
      }
      if (v15)
      {
        int v16 = v14 != 0;
        if (v12) {
          goto LABEL_21;
        }
      }

      else
      {
        unint64_t v17 = v14 + 20 * v9;
        unint64_t v18 = bswap64(*(void *)v13);
        unint64_t v19 = bswap64(*(void *)v17);
        if (v18 == v19
          && (v18 = bswap64(*(void *)(v13 + 8)), unint64_t v19 = bswap64(*(void *)(v17 + 8)), v18 == v19)
          && (v18 = bswap32(*(_DWORD *)(v13 + 16)), unint64_t v19 = bswap32(*(_DWORD *)(v17 + 16)), v18 == v19))
        {
          int v16 = 0;
        }

        else if (v18 < v19)
        {
          int v16 = -1;
        }

        else
        {
          int v16 = 1;
        }
      }

      if (!v16)
      {
        sub_1001A9ECC((char **)v23, (__int128 *)v13);
        unint64_t v7 = v5[1];
        unint64_t v10 = sub_1001AA2E8(*v5, v7, v10);
        uint64_t v20 = *v8;
        unint64_t v11 = v8[1];
        goto LABEL_23;
      }

      if ((v16 & 0x80000000) == 0)
      {
        uint64_t v20 = *v8;
LABEL_23:
        unint64_t v9 = sub_1001AA2E8(v20, v11, v9);
        continue;
      }

CFDataRef *sub_1001AB56C(uint64_t a1, CFDataRef *cf, CFTypeRef *a3)
{
  if (a1 && (uint64_t v5 = a1, (unint64_t)CFDataGetLength(*(CFDataRef *)(a1 + 24)) > 0x13))
  {
    if (cf && (unint64_t)CFDataGetLength(cf[3]) > 0x13)
    {
      *(_OWORD *)unint64_t v11 = 0u;
      __int128 v12 = 0u;
      unint64_t Length = CFDataGetLength(*(CFDataRef *)(v5 + 24));
      *(void *)(v5 + 40) = Length / 0x14;
      *(void *)(v5 + 4_Block_object_dispose(va, 8) = Length / 0x14;
      *(void *)(v5 + 32) = CFDataGetBytePtr(*(CFDataRef *)(v5 + 24));
      uint64_t v8 = v5 + 32;
      *(_BYTE *)(v8 + 24) = 0;
      unint64_t v9 = CFDataGetLength(cf[3]);
      cf[5] = (CFDataRef)(v9 / 0x14);
      cf[6] = (CFDataRef)(v9 / 0x14);
      cf[4] = (CFDataRef)CFDataGetBytePtr(cf[3]);
      unint64_t v10 = (char *)(cf + 4);
      v10[24] = 0;
      sub_1001AA344((uint64_t *)v8, (uint64_t)v10, (char **)v11);
      uint64_t v5 = sub_1001AB230((uint64_t)v11, a3);
      free(v11[0]);
    }

    else
    {
      CFRetain((CFTypeRef)v5);
    }
  }

  else
  {
    if (!cf) {
      return (CFDataRef *)sub_1001AAE28(0LL, 0LL, a3);
    }
    CFRetain(cf);
    return cf;
  }

  return (CFDataRef *)v5;
}

void sub_1001AB830( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

id sub_1001AB8D4(uint64_t a1)
{
  return [*(id *)(a1 + 32) onqueueFreeHashBuff];
}

unsigned __int8 *sub_1001AB8DC(const __CFDictionary *a1)
{
  id v1 = (unsigned __int8 *)a1;
  if (a1)
  {
    CFTypeRef v13 = 0LL;
    uint64_t v2 = sub_100012920(a1, (uint64_t)&v13);
    if (v2)
    {
      size_t v3 = v2;
      uint64_t v4 = (char *)&v12 - ((__chkstk_darwin(v2) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      memset(v4, 170, v3);
      if (sub_100012A4C((const __CFDictionary *)v1, &v13, 0, (uint64_t)v4, (uint64_t)&v4[v3]))
      {
        id v1 = (unsigned __int8 *)malloc(0x20uLL);
        CC_SHA256(v4, v3, v1);
      }

      else
      {
        uint64_t v8 = sub_10001267C("key-interests");
        unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          CFTypeRef v15 = v13;
          _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Failed to DER encode dictionary - %@",  buf,  0xCu);
        }

        CFTypeRef v10 = v13;
        if (v13)
        {
          CFTypeRef v13 = 0LL;
          CFRelease(v10);
        }

        return 0LL;
      }
    }

    else
    {
      uint64_t v5 = sub_10001267C("key-interests");
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFTypeRef v15 = v13;
        _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Failed to get size of dictionary - %@",  buf,  0xCu);
      }

      CFTypeRef v7 = v13;
      if (v13)
      {
        CFTypeRef v13 = 0LL;
        CFRelease(v7);
      }

      return 0LL;
    }
  }

  return v1;
}

void sub_1001ABAB0(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  size_t v3 = (uint64_t *)v2[1];
  uint64_t v4 = *(void **)(a1 + 48);
  if (v3)
  {
    if (!v4) {
      goto LABEL_16;
    }
    uint64_t v5 = *v3;
    uint64_t v6 = v3[1];
    uint64_t v8 = v3[2];
    uint64_t v7 = v3[3];
    BOOL v9 = *v4 == v5 && v4[1] == v6;
    BOOL v10 = v9 && v4[2] == v8;
    if (!v10 || v4[3] != v7) {
      goto LABEL_16;
    }
    free(*(void **)(a1 + 48));
    LOBYTE(v4) = 0;
  }

  else if (v4)
  {
LABEL_16:
    [v2 onqueueFreeHashBuff];
    *(void *)(*(void *)(a1 + 32) + 8LL) = *(void *)(a1 + 48);
    LOBYTE(v4) = 1;
  }

  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = (_BYTE)v4;
}

uint64_t sub_1001ABB38(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  if (a3 <= 5 && (unint64_t)a3 - 5 < 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v4 = off_100292810[a3][2];
    if (v4) {
      return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v4)(a1, a2, a4);
    }
  }

  SOSCreateError(1040LL, @"Not valid ring type", 0LL, a4);
  return 0LL;
}

uint64_t sub_1001ABB98(void *a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6 = sub_1001D5AEC(a1);
  if (v6 > 5 || (unint64_t)v6 - 5 >= 0xFFFFFFFFFFFFFFFDLL)
  {
    SOSCreateError(1040LL, @"Not valid ring type", 0LL, a3);
    return 0LL;
  }

  else
  {
    uint64_t v7 = off_100292810[v6][8];
    if (v7) {
      return ((uint64_t (*)(void *, void, uint64_t, uint64_t))v7)(a1, 0LL, a2, a3);
    }
    else {
      return 1LL;
    }
  }

uint64_t sub_1001ABC40(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v8 = sub_1001D5AEC(a1);
  if (v8 <= 5 && (unint64_t)v8 - 5 < 0xFFFFFFFFFFFFFFFDLL)
  {
    BOOL v9 = off_100292810[v8][13];
    if (v9) {
      return ((uint64_t (*)(void *, void, uint64_t, uint64_t, uint64_t))v9)(a1, 0LL, a2, a3, a4);
    }
  }

  SOSCreateError(1040LL, @"Not valid ring type", 0LL, a4);
  return 0LL;
}

uint64_t sub_1001ABCE8(void *a1, uint64_t a2)
{
  unsigned int v4 = sub_1001D5AEC(a1);
  if (v4 <= 5 && (unint64_t)v4 - 5 < 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v5 = off_100292810[v4][14];
    if (v5) {
      return ((uint64_t (*)(void *, uint64_t))v5)(a1, a2);
    }
  }

  SOSCreateError(1040LL, @"Not valid ring type", 0LL, a2);
  return 0LL;
}

const void *sub_1001ABD80(void *a1)
{
  return 0LL;
}

uint64_t sub_1001ABDDC(uint64_t result, CFTypeRef cf)
{
  CFTypeRef v2 = cf;
  uint64_t v3 = result;
  unsigned int v4 = *(__CFString ***)(result + 40);
  if (!cf || (CFTypeID v5 = CFGetTypeID(cf), result = CFStringGetTypeID(), v5 != result))
  {
    if (v4) {
      uint64_t result = sub_1000194E0(-50, v4, @"object %@ is not a string", v2);
    }
    CFTypeRef v2 = 0LL;
  }

  *(void *)(*(void *)(*(void *)(v3 + 32) + 8LL) + 24LL) = v2;
  return result;
}

uint64_t sub_1001ABE58(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_1001ABE6C(void *a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5)
{
  if (!sub_1001ABF14(a1, a5)) {
    return 0LL;
  }
  uint64_t v10 = SOSBSKBCopyEncoded(a4, a5);
  if (!v10) {
    return 0LL;
  }
  unint64_t v11 = (const void *)v10;
  else {
    uint64_t v12 = 0LL;
  }
  CFRelease(v11);
  return v12;
}

BOOL sub_1001ABF14(void *a1, uint64_t a2)
{
  int v3 = sub_1001D5AEC(a1);
  if (v3 != 1) {
    SOSCreateError(1040LL, @"Not backup ring type", 0LL, a2);
  }
  return v3 == 1;
}

uint64_t sub_1001ABF60(void *a1)
{
  if (sub_1001ABF14(a1, 0LL) && (uint64_t v2 = sub_1001ABCE8(a1, 0LL)) != 0) {
    return SOSBackupSliceKeyBagCreateFromData(kCFAllocatorDefault, v2, 0LL);
  }
  else {
    return 0LL;
  }
}

void sub_1001ABFC4(void *a1, uint64_t a2, CFTypeRef *a3)
{
  id v11 = a1;
  if (!a2) {
    goto LABEL_11;
  }
  CFTypeID v5 = *(const void **)(a2 + 40);
  unsigned int v6 = (const void *)SOSRKNullKey();
  if (v5) {
    BOOL v7 = v6 == 0LL;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    if (v5 == v6)
    {
LABEL_11:
      sub_1001A9290(v11, (uint64_t)@"recoveryKeyBag", a3);
      goto LABEL_12;
    }
  }

  else if (CFEqual(v5, v6))
  {
    goto LABEL_11;
  }

  unsigned int v8 = sub_1001B75A8(a2, a3);
  BOOL v9 = v11;
  if (v8)
  {
    sub_1001A93D0(v11, (uint64_t)@"recoveryKeyBag", (uint64_t)v8, a3);
    CFRelease(v8);
LABEL_12:
    BOOL v9 = v11;
  }
}

uint64_t sub_1001AC080(const __CFAllocator *a1, void *a2, CFTypeRef *a3)
{
  CFTypeID v5 = (const __CFData *)sub_10018DFDC(a2, (uint64_t)@"recoveryKeyBag");
  unsigned int v6 = v5;
  if (v5)
  {
    CFTypeID v7 = CFGetTypeID(v5);
    if (v7 == CFDataGetTypeID()) {
      return sub_1001B7724(a1, v6, a3);
    }
  }

  if (a3) {
    sub_1000194E0(-50, (__CFString **)a3, @"object %@ is not a data", v6);
  }
  return 0LL;
}

CFDataRef sub_1001AC124(const __CFAllocator *a1, void *a2, CFTypeRef *a3)
{
  uint64_t v4 = sub_1001AC080(a1, a2, a3);
  if (!v4)
  {
    CFDataRef Copy = 0LL;
    if (!a3) {
      return Copy;
    }
    goto LABEL_7;
  }

  CFTypeID v5 = (const void *)v4;
  CFDataRef Copy = *(const __CFData **)(v4 + 40);
  if (Copy)
  {
    CFTypeID v7 = (const void *)SOSRKNullKey();
    if (v7 && CFEqual(Copy, v7)) {
      CFDataRef Copy = 0LL;
    }
    else {
      CFDataRef Copy = CFDataCreateCopy(kCFAllocatorDefault, Copy);
    }
  }

  CFRelease(v5);
  if (a3)
  {
LABEL_7:
    if (!Copy && !*a3) {
      SOSErrorCreate(1033LL, a3, 0LL, @"No recovery key available");
    }
  }

  return Copy;
}

BOOL sub_1001AC1D4(void *a1, const __CFData *a2, void *a3)
{
  id v5 = a1;
  uint64_t v34 = 0LL;
  __int128 v35 = &v34;
  uint64_t v36 = 0x2020000000LL;
  char v37 = 0;
  uint64_t v30 = 0LL;
  uint64_t v31 = &v30;
  uint64_t v32 = 0x2020000000LL;
  uint64_t v33 = 0LL;
  if ([v5 isInCircle:a3])
  {
    unsigned int v6 = sub_1001AC124(kCFAllocatorDefault, v5, 0LL);
    v29[0] = _NSConcreteStackBlock;
    v29[1] = 3221225472LL;
    v29[2] = sub_1001AC548;
    v29[3] = &unk_1002931B8;
    v29[4] = v6;
    sub_1001AC59C(a2, v29);
    if (v6) {
      CFRelease(v6);
    }
    CFTypeID v7 = (const void *)sub_1001B736C(kCFAllocatorDefault, v5, a2, 0LL);
    sub_1001ABFC4(v5, (uint64_t)v7, 0LL);
    uint64_t v28 = 0LL;
    uint64_t v20 = _NSConcreteStackBlock;
    uint64_t v21 = 3221225472LL;
    uint64_t v22 = sub_1001AC668;
    unint64_t v23 = &unk_100292868;
    id v24 = v5;
    unint64_t v25 = &v30;
    BOOL v26 = &v34;
    int v27 = v7;
    id v8 = v24;
    *(void *)&__int128 buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 3221225472LL;
    id v39 = sub_1001ACA04;
    id v40 = &unk_100292890;
    id v9 = v8;
    id v41 = v9;
    if (sub_10019D758(v9, (uint64_t)@"RecoveryRing", (const void **)&v28, &buf, &v20))
    {
      objc_msgSend(v9, "setPublicKeyStatus:forKey:", 2, 2, v20, v21, v22, v23, v24, v25, v26, v27);
    }

    else
    {

      id v11 = v31;
      uint64_t v12 = (const void *)v31[3];
      if (v12)
      {
        v31[3] = 0LL;
        CFRelease(v12);
        id v11 = v31;
      }

      v11[3] = v28;
      *((_BYTE *)v35 + 24) = 0;
    }

    if (v7) {
      CFRelease(v7);
    }
    CFTypeRef v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "trust", v20, v21, v22, v23));
    int HasBackupKey = SOSPeerInfoHasBackupKey([v13 peerInfo]);

    if (HasBackupKey) {
      sub_1001957A4(v9);
    }
    if (!*((_BYTE *)v35 + 24))
    {
      if (!v31[3]) {
        SOSErrorCreate(1028LL, v31 + 3, 0LL, @"Failed to set Recovery Key");
      }
      CFTypeRef v15 = sub_10001267C("recovery");
      int v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = v31[3];
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v17;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "SetRecoveryPublic Failed: %@",  (uint8_t *)&buf,  0xCu);
      }

      unint64_t v18 = (const void *)v31[3];
      if (a3)
      {
        *a3 = v18;
      }

      else if (v18)
      {
        v31[3] = 0LL;
        CFRelease(v18);
      }
    }

    BOOL v10 = *((_BYTE *)v35 + 24) != 0;
  }

  else
  {
    BOOL v10 = 0LL;
  }

  _Block_object_dispose(&v30, 8);
  _Block_object_dispose(&v34, 8);

  return v10;
}

void sub_1001AC508( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

void sub_1001AC548(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(const __CFData **)(a1 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1001ACA88;
  v3[3] = &unk_1002931B8;
  void v3[4] = a2;
  sub_1001AC59C(v2, v3);
}

void sub_1001AC59C(const __CFData *a1, void *a2)
{
  id v9 = a2;
  if (a1)
  {
    CFIndex Length = CFDataGetLength(a1);
    CFMutableDataRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
    BytePtr = CFDataGetBytePtr(a1);
    CFIndex v6 = CFDataGetLength(a1);
    if (v6 >= 1)
    {
      CFIndex v7 = v6;
      do
      {
        unsigned int v8 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0LL, @"%02X", v8);
        --v7;
      }

      while (v7);
    }
  }

  else
  {
    CFMutableDataRef Mutable = @"(null)";
  }

  v9[2](v9, Mutable);
  CFRelease(Mutable);
}

void *sub_1001AC668(uint64_t a1, void *a2)
{
  CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) trust]);
  id v6 = [v5 trustedCircle];
  id v7 = [*(id *)(a1 + 32) accountKey];
  v28[0] = _NSConcreteStackBlock;
  v28[1] = 3221225472LL;
  v28[2] = sub_1001ACA5C;
  v28[3] = &unk_100292840;
  v28[4] = Mutable;
  SOSCircleForEachValidSyncingPeer(v6, v7, v28);

  BOOL v8 = sub_1001D5D24((uint64_t)a2, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  id v9 = *(void **)(a1 + 32);
  if (*(void *)(a1 + 56))
  {
    if (sub_100199444( a2,  (uint64_t)[*(id *)(a1 + 32) fullPeerInfo],  *(void *)(a1 + 56),  (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)))
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 1;
      goto LABEL_19;
    }

    CFTypeRef v13 = sub_10001267C("SecError");
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v30 = v15;
      int v16 = "SetRecoveryKey failed at SOSRingSetRecoveryKeyBag #1: %@";
LABEL_13:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v16, buf, 0xCu);
      goto LABEL_14;
    }

    goto LABEL_14;
  }

  BOOL v10 = (const __CFData *)SOSRKNullKey(v8);
  uint64_t v11 = sub_1001B736C(kCFAllocatorDefault, v9, v10, (uint64_t *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL));
  if (!v11)
  {
    uint64_t v17 = sub_10001267C("SecError");
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v30 = v18;
      int v16 = "SetRecoveryKey failed at SOSRecoveryKeyBagCreateForAccount: %@";
      goto LABEL_13;
    }

uint64_t sub_1001ACA04(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) peerID]);
  uint64_t v6 = sub_1001ABB38(a2, (uint64_t)v5, 5u, a3);

  return v6;
}

void sub_1001ACA5C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(__CFSet **)(a1 + 32);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(a2);
  CFSetAddValue(v2, PeerID);
}

void sub_1001ACA88(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10001267C("recovery");
  id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    int v7 = 138412546;
    uint64_t v8 = v6;
    __int16 v9 = 2112;
    uint64_t v10 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "SetRecoveryPublic: %@ from %@",  (uint8_t *)&v7,  0x16u);
  }
}

void sub_1001ACB4C(void *a1)
{
  id v1 = a1;
  uint64_t v2 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([v1 queue]);
  dispatch_assert_queue_V2(v2);

  int v3 = (const void *)sub_1001AC080(kCFAllocatorDefault, v1, 0LL);
  uint64_t v4 = qword_1002DEDF8;
  if (v3) {
    BOOL v5 = qword_1002DEDF8 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    goto LABEL_10;
  }

  if (!CFEqual(v3, (CFTypeRef)qword_1002DEDF8))
  {
    uint64_t v4 = qword_1002DEDF8;
LABEL_10:
    int v7 = sub_10001267C("recovery");
    uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 138412546;
      uint64_t v11 = v4;
      __int16 v12 = 2112;
      CFTypeRef v13 = v3;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Recovery Key changed: old %@ new %@",  (uint8_t *)&v10,  0x16u);
    }

    notify_post(kSOSCCRecoveryKeyChanged);
    __int16 v9 = (const void *)qword_1002DEDF8;
    if ((const void *)qword_1002DEDF8 != v3)
    {
      qword_1002DEDF8 = (uint64_t)v3;
    }

uint64_t sub_1001ACCB8()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_1001ACD34;
  block[3] = &unk_100292910;
  void block[4] = &qword_1002DEE08;
  if (qword_1002DEE00 != -1) {
    dispatch_once(&qword_1002DEE00, block);
  }
  return qword_1002DEE08;
}

uint64_t sub_1001ACD34(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass(&unk_1002928B0);
  **(void **)(a1 + 32) = result;
  return result;
}

void sub_1001ACD64(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  if (v2)
  {
    a1[2] = 0LL;
    CFRelease(v2);
  }

  int v3 = (const void *)a1[5];
  if (v3)
  {
    a1[5] = 0LL;
    CFRelease(v3);
  }

  uint64_t v4 = (const void *)a1[6];
  if (v4)
  {
    a1[6] = 0LL;
    CFRelease(v4);
  }

  BOOL v5 = (const void *)a1[7];
  if (v5)
  {
    a1[7] = 0LL;
    CFRelease(v5);
  }

  uint64_t v6 = (const void *)a1[9];
  if (v6)
  {
    a1[9] = 0LL;
    CFRelease(v6);
  }

  int v7 = (const void *)a1[8];
  if (v7)
  {
    a1[8] = 0LL;
    CFRelease(v7);
  }

  uint64_t v8 = (const void *)a1[10];
  if (v8)
  {
    a1[10] = 0LL;
    CFRelease(v8);
  }

uint64_t sub_1001ACDF8(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 88) != *(void *)(a2 + 88)
    || *(void *)(a1 + 96) != *(void *)(a2 + 96)
    || *(double *)(a1 + 104) != *(double *)(a2 + 104))
  {
    return 0LL;
  }

  BOOL v5 = *(const void **)(a1 + 40);
  uint64_t v6 = *(const void **)(a2 + 40);
  if (v5 && v6)
  {
    uint64_t result = CFEqual(v5, v6);
    if (!(_DWORD)result) {
      return result;
    }
  }

  else if (v5 != v6)
  {
    return 0LL;
  }

  int v7 = *(const void **)(a1 + 48);
  uint64_t v8 = *(const void **)(a2 + 48);
  if (v7 && v8)
  {
    uint64_t result = CFEqual(v7, v8);
    if (!(_DWORD)result) {
      return result;
    }
  }

  else if (v7 != v8)
  {
    return 0LL;
  }

  __int16 v9 = *(const void **)(a1 + 56);
  int v10 = *(const void **)(a2 + 56);
  if (v9 && v10)
  {
    uint64_t result = CFEqual(v9, v10);
    if (!(_DWORD)result) {
      return result;
    }
  }

  else if (v9 != v10)
  {
    return 0LL;
  }

  uint64_t v11 = *(const void **)(a1 + 64);
  __int16 v12 = *(const void **)(a2 + 64);
  if (v11 && v12)
  {
    uint64_t result = CFEqual(v11, v12);
    if (!(_DWORD)result) {
      return result;
    }
    goto LABEL_25;
  }

  if (v11 != v12) {
    return 0LL;
  }
LABEL_25:
  CFTypeRef v13 = *(const void **)(a1 + 72);
  uint64_t v14 = *(const void **)(a2 + 72);
  if (v13 && v14) {
    return CFEqual(v13, v14) != 0;
  }
  else {
    return v13 == v14;
  }
}

CFStringRef sub_1001ACF08(uint64_t a1)
{
  uint64_t v2 = *(const __CFData **)(a1 + 40);
  if (v2) {
    BytePtr = CFDataGetBytePtr(v2);
  }
  else {
    BytePtr = (const UInt8 *)&byte_100205558;
  }
  uint64_t v4 = *(const __CFData **)(a1 + 48);
  if (v4) {
    BOOL v5 = CFDataGetBytePtr(v4);
  }
  else {
    BOOL v5 = (const UInt8 *)&byte_100205558;
  }
  uint64_t v6 = *(const __CFData **)(a1 + 56);
  if (v6) {
    int v7 = CFDataGetBytePtr(v6);
  }
  else {
    int v7 = (const UInt8 *)&byte_100205558;
  }
  uint64_t v8 = CFGetAllocator((CFTypeRef)a1);
  CFDateRef v9 = CFDateCreate(v8, *(CFAbsoluteTime *)(a1 + 104));
  CFMutableSetRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
  uint64_t v11 = sub_1001110DC(0LL);
  uint64_t v12 = sub_100101A94(v11);
  if (v12
    && (uint64_t v13 = (*(uint64_t (**)(uint64_t, const CFStringRef, void))(v12 + 8))( v12,  kSecAttrAccessibleWhenUnlocked,  0LL)) != 0)
  {
    uint64_t v14 = v13;
    v43[0] = 0LL;
    v43[1] = v43;
    v43[2] = 0x2000000000LL;
    v43[3] = 16LL;
    CFIndex v15 = sub_1001AD308(a1);
    CFStringAppendFormat(Mutable, 0LL, @"{[%zu]", v15);
    v42[0] = _NSConcreteStackBlock;
    v42[1] = 0x40000000LL;
    v42[2] = sub_1001AD3DC;
    v42[3] = &unk_100292988;
    v42[5] = v14;
    v42[6] = Mutable;
    v42[4] = v43;
    v44[0] = _NSConcreteStackBlock;
    v44[1] = 0x40000000LL;
    v44[2] = sub_1001AD494;
    v44[3] = &unk_100292960;
    v44[5] = 0LL;
    v44[6] = v14;
    void v44[4] = v42;
    sub_1001AD558(a1, 0LL, (uint64_t)v44);
    CFStringAppend(Mutable, @"}");
    _Block_object_dispose(v43, 8);
  }

  else
  {
    CFStringAppend(Mutable, @"{NO DATASOURCE}");
  }

  if (!*(void *)(a1 + 112))
  {
    id v41 = (char *)sub_1001AD238 + 4 * byte_10020544E[sub_1001AD620((void *)a1)];
    __asm { BR              X9 }
  }

  int v16 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v17 = "J";
  uint64_t v19 = *(void *)(a1 + 88);
  uint64_t v18 = *(void *)(a1 + 96);
  uint64_t v20 = *BytePtr;
  uint64_t v21 = BytePtr[1];
  uint64_t v22 = "P";
  if ((v19 & 1) == 0) {
    uint64_t v17 = "j";
  }
  uint64_t v23 = BytePtr[2];
  uint64_t v24 = BytePtr[3];
  unint64_t v25 = "D";
  uint64_t v26 = *v5;
  uint64_t v27 = v5[1];
  if ((v19 & 2) == 0) {
    uint64_t v22 = "p";
  }
  uint64_t v28 = v5[2];
  uint64_t v29 = v5[3];
  uint64_t v30 = *v7;
  uint64_t v31 = v7[1];
  uint64_t v32 = v7[2];
  uint64_t v33 = v7[3];
  uint64_t v35 = *(void *)(a1 + 64);
  uint64_t v34 = *(void *)(a1 + 72);
  if ((v19 & 3) == 0) {
    unint64_t v25 = "d";
  }
  uint64_t v36 = "k";
  if ((v19 & 4) != 0) {
    uint64_t v36 = "K";
  }
  char v37 = "z";
  if ((v19 & 5) != 0) {
    char v37 = "Z";
  }
  if ((v19 & 6) != 0) {
    uint64_t v38 = "H";
  }
  else {
    uint64_t v38 = "h";
  }
  CFStringRef v39 = CFStringCreateWithFormat( v16,  0LL,  @"<MSG %llu %@ %02X%02X%02X%02X %02X%02X%02X%02X %02X%02X%02X%02X %@ %@ %@ %s%s%s%s%s%s%s>",  v18,  v9,  v20,  v21,  v23,  v24,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v35,  v34,  Mutable,  "g",  v17,  v22,  v25,  v36,  v37,  v38);
  if (v9) {
    CFRelease(v9);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v39;
}

void sub_1001AD238(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
}

void sub_1001AD254( int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
}

void sub_1001AD288(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
}

void sub_1001AD2A8( int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
}

CFStringRef sub_1001AD2E4(uint64_t a1)
{
  return sub_1001ACF08(a1);
}

CFIndex sub_1001AD308(uint64_t a1)
{
  uint64_t v2 = *(const __CFArray **)(a1 + 80);
  if (v2) {
    return CFArrayGetCount(v2);
  }
  if (!*(void *)(a1 + 24)) {
    return 0LL;
  }
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 16));
  BOOL v5 = &BytePtr[CFDataGetLength(*(CFDataRef *)(a1 + 16))];
  uint64_t v10 = 0LL;
  uint64_t v11 = &v10;
  uint64_t v12 = 0x2000000000LL;
  uint64_t v13 = 0LL;
  int v7 = *(const UInt8 **)(a1 + 24);
  uint64_t v6 = *(void *)(a1 + 32);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000LL;
  void v9[2] = sub_1001AD8D8;
  v9[3] = &unk_100292938;
  void v9[4] = &v10;
  sub_1001AD6B0(v6, v7, v5, 0LL, (uint64_t)v9);
  uint64_t v8 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v8;
}

void sub_1001AD3DC(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  BOOL v5 = (const __CFData *)(*(uint64_t (**)(uint64_t, void))(*(void *)(a1 + 40) + 112LL))(a2, 0LL);
  BytePtr = CFDataGetBytePtr(v5);
  CFStringAppendFormat( *(CFMutableStringRef *)(a1 + 48),  0LL,  @" %02X%02X%02X%02X",  *BytePtr,  BytePtr[1],  BytePtr[2],  BytePtr[3]);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v8 = *(void *)(v7 + 24) - 1LL;
  *(void *)(v7 + 24) = v8;
  if (!v8)
  {
    CFStringAppend(*(CFMutableStringRef *)(a1 + 48), @"...");
    *a3 = 1;
  }

void sub_1001AD494(uint64_t a1, CFDataRef theData)
{
  CFTypeRef cf = 0LL;
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  unint64_t v6 = sub_1000126F8( kCFAllocatorDefault,  (CFMutableDictionaryRef *)&cf,  *(CFTypeRef **)(a1 + 40),  (uint64_t)BytePtr,  (uint64_t)&BytePtr[Length]);
  CFTypeRef v7 = cf;
  if (v6)
  {
    uint64_t v8 = (const void *)(*(uint64_t (**)(CFTypeRef, void))(*(void *)(a1 + 48) + 128LL))( cf,  *(void *)(a1 + 40));
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
    if (v8) {
      CFRelease(v8);
    }
  }

  if (v7) {
    CFRelease(v7);
  }
}

BOOL sub_1001AD558(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v5 = *(const __CFArray **)(a1 + 80);
  if (v5)
  {
    CFIndex Count = CFArrayGetCount(v5);
    CFIndex v7 = Count - 1;
    if (Count >= 1)
    {
      CFIndex v8 = 0LL;
      do
      {
        CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), v8);
        char v15 = 0;
        (*(void (**)(uint64_t, const void *, char *))(a3 + 16))(a3, ValueAtIndex, &v15);
        if (v15) {
          BOOL v10 = 1;
        }
        else {
          BOOL v10 = v7 == v8;
        }
        ++v8;
      }

      while (!v10);
    }
  }

  else if (*(void *)(a1 + 24))
  {
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 16));
    CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 16));
    return sub_1001AD6B0(*(void *)(a1 + 32), *(const UInt8 **)(a1 + 24), &BytePtr[Length], a2, a3) != 0LL;
  }

  return 1LL;
}

uint64_t sub_1001AD620(void *a1)
{
  if (a1[6])
  {
    uint64_t v2 = a1[8];
    uint64_t v3 = a1[9];
    if (v3 && (unint64_t)CFDataGetLength(*(CFDataRef *)(v3 + 24)) > 0x13)
    {
      return 3LL;
    }

    else if (sub_1001AD308((uint64_t)a1))
    {
      return 3LL;
    }

    else
    {
      return 1LL;
    }
  }

  else if (a1[9])
  {
    return 2LL;
  }

  else
  {
    return a1[5] != 0LL;
  }

const UInt8 *sub_1001AD6B0(uint64_t a1, const UInt8 *a2, const UInt8 *a3, uint64_t a4, uint64_t a5)
{
  char v16 = 0;
  unint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  do
  {
    if (!ccder_decode_tag(&v15, a2, a3) || !v15) {
      break;
    }
    *(void *)__int128 buf = 0LL;
    if (!ccder_decode_constructed_tl(v15, buf, a2, a3))
    {
      SOSErrorCreate(1029LL, a4, 0LL, @"failed to decode object header");
      return 0LL;
    }

    if (a5)
    {
      CFDataRef v10 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, a2, *(void *)buf - (void)a2, kCFAllocatorNull);
      (*(void (**)(uint64_t, CFDataRef, char *))(a5 + 16))(a5, v10, &v16);
      if (v10) {
        CFRelease(v10);
      }
    }

    a2 = *(const UInt8 **)buf;
  }

  while (!v16);
  if (a1 == -1)
  {
    uint64_t v14 = 0LL;
    a2 = (const UInt8 *)ccder_decode_tl(0LL, &v14, a2, a3);
    if (v14)
    {
      uint64_t v13 = (os_log_s *)sub_10001267C("SecWarning");
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 134217984;
        *(void *)&uint8_t buf[4] = a3 - a2;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%td length ", buf, 0xCu);
      }
    }
  }

  if (!v16 && a2 != a3)
  {
    uint64_t v11 = (os_log_s *)sub_10001267C("SecWarning");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      *(void *)&uint8_t buf[4] = a3 - a2;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "%td trailing bytes after objects DER",  buf,  0xCu);
    }
  }

  return a2;
}

uint64_t sub_1001AD8D8(uint64_t result)
{
  return result;
}

CFArrayRef sub_1001AD8F0(uint64_t a1)
{
  uint64_t result = *(const __CFArray **)(a1 + 80);
  if (result)
  {
    CFIndex Count = CFArrayGetCount(result);
    if (Count < 1)
    {
      uint64_t v6 = 0LL;
    }

    else
    {
      CFIndex v4 = Count;
      CFIndex v5 = 0LL;
      uint64_t v6 = 0LL;
      do
      {
        CFTypeRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), v5);
        v6 += CFDataGetLength(ValueAtIndex);
        ++v5;
      }

      while (v4 != v5);
    }
  }

  else
  {
    uint64_t v6 = 0LL;
    if (*(void *)(a1 + 112)) {
      return result;
    }
  }

  if (*(_BYTE *)(a1 + 120)) {
    return (const __CFArray *)(v6 + 4);
  }
  else {
    return (const __CFArray *)ccder_sizeof(0xA000000000000002LL, v6);
  }
}

uint64_t sub_1001AD994(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(const __CFArray **)(a1 + 80);
  if (!v6 && *(void *)(a1 + 112)) {
    return a3;
  }
  if (!*(_BYTE *)(a1 + 120))
  {
    uint64_t v7 = a3;
    if (!v6) {
      goto LABEL_10;
    }
LABEL_8:
    CFIndex Count = CFArrayGetCount(v6);
    CFIndex v10 = Count - 1;
    if (Count >= 1)
    {
      do
      {
        CFTypeRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), v10);
        CFIndex Length = CFDataGetLength(ValueAtIndex);
        BytePtr = CFDataGetBytePtr(ValueAtIndex);
        uint64_t v7 = ccder_encode_body(Length, BytePtr, a2, v7);
        --v10;
      }

      while (v10 != -1);
    }

    goto LABEL_10;
  }

  uint64_t v7 = ccder_encode_tl(0LL, 0LL, a2, a3);
  uint64_t v6 = *(const __CFArray **)(a1 + 80);
  if (v6) {
    goto LABEL_8;
  }
LABEL_10:
  if (*(_BYTE *)(a1 + 120))
  {
    uint64_t v14 = ccder_encode_len(0LL, a2, v7);
    return ccder_encode_tag(0xA000000000000002LL, a2, v14);
  }

  else
  {
    if (*(void *)(a1 + 112)) {
      unint64_t v15 = 0xA000000000000002LL;
    }
    else {
      unint64_t v15 = 0x2000000000000010LL;
    }
    return ccder_encode_constructed_tl(v15, a3, a2, v7);
  }

uint64_t sub_1001ADAE8(uint64_t a1, CFDataRef theData, uint64_t a3, uint64_t a4)
{
  if (!theData) {
    return a4;
  }
  CFIndex Length = CFDataGetLength(theData);
  BytePtr = CFDataGetBytePtr(theData);
  return ccder_encode_implicit_raw_octet_string(a1, Length, BytePtr, a3, a4);
}

const UInt8 *sub_1001ADB64(uint64_t a1, CFDataRef *a2, uint64_t a3, uint64_t a4)
{
  CFIndex length = 0LL;
  CFIndex v5 = (const UInt8 *)ccder_decode_tl(a1, &length, a3, a4);
  uint64_t v6 = v5;
  if (a2 && v5)
  {
    CFDataRef v7 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v5, length, kCFAllocatorNull);
    *a2 = v7;
    if (v7) {
      v6 += length;
    }
    else {
      return 0LL;
    }
  }

  return v6;
}

const UInt8 *sub_1001ADBE0(uint64_t a1, CFTypeRef *a2, uint64_t a3, uint64_t a4)
{
  CFTypeRef v12 = 0LL;
  CFTypeRef cf = 0LL;
  CFDataRef v7 = sub_1001ADB64(4LL, (CFDataRef *)&cf, a3, a4);
  CFIndex v8 = sub_1001ADB64(4LL, (CFDataRef *)&v12, (uint64_t)v7, a4);
  if (v8)
  {
    *(void *)(a1 + 64) = sub_1001AAD88((const __CFData *)cf, a2);
    CFDateRef v9 = (const void *)sub_1001AAD88((const __CFData *)v12, a2);
    *(void *)(a1 + 72) = v9;
    CFIndex v10 = *(const void **)(a1 + 64);
    if (!v10 || !v9)
    {
      if (v10)
      {
        *(void *)(a1 + 64) = 0LL;
        CFRelease(v10);
        CFDateRef v9 = *(const void **)(a1 + 72);
      }

      if (v9)
      {
        *(void *)(a1 + 72) = 0LL;
        CFRelease(v9);
      }

      CFIndex v8 = 0LL;
    }
  }

  if (cf) {
    CFRelease(cf);
  }
  if (v12) {
    CFRelease(v12);
  }
  return v8;
}

CFDictionaryRef sub_1001ADE20(CFDictionaryRef result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    CFDictionaryRef v5 = result;
    CFTypeID v6 = CFGetTypeID(result);
    if (v6 == CFStringGetTypeID())
    {
      if (a2)
      {
        keys[0] = @"peer-id";
        keys[1] = @"views";
        if (a3)
        {
          keys[2] = @"keybag";
          values = v5;
          uint64_t v10 = a2;
          uint64_t v11 = a3;
          CFDataRef v7 = kCFAllocatorDefault;
          CFIndex v8 = 3LL;
        }

        else
        {
          values = v5;
          uint64_t v10 = a2;
          CFDataRef v7 = kCFAllocatorDefault;
          CFIndex v8 = 2LL;
        }

        return CFDictionaryCreate( v7,  (const void **)keys,  (const void **)&values,  v8,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
      }

      else
      {
        return (CFDictionaryRef)CFRetain(v5);
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

CFTypeRef sub_1001ADF60(CFTypeRef cf, void *a2, void *a3, __CFString **a4)
{
  if (!cf || (CFTypeID v8 = CFGetTypeID(cf), v8 != CFDictionaryGetTypeID()))
  {
    if (a2) {
      *a2 = SOSViewsGetV0ViewSet();
    }
    if (cf)
    {
      CFTypeID v18 = CFGetTypeID(cf);
      if (v18 == CFStringGetTypeID()) {
        return cf;
      }
    }

    if (a4) {
      sub_1000194E0(-50, a4, @"object %@ is not a string", cf);
    }
    return 0LL;
  }

  signed int Value = CFDictionaryGetValue((CFDictionaryRef)cf, @"peer-id");
  uint64_t v10 = Value;
  if (!Value || (CFTypeID v11 = CFGetTypeID(Value), v11 != CFStringGetTypeID()))
  {
    if (a4) {
      sub_1000194E0(-50, a4, @"object %@ is not a string", v10);
    }
    uint64_t v10 = 0LL;
  }

  CFTypeRef v12 = CFDictionaryGetValue((CFDictionaryRef)cf, @"views");
  uint64_t v13 = v12;
  if (!v12 || (CFTypeID v14 = CFGetTypeID(v12), v14 != CFSetGetTypeID()))
  {
    if (a4) {
      sub_1000194E0(-50, a4, @"object %@ is not a set", v13);
    }
    return 0LL;
  }

  unint64_t v15 = CFDictionaryGetValue((CFDictionaryRef)cf, @"keybag");
  char v16 = v15;
  if (v15)
  {
    CFTypeID v17 = CFGetTypeID(v15);
    if (v17 != CFDataGetTypeID())
    {
      if (a4) {
        sub_1000194E0(-50, a4, @"object %@ is not an data", v16);
      }
      return 0LL;
    }
  }

  if (a3) {
    *a3 = v16;
  }
  if (a2) {
    *a2 = v13;
  }
  return v10;
}

CFDictionaryRef sub_1001AE104( __CFDictionary *cf, const void *a2, const void *a3, int a4, int a5, int a6, int a7, int a8)
{
  MutableCFDataRef Copy = cf;
  if (a2)
  {
    if (!cf) {
      return sub_100107FA8( kCFAllocatorDefault,  (int)a2,  (int)a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t)@"views",  (uint64_t)a2);
    }
  }

  else
  {
    sub_10001BB24(@"Execution has encountered an unexpected state", 0x53C0000Eu);
    if (!MutableCopy) {
      return sub_100107FA8( kCFAllocatorDefault,  (int)a2,  (int)a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t)@"views",  (uint64_t)a2);
    }
  }

  CFTypeID v11 = CFGetTypeID(MutableCopy);
  if (v11 != sub_1001AE23C())
  {
    CFTypeID v12 = CFGetTypeID(MutableCopy);
    if (v12 == CFDictionaryGetTypeID())
    {
      MutableCFDataRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, MutableCopy);
      CFDictionarySetValue(MutableCopy, @"views", a2);
      if (a3) {
        CFDictionarySetValue(MutableCopy, @"keybag", a3);
      }
      else {
        CFDictionaryRemoveValue(MutableCopy, @"keybag");
      }
      return MutableCopy;
    }

    return sub_100107FA8( kCFAllocatorDefault,  (int)a2,  (int)a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t)@"views",  (uint64_t)a2);
  }

  sub_1001AE2B8((uint64_t)MutableCopy, (CFSetRef)a2);
  sub_1001AE3AC((uint64_t)MutableCopy, a3);
  CFRetain(MutableCopy);
  return MutableCopy;
}

uint64_t sub_1001AE23C()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1001AEDB4;
  block[3] = &unk_1002935A8;
  void block[4] = &qword_1002DEE18;
  if (qword_1002DEE10 != -1) {
    dispatch_once(&qword_1002DEE10, block);
  }
  return qword_1002DEE18;
}

void sub_1001AE2B8(uint64_t a1, CFSetRef theSet)
{
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4)
  {
    uint64_t v8 = 0LL;
    CFDateRef v9 = &v8;
    uint64_t v10 = 0x2020000000LL;
    char v11 = 1;
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    void v7[2] = sub_1001AED6C;
    void v7[3] = &unk_100292A88;
    void v7[4] = &v8;
    v7[5] = v4;
    CFSetApplyFunction(theSet, (CFSetApplierFunction)sub_1001AEDA0, v7);
    int v5 = *((unsigned __int8 *)v9 + 24);
    _Block_object_dispose(&v8, 8);
    if (!v5) {
      *(_BYTE *)(a1 + 50) = 0;
    }
  }

  CFSetRef v6 = *(CFSetRef *)(a1 + 24);
  if (v6 != theSet)
  {
    if (!theSet || (CFRetain(theSet), (CFSetRef v6 = *(CFSetRef *)(a1 + 24)) != 0LL)) {
      CFRelease(v6);
    }
    *(void *)(a1 + 24) = theSet;
  }

void sub_1001AE394( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1001AE3AC(uint64_t a1, CFTypeRef cf1)
{
  CFTypeRef v4 = *(CFTypeRef *)(a1 + 112);
  BOOL v5 = v4 == 0LL;
  if (cf1 && v4)
  {
    if (CFEqual(cf1, v4)) {
      return;
    }
    BOOL v5 = *(void *)(a1 + 112) == 0LL;
LABEL_7:
    CFSetRef v6 = sub_10001267C("backup");
    CFDataRef v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(a1 + 16);
      int v14 = 138412546;
      uint64_t v15 = v8;
      __int16 v16 = 2112;
      CFTypeRef v17 = cf1;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%@ backup bag: %@", (uint8_t *)&v14, 0x16u);
    }

    if (*(CFTypeRef *)(a1 + 112) != cf1)
    {
      CFRetain(cf1);
      CFDateRef v9 = *(const void **)(a1 + 112);
      if (v9) {
        CFRelease(v9);
      }
      *(void *)(a1 + 112) = cf1;
    }

    goto LABEL_13;
  }

  if (v4 == cf1) {
    return;
  }
  if (cf1) {
    goto LABEL_7;
  }
  uint64_t v10 = sub_10001267C("SecWarning");
  char v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *(void *)(a1 + 16);
    int v14 = 138412290;
    uint64_t v15 = v12;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "%@ keybag for backup unset",  (uint8_t *)&v14,  0xCu);
  }

  uint64_t v13 = *(const void **)(a1 + 112);
  if (!v13)
  {
LABEL_13:
    if (v5) {
      return;
    }
    goto LABEL_14;
  }

  CFRelease(v13);
  *(void *)(a1 + 112) = 0LL;
  if (!v4) {
    return;
  }
LABEL_14:
  sub_1001AE554(a1);
}

void sub_1001AE554(uint64_t a1)
{
  *(_BYTE *)(a1 + 49) = 0;
  if (*(void *)(a1 + 112))
  {
    sub_1001AE92C(a1, 0LL);
    uint64_t v2 = *(void *)(a1 + 16);
    uint64_t v3 = sub_10001267C("syncwith");
    CFTypeRef v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v2;
      _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "SOSCCAccountTriggerSyncWithBackupPeer_server: %@",  (uint8_t *)&buf,  0xCu);
    }

    if (v2)
    {
      id v6 = sub_1001C2128(1LL, v5);
      CFDataRef v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
      if ([v7 SOSMonitorModeSOSIsActive])
      {
        *(void *)&__int128 buf = v2;
        uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &buf, 1LL));
        [v7 triggerBackupForPeers:v8];
      }
    }
  }

  else
  {
    uint64_t v11 = 0LL;
    uint64_t v12 = &v11;
    uint64_t v13 = 0x2020000000LL;
    char v14 = 1;
    *(void *)&__int128 buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 3221225472LL;
    __int16 v16 = sub_1001AE70C;
    CFTypeRef v17 = &unk_100292AB0;
    CFTypeID v18 = &v11;
    uint64_t v19 = a1;
    uint64_t v20 = 0LL;
    BOOL v9 = sub_1001AE804(a1, 0LL, &buf);
    if (*((_BYTE *)v12 + 24)) {
      BOOL v10 = v9;
    }
    else {
      BOOL v10 = 0;
    }
    *((_BYTE *)v12 + 24) = v10;
    _Block_object_dispose(&v11, 8);
  }

void sub_1001AE6EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_1001AE70C(uint64_t a1, const char *a2)
{
  CFTypeRef v4 = sub_10001267C("backup");
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 40);
    *(_DWORD *)__int128 buf = 138412546;
    uint64_t v17 = v6;
    __int16 v18 = 2080;
    uint64_t v19 = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%@ unlinking journal file %s", buf, 0x16u);
  }

  int v7 = unlink(a2);
  BOOL result = sub_1000193E4(v7, *(CFTypeRef **)(a1 + 48), @"unlink %s", v8, v9, v10, v11, v12, (char)a2);
  uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 8LL);
  if (*(_BYTE *)(v14 + 24)) {
    BOOL v15 = result;
  }
  else {
    BOOL v15 = 0;
  }
  *(_BYTE *)(v14 + 24) = v15;
  return result;
}

BOOL sub_1001AE804(uint64_t a1, CFTypeRef *a2, void *a3)
{
  id v5 = a3;
  memset(__b, 170, sizeof(__b));
  if (confstr(65537, __b, 0x401uLL))
  {
    uint64_t v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @"%s/SOSBackup-%@", __b, *(void *)(a1 + 16));
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 0x40000000LL;
    void v15[2] = sub_1000134E4;
    v15[3] = &unk_100283030;
    void v15[4] = v5;
    sub_10001337C(v11, (uint64_t)v15);
    if (v11) {
      CFRelease(v11);
    }
    BOOL v12 = 1LL;
  }

  else
  {
    BOOL v12 = sub_1000193E4( -1,  a2,  @"confstr on _CS_DARWIN_USER_TEMP_DIR returned an error.",  v6,  v7,  v8,  v9,  v10,  v14);
  }

  return v12;
}

uint64_t sub_1001AE92C(uint64_t a1, void *a2)
{
  uint64_t v26 = 0LL;
  uint64_t v27 = &v26;
  uint64_t v28 = 0x2020000000LL;
  char v29 = 1;
  uint64_t v22 = 0LL;
  uint64_t v23 = &v22;
  uint64_t v24 = 0x2020000000LL;
  CFTypeRef v25 = 0LL;
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472LL;
  v21[2] = sub_1001AEBD4;
  v21[3] = &unk_100292AD8;
  v21[5] = &v22;
  v21[6] = a1;
  void v21[4] = &v26;
  CFTypeRef v4 = v21;
  *(void *)__int128 buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 3221225472LL;
  *(void *)&uint8_t buf[16] = sub_1001AECCC;
  uint64_t v31 = &unk_100292B00;
  id v32 = v4;
  uint64_t v33 = &v25;
  id v5 = v4;
  BOOL v6 = sub_1001AE804(a1, &v25, buf);

  if (*((_BYTE *)v27 + 24)) {
    BOOL v7 = v6;
  }
  else {
    BOOL v7 = 0;
  }
  *((_BYTE *)v27 + 24) = v7;
  if (v7)
  {
    uint64_t v8 = sub_10001267C("backup-peer");
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(void *)(a1 + 16);
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%@ Wrote reset.", buf, 0xCu);
    }
  }

  else
  {
    uint64_t v11 = sub_10001267C("SecWarning");
    BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = *(void *)(a1 + 16);
      uint64_t v14 = v23[3];
      *(_DWORD *)__int128 buf = 138412546;
      *(void *)&uint8_t buf[4] = v13;
      *(_WORD *)&_BYTE buf[12] = 2112;
      *(void *)&buf[14] = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "%@ failed to write reset to backup journal: %@",  buf,  0x16u);
    }

    BOOL v15 = (const void *)v23[3];
    if (v15)
    {
      if (a2 && !*a2) {
        *a2 = v15;
      }
      else {
        CFRelease(v15);
      }
    }
  }

  __int16 v16 = *(const void **)(a1 + 72);
  if (v16)
  {
    CFRelease(v16);
    *(void *)(a1 + 72) = 0LL;
  }

  uint64_t v17 = *(const void **)(a1 + 80);
  if (v17)
  {
    *(void *)(a1 + 80) = 0LL;
    CFRelease(v17);
  }

  __int16 v18 = v27;
  *(_BYTE *)(a1 + 4_Block_object_dispose(&a9, 8) = *((_BYTE *)v27 + 24) ^ 1;
  uint64_t v19 = *((unsigned __int8 *)v18 + 24);
  _Block_object_dispose(&v22, 8);
  _Block_object_dispose(&v26, 8);
  return v19;
}

void sub_1001AEBA8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1001AEBD4(void *a1, FILE *a2)
{
  uint64_t v4 = *(void *)(a1[6] + 112LL);
  id v5 = (__CFString **)(*(void *)(a1[5] + 8LL) + 24LL);
  if (v4)
  {
    CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1[6] + 112LL));
    uint64_t v7 = ccder_sizeof_raw_octet_string(Length);
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  size_t v8 = ccder_sizeof(0x2000000000000010LL, v7);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000LL;
  _DWORD v10[2] = sub_1001A5508;
  v10[3] = &unk_100292460;
  void v10[4] = v4;
  v10[5] = v5;
  BOOL result = sub_1001A5578(a2, v5, v8, (uint64_t)v10);
  *(_BYTE *)(*(void *)(a1[4] + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = result;
  if (*(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL))
  {
    if (!*(void *)(a1[6] + 112LL))
    {
      BOOL result = sub_1001A57DC(a2, 999LL, (__CFString **)(*(void *)(a1[5] + 8LL) + 24LL));
      *(_BYTE *)(*(void *)(a1[4] + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = result;
    }
  }

  return result;
}

uint64_t sub_1001AECCC(uint64_t a1, char *__filename)
{
  char v2 = (char)__filename;
  uint64_t v4 = *(CFTypeRef **)(a1 + 40);
  id v5 = fopen(__filename, "w");
  uint64_t result = sub_1000193E4(v5 == 0LL, v4, @"fopen %s,%s", v6, v7, v8, v9, v10, v2);
  if (v5)
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
    return fclose(v5);
  }

  return result;
}

uint64_t sub_1001AED6C(uint64_t a1, const void *a2)
{
  uint64_t result = CFSetContainsValue(*(CFSetRef *)(a1 + 40), a2);
  if (!(_DWORD)result) {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 0;
  }
  return result;
}

uint64_t sub_1001AEDA0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_1001AEDB4(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass(&unk_1002929A8);
  **(void **)(a1 + 32) = result;
  return result;
}

void sub_1001AEDE4(void *a1)
{
  char v2 = (const void *)a1[2];
  if (v2)
  {
    a1[2] = 0LL;
    CFRelease(v2);
  }

  uint64_t v3 = (const void *)a1[3];
  if (v3)
  {
    a1[3] = 0LL;
    CFRelease(v3);
  }

  uint64_t v4 = (const void *)a1[7];
  if (v4)
  {
    a1[7] = 0LL;
    CFRelease(v4);
  }

  id v5 = (const void *)a1[8];
  if (v5)
  {
    a1[8] = 0LL;
    CFRelease(v5);
  }

  uint64_t v6 = (const void *)a1[9];
  if (v6)
  {
    a1[9] = 0LL;
    CFRelease(v6);
  }

  uint64_t v7 = (const void *)a1[10];
  if (v7)
  {
    a1[10] = 0LL;
    CFRelease(v7);
  }

  uint64_t v8 = (const void *)a1[11];
  if (v8)
  {
    a1[11] = 0LL;
    CFRelease(v8);
  }

  uint64_t v9 = (const void *)a1[13];
  if (v9)
  {
    a1[13] = 0LL;
    CFRelease(v9);
  }

  uint64_t v10 = (const void *)a1[12];
  if (v10)
  {
    a1[12] = 0LL;
    CFRelease(v10);
  }

  uint64_t v11 = (const void *)a1[14];
  if (v11)
  {
    a1[14] = 0LL;
    CFRelease(v11);
  }

BOOL sub_1001AEEA8(uint64_t a1, uint64_t a2)
{
  return CFStringCompare(*(CFStringRef *)(a1 + 16), *(CFStringRef *)(a2 + 16), 0LL) == kCFCompareEqualTo;
}

CFStringRef sub_1001AEED0(uint64_t a1)
{
  if (!a1) {
    return @"NULL";
  }
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2) {
    CFStringRef v3 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @" %@%@", @"O", v2);
  }
  else {
    CFStringRef v3 = @" -  ";
  }
  uint64_t v5 = *(void *)(a1 + 64);
  if (v5) {
    CFStringRef v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @" %@%@", @"U", v5);
  }
  else {
    CFStringRef v6 = @" -  ";
  }
  uint64_t v7 = *(void *)(a1 + 72);
  if (v7) {
    CFStringRef v8 = CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @" %@%@", @"C", v7);
  }
  else {
    CFStringRef v8 = @" -  ";
  }
  CFStringRef v9 = sub_1001AF0E0(*(const __CFArray **)(a1 + 80), (uint64_t)@"P");
  CFStringRef v10 = sub_1001AF0E0(*(const __CFArray **)(a1 + 88), (uint64_t)@"L");
  CFStringRef v11 = v10;
  if (*(_BYTE *)(a1 + 48)) {
    uint64_t v12 = "F";
  }
  else {
    uint64_t v12 = "f";
  }
  uint64_t v13 = "S";
  if (!*(_BYTE *)(a1 + 49)) {
    uint64_t v13 = "s";
  }
  if (*(_BYTE *)(a1 + 50)) {
    uint64_t v14 = "K";
  }
  else {
    uint64_t v14 = "k";
  }
  CFStringRef v4 = CFStringCreateWithFormat( kCFAllocatorDefault,  0LL,  @"<%@ %s%s%s%@%@%@%@%@>",  *(void *)(a1 + 16),  v12,  v13,  v14,  v3,  v6,  v8,  v9,  v10);
  if (v11) {
    CFRelease(v11);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v6) {
    CFRelease(v6);
  }
  if (v3) {
    CFRelease(v3);
  }
  return v4;
}

CFStringRef sub_1001AF0BC(uint64_t a1)
{
  return sub_1001AEED0(a1);
}

CFStringRef sub_1001AF0E0(const __CFArray *a1, uint64_t a2)
{
  if (!a1) {
    return @" -  ";
  }
  CFIndex Count = CFArrayGetCount(a1);
  if (!Count) {
    return @" -  ";
  }
  CFIndex v5 = Count;
  CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex(a1, 0LL);
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0LL, @" %@[%ld]%@", a2, v5, ValueAtIndex);
}

__CFDictionary *sub_1001AF160(uint64_t a1)
{
  CFMutableSetRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  uint64_t valuePtr = *(void *)(a1 + 40);
  CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &valuePtr);
  CFDictionarySetValue(Mutable, @"sequence-number", v3);
  if (v3) {
    CFRelease(v3);
  }
  if (*(void *)(a1 + 32))
  {
    uint64_t valuePtr = *(void *)(a1 + 32);
    CFNumberRef v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
    CFDictionarySetValue(Mutable, @"vers", v4);
    if (v4) {
      CFRelease(v4);
    }
  }

  if (*(_BYTE *)(a1 + 48)) {
    CFBooleanRef v5 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v5 = kCFBooleanFalse;
  }
  CFDictionarySetValue(Mutable, @"must-send", v5);
  if (*(_BYTE *)(a1 + 49)) {
    CFBooleanRef v6 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v6 = kCFBooleanFalse;
  }
  CFDictionarySetValue(Mutable, @"send-objects", v6);
  if (*(_BYTE *)(a1 + 50)) {
    CFBooleanRef v7 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v7 = kCFBooleanFalse;
  }
  CFDictionarySetValue(Mutable, @"has-been-in-sync", v7);
  CFStringRef v8 = *(const void **)(a1 + 24);
  if (v8) {
    CFDictionarySetValue(Mutable, @"views", v8);
  }
  CFStringRef v9 = *(const void **)(a1 + 112);
  if (v9 && !CFEqual(*(CFTypeRef *)(a1 + 16), kSOSViewKeychainV0_tomb)) {
    CFDictionarySetValue(Mutable, @"keybag", v9);
  }
  if (!sub_1001AF378(Mutable, @"pending-objects", *(__CFData **)(a1 + 56))
    || !sub_1001AF378(Mutable, @"unwanted-manifest", *(__CFData **)(a1 + 64))
    || !sub_1001AF378(Mutable, @"confirmed-manifest", *(__CFData **)(a1 + 72))
    || !sub_1001AF3C4(Mutable, @"pending-manifest", *(const __CFArray **)(a1 + 80))
    || !sub_1001AF3C4(Mutable, @"local-manifest", *(const __CFArray **)(a1 + 88)))
  {
    if (Mutable)
    {
      CFRelease(Mutable);
      return 0LL;
    }
  }

  return Mutable;
}

uint64_t sub_1001AF378(__CFDictionary *a1, const void *a2, __CFData *a3)
{
  if (!a3) {
    return 1LL;
  }
  uint64_t result = (uint64_t)sub_1001AABD0(a3);
  if (result)
  {
    CFDictionarySetValue(a1, a2, (const void *)result);
    return 1LL;
  }

  return result;
}

BOOL sub_1001AF3C4(__CFDictionary *a1, const void *a2, const __CFArray *a3)
{
  CFMutableSetRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  if (a3)
  {
    CFIndex Count = CFArrayGetCount(a3);
    if (Count >= 1)
    {
      CFIndex v8 = Count;
      for (CFIndex i = 0LL; i != v8; ++i)
      {
        CFTypeRef ValueAtIndex = (__CFData *)CFArrayGetValueAtIndex(a3, i);
        CFStringRef v11 = sub_1001AABD0(ValueAtIndex);
        if (v11)
        {
          if (Mutable) {
            CFArrayAppendValue(Mutable, v11);
          }
        }

        else if (Mutable)
        {
          CFRelease(Mutable);
          CFMutableSetRef Mutable = 0LL;
        }
      }
    }
  }

  if (Mutable)
  {
    CFDictionarySetValue(a1, a2, Mutable);
    CFRelease(Mutable);
  }

  return Mutable != 0LL;
}

CFDictionaryRef sub_1001AF49C(const __CFDictionary *result)
{
  if (result)
  {
    id v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 == sub_1001AE23C()) {
      BOOL v3 = *((void *)v1 + 14) == 0LL;
    }
    else {
      BOOL v3 = CFDictionaryContainsKey(v1, @"keybag") == 0;
    }
    return (const __CFDictionary *)!v3;
  }

  return result;
}

void sub_1001AF4F4(uint64_t a1, char *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = open(a2, 0x1000000);
  if (sub_1000193E4( *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) >> 31,  *(CFTypeRef **)(a1 + 40),  @"open %s",  v4,  v5,  v6,  v7,  v8,  (char)a2))
  {
    int v9 = unlink(a2);
    if (sub_1000193E4(v9, *(CFTypeRef **)(a1 + 40), @"unlink %s", v10, v11, v12, v13, v14, (char)a2))
    {
      BOOL v15 = sub_10001267C("backup");
      __int16 v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        int v17 = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
        v18.tv_sec = 0xAAAAAAAAAAAAAAAALL;
        v18.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
        *(timespec *)&v24.st_blksize = v18;
        *(timespec *)v24.st_qspare = v18;
        v24.st_birthtimespec = v18;
        *(timespec *)&v24.st_size = v18;
        v24.st_mtimespec = v18;
        v24.st_ctimespec = v18;
        *(timespec *)&v24.st_uid = v18;
        v24.st_atimespec = v18;
        *(timespec *)&v24.st_dev = v18;
        fstat(v17, &v24);
        v24.st_dev = 136315394;
        *(void *)&v24.st_mode = a2;
        WORD2(v24.st_ino) = 2048;
        *(__darwin_ino64_t *)((char *)&v24.st_ino + 6) = v24.st_size;
        uint64_t v19 = "Handing off file %s of size %llu";
LABEL_13:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v19, (uint8_t *)&v24, 0x16u);
      }
    }

    else
    {
      close(*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = -1;
      uint64_t v22 = sub_10001267C("backup");
      __int16 v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v23 = *(void **)(a1 + 40);
        if (v23) {
          uint64_t v23 = (void *)*v23;
        }
        v24.st_dev = 136315394;
        *(void *)&v24.st_mode = a2;
        WORD2(v24.st_ino) = 2112;
        *(__darwin_ino64_t *)((char *)&v24.st_ino + 6) = (__darwin_ino64_t)v23;
        uint64_t v19 = "Unable to unlink file %s: %@";
        goto LABEL_13;
      }
    }
  }

  else
  {
    uint64_t v20 = sub_10001267C("backup");
    __int16 v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = *(void **)(a1 + 40);
      if (v21) {
        uint64_t v21 = (void *)*v21;
      }
      v24.st_dev = 136315394;
      *(void *)&v24.st_mode = a2;
      WORD2(v24.st_ino) = 2112;
      *(__darwin_ino64_t *)((char *)&v24.st_ino + 6) = (__darwin_ino64_t)v21;
      uint64_t v19 = "Handing off file %s failed, %@";
      goto LABEL_13;
    }
  }
}

BOOL sub_1001AF718(uint64_t a1, CFTypeRef *a2, void *a3)
{
  uint64_t v12 = 0LL;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2020000000LL;
  char v15 = 1;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_1001AF800;
  void v7[3] = &unk_100292A38;
  uint64_t v10 = a2;
  uint64_t v11 = a1;
  int v9 = &v12;
  id v3 = a3;
  id v8 = v3;
  BOOL v4 = sub_1001AE804(v11, v10, v7);
  if (*((_BYTE *)v13 + 24)) {
    BOOL v5 = v4;
  }
  else {
    BOOL v5 = 0LL;
  }
  *((_BYTE *)v13 + 24) = v5;

  _Block_object_dispose(&v12, 8);
  return v5;
}

void sub_1001AF7E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_1001AF800(uint64_t a1, char *__filename)
{
  char v2 = (char)__filename;
  BOOL v4 = *(CFTypeRef **)(a1 + 48);
  BOOL v5 = fopen(__filename, "a");
  uint64_t result = sub_1000193E4(v5 == 0LL, v4, @"fopen %s,%s", v6, v7, v8, v9, v10, v2);
  if (v5)
  {
    int v21 = -1;
    uint64_t v12 = *(void *)(a1 + 48);
    uint64_t v13 = *(void *)(a1 + 56);
    if (CFEqual(*(CFTypeRef *)(v13 + 16), kSOSViewKeychainV0_tomb))
    {
      uint64_t v14 = *(const __CFData **)(v13 + 112);
      if (v14) {
        CFRetain(*(CFTypeRef *)(v13 + 112));
      }
    }

    else
    {
      uint64_t v15 = SOSBackupSliceKeyBagCreateFromData(kCFAllocatorDefault, *(void *)(v13 + 112), v12);
      if (v15)
      {
        __int16 v16 = (const void *)v15;
        uint64_t v14 = (const __CFData *)SOSBSKBCopyAKSBag(v15, v12);
        CFRelease(v16);
      }

      else
      {
        uint64_t v14 = 0LL;
      }
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v14 != 0LL;
    if (*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL))
    {
      BOOL v17 = sub_100120628(v14, 0LL, &v21, *(CFTypeRef **)(a1 + 48));
      *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v17;
      if (v17)
      {
        (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
        if (v21 != -1)
        {
          BOOL v18 = sub_100120750(v21, *(CFTypeRef **)(a1 + 48));
          uint64_t v19 = *(void *)(*(void *)(a1 + 40) + 8LL);
          if (*(_BYTE *)(v19 + 24)) {
            BOOL v20 = v18;
          }
          else {
            BOOL v20 = 0;
          }
          *(_BYTE *)(v19 + 24) = v20;
        }
      }
    }

    if (v14) {
      CFRelease(v14);
    }
    return fclose(v5);
  }

  return result;
}

BOOL sub_1001AF984(uint64_t a1, uint64_t a2, CFDictionaryRef theDict, __CFArray *a4)
{
  if (!theDict) {
    return 1LL;
  }
  signed int Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"vers");
  if (Value) {
    CFNumberGetValue(Value, kCFNumberCFIndexType, (void *)(a1 + 32));
  }
  *(void *)uint64_t v31 = 0LL;
  uint64_t v9 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"sequence-number");
  if (v9)
  {
    CFNumberGetValue(v9, kCFNumberSInt64Type, v31);
    uint64_t v10 = *(void *)v31;
  }

  else
  {
    uint64_t v10 = 0LL;
  }

  *(void *)(a1 + 40) = v10;
  *(_BYTE *)(a1 + 4_Block_object_dispose(va, 8) = sub_1001AFC54(theDict, @"must-send");
  *(_BYTE *)(a1 + 49) = sub_1001AFC54(theDict, @"send-objects");
  *(_BYTE *)(a1 + 50) = sub_1001AFC54(theDict, @"has-been-in-sync");
  uint64_t V0ViewSet = CFDictionaryGetValue(theDict, @"views");
  if (!V0ViewSet)
  {
    uint64_t V0ViewSet = (const void *)SOSViewsGetV0ViewSet();
    uint64_t v13 = sub_10001267C("peer");
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = *(void *)(a1 + 16);
      *(_DWORD *)uint64_t v31 = 138412546;
      *(void *)&void v31[4] = v15;
      __int16 v32 = 2112;
      uint64_t v33 = V0ViewSet;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%@ had no views, inferring: %@", v31, 0x16u);
    }
  }

  __int16 v16 = *(const void **)(a1 + 24);
  if (v16 != V0ViewSet)
  {
    *(void *)(a1 + 24) = V0ViewSet;
  }

  BOOL v17 = CFDictionaryGetValue(theDict, @"keybag");
  if (!v17 || (v18 = v17, CFTypeID v19 = CFGetTypeID(v17), v19 != CFDataGetTypeID())) {
    BOOL v18 = 0LL;
  }
  sub_1001AE3AC(a1, v18);
  BOOL v20 = sub_1000CC780(a2, theDict, @"pending-objects");
  int v21 = *(const void **)(a1 + 56);
  if (v21) {
    CFRelease(v21);
  }
  *(void *)(a1 + 56) = v20;
  uint64_t v22 = sub_1000CC780(a2, theDict, @"unwanted-manifest");
  uint64_t v23 = *(const void **)(a1 + 64);
  if (v23) {
    CFRelease(v23);
  }
  *(void *)(a1 + 64) = v22;
  stat v24 = sub_1000CC780(a2, theDict, @"confirmed-manifest");
  CFTypeRef v25 = *(const void **)(a1 + 72);
  if (v25) {
    CFRelease(v25);
  }
  *(void *)(a1 + 72) = v24;
  CFMutableArrayRef v26 = sub_1000CC808(a2, theDict, @"pending-manifest", a4);
  uint64_t v27 = *(const void **)(a1 + 80);
  if (v27) {
    CFRelease(v27);
  }
  *(void *)(a1 + 80) = v26;
  CFMutableArrayRef v28 = sub_1000CC808(a2, theDict, @"local-manifest", a4);
  char v29 = *(const void **)(a1 + 88);
  if (v29) {
    CFRelease(v29);
  }
  *(void *)(a1 + 8_Block_object_dispose(va, 8) = v28;
  if (v26) {
    BOOL v30 = v28 == 0LL;
  }
  else {
    BOOL v30 = 1;
  }
  return !v30;
}

CFBooleanRef sub_1001AFC54(const __CFDictionary *a1, const void *a2)
{
  uint64_t result = (const __CFBoolean *)CFDictionaryGetValue(a1, a2);
  if (result) {
    return (const __CFBoolean *)(CFBooleanGetValue(result) != 0);
  }
  return result;
}

void *sub_1001AFC78(uint64_t a1, const void *a2, const __CFDictionary *a3, __CFArray *a4)
{
  uint64_t v8 = sub_1001AE23C();
  uint64_t Instance = (void *)_CFRuntimeCreateInstance(kCFAllocatorDefault, v8, 112LL, 0LL);
  if (a2) {
    CFRetain(a2);
  }
  Instance[2] = a2;
  Instance[4] = 0LL;
  CFDictionaryRef v10 = 0LL;
  Instance[13] = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (!a3)
  {
    CFDictionaryRef v10 = CFDictionaryCreate( kCFAllocatorDefault,  0LL,  0LL,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    a3 = v10;
  }

  if (!sub_1001AF984((uint64_t)Instance, a1, a3, a4))
  {
    CFRelease(Instance);
    uint64_t Instance = 0LL;
  }

  if (v10) {
    CFRelease(v10);
  }
  return Instance;
}

void sub_1001AFD74(__CFArray **a1, const void *a2)
{
  id v3 = *a1;
  if (a2)
  {
    if (v3)
    {
      CFArrayRemoveAllValues(v3);
      CFMutableSetRef Mutable = *a1;
    }

    else
    {
      CFMutableSetRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
      *a1 = Mutable;
    }

    CFArrayAppendValue(Mutable, a2);
  }

  else if (v3)
  {
    *a1 = 0LL;
    CFRelease(v3);
  }

const void *sub_1001AFDF0(uint64_t a1)
{
  char v2 = *(const __CFArray **)(a1 + 80);
  if (v2 && CFArrayGetCount(v2)) {
    return CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), 0LL);
  }
  else {
    return 0LL;
  }
}

void sub_1001AFE34(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 72);
  if (v3 != cf)
  {
    if (!cf || (CFRetain(cf), (CFTypeRef v3 = *(CFTypeRef *)(a1 + 72)) != 0LL)) {
      CFRelease(v3);
    }
    *(void *)(a1 + 72) = cf;
  }

void sub_1001AFE7C(CFArrayRef *a1, const void *a2)
{
  CFTypeRef v3 = *a1;
  if (*a1)
  {
    if (a2)
    {
      uint64_t Count = CFArrayGetCount(*a1);
      v7.id location = 0LL;
      v7.CFIndex length = Count;
      FirstIndexOfsigned int Value = CFArrayGetFirstIndexOfValue(v3, v7, a2);
      if (FirstIndexOfValue)
      {
        if (FirstIndexOfValue == -1)
        {
          if (Count >= 4)
          {
            unint64_t v6 = Count + 1;
            do
            {
              CFArrayRemoveValueAtIndex(v3, v6 - 2);
              --v6;
            }

            while (v6 > 4);
          }
        }

        else
        {
          CFArrayRemoveValueAtIndex(v3, FirstIndexOfValue);
        }

        CFArrayInsertValueAtIndex(v3, 0LL, a2);
      }
    }

    else
    {
      CFArrayRemoveAllValues(*a1);
    }
  }

  else
  {
    sub_1001AFD74(a1, a2);
  }

BOOL sub_1001AFF50(void *key, CFDictionaryRef theDict)
{
  signed int Value = CFDictionaryGetValue(theDict, key);
  CFTypeRef v3 = (void *)objc_claimAutoreleasedReturnValue(Value);
  BOOL v4 = v3 != 0LL;

  return v4;
}

__CFData *sub_1001AFF8C(__CFData **a1, const void *a2)
{
  if (!a2) {
    return 0LL;
  }
  BOOL v4 = a1[10];
  if (v4)
  {
    CFIndex Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      CFIndex v7 = 0LL;
      do
      {
        CFTypeRef ValueAtIndex = (__CFData *)CFArrayGetValueAtIndex(a1[10], v7);
        uint64_t v9 = sub_1001AABD0(ValueAtIndex);
        if (CFEqual(a2, v9)) {
          goto LABEL_15;
        }
      }

      while (v6 != ++v7);
    }
  }

  CFDictionaryRef v10 = a1[11];
  if (v10)
  {
    CFIndex v11 = CFArrayGetCount(v10);
    if (v11 >= 1)
    {
      CFIndex v12 = v11;
      CFIndex v13 = 0LL;
      do
      {
        CFTypeRef ValueAtIndex = (__CFData *)CFArrayGetValueAtIndex(a1[11], v13);
        uint64_t v14 = sub_1001AABD0(ValueAtIndex);
        if (CFEqual(a2, v14)) {
          goto LABEL_15;
        }
      }

      while (v12 != ++v13);
    }
  }

  uint64_t v15 = a1[9];
  if (!v15) {
    return 0LL;
  }
  __int16 v16 = sub_1001AABD0(v15);
  if (!CFEqual(a2, v16)) {
    return 0LL;
  }
  CFTypeRef ValueAtIndex = a1[9];
LABEL_15:
  if (ValueAtIndex) {
    CFRetain(ValueAtIndex);
  }
  return ValueAtIndex;
}

void sub_1001B0090(__CFDictionary *a1, __CFData *a2)
{
  BOOL v4 = sub_1001AABD0(a2);
  if (a2 && v4)
  {
    BOOL v5 = (const void *)*((void *)a2 + 3);
    if (v5) {
      CFDictionarySetValue(a1, v4, v5);
    }
  }

void sub_1001B00DC(__CFDictionary *a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFArrayGetTypeID())
    {
      CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
      if (Count >= 1)
      {
        CFIndex v6 = Count;
        for (CFIndex i = 0LL; i != v6; ++i)
        {
          CFTypeRef ValueAtIndex = (__CFData *)CFArrayGetValueAtIndex((CFArrayRef)cf, i);
          sub_1001B0090(a1, ValueAtIndex);
        }
      }
    }
  }

void sub_1001B015C(void *a1, uint64_t a2, uint64_t a3, CFDataRef *a4, CFTypeRef *a5)
{
  if ((a2 | 2) == 3 && a4 && (unint64_t)CFDataGetLength(a4[3]) >= 0x14)
  {
    CFDictionaryRef v10 = (CFDataRef *)sub_1001AB300(a1[9], a4, a5);
    if (!a3) {
      goto LABEL_8;
    }
LABEL_7:
    goto LABEL_8;
  }

  CFDictionaryRef v10 = 0LL;
  if (a3) {
    goto LABEL_7;
  }
LABEL_8:
  if (!v10) {
    return;
  }
LABEL_10:
  uint64_t v11 = sub_1001AB278(a1[7], a3, (uint64_t)v10, a5);
  CFTypeRef v24 = 0LL;
  CFTypeRef cf = 0LL;
  sub_1001AAED8(a1[7], v11, (uint64_t *)&cf, &v24, a5);
  CFIndex v12 = sub_10001267C("peer");
  CFIndex v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG)) {
    goto LABEL_11;
  }
  uint64_t v15 = a1[2];
  __int16 v16 = "sos";
  if (a2 == 3) {
    __int16 v16 = "ckks";
  }
  if (a2 == 1) {
    __int16 v16 = "api";
  }
  uint64_t v23 = v16;
  else {
    BOOL v17 = "";
  }
  BOOL v18 = (CFDataRef *)cf;
  if (!cf
    || (unint64_t Length = CFDataGetLength(*((CFDataRef *)cf + 3)),
        BOOL v18 = (CFDataRef *)cf,
        BOOL v20 = (const __CFString *)cf,
        Length <= 0x13))
  {
    BOOL v20 = &stru_100294B48;
  }

  if (!v24) {
    goto LABEL_34;
  }
  if ((unint64_t)CFDataGetLength(*((CFDataRef *)v24 + 3)) <= 0x13)
  {
    BOOL v18 = (CFDataRef *)cf;
LABEL_34:
    int v21 = "=";
    goto LABEL_39;
  }

  int v21 = "+";
LABEL_39:
  else {
    uint64_t v22 = &stru_100294B48;
  }
  *(_DWORD *)__int128 buf = 138414338;
  uint64_t v27 = v15;
  __int16 v28 = 2112;
  uint64_t v29 = a3;
  __int16 v30 = 2112;
  uint64_t v31 = a4;
  __int16 v32 = 2112;
  uint64_t v33 = v10;
  __int16 v34 = 2080;
  uint64_t v35 = v23;
  __int16 v36 = 2080;
  char v37 = v17;
  __int16 v38 = 2112;
  CFStringRef v39 = v20;
  __int16 v40 = 2080;
  id v41 = v21;
  __int16 v42 = 2112;
  CFMutableArrayRef v43 = v22;
  _os_log_debug_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEBUG,  "%@: willCommit R:%@ A:%@ UA:%@ %s O%s%@%s%@",  buf,  0x5Cu);
LABEL_11:

  if (cf) {
    CFRelease(cf);
  }
  if (v24) {
    CFRelease(v24);
  }
  uint64_t v14 = (const void *)a1[7];
  if (v14) {
    CFRelease(v14);
  }
  a1[7] = v11;
  if (v10) {
LABEL_18:
  }
    CFRelease(v10);
}

void sub_1001B044C(uint64_t a1, FILE *a2, int a3)
{
  *(_OWORD *)uint64_t v33 = 0u;
  __int128 v34 = 0u;
  *(_OWORD *)uint64_t v31 = 0u;
  __int128 v32 = 0u;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
  if (Count >= 1)
  {
    CFIndex v7 = Count;
    CFIndex v8 = 0LL;
    uint64_t v29 = a3;
    do
    {
      CFTypeRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 40), v8);
      CFDictionaryRef v10 = ValueAtIndex;
      CFTypeRef cf = 0LL;
      uint64_t v11 = *(void *)(a1 + 48);
      if (ValueAtIndex)
      {
        CFTypeID v12 = CFGetTypeID(ValueAtIndex);
        if (v12 == CFArrayGetTypeID())
        {
          if (CFArrayGetCount(v10) != 1)
          {
            CFIndex v20 = CFArrayGetCount(v10);
            sub_1000194E0(-26275, (__CFString **)&cf, @"change array count: %ld", v20);
            BOOL v17 = 0;
            __int16 v16 = 0LL;
            CFIndex v13 = 0LL;
            goto LABEL_16;
          }

          CFIndex v13 = CFArrayGetValueAtIndex(v10, 0LL);
          int v14 = 1;
          if (!v13) {
            goto LABEL_12;
          }
        }

        else
        {
          int v14 = 0;
          CFIndex v13 = v10;
        }

        CFTypeID v15 = CFGetTypeID(v13);
        if (v15 == CFDataGetTypeID())
        {
          __int16 v16 = (const __CFData *)CFRetain(v13);
          CFIndex v13 = 0LL;
          goto LABEL_13;
        }
      }

      else
      {
        int v14 = 0;
        CFIndex v13 = 0LL;
      }

uint64_t sub_1001B07C0( void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, CFDataRef *a6, void *a7, const void *a8, SOSEnginePeerMessageCallBackInfo **a9, CFTypeRef *a10)
{
  id v15 = a1;
  if (a5)
  {
    uint64_t v263 = a2;
    unint64_t v265 = v15;
    __int16 v16 = sub_10001267C("transport");
    BOOL v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = a5;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "coder state: %@", buf, 0xCu);
    }

    uint64_t v18 = *(void *)(a5 + 24);
    if (!v18 || !SecOTRSGetIsReadyForMessages(v18) || *(_BYTE *)(a5 + 32))
    {
      CFTypeID v19 = *(const __CFData **)(a5 + 40);
      if (v19) {
        CFDataRef Copy = CFDataCreateCopy(kCFAllocatorDefault, v19);
      }
      else {
        CFDataRef Copy = 0LL;
      }
      *a6 = Copy;
      CFTypeRef v25 = sub_10001267C("transport");
      CFMutableArrayRef v26 = (os_log_s *)objc_claimAutoreleasedReturnValue(v25);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
      {
        id v69 = @"sending negotiation message.";
        if (!*a6) {
          id v69 = @"waiting for negotiation message.";
        }
        *(_DWORD *)__int128 buf = 138412546;
        *(void *)&uint8_t buf[4] = a7;
        *(_WORD *)&_BYTE buf[12] = 2112;
        *(void *)&buf[14] = v69;
        _os_log_debug_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEBUG, "%@ negotiating, %@", buf, 0x16u);
      }

      uint64_t v27 = objc_opt_new(&OBJC_CLASS___SOSEnginePeerMessageCallBackInfo);
      -[SOSEnginePeerMessageCallBackInfo setCallbackBlock:](v27, "setCallbackBlock:", 0LL);
      -[SOSEnginePeerMessageCallBackInfo setCoder:](v27, "setCoder:", a5);
      *(void *)__int128 buf = 0xAAAAAAAAAAAAAAAALL;
      objc_initWeak((id *)buf, v27);
      v266[0] = _NSConcreteStackBlock;
      v266[1] = 3221225472LL;
      v266[2] = sub_1001B2CA8;
      v266[3] = &unk_100292B28;
      objc_copyWeak(&v267, (id *)buf);
      __int16 v28 = v27;
      uint64_t v29 = v266;
      BOOL v31 = !-[OTSOSActualAdapter sosEnabled]_0((uint64_t)v29, v30);
      if (!v28) {
        LOBYTE(v31) = 1;
      }
      if (!v31) {
        -[SOSEnginePeerMessageCallBackInfo setCallbackBlock:](v28, "setCallbackBlock:", v29);
      }

      __int128 v32 = v28;
      *a9 = v32;
      objc_destroyWeak(&v267);
      objc_destroyWeak((id *)buf);

      uint64_t v33 = 1LL;
      goto LABEL_21;
    }

    __int128 v48 = sub_10001267C("transport");
    __int128 v49 = (os_log_s *)objc_claimAutoreleasedReturnValue(v48);
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = a7;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEBUG,  "%@ Coder can wrap, getting message from engine",  buf,  0xCu);
    }

    if (!-[OTSOSActualAdapter sosEnabled]_0(v50, v51))
    {
      SOSCCSetSOSDisabledError(a10);
      goto LABEL_341;
    }

    uint64_t v52 = (CFDataRef *)sub_1000D08EC(a2, a4, (uint64_t)a10);
    uint64_t v282 = 0LL;
    v283 = &v282;
    uint64_t v284 = 0x2020000000LL;
    unint64_t v285 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v53 = *(void *)(a4 + 32);
    uint64_t v54 = sub_1001ACCB8();
    uint64_t Instance = _CFRuntimeCreateInstance(kCFAllocatorDefault, v54, 112LL, 0LL);
    *(void *)(Instance + 112) = v53;
    unint64_t v285 = Instance;
    uint64_t v57 = *(void **)(a4 + 64);
    uint64_t v56 = *(void *)(a4 + 72);
    CFTypeRef cf = 0LL;
    CFTypeRef v281 = 0LL;
    CFTypeRef v278 = 0LL;
    CFTypeRef v279 = 0LL;
    CFTypeRef v276 = 0LL;
    CFTypeRef v277 = 0LL;
    __int16 v58 = *(CFDataRef **)(a4 + 56);
    BOOL v259 = v52;
    cf1 = (CFDataRef *)v56;
    sub_1001AAED8(v56, (uint64_t)v52, (uint64_t *)&v281, &cf, a10);
    sub_1001AAED8((uint64_t)cf, (uint64_t)v58, (uint64_t *)&v279, &v278, a10);
    if (v278 && (unint64_t)CFDataGetLength(*((CFDataRef *)v278 + 3)) >= 0x14)
    {
      uint64_t v59 = sub_10001267C("SecError");
      char v60 = (os_log_s *)objc_claimAutoreleasedReturnValue(v59);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412546;
        *(void *)&uint8_t buf[4] = a4;
        *(_WORD *)&_BYTE buf[12] = 2112;
        *(void *)&buf[14] = v278;
        _os_log_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_DEFAULT,  "%@ ASSERTION FAILURE purging excess pendingObjects: %@",  buf,  0x16u);
      }

      CFTypeRef v61 = sub_1001AB300((uint64_t)v278, v58, a10);
      CFTypeRef v62 = *(CFTypeRef *)(a4 + 56);
      if (v62 != v61)
      {
        if (!v61 || (CFRetain(v61), (CFTypeRef v62 = *(CFTypeRef *)(a4 + 56)) != 0LL)) {
          CFRelease(v62);
        }
        *(void *)(a4 + 56) = v61;
      }

      if (v61)
      {
        CFRelease(v61);
        __int16 v58 = *(CFDataRef **)(a4 + 56);
      }

      else
      {
        __int16 v58 = 0LL;
      }
    }

    int64_t v256 = v58;
    sub_1001AAED8((uint64_t)v281, (uint64_t)v57, (uint64_t *)&v277, &v276, a10);
    if (v276 && (unint64_t)CFDataGetLength(*((CFDataRef *)v276 + 3)) >= 0x14)
    {
      uint64_t v70 = sub_10001267C("SecError");
      CFDictionaryRef v71 = (os_log_s *)objc_claimAutoreleasedReturnValue(v70);
      if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412546;
        *(void *)&uint8_t buf[4] = a4;
        *(_WORD *)&_BYTE buf[12] = 2112;
        *(void *)&buf[14] = v276;
        _os_log_impl( (void *)&_mh_execute_header,  v71,  OS_LOG_TYPE_DEFAULT,  "%@ ASSERTION FAILURE purging excess unwanted: %@",  buf,  0x16u);
      }

      CFTypeRef v72 = sub_1001AB300((uint64_t)v276, v57, a10);
      CFTypeRef v73 = *(CFTypeRef *)(a4 + 64);
      if (v73 != v72)
      {
        if (!v72 || (CFRetain(v72), (CFTypeRef v73 = *(CFTypeRef *)(a4 + 64)) != 0LL)) {
          CFRelease(v73);
        }
        *(void *)(a4 + 64) = v72;
      }

      if (v72)
      {
        CFRelease(v72);
        uint64_t v57 = *(void **)(a4 + 64);
      }

      else
      {
        uint64_t v57 = 0LL;
      }
    }

    CFTypeRef v74 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v74);
    }

    CFTypeRef v75 = v278;
    if (v278)
    {
      CFTypeRef v278 = 0LL;
      CFRelease(v75);
    }

    CFTypeRef v76 = v281;
    if (v281)
    {
      CFTypeRef v281 = 0LL;
      CFRelease(v76);
    }

    CFTypeRef v77 = v276;
    if (v276)
    {
      CFTypeRef v276 = 0LL;
      CFRelease(v77);
    }

    char v78 = sub_10001267C("engine");
    char v79 = (os_log_s *)objc_claimAutoreleasedReturnValue(v78);
    if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
    {
      dispatch_queue_t queue = *(dispatch_queue_t *)(a4 + 16);
      id v80 = "L";
      if (!v52) {
        id v80 = "l";
      }
      CFDataRef theData = *(CFDataRef *)(v263 + 24);
      id v250 = v80;
      if (cf1) {
        unint64_t v81 = "C";
      }
      else {
        unint64_t v81 = "0";
      }
      id v82 = "P";
      if (!v58) {
        id v82 = "0";
      }
      CFDataRef v244 = (CFDataRef)v82;
      id v246 = v81;
      if (*(_BYTE *)(a4 + 49)) {
        id v83 = "O";
      }
      else {
        id v83 = "o";
      }
      if (*(_BYTE *)(a4 + 48)) {
        uint64_t v84 = "S";
      }
      else {
        uint64_t v84 = "s";
      }
      v242 = v84;
      v243 = v83;
      if (v52) {
        unint64_t v241 = CFDataGetLength(v52[3]) / 0x14uLL;
      }
      else {
        unint64_t v241 = 0LL;
      }
      if (cf1) {
        unint64_t v240 = CFDataGetLength(cf1[3]) / 0x14uLL;
      }
      else {
        unint64_t v240 = 0LL;
      }
      if (v58) {
        unint64_t v239 = CFDataGetLength(v58[3]) / 0x14uLL;
      }
      else {
        unint64_t v239 = 0LL;
      }
      uint64_t v85 = (CFDataRef *)v57;
      if (v279) {
        unint64_t v86 = CFDataGetLength(*((CFDataRef *)v279 + 3)) / 0x14uLL;
      }
      else {
        unint64_t v86 = 0LL;
      }
      if (v277) {
        unint64_t v87 = CFDataGetLength(*((CFDataRef *)v277 + 3)) / 0x14uLL;
      }
      else {
        unint64_t v87 = 0LL;
      }
      if (v85) {
        unint64_t v88 = CFDataGetLength(v85[3]) / 0x14uLL;
      }
      else {
        unint64_t v88 = 0LL;
      }
      *(_DWORD *)__int128 buf = 138415362;
      *(void *)&uint8_t buf[4] = theData;
      *(_WORD *)&_BYTE buf[12] = 2112;
      *(void *)&buf[14] = queue;
      *(_WORD *)&buf[22] = 2080;
      v291 = v250;
      LOWORD(v292[0]) = 2080;
      *(void *)((char *)v292 + 2) = v246;
      WORD5(v292[0]) = 2080;
      *(void *)((char *)v292 + 12) = v244;
      WORD2(v292[1]) = 2080;
      *(void *)((char *)&v292[1] + 6) = v243;
      HIWORD(v292[1]) = 2080;
      uint64_t v293 = v242;
      __int16 v294 = 2048;
      unint64_t v295 = v241;
      __int16 v296 = 2048;
      unint64_t v297 = v240;
      __int16 v298 = 2048;
      unint64_t v299 = v239;
      __int16 v300 = 2048;
      unint64_t v301 = v86;
      __int16 v302 = 2048;
      unint64_t v303 = v87;
      __int16 v304 = 2048;
      unint64_t v305 = v88;
      _os_log_impl( (void *)&_mh_execute_header,  v79,  OS_LOG_TYPE_DEFAULT,  "%@:%@: send state for peer [%s%s%s][%s%s] local:%zu confirmed:%zu pending:%zu, extra:%zu, missing:%zu unwanted:%zu",  buf,  0x84u);
      uint64_t v52 = v259;
    }

    if (!cf1)
    {
      if (v256) {
        CFRetain(v256);
      }
      if (v277 && (unint64_t)CFDataGetLength(*((CFDataRef *)v277 + 3)) > 0x13)
      {
        dispatch_queue_t queuea = 0LL;
      }

      else
      {
        unint64_t v95 = (unint64_t)v279;
        if (v279) {
          unint64_t v95 = CFDataGetLength(*((CFDataRef *)v279 + 3)) / 0x14uLL;
        }
        dispatch_queue_t queuea = 0LL;
        if (!v95)
        {
          uint64_t v96 = 0LL;
          id v97 = 0LL;
          char v98 = v256;
          if (!v256)
          {
LABEL_206:
            uint64_t v257 = (CFDataRef *)v96;
            uint64_t v116 = *(void *)(a4 + 56);
            if (!v116 || (id v117 = v52, (unint64_t)CFDataGetLength(*(CFDataRef *)(v116 + 24)) <= 0x13))
            {
              if (!v279 || (id v117 = v52, (unint64_t)CFDataGetLength(*((CFDataRef *)v279 + 3)) <= 0x13))
              {
                if (!v277 || (id v117 = v52, (unint64_t)CFDataGetLength(*((CFDataRef *)v277 + 3)) <= 0x13))
                {
                  uint64_t v118 = *(void *)(a4 + 64);
                  id v117 = v52;
                  if (v118)
                  {
                    id v117 = v52;
                    if ((unint64_t)CFDataGetLength(*(CFDataRef *)(v118 + 24)) >= 0x14)
                    {
                      __int128 v119 = sub_10001267C("engine");
                      __int128 v120 = (os_log_s *)objc_claimAutoreleasedReturnValue(v119);
                      if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v121 = *(void *)(a4 + 16);
                        uint64_t v122 = *(void *)(v263 + 24);
                        *(_DWORD *)__int128 buf = 138412546;
                        *(void *)&uint8_t buf[4] = v122;
                        *(_WORD *)&_BYTE buf[12] = 2112;
                        *(void *)&buf[14] = v121;
                        _os_log_impl( (void *)&_mh_execute_header,  v120,  OS_LOG_TYPE_DEFAULT,  "%@:%@: only have differences in unwanted set; lying to peer to stop sync",
                          buf,
                          0x16u);
                      }

                      id v117 = cf1;
                    }
                  }
                }
              }
            }

            __int128 v123 = (void *)v283[3];
            if (v123)
            {
              __int128 v124 = sub_1001AABD0((__CFData *)cf1);
              id v125 = v124;
              if (v124) {
                CFRetain(v124);
              }
              v123[6] = v125;
              unint64_t v126 = (os_log_s *)sub_10001267C("engine");
              if (os_log_type_enabled(v126, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v177 = v123[6];
                unint64_t v178 = (unint64_t)cf1;
                if (cf1) {
                  unint64_t v178 = CFDataGetLength(cf1[3]) / 0x14uLL;
                }
                *(_DWORD *)__int128 buf = 138412546;
                *(void *)&uint8_t buf[4] = v177;
                *(_WORD *)&_BYTE buf[12] = 2048;
                *(void *)&buf[14] = v178;
                _os_log_debug_impl( (void *)&_mh_execute_header,  v126,  OS_LOG_TYPE_DEBUG,  "SOSMessageSetManifests: setting base digest to %@ %zu",  buf,  0x16u);
              }

              char v127 = sub_1001AABD0((__CFData *)v257);
              char v128 = v127;
              if (v127) {
                CFRetain(v127);
              }
              v123[7] = v128;
              id v129 = (os_log_s *)sub_10001267C("engine");
              if (os_log_type_enabled(v129, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v179 = v123[7];
                unint64_t v180 = (unint64_t)v257;
                if (v257) {
                  unint64_t v180 = CFDataGetLength(v257[3]) / 0x14uLL;
                }
                *(_DWORD *)__int128 buf = 138412546;
                *(void *)&uint8_t buf[4] = v179;
                *(_WORD *)&_BYTE buf[12] = 2048;
                *(void *)&buf[14] = v180;
                _os_log_debug_impl( (void *)&_mh_execute_header,  v129,  OS_LOG_TYPE_DEBUG,  "SOSMessageSetManifests: setting proposed digest to %@ %zu",  buf,  0x16u);
              }

              uint64_t v130 = sub_1001AABD0((__CFData *)v117);
              unint64_t v131 = v130;
              if (v130) {
                CFRetain(v130);
              }
              v123[5] = v131;
              char v132 = (os_log_s *)sub_10001267C("engine");
              if (os_log_type_enabled(v132, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v181 = v123[5];
                if (v117) {
                  unint64_t v182 = CFDataGetLength(v117[3]) / 0x14uLL;
                }
                else {
                  unint64_t v182 = 0LL;
                }
                *(_DWORD *)__int128 buf = 138412546;
                *(void *)&uint8_t buf[4] = v181;
                *(_WORD *)&_BYTE buf[12] = 2048;
                *(void *)&buf[14] = v182;
                _os_log_debug_impl( (void *)&_mh_execute_header,  v132,  OS_LOG_TYPE_DEBUG,  "SOSMessageSetManifests: setting sender digest to %@ %zu",  buf,  0x16u);
              }

              if (v257)
              {
                *(void *)__int128 buf = 0LL;
                char v133 = sub_1001AAED8((uint64_t)cf1, (uint64_t)v257, v123 + 8, (const void **)buf, a10);
                if (v123[14])
                {
                  v123[9] = sub_1001AB300((uint64_t)queuea, *(CFTypeRef *)buf, a10);
                  if (*(void *)buf) {
                    CFRelease(*(CFTypeRef *)buf);
                  }
                }

                else
                {
                  v123[9] = *(void *)buf;
                }

                if ((v133 & 1) == 0)
                {
                  unsigned int v134 = sub_10001267C("engine");
                  id v135 = (os_log_s *)objc_claimAutoreleasedReturnValue(v134);
                  if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v136 = *(void *)(a4 + 16);
                    uint64_t v137 = *(void *)(v263 + 24);
                    *(_DWORD *)__int128 buf = 138412546;
                    *(void *)&uint8_t buf[4] = v137;
                    *(_WORD *)&_BYTE buf[12] = 2112;
                    *(void *)&buf[14] = v136;
                    _os_log_impl( (void *)&_mh_execute_header,  v135,  OS_LOG_TYPE_DEFAULT,  "%@:%@: failed to set message manifests",  buf,  0x16u);
                  }

                  char v138 = (const void *)v283[3];
                  if (v138)
                  {
                    v283[3] = 0LL;
                    CFRelease(v138);
                  }
                }
              }
            }

            if (v97) {
              CFRelease(v97);
            }
            uint64_t v139 = v283[3];
            if (!v139) {
              goto LABEL_270;
            }
            uint64_t v140 = *(void *)(a4 + 40) + 1LL;
            *(void *)(a4 + 40) = v140;
            *(void *)(v139 + 96) = v140;
            if (!*(void *)(v139 + 112))
            {
              *(_BYTE *)(v139 + 120) = 0;
              __int128 v155 = (char *)&loc_1001B1C68 + 4 * word_100205452[sub_1001AD620((void *)v139)];
              __asm { BR              X9 }
            }

            *(double *)(v139 + 104) = floor(CFAbsoluteTimeGetCurrent());
            if (*(void *)(v139 + 40))
            {
              *(void *)__int128 buf = *(void *)(v139 + 88);
              uint64_t v141 = sub_100014258();
              uint64_t v142 = ccder_sizeof(24LL, v141);
              uint64_t v143 = ccder_sizeof_uint64(*(void *)(v139 + 96));
              uint64_t v144 = ccn_bitlen(1LL, buf);
              uint64_t v145 = v143 + v142 + ccder_sizeof(3LL, ((unint64_t)(v144 + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL | 1);
              id v146 = *(const __CFData **)(v139 + 40);
              if (v146)
              {
                CFIndex Length = CFDataGetLength(v146);
                id v146 = (const __CFData *)ccder_sizeof_implicit_raw_octet_string(4LL, Length);
              }

              id v148 = (char *)v146 + v145;
              id v149 = *(const __CFData **)(v139 + 48);
              if (v149)
              {
                CFIndex v150 = CFDataGetLength(v149);
                id v149 = (const __CFData *)ccder_sizeof_implicit_raw_octet_string(0x8000000000000000LL, v150);
              }

              __int128 v151 = (char *)v149 + (void)v148;
              __int128 v152 = *(const __CFData **)(v139 + 56);
              if (v152)
              {
                CFIndex v153 = CFDataGetLength(v152);
                __int128 v152 = (const __CFData *)ccder_sizeof_implicit_raw_octet_string(0x8000000000000001LL, v153);
              }

              uint64_t v154 = ccder_sizeof(0x2000000000000010LL, (char *)v152 + (void)v151);
            }

            else
            {
              uint64_t v154 = 0LL;
            }

            uint64_t v156 = *(void *)(v139 + 64);
            uint64_t v157 = *(void *)(v139 + 72);
            if (*(_OWORD *)(v139 + 64) == 0LL)
            {
              uint64_t v158 = 0LL;
            }

            else
            {
              uint64_t v159 = *(void *)(v139 + 112);
              if (v156)
              {
                CFIndex v160 = CFDataGetLength(*(CFDataRef *)(v156 + 24));
                uint64_t v157 = *(void *)(v139 + 72);
              }

              else
              {
                CFIndex v160 = 0LL;
              }

              uint64_t v161 = ccder_sizeof(4LL, v160);
              if (v157) {
                CFIndex v162 = CFDataGetLength(*(CFDataRef *)(v157 + 24));
              }
              else {
                CFIndex v162 = 0LL;
              }
              uint64_t v158 = ccder_sizeof(4LL, v162) + v161;
              if (v159) {
                uint64_t v158 = ccder_sizeof(0xA000000000000000LL, v158);
              }
            }

            id v163 = (char *)sub_1001AD8F0(v139) + v158 + v154;
            CFIndex v164 = *(_BYTE *)(v139 + 120) ? (CFIndex)(v163 + 4) : ccder_sizeof(0x2000000000000010LL, v163);
            CFMutableSetRef Mutable = CFDataCreateMutable(0LL, v164);
            if (Mutable)
            {
              __int128 v166 = Mutable;
              CFDataSetLength(Mutable, v164);
              dispatch_queue_t queueb = (dispatch_queue_t)v166;
              MutableBytePtr = CFDataGetMutableBytePtr(v166);
              __int128 v168 = &MutableBytePtr[v164];
              uint64_t v169 = (uint64_t)MutableBytePtr;
              uint64_t v170 = (uint64_t)v168;
              if (*(_BYTE *)(v139 + 120)) {
                uint64_t v170 = ccder_encode_tl(0LL, 0LL, MutableBytePtr, v168);
              }
              uint64_t v171 = sub_1001AD994(v139, v169, v170);
              uint64_t v173 = *(void *)(v139 + 64);
              uint64_t v172 = *(void *)(v139 + 72);
              uint64_t v251 = v168;
              if (*(_OWORD *)(v139 + 64) != 0LL)
              {
                if (v173) {
                  __int16 v174 = *(const __CFData **)(v173 + 24);
                }
                else {
                  __int16 v174 = 0LL;
                }
                uint64_t v183 = *(void *)(v139 + 112);
                if (v172) {
                  id v184 = *(const __CFData **)(v172 + 24);
                }
                else {
                  id v184 = 0LL;
                }
                uint64_t v185 = sub_1001ADAE8(4LL, v184, v169, v171);
                uint64_t v186 = sub_1001ADAE8(4LL, v174, v169, v185);
                if (v183) {
                  uint64_t v171 = ccder_encode_constructed_tl(0xA000000000000000LL, v171, v169, v186);
                }
                else {
                  uint64_t v171 = v186;
                }
              }

              id v187 = *(const __CFData **)(v139 + 40);
              if (v187)
              {
                uint64_t v247 = v171;
                CFDataRef theDataa = *(CFDataRef *)(v139 + 96);
                *(void *)__int128 buf = *(void *)(v139 + 88);
                double v188 = *(double *)(v139 + 104);
                v245 = *(const __CFData **)(v139 + 48);
                uint64_t v189 = sub_1001ADAE8(0x8000000000000001LL, *(CFDataRef *)(v139 + 56), v169, v171);
                uint64_t v190 = sub_1001ADAE8(0x8000000000000000LL, v245, v169, v189);
                uint64_t v191 = sub_1001ADAE8(4LL, v187, v169, v190);
                unint64_t v192 = ((unint64_t)(ccn_bitlen(1LL, buf) + 63) >> 3) & 0x1FFFFFFFFFFFFFF8LL | 1;
                uint64_t v193 = ccder_encode_body_nocopy(v192, v169, v191);
                if (v193) {
                  ccn_write_uint_padded(1LL, buf, v192, v193);
                }
                ccder_encode_tl(3LL, v192, v169, v193);
                unint64_t v194 = ccder_encode_uint64(theDataa);
                unint64_t v195 = sub_1000142C8(a10, 0, v169, v194, v188);
                uint64_t v197 = ccder_encode_constructed_tl(24LL, v194, v169, v195);
                if (!v197) {
                  sub_1000194B4( -7LL,  @"com.apple.security.cfder.error",  0LL,  a10,  v196,  @"ccder failed to encode");
                }
                uint64_t v198 = ccder_encode_constructed_tl(0x2000000000000010LL, v247, v169, v197);
              }

              else
              {
                uint64_t v198 = 0LL;
              }

              if (*(_BYTE *)(v139 + 120))
              {
                uint64_t v199 = ccder_encode_len(0LL, v169, v198);
                uint64_t v200 = ccder_encode_tag(0x2000000000000010LL, v169, v199);
              }

              else
              {
                uint64_t v200 = ccder_encode_constructed_tl(0x2000000000000010LL, v251, v169, v198);
              }

              uint64_t v201 = v200;
              if (v169 != v200)
              {
                v202 = (os_log_s *)sub_10001267C("SecWarning");
                if (os_log_type_enabled(v202, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)__int128 buf = 134217984;
                  *(void *)&uint8_t buf[4] = v201 - v169;
                  _os_log_impl( (void *)&_mh_execute_header,  v202,  OS_LOG_TYPE_DEFAULT,  "internal error %td bytes unused in der buffer",  buf,  0xCu);
                }
              }

              id v203 = objc_alloc(&OBJC_CLASS___SOSEnginePeerMessageCallBackInfo);
              id v204 = -[SOSEnginePeerMessageCallBackInfo initWithEngine:peer:localManifest:proposedManifest:confirmedManifest:andMessage:]( v203,  "initWithEngine:peer:localManifest:proposedManifest:confirmedManifest:andMessage:",  v263,  a4,  v52,  v257,  cf1,  v283[3]);
              CFDataRef v110 = (CFDataRef)queueb;
              v268[0] = _NSConcreteStackBlock;
              v268[1] = 3221225472LL;
              v268[2] = sub_1000D3348;
              v268[3] = &unk_1002857E0;
              id v205 = -[SOSEnginePeerMessageCallBackInfo copy](v204, "copy");
              id v269 = v205;
              -[SOSEnginePeerMessageCallBackInfo setCallbackBlock:](v204, "setCallbackBlock:", v268);
              unsigned int v206 = v204;
              *a9 = v206;
            }

            else
            {
LABEL_270:
              CFDataRef v110 = 0LL;
            }

            if (v52) {
              CFRelease(v52);
            }
            CFTypeRef v207 = v279;
            if (v279)
            {
              CFTypeRef v279 = 0LL;
              CFRelease(v207);
            }

            CFTypeRef v208 = v277;
            if (v277)
            {
              CFTypeRef v277 = 0LL;
              CFRelease(v208);
            }

            id v209 = (const void *)v283[3];
            if (v209)
            {
              v283[3] = 0LL;
              CFRelease(v209);
            }

            if (v257) {
              CFRelease(v257);
            }
            if (a10 && *a10)
            {
              id v210 = sub_10001267C("SecError");
              id v211 = (os_log_s *)objc_claimAutoreleasedReturnValue(v210);
              if (os_log_type_enabled(v211, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v212 = *(void *)(a4 + 16);
                uint64_t v213 = *(void *)(v263 + 24);
                __int16 v214 = (const char *)*a10;
                *(_DWORD *)__int128 buf = 138412802;
                *(void *)&uint8_t buf[4] = v213;
                *(_WORD *)&_BYTE buf[12] = 2112;
                *(void *)&buf[14] = v212;
                *(_WORD *)&buf[22] = 2112;
                v291 = v214;
                _os_log_impl( (void *)&_mh_execute_header,  v211,  OS_LOG_TYPE_DEFAULT,  "%@:%@ error in send: %@",  buf,  0x20u);
              }
            }

            goto LABEL_323;
          }

LABEL_202:
          __int128 v115 = sub_1001AB56C((uint64_t)v279, v98, a10);
          uint64_t v96 = sub_1001AB278((uint64_t)cf1, (uint64_t)v277, (uint64_t)v115, a10);
          if (v115) {
            CFRelease(v115);
          }
          id v97 = v98;
          goto LABEL_206;
        }
      }

      char v98 = v256;
      goto LABEL_202;
    }

    if ((!v256 || (unint64_t)CFDataGetLength(v256[3]) <= 0x13)
      && (!v279 || (unint64_t)CFDataGetLength(*((CFDataRef *)v279 + 3)) <= 0x13))
    {
      *(_BYTE *)(a4 + 49) = 0;
    }

    if (v277 && (unint64_t)CFDataGetLength(*((CFDataRef *)v277 + 3)) <= 0x13)
    {
      id v89 = objc_retainBlock(*(id *)(v263 + 136));
      if (v89 && *(void *)(v263 + 128))
      {
        uint64_t v90 = *(void *)(a4 + 16);
        if (v90) {
          CFRetain(*(CFTypeRef *)(a4 + 16));
        }
        uint64_t v91 = *(void *)(a4 + 24);
        if (v91) {
          CFRetain(*(CFTypeRef *)(a4 + 24));
        }
        id v92 = [v89 copy];
        queuec = *(dispatch_queue_s **)(v263 + 128);
        *(void *)__int128 buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 3221225472LL;
        *(void *)&uint8_t buf[16] = sub_1000D29E0;
        v291 = (const char *)&unk_100285B10;
        *(void *)&v292[0] = v92;
        *((void *)&v292[0] + 1) = v90;
        *(void *)&v292[1] = v91;
        id v93 = v92;
        dispatch_async(queuec, buf);
      }

      *(_BYTE *)(a4 + 50) = 1;
    }

    id v94 = (CFDataRef *)sub_1001AFDF0(a4);
    if (v52 && v94)
    {
      if (!CFEqual(v52, v94)) {
        goto LABEL_162;
      }
    }

    else if (v52 != v94)
    {
      goto LABEL_162;
    }

    if (*(_BYTE *)(a4 + 48)) {
      goto LABEL_162;
    }
    if (CFEqual(cf1, v52))
    {
      id v104 = sub_10001267C("engine");
      id v105 = (os_log_s *)objc_claimAutoreleasedReturnValue(v104);
      if (os_log_type_enabled(v105, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v106 = *(void *)(v263 + 24);
        *(_DWORD *)__int128 buf = 138412546;
        *(void *)&uint8_t buf[4] = v106;
        *(_WORD *)&_BYTE buf[12] = 2112;
        *(void *)&buf[14] = a4;
        _os_log_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_DEFAULT, "synced <No MSG> %@:%@", buf, 0x16u);
      }

      uint64_t v52 = v259;
    }

    else
    {
      char v98 = v256;
      uint64_t v52 = v259;
      if (v277 && (unint64_t)CFDataGetLength(*((CFDataRef *)v277 + 3)) > 0x13)
      {
LABEL_162:
        char v98 = v256;
        if (!v256)
        {
LABEL_165:
          dispatch_queue_t queuea = 0LL;
          goto LABEL_202;
        }

LABEL_163:
        if ((unint64_t)CFDataGetLength(v98[3]) >= 0x14)
        {
          v275[0] = 0LL;
          v275[1] = v275;
          v275[2] = 0x2020000000LL;
          v275[3] = 0LL;
          *(void *)__int128 buf = 0LL;
          *(void *)&uint8_t buf[8] = buf;
          *(void *)&uint8_t buf[16] = 0x4010000000LL;
          v291 = "";
          memset(v292, 0, sizeof(v292));
          CFMutableArrayRef v99 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
          uint64_t v271 = 0LL;
          id v272 = &v271;
          uint64_t v273 = 0x2020000000LL;
          uint64_t v274 = 0LL;
          uint64_t v100 = v263;
          uint64_t v101 = *(void *)(v263 + 16);
          v270[1] = _NSConcreteStackBlock;
          v270[2] = (CFTypeRef)3221225472LL;
          v270[3] = sub_1000D2A2C;
          v270[4] = &unk_1002857B8;
          v270[9] = (CFTypeRef)v263;
          v270[10] = (CFTypeRef)a4;
          v270[11] = v99;
          v270[12] = a10;
          v270[5] = &v271;
          v270[6] = &v282;
          v270[13] = a8;
          v270[7] = buf;
          v270[8] = v275;
          if (((*(uint64_t (**)(void))(v101 + 32))() & 1) == 0)
          {
            char v102 = (const void *)v283[3];
            if (v102)
            {
              v283[3] = 0LL;
              CFRelease(v102);
            }
          }

          if (*(void *)(*(void *)&buf[8] + 40LL)) {
            uint64_t v103 = sub_1001AB230(*(void *)&buf[8] + 32LL, a10);
          }
          else {
            uint64_t v103 = 0LL;
          }
          if (CFArrayGetCount(v99))
          {
            v270[0] = 0LL;
            if ((sub_1000D0BC4(v263, 0LL, 2LL, 0LL, v99, v270) & 1) == 0)
            {
              id v111 = sub_10001267C("SecError");
              id v112 = (os_log_s *)objc_claimAutoreleasedReturnValue(v111);
              if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v286 = 138412546;
                CFMutableArrayRef v287 = v99;
                __int16 v288 = 2112;
                CFTypeRef v289 = v270[0];
                _os_log_impl( (void *)&_mh_execute_header,  v112,  OS_LOG_TYPE_DEFAULT,  "SOSEngineUpdateChanges_locked: %@ failed: %@",  v286,  0x16u);
              }

              uint64_t v100 = v263;
            }

            if (v270[0]) {
              CFRelease(v270[0]);
            }
            uint64_t v52 = (CFDataRef *)sub_1000D08EC(v100, a4, (uint64_t)a10);
            if (v259) {
              CFRelease(v259);
            }
          }

          else
          {
            uint64_t v52 = v259;
          }

          char v98 = (CFDataRef *)v103;
          if (v99) {
            CFRelease(v99);
          }
          uint64_t v113 = *(void *)&buf[8];
          free(*(void **)(*(void *)&buf[8] + 32LL));
          *(void *)(v113 + 32) = 0LL;
          *(void *)(v113 + 40) = 0LL;
          *(_BYTE *)(v113 + 56) = 0;
          *(void *)(v113 + 4_Block_object_dispose(va, 8) = 0LL;
          __int128 v114 = (const void *)v272[3];
          if (v114)
          {
            v272[3] = 0LL;
            CFRelease(v114);
          }

          _Block_object_dispose(&v271, 8);
          _Block_object_dispose(buf, 8);
          _Block_object_dispose(v275, 8);
          dispatch_queue_t queuea = (dispatch_queue_t)v98;
          goto LABEL_202;
        }

        char v98 = 0LL;
        goto LABEL_165;
      }

      id v175 = sub_10001267C("engine");
      id v105 = (os_log_s *)objc_claimAutoreleasedReturnValue(v175);
      if (os_log_type_enabled(v105, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v176 = *(void *)(v263 + 24);
        *(_DWORD *)__int128 buf = 138412802;
        *(void *)&uint8_t buf[4] = v176;
        *(_WORD *)&_BYTE buf[12] = 2112;
        *(void *)&buf[14] = a4;
        *(_WORD *)&buf[22] = 2112;
        v291 = (const char *)v279;
        _os_log_impl( (void *)&_mh_execute_header,  v105,  OS_LOG_TYPE_DEFAULT,  "waiting <MSG not resent> %@:%@ extra: %@",  buf,  0x20u);
      }
    }

    if (v52) {
      CFRelease(v52);
    }
    id v107 = (const void *)v283[3];
    if (v107)
    {
      v283[3] = 0LL;
      CFRelease(v107);
    }

    CFTypeRef v108 = v279;
    if (v279)
    {
      CFTypeRef v279 = 0LL;
      CFRelease(v108);
    }

    CFTypeRef v109 = v277;
    if (v277)
    {
      CFTypeRef v277 = 0LL;
      CFRelease(v109);
    }

    CFDataRef v110 = CFDataCreate(kCFAllocatorDefault, 0LL, 0LL);
LABEL_323:
    _Block_object_dispose(&v282, 8);
    if (v110)
    {
      if (!CFDataGetLength(v110) && !*(_BYTE *)(a4 + 48))
      {
        uint64_t v33 = 1LL;
LABEL_354:
        CFRelease(v110);
        goto LABEL_21;
      }

      cf1a = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
      v215 = *(const void **)(a5 + 24);
      if (!v215)
      {
        CFStringAppend(cf1a, @"*** using null coder ***");
        CFIndex v233 = CFDataGetLength(v110);
        v220 = v110;
        MutableCFDataRef Copy = CFDataCreateMutableCopy(0LL, v233, v110);
        uint64_t v258 = 0LL;
        CFMutableDataRef v260 = 0LL;
        CFStringRef v216 = 0LL;
        goto LABEL_332;
      }

      CFStringRef v216 = CFCopyDescription(v215);
      if ((SecOTRSGetIsReadyForMessages(*(void *)(a5 + 24)) & 1) != 0)
      {
        if (!*(_BYTE *)(a5 + 32))
        {
          CFMutableDataRef v217 = CFDataCreateMutable(kCFAllocatorDefault, 0LL);
          if (v217)
          {
            MutableCFDataRef Copy = v217;
            uint64_t v219 = SecOTRSSignAndProtectMessage(*(void *)(a5 + 24), v110, v217);
            v220 = v110;
            if (!(_DWORD)v219)
            {
              uint64_t v258 = 0LL;
              CFMutableDataRef v260 = MutableCopy;
LABEL_332:
              uint64_t v33 = 1LL;
              goto LABEL_333;
            }

            if (a10) {
              CFTypeRef v235 = *a10;
            }
            else {
              CFTypeRef v235 = 0LL;
            }
            v237 = a7;
            uint64_t v238 = v219;
            SOSCreateErrorWithFormat(1025LL, v235, a10, 0LL, @"%@ cannot protect message: %d");
            CFRelease(MutableCopy);
          }

          else
          {
            v220 = v110;
            v237 = a7;
            SOSCreateErrorWithFormat(1024LL, 0LL, a10, 0LL, @"%@ alloc failed");
          }

          if (a10 && *a10) {
            CFStringAppendFormat(cf1a, 0LL, @" %@", *a10);
          }
          MutableCFDataRef Copy = 0LL;
          uint64_t v33 = 0LL;
          uint64_t v258 = 3LL;
          CFMutableDataRef v260 = 0LL;
LABEL_333:
          v221 = (os_log_s *)sub_10001267C("coder");
          if (os_log_type_enabled(v221, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v230 = SecOTRPacketTypeString(v260);
            uint64_t v231 = *(void *)(a5 + 24);
            v232 = off_100292720[v258];
            *(_DWORD *)__int128 buf = 138413570;
            *(void *)&uint8_t buf[4] = a7;
            *(_WORD *)&_BYTE buf[12] = 2112;
            *(void *)&buf[14] = v216;
            *(_WORD *)&buf[22] = 2080;
            v291 = (const char *)v230;
            LOWORD(v292[0]) = 2112;
            *(void *)((char *)v292 + 2) = cf1a;
            WORD5(v292[0]) = 2112;
            *(void *)((char *)v292 + 12) = v231;
            WORD2(v292[1]) = 2080;
            *(void *)((char *)&v292[1] + 6) = v232;
            _os_log_debug_impl( (void *)&_mh_execute_header,  v221,  OS_LOG_TYPE_DEBUG,  "%@ %@ %s %@ %@ returned %s",  buf,  0x3Eu);
            if (!v216) {
              goto LABEL_336;
            }
          }

          else if (!v216)
          {
LABEL_336:
            CFRelease(cf1a);
            CFDataRef v110 = v220;
            if ((v33 & 1) != 0)
            {
              CFMutableDataRef v223 = *a6;
              if (*a6 != MutableCopy)
              {
                if (!MutableCopy || (CFRetain(MutableCopy), (CFMutableDataRef v223 = *a6) != 0LL)) {
                  CFRelease(v223);
                }
                *a6 = MutableCopy;
              }
            }

            else
            {
              v227 = sub_10001267C("transport");
              v228 = (os_log_s *)objc_claimAutoreleasedReturnValue(v227);
              if (os_log_type_enabled(v228, OS_LOG_TYPE_DEFAULT))
              {
                CFTypeRef v229 = *a10;
                *(_DWORD *)__int128 buf = 138412546;
                *(void *)&uint8_t buf[4] = a7;
                *(_WORD *)&_BYTE buf[12] = 2112;
                *(void *)&buf[14] = v229;
                _os_log_impl( (void *)&_mh_execute_header,  v228,  OS_LOG_TYPE_DEFAULT,  "%@ SOSCoderWrap failed: %@",  buf,  0x16u);
              }
            }

            if (MutableCopy) {
              CFRelease(MutableCopy);
            }
            goto LABEL_354;
          }

          CFRelease(v216);
          goto LABEL_336;
        }

        v220 = v110;
        id v234 = @"waiting for peer to send data packet first";
      }

      else
      {
        v220 = v110;
        id v234 = @"not ready";
      }

      CFStringAppend(cf1a, v234);
      MutableCFDataRef Copy = 0LL;
      uint64_t v33 = 0LL;
      uint64_t v258 = 1LL;
      CFMutableDataRef v260 = 0LL;
      goto LABEL_333;
    }

LABEL_341:
    v224 = sub_10001267C("transport");
    v225 = (os_log_s *)objc_claimAutoreleasedReturnValue(v224);
    if (os_log_type_enabled(v225, OS_LOG_TYPE_DEFAULT))
    {
      CFTypeRef v226 = *a10;
      *(_DWORD *)__int128 buf = 138412546;
      *(void *)&uint8_t buf[4] = a7;
      *(_WORD *)&_BYTE buf[12] = 2112;
      *(void *)&buf[14] = v226;
      _os_log_impl( (void *)&_mh_execute_header,  v225,  OS_LOG_TYPE_DEFAULT,  "%@ SOSEngineCreateMessage_locked failed: %@",  buf,  0x16u);
    }

    uint64_t v33 = 0LL;
LABEL_21:
    BOOL v34 = sub_1001A19D8(v265, 2LL);
    if (*a6) {
      char v35 = v34;
    }
    else {
      char v35 = 1;
    }
    if ((v35 & 1) != 0) {
      goto LABEL_65;
    }
    id v36 = a7;
    id v37 = sub_10018DFDC(v265, (uint64_t)@"NegotiationRetryCount");
    __int16 v38 = (void *)objc_claimAutoreleasedReturnValue(v37);
    if (!v38) {
      __int16 v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
    }
    CFStringRef v39 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v38, "objectForKey:", v36, v237, v238));
    __int16 v40 = v39;
    if (v39)
    {
      BOOL v41 = (int)[v39 intValue] > 6;

      if (v41) {
        goto LABEL_65;
      }
    }

    else
    {
    }

    if (!SecOTRSessionIsSessionInAwaitingState(*(void *)(a5 + 24))
      || sub_1001AFF50(*(void **)(a4 + 16), *(CFDictionaryRef *)(a4 + 104)))
    {
LABEL_57:
      if ((SecOTRSessionIsSessionInAwaitingState(*(void *)(a5 + 24)) & 1) != 0)
      {
        if (!sub_1001AFF50(*(void **)(a4 + 16), *(CFDictionaryRef *)(a4 + 104)))
        {
LABEL_65:
          int v21 = v265;
          goto LABEL_66;
        }

        id v65 = sub_10001267C("otrtimer");
        uint64_t v66 = (os_log_s *)objc_claimAutoreleasedReturnValue(v65);
        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          *(void *)&uint8_t buf[4] = a5;
          _os_log_impl( (void *)&_mh_execute_header,  v66,  OS_LOG_TYPE_DEFAULT,  "timer for coder already set: %@",  buf,  0xCu);
        }
      }

      else
      {
        id v67 = sub_10001267C("otrtimer");
        uint64_t v66 = (os_log_s *)objc_claimAutoreleasedReturnValue(v67);
        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          *(void *)&uint8_t buf[4] = a5;
          _os_log_impl( (void *)&_mh_execute_header,  v66,  OS_LOG_TYPE_DEFAULT,  "coder not in awaiting state: %@",  buf,  0xCu);
        }
      }

      goto LABEL_65;
    }

    id v42 = v36;
    CFMutableArrayRef v43 = (const __CFDictionary *)sub_10018DFDC(v265, (uint64_t)@"PeerNegotiationTimeouts");
    id v44 = v43;
    if (v43 && (CFTypeID v45 = CFGetTypeID(v43), v45 == CFDictionaryGetTypeID()))
    {
      if (CFDictionaryGetValue(v44, v42))
      {

        __int128 v46 = sub_10001267C("otrtimer");
        uint64_t v47 = (os_log_s *)objc_claimAutoreleasedReturnValue(v46);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "coder is in awaiting state", buf, 2u);
        }

        sub_100197318(v265, a4);
        goto LABEL_65;
      }

      uint64_t v236 = sub_10001267C("otrtimer");
      char v64 = (os_log_s *)objc_claimAutoreleasedReturnValue(v236);
      if (!os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_56;
      }
      *(_WORD *)__int128 buf = 0;
    }

    else
    {
      uint64_t v63 = sub_10001267C("otrtimer");
      char v64 = (os_log_s *)objc_claimAutoreleasedReturnValue(v63);
      if (!os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
      {
LABEL_56:

        goto LABEL_57;
      }

      *(_WORD *)__int128 buf = 0;
    }

    _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "do not have an rtt yet", buf, 2u);
    goto LABEL_56;
  }

  int v21 = v15;
  objc_msgSend(v15, "setEngine_peer_state_needs_repair:", 1);
  uint64_t v22 = sub_10001267C("transport");
  uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    if (a10) {
      CFTypeRef v24 = *a10;
    }
    else {
      CFTypeRef v24 = 0LL;
    }
    *(_DWORD *)__int128 buf = 138412546;
    *(void *)&uint8_t buf[4] = a7;
    *(_WORD *)&_BYTE buf[12] = 2112;
    *(void *)&buf[14] = v24;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%@ getCoder: %@", buf, 0x16u);
  }

  uint64_t v33 = 0LL;
LABEL_66:

  return v33;
}

void sub_1001B2BC4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
}

void sub_1001B2CA8(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  CFTypeID v4 = WeakRetained;
  if (a2)
  {
    id v8 = WeakRetained;
    BOOL v5 = [WeakRetained coder];
    CFTypeID v4 = v8;
    CFIndex v6 = v5;
    CFIndex v7 = (const void *)v5[5];
    if (v7)
    {
      void v6[5] = 0LL;
      CFRelease(v7);
      CFTypeID v4 = v8;
    }
  }
}

void sub_1001B2D04(uint64_t a1, uint64_t a2)
{
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(a2);
  if (!CFEqual(*(CFTypeRef *)(a1 + 32), PeerID))
  {
    BOOL v5 = (const void *)SOSPeerInfoCopySerialNumber(a2);
    CFIndex v6 = *(const void **)(a1 + 40);
    if (v5 && v6)
    {
      if (!CFEqual(v6, v5)) {
        goto LABEL_10;
      }
    }

    else if (v6 != v5)
    {
      goto LABEL_9;
    }

    CFSetAddValue(*(CFMutableSetRef *)(a1 + 48), PeerID);
LABEL_9:
    if (!v5) {
      return;
    }
LABEL_10:
    CFRelease(v5);
  }

uint64_t sub_1001B2D9C(void *a1)
{
  id v1 = a1;
  uint64_t v2 = objc_claimAutoreleasedReturnValue([v1 peerID]);
  if (v2)
  {
    CFTypeRef v3 = (void *)objc_claimAutoreleasedReturnValue([v1 trust]);
    id v4 = [v3 trustedCircle];

    if (v4)
    {
      BOOL v5 = (void *)objc_claimAutoreleasedReturnValue([v1 trust]);
      uint64_t v2 = SOSCircleCopyCircle(kCFAllocatorDefault, [v5 trustedCircle], 0);

      if (v2)
      {
        id v6 = [v1 peerInfo];
        if (v6)
        {
          id v7 = v6;
          unsigned int Class = SOSPeerInfoGetClass();
          if (Class <= 5 && ((1 << Class) & 0x34) != 0)
          {
            if (SOSPeerInfoSerialNumberIsSet(v7))
            {
              uint64_t v9 = SOSPeerInfoCopySerialNumber(v7);
              if (v9)
              {
                CFDictionaryRef v10 = (void *)v9;
                uint64_t PeerID = (void (*)(uint64_t))SOSPeerInfoGetPeerID(v7);
                CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
                if (Mutable)
                {
                  CFIndex v13 = Mutable;
                  __int16 v28 = _NSConcreteStackBlock;
                  uint64_t v29 = 3221225472LL;
                  uint64_t v30 = (uint64_t)sub_1001B2D04;
                  BOOL v31 = (uint64_t (*)(uint64_t, uint64_t))&unk_100292B48;
                  __int128 v32 = PeerID;
                  id v33 = v10;
                  CFMutableSetRef v34 = Mutable;
                  SOSCircleForEachPeer(v2, &v28);
                  CFRelease(v10);
                  if (CFSetGetCount(v13)) {
                    SOSCircleRemovePeersByIDUnsigned(v2, v13);
                  }
                  int v14 = v13;
                }

                else
                {
                  int v14 = (const __CFSet *)v10;
                }

                CFRelease(v14);
              }
            }
          }
        }

        SOSCircleRemoveRetired(v2, 0LL);
        id v15 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
        __int16 v28 = _NSConcreteStackBlock;
        uint64_t v29 = 3221225472LL;
        uint64_t v30 = (uint64_t)sub_1001B3120;
        BOOL v31 = (uint64_t (*)(uint64_t, uint64_t))&unk_100292B70;
        __int128 v32 = v15;
        __int16 v16 = v15;
        SOSCircleForEachiCloudIdentityPeer(v2, &v28);
        SOSCircleRemovePeersByIDUnsigned(v2, v16);

        BOOL v17 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
        __int16 v28 = _NSConcreteStackBlock;
        uint64_t v29 = 3221225472LL;
        uint64_t v30 = (uint64_t)sub_1001B3164;
        BOOL v31 = (uint64_t (*)(uint64_t, uint64_t))&unk_100292B70;
        __int128 v32 = v17;
        uint64_t v18 = v17;
        SOSCircleForEachActivePeer(v2, &v28);
        SOSCircleRemovePeersByIDUnsigned(v2, v18);

        __int16 v28 = 0LL;
        uint64_t v29 = (uint64_t)&v28;
        uint64_t v30 = 0x3032000000LL;
        BOOL v31 = sub_1001B31D0;
        __int128 v32 = sub_1001B31E0;
        id v33 = 0LL;
        if (+[SOSAuthKitHelpers accountIsCDPCapable](&OBJC_CLASS___SOSAuthKitHelpers, "accountIsCDPCapable"))
        {
          v27[0] = _NSConcreteStackBlock;
          v27[1] = 3221225472LL;
          v27[2] = sub_1001B31E8;
          v27[3] = &unk_100292B98;
          void v27[4] = &v28;
          +[SOSAuthKitHelpers activeMIDs:](&OBJC_CLASS___SOSAuthKitHelpers, "activeMIDs:", v27);
        }

        CFTypeID v19 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
        CFIndex v20 = v19;
        if (*(void *)(v29 + 40))
        {
          v24[0] = _NSConcreteStackBlock;
          v24[1] = 3221225472LL;
          void v24[2] = sub_1001B3244;
          v24[3] = &unk_100292BC0;
          CFMutableArrayRef v26 = &v28;
          int v21 = v19;
          CFTypeRef v25 = v21;
          SOSCircleForEachActivePeer(v2, v24);
          SOSCircleRemovePeersByIDUnsigned(v2, v21);
        }

        _Block_object_dispose(&v28, 8);
        int v22 = SOSCircleCountPeers(v2);
        CFRelease((CFTypeRef)v2);
        uint64_t v2 = v22 == 0;
      }
    }

    else
    {
      uint64_t v2 = 0LL;
    }
  }

  return v2;
}

void sub_1001B3104( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
}

void sub_1001B3120(uint64_t a1, uint64_t a2)
{
  uint64_t PeerID = SOSPeerInfoGetPeerID(a2);
  id v4 = (id)objc_claimAutoreleasedReturnValue(PeerID);
  [*(id *)(a1 + 32) addObject:v4];
}

void sub_1001B3164(uint64_t a1, uint64_t a2)
{
  uint64_t PeerDeviceType = SOSPeerInfoGetPeerDeviceType(a2);
  id v7 = (id)objc_claimAutoreleasedReturnValue(PeerDeviceType);
  if ([v7 hasPrefix:@"Windows"])
  {
    uint64_t PeerID = SOSPeerInfoGetPeerID(a2);
    id v6 = (void *)objc_claimAutoreleasedReturnValue(PeerID);
    [*(id *)(a1 + 32) addObject:v6];
  }
}

uint64_t sub_1001B31D0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1001B31E0(uint64_t a1)
{
}

void sub_1001B31E8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = -[SOSAuthKitHelpers initWithActiveMIDS:](objc_alloc(&OBJC_CLASS___SOSAuthKitHelpers), "initWithActiveMIDS:", v3);

  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8LL);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;
}

void sub_1001B3244(uint64_t a1, uint64_t a2)
{
  id v6 = (id)SOSPeerInfoV2DictionaryCopyString(a2, sMachineIDKey);
  if ((objc_msgSend(*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), "midIsValidInList:") & 1) == 0)
  {
    uint64_t PeerID = SOSPeerInfoGetPeerID(a2);
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(PeerID);
    [*(id *)(a1 + 32) addObject:v5];
  }
}

uint64_t sub_1001B32C0(const __CFSet *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  CFDictionaryRef v11 = sub_1001B3390(a1);
  uint64_t v15 = 0LL;
  __int16 v16 = &v15;
  uint64_t v17 = 0x2000000000LL;
  int v18 = 4;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000LL;
  v14[2] = sub_1001B34C0;
  v14[3] = &unk_100292BE8;
  void v14[6] = a3;
  v14[7] = a4;
  v14[8] = a6;
  v14[9] = a5;
  void v14[4] = &v15;
  void v14[5] = v11;
  sub_1001D5F24(a2, (uint64_t)v14);
  if (v11) {
    CFRelease(v11);
  }
  uint64_t v12 = *((unsigned int *)v16 + 6);
  _Block_object_dispose(&v15, 8);
  return v12;
}

CFDictionaryRef sub_1001B3390(const __CFSet *a1)
{
  CFIndex Count = CFSetGetCount(a1);
  size_t v3 = 8 * Count;
  unint64_t v4 = (8 * Count + 15) & 0xFFFFFFFFFFFFFFF0LL;
  uint64_t v5 = (const void **)&v10[-v4];
  if (((uint64_t (*)(void))__chkstk_darwin)())
  {
    id v6 = memset(&v10[-v4], 170, v3);
    __chkstk_darwin(v6);
    id v7 = &v10[-v4];
    memset(v7, 170, v3);
    CFSetGetValues(a1, v5);
    uint64_t v8 = 0LL;
    do
    {
      *(void *)&v7[8 * v8] = SOSPeerInfoGetPeerID(v5[v8]);
      ++v8;
    }

    while (Count != v8);
  }

  else
  {
    CFSetGetValues(a1, (const void **)&v10[-v4]);
    id v7 = v10;
  }

  return CFDictionaryCreate( 0LL,  (const void **)v7,  v5,  Count,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
}

void sub_1001B34C0(uint64_t a1, const void *a2)
{
  signed int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), a2);
  uint64_t v5 = Value;
  if (Value
    && (uint64_t v6 = *(void *)(a1 + 48),
        uint64_t v7 = *(void *)(a1 + 56),
        uint64_t v8 = *(CFTypeRef **)(a1 + 64),
        (uint64_t v9 = SOSPeerInfoCopyPubKey(Value, v8)) != 0))
  {
    CFDictionaryRef v10 = (__SecKey *)v9;
    if (sub_1001D5D68(v6, a2) && SOSPeerInfoApplicationVerify(v5, v7, 0LL))
    {
      if (sub_1001D6554(v6, (uint64_t)v10, (uint64_t)v8))
      {
        if (sub_1001D65E8(v6, v10, v8)) {
          int v11 = 0;
        }
        else {
          int v11 = 6;
        }
      }

      else
      {
        int v11 = 7;
      }
    }

    else
    {
      int v11 = 4;
    }

    CFRelease(v10);
  }

  else
  {
    int v11 = 4;
  }

  uint64_t v12 = (os_log_s *)sub_10001267C("ring");
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v20 = 138412546;
    int v21 = a2;
    __int16 v22 = 1024;
    int v23 = v11;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "concordance-signer-status: %@ -> %d",  (uint8_t *)&v20,  0x12u);
  }

  if (v11 == 7)
  {
    uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(v5);
    int v14 = *(const void **)(a1 + 72);
    if (PeerID && v14)
    {
      if (!CFEqual(PeerID, v14))
      {
LABEL_18:
        if (!SOSPeerInfoIsCloudIdentity(v5))
        {
          int v11 = 7;
          goto LABEL_21;
        }
      }
    }

    else if (PeerID != v14)
    {
      goto LABEL_18;
    }

    int v11 = 4;
  }

void sub_1001B36B0(void *a1, uint64_t a2)
{
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID(a2);
  if (!sub_1001D5D68(a1[5], PeerID)) {
    return;
  }
  if (!a2) {
    goto LABEL_32;
  }
  uint64_t v5 = a1[5];
  uint64_t v6 = a1[6];
  uint64_t v7 = (CFTypeRef *)a1[7];
  uint64_t v8 = SOSPeerInfoCopyPubKey(a2, v7);
  if (!v8) {
    goto LABEL_32;
  }
  uint64_t v9 = (void *)v8;
  if (!sub_1001D5D68(v5, PeerID) || !SOSPeerInfoApplicationVerify(a2, v6, 0LL))
  {
    int v10 = 4;
LABEL_10:
    CFRelease(v9);
    goto LABEL_11;
  }

  if (sub_1001D6554(v5, (uint64_t)v9, (uint64_t)v7))
  {
    if (sub_1001D65E8(v5, (__SecKey *)v9, v7)) {
      int v10 = 0;
    }
    else {
      int v10 = 6;
    }
    goto LABEL_10;
  }

  CFRelease(v9);
  uint64_t v16 = (const void *)SOSPeerInfoGetPeerID(a2);
  int v17 = (const void *)a1[8];
  if (!v16 || !v17)
  {
    if (v16 != v17) {
      goto LABEL_31;
    }
LABEL_32:
    int v10 = 4;
    goto LABEL_11;
  }

  if (CFEqual(v16, v17)) {
    goto LABEL_32;
  }
LABEL_31:
  int v10 = 7;
LABEL_11:
  int v11 = 0;
  uint64_t v12 = *(void *)(a1[4] + 8LL);
  if (v10)
  {
    int v13 = *(_DWORD *)(v12 + 24);
    if (v13)
    {
      int v11 = 6;
      if (v10 != 6)
      {
        if (v13 == 7 || v10 == 7) {
          int v15 = 7;
        }
        else {
          int v15 = *(_DWORD *)(v12 + 24);
        }
        if (v13 == 6) {
          int v11 = 6;
        }
        else {
          int v11 = v15;
        }
      }
    }
  }

  *(_DWORD *)(v12 + 24) = v11;
}

uint64_t sub_1001B3814(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_1001B3828( uint64_t a1, const __CFSet *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a6)
  {
    if (!sub_1001D6420(a4))
    {
      if (sub_1001D6420(a3)) {
        goto LABEL_12;
      }
      sub_1001D5570((void *)a4);
      sub_1001D5570((void *)a4);
      signed int Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 24), @"PeerIDs");
      if (!Value || (v18 = Value, CFTypeID v19 = CFGetTypeID(Value), v19 != CFSetGetTypeID())) {
        int v18 = 0LL;
      }
      if (CFSetGetCount(v18) == 1)
      {
LABEL_12:
        int v20 = a2;
        uint64_t v21 = a4;
        uint64_t v22 = a4;
        uint64_t v23 = a6;
        uint64_t v24 = 0LL;
      }

      else
      {
        if (sub_1001D5B70(*(const __CFDictionary **)(a4 + 24), a3))
        {
          SOSCreateError(1039LL, @"Bad generation", 0LL, a8);
          return 1LL;
        }

        int v20 = a2;
        uint64_t v21 = a3;
        uint64_t v22 = a4;
        uint64_t v23 = a6;
        uint64_t v24 = a7;
      }

      return sub_1001B32C0(v20, v21, v22, v23, v24, a8);
    }

    int v14 = (os_log_s *)sub_10001267C("ring");
    BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (v15)
    {
      *(_WORD *)CFTypeRef v25 = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "ring empty -> trusted", v25, 2u);
      return 0LL;
    }
  }

  else
  {
    SOSCreateError(2LL, @"Concordance with no public key - need to validate application", 0LL, a8);
    return 3LL;
  }

  return result;
}

id sub_1001B48A4()
{
  if (!objc_opt_class(&OBJC_CLASS___ACAccount) || !objc_opt_class(&OBJC_CLASS___ACAccountStore))
  {
    size_t v3 = sub_10001267C("sosauthkit");
    id v1 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "ACAccount not available", buf, 2u);
    }

    goto LABEL_10;
  }

  v0 = (os_log_s *)objc_claimAutoreleasedReturnValue(+[ACAccountStore defaultStore](&OBJC_CLASS___ACAccountStore, "defaultStore"));
  if (!v0)
  {
    unint64_t v4 = sub_10001267C("sosauthkit");
    uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "can't get store", v7, 2u);
    }

    id v1 = 0LL;
LABEL_10:
    uint64_t v2 = 0LL;
    goto LABEL_11;
  }

  id v1 = v0;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s aa_primaryAppleAccount](v0, "aa_primaryAppleAccount"));
LABEL_11:

  return v2;
}

uint64_t sub_1001B49B0(uint64_t a1, uint64_t a2)
{
  Hasuint64_t String = SOSPeerInfoV2DictionaryHasString(a2, sMachineIDKey);
  if ((HasString & 1) == 0)
  {
    uint64_t v5 = sub_10001267C("sosauthkit");
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      int v9 = 138412290;
      uint64_t v10 = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Setting PeerInfo MID to %@",  (uint8_t *)&v9,  0xCu);
    }

    SOSPeerInfoV2DictionarySetValue(a2, sMachineIDKey, *(void *)(a1 + 32));
  }

  return HasString ^ 1u;
}

void sub_1001B4AA0(uint64_t a1, void *a2, uint64_t a3)
{
  if (a3)
  {
    (*(void (**)(void, void))(*(void *)(a1 + 32) + 16LL))(*(void *)(a1 + 32), 0LL);
  }

  else
  {
    unint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([a2 deviceList]);
    uint64_t v5 = objc_opt_new(&OBJC_CLASS___NSMutableSet);
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    id v6 = v4;
    id v7 = [v6 countByEnumeratingWithState:&v18 objects:v22 count:16];
    if (v7)
    {
      id v8 = v7;
      uint64_t v9 = *(void *)v19;
      do
      {
        uint64_t v10 = 0LL;
        do
        {
          if (*(void *)v19 != v9) {
            objc_enumerationMutation(v6);
          }
          int v11 = *(void **)(*((void *)&v18 + 1) + 8LL * (void)v10);
          uint64_t v12 = objc_opt_new(&OBJC_CLASS___SOSTrustedDeviceAttributes);
          int v13 = (void *)objc_claimAutoreleasedReturnValue([v11 machineId]);
          -[SOSTrustedDeviceAttributes setMachineID:](v12, "setMachineID:", v13);

          int v14 = (void *)objc_claimAutoreleasedReturnValue([v11 serialNumber]);
          -[SOSTrustedDeviceAttributes setSerialNumber:](v12, "setSerialNumber:", v14);

          -[NSMutableSet addObject:](v5, "addObject:", v12);
          uint64_t v10 = (char *)v10 + 1;
        }

        while (v8 != v10);
        id v8 = [v6 countByEnumeratingWithState:&v18 objects:v22 count:16];
      }

      while (v8);
    }

    if (!-[NSMutableSet count](v5, "count"))
    {
      BOOL v15 = sub_10001267C("sosauthkit");
      uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v17 = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "found no devices in account", v17, 2u);
      }

      uint64_t v5 = 0LL;
    }

    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }

uint64_t sub_1001B4CD8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_1001B4CEC()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1001B4D68;
  block[3] = &unk_1002935A8;
  void block[4] = &qword_1002DEE28;
  if (qword_1002DEE20 != -1) {
    dispatch_once(&qword_1002DEE20, block);
  }
  return qword_1002DEE28;
}

CFMutableArrayRef sub_1001B4D68(uint64_t a1)
{
  CFMutableArrayRef result = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, 0LL);
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t sub_1001B4DA4()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1001B4E20;
  block[3] = &unk_1002935A8;
  void block[4] = &qword_1002DEE38;
  if (qword_1002DEE30 != -1) {
    dispatch_once(&qword_1002DEE30, block);
  }
  return qword_1002DEE38;
}

CFMutableArrayRef sub_1001B4E20(uint64_t a1)
{
  CFMutableArrayRef result = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, 0LL);
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t sub_1001B4E5C()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1001B4ED8;
  block[3] = &unk_1002935A8;
  void block[4] = &qword_1002DEE48;
  if (qword_1002DEE40 != -1) {
    dispatch_once(&qword_1002DEE40, block);
  }
  return qword_1002DEE48;
}

CFMutableArrayRef sub_1001B4ED8(uint64_t a1)
{
  CFMutableArrayRef result = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, 0LL);
  **(void **)(a1 + 32) = result;
  return result;
}

void sub_1001B4F14(void *a1)
{
  id value = a1;
  id v1 = (const __CFArray *)sub_1001B4CEC();
  v5.CFIndex length = CFArrayGetCount(v1);
  v5.id location = 0LL;
  FirstIndexOfsigned int Value = CFArrayGetFirstIndexOfValue(v1, v5, value);
  if (FirstIndexOfValue != -1)
  {
    for (CFIndex i = FirstIndexOfValue; i != -1; CFIndex i = CFArrayGetFirstIndexOfValue(v1, v6, value))
    {
      CFArrayRemoveValueAtIndex(v1, i);
      v6.CFIndex length = CFArrayGetCount(v1);
      v6.id location = 0LL;
    }
  }
}

void sub_1001B4F9C(void *a1)
{
  id value = a1;
  id v1 = (__CFArray *)sub_1001B4E5C();
  CFArrayAppendValue(v1, value);
}

void sub_1001B4FCC(void *a1)
{
  id value = a1;
  id v1 = (const __CFArray *)sub_1001B4E5C();
  v5.CFIndex length = CFArrayGetCount(v1);
  v5.id location = 0LL;
  FirstIndexOfsigned int Value = CFArrayGetFirstIndexOfValue(v1, v5, value);
  if (FirstIndexOfValue != -1)
  {
    for (CFIndex i = FirstIndexOfValue; i != -1; CFIndex i = CFArrayGetFirstIndexOfValue(v1, v6, value))
    {
      CFArrayRemoveValueAtIndex(v1, i);
      v6.CFIndex length = CFArrayGetCount(v1);
      v6.id location = 0LL;
    }
  }
}

void sub_1001B5054(void *a1)
{
  id value = a1;
  id v1 = (const __CFArray *)sub_1001B4DA4();
  v5.CFIndex length = CFArrayGetCount(v1);
  v5.id location = 0LL;
  FirstIndexOfsigned int Value = CFArrayGetFirstIndexOfValue(v1, v5, value);
  if (FirstIndexOfValue != -1)
  {
    for (CFIndex i = FirstIndexOfValue; i != -1; CFIndex i = CFArrayGetFirstIndexOfValue(v1, v6, value))
    {
      CFArrayRemoveValueAtIndex(v1, i);
      v6.CFIndex length = CFArrayGetCount(v1);
      v6.id location = 0LL;
    }
  }
}

void sub_1001B50DC(void *a1)
{
  id v1 = a1;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v3 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v4 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFRange v5 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  if (qword_1002DEE58 != -1) {
    dispatch_once(&qword_1002DEE58, &stru_100292CB0);
  }
  uint64_t v6 = sub_1001B4DA4();
  id v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  v90[0] = _NSConcreteStackBlock;
  v90[1] = 3221225472LL;
  v90[2] = sub_1001B5A94;
  v90[3] = &unk_100292CD8;
  id v8 = v1;
  id v91 = v8;
  CFMutableArrayRef v92 = Mutable;
  CFMutableArrayRef v93 = v3;
  CFMutableArrayRef v94 = v4;
  uint64_t v54 = v7;
  [v7 enumerateObjectsUsingBlock:v90];
  uint64_t v9 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  CFDictionarySetValue(v9, @"AlwaysKeys", Mutable);
  CFDictionarySetValue(v9, @"FirstUnlockKeys", v3);
  CFDictionarySetValue(v9, @"UnlockedKeys", v4);
  uint64_t v53 = v9;
  CFDictionarySetValue(v5, @"KeyParameter", v9);
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v3) {
    CFRelease(v3);
  }
  if (v4) {
    CFRelease(v4);
  }
  CFMutableArrayRef v10 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v11 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v12 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  int v13 = (const __CFArray *)sub_1001B4E5C();
  context[0] = _NSConcreteStackBlock;
  context[1] = 3221225472LL;
  uint64_t context[2] = sub_1001B5BD0;
  context[3] = &unk_100292D00;
  id v14 = v8;
  id v86 = v14;
  CFMutableArrayRef v87 = v10;
  CFMutableArrayRef v88 = v11;
  CFMutableArrayRef v89 = v12;
  v106.CFIndex length = CFArrayGetCount(v13);
  v106.id location = 0LL;
  CFArrayApplyFunction(v13, v106, (CFArrayApplierFunction)sub_1001B4CD8, context);
  BOOL v15 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  CFDictionarySetValue(v15, @"AlwaysKeys", v10);
  CFDictionarySetValue(v15, @"FirstUnlockKeys", v11);
  CFDictionarySetValue(v15, @"UnlockedKeys", v12);
  CFDictionarySetValue(v5, @"Circle", v15);
  if (v10) {
    CFRelease(v10);
  }
  if (v11) {
    CFRelease(v11);
  }
  if (v12) {
    CFRelease(v12);
  }
  CFMutableArrayRef v16 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v17 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v18 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  __int128 v19 = (const __CFArray *)sub_1001B4CEC();
  v80[0] = _NSConcreteStackBlock;
  v80[1] = 3221225472LL;
  v80[2] = sub_1001B5DCC;
  v80[3] = &unk_100292D00;
  id v52 = v14;
  id v81 = v52;
  CFMutableArrayRef v82 = v16;
  CFMutableArrayRef v83 = v17;
  CFMutableArrayRef v84 = v18;
  v107.CFIndex length = CFArrayGetCount(v19);
  v107.id location = 0LL;
  CFArrayApplyFunction(v19, v107, (CFArrayApplierFunction)sub_1001B4CD8, v80);
  __int128 v20 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
  CFMutableArrayRef cf = v16;
  CFDictionarySetValue(v20, @"AlwaysKeys", v16);
  CFMutableArrayRef v50 = v17;
  CFDictionarySetValue(v20, @"FirstUnlockKeys", v17);
  CFMutableArrayRef v51 = v18;
  CFDictionarySetValue(v20, @"UnlockedKeys", v18);
  __int128 v48 = v20;
  CFDictionarySetValue(v5, @"Message", v20);
  unsigned int v21 = [(id)qword_1002DEE50 hasChanged:v5];
  uint64_t v22 = sub_10001267C("key-interests");
  uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = "No Change, Ignoring";
    if (v21) {
      uint64_t v24 = "Registering with CKP";
    }
    *(_DWORD *)__int128 buf = 136315138;
    uint64_t v96 = v24;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Calculating interests done: %s", buf, 0xCu);
  }

  if (v21)
  {
    __int128 v78 = 0u;
    __int128 v79 = 0u;
    __int128 v76 = 0u;
    __int128 v77 = 0u;
    v104[0] = @"Message";
    v104[1] = @"Circle";
    v104[2] = @"KeyParameter";
    id obj = (id)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v104, 3LL));
    char v60 = v5;
    id v57 = [obj countByEnumeratingWithState:&v76 objects:v105 count:16];
    CFTypeRef v25 = 0LL;
    if (v57)
    {
      uint64_t v56 = *(void *)v77;
      do
      {
        uint64_t v26 = 0LL;
        do
        {
          if (*(void *)v77 != v56) {
            objc_enumerationMutation(obj);
          }
          uint64_t v58 = v26;
          uint64_t v27 = *(const char **)(*((void *)&v76 + 1) + 8 * v26);
          __int16 v28 = sub_10001267C("key-interests");
          uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138412290;
            uint64_t v96 = v27;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Updating interests: %@", buf, 0xCu);
          }

          __int128 v74 = 0u;
          __int128 v75 = 0u;
          __int128 v72 = 0u;
          __int128 v73 = 0u;
          v102[0] = @"AlwaysKeys";
          v102[1] = @"FirstUnlockKeys";
          v102[2] = @"UnlockedKeys";
          id v59 = (id)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v102, 3LL));
          id v62 = [v59 countByEnumeratingWithState:&v72 objects:v103 count:16];
          if (v62)
          {
            uint64_t v61 = *(void *)v73;
            do
            {
              uint64_t v30 = 0LL;
              do
              {
                id v65 = v25;
                if (*(void *)v73 != v61) {
                  objc_enumerationMutation(v59);
                }
                uint64_t v64 = v30;
                uint64_t v31 = *(void *)(*((void *)&v72 + 1) + 8 * v30);
                __int128 v32 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", v27));
                id v33 = (void *)objc_claimAutoreleasedReturnValue([v32 objectForKeyedSubscript:v31]);

                id v63 = [v33 count];
                __int128 v68 = 0u;
                __int128 v69 = 0u;
                __int128 v70 = 0u;
                __int128 v71 = 0u;
                id v34 = v33;
                id v35 = [v34 countByEnumeratingWithState:&v68 objects:v101 count:16];
                if (v35)
                {
                  id v36 = v35;
                  uint64_t v37 = *(void *)v69;
                  do
                  {
                    for (CFIndex i = 0LL; i != v36; CFIndex i = (char *)i + 1)
                    {
                      if (*(void *)v69 != v37) {
                        objc_enumerationMutation(v34);
                      }
                      uint64_t v39 = *(void *)(*((void *)&v68 + 1) + 8LL * (void)i);
                      __int16 v40 = sub_10001267C("key-interests");
                      BOOL v41 = (os_log_s *)objc_claimAutoreleasedReturnValue(v40);
                      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)__int128 buf = 138412802;
                        uint64_t v96 = v27;
                        __int16 v97 = 2112;
                        uint64_t v98 = v31;
                        __int16 v99 = 2112;
                        uint64_t v100 = v39;
                        _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  " key-intrest: %@->%@: %@",  buf,  0x20u);
                      }
                    }

                    id v36 = [v34 countByEnumeratingWithState:&v68 objects:v101 count:16];
                  }

                  while (v36);
                }

                CFTypeRef v25 = &v65[(void)v63];

                uint64_t v30 = v64 + 1;
                CFRange v5 = v60;
              }

              while ((id)(v64 + 1) != v62);
              id v62 = [v59 countByEnumeratingWithState:&v72 objects:v103 count:16];
            }

            while (v62);
          }

          uint64_t v26 = v58 + 1;
        }

        while ((id)(v58 + 1) != v57);
        id v57 = [obj countByEnumeratingWithState:&v76 objects:v105 count:16];
      }

      while (v57);
    }

    id v42 = sub_10001267C("key-interests");
    CFMutableArrayRef v43 = (os_log_s *)objc_claimAutoreleasedReturnValue(v42);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      uint64_t v96 = v25;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "Pushing %lu interests to CKP", buf, 0xCu);
    }

    id v44 = v52;
    CFStringRef v45 = sub_1001A9474(v52);
    dispatch_queue_global_t global_queue = dispatch_get_global_queue(-2LL, 0LL);
    uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue(global_queue);
    v66[0] = _NSConcreteStackBlock;
    v66[1] = 3221225472LL;
    v66[2] = sub_1001B5EF4;
    v66[3] = &unk_100292D28;
    id v67 = v52;
    SOSCloudKeychainUpdateKeys(v60, v45, v47, v66);

    if (v45) {
      CFRelease(v45);
    }

    CFRange v5 = v60;
  }

  else
  {
    id v44 = v52;
    objc_msgSend(v52, "setKey_interests_need_updating:", 0);
  }

  if (cf) {
    CFRelease(cf);
  }
  if (v50) {
    CFRelease(v50);
  }
  if (v51) {
    CFRelease(v51);
  }
  if (v53) {
    CFRelease(v53);
  }
  if (v15) {
    CFRelease(v15);
  }
  if (v48) {
    CFRelease(v48);
  }
  if (v5) {
    CFRelease(v5);
  }
}

void sub_1001B5A94(void *a1, void *a2)
{
  id v3 = a2;
  CFMutableArrayRef v4 = (void *)objc_claimAutoreleasedReturnValue([v3 SOSTransportKeyParameterGetAccount:v3]);
  CFRange v5 = v4;
  if (v4 == (void *)a1[4])
  {
    id v6 = [v3 SOSTransportKeyParameterGetTransportType:v3 err:0];

    if (v6 == (id)1)
    {
      CFTypeRef cf = 0LL;
      if (([v3 SOSTransportKeyParameterKVSAppendKeyInterests:v3 ak:a1[5] firstUnLock:a1[6] unlocked:a1[7] err:&cf] & 1) == 0)
      {
        id v7 = sub_10001267C("key-interests");
        id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          CFTypeRef v12 = cf;
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Error getting key parameters interests %@",  buf,  0xCu);
        }
      }

      CFTypeRef v9 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
        CFRelease(v9);
      }
    }
  }

  else
  {
  }
}

void sub_1001B5BD0(void *a1, void *a2)
{
  id v3 = a2;
  CFMutableArrayRef v4 = (void *)objc_claimAutoreleasedReturnValue([v3 getAccount]);
  unsigned int v5 = [v4 isEqual:a1[4]];

  if (v5)
  {
    id v6 = v3;
    CFTypeRef cf = 0LL;
    if (([v6 kvsAppendKeyInterest:a1[5] firstUnlock:a1[6] unlocked:a1[7] err:&cf] & 1) == 0)
    {
      id v7 = sub_10001267C("key-interests");
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFTypeRef v16 = cf;
        _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Error getting circle interests %@",  buf,  0xCu);
      }
    }

    if (([v6 kvsAppendRingKeyInterest:a1[5] firstUnlock:a1[6] unlocked:a1[7] err:&cf] & 1) == 0)
    {
      CFTypeRef v9 = sub_10001267C("key-interests");
      CFMutableArrayRef v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFTypeRef v16 = cf;
        _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Error getting ring interests %@",  buf,  0xCu);
      }
    }

    if (([v6 kvsAppendDebugKeyInterest:a1[5] firstUnlock:a1[6] unlocked:a1[7] err:&cf] & 1) == 0)
    {
      CFMutableArrayRef v11 = sub_10001267C("key-interests");
      CFTypeRef v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFTypeRef v16 = cf;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Error getting debug key interests %@",  buf,  0xCu);
      }
    }

    CFTypeRef v13 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v13);
    }
  }
}

void sub_1001B5DCC(void *a1, void *a2)
{
  id v3 = a2;
  CFMutableArrayRef v4 = (void *)objc_claimAutoreleasedReturnValue([v3 SOSTransportMessageGetAccount]);
  unsigned int v5 = v4;
  if (v4 == (void *)a1[4])
  {
    id v6 = [v3 SOSTransportMessageGetTransportType];

    if (v6 == (id)1)
    {
      CFTypeRef cf = 0LL;
      if (([v3 SOSTransportMessageKVSAppendKeyInterest:v3 ak:a1[5] firstUnlock:a1[6] unlocked:a1[7] err:&cf] & 1) == 0)
      {
        id v7 = sub_10001267C("key-interests");
        id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          CFTypeRef v12 = cf;
          _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "Error getting message interests %@",  buf,  0xCu);
        }
      }

      CFTypeRef v9 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
        CFRelease(v9);
      }
    }
  }

  else
  {
  }
}

id sub_1001B5EF4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return objc_msgSend(*(id *)(a1 + 32), "setKey_interests_need_updating:", 0);
  }
  unsigned int v5 = sub_10001267C("key-interests");
  id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 138412290;
    uint64_t v9 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Error updating keys: %@", (uint8_t *)&v8, 0xCu);
  }

  objc_msgSend(*(id *)(a1 + 32), "setKey_interests_need_updating:", 1);
  return [(id)qword_1002DEE50 reset];
}

void sub_1001B5FF8(id a1)
{
  id v1 = objc_opt_new(&OBJC_CLASS___SOSDictionaryUpdate);
  uint64_t v2 = (void *)qword_1002DEE50;
  qword_1002DEE50 = (uint64_t)v1;
}

uint64_t sub_1001B6020(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1001B6030(uint64_t a1)
{
}

void sub_1001B6038(uint64_t a1, CFTypeRef cf, const void *a3)
{
  CFTypeRef cfa = 0LL;
  key = 0LL;
  CFTypeRef v30 = 0LL;
  CFTypeRef v31 = 0LL;
  CFTypeRef v28 = 0LL;
  CFTypeRef v29 = 0LL;
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFStringGetTypeID())
    {
      switch(SOSKVSKeyGetKeyTypeAndParse(cf, &key, &v31, &cfa, &v28, &v30, &v29))
      {
        case 0u:
          uint64_t v9 = *(__CFDictionary **)(a1 + 48);
          CFMutableArrayRef v10 = key;
          break;
        case 1u:
          if (!*(_BYTE *)(a1 + 96)) {
            goto LABEL_30;
          }
          CFMutableArrayRef v11 = *(const __CFDictionary **)(a1 + 56);
          goto LABEL_17;
        case 2u:
          if (a3)
          {
            CFTypeID v12 = CFGetTypeID(a3);
            if (v12 == CFDataGetTypeID())
            {
              CFRetain(a3);
              *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = a3;
            }
          }

          goto LABEL_30;
        case 3u:
          if (*(_BYTE *)(a1 + 96)) {
            *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
          }
          goto LABEL_30;
        case 4u:
          if (!*(_BYTE *)(a1 + 96)) {
            goto LABEL_30;
          }
          CFMutableArrayRef v11 = *(const __CFDictionary **)(a1 + 64);
LABEL_17:
          CFTypeRef v13 = key;
          signed int Value = (__CFDictionary *)CFDictionaryGetValue(v11, key);
          if (!Value || (CFMutableDictionaryRef Mutable = Value, v16 = CFGetTypeID(Value), v16 != CFDictionaryGetTypeID()))
          {
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
            CFDictionarySetValue(v11, v13, Mutable);
            if (Mutable) {
              CFRelease(Mutable);
            }
          }

          CFMutableArrayRef v10 = v30;
          uint64_t v9 = Mutable;
          break;
        case 5u:
        case 8u:
        case 9u:
        case 0xAu:
          id v7 = sub_10001267C("updates");
          int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 138412290;
            CFTypeRef v35 = cf;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Unknown key '%@', ignoring", buf, 0xCu);
          }

          goto LABEL_30;
        case 6u:
          if (!*(_BYTE *)(a1 + 96)) {
            goto LABEL_30;
          }
          uint64_t v9 = *(__CFDictionary **)(a1 + 80);
          CFMutableArrayRef v10 = v31;
          break;
        case 7u:
          if (!cfa) {
            goto LABEL_30;
          }
          CFTypeID v17 = CFGetTypeID(cfa);
          uint64_t v9 = *(__CFDictionary **)(a1 + 72);
          CFMutableArrayRef v10 = cfa;
          break;
        default:
          goto LABEL_30;
      }

      CFDictionarySetValue(v9, v10, a3);
    }
  }

uint64_t sub_1001B639C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_1001B63B4(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFMutableArrayRef v4 = (void *)objc_claimAutoreleasedReturnValue([v3 SOSTransportKeyParameterGetAccount:v3]);
  unsigned int v5 = [v4 isEqual:*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)];

  if (v5
    && ([v3 SOSTransportKeyParameterHandleKeyParameterChanges:v3 data:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) err:0] & 1) == 0)
  {
    CFTypeID v6 = sub_10001267C("SecError");
    id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      uint64_t v9 = 0LL;
      _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Transport failed to handle new key parameters: %@",  (uint8_t *)&v8,  0xCu);
    }
  }
}

void sub_1001B64BC(void *a1, void *a2)
{
  id v3 = a2;
  CFMutableArrayRef v4 = (void *)objc_claimAutoreleasedReturnValue([v3 getAccount]);
  unsigned int v5 = [v4 isEqual:*(void *)(*(void *)(a1[4] + 8) + 40)];

  if (v5)
  {
    CFTypeID v6 = (const __CFDictionary *)[v3 handleRetirementMessages:a1[5] err:a1[6]];
    if (v6)
    {
      id v7 = v6;
      context[0] = _NSConcreteStackBlock;
      context[1] = 3221225472LL;
      uint64_t context[2] = sub_1001B6FDC;
      context[3] = &unk_100293110;
      void context[4] = a1[7];
      CFDictionaryApplyFunction(v6, (CFDictionaryApplierFunction)sub_1001B639C, context);
      CFRelease(v7);
    }

    else
    {
      int v8 = sub_10001267C("SecError");
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        uint64_t v12 = 0LL;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Transport failed to handle retirement messages: %@",  buf,  0xCu);
      }
    }
  }
}

void sub_1001B6604(void *a1, void *a2)
{
  id v3 = a2;
  CFTypeRef cf = 0LL;
  CFTypeRef v24 = 0LL;
  CFMutableArrayRef v4 = (void *)objc_claimAutoreleasedReturnValue([v3 SOSTransportMessageGetAccount]);
  unsigned int v5 = [v4 isEqual:*(void *)(*(void *)(a1[4] + 8) + 40)];

  if (v5)
  {
    CFTypeID v6 = (const __CFDictionary *)[v3 SOSTransportMessageHandlePeerMessageReturnsHandledCopy:v3 peerMessages:a1[5] err:&v24];
    if (v6)
    {
      id v7 = v6;
      signed int Value = (const __CFArray *)CFDictionaryGetValue(v6, [v3 SOSTransportMessageGetCircleName]);
      if (Value)
      {
        uint64_t v9 = Value;
        CFTypeID v10 = CFGetTypeID(Value);
        if (v10 == CFArrayGetTypeID())
        {
          context[0] = _NSConcreteStackBlock;
          context[1] = 3221225472LL;
          uint64_t context[2] = sub_1001B6F44;
          context[3] = &unk_100293DD0;
          id v11 = v3;
          uint64_t v12 = a1[4];
          id v20 = v11;
          uint64_t v21 = v12;
          uint64_t v22 = a1[6];
          v27.CFIndex length = CFArrayGetCount(v9);
          v27.id location = 0LL;
          CFArrayApplyFunction(v9, v27, (CFArrayApplierFunction)sub_1001B4CD8, context);
        }
      }

      if (([v3 SOSTransportMessageFlushChanges:v3 err:&cf] & 1) == 0)
      {
        CFTypeRef v13 = sub_10001267C("msg");
        id v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          CFTypeRef v26 = cf;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Flush failed: %@", buf, 0xCu);
        }
      }

      CFTypeRef v15 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
        CFRelease(v15);
      }

      CFRelease(v7);
    }

    else
    {
      CFTypeID v16 = sub_10001267C("msg");
      CFTypeID v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFTypeRef v26 = v24;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "No messages handled: %@", buf, 0xCu);
      }
    }

    CFTypeRef v18 = v24;
    if (v24)
    {
      CFTypeRef v24 = 0LL;
      CFRelease(v18);
    }
  }
}

void sub_1001B684C(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFMutableArrayRef v4 = (void *)objc_claimAutoreleasedReturnValue([v3 getAccount]);
  unsigned int v5 = [v4 isEqual:*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)];

  if (v5)
  {
    CFTypeID v6 = (const __CFArray *)[v3 handleCircleMessagesAndReturnHandledCopy:*(void *)(a1 + 40) err:*(void *)(a1 + 48)];
    if (v6)
    {
      id v7 = v6;
      if (CFArrayGetCount(v6))
      {
        v16[0] = _NSConcreteStackBlock;
        v16[1] = 3221225472LL;
        v16[2] = sub_1001B6EF4;
        v16[3] = &unk_100292FB0;
        __int128 v17 = *(_OWORD *)(a1 + 48);
        v24.CFIndex length = CFArrayGetCount(v7);
        v24.id location = 0LL;
        CFArrayApplyFunction(v7, v24, (CFArrayApplierFunction)sub_1001B4CD8, v16);
      }

      else if (CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 40)))
      {
        CFTypeID v10 = sub_10001267C("SecError");
        id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          CFIndex Count = CFArrayGetCount(v7);
          CFIndex v13 = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 40));
          *(_DWORD *)__int128 buf = 134218498;
          CFIndex v19 = Count;
          __int16 v20 = 2048;
          CFIndex v21 = v13;
          __int16 v22 = 2112;
          uint64_t v23 = 0LL;
          _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Transport failed to process all circle messages: (%ld/%ld) %@",  buf,  0x20u);
        }
      }

      else
      {
        id v14 = sub_10001267C("circle");
        CFTypeRef v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Transport handled no circle messages",  buf,  2u);
        }
      }

      CFRelease(v7);
    }

    else
    {
      int v8 = sub_10001267C("SecError");
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFIndex v19 = 0LL;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Transport failed to handle circle messages: %@",  buf,  0xCu);
      }
    }
  }
}

void sub_1001B6A9C(void *a1, void *a2)
{
  id v3 = (void *)objc_claimAutoreleasedReturnValue([a2 getAccount]);
  unsigned int v4 = [v3 isEqual:*(void *)(*(void *)(a1[4] + 8) + 40)];

  if (v4)
  {
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
    context[0] = _NSConcreteStackBlock;
    context[1] = 3221225472LL;
    uint64_t context[2] = sub_1001B6D1C;
    context[3] = &unk_100292DF0;
    CFTypeID v6 = (const __CFDictionary *)a1[5];
    uint64_t v7 = a1[6];
    void context[4] = a1[4];
    void context[5] = v7;
    void context[6] = Mutable;
    CFDictionaryApplyFunction(v6, (CFDictionaryApplierFunction)sub_1001B639C, context);
    if (CFArrayGetCount(Mutable))
    {
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 3221225472LL;
      _DWORD v10[2] = sub_1001B6EAC;
      v10[3] = &unk_100293EA8;
      void v10[4] = a1[7];
      v14.CFIndex length = CFArrayGetCount(Mutable);
      v14.id location = 0LL;
      CFArrayApplyFunction(Mutable, v14, (CFArrayApplierFunction)sub_1001B4CD8, v10);
      if (!Mutable) {
        return;
      }
      goto LABEL_4;
    }

    int v8 = sub_10001267C("SecError");
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      uint64_t v13 = 0LL;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Transport failed to handle ring messages: %@",  buf,  0xCu);
    }

    if (Mutable) {
LABEL_4:
    }
      CFRelease(Mutable);
  }

void sub_1001B6C54(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID()) {
      CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 32), 0LL, @"%@ ", cf);
    }
  }

void sub_1001B6CB8(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID()) {
      CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 32), 0LL, @"%@ ", cf);
    }
  }

void sub_1001B6D1C(uint64_t a1, const void *a2, const __CFData *cf)
{
  if (!cf || (unsigned int v5 = cf, v6 = CFGetTypeID(cf), v6 != CFDataGetTypeID())) {
    unsigned int v5 = 0LL;
  }
  uint64_t v7 = sub_1001A902C(*(CFTypeRef **)(a1 + 40), v5);
  uint64_t v8 = *(void *)(a1 + 40);
  id v9 = *(id *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  CFTypeID v10 = v9;
  if (v9)
  {
    if ([v9 accountIsChanging])
    {
      id v11 = sub_10001267C("circleOps");
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)CFTypeID v16 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "SOSAccountUpdateRingFromRemote called before signing in to new account",  v16,  2u);
      }

LABEL_12:
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), a2);
LABEL_13:
      if (!v7) {
        return;
      }
      goto LABEL_14;
    }

    id v9 = v10;
  }

  if (sub_100199E38(v9, v8))
  {
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v10 trust]);
    CFRange v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "circle_transport"));
    unsigned int v15 = objc_msgSend( v13,  "handleUpdateRing:prospectiveRing:transport:userPublicKey:writeUpdate:err:",  v10,  v7,  v14,  objc_msgSend(v10, "accountKey"),  0,  v8);

    if (!v15) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }

  if (v7) {
LABEL_14:
  }
    CFRelease(v7);
}

void sub_1001B6EAC(uint64_t a1, uint64_t a2)
{
  id v3 = (const void *)SOSRingKeyCreateWithRingName(a2);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v3);
  if (v3) {
    CFRelease(v3);
  }
}

void sub_1001B6EF4(uint64_t a1, uint64_t a2)
{
  id v3 = (const void *)SOSCircleKeyCreateWithName(a2, *(void *)(a1 + 32));
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), v3);
  if (v3) {
    CFRelease(v3);
  }
}

void sub_1001B6F44(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      uint64_t v5 = *(void *)(a1 + 32);
      CFTypeID v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) peerID]);
      uint64_t v7 = (const void *)SOSMessageKeyCreateFromPeerToTransport(v5, v6, cf);

      if (v7)
      {
        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), v7);
        CFRelease(v7);
      }
    }
  }

void sub_1001B6FDC(uint64_t a1, uint64_t a2, CFArrayRef theArray)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_1001B7058;
  void v5[3] = &unk_100292FB0;
  uint64_t v4 = *(void *)(a1 + 32);
  void v5[4] = a2;
  void v5[5] = v4;
  v6.CFIndex length = CFArrayGetCount(theArray);
  v6.id location = 0LL;
  CFArrayApplyFunction(theArray, v6, (CFArrayApplierFunction)sub_1001B4CD8, v5);
}

void sub_1001B7058(uint64_t a1)
{
  uint64_t v2 = (const void *)SOSRetirementKeyCreateWithCircleNameAndPeer(*(void *)(a1 + 32));
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), v2);
  if (v2) {
    CFRelease(v2);
  }
}

uint64_t sub_1001B70A0(const void *a1)
{
  if (CFEqual(a1, @"iCloudIdentity-tomb")) {
    return 1LL;
  }
  if (CFEqual(a1, @"PCS-MasterKey-tomb")) {
    return 1LL;
  }
  uint64_t result = CFEqual(a1, @"RecoveryRing");
  if ((_DWORD)result) {
    return 1LL;
  }
  return result;
}

uint64_t sub_1001B70F8()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1001B7174;
  block[3] = &unk_1002935A8;
  void block[4] = &qword_1002DEE68;
  if (qword_1002DEE60 != -1) {
    dispatch_once(&qword_1002DEE60, block);
  }
  return qword_1002DEE68;
}

uint64_t sub_1001B7174(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass(&unk_100292E10);
  **(void **)(a1 + 32) = result;
  return result;
}

void sub_1001B71A4(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  if (v2)
  {
    a1[2] = 0LL;
    CFRelease(v2);
  }

  id v3 = (const void *)a1[3];
  if (v3)
  {
    a1[3] = 0LL;
    CFRelease(v3);
  }

  uint64_t v4 = (const void *)a1[5];
  if (v4)
  {
    a1[5] = 0LL;
    CFRelease(v4);
  }

__CFString *sub_1001B71F8(void *a1)
{
  uint64_t v2 = (const void *)SOSGenerationCountCopyDescription(a1[3]);
  id v3 = (const void *)SOSCopyIDOfDataBufferWithLength(a1[5], 8LL, 0LL);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
  CFStringAppendFormat( Mutable,  0LL,  @"<SOSRecoveryKeyBag@%p DSID: %@ version: %d  gencount: %@  RecoveryKeyID: %@ ",  a1,  a1[2],  a1[4],  v2,  v3);
  CFStringAppend(Mutable, @">");
  if (v2) {
    CFRelease(v2);
  }
  if (v3) {
    CFRelease(v3);
  }
  return Mutable;
}

__CFString *sub_1001B72AC(void *a1)
{
  return sub_1001B71F8(a1);
}

BOOL sub_1001B72D0(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[5];
  BOOL v5 = v4 != 0;
  if (!v4) {
    SOSCreateError(1025LL, @"RecoveryKeyBag has no public key", 0LL, a2);
  }
  if (!a1[2])
  {
    SOSCreateError(1025LL, @"RecoveryKeyBag has no DSID", 0LL, a2);
    BOOL v5 = 0LL;
  }

  if (!a1[3])
  {
    SOSCreateError(1025LL, @"RecoveryKeyBag has no generation", 0LL, a2);
    return 0LL;
  }

  return v5;
}

uint64_t sub_1001B736C(const __CFAllocator *a1, void *a2, const __CFData *a3, uint64_t *a4)
{
  BOOL v5 = a2;
  if (!a2)
  {
    __int16 v20 = @"Null Account Object";
LABEL_22:
    SOSCreateError(1025LL, v20, 0LL, a4);
LABEL_24:
    uint64_t v14 = 0LL;
    goto LABEL_12;
  }

  uint64_t v8 = (__CFString *)sub_100190528(a2);
  if (!v8)
  {
    id v9 = (void *)objc_claimAutoreleasedReturnValue(+[ACAccountStore defaultStore](&OBJC_CLASS___ACAccountStore, "defaultStore"));
    CFTypeID v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "aa_primaryAppleAccount"));
    uint64_t v8 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "aa_personID"));

    sub_1001A93D0(v5, kSOSDSIDKey, (uint64_t)v8, 0LL);
    if (!v8)
    {
      SOSCreateError(1025LL, @"Couldn't get dsid for recovery keybag components", 0LL, a4);
      BOOL v5 = 0LL;
      goto LABEL_24;
    }
  }

  uint64_t v11 = SOSGenerationCreate();
  BOOL v5 = (void *)v11;
  if (!a3 || !v11)
  {
    __int16 v20 = @"Couldn't get recovery keybag components";
    goto LABEL_22;
  }

  uint64_t v12 = sub_1001B70F8();
  uint64_t Instance = _CFRuntimeCreateInstance(a1, v12, 32LL, 0LL);
  uint64_t v14 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 32) = 1LL;
    *(void *)(Instance + 16) = CFStringCreateCopy(a1, v8);
    if (*(void **)(v14 + 24) != v5)
    {
      CFRetain(v5);
      unsigned int v15 = *(const void **)(v14 + 24);
      if (v15) {
        CFRelease(v15);
      }
      *(void *)(v14 + 24) = v5;
    }

    *(void *)(v14 + 40) = CFDataCreateCopy(a1, a3);
  }

  else
  {
    SOSCreateError(1025LL, @"Couldn't get memory for recoveryKeyBag", 0LL, a4);
  }

__CFData *sub_1001B75A8(uint64_t a1, CFTypeRef *a2)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = sub_10001A4B8(*(const __CFString **)(a1 + 16));
  uint64_t v5 = SOSGenCountGetDEREncodedSize(*(void *)(a1 + 24), 0LL) + v4;
  uint64_t v6 = v5 + ccder_sizeof_uint64(*(void *)(a1 + 32));
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 40));
  uint64_t v8 = ccder_sizeof_raw_octet_string(Length);
  uint64_t v9 = ccder_sizeof(0x2000000000000010LL, v6 + v8);
  if (!v9) {
    return 0LL;
  }
  CFIndex v10 = v9;
  CFMutableDictionaryRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0LL);
  CFDataSetLength(Mutable, v10);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  CFIndex v13 = CFDataGetLength(Mutable);
  if (MutableBytePtr)
  {
    CFIndex v14 = v13;
    uint64_t v15 = (uint64_t)&MutableBytePtr[v14];
    CFTypeID v16 = *(const __CFString **)(a1 + 16);
    uint64_t v17 = *(void *)(a1 + 24);
    uint64_t v18 = *(void *)(a1 + 32);
    sub_10001A7CC(*(const __CFData **)(a1 + 40), a2, (uint64_t)MutableBytePtr, v15);
    uint64_t v19 = ccder_encode_uint64(v18);
    uint64_t v20 = SOSGenCountEncodeToDER(v17, a2, MutableBytePtr, v19);
    uint64_t v22 = sub_10001A534(v16, a2, MutableBytePtr, v20, v21);
    if ((UInt8 *)ccder_encode_constructed_tl(0x2000000000000010LL, v15, MutableBytePtr, v22) != MutableBytePtr)
    {
LABEL_8:
      if (Mutable)
      {
        CFRelease(Mutable);
        return 0LL;
      }
    }
  }

  return Mutable;
}

uint64_t sub_1001B7724(const __CFAllocator *a1, CFDataRef theData, CFTypeRef *a3)
{
  BytePtr = CFDataGetBytePtr(theData);
  uint64_t v7 = (uint64_t)&BytePtr[CFDataGetLength(theData)];
  uint64_t v15 = BytePtr;
  if (!BytePtr) {
    goto LABEL_8;
  }
  uint64_t v8 = sub_1001B70F8();
  uint64_t Instance = _CFRuntimeCreateInstance(a1, v8, 32LL, 0LL);
  if (!sub_1000195D0(Instance, a3, @"Recovery bag allocation failed")
    || (v14 = 0LL, v10 = (const UInt8 *)ccder_decode_sequence_tl(&v14, BytePtr, v7), uint64_t v15 = v10, v14 != v7))
  {
    if (!Instance)
    {
LABEL_9:
      uint64_t v12 = 0LL;
      goto LABEL_10;
    }

    goto LABEL_7;
  }

  uint64_t v15 = sub_10001A3C4(kCFAllocatorDefault, (CFStringRef *)(Instance + 16), a3, (uint64_t)v10, v7);
  *(void *)(Instance + 24) = SOSGenCountCreateFromDER(kCFAllocatorDefault, a3, &v15, v14);
  uint64_t v15 = (const UInt8 *)ccder_decode_uint64(Instance + 32, v15, v14);
  uint64_t v11 = sub_10001A6E4(a1, (CFDataRef *)(Instance + 40), a3, (uint64_t)v15, v14);
  uint64_t v15 = v11;
  sub_100019570(v11 == (const UInt8 *)v7, a3, @"Extra space in sequence");
  if (v11 != (const UInt8 *)v7)
  {
LABEL_7:
    CFRelease((CFTypeRef)Instance);
LABEL_8:
    uint64_t Instance = 0LL;
    goto LABEL_9;
  }

  uint64_t v12 = v15;
LABEL_10:
  sub_100019570(v12 == (const UInt8 *)v7, a3, @"Didn't consume all data supplied");
  if (v12 != (const UInt8 *)v7 && Instance)
  {
    CFRelease((CFTypeRef)Instance);
    return 0LL;
  }

  return Instance;
}

LABEL_119:
      *(void *)CFIndex v153 = 0LL;
      uint64_t v154 = v153;
      __int128 v155 = 0x2020000000LL;
      uint64_t v156 = 0;
      *(void *)__int128 buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3221225472LL;
      *(void *)&uint8_t buf[16] = sub_1001BAB08;
      uint64_t v158 = (const char *)&unk_100292F90;
      __int128 v78 = cf;
      *(void *)&uint64_t v159 = v153;
      *((void *)&v159 + 1) = v144;
      SOSCircleForEachPeer(cf, buf);
      id v147 = _NSConcreteStackBlock;
      id v148 = 3221225472LL;
      id v149 = (uint64_t)sub_1001BAB88;
      CFIndex v150 = &unk_100292F90;
      __int128 v151 = v153;
      __int128 v152 = cf;
      SOSCircleForEachPeer(v144, &v147);
      __int128 v79 = v154[24];
      _Block_object_dispose(v153, 8);
      if (v79)
      {
        id v80 = sub_10001267C("circleOps");
        id v81 = (os_log_s *)objc_claimAutoreleasedReturnValue(v80);
        if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v81,  OS_LOG_TYPE_DEFAULT,  "Sending kSOSCCCircleOctagonKeysChangedNotification",  buf,  2u);
        }

        notify_post(kSOSCCCircleOctagonKeysChangedNotification);
        __int128 v78 = cf;
      }

      if (!cf2)
      {
        CFTypeRef cf2 = 0LL;
        id v91 = 1;
        goto LABEL_183;
      }

      if (SOSCircleHasActivePeer(v78, cf2, 0LL) && (SOSCircleHasPeer(v144, cf2, 0LL) & 1) == 0)
      {
        if (!-[SOSAccountTrustClassic hasLeft](self, "hasLeft")) {
          -[SOSAccountTrust setDepartureCode:](self, "setDepartureCode:", 3LL);
        }
        CFMutableArrayRef v82 = sub_10001267C("circleOps");
        CFMutableArrayRef v83 = (os_log_s *)objc_claimAutoreleasedReturnValue(v82);
        if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
        {
          CFMutableArrayRef v84 = -[SOSAccountTrust departureCode](self, "departureCode");
          *(_DWORD *)__int128 buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v84;
          _os_log_impl( (void *)&_mh_execute_header,  v83,  OS_LOG_TYPE_DEFAULT,  "Member of old circle but not of new circle (%d)",  buf,  8u);
        }

        SOSCircleLogState("circleOps-Old", cf, [v143 accountKey], v135);
        SOSCircleLogState("circleOps-New", v144, [v143 accountKey], v135);
      }

      if (SOSCircleHasActivePeer(cf, cf2, 0LL)
        && (SOSCircleCountPeers(cf) != 1 || (SOSCircleHasPeer(cf, cf2, 0LL) & 1) == 0)
        && (SOSCircleHasPeer(v144, cf2, 0LL) & 1) == 0
        && (SOSCircleHasApplicant(v144, cf2, 0LL) & 1) == 0)
      {
        __int16 v97 = sub_10001267C("circle");
        uint64_t v98 = (os_log_s *)objc_claimAutoreleasedReturnValue(v97);
        if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v99 = SOSPeerInfoGetPeerID(cf2);
          uint64_t v100 = SOSCircleGetName(cf);
          *(_DWORD *)__int128 buf = 138412546;
          *(void *)&uint8_t buf[4] = v99;
          *(_WORD *)&_BYTE buf[12] = 2112;
          *(void *)&buf[14] = v100;
          _os_log_impl( (void *)&_mh_execute_header,  v98,  OS_LOG_TYPE_DEFAULT,  "Purging my peer (ID: %@) for circle '%@'!!!",  buf,  0x16u);
        }

        -[SOSAccountTrustClassic purgeIdentity](self, "purgeIdentity");
        goto LABEL_157;
      }

      if (SOSCircleHasRejectedApplicant(v144, cf2, 0LL))
      {
        uint64_t v85 = (const void *)SOSCircleCopyRejectedApplicant(v144, cf2, 0LL);
        id v86 = v85;
        if (v85
          && CFEqual(v85, cf2)
          && SOSPeerInfoApplicationVerify(cf2, [v143 accountKey], 0))
        {
          CFMutableArrayRef v87 = sub_10001267C("circle");
          CFMutableArrayRef v88 = (os_log_s *)objc_claimAutoreleasedReturnValue(v87);
          if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
          {
            CFMutableArrayRef v89 = SOSPeerInfoGetPeerID(cf2);
            uint64_t v90 = SOSCircleGetName(cf);
            *(_DWORD *)__int128 buf = 138412546;
            *(void *)&uint8_t buf[4] = v89;
            *(_WORD *)&_BYTE buf[12] = 2112;
            *(void *)&buf[14] = v90;
            _os_log_impl( (void *)&_mh_execute_header,  v88,  OS_LOG_TYPE_DEFAULT,  "Rejected, Purging my applicant peer (ID: %@) for circle '%@'",  buf,  0x16u);
          }

          debugDumpCircle(@"oldCircle", cf);
          debugDumpCircle(@"newCircle", v144);
          -[SOSAccountTrustClassic purgeIdentity](self, "purgeIdentity");
          CFRelease(v86);
LABEL_157:
          CFTypeRef cf2 = 0LL;
          id v91 = 1;
          goto LABEL_182;
        }

        CFMutableArrayRef v92 = sub_10001267C("circle");
        CFMutableArrayRef v93 = (os_log_s *)objc_claimAutoreleasedReturnValue(v92);
        if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
        {
          CFMutableArrayRef v94 = SOSPeerInfoGetPeerID(cf2);
          unint64_t v95 = SOSCircleGetName(cf);
          *(_DWORD *)__int128 buf = 138412546;
          *(void *)&uint8_t buf[4] = v94;
          *(_WORD *)&_BYTE buf[12] = 2112;
          *(void *)&buf[14] = v95;
          _os_log_impl( (void *)&_mh_execute_header,  v93,  OS_LOG_TYPE_DEFAULT,  "Rejected, Reapplying (ID: %@) for circle '%@'",  buf,  0x16u);
        }

        debugDumpCircle(@"oldCircle", cf);
        debugDumpCircle(@"newCircle", v144);
        SOSCircleRequestReadmission(v144, [v143 accountKey], cf2, 0);
        if (v86) {
          CFRelease(v86);
        }
        uint64_t v7 = 1;
      }

      uint64_t v96 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTrustClassic iCloudCheckEventHandle:](self, "iCloudCheckEventHandle:", v143));
      if ((v7 & 1) != 0)
      {
        uint64_t v7 = 1;
        goto LABEL_179;
      }

      uint64_t v7 = -[SOSAccountTrustClassic fixICloudIdentities:circle:](self, "fixICloudIdentities:circle:", v143, v144);
      id v105 = sub_10001267C("circleOps");
      CFRange v106 = (os_log_s *)objc_claimAutoreleasedReturnValue(v105);
      CFRange v107 = os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT);
      if (v7)
      {
        if (!v107) {
          goto LABEL_178;
        }
        *(_WORD *)__int128 buf = 0;
        CFTypeRef v108 = "Fixed iCloud Identity in circle";
      }

      else
      {
        if (!v107) {
          goto LABEL_178;
        }
        *(_WORD *)__int128 buf = 0;
        CFTypeRef v108 = "Failed to fix broken icloud identity";
      }

      _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, v108, buf, 2u);
LABEL_178:

LABEL_179:
      [v96 followup];
LABEL_180:

LABEL_181:
      id v91 = 0;
LABEL_182:
      __int128 v78 = cf;
LABEL_183:
      if (v78) {
        CFRetain(cf);
      }
      objc_msgSend(v143, "setPreviousAccountKey:", objc_msgSend(v143, "accountKey"));
      CFTypeRef v109 = sub_10001267C("signing");
      CFDataRef v110 = (os_log_s *)objc_claimAutoreleasedReturnValue(v109);
      if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        *(void *)&uint8_t buf[4] = v137;
        _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "%@, Accepting new circle", buf, 0xCu);
      }

      -[SOSAccountTrust setTrustedCircle:](self, "setTrustedCircle:", v144);
      [v143 sosEvaluateIfNeeded];
      if ((v91 & 1) == 0)
      {
        if ([v143 accountKeyIsTrusted]
          && SOSCircleHasApplicant(cf, cf2, 0LL)
          && (int)SOSCircleCountPeers(v144) >= 1
          && (SOSCircleHasPeer(v144, cf2, 0LL) & 1) == 0
          && (SOSCircleHasApplicant(v144, cf2, 0LL) & 1) == 0)
        {
          id v111 = sub_10001267C("signing");
          id v112 = (os_log_s *)objc_claimAutoreleasedReturnValue(v111);
          if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v112,  OS_LOG_TYPE_DEFAULT,  "requesting readmission to new circle",  buf,  2u);
          }

          v7 |= SOSCircleRequestReadmission(v144, [v143 accountKey], cf2, 0);
        }

        if (SOSCircleHasActivePeer(cf, cf2, 0LL))
        {
          uint64_t v113 = (void *)objc_claimAutoreleasedReturnValue([v143 trust]);
          [v113 cleanupRetirementTickets:v143 circle:cf time:86400 err:0];
        }
      }

      __int128 v114 = v143;
      objc_msgSend(v114, "setCircle_rings_retirements_need_attention:", 1);
      __int128 v115 = (const __CFSet *)SOSCircleCopyPeers(cf, kCFAllocatorDefault);
      uint64_t v116 = (const __CFSet *)SOSCircleCopyPeers(v144, kCFAllocatorDefault);
      id v117 = (const void *)SOSCircleCopyApplicants(cf, kCFAllocatorDefault);
      uint64_t v118 = (__OpaqueSOSCircle *)SOSCircleCopyApplicants(v144, kCFAllocatorDefault);
      __int128 v119 = [v114 peerInfo];
      if (v119 && CFSetContainsValue(v116, v119)) {
        sub_1001A93D0(v114, (uint64_t)@"EscrowRecord", (uint64_t)kCFNull, 0LL);
      }
      *(void *)__int128 buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3221225472LL;
      *(void *)&uint8_t buf[16] = sub_1001A1260;
      uint64_t v158 = (const char *)&unk_1002921E0;
      *((void *)&v159 + 1) = v117;
      CFIndex v160 = v118;
      __int128 v120 = v114;
      *(void *)&uint64_t v159 = v120;
      uint64_t v161 = v144;
      sub_1001A12F8(v115, v116, buf);
      if (v117) {
        CFRelease(v117);
      }
      if (v118) {
        CFRelease(v118);
      }
      if (v115) {
        CFRelease(v115);
      }
      if (v116) {
        CFRelease(v116);
      }

      if (cf) {
        CFRelease(cf);
      }
      uint64_t v121 = v144;
      if (!v7) {
        uint64_t v121 = v136;
      }
      CFTypeRef cf = v121;
      uint64_t v122 = sub_10001267C("circleop");
      __int128 v123 = (os_log_s *)objc_claimAutoreleasedReturnValue(v122);
      if (os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v123,  OS_LOG_TYPE_DEFAULT,  "Setting key_interests_need_updating to true in handleUpdateCircle",  buf,  2u);
      }

      objc_msgSend(v120, "setKey_interests_need_updating:", 1);
LABEL_216:
      if (cf)
      {
        __int128 v124 = sub_10001267C("signing");
        id v125 = (os_log_s *)objc_claimAutoreleasedReturnValue(v124);
        if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 136315138;
          *(void *)&uint8_t buf[4] = v146;
          _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_DEFAULT, "Pushing:[%s]", buf, 0xCu);
        }

        unint64_t v126 = (const void *)SOSCircleCopyEncodedData(cf, kCFAllocatorDefault, a6);
        if (v126)
        {
          objc_msgSend(v143, "setCircle_rings_retirements_need_attention:", 1);
          char v127 = [v11 postCircle:SOSCircleGetName(cf) circleData:v126 err:a6];
          CFRelease(v126);
          LOBYTE(v1_Block_object_dispose(va, 8) = v18 & v127;
        }

        else
        {
          LOBYTE(v1_Block_object_dispose(va, 8) = 0;
        }
      }

LABEL_222:
      CFRelease(v144);
      if (v139) {
        CFRelease(v139);
      }
      char v128 = v18 ^ 1;
      if (!a6) {
        char v128 = 1;
      }
      if ((v128 & 1) == 0)
      {
        id v129 = *a6;
        if (*a6)
        {
          *a6 = 0LL;
          CFRelease(v129);
        }
      }

      [v143 sosEvaluateIfNeeded];
LABEL_15:

      return v18;
    case 3:
      if (v141 == TypeID && cf2 && SOSCircleHasActivePeer(cf, cf2, 0LL))
      {
        __int128 v69 = sub_10001267C("signing");
        __int128 v70 = (os_log_s *)objc_claimAutoreleasedReturnValue(v69);
        if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          *(void *)&uint8_t buf[4] = v137;
          _os_log_impl( (void *)&_mh_execute_header,  v70,  OS_LOG_TYPE_DEFAULT,  "%@, Rejecting new circle, re-publishing old circle",  buf,  0xCu);
        }

        -[SOSAccountTrust setTrustedCircle:](self, "setTrustedCircle:", cf);
        [v143 sosEvaluateIfNeeded];
        goto LABEL_216;
      }

      __int128 v71 = sub_10001267C("canary");
      __int128 v72 = (os_log_s *)objc_claimAutoreleasedReturnValue(v71);
      if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        *(void *)&uint8_t buf[4] = v137;
        _os_log_impl( (void *)&_mh_execute_header,  v72,  OS_LOG_TYPE_DEFAULT,  "%@, Rejecting: new circle Have no old circle - would reset",  buf,  0xCu);
      }

      goto LABEL_222;
    default:
      goto LABEL_222;
  }

void sub_1001B9890( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
}

void sub_1001BA534( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

uint64_t sub_1001BA570(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1001BA580(uint64_t a1)
{
}

BOOL sub_1001BA588(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 40LL);
  id v5 = [*(id *)(a1 + 32) fullPeerInfo];
  uint64_t v6 = *(void *)(a1 + 64);
  id v7 = sub_10018DFDC(v4, (uint64_t)@"EscrowRecord");
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = SOSFullPeerInfoReplaceEscrowRecords(v5, v7, v6);
  char v8 = SOSCircleRequestAdmission( a2,  *(void *)(a1 + 72),  [*(id *)(a1 + 32) fullPeerInfo],  *(void *)(a1 + 64));
  uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8LL);
  if (*(_BYTE *)(v9 + 24)) {
    char v10 = v8;
  }
  else {
    char v10 = 0;
  }
  *(_BYTE *)(v9 + 24) = v10;
  [*(id *)(a1 + 32) setDepartureCode:1];
  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL)) {
    return 0LL;
  }
  uint64_t v11 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL);
  if (!v11) {
    return 1LL;
  }
  CFTypeRef cf = 0LL;
  uint64_t PeerInfo = SOSFullPeerInfoGetPeerInfo(v11);
  uint64_t PeerID = SOSPeerInfoGetPeerID(PeerInfo);
  if (PeerID)
  {
    if (SOSCircleHasActivePeerWithID(a2, PeerID, &cf)) {
      SOSCircleAcceptRequest( a2,  *(void *)(a1 + 72),  *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24),  [*(id *)(a1 + 32) peerInfo],  &cf);
    }
    if (cf)
    {
      uint64_t v14 = sub_10001267C("SecError");
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFTypeRef v20 = cf;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Failed to join with cloud identity: %@",  buf,  0xCu);
      }

      CFTypeRef v16 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
        CFRelease(v16);
      }
    }
  }

  return *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) != 0;
}

uint64_t sub_1001BA784(uint64_t a1, uint64_t a2)
{
  CFTypeRef cf = 0LL;
  if (SOSCircleResetToOffering( a2,  *(void *)(a1 + 48),  [*(id *)(a1 + 32) fullPeerInfo],  &cf)
    && ([*(id *)(a1 + 32) setDepartureCode:1],
        objc_msgSend( *(id *)(a1 + 32),  "addEscrowToPeerInfo:err:",  objc_msgSend(*(id *)(a1 + 32), "fullPeerInfo"),  *(void *)(a1 + 56)))
    && [*(id *)(a1 + 32) addiCloudIdentity:a2 key:*(void *)(a1 + 48) err:*(void *)(a1 + 56)])
  {
    sub_100197744(*(void **)(a1 + 40), 0LL);
    uint64_t v4 = 1LL;
    [*(id *)(a1 + 40) setNotifyBackupOnExit:1];
  }

  else
  {
    char v8 = sub_10001267C("SecError");
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412546;
      uint64_t v12 = a2;
      __int16 v13 = 2112;
      CFTypeRef v14 = cf;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "error resetting circle (%@) to offering: %@",  buf,  0x16u);
    }

    uint64_t v4 = 0LL;
  }

  CFTypeRef v5 = cf;
  if (cf)
  {
    uint64_t v6 = *(CFTypeRef **)(a1 + 56);
    if (v6 && !*v6)
    {
      *uint64_t v6 = cf;
    }

    else
    {
      CFTypeRef cf = 0LL;
      CFRelease(v5);
    }
  }

  return v4;
}

BOOL sub_1001BA900(uint64_t a1, uint64_t a2)
{
  return sub_100191060(*(void **)(a1 + 32), a2, *(CFTypeRef **)(a1 + 40));
}

BOOL sub_1001BA90C(uint64_t a1, uint64_t a2)
{
  return sub_100191060(*(void **)(a1 + 32), a2, *(CFTypeRef **)(a1 + 40));
}

uint64_t sub_1001BA918(uint64_t a1, uint64_t a2)
{
  uint64_t result = SOSPeerInfoGetPeerID(a2);
  if (result)
  {
    uint64_t result = (uint64_t)[*(id *)(a1 + 32) isEqualToString:result];
    if ((result & 1) == 0) {
      return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16LL))();
    }
  }

  return result;
}

uint64_t sub_1001BA96C(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) peerInfo];
  int HasPeer = SOSCircleHasPeer(a2, v4, 0LL);
  uint64_t updated = SOSCircleUpdatePeerInfo(a2, v4);
  if (HasPeer)
  {
    char v7 = SOSCircleVerify(a2, [*(id *)(a1 + 32) accountKey], 0);
    char v8 = *(void **)(a1 + 40);
    if ((v7 & 1) != 0)
    {
      uint64_t updated = updated | [v8 fixICloudIdentities:*(void *)(a1 + 32) circle:a2];
    }

    else
    {
      unsigned int v9 = [v8 upgradeiCloudIdentity:a2 privKey:*(void *)(a1 + 48)];
      objc_msgSend( *(id *)(a1 + 40),  "removeInvalidApplications:userPublic:",  a2,  objc_msgSend(*(id *)(a1 + 32), "accountKey"));
      uint64_t updated = updated | v9 | SOSCircleGenerationSign( a2,  *(void *)(a1 + 48),  [*(id *)(a1 + 40) fullPeerInfo],  0);
      [*(id *)(a1 + 40) setDepartureCode:1];
    }
  }

  char v10 = sub_10001267C("updatingGenSignature");
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v14[0] = 67109120;
    v14[1] = updated;
    _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "we changed the circle? %{BOOL}d",  (uint8_t *)v14,  8u);
  }

  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) iCloudCheckEventHandle:*(void *)(a1 + 32)]);
  [v12 followup];

  return updated;
}

void sub_1001BAB08(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t PeerID = SOSPeerInfoGetPeerID(a2);
  uint64_t v6 = (const void *)SOSCircleCopyPeerWithID(v4, PeerID, 0LL);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) |= sub_1001BAC04(a2, (uint64_t)v6);
  if (v6) {
    CFRelease(v6);
  }
}

void sub_1001BAB88(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t PeerID = SOSPeerInfoGetPeerID(a2);
  uint64_t v6 = (const void *)SOSCircleCopyPeerWithID(v4, PeerID, 0LL);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) |= sub_1001BAC04((uint64_t)v6, a2);
  if (v6) {
    CFRelease(v6);
  }
}

BOOL sub_1001BAC04(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return a2 != 0;
  }
  CFTypeRef cf = 0LL;
  uint64_t v4 = (const void *)SOSPeerInfoCopyOctagonSigningPublicKey(a1, &cf);
  CFTypeRef v26 = 0LL;
  CFTypeRef v5 = (const void *)SOSPeerInfoCopyOctagonEncryptionPublicKey(a1, &v26);
  CFTypeRef v25 = 0LL;
  if (a2)
  {
    uint64_t v6 = (const void *)SOSPeerInfoCopyOctagonSigningPublicKey(a2, &v25);
    CFTypeRef v24 = 0LL;
    char v7 = (const void *)SOSPeerInfoCopyOctagonEncryptionPublicKey(a2, &v24);
  }

  else
  {
    uint64_t v6 = 0LL;
    char v7 = 0LL;
    CFTypeRef v24 = 0LL;
  }

  if (cf)
  {
    unsigned int v9 = sub_10001267C("SecError");
    char v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412546;
      uint64_t v29 = a1;
      __int16 v30 = 2112;
      CFTypeRef v31 = cf;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "circleOps: Cannot fetch signing key for old %@: %@",  buf,  0x16u);
    }
  }

  if (v26)
  {
    uint64_t v11 = sub_10001267C("SecError");
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412546;
      uint64_t v29 = a1;
      __int16 v30 = 2112;
      CFTypeRef v31 = v26;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "circleOps: Cannot fetch encryption key for old %@: %@",  buf,  0x16u);
    }
  }

  if (a2 && v25)
  {
    __int16 v13 = sub_10001267C("SecError");
    CFTypeRef v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412546;
      uint64_t v29 = a2;
      __int16 v30 = 2112;
      CFTypeRef v31 = v25;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "circleOps: Cannot fetch signing key for new %@: %@",  buf,  0x16u);
    }
  }

  if (a2 && v24)
  {
    uint64_t v15 = sub_10001267C("SecError");
    CFTypeRef v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412546;
      uint64_t v29 = a2;
      __int16 v30 = 2112;
      CFTypeRef v31 = v24;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "circleOps: Cannot fetch encryption key for new %@: %@",  buf,  0x16u);
    }
  }

  BOOL v17 = sub_1001BAF44((uint64_t)v4, (uint64_t)v6);
  BOOL v18 = sub_1001BAF44((uint64_t)v5, (uint64_t)v7);
  CFTypeRef v19 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
    CFRelease(v19);
  }

  if (v4) {
    CFRelease(v4);
  }
  CFTypeRef v20 = v26;
  if (v26)
  {
    CFTypeRef v26 = 0LL;
    CFRelease(v20);
  }

  if (v5) {
    CFRelease(v5);
  }
  CFTypeRef v21 = v25;
  if (v25)
  {
    CFTypeRef v25 = 0LL;
    CFRelease(v21);
  }

  if (v6) {
    CFRelease(v6);
  }
  CFTypeRef v22 = v24;
  if (v24)
  {
    CFTypeRef v24 = 0LL;
    CFRelease(v22);
  }

  BOOL v8 = !v17 || !v18;
  if (v7) {
    CFRelease(v7);
  }
  return v8;
}

BOOL sub_1001BAF44(uint64_t a1, uint64_t a2)
{
  if (!a1 || !a2) {
    return (a1 | a2) == 0;
  }
  id v3 = (void *)SecKeyCopySubjectPublicKeyInfo(a1);
  uint64_t v4 = (void *)SecKeyCopySubjectPublicKeyInfo(a2);
  id v5 = [v3 isEqual:v4];

  return (BOOL)v5;
}

void sub_1001BAFB0(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  id v5 = [v4 peerInfo];
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v4 trust]);

  id v7 = [v6 trustedCircle];
  if (v7 && v5)
  {
    id v8 = v7;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472LL;
    void v9[2] = sub_1001BB078;
    v9[3] = &unk_100292F40;
    uint64_t PeerID = SOSPeerInfoGetPeerID(v5);
    id v10 = v3;
    SOSCircleForEachPeer(v8, v9);
  }
}

uint64_t sub_1001BB078(uint64_t a1, uint64_t a2)
{
  uint64_t result = SOSPeerInfoGetPeerID(a2);
  if (result)
  {
    uint64_t result = CFEqual((CFTypeRef)result, *(CFTypeRef *)(a1 + 40));
    if (!(_DWORD)result) {
      return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
    }
  }

  return result;
}

void sub_1001BBD68(uint64_t a1)
{
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(-2LL, 0LL);
  id v3 = (id)objc_claimAutoreleasedReturnValue(global_queue);
  SOSCloudKeychainPutObjectsInCloud(a1, v3, &stru_100292FF0);
}

void sub_1001BBDB8(id a1, __CFDictionary *a2, __CFError *a3)
{
  if (a3)
  {
    id v4 = sub_10001267C("SecError");
    id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 138412290;
      id v7 = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Error putting: %@", (uint8_t *)&v6, 0xCu);
    }
  }

void sub_1001BBE64(uint64_t a1, uint64_t a2)
{
  id v3 = (const void *)SOSRingKeyCreateWithRingName(a2);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v3);
  if (v3) {
    CFRelease(v3);
  }
}

void sub_1001BBEAC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  SOSPeerInfoGetPeerID(a2);
  id v4 = (const void *)SOSRetirementKeyCreateWithCircleNameAndPeer(v3);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), v4);
  if (v4) {
    CFRelease(v4);
  }
}

void sub_1001BBF04(uint64_t a1, CFTypeRef cf, const void *a3)
{
  if (!cf
    || (CFTypeID v6 = CFGetTypeID(cf), TypeID = CFStringGetTypeID(), !a3)
    || v6 != TypeID
    || (CFTypeID v8 = CFGetTypeID(a3), v8 != CFDataGetTypeID()))
  {
    unsigned int v9 = sub_10001267C("SecError");
    id v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Error, Key-Value for CircleMessage was not CFString/CFData",  buf,  2u);
    }
  }

  id v11 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) account]);
  uint64_t v12 = v11;
  CFErrorRef err = 0LL;
  if (v11 && [v11 accountIsChanging])
  {
    __int16 v13 = sub_10001267C("circleOps");
    CFTypeRef v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "SOSAccountHandleCircleMessage called before signing in to new account",  buf,  2u);
    }

LABEL_48:
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), cf);
    return;
  }

  if (!a3) {
    goto LABEL_17;
  }
  CFTypeID v15 = CFGetTypeID(a3);
  if (v15 != CFDataGetTypeID())
  {
    CFTypeID v16 = CFGetTypeID(a3);
    if (v16 != CFNullGetTypeID())
    {
      uint64_t v29 = sub_10001267C("circleOps");
      __int16 v30 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "Value provided not appropriate for a circle",  buf,  2u);
      }

      CFTypeID v31 = CFGetTypeID(a3);
      CFStringRef v32 = CFCopyTypeIDDescription(v31);
      SOSCreateErrorWithFormat(1040LL, 0LL, &err, 0LL, @"Expected data or NULL got %@");
      if (!v32) {
        goto LABEL_43;
      }
      CFStringRef v33 = v32;
      goto LABEL_42;
    }
  }

  CFTypeID v17 = CFGetTypeID(a3);
  if (v17 == CFNullGetTypeID())
  {
LABEL_17:
    BOOL v18 = sub_10001267C("circleOps");
    CFTypeRef v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v46 = a3;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "No circle found in data: %@", buf, 0xCu);
    }

    goto LABEL_43;
  }

  uint64_t v20 = SOSCircleCreateFromData(0LL, a3, &err);
  if (!v20)
  {
    id v34 = sub_10001267C("circleOps");
    CFTypeRef v35 = (os_log_s *)objc_claimAutoreleasedReturnValue(v34);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v35,  OS_LOG_TYPE_DEFAULT,  "SOSCircleCreateFromData returned NULL.",  buf,  2u);
    }

    goto LABEL_43;
  }

  CFTypeRef v21 = (const __CFString *)v20;
  CFTypeRef Name = (CFTypeRef)SOSCircleGetName(v20);
  CFTypeRef v23 = Name;
  if (cf && Name)
  {
    if (CFEqual(Name, cf)) {
      goto LABEL_24;
    }
    goto LABEL_39;
  }

  if (Name != cf)
  {
LABEL_39:
    __int16 v36 = sub_10001267C("circleOps");
    uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue(v36);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412546;
      CFTypeRef v46 = cf;
      __int16 v47 = 2112;
      __int128 v48 = v23;
      _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "Expected circle named %@, got %@",  buf,  0x16u);
    }

    SOSCreateErrorWithFormat(1026LL, 0LL, &err, 0LL, @"Expected circle named %@, got %@");
    CFStringRef v33 = v21;
LABEL_42:
    CFRelease(v33);
LABEL_43:
    __int16 v38 = sub_10001267C("SecError");
    uint64_t v39 = (os_log_s *)objc_claimAutoreleasedReturnValue(v38);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "NULL circle found, ignoring ...", buf, 2u);
    }

    CFErrorRef v27 = err;
    goto LABEL_46;
  }

uint64_t sub_1001BC4A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_1001BC4BC(uint64_t a1, CFTypeRef cf, const void *a3)
{
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    CFTypeID TypeID = CFStringGetTypeID();
    if (a3)
    {
      if (v6 == TypeID)
      {
        CFTypeID v8 = CFGetTypeID(a3);
        if (v8 == CFArrayGetTypeID())
        {
          v10[0] = _NSConcreteStackBlock;
          v10[1] = 3221225472LL;
          _DWORD v10[2] = sub_1001BC580;
          v10[3] = &unk_100292FB0;
          uint64_t v9 = *(void *)(a1 + 32);
          void v10[4] = cf;
          void v10[5] = v9;
          v11.CFIndex length = CFArrayGetCount((CFArrayRef)a3);
          v11.id location = 0LL;
          CFArrayApplyFunction((CFArrayRef)a3, v11, (CFArrayApplierFunction)sub_1001BC604, v10);
        }
      }
    }
  }

void sub_1001BC580(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v3 = CFGetTypeID(cf);
    if (v3 == CFStringGetTypeID())
    {
      id v4 = (const void *)SOSRetirementKeyCreateWithCircleNameAndPeer(*(void *)(a1 + 32));
      CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 40), v4, kCFNull);
      if (v4) {
        CFRelease(v4);
      }
    }
  }

uint64_t sub_1001BC604(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_1001BCF88(uint64_t a1, const __CFString *a2)
{
}

void sub_1001BCF90(id a1, __CFDictionary *a2, __CFError *a3)
{
  if (a3)
  {
    id v4 = sub_10001267C("SecError");
    id v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 138412290;
      id v7 = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Error putting: %@", (uint8_t *)&v6, 0xCu);
    }
  }

void sub_1001BDD40( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

void sub_1001BDF4C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_1001BDFD0(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, _BYTE *a6)
{
  CFArrayRef theArray = 0LL;
  CFDataRef v60 = 0LL;
  id v10 = (id *)(a1 + 32);
  CFRange v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) SOSTransportMessageGetAccount]);
  id v12 = [*v10 engine];
  uint64_t v58 = 0LL;
  LOBYTE(v10) = sub_1001B07C0( v11,  (uint64_t)v12,  a5,  (uint64_t)a2,  a3,  &v60,  *(void **)(a1 + 56),  &theArray,  &v58,  *(CFTypeRef **)(a1 + 64));
  uint64_t v13 = v58;
  *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = (_BYTE)v10;

  CFTypeRef v14 = sub_10001267C("ratelimit");
  CFTypeID v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = theArray;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "attribute list: %@", (uint8_t *)&buf, 0xCu);
  }

  if (!theArray)
  {
    CFArrayRef theArray = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(theArray, @"NoAttribute");
  }

  if (*(_BYTE *)(a1 + 72))
  {
    int v16 = 1;
  }

  else
  {
    CFTypeID v17 = sub_10001267C("ratelimit");
    BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "not going to rate limit, currently in initial sync",  (uint8_t *)&buf,  2u);
    }

    int v16 = *(unsigned __int8 *)(a1 + 72);
  }

  CFDataRef v19 = v60;
  if (v16 && v60)
  {
    uint64_t v20 = sub_10001267C("ratelimit");
    CFTypeRef v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "not in initial sync!", (uint8_t *)&buf, 2u);
    }

    CFTypeRef v22 = theArray;
    id v23 = *(id *)(a1 + 32);
    CFTypeRef v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
    uint64_t v67 = 0LL;
    __int128 v68 = &v67;
    uint64_t v69 = 0x2020000000LL;
    char v70 = 0;
    CFTypeRef v25 = sub_1001BE790((uint64_t)a2);
    unsigned __int8 v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
    uint64_t v61 = 0LL;
    id v62 = &v61;
    uint64_t v63 = 0x3032000000LL;
    uint64_t v64 = sub_1001BE7E8;
    id v65 = sub_1001BE7F8;
    id v66 = 0LL;
    if (qword_1002DEE78 == -1)
    {
      if (v22)
      {
LABEL_16:
        CFErrorRef v27 = sub_10001267C("ratelimit");
        CFTypeRef v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          CFIndex Count = CFArrayGetCount(v22);
          LODWORD(buf) = 134217984;
          *(void *)((char *)&buf + 4) = Count;
          _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "number of attributes to review: %lu",  (uint8_t *)&buf,  0xCu);
        }

        *(void *)&__int128 buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 3221225472LL;
        __int128 v74 = sub_1001BE800;
        __int128 v75 = &unk_1002930A8;
        id v76 = v26;
        id v77 = v24;
        __int128 v79 = &v61;
        id v30 = v23;
        id v81 = a2;
        CFDataRef v82 = v19;
        id v78 = v30;
        id v80 = &v67;
        -[__CFArray enumerateObjectsUsingBlock:](v22, "enumerateObjectsUsingBlock:", &buf);

LABEL_25:
        if ([(id)v62[5] count])
        {
          v71[0] = @"timestamp";
          [v24 timeIntervalSince1970];
          id v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:"));
          v72[0] = v34;
          v71[1] = @"peerShouldSend";
          CFTypeRef v35 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  *((unsigned __int8 *)v68 + 24)));
          v71[2] = @"attributeBadness";
          uint64_t v36 = v62[5];
          v72[1] = v35;
          v72[2] = v36;
          uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v72,  v71,  3LL));
          sub_100018C10(@"SOSKVSRateLimitingEvent", v37);
        }

        BOOL v38 = *((_BYTE *)v68 + 24) != 0;
        _Block_object_dispose(&v61, 8);

        _Block_object_dispose(&v67, 8);
        CFIndex v39 = CFArrayGetCount(theArray);
        v83.id location = 0LL;
        v83.CFIndex length = v39;
        if (CFArrayContainsValue(theArray, v83, @"com.apple.security.ckks")
          || (v84.id location = 0LL, v84.length = v39, CFArrayContainsValue(theArray, v84, @"com.apple.sbd"))
          || (v85.id location = 0LL, v85.length = v39,
                                  CFArrayContainsValue(theArray, v85, @"com.apple.securebackupd")))
        {
          BOOL v38 = 1;
        }

        __int16 v40 = sub_10001267C("ratelimit");
        BOOL v41 = (os_log_s *)objc_claimAutoreleasedReturnValue(v40);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 67109120;
          DWORD1(buf) = v38;
          _os_log_impl( (void *)&_mh_execute_header,  v41,  OS_LOG_TYPE_DEFAULT,  "should send? : %{BOOL}d",  (uint8_t *)&buf,  8u);
        }

        if (!v38)
        {
          CFErrorRef v50 = sub_10001267C("ratelimit");
          CFMutableArrayRef v51 = (os_log_s *)objc_claimAutoreleasedReturnValue(v50);
          if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v52 = *(void *)(a1 + 56);
            LODWORD(buf) = 138412290;
            *(void *)((char *)&buf + 4) = v52;
            _os_log_impl( (void *)&_mh_execute_header,  v51,  OS_LOG_TYPE_DEFAULT,  "peer is rate limited: %@",  (uint8_t *)&buf,  0xCu);
          }

          goto LABEL_43;
        }

void sub_1001BE758( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

PeerRateLimiter *sub_1001BE790(uint64_t a1)
{
  uint64_t v2 = (PeerRateLimiter *)*(id *)(a1 + 96);
  if (!v2)
  {
    CFTypeID v3 = -[PeerRateLimiter initWithPeer:](objc_alloc(&OBJC_CLASS___PeerRateLimiter), "initWithPeer:", a1);
    uint64_t v2 = v3;
    if (v3) {
      CFRetain(v3);
    }
    *(void *)(a1 + 96) = v2;
  }

  return v2;
}

uint64_t sub_1001BE7E8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1001BE7F8(uint64_t a1)
{
}

void sub_1001BE800(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = [*(id *)(a1 + 32) stateForAccessGroup:v3];
  if (v4 == 2)
  {
    id v43 = sub_10001267C("ratelimit");
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v43);
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_30;
    }
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)&uint8_t buf[4] = v3;
    id v44 = "access group: %@ is being rate limited";
LABEL_27:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v44, buf, 0xCu);
    goto LABEL_30;
  }

  if (v4 != 1)
  {
    CFStringRef v45 = sub_10001267C("ratelimit");
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v45);
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_30;
    }
    uint64_t v46 = *(void *)(a1 + 72);
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)&uint8_t buf[4] = v46;
    id v44 = "no state for limiter for peer: %@";
    goto LABEL_27;
  }

  id v5 = -[KeychainItem initWithAccessGroup:](objc_alloc(&OBJC_CLASS___KeychainItem), "initWithAccessGroup:", v3);
  int v6 = *(void **)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 40);
  id v50 = 0LL;
  id v8 = [v6 judge:v5 at:v7 limitTime:&v50];
  uint64_t v9 = (os_log_s *)v50;
  uint64_t v10 = sub_10001267C("ratelimit");
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412546;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(void *)&buf[14] = v8;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "accessGroup: %@, judged: %lu", buf, 0x16u);
  }

  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1002DEE70 objectForKeyedSubscript:v3]);
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", v8));
  if (([v12 isEqual:v13] & 1) == 0)
  {
    [(id)qword_1002DEE70 setObject:v13 forKeyedSubscript:v3];
    uint64_t v14 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
    if (!v14)
    {
      CFTypeID v15 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      uint64_t v16 = *(void *)(*(void *)(a1 + 56) + 8LL);
      CFTypeID v17 = *(void **)(v16 + 40);
      *(void *)(v16 + 40) = v15;

      uint64_t v14 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8LL) + 40LL);
    }

    [v14 setObject:v13 forKeyedSubscript:v3];
  }

  -[os_log_s timeIntervalSinceDate:](v9, "timeIntervalSinceDate:", *(void *)(a1 + 40));
  if (v18 <= 0.0)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 64) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  }

  else
  {
    double v19 = v18;
    unsigned __int8 v49 = v5;
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) SOSTransportMessageGetAccount]);
    CFTypeRef v21 = *(void **)(a1 + 32);
    *(void *)__int128 buf = 0LL;
    id v22 = v3;
    id v23 = v21;
    id v24 = sub_10018DFDC(v20, (uint64_t)@"RateLimitCounters");
    CFTypeRef v25 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue(v24);
    if (!v25) {
      CFTypeRef v25 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    }
    unsigned __int8 v26 = (void *)objc_claimAutoreleasedReturnValue([v23 diagnostics]);
    -[NSMutableDictionary setObject:forKey:](v25, "setObject:forKey:", v26, v22);

    sub_1001A93D0(v20, (uint64_t)@"RateLimitCounters", (uint64_t)v25, (CFTypeRef *)buf);
    CFErrorRef v27 = sub_10001267C("ratelimit");
    CFTypeRef v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = v9;
      _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "setting a timer for next sync: %@",  buf,  0xCu);
    }

    uint64_t v48 = v12;

    uint64_t v29 = *(void *)(a1 + 80);
    uint64_t v47 = *(void *)(a1 + 72);
    id v30 = *(id *)(a1 + 32);
    id v31 = v22;
    CFStringRef v32 = sub_10001267C("ratelimit");
    uint64_t v33 = (os_log_s *)objc_claimAutoreleasedReturnValue(v32);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = (int)v19;
      _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "SOSPeerSetNextTimeToSend next time: %d",  buf,  8u);
    }

    id v34 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, &_dispatch_main_q);
    dispatch_time_t v35 = dispatch_time(0LL, 1000000000LL * (int)v19);
    dispatch_source_set_timer(v34, v35, 0xFFFFFFFFFFFFFFFFLL, 0LL);
    uint64_t v36 = sub_10001267C("ratelimit");
    uint64_t v37 = (os_log_s *)objc_claimAutoreleasedReturnValue(v36);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      *(void *)&uint8_t buf[4] = 1000000000LL * (int)v19;
      _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "SOSPeerSetNextTimeToSend next time to sync: %llu",  buf,  0xCu);
    }

    BOOL v38 = (void *)objc_claimAutoreleasedReturnValue([v30 accessGroupToNextMessageToSend]);
    [v38 setObject:v29 forKey:v31];

    uint64_t v39 = *(void *)(v47 + 16);
    if (v39) {
      CFRetain(*(CFTypeRef *)(v47 + 16));
    }
    if (v31) {
      CFRetain(v31);
    }
    *(void *)__int128 buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472LL;
    *(void *)&uint8_t buf[16] = sub_1001BEFFC;
    int v53 = &unk_1002930C8;
    uint64_t v54 = v39;
    id v55 = v31;
    dispatch_source_set_event_handler(v34, buf);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_1001BF0F0;
    handler[3] = &unk_1002930C8;
    void handler[4] = v39;
    void handler[5] = v31;
    dispatch_source_set_cancel_handler(v34, handler);
    dispatch_resume(v34);
    __int16 v40 = (void *)objc_claimAutoreleasedReturnValue([v30 accessGroupToTimer]);
    [v40 setObject:v34 forKey:v31];

    BOOL v41 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) accessGroupRateLimitState]);
    CFArrayRef v42 = -[NSNumber initWithLong:](objc_alloc(&OBJC_CLASS___NSNumber), "initWithLong:", 2LL);
    [v41 setObject:v42 forKey:v31];

    uint64_t v12 = v48;
    id v5 = v49;
  }

LABEL_30:
}

void sub_1001BEDE8(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) accessGroupToNextMessageToSend]);
  id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKey:v3]);

  if (!v5) {
    goto LABEL_14;
  }
  CFTypeRef v21 = 0LL;
  unsigned int v6 = [*(id *)(a1 + 40) SOSTransportMessageSendMessage:*(void *)(a1 + 40) id:*(void *)(*(void *)(a1 + 48) + 16) messageToSend:v5 err:&v21];
  uint64_t v7 = v21;
  id v8 = sub_10001267C("ratelimit");
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v6) {
    BOOL v11 = v7 == 0LL;
  }
  else {
    BOOL v11 = 0;
  }
  if (v11)
  {
    if (v10)
    {
      *(_DWORD *)__int128 buf = 138412546;
      id v23 = v5;
      __int16 v24 = 2112;
      id v25 = v3;
      uint64_t v12 = "SOSTransportSendPendingMessage: sent pending message: %@ for access group: %@";
      uint64_t v13 = v9;
      uint32_t v14 = 22;
      goto LABEL_10;
    }
  }

  else if (v10)
  {
    *(_DWORD *)__int128 buf = 138412290;
    id v23 = v21;
    uint64_t v12 = "SOSTransportSendPendingMessage: could not send message: %@";
    uint64_t v13 = v9;
    uint32_t v14 = 12;
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v14);
  }

  CFTypeID v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) accessGroupToNextMessageToSend]);
  [v15 removeObjectForKey:v3];

  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) accessGroupToTimer]);
  CFTypeID v17 = (dispatch_source_s *)objc_claimAutoreleasedReturnValue([v16 objectForKey:v3]);

  if (v17) {
    dispatch_source_cancel(v17);
  }
  double v18 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) accessGroupToTimer]);
  [v18 removeObjectForKey:v3];

  double v19 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) accessGroupRateLimitState]);
  uint64_t v20 = -[NSNumber initWithLong:](objc_alloc(&OBJC_CLASS___NSNumber), "initWithLong:", 1LL);
  [v19 setObject:v20 forKey:v3];

LABEL_14:
}

void sub_1001BEFFC(uint64_t a1)
{
  CFTypeRef v5 = 0LL;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1001D376C;
  v3[3] = &unk_1002931D8;
  __int128 v4 = *(_OWORD *)(a1 + 32);
  sub_1001C7358(&v5, v3);
  if (v5)
  {
    id v1 = sub_10001267C("SecError");
    uint64_t v2 = (os_log_s *)objc_claimAutoreleasedReturnValue(v1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "error sending next message: %@", buf, 0xCu);
    }
  }

void sub_1001BF0F0(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2) {
    CFRelease(v2);
  }
  id v3 = *(const void **)(a1 + 40);
  if (v3) {
    CFRelease(v3);
  }
}

void sub_1001BF12C(id a1)
{
  id v1 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v2 = (void *)qword_1002DEE70;
  qword_1002DEE70 = (uint64_t)v1;
}

void sub_1001BF154(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _BYTE *a6)
{
  uint64_t v7 = *(void *)(a1 + 56);
  id v8 = *(__CFString ***)(a1 + 72);
  if (a3)
  {
    BOOL v10 = *(const __CFData **)(a1 + 64);
    CFDataRef v275 = 0LL;
    if (v10)
    {
      if (*(void *)(a3 + 24))
      {
        CFMutableDictionaryRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
        CFStringRef cf = CFCopyDescription(*(CFTypeRef *)(a3 + 24));
        int v12 = SecOTRSGetMessageKind(*(void *)(a3 + 24), v10);
        if (v12 != 1)
        {
          if (v12)
          {
            id v30 = (os_log_s *)sub_10001267C("SecError");
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf[0]) = 138412546;
              *(uint64_t *)((char *)buf + 4) = v7;
              WORD2(buf[1]) = 2112;
              *(uint64_t *)((char *)&buf[1] + 6) = (uint64_t)v10;
              _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "%@ Unknown packet type: %@",  (uint8_t *)buf,  0x16u);
            }

            if (v8) {
              id v31 = *v8;
            }
            else {
              id v31 = 0LL;
            }
            SOSCreateError(1029LL, @"Unknown packet type", v31, v8);
          }

          else
          {
            CFMutableDataRef v13 = CFDataCreateMutable(kCFAllocatorDefault, 0LL);
            if (v13)
            {
              CFMutableDataRef v14 = v13;
              int v15 = SecOTRSProcessPacket(*(void *)(a3 + 24), v10, v13);
              if (v15 == -26275)
              {
                CFStringAppend(Mutable, @"resending dh");
                LODWORD(v1_Block_object_dispose(va, 8) = sub_1001A9DA4(a3);
              }

              else if (v15)
              {
                if (v8) {
                  dispatch_time_t v35 = *v8;
                }
                else {
                  dispatch_time_t v35 = 0LL;
                }
                uint64_t v242 = v7;
                uint64_t v243 = v15;
                SOSCreateErrorWithFormat(1025LL, v35, v8, 0LL, @"%@ Cannot negotiate session (%ld)");
                LODWORD(v1_Block_object_dispose(va, 8) = 3;
              }

              else if (CFDataGetLength(v14) < 2)
              {
                if ((SecOTRSGetIsReadyForMessages(*(void *)(a3 + 24)) & 1) != 0)
                {
                  CFStringAppend(Mutable, @"completed negotiation");
                  *(_BYTE *)(a3 + 32) = 0;
                  LODWORD(v1_Block_object_dispose(va, 8) = 2;
                }

                else
                {
                  CFStringAppend(Mutable, @"stuck?");
                  LODWORD(v1_Block_object_dispose(va, 8) = 1;
                }
              }

              else
              {
                uint64_t v16 = SecOTRPacketTypeString(v14);
                CFStringAppendFormat(Mutable, 0LL, @"Sending OTR Response %s", v16);
                if (*(CFMutableDataRef *)(a3 + 40) != v14)
                {
                  CFRetain(v14);
                  CFTypeID v17 = *(const void **)(a3 + 40);
                  if (v17) {
                    CFRelease(v17);
                  }
                  *(void *)(a3 + 40) = v14;
                }

                LODWORD(v1_Block_object_dispose(va, 8) = 1;
                if (SecOTRSGetIsReadyForMessages(*(void *)(a3 + 24)))
                {
                  CFStringAppend(Mutable, @" begin waiting for data packet");
                  *(_BYTE *)(a3 + 32) = 1;
                }
              }

              CFRelease(v14);
              MutableCFDataRef Copy = 0LL;
              goto LABEL_70;
            }

            if (v8) {
              CFStringRef v32 = *v8;
            }
            else {
              CFStringRef v32 = 0LL;
            }
            uint64_t v242 = v7;
            SOSCreateErrorWithFormat(1024LL, v32, v8, 0LL, @"%@ Cannot allocate CFData");
          }

          MutableCFDataRef Copy = 0LL;
          LODWORD(v1_Block_object_dispose(va, 8) = 3;
LABEL_70:
          if (v8 && (_DWORD)v18 == 3 && *v8) {
            CFStringAppendFormat(Mutable, 0LL, @" %@", *v8);
          }
          uint64_t v39 = (os_log_s *)sub_10001267C("coder");
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v40 = SecOTRPacketTypeString(v10);
            uint64_t v41 = *(void *)(a3 + 24);
            else {
              CFArrayRef v42 = off_1002926F0[v18];
            }
            LODWORD(buf[0]) = 138413570;
            *(uint64_t *)((char *)buf + 4) = v7;
            WORD2(buf[1]) = 2112;
            *(uint64_t *)((char *)&buf[1] + 6) = (uint64_t)cf;
            HIWORD(buf[2]) = 2080;
            uint64_t v284 = (void *)v40;
            LOWORD(v285[0]) = 2112;
            *(void *)((char *)v285 + 2) = Mutable;
            WORD1(v285[1]) = 2112;
            *(void *)((char *)&v285[1] + 4) = v41;
            WORD2(v285[2]) = 2080;
            *(void *)((char *)&v285[2] + 6) = v42;
            _os_log_impl( (void *)&_mh_execute_header,  v39,  OS_LOG_TYPE_DEFAULT,  "%@ %@ %s %@ %@ returned %s",  (uint8_t *)buf,  0x3Eu);
          }

          if (cf) {
            CFRelease(cf);
          }
          CFRelease(Mutable);
          goto LABEL_82;
        }

        theuint64_t String = Mutable;
        id v250 = v8;
        uint64_t v21 = v7;
        id v22 = *(const void **)(a3 + 48);
        id v23 = (CFIndex *)ccsha1_di();
        BytePtr = CFDataGetBytePtr(v10);
        unsigned __int8 Length = CFDataGetLength(v10);
        CFIndex v26 = *v23;
        if (*v23 < 0)
        {
          CFTypeRef v28 = 0LL;
        }

        else
        {
          unsigned __int8 v27 = Length;
          CFTypeRef v28 = CFDataCreateMutable(kCFAllocatorDefault, 0LL);
          CFDataSetLength(v28, v26);
          MutableBytePtr = CFDataGetMutableBytePtr(v28);
          ccdigest(v23, v27, BytePtr, MutableBytePtr);
        }

        *(void *)(a3 + 4_Block_object_dispose(va, 8) = v28;
        int v33 = *(unsigned __int8 *)(a3 + 56);
        *(_BYTE *)(a3 + 56) = 0;
        uint64_t v7 = v21;
        id v34 = v22;
        if ((SecOTRSGetIsReadyForMessages(*(void *)(a3 + 24)) & 1) == 0)
        {
          CFMutableDictionaryRef Mutable = theString;
          CFStringAppend(theString, @"not ready for data; resending DH packet");
          LODWORD(v1_Block_object_dispose(va, 8) = sub_1001A9DA4(a3);
          MutableCFDataRef Copy = 0LL;
          id v8 = v250;
          goto LABEL_68;
        }

        CFMutableDictionaryRef Mutable = theString;
        if (*(_BYTE *)(a3 + 32))
        {
          CFStringAppend(theString, @"got data packet we were waiting for ");
          *(_BYTE *)(a3 + 32) = 0;
        }

        MutableCFDataRef Copy = CFDataCreateMutable(0LL, 0LL);
        uint64_t v18 = SecOTRSVerifyAndExposeMessage(*(void *)(a3 + 24), v10, MutableCopy);
        CFStringAppend(theString, @"verify and expose message");
        id v8 = v250;
        if ((_DWORD)v18 == -25329)
        {
          CFStringAppend(theString, @" too new");
          LODWORD(v1_Block_object_dispose(va, 8) = 5;
          goto LABEL_66;
        }

        if ((_DWORD)v18 != -25328)
        {
          if (!(_DWORD)v18)
          {
            CFStringAppend(theString, @"decoded OTR protected packet");
            goto LABEL_68;
          }

          sub_1000194E0(v18, v250, @"%@ Cannot expose message: %d", v7, v18);
          uint64_t v37 = (os_log_s *)sub_10001267C("SecError");
          if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
          {
            if (v250) {
              BOOL v38 = *v250;
            }
            else {
              BOOL v38 = 0LL;
            }
            LODWORD(buf[0]) = 138412546;
            *(uint64_t *)((char *)buf + 4) = v7;
            WORD2(buf[1]) = 2112;
            *(uint64_t *)((char *)&buf[1] + 6) = (uint64_t)v38;
            _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "%@ Decode OTR Protected Packet: %@",  (uint8_t *)buf,  0x16u);
          }

          LODWORD(v1_Block_object_dispose(va, 8) = 3;
          if (!MutableCopy) {
            goto LABEL_68;
          }
LABEL_67:
          CFRelease(MutableCopy);
          MutableCFDataRef Copy = 0LL;
LABEL_68:
          if (v34) {
            CFRelease(v34);
          }
          goto LABEL_70;
        }

        uint64_t v36 = *(const void **)(a3 + 48);
        if (v34 && v36)
        {
          if (CFEqual(v34, v36))
          {
LABEL_48:
            CFStringAppend(theString, @" repeated");
            LODWORD(v1_Block_object_dispose(va, 8) = 4;
            goto LABEL_66;
          }
        }

        else if (v34 == v36)
        {
          goto LABEL_48;
        }

        *(_BYTE *)(a3 + 56) = 1;
        if (v33)
        {
          CFStringAppend(theString, @" too old, repeated renegotiating");
          LODWORD(v1_Block_object_dispose(va, 8) = 3;
        }

        else
        {
          CFStringAppend(theString, @" too old, forcing message");
          LODWORD(v1_Block_object_dispose(va, 8) = 6;
        }

LABEL_98:
        goto LABEL_109;
      case 5:
        id v57 = sub_10001267C("engine");
        uint64_t v58 = (os_log_s *)objc_claimAutoreleasedReturnValue(v57);
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf[0]) = 138412290;
          *(uint64_t *)((char *)buf + 4) = v7;
          _os_log_impl( (void *)&_mh_execute_header,  v58,  OS_LOG_TYPE_DEFAULT,  "%@ engine received a message too soon, time to restart",  (uint8_t *)buf,  0xCu);
        }

        sub_1001A9D20(a3);
        id v59 = sub_10001267C("SecError");
        CFDataRef v60 = (os_log_s *)objc_claimAutoreleasedReturnValue(v59);
        if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf[0]) = 138412290;
          *(uint64_t *)((char *)buf + 4) = (uint64_t)v275;
          _os_log_impl( (void *)&_mh_execute_header,  v60,  OS_LOG_TYPE_DEFAULT,  "Attempt to recover coder failed to restart: %@",  (uint8_t *)buf,  0xCu);
        }

LABEL_117:
        goto LABEL_118;
      case 6:
        *(_BYTE *)(a2 + 4_Block_object_dispose(va, 8) = 1;
LABEL_109:
        int v47 = 2;
LABEL_110:
        if (!MutableCopy) {
          goto LABEL_120;
        }
        goto LABEL_119;
      default:
        CFMutableArrayRef v51 = sub_10001267C("engine");
        uint64_t v52 = (os_log_s *)objc_claimAutoreleasedReturnValue(v51);
        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf[0]) = 138412546;
          *(uint64_t *)((char *)buf + 4) = v7;
          WORD2(buf[1]) = 1024;
          *(_DWORD *)((char *)&buf[1] + 6) = v18;
          _os_log_impl( (void *)&_mh_execute_header,  v52,  OS_LOG_TYPE_DEFAULT,  "%@ engine unknown coder state: %d",  (uint8_t *)buf,  0x12u);
        }

        sub_10001BB24(@"Execution has encountered an unexpected state", 0x53C0000Eu);
LABEL_118:
        int v47 = 0;
        if (MutableCopy)
        {
LABEL_119:
          CFRetain(MutableCopy);
          CFRelease(MutableCopy);
        }

LABEL_120:
        CFDataRef v62 = v275;
        if (v275)
        {
          CFDataRef v275 = 0LL;
          CFRelease(v62);
        }

        break;
    }

    goto LABEL_122;
  }

  v221 = sub_10001267C("SecError");
  uint64_t v222 = (os_log_s *)objc_claimAutoreleasedReturnValue(v221);
  if (os_log_type_enabled(v222, OS_LOG_TYPE_DEFAULT))
  {
    if (v8) {
      uint64_t v223 = (uint64_t)*v8;
    }
    else {
      uint64_t v223 = 0LL;
    }
    LODWORD(buf[0]) = 138412546;
    *(uint64_t *)((char *)buf + 4) = v7;
    WORD2(buf[1]) = 2112;
    *(uint64_t *)((char *)&buf[1] + 6) = v223;
    _os_log_impl((void *)&_mh_execute_header, v222, OS_LOG_TYPE_DEFAULT, "%@ getCoder: %@", (uint8_t *)buf, 0x16u);
  }

  MutableCFDataRef Copy = 0LL;
  int v47 = 0;
LABEL_122:
  id v63 = sub_10018DFDC(*(void **)(a1 + 32), (uint64_t)@"NegotiationRetryCount");
  uint64_t v64 = objc_claimAutoreleasedReturnValue(v63);
  id v65 = (void *)v64;
  if (a3)
  {
    if (v64)
    {
      if ((SecOTRSessionIsSessionInAwaitingState(*(void *)(a3 + 24)) & 1) == 0)
      {
        id v66 = (void *)objc_claimAutoreleasedReturnValue([v65 objectForKey:*(void *)(a1 + 56)]);
        BOOL v67 = v66 == 0LL;

        if (!v67)
        {
          __int128 v68 = sub_10001267C("otrtimer");
          uint64_t v69 = (os_log_s *)objc_claimAutoreleasedReturnValue(v68);
          if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf[0]) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v69,  OS_LOG_TYPE_DEFAULT,  "otr negotiation completed! clearing max retry counter",  (uint8_t *)buf,  2u);
          }

          char v70 = *(void **)(a1 + 56);
          id v71 = *(id *)(a1 + 32);
          id v72 = v70;
          __int128 v73 = sub_10001267C("otrtimer");
          __int128 v74 = (os_log_s *)objc_claimAutoreleasedReturnValue(v73);
          if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf[0]) = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v74,  OS_LOG_TYPE_DEFAULT,  "negotiation finished! clearing max retry counter",  (uint8_t *)buf,  2u);
          }

          id v75 = sub_10018DFDC(v71, (uint64_t)@"NegotiationRetryCount");
          id v76 = (void *)objc_claimAutoreleasedReturnValue(v75);
          if (!v76) {
            id v76 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
          }
          objc_msgSend(v76, "removeObjectForKey:", v72, v242, v243);
          sub_1001A93D0(v71, (uint64_t)@"NegotiationRetryCount", (uint64_t)v76, 0LL);
        }
      }
    }
  }

  if (v47 == 2)
  {
    CFMutableArrayRef v92 = sub_10001267C("engine");
    CFMutableArrayRef v93 = (os_log_s *)objc_claimAutoreleasedReturnValue(v92);
    if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0]) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v93,  OS_LOG_TYPE_DEFAULT,  "coder handled a negotiation message",  (uint8_t *)buf,  2u);
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
    if (MutableCopy) {
      goto LABEL_274;
    }
    goto LABEL_275;
  }

  if (v47 != 1)
  {
    CFMutableArrayRef v94 = sub_10001267C("engine");
    unint64_t v95 = (os_log_s *)objc_claimAutoreleasedReturnValue(v94);
    if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v96 = *(void **)(a1 + 72);
      if (v96) {
        uint64_t v96 = (void *)*v96;
      }
      LODWORD(buf[0]) = 67109378;
      HIDWORD(buf[0]) = v47;
      LOWORD(buf[1]) = 2112;
      *(uint64_t *)((char *)&buf[1] + 2) = (uint64_t)v96;
      _os_log_impl( (void *)&_mh_execute_header,  v95,  OS_LOG_TYPE_DEFAULT,  "coder handled a error message: %d (error: %@)",  (uint8_t *)buf,  0x12u);
    }

    *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 0;
    if (MutableCopy) {
      goto LABEL_274;
    }
    goto LABEL_275;
  }

  if (MutableCopy && CFDataGetLength(MutableCopy))
  {
    id v77 = *(CFTypeRef **)(a1 + 72);
    uint64_t v78 = sub_1001ACCB8();
    uint64_t Instance = _CFRuntimeCreateInstance(kCFAllocatorDefault, v78, 112LL, 0LL);
    if (!Instance)
    {
      unint64_t v84 = SOSErrorCreate(1024LL, v77, 0LL, @"failed to alloc SOSMessage");
      if ((v84 & 1) != 0)
      {
        uint64_t v80 = v84;
        goto LABEL_238;
      }

      goto LABEL_269;
    }

    uint64_t v80 = Instance;
    CFRetain(MutableCopy);
    *(void *)(v80 + 16) = MutableCopy;
    id v81 = CFDataGetBytePtr(MutableCopy);
    CFIndex v82 = CFDataGetLength(MutableCopy);
    CFRange v83 = &v81[v82];
    uint64_t v265 = 0LL;
    v263[0] = 0LL;
    unint64_t v84 = ccder_decode_tag(&v265, v81, &v81[v82]);
    id v86 = 0LL;
    if (v265 != 0x2000000000000010LL) {
      goto LABEL_236;
    }
    CFMutableArrayRef v87 = (const UInt8 *)v84;
    if (v84 && v84 < (unint64_t)v83)
    {
      if (*(unsigned __int8 *)v84 == 128)
      {
        CFMutableArrayRef v87 = (const UInt8 *)(v84 + 1);
        v263[0] = (void *)-1LL;
      }

      else
      {
        uint64_t v101 = ccder_decode_len(v263, v84, v83);
        CFMutableArrayRef v87 = (const UInt8 *)v101;
        if (v101 && v263[0] && v263[0] != (void *)-1LL)
        {
          char v102 = &v83[-v101];
          if (&v83[-v101] == v263[0])
          {
            CFMutableArrayRef v88 = v83;
          }

          else
          {
            char v132 = (os_log_s *)sub_10001267C("SecWarning");
            if (os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf[0]) = 134217984;
              *(uint64_t *)((char *)buf + 4) = (char *)v102 - (char *)v263[0];
              _os_log_impl( (void *)&_mh_execute_header,  v132,  OS_LOG_TYPE_DEFAULT,  "%td trailing bytes after SOSMessage DER",  (uint8_t *)buf,  0xCu);
            }

            CFMutableArrayRef v88 = &v87[(unint64_t)v263[0]];
          }

LABEL_144:
          unint64_t v84 = ccder_decode_tag(&v265, v87, v88);
          if (!v84) {
            goto LABEL_167;
          }
          if (v265 != 0x2000000000000010LL)
          {
            if (v265 == 2)
            {
              if (v263[0] != (void *)-1LL)
              {
                v287[0] = 0LL;
                CFMutableArrayRef v89 = v87;
                uint64_t v90 = (uint64_t)v88;
                unint64_t v84 = ccder_decode_uint64(v287, v89, v88);
                id v86 = (const UInt8 *)v84;
                if (!v84) {
                  goto LABEL_236;
                }
                if (v287[0] != 3LL)
                {
                  if (v287[0] == 2LL)
                  {
                    CFDataRef v275 = 0LL;
                    unint64_t v84 = (unint64_t)sub_1001ADB64(4LL, &v275, v84, v90);
                    id v86 = (const UInt8 *)v84;
                    if (v84)
                    {
                      if (v84 != v90)
                      {
                        logc = (os_log_s *)sub_10001267C("SecWarning");
                        if (os_log_type_enabled(logc, OS_LOG_TYPE_DEFAULT))
                        {
                          LODWORD(buf[0]) = 134217984;
                          *(uint64_t *)((char *)buf + 4) = v90 - (void)v86;
                          _os_log_impl( (void *)&_mh_execute_header,  logc,  OS_LOG_TYPE_DEFAULT,  "%td trailing bytes after deltas DER",  (uint8_t *)buf,  0xCu);
                        }
                      }

                      *(void *)(v80 + 72) = sub_1001AAD88(v275, v77);
                      v220 = (os_log_s *)sub_10001267C("engine");
                      if (os_log_type_enabled(v220, OS_LOG_TYPE_DEBUG))
                      {
                        uint64_t v237 = *(void *)(v80 + 72);
                        if (v237)
                        {
                          unint64_t v239 = CFDataGetLength(*(CFDataRef *)(v237 + 24)) / 0x14uLL;
                          uint64_t v238 = *(__CFData **)(v80 + 72);
                        }

                        else
                        {
                          uint64_t v238 = 0LL;
                          unint64_t v239 = 0LL;
                        }

                        unint64_t v241 = sub_1001AABD0(v238);
                        LODWORD(buf[0]) = 134218242;
                        *(uint64_t *)((char *)buf + 4) = v239;
                        WORD2(buf[1]) = 2112;
                        *(uint64_t *)((char *)&buf[1] + 6) = (uint64_t)v241;
                        _os_log_debug_impl( (void *)&_mh_execute_header,  v220,  OS_LOG_TYPE_DEBUG,  "der_decode_v0_message_body: received a ManifestMessage with (%zu, %@)",  (uint8_t *)buf,  0x16u);
                      }

                      unint64_t v84 = (unint64_t)v275;
                      if (v275) {
                        CFRelease(v275);
                      }
                    }
                  }

                  else if (v287[0] == 1LL)
                  {
                    id v86 = sub_1001ADB64(4LL, (CFDataRef *)(v80 + 40), v84, v90);
                    id v91 = (os_log_s *)sub_10001267C("engine");
                    unint64_t v84 = os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG);
                    if ((_DWORD)v84)
                    {
                      uint64_t v236 = *(void *)(v80 + 40);
                      LODWORD(buf[0]) = 138412290;
                      *(uint64_t *)((char *)buf + 4) = v236;
                      _os_log_debug_impl( (void *)&_mh_execute_header,  v91,  OS_LOG_TYPE_DEBUG,  "der_decode_v0_message_body: received a DigestMessage with sender digest: %@",  (uint8_t *)buf,  0xCu);
                    }
                  }

                  else
                  {
                    unint64_t v84 = SOSErrorCreate(1042LL, v77, 0LL, @"Invalid message type %llu");
                  }

                  goto LABEL_236;
                }

                CFDataRef v275 = 0LL;
                id v269 = (char *)0xAAAAAAAAAAAAAAAALL;
                uint64_t v133 = ccder_decode_sequence_tl(&v269, v84, v90);
                if (v269 == (char *)v90)
                {
                  uint64_t v231 = sub_1001ADB64(4LL, (CFDataRef *)(v80 + 48), v133, v90);
                  v232 = (os_log_s *)sub_10001267C("engine");
                  if (os_log_type_enabled(v232, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v240 = *(void *)(v80 + 48);
                    LODWORD(buf[0]) = 138412290;
                    *(uint64_t *)((char *)buf + 4) = v240;
                    _os_log_debug_impl( (void *)&_mh_execute_header,  v232,  OS_LOG_TYPE_DEBUG,  "der_decode_manifest_and_objects_message: decoded base digest as %@",  (uint8_t *)buf,  0xCu);
                  }

                  CFIndex v233 = sub_1001ADBE0(v80, v77, (uint64_t)v231, (uint64_t)v269);
                  unint64_t v84 = ccder_decode_tl(0x2000000000000010LL, &v275, v233, v269);
                  CFDataRef v234 = v275;
                  *(void *)(v80 + 24) = v84;
                  *(void *)(v80 + 32) = v234;
                  CFTypeRef v235 = (const UInt8 *)v234 + v84;
                  if (v84) {
                    id v86 = v235;
                  }
                  else {
                    id v86 = 0LL;
                  }
                  goto LABEL_236;
                }

                unint64_t v84 = SOSErrorCreate(1042LL, v77, 0LL, @"Trailing garbage at end of message");
              }

              id v86 = 0LL;
LABEL_236:
              if (v81 && v86 == v83)
              {
LABEL_238:
                char v262 = 1;
                unsigned int v134 = *(const void **)(a1 + 56);
                uint64_t v135 = *(void *)(*(void *)(a1 + 48) + 8LL);
                uint64_t v136 = *(__CFArray **)(a1 + 72);
                os_log_t logb = *(os_log_t *)(a1 + 80);
                if (-[OTSOSActualAdapter sosEnabled]_0(v84, v85))
                {
                  uint64_t v137 = sub_1000CD3A0((uint64_t)logb, v134, v136);
                  if (v137)
                  {
                    CFTypeRef cfa = (void *)v80;
                    CFTypeRef v281 = 0LL;
                    uint64_t v282 = 0LL;
                    CFDataRef v275 = 0LL;
                    CFTypeRef v276 = &v275;
                    uint64_t v277 = 0x4010000000LL;
                    CFTypeRef v278 = "";
                    __int128 v279 = 0u;
                    __int128 v280 = 0u;
                    id v269 = 0LL;
                    unint64_t v270 = (uint64_t *)&v269;
                    uint64_t v271 = 0x4010000000LL;
                    id v272 = "";
                    __int128 v273 = 0u;
                    __int128 v274 = 0u;
                    uint64_t v265 = 0LL;
                    v266 = &v265;
                    uint64_t v267 = 0x2020000000LL;
                    char v268 = 1;
                    char v138 = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
                    CFStringRef v245 = CFCopyDescription(v137);
                    if (*((_BYTE *)v266 + 24))
                    {
                      char v139 = *((_BYTE *)v137 + 50);
                      uint64_t v140 = *((void *)logb + 2);
                      buf[0] = (uint64_t)_NSConcreteStackBlock;
                      buf[1] = 3221225472LL;
                      buf[2] = (uint64_t)sub_1000D2550;
                      uint64_t v284 = &unk_100285768;
                      v285[4] = v136;
                      v285[5] = &v262;
                      v285[6] = v137;
                      v285[7] = a5;
                      v285[0] = &v275;
                      v285[1] = &v265;
                      v285[2] = &v269;
                      v285[3] = logb;
                      v285[8] = v135 + 24;
                      v285[9] = v138;
                      char v286 = v139;
                      v287[0] = _NSConcreteStackBlock;
                      v287[1] = 0x40000000LL;
                      v287[2] = sub_1001AD494;
                      __int16 v288 = &unk_100292960;
                      v289[1] = v136;
                      v289[2] = v140;
                      v289[0] = buf;
                      BOOL v141 = sub_1001AD558(v80, (uint64_t)v136, (uint64_t)v287);
                      if (*((_BYTE *)v266 + 24)) {
                        BOOL v142 = v141;
                      }
                      else {
                        BOOL v142 = 0;
                      }
                      *((_BYTE *)v266 + 24) = v142;
                      if (!v142)
                      {
                        uint64_t v247 = 0LL;
                        theStringa = 0LL;
                        id v187 = 0LL;
                        id v246 = 0LL;
                        CFTypeRef v252 = 0LL;
LABEL_333:
                        unsigned int v206 = sub_10001267C("engine");
                        CFTypeRef v207 = (os_log_s *)objc_claimAutoreleasedReturnValue(v206);
                        if (os_log_type_enabled(v207, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v208 = v137[2];
                          uint64_t v209 = *((void *)logb + 3);
                          LODWORD(v287[0]) = 138412802;
                          *(void *)((char *)v287 + 4) = v209;
                          WORD2(v287[1]) = 2112;
                          *(void *)((char *)&v287[1] + 6) = v208;
                          HIWORD(v287[2]) = 2112;
                          __int16 v288 = (void *)v80;
                          _os_log_impl( (void *)&_mh_execute_header,  v207,  OS_LOG_TYPE_DEFAULT,  "recv %@:%@ %@",  (uint8_t *)v287,  0x20u);
                        }

                        id v210 = sub_10001267C("peer");
                        id v211 = (os_log_s *)objc_claimAutoreleasedReturnValue(v210);
                        if (os_log_type_enabled(v211, OS_LOG_TYPE_DEFAULT))
                        {
                          LODWORD(v287[0]) = 138412546;
                          *(void *)((char *)v287 + 4) = v245;
                          WORD2(v287[1]) = 2112;
                          *(void *)((char *)&v287[1] + 6) = v137;
                          _os_log_impl( (void *)&_mh_execute_header,  v211,  OS_LOG_TYPE_DEFAULT,  "recv %@ -> %@",  (uint8_t *)v287,  0x16u);
                        }

                        if (v247) {
                          CFRelease(v247);
                        }
                        if (v187) {
                          CFRelease(v187);
                        }
                        if (v252) {
                          CFRelease(v252);
                        }
                        if (v245) {
                          CFRelease(v245);
                        }
                        if (v246) {
                          CFRelease(v246);
                        }
                        if (theStringa) {
                          CFRelease(theStringa);
                        }
                        if (v282) {
                          CFRelease(v282);
                        }
                        if (v281) {
                          CFRelease(v281);
                        }
                        CFRelease(v137);
                        BOOL v162 = *((_BYTE *)v266 + 24) != 0;
                        _Block_object_dispose(&v265, 8);
                        _Block_object_dispose(&v269, 8);
                        _Block_object_dispose(&v275, 8);
                        goto LABEL_354;
                      }

                      *(_OWORD *)uint64_t v263 = 0u;
                      __int128 v264 = 0u;
                      sub_1001AA048((char **)v276 + 4);
                      uint64_t v143 = (uint64_t *)sub_1001AAE7C(*(void *)(v80 + 72));
                      sub_1001AA344(v143, (uint64_t)(v276 + 4), (char **)v263);
                      id v246 = (CFDataRef *)sub_1001AB230((uint64_t)v263, (CFTypeRef *)v136);
                      uint64_t v144 = v276;
                      free(v276[4]);
                      void v144[4] = 0LL;
                      v144[5] = 0LL;
                      *((_BYTE *)v144 + 56) = 0;
                      v144[6] = 0LL;
                      free(v263[0]);
                      v263[0] = 0LL;
                      v263[1] = 0LL;
                      BYTE8(v264) = 0;
                      *(void *)&__int128 v264 = 0LL;
                      theStringa = (CFDataRef *)sub_1001AB230((uint64_t)(v270 + 4), (CFTypeRef *)v136);
                      uint64_t v145 = v270;
                      free((void *)v270[4]);
                      void v145[4] = 0LL;
                      v145[5] = 0LL;
                      *((_BYTE *)v145 + 56) = 0;
                      v145[6] = 0LL;
                      if (CFArrayGetCount(v138)) {
                        sub_1000D0BC4((uint64_t)logb, a5, 2LL, 0LL, v138, (CFTypeRef *)v136);
                      }
                      if (v138) {
                        CFRelease(v138);
                      }
                      CFTypeRef v252 = sub_1000D08EC((uint64_t)logb, (uint64_t)v137, (uint64_t)v136);
                      *((_BYTE *)v266 + 24) = v252 != 0LL;
                      if (v252)
                      {
                        *(void *)&__int128 v244 = *(void *)(v80 + 56);
                        *((void *)&v244 + 1) = *(void *)(v80 + 48);
                        uint64_t v247 = (CFDataRef *)sub_1001AFF8C((__CFData **)v137, *((const void **)&v244 + 1));
                        int64_t v256 = (CFDataRef *)sub_1001AFF8C((__CFData **)v137, *(const void **)(v80 + 40));
                        if (v256)
                        {
                          id v146 = sub_10001267C("engine");
                          id v147 = (os_log_s *)objc_claimAutoreleasedReturnValue(v146);
                          if (os_log_type_enabled(v147, OS_LOG_TYPE_DEFAULT))
                          {
                            uint64_t v148 = v137[2];
                            unint64_t v149 = CFDataGetLength(v256[3]);
                            CFIndex v150 = *(void **)(v80 + 40);
                            LODWORD(v287[0]) = 138412802;
                            *(void *)((char *)v287 + 4) = v148;
                            WORD2(v287[1]) = 2048;
                            *(void *)((char *)&v287[1] + 6) = v149 / 0x14;
                            HIWORD(v287[2]) = 2112;
                            __int16 v288 = v150;
                            _os_log_impl( (void *)&_mh_execute_header,  v147,  OS_LOG_TYPE_DEFAULT,  "SOSEngineHandleMessage_locked (%@): got a confirmed manifest by digest: (%zu, %@)",  (uint8_t *)v287,  0x20u);
                          }
                        }

                        else
                        {
                          uint64_t v163 = *(void *)(v80 + 64);
                          if (v163 && (unint64_t)CFDataGetLength(*(CFDataRef *)(v163 + 24)) > 0x13
                            || v246 && (unint64_t)CFDataGetLength(v246[3]) >= 0x14)
                          {
                            if (!v247 && *((void *)&v244 + 1)) {
                              goto LABEL_387;
                            }
                            CFStringRef v216 = sub_10001267C("engine");
                            CFMutableDataRef v217 = (os_log_s *)objc_claimAutoreleasedReturnValue(v216);
                            if (os_log_type_enabled(v217, OS_LOG_TYPE_DEFAULT))
                            {
                              uint64_t v218 = v137[2];
                              if (v247) {
                                unint64_t v219 = CFDataGetLength(v247[3]) / 0x14uLL;
                              }
                              else {
                                unint64_t v219 = 0LL;
                              }
                              v227 = sub_1001AABD0((__CFData *)v247);
                              if (v246) {
                                unint64_t v228 = CFDataGetLength(v246[3]) / 0x14uLL;
                              }
                              else {
                                unint64_t v228 = 0LL;
                              }
                              unint64_t v229 = cfa[8];
                              if (v229) {
                                unint64_t v229 = CFDataGetLength(*(CFDataRef *)(v229 + 24)) / 0x14uLL;
                              }
                              LODWORD(v287[0]) = 138413314;
                              *(void *)((char *)v287 + 4) = v218;
                              WORD2(v287[1]) = 2048;
                              *(void *)((char *)&v287[1] + 6) = v219;
                              HIWORD(v287[2]) = 2112;
                              __int16 v288 = v227;
                              LOWORD(v289[0]) = 2048;
                              *(void *)((char *)v289 + 2) = v228;
                              WORD1(v289[1]) = 2048;
                              *(void *)((char *)&v289[1] + 4) = v229;
                              _os_log_impl( (void *)&_mh_execute_header,  v217,  OS_LOG_TYPE_DEFAULT,  "SOSEngineHandleMessage_locked (%@): creating a confirmed manifest via a patch (base %zu %@, +%zu, -%zu)",  (uint8_t *)v287,  0x34u);
                              uint64_t v80 = (uint64_t)cfa;
                            }

                            int64_t v256 = (CFDataRef *)sub_1001AB278( (uint64_t)v247,  *(void *)(v80 + 64),  (uint64_t)v246,  (CFTypeRef *)v136);
                            if (!v256)
                            {
LABEL_387:
                              uint64_t v230 = *(CFDataRef **)(v80 + 64);
                              if (v230) {
                                CFRetain(*(CFTypeRef *)(v80 + 64));
                              }
                              uint64_t v282 = v230;
                              if (v246) {
                                CFRetain(v246);
                              }
                              int64_t v256 = 0LL;
                              CFTypeRef v281 = v246;
                            }
                          }

                          else if (*((void *)&v244 + 1))
                          {
                            if (v247) {
                              CFRetain(v247);
                            }
                            CFIndex v164 = sub_10001267C("SecError");
                            __int128 v165 = (os_log_s *)objc_claimAutoreleasedReturnValue(v164);
                            if (os_log_type_enabled(v165, OS_LOG_TYPE_DEFAULT))
                            {
                              uint64_t v166 = *((void *)logb + 3);
                              LODWORD(v287[0]) = 138412802;
                              *(void *)((char *)v287 + 4) = v166;
                              WORD2(v287[1]) = 2112;
                              *(void *)((char *)&v287[1] + 6) = v134;
                              HIWORD(v287[2]) = 2112;
                              __int16 v288 = v247;
                              _os_log_impl( (void *)&_mh_execute_header,  v165,  OS_LOG_TYPE_DEFAULT,  "%@:%@ Protocol error send L00 - figure out later base: %@",  (uint8_t *)v287,  0x20u);
                            }

                            int64_t v256 = v247;
                          }

                          else
                          {
                            int64_t v256 = 0LL;
                          }
                        }

                        __int128 v151 = sub_10001267C("engine");
                        __int128 v152 = (os_log_s *)objc_claimAutoreleasedReturnValue(v151);
                        if (os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v153 = *((void *)logb + 3);
                          LODWORD(v287[0]) = 138413058;
                          *(void *)((char *)v287 + 4) = v153;
                          WORD2(v287[1]) = 2112;
                          *(void *)((char *)&v287[1] + 6) = v134;
                          HIWORD(v287[2]) = 2112;
                          __int16 v288 = v256;
                          LOWORD(v289[0]) = 2112;
                          *(void *)((char *)v289 + 2) = v247;
                          _os_log_impl( (void *)&_mh_execute_header,  v152,  OS_LOG_TYPE_DEFAULT,  "%@:%@ confirmed: %@ base: %@",  (uint8_t *)v287,  0x2Au);
                        }

                        if (v256
                          && ((char v154 = sub_1001AAED8( v137[9],  (uint64_t)v256,  (uint64_t *)&v282,  (const void **)&v281,  (CFTypeRef *)v136),  *((_BYTE *)v266 + 24))
                            ? (char v155 = v154)
                            : (char v155 = 0),
                              *((_BYTE *)v266 + 24) = v155,
                              (uint64_t v156 = *(void *)(v80 + 64)) != 0))
                        {
                          unint64_t v157 = CFDataGetLength(*(CFDataRef *)(v156 + 24));
                          uint64_t v158 = v282;
                          if (v157 >= 0x14)
                          {
                            uint64_t v158 = sub_1001AB56C((uint64_t)v282, *(CFDataRef **)(v80 + 64), (CFTypeRef *)v136);
                            if (v282) {
                              CFRelease(v282);
                            }
                            uint64_t v282 = v158;
                          }
                        }

                        else
                        {
                          uint64_t v158 = v282;
                        }

                        if ((!v158 || (unint64_t)CFDataGetLength(v158[3]) <= 0x13)
                          && (!v281 || (unint64_t)CFDataGetLength(v281[3]) <= 0x13)
                          && (!theStringa || (unint64_t)CFDataGetLength(theStringa[3]) < 0x14))
                        {
LABEL_318:
                          uint64_t v186 = (CFDataRef *)v137[9];
                          id v187 = v256;
                          if (!v256)
                          {
                            if (v186)
                            {
                              uint64_t v199 = sub_10001267C("engine");
                              uint64_t v200 = (os_log_s *)objc_claimAutoreleasedReturnValue(v199);
                              if (os_log_type_enabled(v200, OS_LOG_TYPE_DEFAULT))
                              {
                                uint64_t v201 = *((void *)logb + 3);
                                LODWORD(v287[0]) = 138412802;
                                *(void *)((char *)v287 + 4) = v201;
                                WORD2(v287[1]) = 2112;
                                *(void *)((char *)&v287[1] + 6) = v137;
                                HIWORD(v287[2]) = 2112;
                                __int16 v288 = (void *)v80;
                                _os_log_impl( (void *)&_mh_execute_header,  v200,  OS_LOG_TYPE_DEFAULT,  "%@:%@ unable to find confirmed in %@, sync protocol reset",  (uint8_t *)v287,  0x20u);
                              }

                              v202 = (const void *)v137[9];
                              id v187 = 0LL;
                              if (v202)
                              {
                                CFRelease(v202);
                                v137[9] = 0LL;
                                uint64_t v80 = (uint64_t)cfa;
                                id v187 = 0LL;
                              }
                            }

                            goto LABEL_331;
                          }

                          double v188 = sub_10001267C("engine");
                          uint64_t v189 = (os_log_s *)objc_claimAutoreleasedReturnValue(v188);
                          BOOL v190 = os_log_type_enabled(v189, OS_LOG_TYPE_DEFAULT);
                          if (v186)
                          {
                            if (v190)
                            {
                              uint64_t v191 = v137[2];
                              unint64_t v192 = CFDataGetLength(v256[3]) / 0x14uLL;
                              uint64_t v193 = sub_1001AABD0((__CFData *)v256);
                              unint64_t v194 = CFDataGetLength(v186[3]) / 0x14uLL;
                              unint64_t v195 = sub_1001AABD0((__CFData *)v186);
                              LODWORD(v287[0]) = 138413314;
                              *(void *)((char *)v287 + 4) = v191;
                              uint64_t v80 = (uint64_t)cfa;
                              WORD2(v287[1]) = 2048;
                              *(void *)((char *)&v287[1] + 6) = v192;
                              HIWORD(v287[2]) = 2112;
                              __int16 v288 = v193;
                              LOWORD(v289[0]) = 2048;
                              *(void *)((char *)v289 + 2) = v194;
                              WORD1(v289[1]) = 2112;
                              *(void *)((char *)&v289[1] + 4) = v195;
                              uint64_t v196 = "SOSEngineHandleMessage_locked (%@): new confirmed manifest (%zu, %@) will replace e"
                                     "xisting confirmed manifest (%zu, %@)";
                              uint64_t v197 = v189;
                              uint32_t v198 = 52;
LABEL_329:
                              _os_log_impl( (void *)&_mh_execute_header,  v197,  OS_LOG_TYPE_DEFAULT,  v196,  (uint8_t *)v287,  v198);
                            }
                          }

                          else if (v190)
                          {
                            uint64_t v203 = v137[2];
                            unint64_t v204 = CFDataGetLength(v256[3]) / 0x14uLL;
                            id v205 = sub_1001AABD0((__CFData *)v256);
                            LODWORD(v287[0]) = 138412802;
                            *(void *)((char *)v287 + 4) = v203;
                            WORD2(v287[1]) = 2048;
                            *(void *)((char *)&v287[1] + 6) = v204;
                            uint64_t v80 = (uint64_t)cfa;
                            HIWORD(v287[2]) = 2112;
                            __int16 v288 = v205;
                            uint64_t v196 = "SOSEngineHandleMessage_locked (%@): new confirmed manifest (%zu, %@) is first manifest for peer";
                            uint64_t v197 = v189;
                            uint32_t v198 = 32;
                            goto LABEL_329;
                          }

                          id v187 = v256;
                          sub_1001AFE34((uint64_t)v137, v256);
LABEL_331:
                          if (v244 == 0) {
                            *((_BYTE *)v137 + 49) = 1;
                          }
                          goto LABEL_333;
                        }

                        __int128 v168 = v281;
                        __int128 v167 = v282;
                        uint64_t v169 = sub_1001AB3E8((uint64_t)v282, (uint64_t)v252, (CFTypeRef *)v136);
                        uint64_t v170 = (const void *)v169;
                        if (v169)
                        {
                          CFTypeRef v171 = sub_1001AB300(v169, v167, (CFTypeRef *)v136);
                          if (v171)
                          {
                            uint64_t v172 = (const void *)sub_1001AB3E8((uint64_t)v168, (uint64_t)v252, (CFTypeRef *)v136);
                            BOOL v173 = v172 != 0LL;
LABEL_300:
                            __int16 v174 = sub_10001267C("peer");
                            id v175 = (os_log_s *)objc_claimAutoreleasedReturnValue(v174);
                            if (os_log_type_enabled(v175, OS_LOG_TYPE_DEFAULT))
                            {
                              LODWORD(v287[0]) = 138413314;
                              *(void *)((char *)v287 + 4) = v137;
                              WORD2(v287[1]) = 2112;
                              *(void *)((char *)&v287[1] + 6) = v170;
                              HIWORD(v287[2]) = 2112;
                              __int16 v288 = (void *)v171;
                              LOWORD(v289[0]) = 2112;
                              *(void *)((char *)v289 + 2) = v172;
                              WORD1(v289[1]) = 2112;
                              *(void *)((char *)&v289[1] + 4) = theStringa;
                              _os_log_impl( (void *)&_mh_execute_header,  v175,  OS_LOG_TYPE_DEFAULT,  "%@ RM:%@ SR:%@ SA:%@ UR:%@",  (uint8_t *)v287,  0x34u);
                            }

                            uint64_t v176 = sub_1001AB278(v137[7], (uint64_t)v172, (uint64_t)v170, (CFTypeRef *)v136);
                            uint64_t v177 = sub_1001AB278(v137[8], (uint64_t)v171, (uint64_t)theStringa, (CFTypeRef *)v136);
                            unint64_t v178 = (const void *)v137[7];
                            if (v178) {
                              CFRelease(v178);
                            }
                            v137[7] = v176;
                            uint64_t v179 = (const void *)v137[8];
                            if (v179) {
                              CFRelease(v179);
                            }
                            v137[8] = v177;
                            if (v170) {
                              CFRelease(v170);
                            }
                            if (v171) {
                              CFRelease(v171);
                            }
                            if (v172) {
                              CFRelease(v172);
                            }
                            unint64_t v180 = sub_10001267C("peer");
                            uint64_t v181 = (os_log_s *)objc_claimAutoreleasedReturnValue(v180);
                            if (os_log_type_enabled(v181, OS_LOG_TYPE_DEFAULT))
                            {
                              uint64_t v183 = (void *)v137[8];
                              uint64_t v182 = v137[9];
                              uint64_t v184 = v137[7];
                              LODWORD(v287[0]) = 138413058;
                              *(void *)((char *)v287 + 4) = v137;
                              WORD2(v287[1]) = 2112;
                              *(void *)((char *)&v287[1] + 6) = v182;
                              HIWORD(v287[2]) = 2112;
                              __int16 v288 = v183;
                              LOWORD(v289[0]) = 2112;
                              *(void *)((char *)v289 + 2) = v184;
                              _os_log_impl( (void *)&_mh_execute_header,  v181,  OS_LOG_TYPE_DEFAULT,  "%@ C:%@ U:%@ O:%@",  (uint8_t *)v287,  0x2Au);
                            }

                            uint64_t v80 = (uint64_t)cfa;
                            if (*((_BYTE *)v266 + 24)) {
                              BOOL v185 = v173;
                            }
                            else {
                              BOOL v185 = 0;
                            }
                            *((_BYTE *)v266 + 24) = v185;
                            goto LABEL_318;
                          }
                        }

                        else
                        {
                          CFTypeRef v171 = 0LL;
                        }

                        uint64_t v172 = 0LL;
                        BOOL v173 = 0;
                        goto LABEL_300;
                      }

                      uint64_t v247 = 0LL;
                      id v187 = 0LL;
                    }

                    else
                    {
                      uint64_t v247 = 0LL;
                      theStringa = 0LL;
                      id v187 = 0LL;
                      id v246 = 0LL;
                    }

                    CFTypeRef v252 = 0LL;
                    goto LABEL_333;
                  }
                }

                else
                {
                  SOSCCSetSOSDisabledError(v136);
                }

                BOOL v162 = 0;
LABEL_354:
                *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v162;
                CFRelease((CFTypeRef)v80);
                if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL))
                {
                  uint64_t v212 = sub_10001267C("engine");
                  uint64_t v213 = (os_log_s *)objc_claimAutoreleasedReturnValue(v212);
                  if (os_log_type_enabled(v213, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v214 = *(void *)(a1 + 56);
                    v215 = *(void **)(a1 + 72);
                    if (v215) {
                      v215 = (void *)*v215;
                    }
                    LODWORD(buf[0]) = 138412546;
                    *(uint64_t *)((char *)buf + 4) = v214;
                    WORD2(buf[1]) = 2112;
                    *(uint64_t *)((char *)&buf[1] + 6) = (uint64_t)v215;
                    _os_log_impl( (void *)&_mh_execute_header,  v213,  OS_LOG_TYPE_DEFAULT,  "Failed to handle message from peer %@: %@",  (uint8_t *)buf,  0x16u);
                  }
                }

LABEL_274:
                CFRelease(MutableCopy);
                goto LABEL_275;
              }

              if (v77 && !*v77) {
                SOSErrorCreate(1029LL, v77, 0LL, @"SOSMessage DER decoding failure %td bytes left");
              }
              CFRelease((CFTypeRef)v80);
              goto LABEL_269;
            }

LABEL_167:
            id v86 = v87;
            goto LABEL_236;
          }

          loga = v77;
          id v269 = (char *)v88;
          v287[0] = 0LL;
          uint64_t v251 = v88;
          uint64_t v97 = ccder_decode_constructed_tl(0x2000000000000010LL, &v269, v87, v88);
          *(void *)(v80 + 112) = 2LL;
          buf[0] = 0xAAAAAAAAAAAAAAAALL;
          uint64_t v98 = (char *)ccder_decode_tl(0x8000000000000000LL, buf, v97, v269);
          uint64_t v99 = 0LL;
          if (v98 && buf[0])
          {
            uint64_t v100 = v98;
            else {
              uint64_t v99 = (uint64_t)&v100[buf[0]];
            }
          }

          if (v99) {
            uint64_t v97 = v99;
          }
          CFDataRef v275 = 0LL;
          uint64_t v103 = ccder_decode_constructed_tl(24LL, &v275, v97, v269);
          id v105 = (const __CFData *)sub_100013A38((double *)(v80 + 104), loga, v103, (unint64_t)v275, v104);
          if (v275 != v105)
          {
            CFRange v106 = (os_log_s *)sub_10001267C("SecWarning");
            if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf[0]) = 134217984;
              *(uint64_t *)((char *)buf + 4) = v275 - v105;
              _os_log_impl( (void *)&_mh_execute_header,  v106,  OS_LOG_TYPE_DEFAULT,  "internal error %td bytes unused in generalizedtime DER buffer",  (uint8_t *)buf,  0xCu);
            }
          }

          if (v105) {
            uint64_t v107 = (uint64_t)v105;
          }
          else {
            uint64_t v107 = v97;
          }
          uint64_t v108 = ccder_decode_uint64(v80 + 96, v107, v269);
          if (v108) {
            uint64_t v107 = v108;
          }
          buf[0] = 0xAAAAAAAAAAAAAAAALL;
          uint64_t v109 = ccder_decode_sequence_tl(buf, v107, v269);
          uint64_t v110 = buf[0];
          if (!v109) {
            uint64_t v110 = 0LL;
          }
          if (v110) {
            uint64_t v111 = v110;
          }
          else {
            uint64_t v111 = v107;
          }
          buf[0] = 0xAAAAAAAAAAAAAAAALL;
          uint64_t v112 = ccder_decode_tl(3LL, buf, v111, v269);
          uint64_t v113 = 0LL;
          if (v112)
          {
            uint64_t v114 = 0LL;
            if (buf[0])
            {
              uint64_t v115 = v112;
              ccn_read_uint(1LL, v287, buf[0] - 1);
              uint64_t v114 = v115 + buf[0];
              uint64_t v113 = v287[0];
            }
          }

          else
          {
            uint64_t v114 = 0LL;
          }

          *(void *)(v80 + 8_Block_object_dispose(va, 8) = v113;
          uint64_t v116 = sub_1001ADB64(4LL, (CFDataRef *)(v80 + 40), v114, (uint64_t)v269);
          id v117 = (os_log_s *)sub_10001267C("engine");
          if (os_log_type_enabled(v117, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v224 = *(void *)(v80 + 40);
            LODWORD(buf[0]) = 138412290;
            *(uint64_t *)((char *)buf + 4) = v224;
            _os_log_debug_impl( (void *)&_mh_execute_header,  v117,  OS_LOG_TYPE_DEBUG,  "der_decode_message_header: decoded sender digest as %@",  (uint8_t *)buf,  0xCu);
          }

          uint64_t v118 = sub_1001ADB64(0x8000000000000000LL, (CFDataRef *)(v80 + 48), (uint64_t)v116, (uint64_t)v269);
          if (v118) {
            uint64_t v119 = (uint64_t)v118;
          }
          else {
            uint64_t v119 = (uint64_t)v116;
          }
          __int128 v120 = (os_log_s *)sub_10001267C("engine");
          if (os_log_type_enabled(v120, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v225 = *(void *)(v80 + 48);
            LODWORD(buf[0]) = 138412290;
            *(uint64_t *)((char *)buf + 4) = v225;
            _os_log_debug_impl( (void *)&_mh_execute_header,  v120,  OS_LOG_TYPE_DEBUG,  "der_decode_message_header: decoded base digest as %@",  (uint8_t *)buf,  0xCu);
          }

          uint64_t v121 = sub_1001ADB64(0x8000000000000001LL, (CFDataRef *)(v80 + 56), v119, (uint64_t)v269);
          uint64_t v122 = (os_log_s *)sub_10001267C("engine");
          if (os_log_type_enabled(v122, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v226 = *(void *)(v80 + 56);
            LODWORD(buf[0]) = 138412290;
            *(uint64_t *)((char *)buf + 4) = v226;
            _os_log_debug_impl( (void *)&_mh_execute_header,  v122,  OS_LOG_TYPE_DEBUG,  "der_decode_message_header: decoded proposed digest as %@",  (uint8_t *)buf,  0xCu);
          }

          if (v121) {
            uint64_t v119 = (uint64_t)v121;
          }
          buf[0] = 0LL;
          uint64_t v123 = ccder_decode_constructed_tl(0xA000000000000000LL, buf, v119, v251);
          __int128 v124 = sub_1001ADBE0(v80, 0LL, v123, buf[0]);
          if (v124) {
            uint64_t v119 = (uint64_t)v124;
          }
          buf[0] = 0xAAAAAAAAAAAAAAAALL;
          uint64_t v125 = ccder_decode_constructed_tl(0xA000000000000001LL, buf, v119, v251);
          uint64_t v126 = buf[0];
          if (!v125) {
            uint64_t v126 = 0LL;
          }
          if (v126) {
            char v127 = (const UInt8 *)v126;
          }
          else {
            char v127 = (const UInt8 *)v119;
          }
          CFDataRef v275 = 0LL;
          id v269 = 0LL;
          unint64_t v84 = ccder_decode_tag(&v275, v127, v251);
          char v128 = 0LL;
          id v77 = loga;
          if (v275 != (CFDataRef)0xA000000000000002LL)
          {
LABEL_227:
            if (v128) {
              id v86 = v128;
            }
            else {
              id v86 = v127;
            }
            goto LABEL_236;
          }

          unint64_t v129 = v84;
          if (v84 && v84 < (unint64_t)v251)
          {
            if (*(unsigned __int8 *)v84 == 128)
            {
              unint64_t v129 = v84 + 1;
              uint64_t v130 = -1LL;
LABEL_226:
              *(void *)(v80 + 24) = v129;
              *(void *)(v80 + 32) = v130;
              char v128 = (const UInt8 *)(v129 + v130);
              goto LABEL_227;
            }

            unint64_t v84 = ccder_decode_len(&v269, v84, v251);
            unint64_t v129 = v84;
            uint64_t v130 = (uint64_t)v269;
          }

          else
          {
            uint64_t v130 = 0LL;
          }

          if (&v251[-v129] != (const UInt8 *)v130)
          {
            unint64_t v131 = (os_log_s *)sub_10001267C("SecWarning");
            unint64_t v84 = os_log_type_enabled(v131, OS_LOG_TYPE_DEFAULT);
            uint64_t v130 = (uint64_t)v269;
            if ((_DWORD)v84)
            {
              LODWORD(buf[0]) = 134217984;
              *(uint64_t *)((char *)buf + 4) = &v251[-v129] - (const UInt8 *)v269;
              _os_log_impl( (void *)&_mh_execute_header,  v131,  OS_LOG_TYPE_DEFAULT,  "%td trailing bytes after SOSMessage DER",  (uint8_t *)buf,  0xCu);
              uint64_t v130 = (uint64_t)v269;
            }

            id v77 = loga;
          }

          goto LABEL_226;
        }
      }
    }

    CFMutableArrayRef v88 = v83;
    goto LABEL_144;
  }

LABEL_269:
  uint64_t v159 = sub_10001267C("engine");
  CFIndex v160 = (os_log_s *)objc_claimAutoreleasedReturnValue(v159);
  if (os_log_type_enabled(v160, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v161 = *(void **)(a1 + 72);
    if (v161) {
      uint64_t v161 = (void *)*v161;
    }
    LODWORD(buf[0]) = 138412290;
    *(uint64_t *)((char *)buf + 4) = (uint64_t)v161;
    _os_log_impl( (void *)&_mh_execute_header,  v160,  OS_LOG_TYPE_DEFAULT,  "Failed to turn a data gram into an SOSMessage: %@",  (uint8_t *)buf,  0xCu);
  }

  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = SOSErrorCreate( 8LL,  *(void *)(a1 + 72),  0LL,  @"Failed to parse SOSMessage");
  if (MutableCopy) {
    goto LABEL_274;
  }
LABEL_275:
}

void sub_1001C17E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, char a39)
{
}

os_state_data_s *__cdecl sub_1001C185C(id a1, os_state_hints_s *a2)
{
  if (a2->var2 != 3) {
    return 0LL;
  }
  id v8 = (const __CFData *)sub_1001C1904((uint64_t)a1, (int)a2, v2, v3, v4, v5, v6, v7);
  if (!v8) {
    return 0LL;
  }
  uint64_t v9 = v8;
  size_t Length = CFDataGetLength(v8);
  BOOL v11 = (os_state_data_s *)calloc(1uLL, Length + 200);
  int v12 = v11;
  if (v11)
  {
    v11->var0 = 2;
    BytePtr = CFDataGetBytePtr(v9);
    memcpy(v12->var4, BytePtr, Length);
    v12->var1.int var1 = Length;
    __strlcpy_chk(v12->var3, "CloudCircle Account Object", 64LL, 64LL);
  }

  CFRelease(v9);
  return v12;
}

uint64_t sub_1001C1904(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  CFTypeRef cf = 0LL;
  id v8 = sub_1001C1AD0(1LL, a2, a3, a4, a5, a6, a7, a8);
  *(void *)uint64_t result = 0LL;
  OSStatus v9 = SecItemCopyMatching(v8, (CFTypeRef *)result);
  if (v8) {
    CFRelease(v8);
  }
  if (v9)
  {
    sub_1000194E0( v9,  (__CFString **)&cf,  @"Error %@ reading for service '%@'",  *(void *)result,  @"iCloud Keychain Account Meta-data");
  }

  else
  {
    if (*(void *)result)
    {
      CFTypeID v10 = CFGetTypeID(*(CFTypeRef *)result);
      if (v10 == CFDataGetTypeID())
      {
        uint64_t v11 = *(void *)result;
        if (*(void *)result) {
          goto LABEL_17;
        }
        goto LABEL_12;
      }
    }

    SOSCreateErrorWithFormat(1028LL, 0LL, &cf, 0LL, @"SecItemCopyMatching returned non-data in '%@'");
  }

  int v12 = *(const void **)result;
  if (*(void *)result)
  {
    *(void *)uint64_t result = 0LL;
    CFRelease(v12);
  }

CFDictionaryRef sub_1001C1AD0(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return sub_100107FA8( kCFAllocatorDefault,  a2,  a3,  a4,  a5,  a6,  a7,  a8,  (uint64_t)kSecClass,  (uint64_t)kSecClassGenericPassword);
}

void sub_1001C1B7C(uint64_t a1, const void *a2, const void *a3)
{
}

uint64_t sub_1001C1B84(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_1001C1B9C(id a1)
{
  if (!qword_1002DEE80)
  {
    id v1 = (const __CFDictionary *)_CFCopySystemVersionDictionary(a1);
    if (v1)
    {
      int v2 = v1;
      signed int Value = CFDictionaryGetValue(v1, _kCFSystemVersionBuildVersionKey);
      if (Value)
      {
        int v4 = Value;
        CFTypeID v5 = CFGetTypeID(Value);
        if (v5 == CFStringGetTypeID())
        {
          CFRetain(v4);
          qword_1002DEE80 = (uint64_t)v4;
        }
      }

      CFRelease(v2);
    }

    if (!qword_1002DEE80) {
      qword_1002DEE80 = (uint64_t)@"Unknown model";
    }
  }

id sub_1001C2128(uint64_t a1, uint64_t a2)
{
  int v2 = a1;
  if (qword_1002DEB60 != -1) {
    dispatch_once(&qword_1002DEB60, &stru_10028EF88);
  }
  if (byte_1002DDD08)
  {
    if (v2)
    {
      objc_msgSend((id)qword_1002DEEB0, "setSosCompatibilityMode:", -[OTSOSActualAdapter sosEnabled]_0(a1, a2));
    }

    else if (qword_1002DEEB8 != -1)
    {
      dispatch_once(&qword_1002DEEB8, &stru_1002937D8);
    }

    id v3 = (id)qword_1002DEEB0;
  }

  else
  {
    id v3 = 0LL;
  }

  return v3;
}

void sub_1001C21CC(id a1)
{
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(-2LL, 0LL);
  int v2 = (dispatch_queue_s *)(id)objc_claimAutoreleasedReturnValue(global_queue);
  if (qword_1002DEB60 != -1) {
    dispatch_once(&qword_1002DEB60, &stru_10028EF88);
  }
  if (!byte_1002DDD08)
  {

    goto LABEL_16;
  }

  memset(&context, 0, sizeof(context));
  id v3 = SCDynamicStoreCreate( 0LL,  @"com.apple.securityd.cloudcircleserver",  (SCDynamicStoreCallBack)sub_1001C246C,  &context);
  ComputerCFTypeRef Name = (void *)SCDynamicStoreKeyCreateComputerName(0LL);
  values = ComputerName;
  if (v3 && ComputerName)
  {
    CFTypeID v5 = CFArrayCreate(0LL, (const void **)&values, 1LL, &kCFTypeArrayCallBacks);
    if (v5)
    {
      CFDictionaryRef v6 = sub_1001C24C0(v3);
      SCDynamicStoreSetNotificationKeys(v3, v5, 0LL);
      SCDynamicStoreSetDispatchQueue(v3, v2);
    }

    else
    {
      CFDictionaryRef v6 = 0LL;
    }
  }

  else
  {
    CFDictionaryRef v6 = 0LL;
    CFTypeID v5 = 0LL;
    CFDictionaryRef v7 = 0LL;
    id v8 = 0LL;
    if (!v3)
    {
      if (!ComputerName) {
        goto LABEL_12;
      }
      goto LABEL_11;
    }
  }

  CFRelease(v3);
  ComputerCFTypeRef Name = values;
  CFDictionaryRef v7 = v6;
  id v8 = v5;
  if (values) {
LABEL_11:
  }
    CFRelease(ComputerName);
LABEL_12:
  if (v8) {
    CFRelease(v8);
  }

  if (v7)
  {
    id v16 = sub_1001C262C((uint64_t)v7, v9, v10, v11, v12, v13, v14, v15);
    uint64_t v17 = objc_claimAutoreleasedReturnValue(v16);
    uint64_t v18 = (void *)qword_1002DEEC0;
    qword_1002DEEC0 = v17;

    sub_100190FF0((void *)qword_1002DEEC0, &stru_100293818);
    SOSCloudKeychainSetItemsChangedBlock(&stru_100293858);
    CFRelease(v7);
    goto LABEL_19;
  }

void sub_1001C246C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1001C40C4;
  v3[3] = &unk_1002938E0;
  void v3[4] = a1;
  void v3[5] = a2;
  v3[6] = a3;
  sub_1001C3588(v3);
}

CFDictionaryRef sub_1001C24C0(const __SCDynamicStore *a1)
{
  if (qword_1002DEEC8 != -1) {
    dispatch_once(&qword_1002DEEC8, &stru_100293900);
  }
  CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, (CFStringRef)qword_1002DEE88);
  CFStringRef v3 = SCDynamicStoreCopyComputerName(a1, 0LL);
  if (v3) {
    int v4 = v3;
  }
  else {
    int v4 = @"Unknown name";
  }
  if (qword_1002DEE90 != -1) {
    dispatch_once(&qword_1002DEE90, &stru_100293130);
  }
  CFTypeID v5 = (const void *)qword_1002DEE80;
  if (qword_1002DEE80) {
    CFRetain((CFTypeRef)qword_1002DEE80);
  }
  int valuePtr = 0;
  CFNumberRef v6 = CFNumberCreate(0LL, kCFNumberSInt32Type, &valuePtr);
  CFDictionaryRef v14 = sub_100107FA8(kCFAllocatorDefault, v7, v8, v9, v10, v11, v12, v13, kPIUserDefinedDeviceNameKey, (uint64_t)v4);
  if (v5) {
    CFRelease(v5);
  }
  if (Copy) {
    CFRelease(Copy);
  }
  CFRelease(v4);
  if (v6) {
    CFRelease(v6);
  }
  return v14;
}

id sub_1001C262C(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v9 = (const void *)sub_1001C1904(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = sub_1001110DC(0LL);
  uint64_t v11 = sub_100101A94(v10);
  if (v11)
  {
    uint64_t v12 = v11;
    if (v9)
    {
      id v22 = 0LL;
      int v13 = (void *)objc_claimAutoreleasedReturnValue( +[SOSAccount accountFromData:factory:error:]( &OBJC_CLASS___SOSAccount,  "accountFromData:factory:error:",  v9,  v11,  &v22));
      id v14 = v22;
      if (v13)
      {
        int v15 = (void *)objc_claimAutoreleasedReturnValue([v13 trust]);
        [v15 updateGestalt:v13 newGestalt:a1];

        CFRelease(v9);
LABEL_12:
        [v13 sosEvaluateIfNeeded];
        [v13 startStateMachine];
        return v13;
      }

      id v16 = sub_10001267C("account");
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        id v24 = v14;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Got error inflating account: %@",  buf,  0xCu);
      }

      CFRelease(v9);
    }

    uint64_t v18 = sub_100190D30(a1, v12);
    int v13 = (void *)objc_claimAutoreleasedReturnValue(v18);
    if (!v13)
    {
      double v19 = sub_10001267C("account");
      CFIndex v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Got NULL creating account", buf, 2u);
      }

      int v13 = 0LL;
    }

    goto LABEL_12;
  }

  if (v9) {
    CFRelease(v9);
  }
  return 0LL;
}

void sub_1001C2804(id a1, __CFData *a2, __CFError *a3)
{
  if (a2)
  {
    CFTypeRef cf = 0LL;
    if (!qword_1002DEED0 || !CFEqual((CFTypeRef)qword_1002DEED0, a2))
    {
      uint64_t v9 = kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate;
      uint64_t v10 = sub_1001C1AD0(0LL, (int)a2, (int)a3, v3, v4, v5, v6, v7);
      uint64_t v27 = v9;
      uint64_t v18 = sub_100107FA8(kCFAllocatorDefault, v11, v12, v13, v14, v15, v16, v17, (uint64_t)kSecValueData, (uint64_t)a2);
      OSStatus v19 = SecItemUpdate(v10, v18);
      if (v19 == -25300)
      {
        MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v10);
        *(void *)&__int128 context = _NSConcreteStackBlock;
        *((void *)&context + 1) = 3221225472LL;
        id v30 = sub_1001C1B7C;
        dispatch_queue_global_t v31 = &unk_100293110;
        CFStringRef v32 = MutableCopy;
        CFDictionaryApplyFunction(v18, (CFDictionaryApplierFunction)sub_1001C1B84, &context);
        OSStatus v19 = SecItemAdd(MutableCopy, 0LL);
        if (MutableCopy) {
          CFRelease(MutableCopy);
        }
      }

      if (v10) {
        CFRelease(v10);
      }
      if (v18) {
        CFRelease(v18);
      }
      if (sub_1000194E0( v19,  (__CFString **)&cf,  @"Error saving %@ to service '%@'",  a2,  @"iCloud Keychain Account Meta-data",  kSecAttrAccessible,  v27,  0LL))
      {
        CFRetain(a2);
        if (qword_1002DEED0) {
          CFRelease((CFTypeRef)qword_1002DEED0);
        }
        qword_1002DEED0 = (uint64_t)a2;
      }

      else
      {
        id v24 = sub_10001267C("SecError");
        int v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(context) = 138412290;
          *(void *)((char *)&context + 4) = cf;
          _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Can't save account: %@",  (uint8_t *)&context,  0xCu);
        }
      }
    }

    CFTypeRef v26 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v26);
    }
  }

  else
  {
    id v22 = sub_10001267C("SecError");
    int v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(context) = 138412290;
      *(void *)((char *)&context + 4) = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "Failed to transform account into data, error: %@",  (uint8_t *)&context,  0xCu);
    }
  }

__CFArray *__cdecl sub_1001C2A8C(id a1, __CFDictionary *a2)
{
  if (a2) {
    CFRetain(a2);
  }
  uint64_t v6 = 0LL;
  int v7 = &v6;
  uint64_t v8 = 0x2020000000LL;
  uint64_t v9 = 0LL;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_1001C2B4C;
  void v5[3] = &unk_100293880;
  void v5[4] = &v6;
  void v5[5] = a2;
  sub_1001C3588(v5);
  if (a2) {
    CFRelease(a2);
  }
  int v3 = (__CFArray *)v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1001C2B30( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1001C2B4C(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = (const void *)SOSItemsChangedCopyDescription(*(void *)(a1 + 40), 0LL);
  if (v4) {
    CFRelease(v4);
  }
  CFTypeRef v56 = 0LL;
  CFDictionaryRef theDict = *(const __CFDictionary **)(a1 + 40);
  uint64_t v71 = 0LL;
  id v72 = &v71;
  uint64_t v73 = 0x3032000000LL;
  __int128 v74 = sub_1001B6020;
  id v75 = sub_1001B6030;
  id v76 = (id)0xAAAAAAAAAAAAAAAALL;
  id v55 = v3;
  id v76 = (id)objc_claimAutoreleasedReturnValue([v55 account]);
  if (-[OTSOSActualAdapter sosEnabled]_0((uint64_t)v76, v5))
  {
    CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
    id value = 0LL;
    int v7 = (const void *)kSOSKVSAccountChangedKey;
    if (CFDictionaryGetValueIfPresent(theDict, kSOSKVSAccountChangedKey, (const void **)&value))
    {
      uint64_t v8 = sub_10001267C("accountChange");
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "SOSTransportDispatchMessages received kSOSKVSAccountChangedKey",  (uint8_t *)&buf,  2u);
      }

      if (value)
      {
        CFTypeID v10 = CFGetTypeID(value);
        if (v10 == CFBooleanGetTypeID())
        {
          if (CFBooleanGetValue((CFBooleanRef)value))
          {
            int v11 = (void *)objc_claimAutoreleasedReturnValue([v55 account]);
            sub_1001907A8(v11);

            int v12 = (void *)objc_claimAutoreleasedReturnValue([v55 account]);
            [v12 setAccountIsChanging:1];

            int v13 = (void *)objc_claimAutoreleasedReturnValue([v55 account]);
            objc_msgSend(v13, "setKey_interests_need_updating:", 1);
          }
        }
      }

      CFArrayAppendValue(Mutable, v7);
    }

    int v14 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    int v15 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    int v16 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    int v17 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    uint64_t v18 = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    CFMutableDictionaryRef cf = CFDictionaryCreateMutable( kCFAllocatorDefault,  0LL,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks);
    uint64_t v66 = 0LL;
    BOOL v67 = &v66;
    uint64_t v68 = 0x2020000000LL;
    uint64_t v69 = 0LL;
    uint64_t v62 = 0LL;
    id v63 = &v62;
    uint64_t v64 = 0x2020000000LL;
    char v65 = 0;
    unsigned __int8 v19 = [(id)v72[5] SOSMonitorModeSOSIsActive];
    *(void *)&__int128 buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 3221225472LL;
    uint64_t v80 = sub_1001B6038;
    id v81 = &unk_100292D50;
    unsigned __int8 v90 = v19;
    CFIndex v82 = &v62;
    CFRange v83 = &v66;
    unint64_t v84 = v15;
    uint64_t v85 = v14;
    id v86 = v16;
    CFMutableArrayRef v87 = v17;
    CFMutableArrayRef v88 = v18;
    CFMutableArrayRef v89 = &v56;
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_1001B639C, &buf);
    if (v67[3])
    {
      CFIndex v20 = (const __CFArray *)sub_1001B4DA4();
      v61[0] = _NSConcreteStackBlock;
      v61[1] = 3221225472LL;
      v61[2] = sub_1001B63B4;
      v61[3] = &unk_100292D78;
      v61[4] = &v71;
      v61[5] = &v66;
      int v21 = v61;
      v95.CFIndex length = CFArrayGetCount(v20);
      v95.id location = 0LL;
      CFArrayApplyFunction(v20, v95, (CFArrayApplierFunction)sub_1001B4CD8, v21);

      CFArrayAppendValue(Mutable, kSOSKVSKeyParametersKey);
      id v22 = (const void *)v67[3];
      if (v22)
      {
        v67[3] = 0LL;
        CFRelease(v22);
      }
    }

    if (*((_BYTE *)v63 + 24)) {
      CFArrayAppendValue(Mutable, kSOSKVSInitialSyncKey);
    }
    if (CFDictionaryGetCount(v18))
    {
      int v23 = (const __CFString *)CFDictionaryGetValue(v18, @"Scope");
      id v28 = v23;
      if (v23)
      {
        CFTypeID v29 = CFGetTypeID(v23);
        if (v29 == CFStringGetTypeID())
        {
          sub_1000124F8(v28, 4);
        }

        else
        {
          CFTypeID v32 = CFGetTypeID(v28);
          if (v32 == CFDictionaryGetTypeID()) {
            sub_100011EB4((const __CFDictionary *)v28, 4);
          }
        }
      }

      id v33 = (const void *)SOSDebugInfoKeyCreateWithTypeName(@"Scope", v24, v25, v26, v27);
      CFArrayAppendValue(Mutable, v33);
      if (v33) {
        CFRelease(v33);
      }
    }

    if (CFDictionaryGetCount(v16))
    {
      uint64_t v34 = (const __CFArray *)sub_1001B4E5C();
      v60[0] = _NSConcreteStackBlock;
      v60[1] = 3221225472LL;
      v60[2] = sub_1001B64BC;
      v60[3] = &unk_100292DA0;
      v60[4] = &v71;
      v60[5] = v16;
      v60[6] = &v56;
      v60[7] = Mutable;
      dispatch_time_t v35 = v60;
      v96.CFIndex length = CFArrayGetCount(v34);
      v96.id location = 0LL;
      CFArrayApplyFunction(v34, v96, (CFArrayApplierFunction)sub_1001B4CD8, v35);
    }

    if (CFDictionaryGetCount(v14))
    {
      uint64_t v36 = (const __CFArray *)sub_1001B4CEC();
      v59[0] = _NSConcreteStackBlock;
      v59[1] = 3221225472LL;
      v59[2] = sub_1001B6604;
      v59[3] = &unk_100292DC8;
      uint8_t v59[4] = &v71;
      v59[5] = v14;
      v59[6] = Mutable;
      uint64_t v37 = v59;
      v97.CFIndex length = CFArrayGetCount(v36);
      v97.id location = 0LL;
      CFArrayApplyFunction(v36, v97, (CFArrayApplierFunction)sub_1001B4CD8, v37);
    }

    if (CFDictionaryGetCount(v15))
    {
      BOOL v38 = (const __CFArray *)sub_1001B4E5C();
      v58[0] = _NSConcreteStackBlock;
      v58[1] = 3221225472LL;
      v58[2] = sub_1001B684C;
      v58[3] = &unk_100292DA0;
      v58[4] = &v71;
      v58[5] = v15;
      void v58[6] = &v56;
      v58[7] = Mutable;
      uint64_t v39 = v58;
      v98.CFIndex length = CFArrayGetCount(v38);
      v98.id location = 0LL;
      CFArrayApplyFunction(v38, v98, (CFArrayApplierFunction)sub_1001B4CD8, v39);
    }

    if (CFDictionaryGetCount(v17))
    {
      uint64_t v40 = (const __CFArray *)sub_1001B4E5C();
      v57[0] = _NSConcreteStackBlock;
      v57[1] = 3221225472LL;
      v57[2] = sub_1001B6A9C;
      v57[3] = &unk_100292DA0;
      v57[4] = &v71;
      v57[5] = v17;
      v57[6] = &v56;
      v57[7] = Mutable;
      uint64_t v41 = v57;
      v99.CFIndex length = CFArrayGetCount(v40);
      v99.id location = 0LL;
      CFArrayApplyFunction(v40, v99, (CFArrayApplierFunction)sub_1001B4CD8, v41);
    }

    if (v16) {
      CFRelease(v16);
    }
    if (v15) {
      CFRelease(v15);
    }
    if (v14) {
      CFRelease(v14);
    }
    if (v18) {
      CFRelease(v18);
    }
    if (v17) {
      CFRelease(v17);
    }
    if (cf) {
      CFRelease(cf);
    }
    CFMutableStringRef v42 = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
    CFMutableStringRef v43 = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
    context[0] = _NSConcreteStackBlock;
    context[1] = 3221225472LL;
    uint64_t context[2] = sub_1001B6C54;
    context[3] = &unk_100293110;
    void context[4] = v42;
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_1001B639C, context);
    v77[0] = _NSConcreteStackBlock;
    v77[1] = 3221225472LL;
    v77[2] = sub_1001B6CB8;
    v77[3] = &unk_100293EA8;
    v77[4] = v43;
    v100.CFIndex length = CFArrayGetCount(Mutable);
    v100.id location = 0LL;
    CFArrayApplyFunction(Mutable, v100, (CFArrayApplierFunction)sub_1001B4CD8, v77);
    id v44 = sub_10001267C("updates");
    CFStringRef v45 = (os_log_s *)objc_claimAutoreleasedReturnValue(v44);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
    {
      CFIndex Count = CFDictionaryGetCount(theDict);
      *(_DWORD *)id v91 = 134218242;
      CFIndex v92 = Count;
      __int16 v93 = 2112;
      CFMutableStringRef v94 = v42;
      _os_log_debug_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEBUG, "Updates [%ld]: %@", v91, 0x16u);
    }

    uint64_t v46 = sub_10001267C("updates");
    int v47 = (os_log_s *)objc_claimAutoreleasedReturnValue(v46);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
    {
      CFIndex v52 = CFArrayGetCount(Mutable);
      *(_DWORD *)id v91 = 134218242;
      CFIndex v92 = v52;
      __int16 v93 = 2112;
      CFMutableStringRef v94 = v43;
      _os_log_debug_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEBUG, "Handled [%ld]: %@", v91, 0x16u);
    }

    if (v42) {
      CFRelease(v42);
    }
    if (v43) {
      CFRelease(v43);
    }
    _Block_object_dispose(&v62, 8);
    _Block_object_dispose(&v66, 8);
  }

  else
  {
    id v30 = sub_10001267C("nosos");
    dispatch_queue_global_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "transport received a message for sos but the system is off",  (uint8_t *)&buf,  2u);
    }

    CFMutableDictionaryRef Mutable = 0LL;
  }

  _Block_object_dispose(&v71, 8);

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = Mutable;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) || v56)
  {
    uint64_t v48 = sub_10001267C("SecError");
    unsigned __int8 v49 = (os_log_s *)objc_claimAutoreleasedReturnValue(v48);
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v56;
      _os_log_impl( (void *)&_mh_execute_header,  v49,  OS_LOG_TYPE_DEFAULT,  "Error handling updates: %@",  (uint8_t *)&buf,  0xCu);
    }

    CFTypeRef v50 = v56;
    if (v56)
    {
      CFTypeRef v56 = 0LL;
      CFRelease(v50);
    }
  }
}

void sub_1001C34FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, char a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
}

void sub_1001C3588(void *a1)
{
  id v1 = a1;
  int v2 = objc_autoreleasePoolPush();
  id v4 = sub_1001C2128(0LL, v3);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  if (v5)
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472LL;
    v6[2] = sub_1001C362C;
    v6[3] = &unk_100293978;
    id v7 = v1;
    [v5 performTransaction:v6];
  }

  objc_autoreleasePoolPop(v2);
}

uint64_t sub_1001C362C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_1001C3638( id a1, SOSAccount *a2, __OpaqueSOSCircle *a3, __CFSet *a4, __CFSet *a5, __CFSet *a6, __CFSet *a7)
{
  int v12 = a2;
  int v13 = -[SOSAccount peerInfo](v12, "peerInfo");
  if (!v13)
  {
    CFIndex v20 = sub_10001267C("circleOps");
    int v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEBUG,  "Change block called with no peerInfo",  buf,  2u);
    }

    goto LABEL_9;
  }

  int v14 = v13;
  if ((SOSCircleHasPeer(a3, v13, 0LL) & 1) == 0)
  {
    id v22 = sub_10001267C("circleOps");
    int v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_debug_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEBUG,  "Change block called while not in circle",  buf,  2u);
    }

void sub_1001C3AB8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_1001C3AE0(const __CFSet *a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1001C3BDC;
  v3[3] = &unk_100293EA8;
  void v3[4] = Mutable;
  CFSetApplyFunction(a1, (CFSetApplierFunction)sub_1001C3BC8, v3);
  activity_block[0] = _NSConcreteStackBlock;
  activity_block[1] = 3221225472LL;
  activity_block[2] = sub_1001C3D44;
  activity_block[3] = &unk_1002935A8;
  activity_void block[4] = Mutable;
  _os_activity_initiate( (void *)&_mh_execute_header,  "CloudCircle RequestSyncWithPeersList",  OS_ACTIVITY_FLAG_DEFAULT,  activity_block);
  if (Mutable) {
    CFRelease(Mutable);
  }
}

void sub_1001C3BC0(uint64_t a1, const void *a2)
{
}

uint64_t sub_1001C3BC8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_1001C3BDC(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      uint64_t v5 = *(__CFArray **)(a1 + 32);
      CFTypeRef PeerID = cf;
LABEL_9:
      CFArrayAppendValue(v5, PeerID);
      return;
    }

    CFTypeID v7 = CFGetTypeID(cf);
    if (v7 == SOSPeerInfoGetTypeID())
    {
      CFTypeID v8 = CFGetTypeID(cf);
      if (v8 == SOSPeerInfoGetTypeID()) {
        CFTypeRef v9 = cf;
      }
      else {
        CFTypeRef v9 = 0LL;
      }
      CFTypeID v10 = *(__CFArray **)(a1 + 32);
      CFTypeRef PeerID = (CFTypeRef)SOSPeerInfoGetPeerID(v9);
      uint64_t v5 = v10;
      goto LABEL_9;
    }
  }

  int v11 = sub_10001267C("SecError");
  int v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 138412290;
    CFTypeRef v14 = cf;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Bad element, skipping: %@",  (uint8_t *)&v13,  0xCu);
  }
}

void sub_1001C3D44(uint64_t a1)
{
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  CFTypeRef v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  CFTypeID v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCRequestSyncWithPeersList",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v33 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCRequestSyncWithPeersList  enableTelemetry=YES ",  buf,  0xCu);
  }

  CFArrayRef v21 = sub_1001141B8(kCFAllocatorDefault, v14, v15, v16, v17, v18, v19, v20, 0LL);
  sub_100012EDC(*(const __CFArray **)(a1 + 32), @"[", @"]", (uint64_t)&stru_100293588);
  uint64_t v22 = *(void *)(a1 + 32);
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(-32768LL, 0LL);
  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(global_queue);
  SOSCloudKeychainRequestSyncWithPeers(v22, v21, v24, 0LL);

  if (v21) {
    CFRelease(v21);
  }
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v26 = _OctagonSignpostLogSystem(Nanoseconds);
  uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
  id v28 = v27;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v27))
  {
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v33) = 1;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v28,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCRequestSyncWithPeersList",  " SOSSignpostNameSOSCCRequestSyncWithPeersList=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRequest SyncWithPeersList}d ",  buf,  8u);
  }

  uint64_t v30 = _OctagonSignpostLogSystem(v29);
  CFTypeRef v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v33 = v4;
    __int16 v34 = 2048;
    double v35 = (double)Nanoseconds / 1000000000.0;
    __int16 v36 = 1026;
    int v37 = 1;
    _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCRequestSyncWithPeersList  SOSSignpostNameSOSCCRequestSyncWithPeersList=%{public,signpost.tele metry:number1,name=SOSSignpostNameSOSCCRequestSyncWithPeersList}d ",  buf,  0x1Cu);
  }
}

void sub_1001C3FD4(id a1, __CFString *a2)
{
  uint64_t v3 = sub_10001267C("syncwith");
  os_signpost_id_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 138412290;
    uint64_t v6 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Request Sync With: %@", (uint8_t *)&v5, 0xCu);
  }
}

void sub_1001C407C(id a1)
{
  if (!qword_1002DEE88)
  {
    uint64_t v1 = MGCopyAnswer(@"DeviceName", 0LL);
    uint64_t v2 = @"Unknown model";
    if (v1) {
      uint64_t v2 = (const __CFString *)v1;
    }
    qword_1002DEE88 = (uint64_t)v2;
  }

void sub_1001C40C4(uint64_t a1, void *a2)
{
  id v3 = a2;
  os_signpost_id_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);

  if (v4)
  {
    CFDictionaryRef v5 = sub_1001C24C0(*(const __SCDynamicStore **)(a1 + 32));
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v6 trust]);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
    unsigned int v9 = [v7 updateGestalt:v8 newGestalt:v5];

    if (v9)
    {
      CFTypeID v10 = sub_10001267C("circleOps");
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v12 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "Changed our peer's gestalt information.  This is not a circle change.",  v12,  2u);
      }
    }

    if (v5) {
      CFRelease(v5);
    }
  }
}

void *sub_1001C41CC(uint64_t a1, uint64_t a2)
{
  id v2 = sub_1001C2128(1LL, a2);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  if (!v3)
  {
    os_signpost_id_t v4 = sub_10001267C("secAccount");
    CFDictionaryRef v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Failed request for account object", v7, 2u);
    }
  }

  return v3;
}

uint64_t sub_1001C4254(uint64_t a1, int a2, CFTypeRef *a3)
{
  uint64_t v7 = 0LL;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000LL;
  int v10 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_1001C4300;
  void v5[3] = &unk_100293198;
  int v6 = a2;
  void v5[4] = &v7;
  void v5[5] = a1;
  void v5[6] = a3;
  sub_1001C44A8(a3, v5);
  uint64_t v3 = *((unsigned int *)v8 + 6);
  _Block_object_dispose(&v7, 8);
  return v3;
}

void sub_1001C42E8(_Unwind_Exception *a1)
{
}

uint64_t sub_1001C4300(uint64_t a1, void *a2)
{
  id v3 = a2;
  os_signpost_id_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  unsigned int v5 = [v4 SOSMonitorModeSOSIsActive];

  if (!v5)
  {
LABEL_11:
    uint64_t v11 = 0LL;
    goto LABEL_12;
  }

  int v6 = *(_DWORD *)(a1 + 56);
  if (v6 == 1 || v6 == 2)
  {
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 trust]);
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
    unsigned int v10 = [v8 updateView:v9 name:*(void *)(a1 + 40) code:*(unsigned int *)(a1 + 56) err:*(void *)(a1 + 48)];
    goto LABEL_7;
  }

  if (v6 != 3)
  {
    uint64_t v12 = sub_10001267C("views");
    int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = *(_DWORD *)(a1 + 56);
      v16[0] = 67109120;
      v16[1] = v14;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "Bad SOSViewActionCode - %d",  (uint8_t *)v16,  8u);
    }

    goto LABEL_11;
  }

  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 trust]);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  unsigned int v10 = [v8 viewStatus:v9 name:*(void *)(a1 + 40) err:*(void *)(a1 + 48)];
LABEL_7:
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v10;

  uint64_t v11 = 1LL;
LABEL_12:

  return v11;
}

BOOL sub_1001C44A8(CFTypeRef *a1, void *a2)
{
  uint64_t v14 = 0LL;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2020000000LL;
  char v17 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  uint64_t v9 = sub_1001C45F0;
  unsigned int v10 = &unk_100293950;
  uint64_t v12 = &v14;
  id v3 = a2;
  id v11 = v3;
  int v13 = a1;
  os_signpost_id_t v4 = v8;
  int v18 = -1431655766;
  uint64_t v5 = sub_1000053C4(0, &v18);
  if (sub_1000190E4(v5, a1, @"aks_get_lock_state failed: %x", v5))
  {
    if ((v18 & 4) != 0)
    {
      v9((uint64_t)v4);

      BOOL v6 = *((_BYTE *)v15 + 24) != 0;
      goto LABEL_5;
    }

    SOSCreateErrorWithFormat(4LL, 0LL, a1, 0LL, @"Keybag never unlocked, ask after first unlock");
  }

  BOOL v6 = 0LL;
LABEL_5:

  _Block_object_dispose(&v14, 8);
  return v6;
}

void sub_1001C45D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
}

void sub_1001C45F0(uint64_t a1)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  void v4[2] = sub_1001C4670;
  void v4[3] = &unk_100293928;
  __int128 v3 = *(_OWORD *)(a1 + 32);
  id v2 = (id)v3;
  __int128 v5 = v3;
  uint64_t v6 = *(void *)(a1 + 48);
  sub_1001C3588(v4);
}

uint64_t sub_1001C4670(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = result;
  return result;
}

BOOL sub_1001C46A8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = _OctagonSignpostLogSystem(a1);
  __int128 v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  os_signpost_id_t v6 = _OctagonSignpostCreate();
  uint64_t v8 = v7;

  uint64_t v10 = _OctagonSignpostLogSystem(v9);
  id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
  uint64_t v12 = v11;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_INTERVAL_BEGIN,  v6,  "SOSCCViewSet",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v14 = _OctagonSignpostLogSystem(v13);
  uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v27 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCViewSet  enableTelemetry=YES ",  buf,  0xCu);
  }

  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472LL;
  v25[2] = sub_1001C4904;
  v25[3] = &unk_1002931D8;
  v25[4] = a1;
  v25[5] = a2;
  BOOL v16 = sub_1001C44A8(0LL, v25);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v6, v8);
  uint64_t v18 = _OctagonSignpostLogSystem(Nanoseconds);
  uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
  uint64_t v20 = v19;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v19))
  {
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v27) = v16;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_INTERVAL_END,  v6,  "SOSCCViewSet",  " SOSSignpostNameSOSCCViewSet=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCViewSet}d ",  buf,  8u);
  }

  uint64_t v22 = _OctagonSignpostLogSystem(v21);
  int v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v27 = v6;
    __int16 v28 = 2048;
    double v29 = (double)Nanoseconds / 1000000000.0;
    __int16 v30 = 1026;
    BOOL v31 = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCViewSet  SOSSignpostNameSOSCCViewSet=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCViewSet}d ",  buf,  0x1Cu);
  }

  return v16;
}

id sub_1001C4904(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (SOSVisibleKeychainNotAllowed()
    && (uint64_t v4 = *(const __CFSet **)(a1 + 32)) != 0LL
    && CFSetGetCount(v4)
    && SOSViewSetIntersectsV0(*(void *)(a1 + 32)))
  {
    __int128 v5 = sub_10001267C("views");
    os_signpost_id_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Cannot enable visible keychain views due to profile restrictions",  buf,  2u);
    }

    id v7 = 0LL;
  }

  else
  {
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472LL;
    v12[2] = sub_1001C4A44;
    void v12[3] = &unk_1002931B8;
    uint64_t v8 = *(const __CFSet **)(a1 + 32);
    void v12[4] = *(void *)(a1 + 40);
    sub_1000130AC(v8, (uint64_t)v12);
    os_signpost_id_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue([v3 account]);
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(-[os_log_s trust](v6, "trust"));
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
    id v7 = [v9 updateViewSets:v10 enabled:*(void *)(a1 + 32) disabled:*(void *)(a1 + 40)];
  }

  return v7;
}

void sub_1001C4A44(uint64_t a1, uint64_t a2)
{
  id v2 = *(const __CFSet **)(a1 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1001C4A98;
  v3[3] = &unk_1002931B8;
  void v3[4] = a2;
  sub_1000130AC(v2, (uint64_t)v3);
}

void sub_1001C4A98(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10001267C("viewChange");
  __int128 v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    int v7 = 138412546;
    uint64_t v8 = v6;
    __int16 v9 = 2112;
    uint64_t v10 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Calling updateViewSets to enable %@ and disable %@",  (uint8_t *)&v7,  0x16u);
  }
}

void sub_1001C4B5C(uint64_t a1)
{
  char v1 = a1;
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  __int16 v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  uint64_t v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    LOWORD(buf) = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SyncTheLastDataToKVS",  " enableTelemetry=YES ",  (uint8_t *)&buf,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SyncTheLastDataToKVS  enableTelemetry=YES ",  (uint8_t *)&buf,  0xCu);
  }

  *(void *)&__int128 buf = 0LL;
  *((void *)&buf + 1) = &buf;
  uint64_t v39 = 0x2020000000LL;
  uint64_t v40 = 0LL;
  dispatch_semaphore_t v14 = dispatch_semaphore_create(0LL);
  uint64_t v15 = sub_10001267C("force-push");
  BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFTypeID v32 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "calling SOSCloudKeychainSynchronizeAndWait",  v32,  2u);
  }

  dispatch_queue_global_t global_queue = dispatch_get_global_queue(-2LL, 0LL);
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(global_queue);
  v29[0] = _NSConcreteStackBlock;
  v29[1] = 3221225472LL;
  v29[2] = sub_1001C4ECC;
  v29[3] = &unk_100293200;
  p___int128 buf = &buf;
  uint64_t v19 = v14;
  __int16 v30 = v19;
  SOSCloudKeychainSynchronizeAndWait(v18, v29);

  if ((v1 & 1) != 0) {
    dispatch_time_t v20 = -1LL;
  }
  else {
    dispatch_time_t v20 = dispatch_time(0LL, 60000000000LL);
  }
  dispatch_semaphore_wait(v19, v20);

  uint64_t v21 = *(void *)(*((void *)&buf + 1) + 24LL);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v23 = _OctagonSignpostLogSystem(Nanoseconds);
  uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
  uint64_t v25 = v24;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v24))
  {
    *(_DWORD *)CFTypeID v32 = 67240192;
    LODWORD(v33) = v21 == 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v25,  OS_SIGNPOST_INTERVAL_END,  v4,  "SyncTheLastDataToKVS",  " SOSSignpostNameSyncTheLastDataToKVS=%{public,signpost.telemetry:number1,name=SOSSignpostNameSyncTheLastDataToKVS}d ",  v32,  8u);
  }

  uint64_t v27 = _OctagonSignpostLogSystem(v26);
  __int16 v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)CFTypeID v32 = 134218496;
    os_signpost_id_t v33 = v4;
    __int16 v34 = 2048;
    double v35 = (double)Nanoseconds / 1000000000.0;
    __int16 v36 = 1026;
    BOOL v37 = v21 == 0;
    _os_log_impl( (void *)&_mh_execute_header,  v28,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SyncTheLastDataToKVS  SOSSignpostNameSyncTheLastDataToKVS=%{public,signpost.telemetry:number1,name =SOSSignpostNameSyncTheLastDataToKVS}d ",  v32,  0x1Cu);
  }

  _Block_object_dispose(&buf, 8);
}

void sub_1001C4EA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t sub_1001C4ECC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v5 = sub_10001267C("SecError");
    uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138412290;
      uint64_t v12 = a3;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "SOSCloudKeychainSynchronizeAndWait: %@",  (uint8_t *)&v11,  0xCu);
    }

    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = a3;
  }

  else
  {
    uint64_t v8 = sub_10001267C("force-push");
    __int16 v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138412290;
      uint64_t v12 = a2;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "returned from call; in callback to SOSCloudKeychainSynchronizeAndWait: results: %@",
        (uint8_t *)&v11,
        0xCu);
    }
  }

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t sub_1001C4FF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = sub_10001267C("updates");
  __int16 v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412546;
    uint64_t v13 = a3;
    __int16 v14 = 2112;
    uint64_t v15 = a1;
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Trying credentials and dsid (%@) for %@",  buf,  0x16u);
  }

  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472LL;
  v11[2] = sub_1001C5108;
  v11[3] = &unk_100293248;
  void v11[4] = a3;
  void v11[5] = a1;
  void v11[6] = a2;
  return SOSDoWithCredentialsWhileUnlocked(a4, v11);
}

uint64_t sub_1001C5108(uint64_t a1, uint64_t a2)
{
  uint64_t v35 = 0LL;
  __int16 v36 = &v35;
  uint64_t v37 = 0x2020000000LL;
  char v38 = 0;
  uint64_t v4 = _OctagonSignpostLogSystem(a1);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  os_signpost_id_t v6 = _OctagonSignpostCreate();
  uint64_t v8 = v7;

  uint64_t v10 = _OctagonSignpostLogSystem(v9);
  int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
  uint64_t v12 = v11;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_INTERVAL_BEGIN,  v6,  "SOSCCTryUserCredentials",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v14 = _OctagonSignpostLogSystem(v13);
  uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v40 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCTryUserCredentials  enableTelemetry=YES ",  buf,  0xCu);
  }

  v32[0] = _NSConcreteStackBlock;
  v32[1] = 3221225472LL;
  v32[2] = sub_1001C54B0;
  v32[3] = &unk_100293228;
  uint8_t v32[4] = &v35;
  __int128 v33 = *(_OWORD *)(a1 + 32);
  uint64_t v34 = *(void *)(a1 + 48);
  sub_1001C3588(v32);
  if (!*((_BYTE *)v36 + 24))
  {
    BOOL v16 = sub_10001267C("updates");
    char v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "SOSCCTryUserCredentials_Server: Trying again with EFRESH",  buf,  2u);
    }

    if (sub_1001C567C(a2) && sub_1001C59C0(a2))
    {
      sleep(1u);
      v29[0] = _NSConcreteStackBlock;
      v29[1] = 3221225472LL;
      v29[2] = sub_1001C5DA0;
      v29[3] = &unk_100293228;
      void v29[4] = &v35;
      __int128 v30 = *(_OWORD *)(a1 + 40);
      uint64_t v31 = a2;
      sub_1001C3588(v29);
    }
  }

  sub_1001C59C0(0LL);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v6, v8);
  uint64_t v19 = _OctagonSignpostLogSystem(Nanoseconds);
  dispatch_time_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
  uint64_t v21 = v20;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v20))
  {
    int v22 = *((unsigned __int8 *)v36 + 24);
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v40) = v22;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v21,  OS_SIGNPOST_INTERVAL_END,  v6,  "SOSCCTryUserCredentials",  " SOSSignpostNameSOSCCTryUserCredentials=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCTryUserCredentials}d ",  buf,  8u);
  }

  uint64_t v24 = _OctagonSignpostLogSystem(v23);
  uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    int v26 = *((unsigned __int8 *)v36 + 24);
    os_signpost_id_t v40 = v6;
    __int16 v41 = 2048;
    double v42 = (double)Nanoseconds / 1000000000.0;
    __int16 v43 = 1026;
    int v44 = v26;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCTryUserCredentials  SOSSignpostNameSOSCCTryUserCredentials=%{public,signpost.telemetry:number 1,name=SOSSignpostNameSOSCCTryUserCredentials}d ",  buf,  0x1Cu);
  }

  uint64_t v27 = *((unsigned __int8 *)v36 + 24);
  _Block_object_dispose(&v35, 8);
  return v27;
}

void sub_1001C5478( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

void sub_1001C54B0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(const __CFString **)(a1 + 40);
  if (v4 && CFStringCompare(v4, &stru_100294B48, 0LL))
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
    sub_1001905A8(v5, *(void *)(a1 + 40));
  }

  os_signpost_id_t v6 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v6 accountKeyDerivationParameters]);

  if (v7)
  {
    CFTypeRef cf = 0LL;
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = sub_10019AAC0( v8,  *(void *)(a1 + 48),  *(const __CFData **)(a1 + 56),  &cf);

    CFTypeRef v9 = cf;
    if (*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)) {
      BOOL v10 = 1;
    }
    else {
      BOOL v10 = cf == 0LL;
    }
    if (!v10)
    {
      int v11 = sub_10001267C("updates");
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFTypeRef v17 = cf;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Failed with SOSAccountTryUserCredentials() with initial known parameters %@",  buf,  0xCu);
      }

      CFTypeRef v9 = cf;
    }

    if (v9)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v9);
    }
  }

  else
  {
    uint64_t v13 = sub_10001267C("updates");
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "SOSCCTryUserCredentials_Server: No known parameters",  buf,  2u);
    }
  }
}

BOOL sub_1001C567C(uint64_t a1)
{
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  CFTypeRef v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  BOOL v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    LOWORD(buf) = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SyncKVSAndWait",  " enableTelemetry=YES ",  (uint8_t *)&buf,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SyncKVSAndWait  enableTelemetry=YES ",  (uint8_t *)&buf,  0xCu);
  }

  dispatch_semaphore_t v14 = dispatch_semaphore_create(0LL);
  *(void *)&__int128 buf = 0LL;
  *((void *)&buf + 1) = &buf;
  uint64_t v40 = 0x2020000000LL;
  char v41 = 0;
  uint64_t v15 = sub_10001267C("fresh");
  BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 v33 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "EFP calling SOSCloudKeychainSynchronizeAndWait",  v33,  2u);
  }

  activity_block[0] = _NSConcreteStackBlock;
  activity_block[1] = 3221225472LL;
  activity_block[2] = sub_1001C5F0C;
  activity_block[3] = &unk_1002939C8;
  p___int128 buf = &buf;
  uint64_t v32 = a1;
  CFTypeRef v17 = v14;
  __int128 v30 = v17;
  _os_activity_initiate((void *)&_mh_execute_header, "CloudCircle EFRESH", OS_ACTIVITY_FLAG_DEFAULT, activity_block);

  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v19 = _OctagonSignpostLogSystem(Nanoseconds);
  dispatch_time_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
  uint64_t v21 = v20;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v20))
  {
    int v22 = *(unsigned __int8 *)(*((void *)&buf + 1) + 24LL);
    *(_DWORD *)__int128 v33 = 67240192;
    LODWORD(v34) = v22;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v21,  OS_SIGNPOST_INTERVAL_END,  v4,  "SyncKVSAndWait",  " SOSSignpostNameSyncKVSAndWait=%{public,signpost.telemetry:number1,name=SOSSignpostNameSyncKVSAndWait}d ",  v33,  8u);
  }

  uint64_t v24 = _OctagonSignpostLogSystem(v23);
  uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 v33 = 134218496;
    int v26 = *(unsigned __int8 *)(*((void *)&buf + 1) + 24LL);
    os_signpost_id_t v34 = v4;
    __int16 v35 = 2048;
    double v36 = (double)Nanoseconds / 1000000000.0;
    __int16 v37 = 1026;
    int v38 = v26;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SyncKVSAndWait  SOSSignpostNameSyncKVSAndWait=%{public,signpost.telemetry:number1,name=SOSSignpost NameSyncKVSAndWait}d ",  v33,  0x1Cu);
  }

  BOOL v27 = *(_BYTE *)(*((void *)&buf + 1) + 24LL) != 0;
  _Block_object_dispose(&buf, 8);

  return v27;
}

void sub_1001C5998( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

BOOL sub_1001C59C0(uint64_t a1)
{
  uint64_t v38 = 0LL;
  uint64_t v39 = &v38;
  uint64_t v40 = 0x2020000000LL;
  char v41 = 0;
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  CFTypeRef v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  BOOL v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "Flush",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v43 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: Flush  enableTelemetry=YES ",  buf,  0xCu);
  }

  dispatch_semaphore_t v14 = dispatch_semaphore_create(0LL);
  uint64_t v15 = sub_10001267C("flush");
  BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Starting", buf, 2u);
  }

  dispatch_queue_global_t global_queue = dispatch_get_global_queue(-2LL, 0LL);
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(global_queue);
  v34[0] = _NSConcreteStackBlock;
  v34[1] = 3221225472LL;
  v34[2] = sub_1001C5EA0;
  v34[3] = &unk_1002939A0;
  double v36 = &v38;
  uint64_t v37 = a1;
  uint64_t v19 = v14;
  __int16 v35 = v19;
  SOSCloudKeychainFlush(v18, v34);

  dispatch_semaphore_wait(v19, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_time_t v20 = sub_10001267C("flush");
  uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    if (*((_BYTE *)v39 + 24)) {
      int v22 = "Success";
    }
    else {
      int v22 = "Failure";
    }
    *(_DWORD *)__int128 buf = 136315138;
    os_signpost_id_t v43 = (os_signpost_id_t)v22;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Returned %s", buf, 0xCu);
  }

  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v24 = _OctagonSignpostLogSystem(Nanoseconds);
  uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
  int v26 = v25;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v25))
  {
    int v27 = *((unsigned __int8 *)v39 + 24);
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v43) = v27;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v26,  OS_SIGNPOST_INTERVAL_END,  v4,  "Flush",  " SOSSignpostNameFlush=%{public,signpost.telemetry:number1,name=SOSSignpostNameFlush}d ",  buf,  8u);
  }

  uint64_t v29 = _OctagonSignpostLogSystem(v28);
  __int128 v30 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    int v31 = *((unsigned __int8 *)v39 + 24);
    os_signpost_id_t v43 = v4;
    __int16 v44 = 2048;
    double v45 = (double)Nanoseconds / 1000000000.0;
    __int16 v46 = 1026;
    int v47 = v31;
    _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: Flush  SOSSignpostNameFlush=%{public,signpost.telemetry:number1,name=SOSSignpostNameFlush}d ",  buf,  0x1Cu);
  }

  BOOL v32 = *((_BYTE *)v39 + 24) != 0;
  _Block_object_dispose(&v38, 8);
  return v32;
}

void sub_1001C5D68( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1001C5DA0(uint64_t a1, void *a2)
{
  id v3 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = sub_10019AAC0( v3,  *(void *)(a1 + 40),  *(const __CFData **)(a1 + 48),  *(CFTypeRef **)(a1 + 56));

  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    os_signpost_id_t v4 = *(void **)(a1 + 56);
    if (v4)
    {
      if (*v4)
      {
        uint64_t v5 = sub_10001267C("updates");
        uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v7 = **(void **)(a1 + 56);
          int v8 = 138412290;
          uint64_t v9 = v7;
          _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "Failed with SOSAccountTryUserCredentials() %@",  (uint8_t *)&v8,  0xCu);
        }
      }
    }
  }

uint64_t sub_1001C5EA0(uint64_t a1, int a2, CFTypeRef cf)
{
  os_signpost_id_t v4 = *(CFTypeRef **)(a1 + 48);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = cf == 0LL;
  if (v4)
  {
    CFTypeRef v6 = *v4;
    if (*v4 != cf)
    {
      if (!cf || (CFRetain(cf), (CFTypeRef v6 = *v4) != 0LL)) {
        CFRelease(v6);
      }
      *os_signpost_id_t v4 = cf;
    }
  }

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_1001C5F0C(uint64_t a1)
{
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(-2LL, 0LL);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(global_queue);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  _DWORD v10[2] = sub_1001C6070;
  v10[3] = &unk_1002939A0;
  uint64_t v12 = *(void *)(a1 + 48);
  __int128 v9 = *(_OWORD *)(a1 + 32);
  id v4 = (id)v9;
  __int128 v11 = v9;
  SOSCloudKeychainSynchronizeAndWait(v3, v10);

  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 32), 0xFFFFFFFFFFFFFFFFLL);
  uint64_t v5 = sub_10001267C("fresh");
  CFTypeRef v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void **)(a1 + 48);
    if (*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL)) {
      int v8 = "success";
    }
    else {
      int v8 = "failure";
    }
    if (v7) {
      uint64_t v7 = (void *)*v7;
    }
    *(_DWORD *)__int128 buf = 136315394;
    dispatch_semaphore_t v14 = v8;
    __int16 v15 = 2112;
    BOOL v16 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "EFP complete: %s %@", buf, 0x16u);
  }
}

uint64_t sub_1001C6070(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v5 = sub_10001267C("fresh");
  CFTypeRef v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = 138412290;
    __int128 v11 = a3;
    _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "EFP returned, callback error: %@",  (uint8_t *)&v10,  0xCu);
  }

  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = a3 == 0LL;
  uint64_t v7 = *(const void ***)(a1 + 48);
  if (v7)
  {
    int v8 = *v7;
    if (*v7 != a3)
    {
      if (!a3 || (CFRetain(a3), (int v8 = *v7) != 0LL)) {
        CFRelease(v8);
      }
      *uint64_t v7 = a3;
    }
  }

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t sub_1001C6174(uint64_t a1, uint64_t a2, os_signpost_id_t a3, uint64_t *a4)
{
  int v8 = sub_10001267C("updates");
  __int128 v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412802;
    os_signpost_id_t v37 = a3;
    __int16 v38 = 2112;
    double v39 = *(double *)&a1;
    __int16 v40 = 1024;
    uid_t v41 = getuid();
    _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Setting credentials and dsid (%@) for %@.  UID is %d",  buf,  0x1Cu);
  }

  uint64_t v11 = _OctagonSignpostLogSystem(v10);
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
  os_signpost_id_t v13 = _OctagonSignpostCreate();
  uint64_t v15 = v14;

  uint64_t v17 = _OctagonSignpostLogSystem(v16);
  uint64_t v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
  uint64_t v19 = v18;
  if (v13 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v18))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v19,  OS_SIGNPOST_INTERVAL_BEGIN,  v13,  "AssertUserCredentialsAndOptionalDSID",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v21 = _OctagonSignpostLogSystem(v20);
  int v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v37 = v13;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: AssertUserCredentialsAndOptionalDSID  enableTelemetry=YES ",  buf,  0xCu);
  }

  v35[0] = _NSConcreteStackBlock;
  v35[1] = 3221225472LL;
  v35[2] = sub_1001C64E0;
  v35[3] = &unk_100293248;
  v35[4] = a3;
  void v35[5] = a1;
  v35[6] = a2;
  uint64_t v23 = SOSDoWithCredentialsWhileUnlocked(a4, v35);
  uint64_t v24 = sub_10001267C("updates");
  uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    if (a4) {
      uint64_t v26 = *a4;
    }
    else {
      uint64_t v26 = 0LL;
    }
    *(_DWORD *)__int128 buf = 138413058;
    os_signpost_id_t v37 = a3;
    __int16 v38 = 2112;
    double v39 = *(double *)&a1;
    __int16 v40 = 1024;
    uid_t v41 = v23;
    __int16 v42 = 2112;
    uint64_t v43 = v26;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "Complete credentials and dsid (%@) for %@: %d %@",  buf,  0x26u);
  }

  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v13, v15);
  uint64_t v28 = _OctagonSignpostLogSystem(Nanoseconds);
  uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);
  __int128 v30 = v29;
  if (v13 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v29))
  {
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v37) = v23;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v30,  OS_SIGNPOST_INTERVAL_END,  v13,  "AssertUserCredentialsAndOptionalDSID",  " SOSSignpostNameAssertUserCredentialsAndOptionalDSID=%{public,signpost.telemetry:number1,name=SOSSignpostNameAsser tUserCredentialsAndOptionalDSID}d ",  buf,  8u);
  }

  uint64_t v32 = _OctagonSignpostLogSystem(v31);
  __int128 v33 = (os_log_s *)objc_claimAutoreleasedReturnValue(v32);
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v37 = v13;
    __int16 v38 = 2048;
    double v39 = (double)Nanoseconds / 1000000000.0;
    __int16 v40 = 1026;
    uid_t v41 = v23;
    _os_log_impl( (void *)&_mh_execute_header,  v33,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: AssertUserCredentialsAndOptionalDSID  SOSSignpostNameAssertUserCredentialsAndOptionalDSID=%{public ,signpost.telemetry:number1,name=SOSSignpostNameAssertUserCredentialsAndOptionalDSID}d ",  buf,  0x1Cu);
  }

  return v23;
}

BOOL sub_1001C64E0(uint64_t a1, uint64_t a2)
{
  v18[0] = 0LL;
  v18[1] = v18;
  v18[2] = 0x2020000000LL;
  char v19 = 0;
  uint64_t v14 = 0LL;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2020000000LL;
  char v17 = 0;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  _DWORD v10[2] = sub_1001C6688;
  v10[3] = &unk_1002939F0;
  void v10[4] = v18;
  void v10[5] = &v14;
  __int128 v11 = *(_OWORD *)(a1 + 32);
  uint64_t v12 = *(void *)(a1 + 48);
  uint64_t v13 = a2;
  sub_1001C3588(v10);
  if (*((_BYTE *)v15 + 24))
  {
    BOOL v4 = 1LL;
  }

  else
  {
    if (sub_1001C567C(0LL) && sub_1001C59C0(0LL))
    {
      sleep(1u);
      v7[0] = _NSConcreteStackBlock;
      v7[1] = 3221225472LL;
      void v7[2] = sub_1001C6770;
      void v7[3] = &unk_100293228;
      void v7[4] = &v14;
      __int128 v8 = *(_OWORD *)(a1 + 40);
      uint64_t v9 = a2;
      sub_1001C3588(v7);
    }

    if (*((_BYTE *)v15 + 24) && sub_1001C59C0(0LL))
    {
      v6[0] = _NSConcreteStackBlock;
      v6[1] = 3221225472LL;
      v6[2] = sub_1001C6B64;
      v6[3] = &unk_100293A18;
      void v6[4] = &v14;
      sub_1001C3588(v6);
    }

    BOOL v4 = *((_BYTE *)v15 + 24) != 0;
  }

  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(v18, 8);
  return v4;
}

void sub_1001C6664(_Unwind_Exception *a1)
{
}

void sub_1001C6688(uint64_t a1, void *a2)
{
  id v9 = a2;
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v9 account]);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = sub_1001905A8(v3, *(void *)(a1 + 48));

  if (!*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    BOOL v4 = (void *)objc_claimAutoreleasedReturnValue([v9 account]);
    uint64_t v5 = objc_claimAutoreleasedReturnValue([v4 accountKeyDerivationParameters]);
    if (!v5)
    {
LABEL_5:

      goto LABEL_6;
    }

    CFTypeRef v6 = (void *)v5;
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v9 account]);
    unsigned int v8 = [v7 accountKeyIsTrusted];

    if (v8)
    {
      BOOL v4 = (void *)objc_claimAutoreleasedReturnValue([v9 account]);
      *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = sub_10019AAC0( v4,  *(void *)(a1 + 56),  *(const __CFData **)(a1 + 64),  *(CFTypeRef **)(a1 + 72));
      goto LABEL_5;
    }
  }

void sub_1001C6770(void *a1, void *a2)
{
  id v3 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  uint64_t v4 = a1[5];
  uint64_t v5 = (const __CFData *)a1[6];
  CFTypeRef v6 = (CFTypeRef *)a1[7];
  id v29 = v3;
  int v7 = [v29 accountKeyIsTrusted];
  [v29 setAccountKeyIsTrusted:0];
  if ((sub_10019A838(v29, v5, v6) & 1) != 0)
  {
    __int128 v11 = 0LL;
    CFMutableArrayRef Mutable = 0LL;
    goto LABEL_16;
  }

  if (CFDataGetLength(v5) >= 21)
  {
    unsigned int v8 = sub_10001267C("SecWarning");
    id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "Long password (>20 byte utf8) being used to derive account key  this may be a PET by mistake!!",  buf,  2u);
    }
  }

  memset(buf, 170, 16);
  if (SecRandomCopyBytes(0LL, 0x10uLL, buf))
  {
    SOSCreateError(1028LL, @"SecRandomCopyBytes failed", 0LL, v6);
LABEL_8:
    CFMutableArrayRef Mutable = 0LL;
    goto LABEL_9;
  }

  CFMutableArrayRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0LL);
  uint64_t v18 = ccder_sizeof_raw_octet_string(16LL);
  uint64_t v19 = ccder_sizeof_uint64(50000LL) + v18;
  uint64_t v20 = v19 + ccder_sizeof_uint64(256LL);
  uint64_t v21 = ccder_sizeof(6LL, CSSMOID_PKCS5_HMAC_SHA1.Length);
  CFIndex v22 = ccder_sizeof(0x2000000000000010LL, v20 + v21);
  CFDataSetLength(Mutable, v22);
  BytePtr = CFDataGetBytePtr(Mutable);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  uint64_t v25 = &MutableBytePtr[CFDataGetLength(Mutable)];
  uint64_t v26 = ccder_encode_body(CSSMOID_PKCS5_HMAC_SHA1.Length, CSSMOID_PKCS5_HMAC_SHA1.Data, BytePtr, v25);
  ccder_encode_tl(6LL, CSSMOID_PKCS5_HMAC_SHA1.Length, BytePtr, v26);
  ccder_encode_uint64(256LL);
  uint64_t v27 = ccder_encode_uint64(50000LL);
  uint64_t v28 = ccder_encode_raw_octet_string(16LL, buf, BytePtr, v27);
  if (ccder_encode_constructed_tl(0x2000000000000010LL, v25, BytePtr, v28))
  {
    if (Mutable) {
      sub_1001965A8((uint64_t)@"SOSUserKeyCreateGenerateParameters created new parameters:", Mutable);
    }
    goto LABEL_9;
  }

  if (Mutable)
  {
    CFRelease(Mutable);
    goto LABEL_8;
  }

void sub_1001C6B64(uint64_t a1, void *a2)
{
  id v3 = (id)objc_claimAutoreleasedReturnValue([a2 account]);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = sub_10019969C(v3, 0LL);
}

uint64_t sub_1001C6BB0(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return sub_1001C6174(a1, a2, 0LL, a3);
}

BOOL sub_1001C6BBC(CFTypeRef *a1)
{
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  uint64_t v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    LOWORD(v25) = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCCanAuthenticate",  " enableTelemetry=YES ",  (uint8_t *)&v25,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    int v25 = 134217984;
    os_signpost_id_t v26 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCCanAuthenticate  enableTelemetry=YES ",  (uint8_t *)&v25,  0xCu);
  }

  BOOL v14 = sub_1001C44A8(a1, &stru_100293288);
  BOOL v15 = v14;
  if (a1)
  {
    if (!v14)
    {
      if (*a1)
      {
        if (CFErrorGetDomain((CFErrorRef)*a1) == (CFErrorDomain)kSOSErrorDomain
          && (unint64_t)(CFErrorGetCode((CFErrorRef)*a1) - 1) <= 1)
        {
          CFTypeRef v16 = *a1;
          if (*a1)
          {
            *a1 = 0LL;
            CFRelease(v16);
          }
        }
      }
    }
  }

  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v18 = _OctagonSignpostLogSystem(Nanoseconds);
  uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
  uint64_t v20 = v19;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v19))
  {
    int v25 = 67240192;
    LODWORD(v26) = v15;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCCanAuthenticate",  " SOSSignpostNameSOSCCCanAuthenticate=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCanAuthenticate}d ",  (uint8_t *)&v25,  8u);
  }

  uint64_t v22 = _OctagonSignpostLogSystem(v21);
  uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    int v25 = 134218496;
    os_signpost_id_t v26 = v4;
    __int16 v27 = 2048;
    double v28 = (double)Nanoseconds / 1000000000.0;
    __int16 v29 = 1026;
    BOOL v30 = v15;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCCanAuthenticate  SOSSignpostNameSOSCCCanAuthenticate=%{public,signpost.telemetry:number1,name =SOSSignpostNameSOSCCCanAuthenticate}d ",  (uint8_t *)&v25,  0x1Cu);
  }

  return v15;
}

BOOL sub_1001C6E34(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  os_signpost_id_t v4 = a2;
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](v4, "account"));
  sub_10019987C(v5);

  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](v4, "account"));
  LOBYTE(a3) = sub_100199708(v6, (uint64_t)a3) != 0LL;

  return (char)a3;
}

BOOL sub_1001C6EA4(CFTypeRef *a1)
{
  return sub_1001C44A8(a1, &stru_1002932A8);
}

BOOL sub_1001C6EB0(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  id v3 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](a2, "account", a3));
  sub_100199760(v3);

  return 1;
}

uint64_t sub_1001C6EE4(CFTypeRef *a1)
{
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000LL;
  int v7 = -1;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1001C6F94;
  v3[3] = &unk_1002932D0;
  void v3[4] = &v4;
  if (sub_1001C44A8(a1, v3)) {
    uint64_t v1 = *((unsigned int *)v5 + 6);
  }
  else {
    uint64_t v1 = 0xFFFFFFFFLL;
  }
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1001C6F7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1001C6F94(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = [v5 getCircleStatus:a3];

  return 1LL;
}

BOOL sub_1001C6FE8(CFTypeRef *a1)
{
  v24[0] = 0LL;
  v24[1] = v24;
  void v24[2] = 0x2020000000LL;
  char v25 = 1;
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  uint64_t v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCRequestToJoinCircle",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v27 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCRequestToJoinCircle  enableTelemetry=YES ",  buf,  0xCu);
  }

  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472LL;
  void v23[2] = sub_1001C72A4;
  void v23[3] = &unk_1002932D0;
  v23[4] = v24;
  BOOL v14 = sub_1001C7358(a1, v23);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v16 = _OctagonSignpostLogSystem(Nanoseconds);
  unsigned __int8 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
  uint64_t v18 = v17;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v17))
  {
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v27) = v14;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v18,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCRequestToJoinCircle",  " SOSSignpostNameSOSCCRequestToJoinCircle=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRequestToJoinCircle}d ",  buf,  8u);
  }

  uint64_t v20 = _OctagonSignpostLogSystem(v19);
  uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v27 = v4;
    __int16 v28 = 2048;
    double v29 = (double)Nanoseconds / 1000000000.0;
    __int16 v30 = 1026;
    BOOL v31 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCRequestToJoinCircle  SOSSignpostNameSOSCCRequestToJoinCircle=%{public,signpost.telemetry:numb er1,name=SOSSignpostNameSOSCCRequestToJoinCircle}d ",  buf,  0x1Cu);
  }

  _Block_object_dispose(v24, 8);
  return v14;
}

void sub_1001C726C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1001C72A4(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = sub_10001267C("circleOps");
  uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v10 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Normal path circle join (SOSAccountJoinCircles)",  v10,  2u);
  }

  char v8 = sub_100191514(v5, 0, a3);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v8;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

BOOL sub_1001C7358(CFTypeRef *a1, void *a2)
{
  CFTypeRef v51 = 0LL;
  uint64_t v47 = 0LL;
  uint64_t v48 = &v47;
  uint64_t v49 = 0x2020000000LL;
  char v50 = 0;
  uint64_t v43 = 0LL;
  __int16 v44 = &v43;
  uint64_t v45 = 0x2020000000LL;
  char v46 = 0;
  uint64_t v39 = 0LL;
  __int16 v40 = &v39;
  uint64_t v41 = 0x2020000000LL;
  CFTypeRef v42 = 0LL;
  v34[0] = _NSConcreteStackBlock;
  v34[1] = 3221225472LL;
  v34[2] = sub_1001C7890;
  v34[3] = &unk_100293AA8;
  double v36 = &v43;
  os_signpost_id_t v37 = &v47;
  id v3 = a2;
  id v35 = v3;
  __int16 v38 = a1;
  BOOL v4 = sub_10001B930(0, &v42, (uint64_t)v34);
  if (v4) {
    goto LABEL_18;
  }
  id v5 = (__CFError *)v40[3];
  if (CFErrorGetCode(v5) != -536870174) {
    goto LABEL_18;
  }
  CFErrorDomain Domain = CFErrorGetDomain(v5);
  if (!Domain || !kCFErrorDomainMach)
  {
    if (Domain == kCFErrorDomainMach) {
      goto LABEL_6;
    }
LABEL_18:
    if (a1)
    {
      if (!*a1)
      {
        uint64_t v10 = (const void *)v40[3];
        if (v10)
        {
          v40[3] = 0LL;
          if (*a1) {
            CFRelease(*a1);
          }
          *a1 = v10;
        }
      }
    }

    uint64_t v11 = (const void *)v40[3];
    if (v11)
    {
      v40[3] = 0LL;
      CFRelease(v11);
    }

    CFTypeRef v12 = v51;
    if (v51)
    {
      CFTypeRef v51 = 0LL;
      CFRelease(v12);
    }

    if (!v4) {
      goto LABEL_64;
    }
    BOOL v13 = *((_BYTE *)v48 + 24) != 0;
    goto LABEL_65;
  }

  if (!CFEqual(Domain, kCFErrorDomainMach)) {
    goto LABEL_18;
  }
LABEL_6:
  if (*((_BYTE *)v44 + 24))
  {
    if (a1)
    {
      if (!*a1)
      {
        uint64_t v7 = (const void *)v40[3];
        if (v7)
        {
          v40[3] = 0LL;
          if (*a1) {
            CFRelease(*a1);
          }
          *a1 = v7;
        }
      }
    }

    char v8 = (const void *)v40[3];
    if (v8)
    {
      v40[3] = 0LL;
      CFRelease(v8);
    }

    CFTypeRef v9 = v51;
    if (!v51) {
      goto LABEL_64;
    }
    goto LABEL_63;
  }

  *(_DWORD *)__int128 buf = -1431655766;
  uint64_t v14 = sub_1000053C4(0, buf);
  if (!sub_1000190E4(v14, &v51, @"aks_get_lock_state failed: %x", v14) || (buf[0] & 1) != 0)
  {
    char v25 = sub_10001267C("while-unlocked-hack");
    os_signpost_id_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue(v25);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      int v53 = (const char *)v51;
      _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "Not trying action, aks bag locked (%@)",  buf,  0xCu);
    }

    if (a1)
    {
      if (!*a1)
      {
        os_signpost_id_t v27 = (const void *)v40[3];
        if (v27)
        {
          v40[3] = 0LL;
          if (*a1) {
            CFRelease(*a1);
          }
          *a1 = v27;
        }
      }
    }

    __int16 v28 = (const void *)v40[3];
    if (v28)
    {
      v40[3] = 0LL;
      CFRelease(v28);
    }

    CFTypeRef v9 = v51;
    if (!v51) {
      goto LABEL_64;
    }
LABEL_63:
    CFTypeRef v51 = 0LL;
    CFRelease(v9);
LABEL_64:
    BOOL v13 = 0LL;
    goto LABEL_65;
  }

  BOOL v15 = (const void *)v40[3];
  if (v15)
  {
    v40[3] = 0LL;
    CFRelease(v15);
  }

  uint64_t v16 = sub_10001267C("while-unlocked-hack");
  unsigned __int8 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "Trying action while unlocked without assertion",  buf,  2u);
  }

  v30[0] = _NSConcreteStackBlock;
  v30[1] = 3221225472LL;
  v30[2] = sub_1001C7924;
  v30[3] = &unk_100293AD0;
  uint64_t v32 = &v47;
  id v31 = v3;
  __int128 v33 = &v39;
  sub_1001C3588(v30);
  uint64_t v18 = sub_10001267C("while-unlocked-hack");
  uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    if (*((_BYTE *)v48 + 24)) {
      uint64_t v20 = "succeeded";
    }
    else {
      uint64_t v20 = "failed";
    }
    uint64_t v21 = v40[3];
    *(_DWORD *)__int128 buf = 136315394;
    int v53 = v20;
    __int16 v54 = 2112;
    uint64_t v55 = v21;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Action %s (%@)", buf, 0x16u);
  }

  if (a1)
  {
    if (!*a1)
    {
      uint64_t v22 = (const void *)v40[3];
      if (v22)
      {
        v40[3] = 0LL;
        if (*a1) {
          CFRelease(*a1);
        }
        *a1 = v22;
      }
    }
  }

  uint64_t v23 = (const void *)v40[3];
  if (v23)
  {
    v40[3] = 0LL;
    CFRelease(v23);
  }

  CFTypeRef v24 = v51;
  if (v51)
  {
    CFTypeRef v51 = 0LL;
    CFRelease(v24);
  }

  BOOL v13 = *((_BYTE *)v48 + 24) != 0;

LABEL_65:
  _Block_object_dispose(&v39, 8);
  _Block_object_dispose(&v43, 8);
  _Block_object_dispose(&v47, 8);

  return v13;
}

void sub_1001C7820( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, char a30)
{
}

void sub_1001C7890(uint64_t a1)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  void v4[2] = sub_1001C7964;
  void v4[3] = &unk_100293A80;
  uint64_t v6 = *(void *)(a1 + 48);
  __int128 v3 = *(_OWORD *)(a1 + 32);
  id v2 = (id)v3;
  __int128 v5 = v3;
  uint64_t v7 = *(void *)(a1 + 56);
  sub_1001C3588(v4);
}

uint64_t sub_1001C7924(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = result;
  return result;
}

void sub_1001C7964(void *a1, void *a2)
{
  id v4 = a2;
  __int128 v3 = (void *)objc_claimAutoreleasedReturnValue([v4 account]);
  if ([v3 isInCircle:0]
    && +[SOSAuthKitHelpers accountIsCDPCapable](&OBJC_CLASS___SOSAuthKitHelpers, "accountIsCDPCapable")
    && !+[SOSAuthKitHelpers peerinfoHasMID:](&OBJC_CLASS___SOSAuthKitHelpers, "peerinfoHasMID:", v3))
  {
    +[SOSAuthKitHelpers updateMIDInPeerInfo:](&OBJC_CLASS___SOSAuthKitHelpers, "updateMIDInPeerInfo:", v3);
  }

  *(_BYTE *)(*(void *)(a1[5] + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  *(_BYTE *)(*(void *)(a1[6] + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = (*(uint64_t (**)(void))(a1[4] + 16LL))();
}

void sub_1001C7A14(id a1, SOSAccountTransaction *a2)
{
  id v2 = a2;
  if (SOSVisibleKeychainNotAllowed())
  {
    __int128 v3 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](v2, "account"));
    if ([v3 isInCircle:0])
    {
      id v4 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](v2, "account"));
      int HasUserVisibleViewsEnabled = SOSPeerInfoHasUserVisibleViewsEnabled([v4 peerInfo]);

      if (HasUserVisibleViewsEnabled)
      {
        uint64_t v6 = sub_10001267C("views");
        uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v11 = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "Cannot have visible keychain views due to profile restrictions",  v11,  2u);
        }

        char v8 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](v2, "account"));
        CFTypeRef v9 = (void *)objc_claimAutoreleasedReturnValue([v8 trust]);
        uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](v2, "account"));
        [v9 updateViewSets:v10 enabled:0 disabled:SOSViewsGetV0ViewSet(v10)];
      }
    }
  }
}

BOOL sub_1001C7B38(CFTypeRef *a1)
{
  v10[0] = 0LL;
  v10[1] = v10;
  _DWORD v10[2] = 0x2020000000LL;
  char v11 = 1;
  uint64_t v6 = 0LL;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2020000000LL;
  uint64_t v9 = 0LL;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  _DWORD v5[2] = sub_1001C7C18;
  void v5[3] = &unk_1002932F8;
  void v5[4] = v10;
  void v5[5] = &v6;
  BOOL v2 = sub_1001C7358(a1, v5);
  if (a1)
  {
    __int128 v3 = (const void *)v7[3];
    if (v3) {
      *a1 = v3;
    }
  }

  _Block_object_dispose(&v6, 8);
  _Block_object_dispose(v10, 8);
  return v2;
}

void sub_1001C7BF4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1001C7C18(uint64_t a1, void *a2)
{
  __int128 v3 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = sub_100199E38( v3,  *(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) != 0LL;

  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

BOOL sub_1001C7C78(CFTypeRef *a1)
{
  uint64_t v26 = 0LL;
  os_signpost_id_t v27 = &v26;
  uint64_t v28 = 0x2020000000LL;
  char v29 = 1;
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  __int128 v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  uint64_t v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCRequestToJoinCircleAfterRestore",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v31 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCRequestToJoinCircleAfterRestore  enableTelemetry=YES ",  buf,  0xCu);
  }

  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472LL;
  v25[2] = sub_1001C7F44;
  v25[3] = &unk_1002932D0;
  v25[4] = &v26;
  BOOL v14 = sub_1001C7358(a1, v25);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v16 = _OctagonSignpostLogSystem(Nanoseconds);
  unsigned __int8 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
  uint64_t v18 = v17;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v17))
  {
    int v19 = *((unsigned __int8 *)v27 + 24);
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v31) = v19;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v18,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCRequestToJoinCircleAfterRestore",  " SOSSignpostNameSOSCCRequestToJoinCircleAfterRestore=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCC RequestToJoinCircleAfterRestore}d ",  buf,  8u);
  }

  uint64_t v21 = _OctagonSignpostLogSystem(v20);
  uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    int v23 = *((unsigned __int8 *)v27 + 24);
    os_signpost_id_t v31 = v4;
    __int16 v32 = 2048;
    double v33 = (double)Nanoseconds / 1000000000.0;
    __int16 v34 = 1026;
    int v35 = v23;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCRequestToJoinCircleAfterRestore  SOSSignpostNameSOSCCRequestToJoinCircleAfterRestore=%{public ,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRequestToJoinCircleAfterRestore}d ",  buf,  0x1Cu);
  }

  _Block_object_dispose(&v26, 8);
  return v14;
}

void sub_1001C7F0C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1001C7F44(uint64_t a1, void *a2, id *a3)
{
  id v5 = a2;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
  sub_100192738(v6);

  if (a3 && *a3)
  {
    id v7 = *a3;
    uint64_t v8 = sub_10001267C("SecError");
    uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl( (void *)&_mh_execute_header,  v9,  OS_LOG_TYPE_DEFAULT,  "ensure peer registration error: %@",  buf,  0xCu);
    }
  }

  *(void *)__int128 buf = 0LL;
  id v10 = v5;
  uint64_t v11 = sub_10001267C("circleOps");
  uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v48 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "Joining after restore (SOSAccountJoinCirclesAfterRestore)",  v48,  2u);
  }

  char v13 = sub_100191514(v10, 1, (uint64_t)buf);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v13;
  if (a3)
  {
    BOOL v14 = *(void **)buf;
    if (*(void *)buf)
    {
      CFRetain(*(CFTypeRef *)buf);
      *a3 = v14;
    }
  }

  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL))
  {
    if (qword_1002DEB80 != -1) {
      dispatch_once(&qword_1002DEB80, &stru_10028EFC8);
    }
    if (byte_1002DEB78)
    {
      BOOL v15 = sub_10001267C("join-after-restore");
      uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v48 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "posting kSOSCCCircleOctagonKeysChangedNotification",  v48,  2u);
      }

      notify_post(kSOSCCCircleOctagonKeysChangedNotification);
      unsigned __int8 v17 = (void *)objc_claimAutoreleasedReturnValue([v10 account]);
      uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v17 trust]);
      unsigned int v19 = [v18 isInCircleOnly:0];

      if (*(void *)buf)
      {
        id v22 = objc_msgSend((id)objc_opt_class(CKKSAnalytics, v21), "logger");
        int v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
        uint64_t v24 = *(void *)buf;
        v49[0] = @"SOSEnabled";
        BOOL v26 = -[OTSOSActualAdapter sosEnabled]_0((uint64_t)v23, v25);
        os_signpost_id_t v27 = @"compat_disabled";
        if (v26) {
          os_signpost_id_t v27 = @"compat_enabled";
        }
        v50[0] = v27;
        v50[1] = @"Restore";
        v49[1] = @"SOSJoinMethod";
        v49[2] = @"JoiningSOSResult";
        uint64_t v28 = @"not_in_circle";
        if (v19) {
          uint64_t v28 = @"in_circle";
        }
        v50[2] = v28;
        v49[3] = @"CircleContainsLegacy";
        char v29 = (void *)objc_claimAutoreleasedReturnValue([v10 account]);
        uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v29 trust]);
        id v31 = [v30 trustedCircle];
        __int16 v32 = (void *)objc_claimAutoreleasedReturnValue([v10 account]);
        int IsLegacy = SOSCircleIsLegacy(v31, [v32 accountKey]);
        __int16 v34 = @"does_not_contain_legacy";
        if (IsLegacy) {
          __int16 v34 = @"contains_legacy";
        }
        void v50[3] = v34;
        int v35 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v50,  v49,  4LL));
        [v23 logResultForEvent:@"SOSDeferralEventJoinCircleAfterRestore" hardFailure:0 result:v24 withAttributes:v35];
      }

      else
      {
        if (-[OTSOSActualAdapter sosEnabled]_0(v20, v21)) {
          double v36 = @"compat_enabled";
        }
        else {
          double v36 = @"compat_disabled";
        }
        if (v19) {
          os_signpost_id_t v37 = @"in_circle";
        }
        else {
          os_signpost_id_t v37 = @"not_in_circle";
        }
        __int16 v38 = (void *)objc_claimAutoreleasedReturnValue([v10 account]);
        uint64_t v39 = (void *)objc_claimAutoreleasedReturnValue([v38 trust]);
        id v40 = [v39 trustedCircle];
        uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v10 account]);
        int v42 = SOSCircleIsLegacy(v40, [v41 accountKey]);
        uint64_t v43 = @"does_not_contain_legacy";
        if (v42) {
          uint64_t v43 = @"contains_legacy";
        }
        int v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@-%@-%@-%@",  v36,  @"Restore",  v37,  v43));

        id v45 = objc_msgSend((id)objc_opt_class(CKKSAnalytics, v44), "logger");
        char v29 = (void *)objc_claimAutoreleasedReturnValue(v45);
        [v29 logSuccessForEventNamed:v23];
      }
    }
  }

  uint64_t v46 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);

  return v46;
}

BOOL sub_1001C83F0(CFTypeRef *a1)
{
  return sub_1001C44A8(a1, &stru_100293318);
}

BOOL sub_1001C83FC(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  __int128 v3 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](a2, "account", a3));
  sub_1001907A8(v3);

  return 1;
}

BOOL sub_1001C8430(CFTypeRef *a1)
{
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  __int128 v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  id v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCResetToOffering",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v25 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCResetToOffering  enableTelemetry=YES ",  buf,  0xCu);
  }

  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472LL;
  void v23[2] = sub_1001C8688;
  void v23[3] = &unk_100293338;
  v23[4] = a1;
  BOOL v14 = sub_1001C7358(a1, v23);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v16 = _OctagonSignpostLogSystem(Nanoseconds);
  unsigned __int8 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
  uint64_t v18 = v17;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v17))
  {
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v25) = v14;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v18,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCResetToOffering",  " SOSSignpostNameSOSCCResetToOffering=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCResetToOffering}d ",  buf,  8u);
  }

  uint64_t v20 = _OctagonSignpostLogSystem(v19);
  uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v25 = v4;
    __int16 v26 = 2048;
    double v27 = (double)Nanoseconds / 1000000000.0;
    __int16 v28 = 1026;
    BOOL v29 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCResetToOffering  SOSSignpostNameSOSCCResetToOffering=%{public,signpost.telemetry:number1,name =SOSSignpostNameSOSCCResetToOffering}d ",  buf,  0x1Cu);
  }

  return v14;
}

id sub_1001C8688(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
  id v7 = sub_100199708(v6, *(void *)(a1 + 32));

  if (v7)
  {
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 trust]);
    id v10 = [v9 trustedCircle];
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
    int IsLegacy = SOSCircleIsLegacy(v10, [v11 accountKey]);

    CFTypeRef cf = 0LL;
    char v13 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
    BOOL v14 = (void *)objc_claimAutoreleasedReturnValue([v13 trust]);
    id v7 = [v14 resetToOffering:v5 key:v7 err:&cf];

    if (a3)
    {
      CFTypeRef v15 = cf;
      if (cf)
      {
        CFRetain(cf);
        *a3 = v15;
      }
    }

    if ((_DWORD)v7)
    {
      if (qword_1002DEB80 != -1) {
        dispatch_once(&qword_1002DEB80, &stru_10028EFC8);
      }
      if (byte_1002DEB78)
      {
        uint64_t v16 = sub_10001267C("reset-to-offering");
        unsigned __int8 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int128 buf = 0;
          _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "posting kSOSCCCircleOctagonKeysChangedNotification",  buf,  2u);
        }

        notify_post(kSOSCCCircleOctagonKeysChangedNotification);
        uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
        uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v18 trust]);
        unsigned int v20 = [v19 isInCircleOnly:0];

        if (cf)
        {
          id v23 = objc_msgSend((id)objc_opt_class(CKKSAnalytics, v22), "logger");
          uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
          CFTypeRef v25 = cf;
          v41[0] = @"SOSEnabled";
          BOOL v27 = -[OTSOSActualAdapter sosEnabled]_0((uint64_t)v24, v26);
          __int16 v28 = @"compat_disabled";
          if (v27) {
            __int16 v28 = @"compat_enabled";
          }
          v42[0] = v28;
          v42[1] = @"ResetToOffering";
          v41[1] = @"SOSJoinMethod";
          v41[2] = @"JoiningSOSResult";
          BOOL v29 = @"in_circle";
          if (!v20) {
            BOOL v29 = @"not_in_circle";
          }
          v41[3] = @"CircleContainsLegacy";
          uint64_t v30 = @"does_not_contain_legacy";
          if (IsLegacy) {
            uint64_t v30 = @"contains_legacy";
          }
          v42[2] = v29;
          v42[3] = v30;
          id v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v42,  v41,  4LL));
          [v24 logResultForEvent:@"SOSDeferralEventResetToOffering" hardFailure:0 result:v25 withAttributes:v31];
        }

        else
        {
          BOOL v32 = -[OTSOSActualAdapter sosEnabled]_0(v21, v22);
          double v33 = @"compat_disabled";
          if (v32) {
            double v33 = @"compat_enabled";
          }
          __int16 v34 = @"not_in_circle";
          if (v20) {
            __int16 v34 = @"in_circle";
          }
          int v35 = @"does_not_contain_legacy";
          if (IsLegacy) {
            int v35 = @"contains_legacy";
          }
          uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@-%@-%@-%@",  v33,  @"ResetToOffering",  v34,  v35));
          id v37 = objc_msgSend((id)objc_opt_class(CKKSAnalytics, v36), "logger");
          id v31 = (void *)objc_claimAutoreleasedReturnValue(v37);
          [v31 logSuccessForEventNamed:v24];
        }
      }
    }
  }

  return v7;
}

BOOL sub_1001C8A20(CFTypeRef *a1)
{
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  __int128 v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  id v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCResetToEmpty",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v25 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCResetToEmpty  enableTelemetry=YES ",  buf,  0xCu);
  }

  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472LL;
  void v23[2] = sub_1001C8C78;
  void v23[3] = &unk_100293338;
  v23[4] = a1;
  BOOL v14 = sub_1001C7358(a1, v23);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v16 = _OctagonSignpostLogSystem(Nanoseconds);
  unsigned __int8 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
  uint64_t v18 = v17;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v17))
  {
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v25) = v14;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v18,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCResetToEmpty",  " SOSSignpostNameSOSCCResetToEmpty=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCResetToEmpty}d ",  buf,  8u);
  }

  uint64_t v20 = _OctagonSignpostLogSystem(v19);
  uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v25 = v4;
    __int16 v26 = 2048;
    double v27 = (double)Nanoseconds / 1000000000.0;
    __int16 v28 = 1026;
    BOOL v29 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCResetToEmpty  SOSSignpostNameSOSCCResetToEmpty=%{public,signpost.telemetry:number1,name=SOSSi gnpostNameSOSCCResetToEmpty}d ",  buf,  0x1Cu);
  }

  return v14;
}

id sub_1001C8C78(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
  id v7 = sub_100199E38(v6, *(void *)(a1 + 32));

  if (v7)
  {
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 trust]);
    id v10 = [v9 trustedCircle];
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
    int IsLegacy = SOSCircleIsLegacy(v10, [v11 accountKey]);

    CFTypeRef cf = 0LL;
    char v13 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
    BOOL v14 = (void *)objc_claimAutoreleasedReturnValue([v13 trust]);
    CFTypeRef v15 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
    unsigned __int8 v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "circle_transport"));
    id v7 = [v14 resetAccountToEmpty:v15 transport:v17 err:&cf];

    CFTypeRef v20 = cf;
    if (a3 && cf)
    {
      CFTypeRef v18 = CFRetain(cf);
      *a3 = v20;
      CFTypeRef v20 = cf;
    }

    if (v20)
    {
      id v21 = objc_msgSend((id)objc_opt_class(CKKSAnalytics, v19), "logger");
      uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
      CFTypeRef v23 = cf;
      v36[0] = @"SOSEnabled";
      BOOL v25 = -[OTSOSActualAdapter sosEnabled]_0((uint64_t)v22, v24);
      __int16 v26 = @"compat_disabled";
      if (v25) {
        __int16 v26 = @"compat_enabled";
      }
      v37[0] = v26;
      v37[1] = @"Reset";
      double v27 = @"does_not_contain_legacy";
      v36[1] = @"SOSJoinMethod";
      v36[2] = @"CircleContainsLegacy";
      if (IsLegacy) {
        double v27 = @"contains_legacy";
      }
      void v37[2] = v27;
      __int16 v28 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v37,  v36,  3LL));
      [v22 logResultForEvent:@"SOSDeferralEventReset" hardFailure:0 result:v23 withAttributes:v28];
    }

    else
    {
      BOOL v29 = -[OTSOSActualAdapter sosEnabled]_0((uint64_t)v18, v19);
      uint64_t v30 = @"compat_disabled";
      if (v29) {
        uint64_t v30 = @"compat_enabled";
      }
      if (IsLegacy) {
        id v31 = @"contains_legacy";
      }
      else {
        id v31 = @"does_not_contain_legacy";
      }
      uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@-%@-%@",  v30,  @"Reset",  v31));
      id v33 = objc_msgSend((id)objc_opt_class(CKKSAnalytics, v32), "logger");
      __int16 v28 = (void *)objc_claimAutoreleasedReturnValue(v33);
      [v28 logSuccessForEventNamed:v22];
    }
  }

  return v7;
}

BOOL sub_1001C8F54(CFTypeRef *a1)
{
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  __int128 v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  id v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    LOWORD(v23) = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCRemoveThisDeviceFromCircle",  " enableTelemetry=YES ",  (uint8_t *)&v23,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    int v23 = 134217984;
    os_signpost_id_t v24 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCRemoveThisDeviceFromCircle  enableTelemetry=YES ",  (uint8_t *)&v23,  0xCu);
  }

  BOOL v14 = sub_1001C7358(a1, &stru_100293358);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v16 = _OctagonSignpostLogSystem(Nanoseconds);
  unsigned __int8 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
  CFTypeRef v18 = v17;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v17))
  {
    int v23 = 67240192;
    LODWORD(v24) = v14;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v18,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCRemoveThisDeviceFromCircle",  " SOSSignpostNameSOSCCRemoveThisDeviceFromCircle=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRemov eThisDeviceFromCircle}d ",  (uint8_t *)&v23,  8u);
  }

  uint64_t v20 = _OctagonSignpostLogSystem(v19);
  id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    int v23 = 134218496;
    os_signpost_id_t v24 = v4;
    __int16 v25 = 2048;
    double v26 = (double)Nanoseconds / 1000000000.0;
    __int16 v27 = 1026;
    BOOL v28 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCRemoveThisDeviceFromCircle  SOSSignpostNameSOSCCRemoveThisDeviceFromCircle=%{public,signpost. telemetry:number1,name=SOSSignpostNameSOSCCRemoveThisDeviceFromCircle}d ",  (uint8_t *)&v23,  0x1Cu);
  }

  return v14;
}

BOOL sub_1001C9180(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  os_signpost_id_t v4 = a2;
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](v4, "account"));
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 trust]);
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](v4, "account"));

  LOBYTE(a3) = [v6 leaveCircle:v7 err:a3];
  return (char)a3;
}

BOOL sub_1001C9204(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4 = _OctagonSignpostLogSystem(a1);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  os_signpost_id_t v6 = _OctagonSignpostCreate();
  uint64_t v8 = v7;

  uint64_t v10 = _OctagonSignpostLogSystem(v9);
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
  uint64_t v12 = v11;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_INTERVAL_BEGIN,  v6,  "SOSCCRemovePeersFromCircle",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v14 = _OctagonSignpostLogSystem(v13);
  CFTypeRef v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v27 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCRemovePeersFromCircle  enableTelemetry=YES ",  buf,  0xCu);
  }

  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472LL;
  v25[2] = sub_1001C9460;
  v25[3] = &unk_100293338;
  v25[4] = a1;
  BOOL v16 = sub_1001C7358(a2, v25);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v6, v8);
  uint64_t v18 = _OctagonSignpostLogSystem(Nanoseconds);
  uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
  uint64_t v20 = v19;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v19))
  {
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v27) = v16;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_INTERVAL_END,  v6,  "SOSCCRemovePeersFromCircle",  " SOSSignpostNameSOSCCRemovePeersFromCircle=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRemovePeersFromCircle}d ",  buf,  8u);
  }

  uint64_t v22 = _OctagonSignpostLogSystem(v21);
  int v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v27 = v6;
    __int16 v28 = 2048;
    double v29 = (double)Nanoseconds / 1000000000.0;
    __int16 v30 = 1026;
    BOOL v31 = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCRemovePeersFromCircle  SOSSignpostNameSOSCCRemovePeersFromCircle=%{public,signpost.telemetry: number1,name=SOSSignpostNameSOSCCRemovePeersFromCircle}d ",  buf,  0x1Cu);
  }

  return v16;
}

uint64_t sub_1001C9460(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  uint64_t v6 = sub_100191D4C(v5, *(const __CFArray **)(a1 + 32), a3);

  return v6;
}

void sub_1001C94B0()
{
  uint64_t v0 = SOSCCCredentialQueue();
  uint64_t v1 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(v0);
  dispatch_async(v1, &stru_100293378);
}

void sub_1001C94E4(id a1)
{
  CFTypeRef cf = 0LL;
  if (!sub_1001C7358(&cf, &stru_100293398) || cf != 0LL)
  {
    uint64_t v2 = sub_10001267C("SecError");
    __int128 v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v7 = cf;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "circleOps: error delivering account-sign-in notification: %@",  buf,  0xCu);
    }

    CFTypeRef v4 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v4);
    }
  }

BOOL sub_1001C95C0(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  __int128 v3 = a2;
  CFTypeRef v4 = sub_10001267C("circleOps");
  uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)uint64_t v8 = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Signed into account!", v8, 2u);
  }

  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](v3, "account"));
  [v6 setAccountIsChanging:0];

  return 1;
}

BOOL sub_1001C9660(CFTypeRef *a1)
{
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  __int128 v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  uint64_t v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    LOWORD(v23) = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCLoggedOutOfAccount",  " enableTelemetry=YES ",  (uint8_t *)&v23,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    int v23 = 134217984;
    os_signpost_id_t v24 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCLoggedOutOfAccount  enableTelemetry=YES ",  (uint8_t *)&v23,  0xCu);
  }

  BOOL v14 = sub_1001C7358(a1, &stru_1002933B8);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v16 = _OctagonSignpostLogSystem(Nanoseconds);
  unsigned __int8 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
  uint64_t v18 = v17;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v17))
  {
    int v23 = 67240192;
    LODWORD(v24) = v14;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v18,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCLoggedOutOfAccount",  " SOSSignpostNameSOSCCLoggedOutOfAccount=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCLoggedOutOfAccount}d ",  (uint8_t *)&v23,  8u);
  }

  uint64_t v20 = _OctagonSignpostLogSystem(v19);
  uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    int v23 = 134218496;
    os_signpost_id_t v24 = v4;
    __int16 v25 = 2048;
    double v26 = (double)Nanoseconds / 1000000000.0;
    __int16 v27 = 1026;
    BOOL v28 = v14;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCLoggedOutOfAccount  SOSSignpostNameSOSCCLoggedOutOfAccount=%{public,signpost.telemetry:number 1,name=SOSSignpostNameSOSCCLoggedOutOfAccount}d ",  (uint8_t *)&v23,  0x1Cu);
  }

  return v14;
}

BOOL sub_1001C988C(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  os_signpost_id_t v4 = a2;
  uint64_t v5 = sub_10001267C("circleOps");
  uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFTypeRef v15 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Signed out of account!", v15, 2u);
  }

  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](v4, "account"));
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 trust]);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](v4, "account"));
  unsigned __int8 v10 = [v8 leaveCircle:v9 err:a3];

  -[SOSAccountTransaction restart](v4, "restart");
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](v4, "account"));
  sub_1001C4B5C(1LL);

  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](v4, "account"));
  sub_1001907A8(v12);

  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](v4, "account"));
  [v13 setAccountIsChanging:1];

  return v10;
}

BOOL sub_1001C99C4(uint64_t a1, CFTypeRef *a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1001C9A1C;
  v3[3] = &unk_100293338;
  void v3[4] = a1;
  return sub_1001C7358(a2, v3);
}

uint64_t sub_1001C9A1C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
  uint64_t v7 = *(void *)(a1 + 32);
  id v8 = v6;
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(-2LL, 0LL);
  unsigned __int8 v10 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(global_queue);
  uint64_t v11 = dispatch_group_create();
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v8 trust]);
  uint64_t v13 = sub_10001267C("circle");
  BOOL v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v20) = 134217984;
    *(void *)((char *)&v20 + 4) = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "Attempting to leave circle - best effort - in %llu seconds\n",  (uint8_t *)&v20,  0xCu);
  }

  *(void *)&__int128 v20 = _NSConcreteStackBlock;
  *((void *)&v20 + 1) = 3221225472LL;
  uint64_t v21 = sub_1001921F8;
  uint64_t v22 = &unk_100291850;
  id v23 = v12;
  id v24 = v8;
  uint64_t v25 = a3;
  id v15 = v8;
  id v16 = v12;
  dispatch_group_async(v11, v10, &v20);
  dispatch_time_t v17 = dispatch_time(0LL, 1000000000 * v7);
  dispatch_group_wait(v11, v17);
  [v16 setDepartureCode:2];

  [v5 restart];
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);

  sub_1001C4B5C(0LL);
  return 0LL;
}

uint64_t sub_1001C9BF8(CFTypeRef *a1)
{
  uint64_t v26 = 0LL;
  __int16 v27 = &v26;
  uint64_t v28 = 0x2020000000LL;
  uint64_t v29 = 0LL;
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  __int128 v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  unsigned __int8 v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCCopyApplicantPeerInfo",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v31 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCCopyApplicantPeerInfo  enableTelemetry=YES ",  buf,  0xCu);
  }

  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472LL;
  v25[2] = sub_1001C9ED4;
  v25[3] = &unk_1002932D0;
  v25[4] = &v26;
  sub_1001C44A8(a1, v25);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v15 = _OctagonSignpostLogSystem(Nanoseconds);
  id v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
  dispatch_time_t v17 = v16;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v16))
  {
    BOOL v18 = v27[3] != 0;
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v31) = v18;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v17,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCCopyApplicantPeerInfo",  " SOSSignpostNameSOSCCCopyApplicantPeerInfo=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyApplicantPeerInfo}d ",  buf,  8u);
  }

  uint64_t v20 = _OctagonSignpostLogSystem(v19);
  uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = v27[3];
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v31 = v4;
    __int16 v32 = 2048;
    double v33 = (double)Nanoseconds / 1000000000.0;
    __int16 v34 = 1026;
    BOOL v35 = v22 != 0;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCCopyApplicantPeerInfo  SOSSignpostNameSOSCCCopyApplicantPeerInfo=%{public,signpost.telemetry: number1,name=SOSSignpostNameSOSCCCopyApplicantPeerInfo}d ",  buf,  0x1Cu);
  }

  uint64_t v23 = v27[3];
  _Block_object_dispose(&v26, 8);
  return v23;
}

void sub_1001C9E9C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_1001C9ED4(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = sub_10019BF14(v5, a3, &stru_100291FD8);

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

uint64_t sub_1001C9F40(CFTypeRef *a1)
{
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000LL;
  uint64_t v7 = 0LL;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1001C9FE0;
  v3[3] = &unk_1002932D0;
  void v3[4] = &v4;
  sub_1001C44A8(a1, v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1001C9FC8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_1001C9FE0(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = (id)objc_claimAutoreleasedReturnValue([a2 account]);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 trust]);
  id v7 = sub_100199E38(v5, a3);

  if (!v7) {
    goto LABEL_6;
  }
  if (![v6 trustedCircle])
  {
    SOSErrorCreate(1037LL, a3, 0LL, @"No circle");
LABEL_6:
    CFArrayRef v16 = 0LL;
    goto LABEL_4;
  }

  uint64_t Generation = SOSCircleGetGeneration([v6 trustedCircle]);
  CFArrayRef v16 = sub_1001141B8(kCFAllocatorDefault, v9, v10, v11, v12, v13, v14, v15, Generation);
LABEL_4:

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v16;
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

uint64_t sub_1001CA0CC(CFTypeRef *a1)
{
  uint64_t v27 = 0LL;
  uint64_t v28 = &v27;
  uint64_t v29 = 0x2020000000LL;
  uint64_t v30 = 0LL;
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  __int128 v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  uint64_t v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCCopyValidPeerPeerInfo",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v32 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCCopyValidPeerPeerInfo  enableTelemetry=YES ",  buf,  0xCu);
  }

  uint64_t v14 = objc_autoreleasePoolPush();
  v26[0] = _NSConcreteStackBlock;
  v26[1] = 3221225472LL;
  v26[2] = sub_1001CA3B8;
  v26[3] = &unk_1002932D0;
  _BYTE v26[4] = &v27;
  sub_1001C44A8(a1, v26);
  objc_autoreleasePoolPop(v14);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v16 = _OctagonSignpostLogSystem(Nanoseconds);
  dispatch_time_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
  BOOL v18 = v17;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v17))
  {
    BOOL v19 = v28[3] != 0;
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v32) = v19;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v18,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCCopyValidPeerPeerInfo",  " SOSSignpostNameSOSCCCopyValidPeerPeerInfo=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyValidPeerPeerInfo}d ",  buf,  8u);
  }

  uint64_t v21 = _OctagonSignpostLogSystem(v20);
  uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v23 = v28[3];
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v32 = v4;
    __int16 v33 = 2048;
    double v34 = (double)Nanoseconds / 1000000000.0;
    __int16 v35 = 1026;
    BOOL v36 = v23 != 0;
    _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCCopyValidPeerPeerInfo  SOSSignpostNameSOSCCCopyValidPeerPeerInfo=%{public,signpost.telemetry: number1,name=SOSSignpostNameSOSCCCopyValidPeerPeerInfo}d ",  buf,  0x1Cu);
  }

  uint64_t v24 = v28[3];
  _Block_object_dispose(&v27, 8);
  return v24;
}

void sub_1001CA380( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_1001CA3B8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = objc_autoreleasePoolPush();
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472LL;
  v11[2] = sub_10019C058;
  v11[3] = &unk_100291F08;
  id v12 = (id)objc_claimAutoreleasedReturnValue([v5 account]);
  id v7 = v12;
  CFMutableArrayRef v8 = sub_10019BF14(v7, a3, v11);

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v8;
  objc_autoreleasePoolPop(v6);
  BOOL v9 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;

  return v9;
}

uint64_t sub_1001CA498(CFTypeRef *a1)
{
  uint64_t v26 = 0LL;
  uint64_t v27 = &v26;
  uint64_t v28 = 0x2020000000LL;
  char v29 = 0;
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  __int128 v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  BOOL v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  uint64_t v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCValidateUserPublic",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v31 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCValidateUserPublic  enableTelemetry=YES ",  buf,  0xCu);
  }

  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472LL;
  v25[2] = sub_1001CA764;
  v25[3] = &unk_1002932D0;
  v25[4] = &v26;
  sub_1001C44A8(a1, v25);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v15 = _OctagonSignpostLogSystem(Nanoseconds);
  uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
  dispatch_time_t v17 = v16;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v16))
  {
    int v18 = *((unsigned __int8 *)v27 + 24);
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v31) = v18;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v17,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCValidateUserPublic",  " SOSSignpostNameSOSCCValidateUserPublic=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCValidateUserPublic}d ",  buf,  8u);
  }

  uint64_t v20 = _OctagonSignpostLogSystem(v19);
  uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    int v22 = *((unsigned __int8 *)v27 + 24);
    os_signpost_id_t v31 = v4;
    __int16 v32 = 2048;
    double v33 = (double)Nanoseconds / 1000000000.0;
    __int16 v34 = 1026;
    int v35 = v22;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCValidateUserPublic  SOSSignpostNameSOSCCValidateUserPublic=%{public,signpost.telemetry:number 1,name=SOSSignpostNameSOSCCValidateUserPublic}d ",  buf,  0x1Cu);
  }

  uint64_t v23 = *((unsigned __int8 *)v27 + 24);
  _Block_object_dispose(&v26, 8);
  return v23;
}

void sub_1001CA72C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1001CA764(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = (id)objc_claimAutoreleasedReturnValue([a2 account]);
  if (sub_100199E38(v5, a3)) {
    unsigned __int8 v6 = [v5 accountKeyIsTrusted];
  }
  else {
    unsigned __int8 v6 = 0;
  }

  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v6;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

uint64_t sub_1001CA7E0(CFTypeRef *a1)
{
  uint64_t v4 = 0LL;
  id v5 = &v4;
  uint64_t v6 = 0x2020000000LL;
  uint64_t v7 = 0LL;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1001CA880;
  v3[3] = &unk_1002932D0;
  void v3[4] = &v4;
  sub_1001C44A8(a1, v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1001CA868( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_1001CA880(uint64_t a1, void *a2, uint64_t a3)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  void v8[2] = sub_10019BEA0;
  v8[3] = &unk_100291F08;
  id v9 = (id)objc_claimAutoreleasedReturnValue([a2 account]);
  id v5 = v9;
  CFMutableArrayRef v6 = sub_10019BF14(v5, a3, v8);

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v6;
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

uint64_t sub_1001CA938(CFTypeRef *a1)
{
  uint64_t v4 = 0LL;
  id v5 = &v4;
  uint64_t v6 = 0x2020000000LL;
  uint64_t v7 = 0LL;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1001CA9D8;
  v3[3] = &unk_1002932D0;
  void v3[4] = &v4;
  sub_1001C44A8(a1, v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1001CA9C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_1001CA9D8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = sub_10019BF14(v5, a3, &stru_100291F98);

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

uint64_t sub_1001CAA44(CFTypeRef *a1)
{
  uint64_t v26 = 0LL;
  uint64_t v27 = &v26;
  uint64_t v28 = 0x2020000000LL;
  uint64_t v29 = 0LL;
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  __int128 v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  uint64_t v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCCopyViewUnawarePeerInfo",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v31 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCCopyViewUnawarePeerInfo  enableTelemetry=YES ",  buf,  0xCu);
  }

  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472LL;
  v25[2] = sub_1001CAD20;
  v25[3] = &unk_1002932D0;
  v25[4] = &v26;
  sub_1001C44A8(a1, v25);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v15 = _OctagonSignpostLogSystem(Nanoseconds);
  uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
  dispatch_time_t v17 = v16;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v16))
  {
    BOOL v18 = v27[3] != 0;
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v31) = v18;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v17,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCCopyViewUnawarePeerInfo",  " SOSSignpostNameSOSCCCopyViewUnawarePeerInfo=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyView UnawarePeerInfo}d ",  buf,  8u);
  }

  uint64_t v20 = _OctagonSignpostLogSystem(v19);
  uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = v27[3];
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v31 = v4;
    __int16 v32 = 2048;
    double v33 = (double)Nanoseconds / 1000000000.0;
    __int16 v34 = 1026;
    BOOL v35 = v22 != 0;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCCopyViewUnawarePeerInfo  SOSSignpostNameSOSCCCopyViewUnawarePeerInfo=%{public,signpost.teleme try:number1,name=SOSSignpostNameSOSCCCopyViewUnawarePeerInfo}d ",  buf,  0x1Cu);
  }

  uint64_t v23 = v27[3];
  _Block_object_dispose(&v26, 8);
  return v23;
}

void sub_1001CACE8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_1001CAD20(uint64_t a1, void *a2, uint64_t a3)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472LL;
  void v8[2] = sub_10019C32C;
  v8[3] = &unk_100291F08;
  id v9 = (id)objc_claimAutoreleasedReturnValue([a2 account]);
  id v5 = v9;
  CFMutableArrayRef v6 = sub_10019BF14(v5, a3, v8);

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v6;
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

uint64_t sub_1001CADD8(CFTypeRef *a1)
{
  uint64_t v2 = sub_1001110DC(0LL);
  uint64_t v3 = sub_100101A94(v2);
  sub_100019570(v3 != 0, a1, @"No datasource");
  if (!v3) {
    return 0LL;
  }
  os_signpost_id_t v4 = (uint64_t *)(*(uint64_t (**)(uint64_t, const CFStringRef, CFTypeRef *))(v3 + 8))( v3,  kSecAttrAccessibleWhenUnlocked,  a1);
  if (!v4) {
    return 0LL;
  }
  id v5 = v4;
  uint64_t v6 = sub_1000D56F4(*v4, (uint64_t)a1);
  ((void (*)(uint64_t *, CFTypeRef *))v5[9])(v5, a1);
  return v6;
}

BOOL sub_1001CAE78(CFTypeRef *a1)
{
  uint64_t v65 = 0LL;
  uint64_t v66 = &v65;
  uint64_t v67 = 0x3032000000LL;
  uint64_t v68 = sub_1001CB5B8;
  uint64_t v69 = sub_1001CB5C8;
  id v70 = 0LL;
  v63[0] = 0LL;
  v63[1] = v63;
  v63[2] = 0x2020000000LL;
  char v64 = 0;
  uint64_t v59 = 0LL;
  CFDataRef v60 = &v59;
  uint64_t v61 = 0x2020000000LL;
  uint64_t v62 = 0LL;
  uint64_t v55 = 0LL;
  CFTypeRef v56 = &v55;
  uint64_t v57 = 0x2020000000LL;
  unint64_t v58 = 0xAAAAAAAAAAAAAAAALL;
  v54[0] = 0LL;
  v54[1] = v54;
  v54[2] = 0x2020000000LL;
  v54[3] = kCFBooleanFalse;
  uint64_t v50 = 0LL;
  CFTypeRef v51 = &v50;
  uint64_t v52 = 0x2020000000LL;
  char v53 = 0;
  uint64_t v2 = sub_1001CB5D0();
  if ((v2 & 1) != 0)
  {
    uint64_t v3 = _OctagonSignpostLogSystem(v2);
    os_signpost_id_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
    os_signpost_id_t v5 = _OctagonSignpostCreate();
    uint64_t v7 = v6;

    uint64_t v9 = _OctagonSignpostLogSystem(v8);
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    uint64_t v11 = v10;
    if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v10))
    {
      *(_WORD *)__int128 buf = 0;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v11,  OS_SIGNPOST_INTERVAL_BEGIN,  v5,  "SOSCCWaitForInitialSync",  " enableTelemetry=YES ",  buf,  2u);
    }

    uint64_t v13 = _OctagonSignpostLogSystem(v12);
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134217984;
      *(void *)&uint8_t buf[4] = v5;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCWaitForInitialSync  enableTelemetry=YES ",  buf,  0xCu);
    }

    uint64_t v15 = sub_10001267C("initial sync");
    uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Wait for initial sync start!", buf, 2u);
    }

    v49[0] = _NSConcreteStackBlock;
    v49[1] = 3221225472LL;
    v49[2] = sub_1001CB670;
    v49[3] = &unk_100293408;
    void v49[4] = v54;
    v49[5] = &v50;
    v49[6] = &v55;
    v49[7] = &v65;
    v49[8] = &v59;
    v49[9] = v63;
    v49[10] = a1;
    BOOL v17 = sub_1001C44A8(a1, v49);
    if (v17)
    {
      if (v66[5])
      {
        if (*((_BYTE *)v51 + 24))
        {
          BOOL v18 = sub_10001267C("piggy");
          uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__int128 buf = 0;
            _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "setting initial sync timeout to 5 minutes",  buf,  2u);
          }

          uint64_t v20 = (dispatch_semaphore_s *)v66[5];
          int64_t v21 = 300000000000LL;
        }

        else
        {
          *(void *)__int128 buf = 10LL;
          uint64_t v22 = (const __CFNumber *)CFPreferencesCopyValue( @"InitialSync.WaitPeriod",  @"com.apple.security",  kCFPreferencesAnyUser,  kCFPreferencesCurrentHost);
          uint64_t v23 = v22;
          if (v22)
          {
            CFTypeID v24 = CFGetTypeID(v22);
            if (v24 == CFNumberGetTypeID()) {
              CFNumberGetValue(v23, kCFNumberSInt64Type, buf);
            }
            CFRelease(v23);
            uint64_t v25 = *(void *)buf;
          }

          else
          {
            uint64_t v25 = 10LL;
          }

          uint64_t v26 = sub_10001267C("piggy");
          uint64_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 134217984;
            *(void *)&uint8_t buf[4] = v25;
            _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "setting initial sync timeout to %llu seconds",  buf,  0xCu);
          }

          uint64_t v20 = (dispatch_semaphore_s *)v66[5];
          int64_t v21 = 1000000000 * v25;
        }

        dispatch_time_t v28 = dispatch_time(0LL, v21);
        if (dispatch_semaphore_wait(v20, v28) && *((_BYTE *)v51 + 24))
        {
          v48[0] = _NSConcreteStackBlock;
          v48[1] = 3221225472LL;
          int v48[2] = sub_1001CB948;
          v48[3] = &unk_100293430;
          v48[4] = &v59;
          v48[5] = &v65;
          sub_1001C3588(v48);
        }
      }

      uint64_t v76 = SecCoreAnalyticsValue;
      uint64_t v29 = v56[3];
      time_t v30 = time(0LL);
      unint64_t v31 = v30 - v29;
      uint64_t v32 = 1LL;
      if (v30 - v29 >= 11)
      {
        unint64_t v33 = v30 - v29;
        do
        {
          unint64_t v31 = v33 / 0xA;
          v32 *= 10LL;
          BOOL v34 = v33 > 0x6D;
          v33 /= 0xAuLL;
        }

        while (v34);
      }

      BOOL v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithLong:](&OBJC_CLASS___NSNumber, "numberWithLong:", v32 * v31));
      id v77 = v35;
      BOOL v36 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v77,  &v76,  1LL));
      +[SecCoreAnalytics sendEvent:event:]( &OBJC_CLASS___SecCoreAnalytics,  "sendEvent:event:",  @"com.apple.security.sos.synccompletion",  v36);

      id v37 = sub_10001267C("initial sync");
      __int16 v38 = (os_log_s *)objc_claimAutoreleasedReturnValue(v37);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = 1;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Finished!: %d", buf, 8u);
      }
    }

    uint64_t v39 = (const void *)v60[3];
    if (v39)
    {
      v60[3] = 0LL;
      CFRelease(v39);
    }

    unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v5, v7);
    uint64_t v41 = _OctagonSignpostLogSystem(Nanoseconds);
    int v42 = (os_log_s *)objc_claimAutoreleasedReturnValue(v41);
    uint64_t v43 = v42;
    if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v42))
    {
      *(_DWORD *)__int128 buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v17;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v43,  OS_SIGNPOST_INTERVAL_END,  v5,  "SOSCCWaitForInitialSync",  " SOSSignpostNameSOSCCWaitForInitialSync=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCWaitForInitialSync}d ",  buf,  8u);
    }

    uint64_t v45 = _OctagonSignpostLogSystem(v44);
    uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue(v45);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 134218496;
      *(void *)&uint8_t buf[4] = v5;
      __int16 v72 = 2048;
      double v73 = (double)Nanoseconds / 1000000000.0;
      __int16 v74 = 1026;
      BOOL v75 = v17;
      _os_log_impl( (void *)&_mh_execute_header,  v46,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCWaitForInitialSync  SOSSignpostNameSOSCCWaitForInitialSync=%{public,signpost.telemetry:numb er1,name=SOSSignpostNameSOSCCWaitForInitialSync}d ",  buf,  0x1Cu);
    }
  }

  else
  {
    BOOL v17 = 1LL;
  }

  _Block_object_dispose(&v50, 8);
  _Block_object_dispose(v54, 8);
  _Block_object_dispose(&v55, 8);
  _Block_object_dispose(&v59, 8);
  _Block_object_dispose(v63, 8);
  _Block_object_dispose(&v65, 8);

  return v17;
}

void sub_1001CB538( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, char a39)
{
}

uint64_t sub_1001CB5B8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1001CB5C8(uint64_t a1)
{
}

uint64_t sub_1001CB5D0()
{
  uint64_t v3 = 0LL;
  os_signpost_id_t v4 = &v3;
  uint64_t v5 = 0x2020000000LL;
  char v6 = 0;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472LL;
  _DWORD v2[2] = sub_1001CBA44;
  v2[3] = &unk_100293A18;
  v2[4] = &v3;
  sub_1001C3588(v2);
  uint64_t v0 = *((unsigned __int8 *)v4 + 24);
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1001CB658( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1001CB670(void *a1, void *a2)
{
  id v3 = a2;
  os_signpost_id_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  *(void *)(*(void *)(a1[4] + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = sub_10018DFDC(v4, (uint64_t)@"initialsynctimeout");

  uint64_t v5 = *(const __CFBoolean **)(*(void *)(a1[4] + 8LL) + 24LL);
  if (v5) {
    *(_BYTE *)(*(void *)(a1[5] + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = CFBooleanGetValue(v5) != 0;
  }
  char v6 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  BOOL v7 = sub_1001A19D8(v6, 2LL);

  if (v7)
  {
    *(_BYTE *)(*(void *)(a1[9] + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  }

  else
  {
    *(void *)(*(void *)(a1[6] + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = time(0LL);
    dispatch_semaphore_t v8 = dispatch_semaphore_create(0LL);
    uint64_t v9 = *(void *)(a1[7] + 8LL);
    uint64_t v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = v8;

    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
    uint64_t v25 = _NSConcreteStackBlock;
    uint64_t v26 = 3221225472LL;
    uint64_t v27 = sub_1001CBA0C;
    dispatch_time_t v28 = &unk_1002933E0;
    uint64_t v12 = a1[7];
    uint64_t v29 = a1[9];
    uint64_t v30 = v12;
    id v13 = v11;
    uint64_t v14 = &v25;
    if (sub_10018DFDC(v13, (uint64_t)@"unsynced"))
    {
      uint64_t v15 = CFUUIDCreate(kCFAllocatorDefault);
      CFStringRef v16 = CFUUIDCreateString(kCFAllocatorDefault, v15);
      if (v15) {
        CFRelease(v15);
      }
      BOOL v17 = sub_10001267C("initial-sync");
      BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        CFStringRef v32 = v16;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "adding sync block [%@] to array!",  buf,  0xCu);
      }

      uint64_t v19 = objc_retainBlock(v14);
      uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "waitForInitialSync_blocks", v25, v26));

      if (!v20)
      {
        int64_t v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
        objc_msgSend(v13, "setWaitForInitialSync_blocks:", v21);
      }

      uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "waitForInitialSync_blocks"));
      uint64_t v23 = objc_retainBlock(v19);
      [v22 setObject:v23 forKey:v16];
    }

    else
    {
      ((void (*)(void ***, id))v27)(v14, v13);
      CFStringRef v16 = 0LL;
    }

    *(void *)(*(void *)(a1[8] + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v16;
  }

  return 1LL;
}

void sub_1001CB948(uint64_t a1, void *a2)
{
  id v3 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  id v9 = v3;
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "waitForInitialSync_blocks"));

  if (v5)
  {
    char v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "waitForInitialSync_blocks"));
    [v6 removeObjectForKey:v4];

    uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8LL);
    dispatch_semaphore_t v8 = *(void **)(v7 + 40);
    if (!v8) {
      return;
    }
    *(void *)(v7 + 40) = 0LL;
  }

  else
  {

    dispatch_semaphore_t v8 = v9;
  }
}

uint64_t sub_1001CBA0C(uint64_t a1)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
  uint64_t v1 = *(dispatch_semaphore_s **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
  if (v1) {
    dispatch_semaphore_signal(v1);
  }
  return 1LL;
}

void sub_1001CBA44(uint64_t a1, void *a2)
{
  id v3 = (id)objc_claimAutoreleasedReturnValue([a2 account]);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = [v3 SOSMonitorModeSOSIsActive];
}

BOOL sub_1001CBA8C(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4 = _OctagonSignpostLogSystem(a1);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  os_signpost_id_t v6 = _OctagonSignpostCreate();
  uint64_t v8 = v7;

  uint64_t v10 = _OctagonSignpostLogSystem(v9);
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
  uint64_t v12 = v11;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_INTERVAL_BEGIN,  v6,  "SOSCCAcceptApplicants",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v14 = _OctagonSignpostLogSystem(v13);
  uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v27 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCAcceptApplicants  enableTelemetry=YES ",  buf,  0xCu);
  }

  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472LL;
  v25[2] = sub_1001CBCE8;
  v25[3] = &unk_100293338;
  v25[4] = a1;
  BOOL v16 = sub_1001C7358(a2, v25);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v6, v8);
  uint64_t v18 = _OctagonSignpostLogSystem(Nanoseconds);
  uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
  uint64_t v20 = v19;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v19))
  {
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v27) = v16;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_INTERVAL_END,  v6,  "SOSCCAcceptApplicants",  " SOSSignpostNameSOSCCAcceptApplicants=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCAcceptApplicants}d ",  buf,  8u);
  }

  uint64_t v22 = _OctagonSignpostLogSystem(v21);
  uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v27 = v6;
    __int16 v28 = 2048;
    double v29 = (double)Nanoseconds / 1000000000.0;
    __int16 v30 = 1026;
    BOOL v31 = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCAcceptApplicants  SOSSignpostNameSOSCCAcceptApplicants=%{public,signpost.telemetry:number1,na me=SOSSignpostNameSOSCCAcceptApplicants}d ",  buf,  0x1Cu);
  }

  return v16;
}

BOOL sub_1001CBCE8(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  os_signpost_id_t v6 = *(const __CFArray **)(a1 + 32);
  id v7 = v5;
  id v8 = sub_100199708(v7, a3);
  if (v8)
  {
    uint64_t v13 = 0LL;
    uint64_t v14 = &v13;
    uint64_t v15 = 0x2020000000LL;
    uint64_t v16 = 0LL;
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472LL;
    v12[2] = sub_100192318;
    void v12[3] = &unk_100291878;
    void v12[5] = v8;
    void v12[6] = a3;
    void v12[4] = &v13;
    sub_10019235C(v7, (uint64_t)v6, v12);
    uint64_t v9 = v14[3];
    BOOL v10 = v9 == CFArrayGetCount(v6);
    _Block_object_dispose(&v13, 8);
  }

  else
  {
    BOOL v10 = 0LL;
  }

  return v10;
}

void sub_1001CBDD0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

BOOL sub_1001CBDE8(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4 = _OctagonSignpostLogSystem(a1);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  os_signpost_id_t v6 = _OctagonSignpostCreate();
  uint64_t v8 = v7;

  uint64_t v10 = _OctagonSignpostLogSystem(v9);
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
  uint64_t v12 = v11;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_INTERVAL_BEGIN,  v6,  "SOSCCAcceptApplicants",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v14 = _OctagonSignpostLogSystem(v13);
  uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v27 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCAcceptApplicants  enableTelemetry=YES ",  buf,  0xCu);
  }

  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472LL;
  v25[2] = sub_1001CC044;
  v25[3] = &unk_100293338;
  v25[4] = a1;
  BOOL v16 = sub_1001C7358(a2, v25);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v6, v8);
  uint64_t v18 = _OctagonSignpostLogSystem(Nanoseconds);
  uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
  uint64_t v20 = v19;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v19))
  {
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v27) = v16;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_INTERVAL_END,  v6,  "SOSCCAcceptApplicants",  " SOSSignpostNameSOSCCAcceptApplicants=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCAcceptApplicants}d ",  buf,  8u);
  }

  uint64_t v22 = _OctagonSignpostLogSystem(v21);
  uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v27 = v6;
    __int16 v28 = 2048;
    double v29 = (double)Nanoseconds / 1000000000.0;
    __int16 v30 = 1026;
    BOOL v31 = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCAcceptApplicants  SOSSignpostNameSOSCCAcceptApplicants=%{public,signpost.telemetry:number1,na me=SOSSignpostNameSOSCCAcceptApplicants}d ",  buf,  0x1Cu);
  }

  return v16;
}

uint64_t sub_1001CC044(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  uint64_t v6 = *(void *)(a1 + 32);
  id v7 = v5;
  uint64_t v12 = 0LL;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2020000000LL;
  char v15 = 1;
  v11[0] = 0LL;
  v11[1] = v11;
  v11[2] = 0x2020000000LL;
  v11[3] = 0LL;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  _DWORD v10[2] = sub_1001926B0;
  void v10[3] = &unk_1002918A0;
  void v10[5] = v11;
  void v10[6] = a3;
  void v10[4] = &v12;
  sub_10019235C(v7, v6, v10);
  uint64_t v8 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(v11, 8);
  _Block_object_dispose(&v12, 8);

  return v8;
}

void sub_1001CC124( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_1001CC148(CFTypeRef *a1)
{
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000LL;
  uint64_t v7 = 0LL;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1001CC1E8;
  v3[3] = &unk_1002932D0;
  void v3[4] = &v4;
  sub_1001C44A8(a1, v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1001CC1D0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_1001CC1E8(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = sub_10019BF14(v5, a3, &stru_100291FF8);

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

uint64_t sub_1001CC254(CFTypeRef *a1)
{
  uint64_t v26 = 0LL;
  os_signpost_id_t v27 = &v26;
  uint64_t v28 = 0x2020000000LL;
  uint64_t v29 = 0LL;
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  uint64_t v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCCopyConcurringPeerPeerInfo",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v31 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCCopyConcurringPeerPeerInfo  enableTelemetry=YES ",  buf,  0xCu);
  }

  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472LL;
  v25[2] = sub_1001CC530;
  v25[3] = &unk_1002932D0;
  v25[4] = &v26;
  sub_1001C44A8(a1, v25);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v15 = _OctagonSignpostLogSystem(Nanoseconds);
  BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
  BOOL v17 = v16;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v16))
  {
    BOOL v18 = v27[3] != 0;
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v31) = v18;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v17,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCCopyConcurringPeerPeerInfo",  " SOSSignpostNameSOSCCCopyConcurringPeerPeerInfo=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyC oncurringPeerPeerInfo}d ",  buf,  8u);
  }

  uint64_t v20 = _OctagonSignpostLogSystem(v19);
  uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = v27[3];
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v31 = v4;
    __int16 v32 = 2048;
    double v33 = (double)Nanoseconds / 1000000000.0;
    __int16 v34 = 1026;
    BOOL v35 = v22 != 0;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCCopyConcurringPeerPeerInfo  SOSSignpostNameSOSCCCopyConcurringPeerPeerInfo=%{public,signpost. telemetry:number1,name=SOSSignpostNameSOSCCCopyConcurringPeerPeerInfo}d ",  buf,  0x1Cu);
  }

  uint64_t v23 = v27[3];
  _Block_object_dispose(&v26, 8);
  return v23;
}

void sub_1001CC4F8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_1001CC530(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = sub_10019BF14(v5, a3, &stru_100292018);

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

uint64_t sub_1001CC59C(CFTypeRef *a1)
{
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2020000000LL;
  uint64_t v7 = 0LL;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1001CC63C;
  v3[3] = &unk_1002932D0;
  void v3[4] = &v4;
  sub_1001C44A8(a1, v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1001CC624( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_1001CC63C(uint64_t a1, void *a2)
{
  id v3 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  CFTypeRef PeerID = (const __CFString *)SOSPeerInfoGetPeerID([v3 peerInfo]);

  if (PeerID) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = CFStringCreateCopy(kCFAllocatorDefault, PeerID);
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

uint64_t sub_1001CC6B8(CFTypeRef *a1)
{
  uint64_t v26 = 0LL;
  os_signpost_id_t v27 = &v26;
  uint64_t v28 = 0x2020000000LL;
  uint64_t v29 = 0LL;
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  uint64_t v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCCopyMyPeerInfo",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v31 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCCopyMyPeerInfo  enableTelemetry=YES ",  buf,  0xCu);
  }

  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472LL;
  v25[2] = sub_1001CC994;
  v25[3] = &unk_1002932D0;
  v25[4] = &v26;
  sub_1001C44A8(a1, v25);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v15 = _OctagonSignpostLogSystem(Nanoseconds);
  BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
  BOOL v17 = v16;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v16))
  {
    BOOL v18 = v27[3] != 0;
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v31) = v18;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v17,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCCopyMyPeerInfo",  " SOSSignpostNameSOSCCCopyMyPeerInfo=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyMyPeerInfo}d ",  buf,  8u);
  }

  uint64_t v20 = _OctagonSignpostLogSystem(v19);
  uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = v27[3];
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v31 = v4;
    __int16 v32 = 2048;
    double v33 = (double)Nanoseconds / 1000000000.0;
    __int16 v34 = 1026;
    BOOL v35 = v22 != 0;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCCopyMyPeerInfo  SOSSignpostNameSOSCCCopyMyPeerInfo=%{public,signpost.telemetry:number1,name=S OSSignpostNameSOSCCCopyMyPeerInfo}d ",  buf,  0x1Cu);
  }

  uint64_t v23 = v27[3];
  _Block_object_dispose(&v26, 8);
  return v23;
}

void sub_1001CC95C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_1001CC994(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = SOSPeerInfoCreateCopy( kCFAllocatorDefault,  [v5 peerInfo],  a3);

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

uint64_t sub_1001CCA10(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v30 = 0LL;
  os_signpost_id_t v31 = &v30;
  uint64_t v32 = 0x2020000000LL;
  uint64_t v33 = 0LL;
  uint64_t v4 = _OctagonSignpostLogSystem(a1);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  os_signpost_id_t v6 = _OctagonSignpostCreate();
  uint64_t v8 = v7;

  uint64_t v10 = _OctagonSignpostLogSystem(v9);
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
  uint64_t v12 = v11;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_INTERVAL_BEGIN,  v6,  "SOSCCSetNewPublicBackupKey",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v14 = _OctagonSignpostLogSystem(v13);
  uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v35 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCSetNewPublicBackupKey  enableTelemetry=YES ",  buf,  0xCu);
  }

  BOOL v16 = sub_10001267C("devRecovery");
  BOOL v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "SOSCCSetNewPublicBackupKey_Server acquiring account lock",  buf,  2u);
  }

  v29[0] = _NSConcreteStackBlock;
  v29[1] = 3221225472LL;
  v29[2] = sub_1001CCD40;
  v29[3] = &unk_100293458;
  void v29[5] = a1;
  v29[6] = a2;
  void v29[4] = &v30;
  sub_1001C7358(a2, v29);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v6, v8);
  uint64_t v19 = _OctagonSignpostLogSystem(Nanoseconds);
  uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
  uint64_t v21 = v20;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v20))
  {
    BOOL v22 = v31[3] != 0;
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v35) = v22;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v21,  OS_SIGNPOST_INTERVAL_END,  v6,  "SOSCCSetNewPublicBackupKey",  " SOSSignpostNameSOSCCSetNewPublicBackupKey=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCSetNewPublicBackupKey}d ",  buf,  8u);
  }

  uint64_t v24 = _OctagonSignpostLogSystem(v23);
  uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v26 = v31[3];
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v35 = v6;
    __int16 v36 = 2048;
    double v37 = (double)Nanoseconds / 1000000000.0;
    __int16 v38 = 1026;
    BOOL v39 = v26 != 0;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCSetNewPublicBackupKey  SOSSignpostNameSOSCCSetNewPublicBackupKey=%{public,signpost.telemetry: number1,name=SOSSignpostNameSOSCCSetNewPublicBackupKey}d ",  buf,  0x1Cu);
  }

  uint64_t v27 = v31[3];
  _Block_object_dispose(&v30, 8);
  return v27;
}

void sub_1001CCD08( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

BOOL sub_1001CCD40(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  os_signpost_id_t v6 = sub_10001267C("devRecovery");
  uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v7,  OS_LOG_TYPE_DEFAULT,  "SOSCCSetNewPublicBackupKey_Server acquired account lock",  buf,  2u);
  }

  int v8 = sub_1001959EC(v5, *(const __CFData **)(a1 + 40), *(void *)(a1 + 48));
  uint64_t v9 = sub_10001267C("devRecovery");
  uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
  BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
  if (v8)
  {
    if (v11)
    {
      *(_WORD *)uint64_t v20 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "SOSCCSetNewPublicBackupKey_Server, new public backup is set in account",  v20,  2u);
    }

    [v5 restart];
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = SOSPeerInfoCreateCopy( kCFAllocatorDefault,  [v12 peerInfo],  a3);

    uint64_t v13 = sub_10001267C("devRecovery");
    uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v19 = 0;
      uint64_t v14 = "SOSCCSetNewPublicBackupKey_Server, new public backup is set and pushed";
      uint64_t v15 = (uint8_t *)&v19;
LABEL_10:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v14, v15, 2u);
    }
  }

  else if (v11)
  {
    __int16 v18 = 0;
    uint64_t v14 = "SOSCCSetNewPublicBackupKey_Server, could not set new public backup";
    uint64_t v15 = (uint8_t *)&v18;
    goto LABEL_10;
  }

  BOOL v16 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
  return v16;
}

BOOL sub_1001CCEFC(uint64_t a1, char a2, CFTypeRef *a3)
{
  uint64_t v6 = _OctagonSignpostLogSystem(a1);
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  os_signpost_id_t v8 = _OctagonSignpostCreate();
  uint64_t v10 = v9;

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  uint64_t v14 = v13;
  if (v8 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v13))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v14,  OS_SIGNPOST_INTERVAL_BEGIN,  v8,  "SOSCCRegisterSingleRecoverySecret",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v16 = _OctagonSignpostLogSystem(v15);
  BOOL v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v30 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCRegisterSingleRecoverySecret  enableTelemetry=YES ",  buf,  0xCu);
  }

  v27[0] = _NSConcreteStackBlock;
  v27[1] = 3221225472LL;
  v27[2] = sub_1001CD168;
  v27[3] = &unk_100293478;
  char v28 = a2;
  void v27[4] = a1;
  void v27[5] = a3;
  BOOL v18 = sub_1001C7358(a3, v27);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v8, v10);
  uint64_t v20 = _OctagonSignpostLogSystem(Nanoseconds);
  uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
  BOOL v22 = v21;
  if (v8 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v21))
  {
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v30) = v18;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v22,  OS_SIGNPOST_INTERVAL_END,  v8,  "SOSCCRegisterSingleRecoverySecret",  " SOSSignpostNameSOSCCRegisterSingleRecoverySecret=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCReg isterSingleRecoverySecret}d ",  buf,  8u);
  }

  uint64_t v24 = _OctagonSignpostLogSystem(v23);
  uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v30 = v8;
    __int16 v31 = 2048;
    double v32 = (double)Nanoseconds / 1000000000.0;
    __int16 v33 = 1026;
    BOOL v34 = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCRegisterSingleRecoverySecret  SOSSignpostNameSOSCCRegisterSingleRecoverySecret=%{public,signp ost.telemetry:number1,name=SOSSignpostNameSOSCCRegisterSingleRecoverySecret}d ",  buf,  0x1Cu);
  }

  return v18;
}

BOOL sub_1001CD168(uint64_t a1, void *a2)
{
  id v3 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  int v4 = *(unsigned __int8 *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 32);
  id v5 = *(__CFString ***)(a1 + 40);
  id v7 = v3;
  uint64_t v34 = 0LL;
  os_signpost_id_t v35 = &v34;
  uint64_t v36 = 0x2020000000LL;
  char v37 = 0;
  uint64_t v8 = (uint64_t)[v7 isInCircle:v5];
  if ((v8 & 1) != 0)
  {
    if (v4)
    {
      uint64_t v16 = sub_100194C30(v8, v9, v10, v11, v12, v13, v14, v15);
      uint64_t v24 = sub_100107FA8(kCFAllocatorDefault, v17, v18, v19, v20, v21, v22, v23, (uint64_t)kSecValueData, v6);
      OSStatus v25 = SecItemUpdate(v16, v24);
      if (v25 == -25300)
      {
        MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0LL, v16);
        *(void *)&__int128 context = _NSConcreteStackBlock;
        *((void *)&context + 1) = 3221225472LL;
        BOOL v39 = sub_100195D78;
        id v40 = &unk_100293110;
        CFMutableDictionaryRef v41 = MutableCopy;
        CFDictionaryApplyFunction(v24, (CFDictionaryApplierFunction)sub_100195D80, &context);
        OSStatus v25 = SecItemAdd(MutableCopy, 0LL);
        if (MutableCopy) {
          CFRelease(MutableCopy);
        }
      }

      BOOL v27 = sub_1000194E0(v25, v5, @"Error saving %@", v16);
      if (v16) {
        CFRelease(v16);
      }
      if (v24) {
        CFRelease(v24);
      }
      *((_BYTE *)v35 + 24) = v27;
      if (!v27)
      {
        char v28 = sub_10001267C("keybag");
        uint64_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue(v28);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          os_signpost_id_t v30 = *v5;
          LODWORD(context) = 138412290;
          *(void *)((char *)&context + 4) = v30;
          _os_log_impl( (void *)&_mh_execute_header,  v29,  OS_LOG_TYPE_DEFAULT,  "failed to set V0 keybag (%@)",  (uint8_t *)&context,  0xCu);
        }
      }
    }

    else
    {
      *((_BYTE *)v35 + 24) = 1;
      Direct = (const void *)SOSBackupSliceKeyBagCreateDirect(kCFAllocatorDefault, v6, v5);
      *(void *)&__int128 context = _NSConcreteStackBlock;
      *((void *)&context + 1) = 3221225472LL;
      BOOL v39 = sub_100195D98;
      id v40 = &unk_100291D58;
      int v42 = &v34;
      CFMutableDictionaryRef v41 = (CFMutableDictionaryRef)v7;
      uint64_t v43 = Direct;
      uint64_t v44 = v5;
      sub_1001953F4(v41, &context);

      if (Direct) {
        CFRelease(Direct);
      }
    }
  }

  BOOL v32 = *((_BYTE *)v35 + 24) != 0;
  _Block_object_dispose(&v34, 8);

  return v32;
}

void sub_1001CD41C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
}

uint64_t sub_1001CD440(CFTypeRef *a1)
{
  uint64_t v4 = 0LL;
  id v5 = &v4;
  uint64_t v6 = 0x2020000000LL;
  int v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1001CD4E0;
  v3[3] = &unk_1002932D0;
  void v3[4] = &v4;
  sub_1001C44A8(a1, v3);
  uint64_t v1 = *((unsigned int *)v5 + 6);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1001CD4C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_1001CD4E0(uint64_t a1, void *a2)
{
  id v3 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 trust]);
  unsigned int v5 = [v4 departureCode];

  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v5;
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0;
}

BOOL sub_1001CD550(int a1, CFTypeRef *a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1001CD5A8;
  v3[3] = &unk_100293498;
  int v4 = a1;
  return sub_1001C44A8(a2, v3);
}

uint64_t sub_1001CD5A8(uint64_t a1, void *a2)
{
  id v3 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  uint64_t v4 = *(unsigned int *)(a1 + 32);
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue([v3 trust]);
  [v5 setDepartureCode:v4];

  return 1LL;
}

BOOL sub_1001CD600(CFTypeRef *a1)
{
  uint64_t v2 = sub_10001267C("updates");
  id v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v26) = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "Request for registering peers",  (uint8_t *)&v26,  2u);
  }

  uint64_t v5 = _OctagonSignpostLogSystem(v4);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  os_signpost_id_t v7 = _OctagonSignpostCreate();
  uint64_t v9 = v8;

  uint64_t v11 = _OctagonSignpostLogSystem(v10);
  int v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
  int v13 = v12;
  if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v12))
  {
    LOWORD(v26) = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v13,  OS_SIGNPOST_INTERVAL_BEGIN,  v7,  "SOSCCProcessEnsurePeerRegistration",  " enableTelemetry=YES ",  (uint8_t *)&v26,  2u);
  }

  uint64_t v15 = _OctagonSignpostLogSystem(v14);
  uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    int v26 = 134217984;
    os_signpost_id_t v27 = v7;
    _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCProcessEnsurePeerRegistration  enableTelemetry=YES ",  (uint8_t *)&v26,  0xCu);
  }

  BOOL v17 = sub_1001C7358(a1, &stru_1002934B8);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v7, v9);
  uint64_t v19 = _OctagonSignpostLogSystem(Nanoseconds);
  int v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
  int v21 = v20;
  if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v20))
  {
    int v26 = 67240192;
    LODWORD(v27) = v17;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v21,  OS_SIGNPOST_INTERVAL_END,  v7,  "SOSCCProcessEnsurePeerRegistration",  " SOSSignpostNameSOSCCProcessEnsurePeerRegistration=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCPr ocessEnsurePeerRegistration}d ",  (uint8_t *)&v26,  8u);
  }

  uint64_t v23 = _OctagonSignpostLogSystem(v22);
  uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    int v26 = 134218496;
    os_signpost_id_t v27 = v7;
    __int16 v28 = 2048;
    double v29 = (double)Nanoseconds / 1000000000.0;
    __int16 v30 = 1026;
    BOOL v31 = v17;
    _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCProcessEnsurePeerRegistration  SOSSignpostNameSOSCCProcessEnsurePeerRegistration=%{public,sig npost.telemetry:number1,name=SOSSignpostNameSOSCCProcessEnsurePeerRegistration}d ",  (uint8_t *)&v26,  0x1Cu);
  }

  return v17;
}

BOOL sub_1001CD878(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  id v3 = a2;
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](v3, "account"));
  unsigned int v5 = [v4 SOSMonitorModeSOSIsActive];

  if (v5)
  {
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](v3, "account"));
    sub_100192738(v6);
  }

  return 1;
}

uint64_t sub_1001CD8DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (qword_1002DEEA8 != -1) {
    dispatch_once(&qword_1002DEEA8, &stru_1002934D8);
  }
  uint64_t v13 = 0LL;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2020000000LL;
  CFMutableSetRef Mutable = (CFMutableSetRef)0xAAAAAAAAAAAAAAAALL;
  CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
  uint64_t v9 = 0LL;
  uint64_t v10 = &v9;
  uint64_t v11 = 0x2020000000LL;
  CFMutableSetRef v12 = (CFMutableSetRef)0xAAAAAAAAAAAAAAAALL;
  CFMutableSetRef v12 = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
  if (!a1)
  {
    a1 = v10[3];
    if (a2) {
      goto LABEL_6;
    }
LABEL_10:
    a2 = v10[3];
    goto LABEL_6;
  }

  if (!a2) {
    goto LABEL_10;
  }
LABEL_6:
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1001CDA6C;
  block[3] = &unk_100293528;
  block[6] = a1;
  block[7] = a2;
  block[8] = a3;
  void block[4] = &v13;
  void block[5] = &v9;
  dispatch_sync((dispatch_queue_t)qword_1002DEEA0, block);
  uint64_t v6 = v14[3];
  _Block_object_dispose(&v9, 8);
  _Block_object_dispose(&v13, 8);
  return v6;
}

void sub_1001CDA54(_Unwind_Exception *a1)
{
}

void sub_1001CDA6C(uint64_t a1)
{
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  uint64_t v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCProcessSyncWithPeers",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCProcessSyncWithPeers  enableTelemetry=YES ",  buf,  0xCu);
  }

  CFIndex Count = CFSetGetCount(*(CFSetRef *)(a1 + 48));
  if (CFSetGetCount(*(CFSetRef *)(a1 + 56)) + Count > 6)
  {
    BOOL v17 = *(const __CFSet **)(a1 + 56);
    if (v17 && CFSetGetCount(v17))
    {
      int v18 = *(const __CFSet **)(a1 + 56);
      uint64_t v19 = *(void *)(a1 + 64);
      v38[0] = _NSConcreteStackBlock;
      v38[1] = 3221225472LL;
      v38[2] = sub_1001CE11C;
      v38[3] = &unk_100293500;
      int8x16_t v39 = vextq_s8(*(int8x16_t *)(a1 + 32), *(int8x16_t *)(a1 + 32), 8uLL);
      sub_1001CE188(v18, v19, v38);
    }

    int v20 = *(const __CFSet **)(a1 + 48);
    if (v20 && CFSetGetCount(v20))
    {
      int v21 = *(const __CFSet **)(a1 + 48);
      uint64_t v22 = *(void *)(a1 + 64);
      v36[0] = _NSConcreteStackBlock;
      v36[1] = 3221225472LL;
      v36[2] = sub_1001CE340;
      void v36[3] = &unk_100293500;
      int8x16_t v37 = vextq_s8(*(int8x16_t *)(a1 + 32), *(int8x16_t *)(a1 + 32), 8uLL);
      sub_1001CE188(v21, v22, v36);
    }
  }

  else
  {
    uint64_t v15 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    uint64_t v16 = *(CFTypeRef **)(a1 + 64);
    *(void *)__int128 buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472LL;
    *(void *)&uint8_t buf[16] = sub_1001CDE1C;
    CFMutableDictionaryRef v41 = &unk_100293AF0;
    __int128 v42 = *(_OWORD *)(a1 + 48);
    uint64_t v43 = v15;
    sub_1001C7358(v16, buf);
  }

  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v24 = _OctagonSignpostLogSystem(Nanoseconds);
  OSStatus v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
  int v26 = v25;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v25))
  {
    CFIndex v27 = CFSetGetCount(*(CFSetRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
    *(_DWORD *)__int128 buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = v27 != 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v26,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCProcessSyncWithPeers",  " SOSSignpostNameSOSCCProcessSyncWithPeers=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCProcessSyncWithPeers}d ",  buf,  8u);
  }

  uint64_t v29 = _OctagonSignpostLogSystem(v28);
  __int16 v30 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    CFIndex v31 = CFSetGetCount(*(CFSetRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL));
    *(_DWORD *)__int128 buf = 134218496;
    *(void *)&uint8_t buf[4] = v4;
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(double *)&buf[14] = (double)Nanoseconds / 1000000000.0;
    *(_WORD *)&buf[22] = 1026;
    LODWORD(v41) = v31 != 0;
    _os_log_impl( (void *)&_mh_execute_header,  v30,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCProcessSyncWithPeers  SOSSignpostNameSOSCCProcessSyncWithPeers=%{public,signpost.telemetry:nu mber1,name=SOSSignpostNameSOSCCProcessSyncWithPeers}d ",  buf,  0x1Cu);
  }

  if (!CFSetGetCount(*(CFSetRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)))
  {
    uint64_t v32 = *(void *)(*(void *)(a1 + 32) + 8LL);
    __int16 v33 = *(const void **)(v32 + 24);
    if (v33)
    {
      *(void *)(v32 + 24) = 0LL;
      CFRelease(v33);
    }
  }

  uint64_t v34 = *(void *)(*(void *)(a1 + 40) + 8LL);
  os_signpost_id_t v35 = *(const void **)(v34 + 24);
  if (v35)
  {
    *(void *)(v34 + 24) = 0LL;
    CFRelease(v35);
  }

uint64_t sub_1001CDE1C(void *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
  unsigned int v7 = [v6 SOSMonitorModeSOSIsActive];

  if (v7)
  {
    uint64_t v8 = (const __CFSet *)a1[4];
    uint64_t v9 = a1[5];
    id v10 = v5;
    CFTypeRef cf = 0LL;
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v10 account]);
    uint64_t v12 = &qword_100205000;
    if ((sub_100197C6C(v11, a3) & 1) != 0)
    {
      CFMutableSetRef Mutable = sub_1001981F8(v10, v8, (uint64_t)&cf);
      if (!Mutable)
      {
        uint64_t v14 = sub_10001267C("account-sync");
        uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = cf;
          _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "Peer Sync failed: %@",  (uint8_t *)&buf,  0xCu);
        }

        CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
      }

      CFTypeRef v16 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
        CFRelease(v16);
      }

      BOOL v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "kvs_message_transport"));
      id v18 = [v17 SOSTransportMessageGetEngine];

      uint64_t v19 = sub_1000D3638((uint64_t)v18, v9, 0, a3);
      int v20 = v19;
      if (v19)
      {
        *(void *)&__int128 buf = _NSConcreteStackBlock;
        uint64_t v12 = &qword_100205000;
        *((void *)&buf + 1) = 3221225472LL;
        uint64_t v29 = sub_100198580;
        __int16 v30 = &unk_100293EA8;
        CFIndex v31 = Mutable;
        CFSetApplyFunction(v19, (CFSetApplierFunction)sub_1001981E4, &buf);
      }

      else
      {
        int v21 = sub_10001267C("account-sync");
        uint64_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue(v21);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = cf;
          _os_log_impl( (void *)&_mh_execute_header,  v22,  OS_LOG_TYPE_DEFAULT,  "Engine Backup Sync failed: %@",  (uint8_t *)&buf,  0xCu);
        }

        uint64_t v12 = &qword_100205000;
      }

      CFTypeRef v23 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
        CFRelease(v23);
      }

      if (v20) {
        CFRelease(v20);
      }
    }

    else
    {
      CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
    }

    uint64_t v24 = (const __CFSet *)a1[6];
    *(void *)&__int128 buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = v12[1];
    uint64_t v29 = sub_1001CE458;
    __int16 v30 = &unk_100293EA8;
    CFIndex v31 = v24;
    CFSetApplyFunction(Mutable, (CFSetApplierFunction)sub_1001C3BC8, &buf);
    if (!Mutable)
    {
      uint64_t v25 = 0LL;
      goto LABEL_22;
    }

    CFRelease(Mutable);
  }

  uint64_t v25 = 1LL;
LABEL_22:

  return v25;
}

BOOL sub_1001CE11C(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v3 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  v6[2] = sub_1001CDE1C;
  v6[3] = &unk_100293AF0;
  void v6[4] = v3;
  void v6[5] = a2;
  void v6[6] = v4;
  return sub_1001C7358(a3, v6);
}

void sub_1001CE188(const __CFSet *a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v22 = 0LL;
  CFTypeRef v23 = &v22;
  uint64_t v24 = 0x2020000000LL;
  char v25 = 1;
  v21[0] = 0LL;
  v21[1] = v21;
  v21[2] = 0x2020000000LL;
  v21[3] = 0LL;
  uint64_t v17 = 0LL;
  id v18 = &v17;
  uint64_t v19 = 0x2020000000LL;
  CFMutableSetRef Mutable = (CFMutableSetRef)0xAAAAAAAAAAAAAAAALL;
  CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeSetCallBacks);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  _DWORD v10[2] = sub_1001CE3AC;
  void v10[3] = &unk_100293B18;
  uint64_t v12 = &v17;
  uint64_t v13 = v21;
  uint64_t v14 = &v22;
  uint64_t v15 = 7LL;
  id v6 = v5;
  id v11 = v6;
  uint64_t v16 = a2;
  CFSetApplyFunction(a1, (CFSetApplierFunction)sub_1001C3BC8, v10);
  if (CFSetGetCount((CFSetRef)v18[3]))
  {
    char v7 = (*((uint64_t (**)(id, uint64_t, uint64_t))v6 + 2))(v6, v18[3], a2);
    if (*((_BYTE *)v23 + 24)) {
      char v8 = v7;
    }
    else {
      char v8 = 0;
    }
    *((_BYTE *)v23 + 24) = v8;
  }

  uint64_t v9 = (const void *)v18[3];
  if (v9)
  {
    void v18[3] = 0LL;
    CFRelease(v9);
  }

  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(v21, 8);
  _Block_object_dispose(&v22, 8);
}

void sub_1001CE304( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

BOOL sub_1001CE340(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v3 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  v6[2] = sub_1001CDE1C;
  v6[3] = &unk_100293AF0;
  void v6[4] = a2;
  void v6[5] = v3;
  void v6[6] = v4;
  return sub_1001C7358(a3, v6);
}

void sub_1001CE3AC(void *a1, const void *a2)
{
  if (++*(void *)(*(void *)(a1[6] + 8LL) + 24LL) >= a1[8])
  {
    char v3 = (*(uint64_t (**)(void))(a1[4] + 16LL))();
    uint64_t v4 = *(void *)(a1[7] + 8LL);
    if (*(_BYTE *)(v4 + 24)) {
      char v5 = v3;
    }
    else {
      char v5 = 0;
    }
    *(_BYTE *)(v4 + 24) = v5;
    *(void *)(*(void *)(a1[6] + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 0LL;
    CFSetRemoveAllValues(*(CFMutableSetRef *)(*(void *)(a1[5] + 8LL) + 24LL));
  }

void sub_1001CE458(uint64_t a1, const void *a2)
{
}

void sub_1001CE460(id a1)
{
  dispatch_queue_t v1 = dispatch_queue_create("syncWithPeers", 0LL);
  uint64_t v2 = (void *)qword_1002DEEA0;
  qword_1002DEEA0 = (uint64_t)v1;
}

uint64_t sub_1001CE48C(CFErrorRef *a1)
{
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  char v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  id v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCProcessSyncWithAllPeers",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v32 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCProcessSyncWithAllPeers  enableTelemetry=YES ",  buf,  0xCu);
  }

  CFTypeRef cf = 0LL;
  if (sub_1001C7358(&cf, &stru_100293548) || !cf)
  {
    uint64_t v17 = 1LL;
  }

  else
  {
    if (SecErrorGetOSStatus(cf) == -25308)
    {
      uint64_t v14 = sub_10001267C("updates");
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "SOSAccountSyncWithAllKVSPeers failed because device is locked; letting CloudKeychainProxy know",
          buf,
          2u);
      }

      CFTypeRef v16 = cf;
      if (!cf)
      {
        uint64_t v17 = 2LL;
        goto LABEL_14;
      }

      CFTypeRef cf = 0LL;
      CFRelease(v16);
      uint64_t v17 = 2LL;
    }

    else
    {
      int v26 = sub_10001267C("SecError");
      CFIndex v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412290;
        os_signpost_id_t v32 = (os_signpost_id_t)cf;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Unexpected error: %@", buf, 0xCu);
      }

      uint64_t v17 = 1LL;
    }

    uint64_t v28 = (__CFError *)cf;
    if (a1 && cf)
    {
      if (!*a1) {
        goto LABEL_33;
      }
      if (CFErrorGetCode(*a1) == -25330)
      {
        CFErrorRef v29 = *a1;
        if (!*a1) {
          goto LABEL_33;
        }
        *a1 = 0LL;
        CFRelease(v29);
      }

BOOL sub_1001CE800(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  os_signpost_id_t v4 = a2;
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](v4, "account"));
  unsigned int v6 = [v5 SOSMonitorModeSOSIsActive];

  if (v6) {
    unsigned __int8 v7 = sub_10019865C(v4, (uint64_t)a3);
  }
  else {
    unsigned __int8 v7 = 0;
  }

  return v7;
}

void sub_1001CE868( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFArrayRef v8 = sub_1001141B8(kCFAllocatorDefault, a2, a3, a4, a5, a6, a7, a8, a1);
  activity_block[0] = _NSConcreteStackBlock;
  activity_block[1] = 3221225472LL;
  activity_block[2] = sub_1001C3D44;
  activity_block[3] = &unk_1002935A8;
  activity_void block[4] = v8;
  _os_activity_initiate( (void *)&_mh_execute_header,  "CloudCircle RequestSyncWithPeersList",  OS_ACTIVITY_FLAG_DEFAULT,  activity_block);
  if (v8) {
    CFRelease(v8);
  }
}

void sub_1001CE908(uint64_t a1)
{
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  char v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  id v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCRequestSyncWithBackupPeerList",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v33 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCRequestSyncWithBackupPeerList  enableTelemetry=YES ",  buf,  0xCu);
  }

  CFArrayRef v21 = sub_1001141B8(kCFAllocatorDefault, v14, v15, v16, v17, v18, v19, v20, 0LL);
  sub_100012EDC(*(const __CFArray **)(a1 + 32), @"[", @"]", (uint64_t)&stru_1002935C8);
  uint64_t v22 = *(void *)(a1 + 32);
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(-32768LL, 0LL);
  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(global_queue);
  SOSCloudKeychainRequestSyncWithPeers(v21, v22, v24, 0LL);

  if (v21) {
    CFRelease(v21);
  }
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v26 = _OctagonSignpostLogSystem(Nanoseconds);
  CFIndex v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
  uint64_t v28 = v27;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v27))
  {
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v33) = 1;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v28,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCRequestSyncWithBackupPeerList",  " SOSSignpostNameSOSCCRequestSyncWithBackupPeerList=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRe questSyncWithBackupPeerList}d ",  buf,  8u);
  }

  uint64_t v30 = _OctagonSignpostLogSystem(v29);
  CFIndex v31 = (os_log_s *)objc_claimAutoreleasedReturnValue(v30);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v33 = v4;
    __int16 v34 = 2048;
    double v35 = (double)Nanoseconds / 1000000000.0;
    __int16 v36 = 1026;
    int v37 = 1;
    _os_log_impl( (void *)&_mh_execute_header,  v31,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCRequestSyncWithBackupPeerList  SOSSignpostNameSOSCCRequestSyncWithBackupPeerList=%{public,sig npost.telemetry:number1,name=SOSSignpostNameSOSCCRequestSyncWithBackupPeerList}d ",  buf,  0x1Cu);
  }
}

void sub_1001CEB98(id a1, __CFString *a2)
{
  char v3 = sub_10001267C("syncwith");
  os_signpost_id_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 138412290;
    uint64_t v6 = a2;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Request backup sync With: %@",  (uint8_t *)&v5,  0xCu);
  }
}

void sub_1001CEC40(id a1)
{
  uint64_t v1 = _OctagonSignpostLogSystem(a1);
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(v1);
  os_signpost_id_t v3 = _OctagonSignpostCreate();
  uint64_t v5 = v4;

  uint64_t v7 = _OctagonSignpostLogSystem(v6);
  uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
  uint64_t v9 = v8;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
  {
    LOWORD(v22) = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v9,  OS_SIGNPOST_INTERVAL_BEGIN,  v3,  "SOSCCEnsurePeerRegistration",  " enableTelemetry=YES ",  (uint8_t *)&v22,  2u);
  }

  uint64_t v11 = _OctagonSignpostLogSystem(v10);
  uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v22 = 134217984;
    os_signpost_id_t v23 = v3;
    _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCEnsurePeerRegistration  enableTelemetry=YES ",  (uint8_t *)&v22,  0xCu);
  }

  dispatch_queue_global_t global_queue = dispatch_get_global_queue(-32768LL, 0LL);
  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(global_queue);
  SOSCloudKeychainRequestEnsurePeerRegistration(v14, 0LL);

  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v3, v5);
  uint64_t v16 = _OctagonSignpostLogSystem(Nanoseconds);
  uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
  uint64_t v18 = v17;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v17))
  {
    int v22 = 67240192;
    LODWORD(v23) = 1;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v18,  OS_SIGNPOST_INTERVAL_END,  v3,  "SOSCCEnsurePeerRegistration",  " SOSSignpostNameSOSCCEnsurePeerRegistration=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCEnsurePee rRegistration}d ",  (uint8_t *)&v22,  8u);
  }

  uint64_t v20 = _OctagonSignpostLogSystem(v19);
  CFArrayRef v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    int v22 = 134218496;
    os_signpost_id_t v23 = v3;
    __int16 v24 = 2048;
    double v25 = (double)Nanoseconds / 1000000000.0;
    __int16 v26 = 1026;
    int v27 = 1;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCEnsurePeerRegistration  SOSSignpostNameSOSCCEnsurePeerRegistration=%{public,signpost.telemetr y:number1,name=SOSSignpostNameSOSCCEnsurePeerRegistration}d ",  (uint8_t *)&v22,  0x1Cu);
  }
}

uint64_t sub_1001CEE70(CFTypeRef *a1)
{
  uint64_t v26 = 0LL;
  int v27 = &v26;
  uint64_t v28 = 0x2020000000LL;
  uint64_t v29 = 0LL;
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  os_signpost_id_t v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  uint64_t v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCCopyApplication",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v31 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCCopyApplication  enableTelemetry=YES ",  buf,  0xCu);
  }

  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472LL;
  v25[2] = sub_1001CF14C;
  v25[3] = &unk_1002932D0;
  v25[4] = &v26;
  sub_1001C7358(a1, v25);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v15 = _OctagonSignpostLogSystem(Nanoseconds);
  uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
  uint64_t v17 = v16;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v16))
  {
    BOOL v18 = v27[3] != 0;
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v31) = v18;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v17,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCCopyApplication",  " SOSSignpostNameSOSCCCopyApplication=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyApplication}d ",  buf,  8u);
  }

  uint64_t v20 = _OctagonSignpostLogSystem(v19);
  CFArrayRef v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = v27[3];
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v31 = v4;
    __int16 v32 = 2048;
    double v33 = (double)Nanoseconds / 1000000000.0;
    __int16 v34 = 1026;
    BOOL v35 = v22 != 0;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCCopyApplication  SOSSignpostNameSOSCCCopyApplication=%{public,signpost.telemetry:number1,name =SOSSignpostNameSOSCCCopyApplication}d ",  buf,  0x1Cu);
  }

  uint64_t v23 = v27[3];
  _Block_object_dispose(&v26, 8);
  return v23;
}

void sub_1001CF114( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_1001CF14C(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = sub_10018F458(v5, a3);

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

BOOL sub_1001CF1B0(CFTypeRef *a1)
{
  BOOL v2 = sub_1001C7358(a1, &stru_100293608);
  BOOL v3 = v2;
  if (a1)
  {
    if (v2)
    {
      CFTypeRef v4 = *a1;
      if (*a1)
      {
        *a1 = 0LL;
        CFRelease(v4);
      }
    }
  }

  return v3;
}

BOOL sub_1001CF1F8(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  CFTypeRef v4 = (void *)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](a2, "account"));
  sub_100192BC8(v4, (uint64_t *)a3);

  return 1;
}

uint64_t sub_1001CF234(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v28 = 0LL;
  uint64_t v29 = &v28;
  uint64_t v30 = 0x2020000000LL;
  uint64_t v31 = 0LL;
  uint64_t v4 = _OctagonSignpostLogSystem(a1);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  os_signpost_id_t v6 = _OctagonSignpostCreate();
  uint64_t v8 = v7;

  uint64_t v10 = _OctagonSignpostLogSystem(v9);
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
  uint64_t v12 = v11;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_INTERVAL_BEGIN,  v6,  "SOSCCCopyCircleJoiningBlob",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v14 = _OctagonSignpostLogSystem(v13);
  uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v33 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCCopyCircleJoiningBlob  enableTelemetry=YES ",  buf,  0xCu);
  }

  v27[0] = _NSConcreteStackBlock;
  v27[1] = 3221225472LL;
  v27[2] = sub_1001CF514;
  v27[3] = &unk_100293630;
  void v27[4] = &v28;
  void v27[5] = a1;
  sub_1001C7358(a2, v27);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v6, v8);
  uint64_t v17 = _OctagonSignpostLogSystem(Nanoseconds);
  BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
  uint64_t v19 = v18;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v18))
  {
    BOOL v20 = v29[3] != 0;
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v33) = v20;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v19,  OS_SIGNPOST_INTERVAL_END,  v6,  "SOSCCCopyCircleJoiningBlob",  " SOSSignpostNameSOSCCCopyCircleJoiningBlob=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyCircleJoiningBlob}d ",  buf,  8u);
  }

  uint64_t v22 = _OctagonSignpostLogSystem(v21);
  uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = v29[3];
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v33 = v6;
    __int16 v34 = 2048;
    double v35 = (double)Nanoseconds / 1000000000.0;
    __int16 v36 = 1026;
    BOOL v37 = v24 != 0;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCCopyCircleJoiningBlob  SOSSignpostNameSOSCCCopyCircleJoiningBlob=%{public,signpost.telemetry: number1,name=SOSSignpostNameSOSCCCopyCircleJoiningBlob}d ",  buf,  0x1Cu);
  }

  uint64_t v25 = v29[3];
  _Block_object_dispose(&v28, 8);
  return v25;
}

void sub_1001CF4DC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_1001CF514(uint64_t a1, void *a2, uint64_t *a3)
{
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = sub_10018EE40( v5,  0LL,  0LL,  0LL,  0,  *(void *)(a1 + 40),  a3);

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

uint64_t sub_1001CF58C(uint64_t a1, CFTypeRef *a2)
{
  int v3 = a1;
  uint64_t v29 = 0LL;
  uint64_t v30 = &v29;
  uint64_t v31 = 0x2020000000LL;
  uint64_t v32 = 0LL;
  uint64_t v4 = _OctagonSignpostLogSystem(a1);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  os_signpost_id_t v6 = _OctagonSignpostCreate();
  uint64_t v8 = v7;

  uint64_t v10 = _OctagonSignpostLogSystem(v9);
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
  uint64_t v12 = v11;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_INTERVAL_BEGIN,  v6,  "SOSCCCopyInitialSyncData",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v14 = _OctagonSignpostLogSystem(v13);
  uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v34 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCCopyInitialSyncData  enableTelemetry=YES ",  buf,  0xCu);
  }

  v27[0] = _NSConcreteStackBlock;
  v27[1] = 3221225472LL;
  v27[2] = sub_1001CF870;
  v27[3] = &unk_100293658;
  void v27[4] = &v29;
  int v28 = v3;
  sub_1001C7358(a2, v27);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v6, v8);
  uint64_t v17 = _OctagonSignpostLogSystem(Nanoseconds);
  BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
  uint64_t v19 = v18;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v18))
  {
    BOOL v20 = v30[3] != 0;
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v34) = v20;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v19,  OS_SIGNPOST_INTERVAL_END,  v6,  "SOSCCCopyInitialSyncData",  " SOSSignpostNameSOSCCCopyInitialSyncData=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyInitialSyncData}d ",  buf,  8u);
  }

  uint64_t v22 = _OctagonSignpostLogSystem(v21);
  uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v24 = v30[3];
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v34 = v6;
    __int16 v35 = 2048;
    double v36 = (double)Nanoseconds / 1000000000.0;
    __int16 v37 = 1026;
    BOOL v38 = v24 != 0;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCCopyInitialSyncData  SOSSignpostNameSOSCCCopyInitialSyncData=%{public,signpost.telemetry:numb er1,name=SOSSignpostNameSOSCCCopyInitialSyncData}d ",  buf,  0x1Cu);
  }

  uint64_t v25 = v30[3];
  _Block_object_dispose(&v29, 8);
  return v25;
}

void sub_1001CF838( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_1001CF870(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  uint64_t v108 = a1;
  int v6 = *(_DWORD *)(a1 + 40);
  id v109 = v5;
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  if ((v6 & 4) != 0)
  {
    BOOL v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
    sub_100193780(v18, v19, 1LL);
  }

  else
  {
    if ((v6 & 2) != 0)
    {
      id v8 = v109;
      CFMutableSetRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0LL, &kCFTypeArrayCallBacks);
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v8 trust]);

      *(void *)&__int128 buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 3221225472LL;
      uint64_t v133 = sub_1001942BC;
      unsigned int v134 = (const __CFString *)&unk_100292840;
      CFBooleanRef v135 = Mutable;
      SOSCircleForEachActivePeer([v10 trustedCircle], &buf);

      uint64_t v11 = sub_10001267C("piggy");
      uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = Mutable;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "identities: %@", (uint8_t *)&buf, 0xCu);
      }

      CFIndex Count = CFArrayGetCount(Mutable);
      if (Count >= 1)
      {
        CFIndex v14 = Count;
        for (CFIndex i = 0LL; i != v14; ++i)
        {
          CFTypeRef ValueAtIndex = CFArrayGetValueAtIndex(Mutable, i);
          uint64_t v17 = (void *)SOSPeerInfoCopyData(ValueAtIndex, a3);
          if (v17) {
            [v7 addObject:v17];
          }
        }
      }

      CFRelease(Mutable);
    }

    if ((v6 & 1) != 0)
    {
      result[0] = 0LL;
      BOOL v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
      uint64_t v115 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](&OBJC_CLASS___NSMutableSet, "set"));
      sub_100193780(v18, v115, 0LL);
      *(void *)uint64_t v121 = kSecClass;
      *(void *)&v121[8] = kSecUseDataProtectionKeychain;
      *(void *)&__int128 buf = kSecClassInternetPassword;
      *((void *)&buf + 1) = &__kCFBooleanTrue;
      *(void *)&__int128 v122 = kSecAttrAccessGroup;
      *((void *)&v122 + 1) = kSecAttrDescription;
      uint64_t v133 = (void (*)(uint64_t, const void *))@"com.apple.security.ckks";
      unsigned int v134 = @"tlk";
      *(void *)&__int128 v123 = kSecAttrSynchronizable;
      *((void *)&v123 + 1) = kSecMatchLimit;
      CFBooleanRef v135 = kCFBooleanTrue;
      CFStringRef v136 = kSecMatchLimitAll;
      unsigned __int128 v124 = __PAIR128__((unint64_t)kSecReturnData, (unint64_t)kSecReturnAttributes);
      uint64_t v137 = &__kCFBooleanTrue;
      char v138 = &__kCFBooleanTrue;
      BOOL v20 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &buf,  v121,  8LL));
      if (!SecItemCopyMatching(v20, result)) {
        sub_100193BBC(v18, (void *)result[0], v115);
      }
      CFTypeRef v21 = result[0];
      if (result[0])
      {
        result[0] = 0LL;
        CFRelease(v21);
      }

      *(void *)&__int128 v125 = kSecClass;
      *((void *)&v125 + 1) = kSecUseDataProtectionKeychain;
      *(void *)unint64_t v129 = kSecClassInternetPassword;
      *(void *)&__int128 v126 = kSecAttrAccessGroup;
      *((void *)&v126 + 1) = kSecAttrDescription;
      *(void *)&v129[8] = &__kCFBooleanTrue;
      *(void *)&v129[16] = @"com.apple.security.ckks";
      *(void *)&v129[24] = @"tlk-piggy";
      *(void *)&__int128 v127 = kSecAttrSynchronizable;
      *((void *)&v127 + 1) = kSecMatchLimit;
      *(void *)&__int128 v130 = kSecAttrSynchronizableAny;
      *((void *)&v130 + 1) = kSecMatchLimitAll;
      unsigned __int128 v128 = __PAIR128__((unint64_t)kSecReturnData, (unint64_t)kSecReturnAttributes);
      *(void *)&__int128 v131 = &__kCFBooleanTrue;
      *((void *)&v131 + 1) = &__kCFBooleanTrue;
      uint64_t v22 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v129,  &v125,  8LL));

      if (!SecItemCopyMatching(v22, result)) {
        sub_100193BBC(v18, (void *)result[0], v115);
      }
      CFTypeRef v23 = result[0];
      if (result[0])
      {
        result[0] = 0LL;
        CFRelease(v23);
      }

      uint64_t v24 = sub_10001267C("piggy");
      uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v118 = 67109120;
        unsigned int v119 = [v18 count];
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Found %d TLKs", v118, 8u);
      }
    }

    else
    {
      BOOL v18 = 0LL;
    }
  }

  id v26 = v7;
  id v27 = v18;
  id v106 = v26;
  int v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  uint64_t v107 = v27;
  id v29 = [v27 mutableCopy];
  [v29 sortUsingComparator:&stru_100291958];
  __int128 v123 = 0u;
  unsigned __int128 v124 = 0u;
  *(_OWORD *)uint64_t v121 = 0u;
  __int128 v122 = 0u;
  id v30 = v29;
  id v116 = [v30 countByEnumeratingWithState:v121 objects:&buf count:16];
  if (v116)
  {
    uint64_t v113 = *(void *)v122;
    id obj = v30;
    while (2)
    {
      for (j = 0LL; j != v116; j = (char *)j + 1)
      {
        if (*(void *)v122 != v113) {
          objc_enumerationMutation(obj);
        }
        uint64_t v32 = *(void **)(*(void *)&v121[8] + 8LL * (void)j);
        os_signpost_id_t v33 = (void *)objc_claimAutoreleasedReturnValue([v32 objectForKeyedSubscript:kSecValueData]);
        os_signpost_id_t v34 = (void *)objc_claimAutoreleasedReturnValue([v32 objectForKeyedSubscript:kSecAttrServer]);
        id v35 = (id)objc_claimAutoreleasedReturnValue([v32 objectForKeyedSubscript:kSecAttrAccount]);
        double v36 = -[NSUUID initWithUUIDString:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDString:", v35);

        memset(v129, 170, 16);
        -[NSUUID getUUIDBytes:](v36, "getUUIDBytes:", v129);
        __int16 v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", v129, 16LL));

        unsigned int v38 = sub_100194038(v34);
        int8x16_t v39 = v34;
        id v40 = v37;
        id v41 = [v33 length];
        id v42 = [v40 length];

        if (v38) {
          uint64_t v43 = ccder_sizeof_uint64(v38);
        }
        else {
          uint64_t v43 = sub_10001A4B8(v39);
        }
        uint64_t v44 = v43;
        uint64_t v45 = ccder_sizeof(4LL, v42);
        uint64_t v46 = ccder_sizeof(4LL, v41);
        uint64_t v47 = ccder_sizeof(0x2000000000000010LL, v45 + v44 + v46);

        id v48 = objc_claimAutoreleasedReturnValue( +[NSMutableData dataWithLength:]( &OBJC_CLASS___NSMutableData, "dataWithLength:", v47));
        uint64_t v49 = (UInt8 *)[v48 mutableBytes];
        uint64_t v50 = (char *)[v48 length] + (void)v49;
        unsigned int v51 = sub_100194038(v39);
        if (v51)
        {
          uint64_t v52 = v51;
          id v53 = v33;
          id v54 = v40;
          uint64_t v55 = ccder_encode_uint64(v52);
        }

        else
        {
          id v56 = v33;
          id v57 = v40;
          uint64_t v55 = sub_10001A534(v39, 0LL, v49, (uint64_t)v50, v58);
        }

        uint64_t v59 = sub_1001940CC(v40, (uint64_t)v49, v55);

        uint64_t v60 = sub_1001940CC(v33, (uint64_t)v49, v59);
        if (!ccder_encode_constructed_tl(0x2000000000000010LL, v50, v49, v60))
        {

          id v30 = obj;
          id v111 = 0LL;
          goto LABEL_43;
        }

        uint64_t v61 = sub_10001267C("piggy");
        uint64_t v62 = (os_log_s *)objc_claimAutoreleasedReturnValue(v61);
        if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)unint64_t v129 = 138412546;
          *(void *)&v129[4] = v39;
          *(_WORD *)&v129[12] = 2112;
          *(void *)&v129[14] = v35;
          _os_log_impl( (void *)&_mh_execute_header,  v62,  OS_LOG_TYPE_DEFAULT,  "preparing TLK in order: %@: %@",  v129,  0x16u);
        }

        [v28 addObject:v48];
      }

      id v30 = obj;
      id v116 = [obj countByEnumeratingWithState:v121 objects:&buf count:16];
      if (v116) {
        continue;
      }
      break;
    }
  }

  id v111 = v28;
LABEL_43:

  id v63 = v106;
  char v64 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  *(_OWORD *)uint64_t v121 = 0u;
  __int128 v122 = 0u;
  __int128 v123 = 0u;
  unsigned __int128 v124 = 0u;
  id v65 = v63;
  id v66 = [v65 countByEnumeratingWithState:v121 objects:&buf count:16];
  if (v66)
  {
    id v67 = v66;
    uint64_t v68 = *(void *)v122;
    do
    {
      for (k = 0LL; k != v67; k = (char *)k + 1)
      {
        if (*(void *)v122 != v68) {
          objc_enumerationMutation(v65);
        }
        id v70 = *(void **)(*(void *)&v121[8] + 8LL * (void)k);
        uint64_t v71 = +[NSMutableData dataWithLength:]( NSMutableData,  "dataWithLength:",  ccder_sizeof_raw_octet_string([v70 length]));
        id v72 = objc_claimAutoreleasedReturnValue(v71);
        id v73 = [v72 mutableBytes];
        ccder_encode_raw_octet_string( [v70 length],  objc_msgSend(objc_retainAutorelease(v70), "bytes"),  v73,  (char *)objc_msgSend(v72, "length") + (void)v73);
        [v64 addObject:v72];
      }

      id v67 = [v65 countByEnumeratingWithState:v121 objects:&buf count:16];
    }

    while (v67);
  }

  id v117 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  uint64_t v114 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
  memset(v129, 0, sizeof(v129));
  __int128 v130 = 0u;
  __int128 v131 = 0u;
  id v112 = v111;
  id v74 = [v112 countByEnumeratingWithState:v129 objects:&buf count:16];
  if (v74)
  {
    id v75 = v74;
    uint64_t v76 = 0LL;
    uint64_t v77 = **(void **)&v129[16];
LABEL_52:
    uint64_t v78 = 0LL;
    while (1)
    {
      if (**(void **)&v129[16] != v77) {
        objc_enumerationMutation(v112);
      }
      __int128 v79 = *(void **)(*(void *)&v129[8] + 8 * v78);
      [v117 addObject:v79];
      v76 += (uint64_t)[v79 length];
      if (v75 == (id)++v78)
      {
        id v75 = [v112 countByEnumeratingWithState:v129 objects:&buf count:16];
        if (v75) {
          goto LABEL_52;
        }
        break;
      }
    }
  }

  else
  {
    uint64_t v76 = 0LL;
  }

  uint64_t v80 = sub_10001267C("piggy");
  id v81 = (os_log_s *)objc_claimAutoreleasedReturnValue(v80);
  if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v82 = [v117 count];
    *(_DWORD *)uint64_t v121 = 67109120;
    *(_DWORD *)&v121[4] = v82;
    _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "sending %d tlks", v121, 8u);
  }

  __int128 v127 = 0u;
  unsigned __int128 v128 = 0u;
  __int128 v125 = 0u;
  __int128 v126 = 0u;
  id v83 = v64;
  id v84 = [v83 countByEnumeratingWithState:&v125 objects:v121 count:16];
  if (v84)
  {
    id v85 = v84;
    uint64_t v86 = 0LL;
    uint64_t v87 = *(void *)v126;
LABEL_64:
    uint64_t v88 = 0LL;
    while (1)
    {
      if (*(void *)v126 != v87) {
        objc_enumerationMutation(v83);
      }
      CFMutableArrayRef v89 = *(void **)(*((void *)&v125 + 1) + 8 * v88);
      [v114 addObject:v89];
      v86 += (uint64_t)[v89 length];
      if (v85 == (id)++v88)
      {
        id v85 = [v83 countByEnumeratingWithState:&v125 objects:v121 count:16];
        if (v85) {
          goto LABEL_64;
        }
        break;
      }
    }
  }

  else
  {
    uint64_t v86 = 0LL;
  }

  unsigned __int8 v90 = sub_10001267C("piggy");
  id v91 = (os_log_s *)objc_claimAutoreleasedReturnValue(v90);
  if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v92 = [v114 count];
    LODWORD(result[0]) = 67109120;
    HIDWORD(result[0]) = v92;
    _os_log_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_DEFAULT, "sending %d identities", (uint8_t *)result, 8u);
  }

  uint64_t v93 = ccder_sizeof(0x2000000000000010LL, v86);
  uint64_t v94 = ccder_sizeof(0x2000000000000010LL, v76);
  CFRange v95 = +[NSMutableData dataWithLength:]( &OBJC_CLASS___NSMutableData,  "dataWithLength:",  ccder_sizeof(0x2000000000000010LL, v94 + v93));
  id v96 = objc_claimAutoreleasedReturnValue(v95);
  uint64_t v97 = (uint64_t)[v96 mutableBytes];
  CFRange v98 = (char *)[v96 length];
  CFRange v99 = &v98[v97];
  uint64_t v100 = sub_100194154(v117, v97, (uint64_t)&v98[v97]);
  uint64_t v101 = sub_100194154(v114, v97, v100);
  id v102 = (id)ccder_encode_constructed_tl(0x2000000000000010LL, v99, v97, v101);
  id v103 = v96;
  if (v102 == [v103 mutableBytes]) {
    id v104 = v103;
  }
  else {
    id v104 = 0LL;
  }

  *(void *)(*(void *)(*(void *)(v108 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v104;
  return *(void *)(*(void *)(*(void *)(v108 + 32) + 8LL) + 24LL) != 0LL;
}

BOOL sub_1001D057C(uint64_t a1, int a2, CFTypeRef *a3)
{
  uint64_t v6 = _OctagonSignpostLogSystem(a1);
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  os_signpost_id_t v8 = _OctagonSignpostCreate();
  uint64_t v10 = v9;

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  CFIndex v14 = v13;
  if (v8 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v13))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v14,  OS_SIGNPOST_INTERVAL_BEGIN,  v8,  "SOSCCJoinWithCircleJoiningBlob",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v16 = _OctagonSignpostLogSystem(v15);
  uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v30 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCJoinWithCircleJoiningBlob  enableTelemetry=YES ",  buf,  0xCu);
  }

  v27[0] = _NSConcreteStackBlock;
  v27[1] = 3221225472LL;
  v27[2] = sub_1001D07E8;
  v27[3] = &unk_100293678;
  void v27[4] = a1;
  int v28 = a2;
  BOOL v18 = sub_1001C7358(a3, v27);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v8, v10);
  uint64_t v20 = _OctagonSignpostLogSystem(Nanoseconds);
  CFTypeRef v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
  uint64_t v22 = v21;
  if (v8 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v21))
  {
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v30) = v18;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v22,  OS_SIGNPOST_INTERVAL_END,  v8,  "SOSCCJoinWithCircleJoiningBlob",  " SOSSignpostNameSOSCCJoinWithCircleJoiningBlob=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCJoinWi thCircleJoiningBlob}d ",  buf,  8u);
  }

  uint64_t v24 = _OctagonSignpostLogSystem(v23);
  uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v30 = v8;
    __int16 v31 = 2048;
    double v32 = (double)Nanoseconds / 1000000000.0;
    __int16 v33 = 1026;
    BOOL v34 = v18;
    _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCJoinWithCircleJoiningBlob  SOSSignpostNameSOSCCJoinWithCircleJoiningBlob=%{public,signpost.te lemetry:number1,name=SOSSignpostNameSOSCCJoinWithCircleJoiningBlob}d ",  buf,  0x1Cu);
  }

  return v18;
}

id sub_1001D07E8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  CFTypeRef cf = 0LL;
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
  id v7 = sub_10018E708(v6, *(const void **)(a1 + 32), *(unsigned int *)(a1 + 40), &cf);

  if (a3)
  {
    CFTypeRef v8 = cf;
    if (cf)
    {
      CFRetain(cf);
      *a3 = v8;
    }
  }

  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 trust]);
  unsigned int v11 = [v10 isInCircleOnly:0];

  if (cf)
  {
    id v14 = objc_msgSend((id)objc_opt_class(CKKSAnalytics, v13), "logger");
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
    CFTypeRef v16 = cf;
    v40[0] = @"SOSEnabled";
    BOOL v18 = -[OTSOSActualAdapter sosEnabled]_0((uint64_t)v15, v17);
    uint64_t v19 = @"compat_disabled";
    if (v18) {
      uint64_t v19 = @"compat_enabled";
    }
    v41[0] = v19;
    v41[1] = @"Piggybacking";
    v40[1] = @"SOSJoinMethod";
    v40[2] = @"JoiningSOSResult";
    uint64_t v20 = @"not_in_circle";
    if (v11) {
      uint64_t v20 = @"in_circle";
    }
    v41[2] = v20;
    v40[3] = @"CircleContainsLegacy";
    CFTypeRef v21 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v21 trust]);
    id v23 = [v22 trustedCircle];
    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
    int IsLegacy = SOSCircleIsLegacy(v23, [v24 accountKey]);
    id v26 = @"does_not_contain_legacy";
    if (IsLegacy) {
      id v26 = @"contains_legacy";
    }
    v41[3] = v26;
    id v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v41,  v40,  4LL));
    [v15 logResultForEvent:@"SOSDeferralEventPiggybacking" hardFailure:0 result:v16 withAttributes:v27];
  }

  else
  {
    if (-[OTSOSActualAdapter sosEnabled]_0(v12, v13)) {
      int v28 = @"compat_enabled";
    }
    else {
      int v28 = @"compat_disabled";
    }
    if (v11) {
      id v29 = @"in_circle";
    }
    else {
      id v29 = @"not_in_circle";
    }
    os_signpost_id_t v30 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
    __int16 v31 = (void *)objc_claimAutoreleasedReturnValue([v30 trust]);
    id v32 = [v31 trustedCircle];
    __int16 v33 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
    int v34 = SOSCircleIsLegacy(v32, [v33 accountKey]);
    id v35 = @"does_not_contain_legacy";
    if (v34) {
      id v35 = @"contains_legacy";
    }
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"%@-%@-%@-%@",  v28,  @"Piggybacking",  v29,  v35));

    id v37 = objc_msgSend((id)objc_opt_class(CKKSAnalytics, v36), "logger");
    CFTypeRef v21 = (void *)objc_claimAutoreleasedReturnValue(v37);
    [v21 logSuccessForEventNamed:v15];
  }

  return v7;
}

uint64_t sub_1001D0B10(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2020000000LL;
  uint64_t v8 = 0LL;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  void v4[2] = sub_1001D0BB8;
  void v4[3] = &unk_100293630;
  void v4[4] = &v5;
  void v4[5] = a1;
  sub_1001C44A8(a2, v4);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1001D0BA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_1001D0BB8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = _OctagonSignpostLogSystem(v5);
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  os_signpost_id_t v8 = _OctagonSignpostCreate();
  uint64_t v10 = v9;

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  uint64_t v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  id v14 = v13;
  if (v8 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v13))
  {
    *(_WORD *)id v40 = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v14,  OS_SIGNPOST_INTERVAL_BEGIN,  v8,  "SOSCCPeersHaveViewsEnabled",  " enableTelemetry=YES ",  v40,  2u);
  }

  uint64_t v16 = _OctagonSignpostLogSystem(v15);
  uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)id v40 = 134217984;
    *(void *)&void v40[4] = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCPeersHaveViewsEnabled  enableTelemetry=YES ",  v40,  0xCu);
  }

  BOOL v18 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
  uint64_t v19 = *(const __CFArray **)(a1 + 40);
  id v20 = v18;
  if ([v20 isInCircle:a3])
  {
    unint64_t Count = CFArrayGetCount(v19);
    if (Count >> 61)
    {
      MutableCFStringRef Copy = CFSetCreateMutableCopy(kCFAllocatorDefault, 0LL, 0LL);
    }

    else
    {
      CFIndex v24 = Count;
      uint64_t v25 = (const void **)malloc(8 * Count);
      v44.id location = 0LL;
      v44.CFIndex length = v24;
      CFArrayGetValues(v19, v44, v25);
      id v26 = CFGetAllocator(v19);
      id v27 = CFSetCreate(v26, v25, v24, &kCFTypeSetCallBacks);
      free(v25);
      MutableCFStringRef Copy = CFSetCreateMutableCopy(kCFAllocatorDefault, 0LL, v27);
      if (v27) {
        CFRelease(v27);
      }
    }

    *(void *)id v40 = _NSConcreteStackBlock;
    *(void *)&v40[8] = 3221225472LL;
    *(void *)&v40[16] = sub_10019C4C4;
    id v41 = &unk_100291EE0;
    id v42 = v20;
    uint64_t v43 = MutableCopy;
    sub_1001BAFB0(v42, v40);
    CFIndex v28 = CFSetGetCount(MutableCopy);
    id v29 = &kCFBooleanTrue;
    if (v28) {
      id v29 = &kCFBooleanFalse;
    }
    CFBooleanRef v23 = *v29;
    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
  }

  else
  {
    CFBooleanRef v23 = 0LL;
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = v23;
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v8, v10);
  uint64_t v31 = _OctagonSignpostLogSystem(Nanoseconds);
  id v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v31);
  __int16 v33 = v32;
  if (v8 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v32))
  {
    BOOL v34 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
    *(_DWORD *)id v40 = 67240192;
    *(_DWORD *)&void v40[4] = v34;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v33,  OS_SIGNPOST_INTERVAL_END,  v8,  "SOSCCPeersHaveViewsEnabled",  " SOSSignpostNameSOSCCPeersHaveViewsEnabled=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCPeersHaveViewsEnabled}d ",  v40,  8u);
  }

  uint64_t v36 = _OctagonSignpostLogSystem(v35);
  id v37 = (os_log_s *)objc_claimAutoreleasedReturnValue(v36);
  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v38 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    *(_DWORD *)id v40 = 134218496;
    *(void *)&void v40[4] = v8;
    *(_WORD *)&v40[12] = 2048;
    *(double *)&v40[14] = (double)Nanoseconds / 1000000000.0;
    *(_WORD *)&v40[22] = 1026;
    LODWORD(v41) = v38 != 0;
    _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCPeersHaveViewsEnabled  SOSSignpostNameSOSCCPeersHaveViewsEnabled=%{public,signpost.telemetry: number1,name=SOSSignpostNameSOSCCPeersHaveViewsEnabled}d ",  v40,  0x1Cu);
  }

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) != 0LL;
}

uint64_t sub_1001D0F7C(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4 = _OctagonSignpostLogSystem(a1);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  os_signpost_id_t v6 = _OctagonSignpostCreate();
  uint64_t v8 = v7;

  uint64_t v10 = _OctagonSignpostLogSystem(v9);
  uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
  uint64_t v12 = v11;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    LOWORD(buf) = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_INTERVAL_BEGIN,  v6,  "SOSCCRegisterRecoveryPublicKey",  " enableTelemetry=YES ",  (uint8_t *)&buf,  2u);
  }

  uint64_t v14 = _OctagonSignpostLogSystem(v13);
  uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCRegisterRecoveryPublicKey  enableTelemetry=YES ",  (uint8_t *)&buf,  0xCu);
  }

  v42[0] = _NSConcreteStackBlock;
  v42[1] = 3221225472LL;
  v42[2] = sub_1001D142C;
  v42[3] = &unk_100293338;
  void v42[4] = a1;
  BOOL v16 = sub_1001C44A8(a2, v42);
  if (!v16)
  {
    uint64_t v35 = sub_10001267C("SecError");
    uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v35);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "register-recovery-public-key: Failed to register recovery key",  (uint8_t *)&buf,  2u);
    }

    goto LABEL_34;
  }

  BOOL v18 = sub_1001C41CC(v16, v17);
  uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
  if (!v19)
  {
    uint64_t v36 = sub_10001267C("SecError");
    id v37 = (os_log_s *)objc_claimAutoreleasedReturnValue(v36);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v37,  OS_LOG_TYPE_DEFAULT,  "register-recovery-public-key: Failed to get account object",  (uint8_t *)&buf,  2u);
    }

    if (a2)
    {
      uint64_t v19 = 0LL;
      uint64_t v27 = 0LL;
      *a2 = CFErrorCreate(kCFAllocatorDefault, kSOSErrorDomain, 1048LL, 0LL);
      goto LABEL_35;
    }

    uint64_t v19 = 0LL;
LABEL_34:
    uint64_t v27 = 0LL;
    goto LABEL_35;
  }

  dispatch_semaphore_t v20 = dispatch_semaphore_create(0LL);
  *(void *)&__int128 buf = 0LL;
  *((void *)&buf + 1) = &buf;
  uint64_t v50 = 0x3032000000LL;
  unsigned int v51 = sub_1001CB5B8;
  uint64_t v52 = sub_1001CB5C8;
  id v53 = 0LL;
  v39[0] = _NSConcreteStackBlock;
  v39[1] = 3221225472LL;
  v39[2] = sub_1001D16E0;
  v39[3] = &unk_1002936A0;
  p___int128 buf = &buf;
  CFTypeRef v21 = v20;
  id v40 = v21;
  -[os_log_s triggerRingUpdateNow:](v19, "triggerRingUpdateNow:", v39);
  dispatch_time_t v22 = dispatch_time(0LL, 60000000000LL);
  if (dispatch_semaphore_wait(v21, v22))
  {
    CFBooleanRef v23 = sub_10001267C("SecError");
    CFIndex v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v43 = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "timed out waiting for ring update", v43, 2u);
    }
  }

  uint64_t v25 = *(void **)(*((void *)&buf + 1) + 40LL);
  if (a2) {
    BOOL v26 = v25 == 0LL;
  }
  else {
    BOOL v26 = 1;
  }
  uint64_t v27 = v26;
  if (v26)
  {
    unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v6, v8);
    uint64_t v29 = _OctagonSignpostLogSystem(Nanoseconds);
    os_signpost_id_t v30 = (os_log_s *)objc_claimAutoreleasedReturnValue(v29);
    uint64_t v31 = v30;
    if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v30))
    {
      *(_DWORD *)uint64_t v43 = 67240192;
      LODWORD(v44) = 1;
      _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v31,  OS_SIGNPOST_INTERVAL_END,  v6,  "SOSCCRegisterRecoveryPublicKey",  " SOSSignpostNameSOSCCRegisterRecoveryPublicKey=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRegi sterRecoveryPublicKey}d ",  v43,  8u);
    }

    uint64_t v33 = _OctagonSignpostLogSystem(v32);
    BOOL v34 = (os_log_s *)objc_claimAutoreleasedReturnValue(v33);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v43 = 134218496;
      os_signpost_id_t v44 = v6;
      __int16 v45 = 2048;
      double v46 = (double)Nanoseconds / 1000000000.0;
      __int16 v47 = 1026;
      int v48 = 1;
      _os_log_impl( (void *)&_mh_execute_header,  v34,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCRegisterRecoveryPublicKey  SOSSignpostNameSOSCCRegisterRecoveryPublicKey=%{public,signpost. telemetry:number1,name=SOSSignpostNameSOSCCRegisterRecoveryPublicKey}d ",  v43,  0x1Cu);
    }
  }

  else
  {
    *a2 = v25;
  }

  _Block_object_dispose(&buf, 8);
LABEL_35:

  return v27;
}

void sub_1001D1400( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

BOOL sub_1001D142C(uint64_t a1, void *a2, const void **a3)
{
  id v5 = a2;
  os_signpost_id_t v6 = *(const __CFData **)(a1 + 32);
  if (v6 && CFDataGetLength(v6))
  {
    uint64_t v7 = *(const __CFData **)(a1 + 32);
    id v8 = v5;
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 account]);
    BOOL v10 = sub_1001AC1D4(v9, v7, a3);

    uint64_t v11 = sub_10001267C("recovery");
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
    BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
    if (v10)
    {
      if (v13)
      {
        LOWORD(v32) = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "successfully registered recovery public key",  (uint8_t *)&v32,  2u);
      }

      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v8 account]);
      BOOL v15 = 1LL;
      [v14 setPublicKeyStatus:1 forKey:2];

      if (a3)
      {
        BOOL v16 = *a3;
        if (*a3)
        {
          *a3 = 0LL;
          CFRelease(v16);
        }
      }
    }

    else
    {
      if (v13)
      {
        uint64_t v29 = *a3;
        int v32 = 138412290;
        uint64_t v33 = v29;
        _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "could not register recovery public key: %@",  (uint8_t *)&v32,  0xCu);
      }

      os_signpost_id_t v30 = (void *)objc_claimAutoreleasedReturnValue([v8 account]);
      [v30 setPublicKeyStatus:0 forKey:2];

      BOOL v15 = 0LL;
    }

    goto LABEL_24;
  }

  id v17 = v5;
  BOOL v18 = (void *)objc_claimAutoreleasedReturnValue([v17 account]);
  BOOL v15 = sub_1001AC1D4(v18, 0LL, a3);

  uint64_t v19 = sub_10001267C("recovery");
  dispatch_semaphore_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
  BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
  if (v15)
  {
    if (v21)
    {
      LOWORD(v32) = 0;
      dispatch_time_t v22 = "RK Cleared";
      CFBooleanRef v23 = v20;
      uint32_t v24 = 2;
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v22, (uint8_t *)&v32, v24);
    }
  }

  else if (v21)
  {
    uint64_t v25 = *a3;
    int v32 = 138412290;
    uint64_t v33 = v25;
    dispatch_time_t v22 = "Couldn't clear RK(%@)";
    CFBooleanRef v23 = v20;
    uint32_t v24 = 12;
    goto LABEL_14;
  }

  BOOL v26 = (void *)objc_claimAutoreleasedReturnValue([v17 account]);
  [v26 setPublicKeyStatus:0 forKey:2];

  char v27 = !v15;
  if (!a3) {
    char v27 = 1;
  }
  if ((v27 & 1) == 0)
  {
    CFIndex v28 = *a3;
    if (*a3)
    {
      *a3 = 0LL;
      CFRelease(v28);
    }

    BOOL v15 = 1LL;
  }

void sub_1001D16E0(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    id v5 = sub_10001267C("SecError");
    os_signpost_id_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue(v5);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 138412290;
      id v8 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v6,  OS_LOG_TYPE_DEFAULT,  "trigger ring update error: %@",  (uint8_t *)&v7,  0xCu);
    }

    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL), a2);
  }

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t sub_1001D17C0(CFTypeRef *a1)
{
  uint64_t v26 = 0LL;
  char v27 = &v26;
  uint64_t v28 = 0x2020000000LL;
  uint64_t v29 = 0LL;
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  int v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  BOOL v10 = v9;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCCopyRecoveryPublicKey",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem(v11);
  BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v31 = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCCopyRecoveryPublicKey  enableTelemetry=YES ",  buf,  0xCu);
  }

  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472LL;
  v25[2] = sub_1001D1A9C;
  v25[3] = &unk_1002932D0;
  v25[4] = &v26;
  sub_1001C44A8(a1, v25);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v15 = _OctagonSignpostLogSystem(Nanoseconds);
  BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
  id v17 = v16;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v16))
  {
    BOOL v18 = v27[3] != 0;
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v31) = v18;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v17,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCCopyRecoveryPublicKey",  " SOSSignpostNameSOSCCCopyRecoveryPublicKey=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyRecoveryPublicKey}d ",  buf,  8u);
  }

  uint64_t v20 = _OctagonSignpostLogSystem(v19);
  BOOL v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = v27[3];
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v31 = v4;
    __int16 v32 = 2048;
    double v33 = (double)Nanoseconds / 1000000000.0;
    __int16 v34 = 1026;
    BOOL v35 = v22 != 0;
    _os_log_impl( (void *)&_mh_execute_header,  v21,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCCopyRecoveryPublicKey  SOSSignpostNameSOSCCCopyRecoveryPublicKey=%{public,signpost.telemetry: number1,name=SOSSignpostNameSOSCCCopyRecoveryPublicKey}d ",  buf,  0x1Cu);
  }

  uint64_t v23 = v27[3];
  _Block_object_dispose(&v26, 8);
  return v23;
}

void sub_1001D1A64( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

BOOL sub_1001D1A9C(uint64_t a1, void *a2, CFTypeRef *a3)
{
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  uint64_t v6 = sub_1001AC124(kCFAllocatorDefault, v5, a3);

  if (!v6)
  {
    uint64_t v9 = sub_10001267C("recovery");
    BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      CFTypeRef v11 = *a3;
      int v13 = 138412290;
      CFTypeRef v14 = v11;
      _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Could not retrieve the recovery public key from the ring: %@",  (uint8_t *)&v13,  0xCu);
    }

    goto LABEL_10;
  }

  CFTypeID v7 = CFGetTypeID(v6);
  if (v7 != CFDataGetTypeID())
  {
    CFRelease(v6);
LABEL_10:
    uint64_t v6 = 0LL;
    goto LABEL_11;
  }

  if (a3)
  {
    CFTypeRef v8 = *a3;
    if (*a3)
    {
      *a3 = 0LL;
      CFRelease(v8);
    }
  }

BOOL sub_1001D1BEC(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4 = _OctagonSignpostLogSystem(a1);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  os_signpost_id_t v6 = _OctagonSignpostCreate();
  uint64_t v8 = v7;

  uint64_t v10 = _OctagonSignpostLogSystem(v9);
  CFTypeRef v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
  uint64_t v12 = v11;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_INTERVAL_BEGIN,  v6,  "SOSCCMessageFromPeerIsPending",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v14 = _OctagonSignpostLogSystem(v13);
  uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v27 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCMessageFromPeerIsPending  enableTelemetry=YES ",  buf,  0xCu);
  }

  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472LL;
  v25[2] = sub_1001D1E48;
  v25[3] = &unk_100293338;
  v25[4] = a1;
  BOOL v16 = sub_1001C44A8(a2, v25);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v6, v8);
  uint64_t v18 = _OctagonSignpostLogSystem(Nanoseconds);
  uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
  uint64_t v20 = v19;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v19))
  {
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v27) = v16;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_INTERVAL_END,  v6,  "SOSCCMessageFromPeerIsPending",  " SOSSignpostNameSOSCCMessageFromPeerIsPending=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCMessage FromPeerIsPending}d ",  buf,  8u);
  }

  uint64_t v22 = _OctagonSignpostLogSystem(v21);
  uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v27 = v6;
    __int16 v28 = 2048;
    double v29 = (double)Nanoseconds / 1000000000.0;
    __int16 v30 = 1026;
    BOOL v31 = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCMessageFromPeerIsPending  SOSSignpostNameSOSCCMessageFromPeerIsPending=%{public,signpost.tele metry:number1,name=SOSSignpostNameSOSCCMessageFromPeerIsPending}d ",  buf,  0x1Cu);
  }

  return v16;
}

uint64_t sub_1001D1E48(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  os_signpost_id_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
  unsigned int v7 = [v6 SOSMonitorModeSOSIsActive];

  if (v7)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
    if (sub_100197C6C(v9, a3))
    {
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "kvs_message_transport"));
      CFTypeRef v11 = (void *)objc_claimAutoreleasedReturnValue([v9 peerID]);
      uint64_t PeerID = SOSPeerInfoGetPeerID(v8);
      uint64_t v13 = (const void *)SOSMessageKeyCreateFromPeerToTransport(v10, v11, PeerID);

      uint64_t HasPendingKey = SOSCloudKeychainHasPendingKey(v13, a3);
      if (v13) {
        CFRelease(v13);
      }
    }

    else
    {
      uint64_t HasPendingKey = 0LL;
    }
  }

  else
  {
    uint64_t HasPendingKey = 0LL;
  }

  return HasPendingKey;
}

BOOL sub_1001D1F38(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4 = _OctagonSignpostLogSystem(a1);
  id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  os_signpost_id_t v6 = _OctagonSignpostCreate();
  uint64_t v8 = v7;

  uint64_t v10 = _OctagonSignpostLogSystem(v9);
  CFTypeRef v11 = (os_log_s *)objc_claimAutoreleasedReturnValue(v10);
  uint64_t v12 = v11;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v12,  OS_SIGNPOST_INTERVAL_BEGIN,  v6,  "SOSCCSendToPeerIsPending",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v14 = _OctagonSignpostLogSystem(v13);
  uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v27 = v6;
    _os_log_impl( (void *)&_mh_execute_header,  v15,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCSendToPeerIsPending  enableTelemetry=YES ",  buf,  0xCu);
  }

  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472LL;
  v25[2] = sub_1001D2194;
  v25[3] = &unk_100293338;
  v25[4] = a1;
  BOOL v16 = sub_1001C44A8(a2, v25);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v6, v8);
  uint64_t v18 = _OctagonSignpostLogSystem(Nanoseconds);
  uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
  uint64_t v20 = v19;
  if (v6 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v19))
  {
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v27) = v16;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v20,  OS_SIGNPOST_INTERVAL_END,  v6,  "SOSCCSendToPeerIsPending",  " SOSSignpostNameSOSCCSendToPeerIsPending=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCSendToPeerIsPending}d ",  buf,  8u);
  }

  uint64_t v22 = _OctagonSignpostLogSystem(v21);
  uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v27 = v6;
    __int16 v28 = 2048;
    double v29 = (double)Nanoseconds / 1000000000.0;
    __int16 v30 = 1026;
    BOOL v31 = v16;
    _os_log_impl( (void *)&_mh_execute_header,  v23,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCSendToPeerIsPending  SOSSignpostNameSOSCCSendToPeerIsPending=%{public,signpost.telemetry:numb er1,name=SOSSignpostNameSOSCCSendToPeerIsPending}d ",  buf,  0x1Cu);
  }

  return v16;
}

uint64_t sub_1001D2194(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  os_signpost_id_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
  unsigned int v7 = [v6 SOSMonitorModeSOSIsActive];

  if (v7)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
  }

  return 0LL;
}

BOOL sub_1001D221C(int a1, CFTypeRef *a2)
{
  uint64_t v2 = a2;
  id v4 = objc_msgSend((id)objc_opt_class(CKKSAnalytics, a2), "logger");
  id v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  os_signpost_id_t v6 = (void *)objc_claimAutoreleasedReturnValue( [v5 startLogSystemMetricsForActivityNamed:@"SOSDeferralActivitySetCompatibilityMode"]);

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
  os_signpost_id_t v10 = _OctagonSignpostCreate();
  uint64_t v12 = v11;

  uint64_t v14 = _OctagonSignpostLogSystem(v13);
  uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
  BOOL v16 = v15;
  if (v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v15))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v16,  OS_SIGNPOST_INTERVAL_BEGIN,  v10,  "SOSCCSetCompatibilityMode",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v18 = _OctagonSignpostLogSystem(v17);
  uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    os_signpost_id_t v37 = v10;
    _os_log_impl( (void *)&_mh_execute_header,  v19,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCSetCompatibilityMode  enableTelemetry=YES ",  buf,  0xCu);
  }

  v34[0] = _NSConcreteStackBlock;
  v34[1] = 3221225472LL;
  v34[2] = sub_1001D2524;
  v34[3] = &unk_1002936C0;
  char v35 = a1;
  BOOL v20 = sub_1001C44A8(v2, v34);
  unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v10, v12);
  uint64_t v22 = _OctagonSignpostLogSystem(Nanoseconds);
  uint64_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue(v22);
  uint32_t v24 = v23;
  if (v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v23))
  {
    *(_DWORD *)__int128 buf = 67240192;
    LODWORD(v37) = v20;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v24,  OS_SIGNPOST_INTERVAL_END,  v10,  "SOSCCSetCompatibilityMode",  " SOSSignpostNameSOSCCSetCompatibilityMode=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCSetCompatibilityMode}d ",  buf,  8u);
  }

  uint64_t v26 = _OctagonSignpostLogSystem(v25);
  os_signpost_id_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    os_signpost_id_t v37 = v10;
    __int16 v38 = 2048;
    double v39 = (double)Nanoseconds / 1000000000.0;
    __int16 v40 = 1026;
    BOOL v41 = v20;
    _os_log_impl( (void *)&_mh_execute_header,  v27,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCSetCompatibilityMode  SOSSignpostNameSOSCCSetCompatibilityMode=%{public,signpost.telemetry:nu mber1,name=SOSSignpostNameSOSCCSetCompatibilityMode}d ",  buf,  0x1Cu);
  }

  if (v2)
  {
    if (*v2) {
      uint64_t v2 = (id)*v2;
    }
    else {
      uint64_t v2 = 0LL;
    }
  }

  [v6 stopWithEvent:@"SOSDeferralActivitySetCompatibilityMode" result:v2];
  id v29 = objc_msgSend((id)objc_opt_class(CKKSAnalytics, v28), "logger");
  __int16 v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
  BOOL v31 = v30;
  if (a1) {
    __int16 v32 = @"SOSDeferralEventCompatibilityModeEnabled";
  }
  else {
    __int16 v32 = @"SOSDeferralEventCompatibilityModeDisabled";
  }
  [v30 logSuccessForEventNamed:v32];

  return v20;
}

BOOL sub_1001D2524(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  if (qword_1002DEB80 != -1) {
    dispatch_once(&qword_1002DEB80, &stru_10028EFC8);
  }
  if (byte_1002DEB78)
  {
    uint64_t v6 = *(unsigned __int8 *)(a1 + 32);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
    [v7 setSosCompatibilityMode:v6];

    if (*(_BYTE *)(a1 + 32))
    {
      dword_1002DEE98 = 2;
      uint64_t v8 = sub_10001267C("sos-compatibility-mode");
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Alerting SOS of account sign in", buf, 2u);
      }

      os_signpost_id_t v10 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
      [v10 setAccountIsChanging:0];

      uint64_t v11 = sub_1001110DC(0LL);
      uint64_t v12 = sub_100101A94(v11);
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
      [v13 setFactory:v12];

      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
      [v14 SOSMonitorModeEnableSOS];

      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
      [v15 ensureFactoryCircles];

      BOOL v16 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
      objc_msgSend(v16, "setKey_interests_need_updating:", 1);

      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
      [v17 setConsolidateKeyInterest:0];

      [v5 restart];
    }

    else
    {
      uint64_t v19 = sub_10001267C("sos-compatibility-mode");
      BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int128 buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Alerting SOS of account sign out", buf, 2u);
      }

      uint64_t v41 = 0LL;
      uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
      uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v21 trust]);
      uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
      unsigned int v24 = [v22 leaveCircle:v23 err:&v41];

      if (!v24 || v41)
      {
        uint64_t v25 = sub_10001267C("SecError");
        uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue(v25);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int128 buf = 138412290;
          uint64_t v47 = v41;
          _os_log_impl( (void *)&_mh_execute_header,  v26,  OS_LOG_TYPE_DEFAULT,  "sos-compatibility-mode: failed to leave circle, error: %@",  buf,  0xCu);
        }
      }

      [v5 restart];
      os_signpost_id_t v27 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
      sub_1001C4B5C(0LL);

      uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
      sub_1001907A8(v28);

      id v29 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
      [v29 setAccountIsChanging:1];

      __int16 v30 = (void *)objc_claimAutoreleasedReturnValue([v5 account]);
      [v30 SOSMonitorModeDisableSOS];

      notify_post(kSOSCCSOSIsNowOFF);
      dword_1002DEE98 = 1;
    }

    v44[0] = kSecClass;
    v44[1] = kSecUseDataProtectionKeychain;
    v45[0] = kSecClassGenericPassword;
    v45[1] = &__kCFBooleanTrue;
    v44[2] = kSecAttrSynchronizable;
    v44[3] = kSecAttrAccessGroup;
    v45[2] = &__kCFBooleanFalse;
    v45[3] = @"com.apple.security.sos";
    void v44[4] = kSecAttrAccount;
    v44[5] = kSecAttrAccessible;
    v45[4] = @"sos-compatibility-mode";
    v45[5] = kSecAttrAccessibleAfterFirstUnlock;
    v44[6] = kSecAttrSysBound;
    v45[6] = &off_1002AE028;
    BOOL v31 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v45,  v44,  7LL));
    if (*(_BYTE *)(a1 + 32)) {
      __int16 v32 = @"enabled";
    }
    else {
      __int16 v32 = @"disabled";
    }
    double v33 = v32;
    __int16 v34 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString dataUsingEncoding:](v33, "dataUsingEncoding:", 134217984LL));
    CFStringRef v42 = kSecValueData;
    uint64_t v43 = v34;
    char v35 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v43,  &v42,  1LL));

    id v36 = [v31 mutableCopy];
    [v36 addEntriesFromDictionary:v35];
    OSStatus v37 = SecItemAdd((CFDictionaryRef)v36, 0LL);
    if (v37 == -25299) {
      OSStatus v37 = SecItemUpdate((CFDictionaryRef)v31, v35);
    }
    BOOL v18 = v37 == 0;
    if (v37)
    {
      Error = (const void *)SecCopyLastError();
      double v39 = Error;
      if (a3)
      {
        if (Error) {
          CFRetain(Error);
        }
        *a3 = v39;
      }

      if (v39) {
        CFRelease(v39);
      }
    }
  }

  else
  {
    BOOL v18 = 1LL;
  }

  return v18;
}

BOOL sub_1001D2A60(uint64_t a1, uint64_t a2)
{
  BOOL v2 = -[OTSOSActualAdapter sosEnabled]_0(a1, a2);
  int v3 = sub_10001267C("sos-compatibility-mode-cached");
  id v4 = (os_log_s *)objc_claimAutoreleasedReturnValue(v3);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = @"disabled";
    if (v2) {
      id v5 = @"enabled";
    }
    int v7 = 138412290;
    uint64_t v8 = v5;
    _os_log_impl( (void *)&_mh_execute_header,  v4,  OS_LOG_TYPE_DEFAULT,  "Cached SOS Compatibility Mode is %@",  (uint8_t *)&v7,  0xCu);
  }

  return v2;
}

uint64_t sub_1001D2B28(CFTypeRef *a1)
{
  uint64_t v2 = _OctagonSignpostLogSystem(a1);
  int v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  os_signpost_id_t v4 = _OctagonSignpostCreate();
  uint64_t v6 = v5;

  uint64_t v8 = _OctagonSignpostLogSystem(v7);
  uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue(v8);
  os_signpost_id_t v10 = v9;
  unint64_t v11 = v4 - 1;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_WORD *)__int128 buf = 0;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v10,  OS_SIGNPOST_INTERVAL_BEGIN,  v4,  "SOSCCFetchCompatibilityMode",  " enableTelemetry=YES ",  buf,  2u);
  }

  uint64_t v13 = _OctagonSignpostLogSystem(v12);
  uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134217984;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "BEGIN [%lld]: SOSCCFetchCompatibilityMode  enableTelemetry=YES ",  buf,  0xCu);
  }

  if (qword_1002DEB80 != -1) {
    dispatch_once(&qword_1002DEB80, &stru_10028EFC8);
  }
  if (byte_1002DEB78)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x2020000000LL;
    LOBYTE(v46) = 0;
    v38[0] = _NSConcreteStackBlock;
    v38[1] = 3221225472LL;
    v38[2] = sub_1001D2FDC;
    v38[3] = &unk_1002932D0;
    void v38[4] = buf;
    sub_1001C44A8(a1, v38);
    if (*(_BYTE *)(*(void *)&buf[8] + 24LL))
    {
      uint64_t v17 = sub_10001267C("sos-compatibility-mode");
      BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)double v39 = 0;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "Device is in circle, SOS Compatibility Mode is enabled",  v39,  2u);
      }

      unint64_t Nanoseconds = _OctagonSignpostGetNanoseconds(v4, v6);
      uint64_t v20 = _OctagonSignpostLogSystem(Nanoseconds);
      uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue(v20);
      uint64_t v22 = v21;
      if (v11 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v21))
      {
        *(_DWORD *)double v39 = 67240192;
        LODWORD(v40) = 1;
        _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v22,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCFetchCompatibilityMode",  " SOSSignpostNameSOSCCFetchCompatibilityMode=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCFetch CompatibilityMode}d ",  v39,  8u);
      }

      uint64_t v24 = _OctagonSignpostLogSystem(v23);
      uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue(v24);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)double v39 = 134218496;
        os_signpost_id_t v40 = v4;
        __int16 v41 = 2048;
        double v42 = (double)Nanoseconds / 1000000000.0;
        __int16 v43 = 1026;
        int v44 = 1;
        _os_log_impl( (void *)&_mh_execute_header,  v25,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCFetchCompatibilityMode  SOSSignpostNameSOSCCFetchCompatibilityMode=%{public,signpost.tele metry:number1,name=SOSSignpostNameSOSCCFetchCompatibilityMode}d ",  v39,  0x1Cu);
      }

      _Block_object_dispose(buf, 8);
      return 1LL;
    }

    _Block_object_dispose(buf, 8);
  }

  BOOL v26 = -[OTSOSActualAdapter sosEnabled]_0(v15, v16);
  os_signpost_id_t v27 = sub_10001267C("sos-compatibility-mode");
  uint64_t v28 = (os_log_s *)objc_claimAutoreleasedReturnValue(v27);
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    id v29 = @"disabled";
    if (v26) {
      id v29 = @"enabled";
    }
    *(_DWORD *)__int128 buf = 138412290;
    *(void *)&uint8_t buf[4] = v29;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "SOS Compatibility Mode is %@", buf, 0xCu);
  }

  unint64_t v30 = _OctagonSignpostGetNanoseconds(v4, v6);
  uint64_t v31 = _OctagonSignpostLogSystem(v30);
  __int16 v32 = (os_log_s *)objc_claimAutoreleasedReturnValue(v31);
  double v33 = v32;
  if (v11 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled(v32))
  {
    *(_DWORD *)__int128 buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = v26;
    _os_signpost_emit_with_name_impl( (void *)&_mh_execute_header,  v33,  OS_SIGNPOST_INTERVAL_END,  v4,  "SOSCCFetchCompatibilityMode",  " SOSSignpostNameSOSCCFetchCompatibilityMode=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCFetchComp atibilityMode}d ",  buf,  8u);
  }

  uint64_t v35 = _OctagonSignpostLogSystem(v34);
  id v36 = (os_log_s *)objc_claimAutoreleasedReturnValue(v35);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 134218496;
    *(void *)&uint8_t buf[4] = v4;
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(double *)&buf[14] = (double)v30 / 1000000000.0;
    *(_WORD *)&buf[22] = 1026;
    BOOL v46 = v26;
    _os_log_impl( (void *)&_mh_execute_header,  v36,  OS_LOG_TYPE_DEFAULT,  "END [%lld] %fs: SOSCCFetchCompatibilityMode  SOSSignpostNameSOSCCFetchCompatibilityMode=%{public,signpost.telemetr y:number1,name=SOSSignpostNameSOSCCFetchCompatibilityMode}d ",  buf,  0x1Cu);
  }

  return v26;
}

void sub_1001D2FB0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t sub_1001D2FDC(uint64_t a1, void *a2)
{
  id v3 = a2;
  os_signpost_id_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  unsigned int v5 = [v4 getCircleStatus:0];

  if (!v5 && dword_1002DEE98 != 2)
  {
    dword_1002DEE98 = 2;
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
    [v6 setSosCompatibilityMode:1];

    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
    [v7 setAccountIsChanging:0];

    uint64_t v8 = sub_1001110DC(0LL);
    uint64_t v9 = sub_100101A94(v8);
    os_signpost_id_t v10 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
    [v10 setFactory:v9];

    unint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
    [v11 SOSMonitorModeEnableSOS];

    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
    [v12 ensureFactoryCircles];

    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
    objc_msgSend(v13, "setKey_interests_need_updating:", 1);

    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
    [v14 setConsolidateKeyInterest:0];

    [v3 restart];
    id v16 = objc_msgSend((id)objc_opt_class(CKKSAnalytics, v15), "logger");
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
    [v17 logSuccessForEventNamed:@"SOSDeferralEventCompatibilityModeEnabled"];

LABEL_5:
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
    goto LABEL_6;
  }

  if (!v5) {
    goto LABEL_5;
  }
LABEL_6:
  BOOL v18 = v5 == 0;
  uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  [v19 setSosCompatibilityMode:v18];

  return 1LL;
}

void sub_1001D3188(void *a1)
{
  CFTypeRef v4 = 0LL;
  sub_1001C7358(&v4, &stru_1002936E0);
  if (v4)
  {
    uint64_t v2 = sub_10001267C("SecError");
    id v3 = (os_log_s *)objc_claimAutoreleasedReturnValue(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v6 = v4;
      _os_log_impl( (void *)&_mh_execute_header,  v3,  OS_LOG_TYPE_DEFAULT,  "SOSCCPushResetCircle_Server: error writing reset circle to kvs: %@",  buf,  0xCu);
    }

    if (a1) {
      *a1 = v4;
    }
  }

BOOL sub_1001D325C(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  id v3 = (id)objc_claimAutoreleasedReturnValue(-[SOSAccountTransaction account](a2, "account", a3));
  CFTypeRef v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](&OBJC_CLASS___NSMutableDictionary, "dictionary"));
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue([v3 trust]);

  uint64_t Name = SOSCircleGetName([v5 trustedCircle]);
  CFTypeRef v26 = 0LL;
  uint64_t v7 = (void *)SOSCircleKeyCreateWithName(Name, &v26);
  if (!v7 || v26)
  {
    uint64_t v15 = sub_10001267C("SecError");
    id v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v26;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "SOSAccountWriteEmptyCircleToKVS failed to create circle key: %@",  (uint8_t *)&buf,  0xCu);
    }

    CFTypeRef v14 = v26;
    if (v26)
    {
      CFTypeRef v26 = 0LL;
      goto LABEL_17;
    }
  }

  else
  {
    CFTypeRef cf = 0LL;
    uint64_t v8 = SOSCircleCreate(kCFAllocatorDefault, Name, &cf);
    uint64_t v9 = (const void *)v8;
    if (v8) {
      BOOL v10 = cf == 0LL;
    }
    else {
      BOOL v10 = 0;
    }
    if (v10)
    {
      uint64_t v17 = (void *)SOSCircleCopyEncodedData(v8, kCFAllocatorDefault, 0LL);
      CFRelease(v9);
      [v4 setObject:v17 forKeyedSubscript:v7];

      dispatch_semaphore_t v18 = dispatch_semaphore_create(0LL);
      dispatch_time_t v19 = dispatch_time(0LL, 30000000000LL);
      dispatch_queue_global_t global_queue = dispatch_get_global_queue(-2LL, 0LL);
      uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(global_queue);
      *(void *)&__int128 buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 3221225472LL;
      uint64_t v28 = sub_100192B08;
      id v29 = &unk_100292D28;
      dispatch_semaphore_t v30 = v18;
      uint64_t v22 = v18;
      uint64_t v23 = objc_retainBlock(&buf);
      SOSCloudKeychainPutObjectsInCloud(v4, v21, v23);
      dispatch_semaphore_wait(v22, v19);

      goto LABEL_19;
    }

    unint64_t v11 = sub_10001267C("SecError");
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = cf;
      _os_log_impl( (void *)&_mh_execute_header,  v12,  OS_LOG_TYPE_DEFAULT,  "SOSAccountWriteEmptyCircleToKVS failed to create circle key: %@",  (uint8_t *)&buf,  0xCu);
    }

    CFTypeRef v13 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v13);
    }

    if (v9)
    {
      CFTypeRef v14 = v9;
LABEL_17:
      CFRelease(v14);
    }
  }

uint64_t sub_1001D353C(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFTypeRef v4 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  unsigned int v5 = [v4 SOSMonitorModeSOSIsActive];

  if (v5)
  {
    CFTypeRef v6 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
    uint64_t v7 = *(void *)(a1 + 32);
    id v8 = v6;
    uint64_t v9 = sub_10001267C("otrtimer");
    BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v20[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "timer fired!", (uint8_t *)v20, 2u);
    }

    CFTypeRef cf = 0LL;
    unint64_t v11 = (uint64_t (**)(id, uint64_t, void))[v8 factory];
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v8 trust]);
    uint64_t Name = SOSCircleGetName([v12 trustedCircle]);
    if (v11)
    {
      uint64_t v14 = v11[1](v11, Name, 0LL);
      if (v14)
      {
        unint64_t v11 = *(uint64_t (***)(id, uint64_t, void))v14;
        (*(void (**)(uint64_t, void))(v14 + 72))(v14, 0LL);
      }

      else
      {
        unint64_t v11 = 0LL;
      }
    }

    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472LL;
    void v20[2] = sub_100194498;
    v20[3] = &unk_1002919E8;
    uint64_t v22 = v11;
    id v15 = v8;
    id v21 = v15;
    sub_1000CCE88((uint64_t)v11, v7, (uint64_t)&cf, v20);
    if (cf)
    {
      id v16 = sub_10001267C("otrtimer");
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412546;
        uint64_t v25 = v7;
        __int16 v26 = 2112;
        CFTypeRef v27 = cf;
        _os_log_impl( (void *)&_mh_execute_header,  v17,  OS_LOG_TYPE_DEFAULT,  "error grabbing engine for peer id: %@, error:%@",  buf,  0x16u);
      }

      CFTypeRef v18 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
        CFRelease(v18);
      }
    }
  }

  return 1LL;
}

uint64_t sub_1001D376C(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFTypeRef v4 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  unsigned int v5 = [v4 SOSMonitorModeSOSIsActive];

  if (v5)
  {
    CFTypeRef v6 = *(void **)(a1 + 32);
    uint64_t v7 = *(void **)(a1 + 40);
    id v8 = v3;
    id v9 = v6;
    id v10 = v7;
    uint64_t v25 = 0LL;
    __int16 v26 = &v25;
    uint64_t v27 = 0x3032000000LL;
    uint64_t v28 = sub_10018ED10;
    id v29 = sub_10018ED20;
    id v30 = (id)0xAAAAAAAAAAAAAAAALL;
    id v30 = (id)objc_claimAutoreleasedReturnValue([v8 account]);
    CFTypeRef cf = 0LL;
    unint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v8 account]);
    uint64_t v12 = (uint64_t (**)(id, uint64_t, void))[v11 factory];
    CFTypeRef v13 = (void *)objc_claimAutoreleasedReturnValue([(id)v26[5] trust]);
    uint64_t Name = SOSCircleGetName([v13 trustedCircle]);
    if (v12)
    {
      uint64_t v15 = v12[1](v12, Name, 0LL);
      if (v15)
      {
        uint64_t v12 = *(uint64_t (***)(id, uint64_t, void))v15;
        (*(void (**)(uint64_t, void))(v15 + 72))(v15, 0LL);
      }

      else
      {
        uint64_t v12 = 0LL;
      }
    }

    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472LL;
    v21[2] = sub_1001949DC;
    v21[3] = &unk_100291A10;
    id v16 = v10;
    id v22 = v16;
    uint64_t v23 = &v25;
    sub_1000CCE88((uint64_t)v12, (uint64_t)v9, (uint64_t)&cf, v21);
    if (cf)
    {
      uint64_t v17 = sub_10001267C("otrtimer");
      CFTypeRef v18 = (os_log_s *)objc_claimAutoreleasedReturnValue(v17);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 138412546;
        id v32 = v9;
        __int16 v33 = 2112;
        CFTypeRef v34 = cf;
        _os_log_impl( (void *)&_mh_execute_header,  v18,  OS_LOG_TYPE_DEFAULT,  "error grabbing engine for peer id: %@, error:%@",  buf,  0x16u);
      }

      CFTypeRef v19 = cf;
      if (cf)
      {
        CFTypeRef cf = 0LL;
        CFRelease(v19);
      }
    }

    _Block_object_dispose(&v25, 8);
  }

  return 1LL;
}

void sub_1001D39CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t sub_1001D39F0(uint64_t a1, void *a2, const void **a3)
{
  if (a3) {
    CFTypeRef v4 = *a3;
  }
  else {
    CFTypeRef v4 = 0LL;
  }
  CFTypeRef cf = v4;
  unsigned int v5 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  CFTypeRef v6 = (void *)objc_claimAutoreleasedReturnValue([v5 trust]);
  id v7 = [v6 fullPeerInfo];

  if (!v7)
  {
    unint64_t v11 = sub_10001267C("SecError");
    uint64_t v12 = (os_log_s *)objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "device does not have a peer", buf, 2u);
    }

    SOSCreateError(1032LL, @"No Peer for Account", 0LL, &cf);
    CFTypeRef v9 = 0LL;
    id v8 = 0LL;
LABEL_22:
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
    CFTypeRef v17 = cf;
    if (cf)
    {
      CFTypeRef cf = 0LL;
      CFRelease(v17);
    }

    if (v8) {
      CFRelease(v8);
    }
    if (v9) {
      goto LABEL_11;
    }
    return 1LL;
  }

  id v8 = (const void *)SOSFullPeerInfoCopyOctagonSigningKey(v7, &cf);
  if (!v8 || cf)
  {
    CFTypeRef v13 = sub_10001267C("SecError");
    uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v20 = cf;
      _os_log_impl( (void *)&_mh_execute_header,  v14,  OS_LOG_TYPE_DEFAULT,  "SOSCCPerformWithAllOctagonKeys signing key error: %@",  buf,  0xCu);
    }

    CFTypeRef v9 = 0LL;
    goto LABEL_22;
  }

  CFTypeRef v9 = (CFTypeRef)SOSFullPeerInfoCopyOctagonEncryptionKey(v7, &cf);
  if (!v9 || cf)
  {
    uint64_t v15 = sub_10001267C("SecError");
    id v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      CFTypeRef v20 = cf;
      _os_log_impl( (void *)&_mh_execute_header,  v16,  OS_LOG_TYPE_DEFAULT,  "SOSCCPerformWithAllOctagonKeys encryption key error: %@",  buf,  0xCu);
    }

    goto LABEL_22;
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  CFRelease(v8);
  CFRelease(v9);
  CFTypeRef v9 = cf;
  if (cf)
  {
    CFTypeRef cf = 0LL;
LABEL_11:
    CFRelease(v9);
  }

  return 1LL;
}

void sub_1001D3C70(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a1;
  PrivateAttributeDictionary = (void *)SecKeyGeneratePrivateAttributeDictionary(a3, kSecAttrKeyTypeEC, a2);
  id v9 = [PrivateAttributeDictionary mutableCopy];

  [v9 setObject:v7 forKeyedSubscript:kSecAttrLabel];
  [v9 setObject:&__kCFBooleanTrue forKeyedSubscript:kSecUseDataProtectionKeychain];
  [v9 setObject:kCFBooleanFalse forKeyedSubscript:kSecAttrSynchronizable];
  [v9 setObject:kSOSInternalAccessGroup forKeyedSubscript:kSecAttrAccessGroup];
  CFTypeRef result = 0LL;
  uint64_t v10 = SecItemAdd((CFDictionaryRef)v9, &result);
  if ((_DWORD)v10)
  {
    if ((_DWORD)v10 == -25299)
    {
      unint64_t v11 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:kSecClass]);
      -[NSMutableDictionary setObject:forKeyedSubscript:](v11, "setObject:forKeyedSubscript:", v12, kSecClass);

      CFTypeRef v13 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:kSecAttrKeyTypeEC]);
      -[NSMutableDictionary setObject:forKeyedSubscript:](v11, "setObject:forKeyedSubscript:", v13, kSecAttrKeyType);

      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:kSecAttrKeyClassPrivate]);
      -[NSMutableDictionary setObject:forKeyedSubscript:](v11, "setObject:forKeyedSubscript:", v14, kSecAttrKeyClass);

      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:kSecAttrAccessGroup]);
      -[NSMutableDictionary setObject:forKeyedSubscript:](v11, "setObject:forKeyedSubscript:", v15, kSecAttrAccessGroup);

      id v16 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:kSecAttrLabel]);
      -[NSMutableDictionary setObject:forKeyedSubscript:](v11, "setObject:forKeyedSubscript:", v16, kSecAttrLabel);

      CFTypeRef v17 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:kSecAttrApplicationLabel]);
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v11,  "setObject:forKeyedSubscript:",  v17,  kSecAttrApplicationLabel);

      CFTypeRef v18 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:kSecUseDataProtectionKeychain]);
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v11,  "setObject:forKeyedSubscript:",  v18,  kSecUseDataProtectionKeychain);

      id v19 = [v9 mutableCopy];
      [v19 setObject:0 forKeyedSubscript:kSecClass];
      uint64_t v20 = SecItemUpdate((CFDictionaryRef)v11, (CFDictionaryRef)v19);
      if ((_DWORD)v20)
      {
        uint64_t v21 = (int)v20;
        id v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"SecItemUpdate: %d",  v20));
        uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  NSOSStatusErrorDomain,  v21,  v22));
      }

      else
      {
        uint64_t v23 = 0LL;
      }
    }

    else
    {
      uint64_t v24 = (int)v10;
      unint64_t v11 = (NSMutableDictionary *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"SecItemAdd: %d",  v10));
      uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:description:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:description:",  NSOSStatusErrorDomain,  v24,  v11));
    }

    if (a4 && v23) {
      *a4 = v23;
    }
  }
}

void sub_1001D3FF8(uint64_t a1, void *a2)
{
  CFTypeRef v4 = @"sync";
  id v5 = a2;
  CFTypeRef v6 = (void *)SecKeyCopyPublicKeyHash(a1);
  v19[0] = kSecClass;
  v19[1] = kSecAttrSynchronizable;
  v20[0] = kSecClassKey;
  v20[1] = kSecAttrSynchronizableAny;
  void v19[2] = kSecAttrApplicationLabel;
  void v19[3] = kSecAttrAccessGroup;
  void v20[2] = v6;
  v20[3] = @"sync";
  id v7 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v20,  v19,  4LL));
  CFStringRef v17 = kSecAttrAccessGroup;
  id v18 = v5;
  OSStatus v8 = SecItemUpdate( v7,  (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v18,  &v17,  1LL));
  id v9 = sub_10001267C("octagon");
  uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 138412802;
    id v12 = v5;
    __int16 v13 = 2112;
    uint64_t v14 = @"sync";
    __int16 v15 = 1024;
    OSStatus v16 = v8;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "Ensuring key agrp ('%@' from '%@') status: %d",  (uint8_t *)&v11,  0x1Cu);
  }
}

uint64_t sub_1001D41A4(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v16 = 0LL;
  CFTypeRef v4 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  v10[1] = 3221225472LL;
  __int128 v9 = *(_OWORD *)(a1 + 32);
  __int128 v13 = *(_OWORD *)(a1 + 48);
  v10[0] = _NSConcreteStackBlock;
  _DWORD v10[2] = sub_1001D4284;
  void v10[3] = &unk_100293730;
  id v11 = v3;
  uint64_t v14 = *(void *)(a1 + 64);
  id v5 = (id)v9;
  __int128 v12 = v9;
  __int128 v15 = *(_OWORD *)(a1 + 72);
  id v6 = v3;
  uint64_t v7 = sub_10019BC50(v4, (uint64_t)@"Updating Octagon Keys in SOS", (uint64_t)&v16, v10);

  return v7;
}

uint64_t sub_1001D4284(uint64_t a1, uint64_t a2)
{
  CFTypeRef v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) account]);
  id v5 = sub_1001D45A0(v4, *(void **)(a1 + 48), *(void **)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 72));
  id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);

  if (v6)
  {
    uint64_t v7 = sub_10001267C("SecError");
    OSStatus v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      id v29 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "octagon: failed to save Octagon keys to the keychain: %@",  buf,  0xCu);
    }

    __int128 v9 = *(void (**)(void))(*(void *)(a1 + 40) + 16LL);
LABEL_5:
    v9();
LABEL_6:
    uint64_t v10 = 0LL;
    goto LABEL_7;
  }

  if (!a2)
  {
    uint64_t v14 = sub_10001267C("octagon");
    __int128 v15 = (os_log_s *)objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "No peer info to update?", buf, 2u);
    }

    uint64_t v16 = kSOSErrorDomain;
    NSErrorUserInfoKey v26 = NSLocalizedDescriptionKey;
    uint64_t v27 = @"Device has no full peer info";
    CFStringRef v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v27,  &v26,  1LL));
    id v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v16,  1032LL,  v17));

    (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
    goto LABEL_6;
  }

  uint64_t v25 = 0LL;
  SOSPeerInfoSetOctagonKeysInDescription(a2, *(void *)(a1 + 64), *(void *)(a1 + 72), &v25);
  if (v25)
  {
    __int128 v12 = sub_10001267C("SecError");
    __int128 v13 = (os_log_s *)objc_claimAutoreleasedReturnValue(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      id v29 = v25;
      _os_log_impl( (void *)&_mh_execute_header,  v13,  OS_LOG_TYPE_DEFAULT,  "octagon: Failed to set Octagon Keys in peerInfo: %@",  buf,  0xCu);
    }

    __int128 v9 = *(void (**)(void))(*(void *)(a1 + 40) + 16LL);
    goto LABEL_5;
  }

  uint64_t v19 = *(void *)(a1 + 80);
  if (v19) {
    CFRetain(*(CFTypeRef *)(a1 + 80));
  }
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) account]);
  [v20 setOctagonSigningFullKeyRef:v19];

  uint64_t v21 = *(void *)(a1 + 88);
  if (v21) {
    CFRetain(*(CFTypeRef *)(a1 + 88));
  }
  id v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) account]);
  [v22 setOctagonEncryptionFullKeyRef:v21];

  uint64_t v23 = sub_10001267C("octagon");
  uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v24,  OS_LOG_TYPE_DEFAULT,  "Success! Updated Octagon keys in SOS!",  buf,  2u);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
  uint64_t v10 = 1LL;
LABEL_7:

  return v10;
}

id sub_1001D45A0(void *a1, void *a2, void *a3, uint64_t a4, uint64_t a5)
{
  id v9 = a3;
  id v10 = a2;
  id v11 = a1;
  __int128 v12 = (void *)objc_claimAutoreleasedReturnValue([v11 trust]);
  uint64_t Name = SOSCircleGetName([v12 trustedCircle]);
  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(Name);

  __int128 v15 = (void *)objc_claimAutoreleasedReturnValue([v11 gestalt]);
  id v16 = sub_1001D47B0((uint64_t)v15, v14, @"Octagon Peer Signing ");
  CFStringRef v17 = (void *)objc_claimAutoreleasedReturnValue(v16);

  id v18 = (void *)objc_claimAutoreleasedReturnValue([v11 gestalt]);
  id v19 = sub_1001D47B0((uint64_t)v18, v14, @"Octagon Peer Encryption ");
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(v19);

  id v29 = 0LL;
  sub_1001D3C70(v17, (uint64_t)v10, a4, &v29);

  id v21 = v29;
  if (v21)
  {
    id v22 = v21;
    uint64_t v23 = sub_10001267C("SecError");
    uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v23);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      id v31 = v22;
      uint64_t v25 = "octagon: could not save signing key: %@";
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v25, buf, 0xCu);
      goto LABEL_8;
    }

    goto LABEL_8;
  }

  id v28 = 0LL;
  sub_1001D3C70(v20, (uint64_t)v9, a5, &v28);
  id v22 = v28;
  if (v22)
  {
    NSErrorUserInfoKey v26 = sub_10001267C("SecError");
    uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue(v26);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      id v31 = v22;
      uint64_t v25 = "octagon: could not save encryption key: %@";
      goto LABEL_7;
    }

id sub_1001D47B0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = a2;
  uint64_t v7 = +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"ID for %@-%@",  SOSPeerGestaltGetName(a1),  v6);
  OSStatus v8 = (void *)objc_claimAutoreleasedReturnValue(v7);

  id v9 = (void *)objc_claimAutoreleasedReturnValue([v5 stringByAppendingString:v8]);
  return v9;
}

uint64_t sub_1001D4840(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFTypeRef v4 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  id v5 = sub_1001D45A0(v4, *(void **)(a1 + 40), *(void **)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 64));
  id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);

  if (v6)
  {
    uint64_t v7 = sub_10001267C("SecError");
    OSStatus v8 = (os_log_s *)objc_claimAutoreleasedReturnValue(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 138412290;
      NSErrorUserInfoKey v26 = v6;
      _os_log_impl( (void *)&_mh_execute_header,  v8,  OS_LOG_TYPE_DEFAULT,  "octagon-preload-keys: failed to save Octagon keys to the keychain: %@",  buf,  0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
LABEL_5:
    uint64_t v9 = 0LL;
    goto LABEL_14;
  }

  id v10 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);

  if (!v10)
  {
    id v18 = sub_10001267C("octagon-preload-keys");
    id v19 = (os_log_s *)objc_claimAutoreleasedReturnValue(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "No SOSAccount to update?", buf, 2u);
    }

    uint64_t v20 = kSOSErrorDomain;
    NSErrorUserInfoKey v23 = NSLocalizedDescriptionKey;
    uint64_t v24 = @"Device has no SOSAccount";
    id v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v24,  &v23,  1LL));
    id v22 = (void *)objc_claimAutoreleasedReturnValue( +[NSError errorWithDomain:code:userInfo:]( &OBJC_CLASS___NSError,  "errorWithDomain:code:userInfo:",  v20,  1048LL,  v21));

    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
    goto LABEL_5;
  }

  uint64_t v11 = *(void *)(a1 + 72);
  if (v11) {
    CFRetain(*(CFTypeRef *)(a1 + 72));
  }
  __int128 v12 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  [v12 setOctagonSigningFullKeyRef:v11];

  uint64_t v13 = *(void *)(a1 + 80);
  if (v13) {
    CFRetain(*(CFTypeRef *)(a1 + 80));
  }
  uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v3 account]);
  [v14 setOctagonEncryptionFullKeyRef:v13];

  __int128 v15 = sub_10001267C("octagon-preload-keys");
  id v16 = (os_log_s *)objc_claimAutoreleasedReturnValue(v15);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int128 buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Success! Octagon Keys Preloaded!", buf, 2u);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  uint64_t v9 = 1LL;
LABEL_14:

  return v9;
}

uint64_t sub_1001D4AEC(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  void v7[2] = sub_1001D4B7C;
  void v7[3] = &unk_100293778;
  char v8 = *(_BYTE *)(a1 + 32);
  sub_10019BA34(v5, (uint64_t)@"CKKS4All update", a3, v7);

  return 1LL;
}

uint64_t sub_1001D4B7C(uint64_t a1, uint64_t a2)
{
  return SOSFullPeerInfoSetCKKS4AllSupport(a2, *(unsigned __int8 *)(a1 + 32));
}

uint64_t sub_1001D4B8C(uint64_t a1, void *a2)
{
  id v3 = (void *)objc_claimAutoreleasedReturnValue([a2 account]);
  CFTypeRef v4 = (void *)objc_claimAutoreleasedReturnValue([v3 trust]);
  id v5 = [v4 copyPeerSetMatching:&stru_1002937B8];

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  if (v5) {
    CFRelease(v5);
  }
  return 1LL;
}

BOOL sub_1001D4C20(id a1, __OpaqueSOSPeerInfo *a2)
{
  return 1;
}

uint64_t sub_1001D4F80()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000LL;
  block[2] = sub_1001D4FFC;
  block[3] = &unk_100293B98;
  void block[4] = &qword_1002DEEE0;
  if (qword_1002DEED8 != -1) {
    dispatch_once(&qword_1002DEED8, block);
  }
  return qword_1002DEEE0;
}

uint64_t sub_1001D4FFC(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass(&unk_100293B38);
  **(void **)(a1 + 32) = result;
  return result;
}

void sub_1001D502C(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  if (v2)
  {
    a1[2] = 0LL;
    CFRelease(v2);
  }

  id v3 = (const void *)a1[3];
  if (v3)
  {
    a1[3] = 0LL;
    CFRelease(v3);
  }

  CFTypeRef v4 = (const void *)a1[5];
  if (v4)
  {
    a1[5] = 0LL;
    CFRelease(v4);
  }

  id v5 = (const void *)a1[4];
  if (v5)
  {
    a1[4] = 0LL;
    CFRelease(v5);
  }

uint64_t sub_1001D5090(void *a1, void *a2)
{
  id v3 = a1;
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != sub_1001D4F80()) {
    return 0LL;
  }
  CFTypeID v5 = CFGetTypeID(a2);
  if (v5 != sub_1001D4F80()) {
    return 0LL;
  }
  CFTypeID v6 = CFGetTypeID(v3);
  if (v6 == sub_1001D4F80()) {
    sub_1001D5570(v3);
  }
  else {
    id v3 = 0LL;
  }
  CFTypeID v7 = CFGetTypeID(a2);
  if (v7 != sub_1001D4F80()) {
    return 0LL;
  }
  sub_1001D5570(a2);
  uint64_t result = 0LL;
  if (!a2 || !v3) {
    return result;
  }
  uint64_t v9 = (const void *)v3[2];
  id v10 = (const void *)a2[2];
  if (v9 && v10)
  {
    uint64_t result = CFEqual(v9, v10);
    if (!(_DWORD)result) {
      return result;
    }
  }

  else if (v9 != v10)
  {
    return 0LL;
  }

  uint64_t v11 = (const void *)v3[3];
  __int128 v12 = (const void *)a2[3];
  if (v11 && v12)
  {
    uint64_t result = CFEqual(v11, v12);
    if (!(_DWORD)result) {
      return result;
    }
  }

  else if (v11 != v12)
  {
    return 0LL;
  }

  uint64_t v13 = (const void *)v3[5];
  uint64_t v14 = (const void *)a2[5];
  if (v13 && v14)
  {
    uint64_t result = CFEqual(v13, v14);
    if (!(_DWORD)result) {
      return result;
    }
    goto LABEL_26;
  }

  if (v13 != v14) {
    return 0LL;
  }
LABEL_26:
  __int128 v15 = (const void *)v3[4];
  id v16 = (const void *)a2[4];
  if (v15 && v16) {
    return CFEqual(v15, v16) != 0;
  }
  else {
    return v15 == v16;
  }
}

__CFString *sub_1001D51D4(uint64_t a1, const __CFDictionary *a2)
{
  signed int Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"PeerIDs");
  if (!Value || (CFTypeID v5 = Value, v6 = CFGetTypeID(Value), v6 != CFSetGetTypeID())) {
    CFTypeID v5 = 0LL;
  }
  CFMutableStringRef v7 = sub_1001D5850(v5);
  sub_1001D5570((void *)a1);
  char v8 = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"Applicants");
  CFMutableStringRef v9 = sub_1001D5850(v8);
  sub_1001D5570((void *)a1);
  id v10 = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"Rejections");
  CFMutableStringRef v11 = sub_1001D5850(v10);
  id v19 = sub_1001D5920((uint64_t)v11, v12, v13, v14, v15, v16, v17, v18, (uint64_t)@"MEMBER", (uint64_t)v7);
  if (v7) {
    CFRelease(v7);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v11) {
    CFRelease(v11);
  }
  v37[0] = 0LL;
  v37[1] = v37;
  void v37[2] = 0x2000000000LL;
  char v38 = 0;
  CFMutableStringRef Mutable = CFStringCreateMutable(0LL, 0LL);
  id v21 = *(const __CFDictionary **)(a1 + 32);
  context[0] = _NSConcreteStackBlock;
  context[1] = 0x40000000LL;
  uint64_t context[2] = sub_1001D5788;
  context[3] = &unk_100293C08;
  void context[4] = v37;
  void context[5] = Mutable;
  CFDictionaryApplyFunction(v21, (CFDictionaryApplierFunction)sub_1001D5838, context);
  _Block_object_dispose(v37, 8);
  id v22 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"Generation");
  NSErrorUserInfoKey v23 = (const void *)SOSGenerationCountCopyDescription(v22);
  uint64_t v24 = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
  uint64_t v25 = sub_1001D570C(*(const __CFDictionary **)(a1 + 24));
  CFStringAppendFormat(v24, a2, @"<SOSRing: '%@'", v25);
  NSErrorUserInfoKey v26 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"Generation");
  v35[0] = _NSConcreteStackBlock;
  v35[1] = 0x40000000LL;
  v35[2] = sub_1001D5754;
  v35[3] = &unk_100293C78;
  v35[4] = v24;
  void v35[5] = a2;
  SOSGenerationCountWithDescription(v26, v35);
  uint64_t v27 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"LastModifier");
  if (v27)
  {
    id v28 = v27;
    if (CFStringGetLength(v27) > 8)
    {
      v39.id location = 0LL;
      v39.CFIndex length = 8LL;
      CFStringRef Copy = CFStringCreateWithSubstring(kCFAllocatorDefault, v28, v39);
    }

    else
    {
      CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, v28);
    }

    CFStringRef v30 = Copy;
    CFStringAppendFormat(v24, a2, @"Mod: %@, ", Copy);
    if (v30) {
      CFRelease(v30);
    }
  }

  else
  {
    CFStringAppendFormat(v24, a2, @"Mod: %@, ", 0LL);
  }

  id v31 = CFDictionaryGetValue(v19, @"MEMBER");
  CFStringAppendFormat(v24, a2, @"P: [%@], ", v31);
  id v32 = CFDictionaryGetValue(v19, @"APPLICANTS");
  CFStringAppendFormat(v24, a2, @"A: [%@], ", v32);
  __int16 v33 = CFDictionaryGetValue(v19, @"REJECTS");
  CFStringAppendFormat(v24, a2, @"R: [%@], ", v33);
  CFStringAppendFormat(v24, a2, @"S: [%@]>", Mutable);
  if (v23) {
    CFRelease(v23);
  }
  if (v19) {
    CFRelease(v19);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v24;
}

__CFString *sub_1001D5548(uint64_t a1)
{
  uint64_t v2 = (const __CFDictionary *)sub_100012DC4();
  return sub_1001D51D4(a1, v2);
}

uint64_t sub_1001D5570(void *a1)
{
  if (!a1)
  {
    uint64_t v2 = (os_log_s *)sub_10001267C("SecError");
    BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (!v3) {
      return result;
    }
    __int16 v14 = 0;
    CFTypeID v4 = "no ring passed in";
    CFTypeID v5 = (uint8_t *)&v14;
    goto LABEL_18;
  }

  if (!a1[2])
  {
    uint64_t v2 = (os_log_s *)sub_10001267C("SecError");
    BOOL v6 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (!v6) {
      return result;
    }
    __int16 v13 = 0;
    CFTypeID v4 = "ring has no unSignedInformation";
    CFTypeID v5 = (uint8_t *)&v13;
    goto LABEL_18;
  }

  if (!a1[3])
  {
    uint64_t v2 = (os_log_s *)sub_10001267C("SecError");
    BOOL v7 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (!v7) {
      return result;
    }
    __int16 v12 = 0;
    CFTypeID v4 = "ring has no signedInformation";
    CFTypeID v5 = (uint8_t *)&v12;
    goto LABEL_18;
  }

  if (!a1[4])
  {
    uint64_t v2 = (os_log_s *)sub_10001267C("SecError");
    BOOL v8 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0LL;
    if (!v8) {
      return result;
    }
    __int16 v11 = 0;
    CFTypeID v4 = "ring has no signatures";
    CFTypeID v5 = (uint8_t *)&v11;
LABEL_18:
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, v4, v5, 2u);
    return 0LL;
  }

  if (a1[5]) {
    return 1LL;
  }
  uint64_t v2 = (os_log_s *)sub_10001267C("SecError");
  BOOL v9 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0LL;
  if (v9)
  {
    __int16 v10 = 0;
    CFTypeID v4 = "ring has no data";
    CFTypeID v5 = (uint8_t *)&v10;
    goto LABEL_18;
  }

  return result;
}

const void *sub_1001D570C(const __CFDictionary *a1)
{
  signed int Value = CFDictionaryGetValue(a1, @"RingName");
  if (!Value) {
    return 0LL;
  }
  uint64_t v2 = Value;
  CFTypeID v3 = CFGetTypeID(Value);
  if (v3 != CFStringGetTypeID()) {
    return 0LL;
  }
  return v2;
}

void sub_1001D5754(uint64_t a1, uint64_t a2)
{
}

void sub_1001D5788(uint64_t a1, CFStringRef theString)
{
  uint64_t v2 = theString;
  if (theString)
  {
    if (CFStringGetLength(theString) > 8)
    {
      v5.id location = 0LL;
      v5.CFIndex length = 8LL;
      CFStringRef Copy = CFStringCreateWithSubstring(kCFAllocatorDefault, v2, v5);
    }

    else
    {
      CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, v2);
    }

    uint64_t v2 = Copy;
  }

  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)) {
    CFStringAppendCString(*(CFMutableStringRef *)(a1 + 40), ", ", 0x8000100u);
  }
  CFStringAppend(*(CFMutableStringRef *)(a1 + 40), v2);
  if (v2) {
    CFRelease(v2);
  }
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
}

uint64_t sub_1001D5838(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

CFMutableStringRef sub_1001D5850(const __CFSet *a1)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0LL);
  CFMutableStringRef v3 = Mutable;
  v6[0] = 0LL;
  v6[1] = v6;
  v6[2] = 0x2000000000LL;
  char v7 = 0;
  if (a1)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000LL;
    _DWORD v5[2] = sub_1001D5A0C;
    void v5[3] = &unk_100293C30;
    void v5[4] = v6;
    void v5[5] = Mutable;
    context[0] = _NSConcreteStackBlock;
    context[1] = 0x40000000LL;
    uint64_t context[2] = sub_1001D5ACC;
    context[3] = &unk_100293C58;
    void context[4] = v5;
    CFSetApplyFunction(a1, (CFSetApplierFunction)sub_1001D5AD8, context);
  }

  _Block_object_dispose(v6, 8);
  return v3;
}

CFDictionaryRef sub_1001D5920( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  id v21 = &a10;
  unint64_t v10 = 0LL;
  if (a9)
  {
    do
    {
      v10 += 2LL;
      __int16 v11 = v21;
      v21 += 2;
    }

    while (v11[1]);
  }

  unint64_t v12 = v10 >> 1;
  id v22 = (const void **)&a9;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, v10 >> 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable) {
    return 0LL;
  }
  __int16 v14 = Mutable;
  if (v10)
  {
    do
    {
      uint64_t v15 = v22;
      uint64_t v16 = *v22;
      v22 += 2;
      uint64_t v17 = (const __CFNull *)v15[1];
      if (v17) {
        CFNullRef v18 = v17;
      }
      else {
        CFNullRef v18 = kCFNull;
      }
      CFDictionarySetValue(v14, v16, v18);
      --v12;
    }

    while (v12);
  }

  CFDictionaryRef Copy = CFDictionaryCreateCopy(0LL, v14);
  CFRelease(v14);
  return Copy;
}

void sub_1001D5A0C(uint64_t a1, CFStringRef theString)
{
  if (*(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL)) {
    CFStringAppendCString(*(CFMutableStringRef *)(a1 + 40), ", ", 0x8000100u);
  }
  if (theString)
  {
    if (CFStringGetLength(theString) > 8)
    {
      v6.id location = 0LL;
      v6.CFIndex length = 8LL;
      CFDictionaryRef Copy = CFStringCreateWithSubstring(kCFAllocatorDefault, theString, v6);
    }

    else
    {
      CFDictionaryRef Copy = CFStringCreateCopy(kCFAllocatorDefault, theString);
    }

    CFRange v5 = Copy;
    CFStringAppend(*(CFMutableStringRef *)(a1 + 40), Copy);
    if (v5) {
      CFRelease(v5);
    }
  }

  else
  {
    CFStringAppend(*(CFMutableStringRef *)(a1 + 40), 0LL);
  }

  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
}

uint64_t sub_1001D5ACC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t sub_1001D5AD8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_1001D5AEC(void *a1)
{
  uint64_t v2 = 64429LL;
  unsigned int valuePtr = 64429;
  if (sub_1001D5570(a1))
  {
    CFMutableStringRef v3 = (const __CFDictionary *)a1[3];
    if (v3)
    {
      signed int Value = (const __CFNumber *)CFDictionaryGetValue(v3, @"RingType");
      if (Value)
      {
        CFRange v5 = Value;
        CFTypeID v6 = CFGetTypeID(Value);
        if (v6 == CFNumberGetTypeID())
        {
          CFNumberGetValue(v5, kCFNumberSInt32Type, &valuePtr);
          return valuePtr;
        }

        else
        {
          return 64429LL;
        }
      }
    }
  }

  return v2;
}

uint64_t sub_1001D5B70(const __CFDictionary *a1, uint64_t a2)
{
  signed int Value = CFDictionaryGetValue(a1, @"Generation");
  CFTypeID v4 = CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 24), @"Generation");
  return SOSGenerationIsOlder(Value, v4);
}

BOOL sub_1001D5BBC(uint64_t a1, const void *a2)
{
  signed int Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"Applicants");
  return CFSetContainsValue(Value, a2) != 0;
}

BOOL sub_1001D5C08(uint64_t a1, const void *a2)
{
  signed int Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"Rejections");
  return CFSetContainsValue(Value, a2) != 0;
}

void sub_1001D5C54(uint64_t a1, const void *a2)
{
  signed int Value = (__CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"Rejections");
  CFSetRemoveValue(Value, a2);
}

const void *sub_1001D5C8C(uint64_t a1)
{
  signed int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"BackupViews");
  if (!Value) {
    return 0LL;
  }
  CFMutableStringRef v3 = Value;
  CFTypeID v4 = CFGetTypeID(Value);
  if (v4 != CFSetGetTypeID()) {
    return 0LL;
  }
  return v3;
}

BOOL sub_1001D5CE0(uint64_t a1, const void *a2)
{
  if (a2) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"BackupViews", a2);
  }
  return a2 != 0LL;
}

BOOL sub_1001D5D24(uint64_t a1, const void *a2)
{
  if (a2) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"PeerIDs", a2);
  }
  return a2 != 0LL;
}

BOOL sub_1001D5D68(uint64_t a1, const void *a2)
{
  signed int Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"PeerIDs");
  if (!Value || (CFRange v5 = Value, v6 = CFGetTypeID(Value), v6 != CFSetGetTypeID())) {
    CFRange v5 = 0LL;
  }
  return CFSetContainsValue(v5, a2) != 0;
}

CFMutableSetRef sub_1001D5DE0(uint64_t a1)
{
  signed int Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"PeerIDs");
  if (!Value || (v3 = Value, CFTypeID v4 = CFGetTypeID(Value), v4 != CFSetGetTypeID())) {
    CFMutableStringRef v3 = 0LL;
  }
  return CFSetCreateMutableCopy(0LL, 0LL, v3);
}

void sub_1001D5E3C(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeRef PeerID = cf;
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 != SOSPeerInfoGetTypeID() || (CFTypeRef PeerID = (CFTypeRef)SOSPeerInfoGetPeerID(PeerID)) != 0LL)
    {
      CFTypeID v5 = CFGetTypeID(PeerID);
      if (v5 == CFStringGetTypeID()) {
        sub_1001D5EC0(*(void *)(a1 + 32), PeerID);
      }
    }
  }

void sub_1001D5EC0(uint64_t a1, const void *a2)
{
  signed int Value = (__CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"PeerIDs");
  if (!Value || (CFTypeID v5 = Value, v6 = CFGetTypeID(Value), v6 != CFSetGetTypeID())) {
    CFTypeID v5 = 0LL;
  }
  CFSetAddValue(v5, a2);
}

void sub_1001D5F24(uint64_t a1, uint64_t a2)
{
  signed int Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"PeerIDs");
  if (Value)
  {
    CFTypeID v5 = Value;
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFSetGetTypeID())
    {
      context[0] = _NSConcreteStackBlock;
      context[1] = 0x40000000LL;
      uint64_t context[2] = sub_1001D5FD0;
      context[3] = &unk_100293BE0;
      void context[4] = a2;
      CFSetApplyFunction(v5, (CFSetApplierFunction)sub_1001D5AD8, context);
    }
  }

uint64_t sub_1001D5FD0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t sub_1001D5FDC(const void *a1, int a2, uint64_t a3)
{
  uint64_t v6 = sub_1001D4F80();
  uint64_t Instance = _CFRuntimeCreateInstance(0LL, v6, 32LL, 0LL);
  BOOL v8 = (const void *)SOSGenerationCreate();
  if (!a1)
  {
    SOSCreateError(1036LL, @"No ring name", 0LL, a3);
    if (v8) {
LABEL_29:
    }
      CFRelease(v8);
LABEL_30:
    uint64_t v23 = 0LL;
    uint64_t result = 0LL;
    CFMutableSetRef v22 = (CFMutableSetRef)Instance;
    if (!Instance) {
      return result;
    }
    goto LABEL_31;
  }

  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(void *)(Instance + 16) = Mutable;
  if (!Mutable)
  {
    uint64_t v25 = @"Failed to allocate unsigned information area";
    goto LABEL_20;
  }

  CFMutableDictionaryRef v10 = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(void *)(Instance + 24) = v10;
  if (!v10)
  {
    uint64_t v25 = @"Failed to allocate signed information area";
    goto LABEL_20;
  }

  CFMutableDictionaryRef v11 = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(void *)(Instance + 32) = v11;
  if (!v11)
  {
    uint64_t v25 = @"Failed to allocate signature area";
    goto LABEL_20;
  }

  CFMutableDictionaryRef v12 = CFDictionaryCreateMutable(0LL, 0LL, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(void *)(Instance + 40) = v12;
  if (!v12)
  {
    uint64_t v25 = @"Failed to allocate data area";
    goto LABEL_20;
  }

  CFDictionarySetValue(*(CFMutableDictionaryRef *)(Instance + 24), @"RingName", a1);
  int valuePtr = a2;
  sub_1001D5570((void *)Instance);
  CFNumberRef v13 = CFNumberCreate(0LL, kCFNumberSInt32Type, &valuePtr);
  if (!v13)
  {
    uint64_t v25 = @"Failed to allocate ring type";
    goto LABEL_20;
  }

  CFNumberRef v14 = v13;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(Instance + 24), @"RingType", v13);
  CFRelease(v14);
  int v34 = 1;
  CFNumberRef v15 = CFNumberCreate(0LL, kCFNumberSInt32Type, &v34);
  if (!v15)
  {
    CFStringRef v30 = (os_log_s *)sub_10001267C("ring");
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int128 buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Could not create version number", buf, 2u);
    }

    uint64_t v25 = @"Failed to allocate ring version";
LABEL_20:
    SOSCreateError(1024LL, v25, 0LL, a3);
    NSErrorUserInfoKey v26 = *(const void **)(Instance + 16);
    if (v26)
    {
      *(void *)(Instance + 16) = 0LL;
      CFRelease(v26);
    }

    uint64_t v27 = *(const void **)(Instance + 24);
    if (v27)
    {
      *(void *)(Instance + 24) = 0LL;
      CFRelease(v27);
    }

    id v28 = *(const void **)(Instance + 32);
    if (v28)
    {
      *(void *)(Instance + 32) = 0LL;
      CFRelease(v28);
    }

    id v29 = *(const void **)(Instance + 40);
    if (v29)
    {
      *(void *)(Instance + 40) = 0LL;
      CFRelease(v29);
    }

    if (v8) {
      goto LABEL_29;
    }
    goto LABEL_30;
  }

  CFNumberRef v16 = v15;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(Instance + 24), @"RingVersion", v15);
  CFRelease(v16);
  uint64_t v17 = CFUUIDCreate(0LL);
  if (!v17)
  {
    id v31 = (os_log_s *)sub_10001267C("ring");
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v35 = 0;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Could not create ring identifier", v35, 2u);
    }

    uint64_t v25 = @"Failed to allocate ring identifier";
    goto LABEL_20;
  }

  CFNullRef v18 = v17;
  CFStringRef v19 = CFUUIDCreateString(0LL, v17);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(Instance + 24), @"Identifier", v19);
  CFRelease(v18);
  if (v19) {
    CFRelease(v19);
  }
  CFMutableSetRef v20 = CFSetCreateMutable(0LL, 0LL, &kCFTypeSetCallBacks);
  sub_1001D5570((void *)Instance);
  if (!v20)
  {
    uint64_t v25 = @"Failed to allocate applicant area";
    goto LABEL_20;
  }

  CFDictionarySetValue(*(CFMutableDictionaryRef *)(Instance + 16), @"Applicants", v20);
  CFRelease(v20);
  CFMutableSetRef v21 = CFSetCreateMutable(0LL, 0LL, &kCFTypeSetCallBacks);
  sub_1001D5570((void *)Instance);
  if (!v21)
  {
    uint64_t v25 = @"Failed to allocate rejection area";
    goto LABEL_20;
  }

  CFDictionarySetValue(*(CFMutableDictionaryRef *)(Instance + 16), @"Rejections", v21);
  CFRelease(v21);
  if (!v8)
  {
    uint64_t v25 = @"Failed to allocate generation count";
    goto LABEL_20;
  }

  CFDictionarySetValue(*(CFMutableDictionaryRef *)(Instance + 24), @"Generation", v8);
  CFMutableSetRef v22 = CFSetCreateMutable(0LL, 0LL, &kCFTypeSetCallBacks);
  if (!sub_1001D5D24(Instance, v22))
  {
    uint64_t v25 = @"Failed to allocate PeerID";
    goto LABEL_20;
  }

  CFRelease(v8);
  uint64_t v23 = Instance;
  uint64_t result = Instance;
  if (!v22) {
    return result;
  }
LABEL_31:
  CFRelease(v22);
  return v23;
}

BOOL sub_1001D6420(uint64_t a1)
{
  signed int Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"PeerIDs");
  if (!Value || (v3 = Value, CFTypeID v4 = CFGetTypeID(Value), v4 != CFSetGetTypeID())) {
    CFMutableStringRef v3 = 0LL;
  }
  return CFSetGetCount(v3) == 0;
}

void sub_1001D6480(uint64_t a1)
{
  signed int Value = (__CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"Applicants");
  CFSetRemoveAllValues(Value);
  sub_1001D5570((void *)a1);
  CFMutableStringRef v3 = (__CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"Rejections");
  CFSetRemoveAllValues(v3);
  sub_1001D5570((void *)a1);
  CFTypeID v4 = (__CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"PeerIDs");
  if (!v4 || (CFTypeID v5 = v4, v6 = CFGetTypeID(v4), v6 != CFSetGetTypeID())) {
    CFTypeID v5 = 0LL;
  }
  CFSetRemoveAllValues(v5);
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 32));
  char v7 = (const void *)SOSGenerationCreate();
  if (v7)
  {
    BOOL v8 = v7;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Generation", v7);
    CFRelease(v8);
  }

BOOL sub_1001D6554(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFTypeID v4 = (const void *)SOSCopyIDOfKey(a2, a3);
  CFTypeID v5 = v4;
  if (a1 && v4)
  {
    signed int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), v4);
    char v7 = Value;
    if (Value)
    {
      CFTypeID v8 = CFGetTypeID(Value);
      if (v8 != CFDataGetTypeID()) {
        char v7 = 0LL;
      }
    }

    goto LABEL_8;
  }

  char v7 = 0LL;
  BOOL v9 = 0LL;
  if (v4)
  {
LABEL_8:
    CFRelease(v5);
    BOOL v9 = v7;
  }

  return v9 != 0LL;
}

BOOL sub_1001D65E8(uint64_t a1, __SecKey *a2, CFTypeRef *a3)
{
  CFTypeID v6 = (const __CFData *)SOSCopyIDOfKey(a2, a3);
  CFDataRef v7 = v6;
  if (a1 && v6)
  {
    signed int Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), v6);
    if (Value && (BOOL v9 = Value, v10 = CFGetTypeID(Value), v10 == CFDataGetTypeID()))
    {
      CFRelease(v7);
      CFMutableDictionaryRef v12 = (CFIndex *)ccsha256_di(v11);
      CFDataRef v7 = sub_1001D66E8(v12, a1, a3);
      BytePtr = CFDataGetBytePtr(v7);
      size_t Length = CFDataGetLength(v7);
      CFNumberRef v15 = CFDataGetBytePtr(v9);
      size_t v16 = CFDataGetLength(v9);
      BOOL v17 = SecKeyRawVerify(a2, 0, BytePtr, Length, v15, v16) == 0;
      if (!v7) {
        return v17;
      }
    }

    else
    {
      BOOL v17 = 0LL;
    }
  }

  else
  {
    BOOL v17 = 0LL;
    if (!v6) {
      return v17;
    }
  }

  CFRelease(v7);
  return v17;
}

CFDataRef sub_1001D66E8(CFIndex *a1, uint64_t a2, CFTypeRef *a3)
{
  BOOL v9 = (const UInt8 *)&v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  if (v6) {
    memset((char *)&v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL), 170, v6);
  }
  CFDataRef result = (CFDataRef)sub_100019A68(*(const __CFString **)(a2 + 24), a3, v6, v7, v8);
  if (result)
  {
    CFDataRef v11 = result;
    CFDataRef result = (CFDataRef)malloc((size_t)result);
    if (result)
    {
      CFDataRef v12 = result;
      if (sub_100019C44(*(const __CFString **)(a2 + 24), a3, 0LL, (UInt8 *)v12, (unint64_t)v11 + (void)v12))
      {
        ccdigest(a1, v11, v12, v9);
        free(v12);
        return CFDataCreate(0LL, v9, *a1);
      }

      else
      {
        free(v12);
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t sub_1001D6800(uint64_t a1, __SecKey *a2, CFTypeRef *a3)
{
  if (a1) {
    BOOL v3 = a2 == 0LL;
  }
  else {
    BOOL v3 = 1;
  }
  uint64_t v4 = !v3;
  if (!v3)
  {
    signed int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"Generation");
    BOOL v9 = (const void *)SOSGenerationIncrementAndCreate(Value);
    if (v9)
    {
      CFTypeID v10 = v9;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Generation", v9);
      CFRelease(v10);
    }

    CFDataRef v11 = (os_log_s *)sub_10001267C("Development");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v13 = 0;
      _os_log_impl( (void *)&_mh_execute_header,  v11,  OS_LOG_TYPE_DEFAULT,  "SOSRingEnsureRingConsistency requires ring membership and generation count consistency check",  v13,  2u);
    }

    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 32));
    sub_1001D68E4(a1, a2, a3);
  }

  return v4;
}

void sub_1001D68E4(uint64_t a1, __SecKey *a2, CFTypeRef *a3)
{
  size_t v6 = (CFIndex *)ccsha256_di(a1);
  uint64_t v7 = sub_1001D66E8(v6, a1, a3);
  CFDataRef v8 = sub_1001D69A4(a2, v7);
  id PublicFromPrivate = (const void *)SecKeyCreatePublicFromPrivate(a2);
  CFTypeID v10 = (const void *)SOSCopyIDOfKey(PublicFromPrivate, a3);
  if (v10) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), v10, v8);
  }
  if (PublicFromPrivate) {
    CFRelease(PublicFromPrivate);
  }
  if (v10) {
    CFRelease(v10);
  }
  CFRelease(v8);
  if (v7) {
    CFRelease(v7);
  }
}

CFDataRef sub_1001D69A4(__SecKey *a1, const __CFData *a2)
{
  uint64_t Size = SecKeyGetSize(a1, 1LL);
  size_t sigLen = Size + 16;
  __chkstk_darwin(Size);
  uint64_t v7 = (UInt8 *)&sigLen - v6;
  if (v5) {
    memset((char *)&sigLen - v6, 170, v5);
  }
  BytePtr = CFDataGetBytePtr(a2);
  size_t Length = CFDataGetLength(a2);
  if (SecKeyRawSign(a1, 0, BytePtr, Length, v7, &sigLen)) {
    return 0LL;
  }
  else {
    return CFDataCreate(0LL, v7, sigLen);
  }
}

void sub_1001D7B90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1001D7C5C(uint64_t a1, char a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = a2;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_1001D7C70(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) account]);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  _DWORD v3[2] = sub_1001D7CF4;
  v3[3] = &unk_100293CC8;
  id v4 = *(id *)(a1 + 40);
  [v2 SOSMonitorModeSOSIsActiveWithCallback:v3];
}

uint64_t sub_1001D7CF4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_1001D7D00(uint64_t a1)
{
  id v1 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) account]);
  [v1 SOSMonitorModeEnableSOS];
}

void sub_1001D7D30(uint64_t a1)
{
  id v1 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) account]);
  [v1 SOSMonitorModeDisableSOS];
}

void sub_1001D7FB0(id a1)
{
  id v1 = objc_autoreleasePoolPush();
  uint64_t v2 = objc_opt_new(&OBJC_CLASS___SOSControlServer);
  BOOL v3 = (void *)qword_1002DEEF8;
  qword_1002DEEF8 = (uint64_t)v2;

  id v4 = -[NSXPCListener initWithMachServiceName:]( objc_alloc(&OBJC_CLASS___NSXPCListener),  "initWithMachServiceName:",  @"com.apple.securityd.sos");
  size_t v5 = (void *)qword_1002DEEF0;
  qword_1002DEEF0 = (uint64_t)v4;

  [(id)qword_1002DEEF0 setDelegate:qword_1002DEEF8];
  [(id)qword_1002DEEF0 resume];
  objc_autoreleasePoolPop(v1);
}

void sub_1001D873C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1001D8810( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1001D8848(uint64_t a1, CFTypeRef cf, const void *a3)
{
  if (!cf || (CFTypeRef v5 = cf, v6 = CFGetTypeID(cf), v6 != CFStringGetTypeID())) {
    CFTypeRef v5 = 0LL;
  }
  if (a3)
  {
    CFTypeID v7 = CFGetTypeID(a3);
    CFTypeID TypeID = CFDataGetTypeID();
    if (v5)
    {
      if (v7 == TypeID)
      {
        BOOL v9 = *(void **)(a1 + 32);
        id v25 = (id)objc_claimAutoreleasedReturnValue([v9 circleName]);
        id v10 = v9;
        CFDataRef v11 = (void *)objc_claimAutoreleasedReturnValue([v10 SOSTransportMessageGetAccount]);
        sub_100190528(v11);
        CFDataRef v12 = (void *)objc_claimAutoreleasedReturnValue([v11 peerID]);
        uint64_t v13 = (const void *)SOSMessageKeyCreateFromTransportToPeer(v10, v12, v5);

        CFDictionaryRef v22 = sub_1001D5920(v14, v15, v16, v17, v18, v19, v20, v21, (uint64_t)v13, (uint64_t)a3);
        dispatch_queue_global_t global_queue = dispatch_get_global_queue(-2LL, 0LL);
        uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(global_queue);
        SOSCloudKeychainPutObjectsInCloud(v22, v24, &stru_100293E60);

        if (v22) {
          CFRelease(v22);
        }
        if (v13) {
          CFRelease(v13);
        }
      }
    }
  }

uint64_t sub_1001D89B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_1001D89CC(id a1, __CFDictionary *a2, __CFError *a3)
{
  if (a3)
  {
    id v4 = sub_10001267C("SecError");
    CFTypeRef v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 138412290;
      CFTypeID v7 = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Error putting: %@", (uint8_t *)&v6, 0xCu);
    }
  }

void sub_1001D8A78(void *a1, CFTypeRef cf)
{
  if (!cf || (v3 = cf, CFTypeID v4 = CFGetTypeID(cf), v4 != CFStringGetTypeID())) {
    CFTypeRef v3 = 0LL;
  }
  CFTypeRef cfa = 0LL;
  CFTypeRef v5 = (void *)a1[4];
  int v6 = (void *)objc_claimAutoreleasedReturnValue([v5 circleName]);
  unsigned __int8 v7 = [v5 SOSTransportMessageSendMessageIfNeeded:v5 circleName:v6 pID:v3 err:&cfa];
  uint64_t v8 = *(void *)(a1[5] + 8LL);
  if (*(_BYTE *)(v8 + 24)) {
    unsigned __int8 v9 = v7;
  }
  else {
    unsigned __int8 v9 = 0;
  }
  *(_BYTE *)(v8 + 24) = v9;

  if (!*(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL))
  {
    CFDataRef v11 = (void *)a1[6];
    if (v11)
    {
      CFTypeRef v10 = cfa;
      if (*v11 || !cfa) {
        goto LABEL_9;
      }
      *(void *)a1[6] = CFRetain(cfa);
    }
  }

  CFTypeRef v10 = cfa;
LABEL_9:
  if (v10)
  {
    CFTypeRef cfa = 0LL;
    CFRelease(v10);
  }

uint64_t sub_1001D8B5C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_1001D8B70(uint64_t a1, CFTypeRef cf, const void *a3)
{
  if (!cf || (CFTypeID v6 = CFGetTypeID(cf), v7 = cf, v6 != CFStringGetTypeID())) {
    CFTypeRef v7 = 0LL;
  }
  if (a3 && (CFTypeID v8 = CFGetTypeID(a3), v8 == CFDataGetTypeID()))
  {
    CFTypeRef cfa = 0LL;
    if (v7
      && [*(id *)(a1 + 32) SOSTransportMessageHandlePeerMessage:*(void *)(a1 + 32) id:v7 cm:a3 err:&cfa])
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), cf);
      goto LABEL_13;
    }
  }

  else
  {
    CFTypeRef cfa = 0LL;
  }

  unsigned __int8 v9 = sub_10001267C("transport");
  CFTypeRef v10 = (os_log_s *)objc_claimAutoreleasedReturnValue(v9);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 138412546;
    CFTypeRef v14 = v7;
    __int16 v15 = 2112;
    CFTypeRef v16 = cfa;
    _os_log_impl( (void *)&_mh_execute_header,  v10,  OS_LOG_TYPE_DEFAULT,  "%@ KVSTransport handle message failed: %@",  buf,  0x16u);
  }

LABEL_13:
  CFTypeRef v11 = cfa;
  if (cfa)
  {
    CFTypeRef cfa = 0LL;
    CFRelease(v11);
  }

void sub_1001D8CC8(uint64_t a1, CFTypeRef cf, const void *a3)
{
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    CFTypeID TypeID = CFStringGetTypeID();
    if (a3)
    {
      if (v6 == TypeID)
      {
        CFTypeID v8 = CFGetTypeID(a3);
        if (v8 == CFArrayGetTypeID())
        {
          context[0] = _NSConcreteStackBlock;
          context[1] = 3221225472LL;
          uint64_t context[2] = sub_1001D8DA8;
          context[3] = &unk_100293E20;
          CFTypeRef v13 = cf;
          __int128 v10 = *(_OWORD *)(a1 + 32);
          id v9 = (id)v10;
          __int128 v12 = v10;
          v14.CFIndex length = CFArrayGetCount((CFArrayRef)a3);
          v14.id location = 0LL;
          CFArrayApplyFunction((CFArrayRef)a3, v14, (CFArrayApplierFunction)sub_1001D8B5C, context);
        }
      }
    }
  }

void sub_1001D8DA8(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      CFTypeRef v5 = *(const __CFArray **)(a1 + 40);
      if (v5)
      {
        context[0] = _NSConcreteStackBlock;
        context[1] = 3221225472LL;
        uint64_t context[2] = sub_1001D8E68;
        context[3] = &unk_100293E20;
        uint64_t v8 = *(void *)(a1 + 48);
        CFTypeRef v9 = cf;
        id v7 = *(id *)(a1 + 32);
        v10.CFIndex length = CFArrayGetCount(v5);
        v10.id location = 0LL;
        CFArrayApplyFunction(v5, v10, (CFArrayApplierFunction)sub_1001D8B5C, context);
      }
    }
  }

void sub_1001D8E68(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      CFTypeRef v5 = (const void *)SOSMessageKeyCreateWithCircleNameAndPeerNames(*(void *)(a1 + 40), *(void *)(a1 + 48), cf);
      sub_1001D8F08(*(void **)(a1 + 32), v5);
      if (v5) {
        CFRelease(v5);
      }
      CFTypeID v6 = (const void *)SOSMessageKeyCreateWithCircleNameAndPeerNames(*(void *)(a1 + 40), cf, *(void *)(a1 + 48));
      sub_1001D8F08(*(void **)(a1 + 32), v6);
      if (v6) {
        CFRelease(v6);
      }
    }
  }

void sub_1001D8F08(void *a1, const void *a2)
{
  id v3 = a1;
  if (!objc_msgSend(v3, "pending_changes")) {
    objc_msgSend( v3,  "setPending_changes:",  CFDictionaryCreateMutable( kCFAllocatorDefault,  0,  &kCFTypeDictionaryKeyCallBacks,  &kCFTypeDictionaryValueCallBacks));
  }
  CFDictionarySetValue((CFMutableDictionaryRef)objc_msgSend(v3, "pending_changes"), a2, kCFNull);
}

void sub_1001D8F8C(uint64_t a1, uint64_t a2)
{
  uint64_t PeerID = SOSPeerInfoGetPeerID(a2);
  CFTypeID v4 = (const void *)SOSMessageKeyCreateFromPeerToTransport(*(void *)(a1 + 32), *(void *)(a1 + 40), PeerID);
  if (v4)
  {
    CFTypeRef v5 = v4;
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), v4);
    CFRelease(v5);
  }

void sub_1001DA448(uint64_t a1, const void *a2)
{
}

uint64_t sub_1001DA450(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_1001DA464(uint64_t a1, uint64_t a2)
{
  uint64_t PeerInfo = SOSFullPeerInfoGetPeerInfo([*(id *)(a1 + 32) fullPeerInfo]);
  return SOSCircleUpdatePeerInfo(a2, PeerInfo);
}

uint64_t sub_1001DA494(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = sub_10001267C("circleChange");
  CFTypeRef v5 = (os_log_s *)objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v7 = 0;
    _os_log_impl( (void *)&_mh_execute_header,  v5,  OS_LOG_TYPE_DEFAULT,  "Calling SOSCircleUpdatePeerInfo for gestalt change",  v7,  2u);
  }

  return SOSCircleUpdatePeerInfo(a2, [*(id *)(a1 + 32) peerInfo]);
}

id objc_msgSend_SOSTransportKeyParameterKVSAppendKeyInterests_ak_firstUnLock_unlocked_err_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "SOSTransportKeyParameterKVSAppendKeyInterests:ak:firstUnLock:unlocked:err:");
}

id objc_msgSend__onqueueHandleIQEChange_attributes_class_viewState_sortedForThisView_keyCache_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_onqueueHandleIQEChange:attributes:class:viewState:sortedForThisView:keyCache:");
}

id objc_msgSend__onqueueHandleMismatchedViewItem_secDbClass_attributes_intendedView_viewState_keyCache_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_onqueueHandleMismatchedViewItem:secDbClass:attributes:intendedView:viewState:keyCache:");
}

id objc_msgSend_afterAuthKitFetch_userInitiatedRemovals_evictedRemovals_unknownReasonRemovals_trustedDeviceHash_deletedDeviceHash_trustedDevicesUpdateTimestamp_accountIsDemo_version_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "afterAuthKitFetch:userInitiatedRemovals:evictedRemovals:unknownReasonRemovals:trustedDeviceHash:deletedDevice Hash:trustedDevicesUpdateTimestamp:accountIsDemo:version:");
}

id objc_msgSend_aksDecryptWithKeybag_keyclass_ciphertext_outKeyclass_plaintext_personaId_personaIdLength_error_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "aksDecryptWithKeybag:keyclass:ciphertext:outKeyclass:plaintext:personaId:personaIdLength:error:");
}

id objc_msgSend_aksEncryptWithKeybag_keyclass_plaintext_outKeyclass_ciphertext_personaId_personaIdLength_error_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "aksEncryptWithKeybag:keyclass:plaintext:outKeyclass:ciphertext:personaId:personaIdLength:error:");
}

id objc_msgSend_attemptPreapprovedJoinWithSpecificUser_ckksKeys_tlkShares_preapprovedKeys_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "attemptPreapprovedJoinWithSpecificUser:ckksKeys:tlkShares:preapprovedKeys:reply:");
}

id objc_msgSend_circleJoiningBlob_flowID_deviceSessionID_canSendMetrics_applicant_complete_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "circleJoiningBlob:flowID:deviceSessionID:canSendMetrics:applicant:complete:");
}

id objc_msgSend_contextForClientRPCWithActiveAccount_createIfMissing_allowNonPrimaryAccounts_error_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "contextForClientRPCWithActiveAccount:createIfMissing:allowNonPrimaryAccounts:error:");
}

id objc_msgSend_contextForContainerName_contextID_possibleAccount_createIfMissing_sosAdapter_accountsAdapter_authKitAdapter_tooManyPeersAdapter_tapToRadarAdapter_lockStateTracker_deviceInformationAdapter_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "contextForContainerName:contextID:possibleAccount:createIfMissing:sosAdapter:accountsAdapter:authKitAdapter:t ooManyPeersAdapter:tapToRadarAdapter:lockStateTracker:deviceInformationAdapter:");
}

id objc_msgSend_createCustodianRecoveryKeyWithSpecificUser_recoveryKey_salt_ckksKeys_uuid_kind_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "createCustodianRecoveryKeyWithSpecificUser:recoveryKey:salt:ckksKeys:uuid:kind:reply:");
}

id objc_msgSend_deleteFromKeychainForContainer_contextID_personaAdapter_personaUniqueString_error_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "deleteFromKeychainForContainer:contextID:personaAdapter:personaUniqueString:error:");
}

id objc_msgSend_deleteWithAcmContext_accessControl_callerAccessGroups_keyDiversify_error_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "deleteWithAcmContext:accessControl:callerAccessGroups:keyDiversify:error:");
}

id objc_msgSend_encryptCKKSItem_dataDictionary_updatingCKKSItem_parentkey_keyCache_error_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "encryptCKKSItem:dataDictionary:updatingCKKSItem:parentkey:keyCache:error:");
}

id objc_msgSend_fetchCurrentPolicyWithSpecificUser_modelIDOverride_isInheritedAccount_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "fetchCurrentPolicyWithSpecificUser:modelIDOverride:isInheritedAccount:reply:");
}

id objc_msgSend_findAccountForCurrentThread_optionalAltDSID_cloudkitContainerName_octagonContextID_error_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "findAccountForCurrentThread:optionalAltDSID:cloudkitContainerName:octagonContextID:error:");
}

id objc_msgSend_getCurrentItemForAccessGroup_identifier_viewHint_fetchCloudValue_complete_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "getCurrentItemForAccessGroup:identifier:viewHint:fetchCloudValue:complete:");
}

id objc_msgSend_handleRemovedMachineIDsDueToUnknownReasonsWithSpecificUser_machineIDs_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "handleRemovedMachineIDsDueToUnknownReasonsWithSpecificUser:machineIDs:reply:");
}

id objc_msgSend_handleUpdateRing_prospectiveRing_transport_userPublicKey_writeUpdate_err_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "handleUpdateRing:prospectiveRing:transport:userPublicKey:writeUpdate:err:");
}

id objc_msgSend_init_contextID_reason_idmsTargetContext_idmsCuttlefishPassword_notifyIdMS_isGuitarfish_accountType_intendedState_dependencies_errorState_cuttlefishXPCWrapper_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "init:contextID:reason:idmsTargetContext:idmsCuttlefishPassword:notifyIdMS:isGuitarfish:accountType:intendedSt ate:dependencies:errorState:cuttlefishXPCWrapper:");
}

id objc_msgSend_initForContainer_contextID_activeAccount_stateHolder_flagHandler_sosAdapter_octagonAdapter_accountsAdapter_authKitAdapter_personaAdapter_deviceInfoAdapter_ckksAccountSync_lockStateTracker_cuttlefishXPCWrapper_escrowRequestClass_notifierClass_flowID_deviceSessionID_permittedToSendMetrics_reachabilityTracker_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initForContainer:contextID:activeAccount:stateHolder:flagHandler:sosAdapter:octagonAdapter:accountsAdapter:au thKitAdapter:personaAdapter:deviceInfoAdapter:ckksAccountSync:lockStateTracker:cuttlefishXPCWrapper:escrowReq uestClass:notifierClass:flowID:deviceSessionID:permittedToSendMetrics:reachabilityTracker:");
}

id objc_msgSend_initForContainerName_contextID_epoch_machineID_modelID_deviceName_serialNumber_osVersion_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initForContainerName:contextID:epoch:machineID:modelID:deviceName:serialNumber:osVersion:");
}

id objc_msgSend_initForDevice_contextID_osVersion_lastUnlockTime_octagonPeerID_octagonStatus_circlePeerID_circleStatus_keyState_currentTLKUUID_currentClassAUUID_currentClassCUUID_zoneID_encodedCKRecord_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initForDevice:contextID:osVersion:lastUnlockTime:octagonPeerID:octagonStatus:circlePeerID:circleStatus:keySta te:currentTLKUUID:currentClassAUUID:currentClassCUUID:zoneID:encodedCKRecord:");
}

id objc_msgSend_initForIdentifier_contextID_currentItemUUID_state_zoneID_encodedCKRecord_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initForIdentifier:contextID:currentItemUUID:state:zoneID:encodedCKRecord:");
}

id objc_msgSend_initForKey_contextID_senderPeerID_recieverPeerID_receiverEncPublicKeySPKI_curve_version_epoch_poisoned_wrappedKey_signature_zoneID_encodedCKRecord_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initForKey:contextID:senderPeerID:recieverPeerID:receiverEncPublicKeySPKI:curve:version:epoch:poisoned:wrappe dKey:signature:zoneID:encodedCKRecord:");
}

id objc_msgSend_initForKey_senderPeerID_recieverPeerID_receiverEncPublicKeySPKI_curve_version_epoch_poisoned_wrappedKey_signature_zoneID_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initForKey:senderPeerID:recieverPeerID:receiverEncPublicKeySPKI:curve:version:epoch:poisoned:wrappedKey:signature:zoneID:");
}

id objc_msgSend_initSelfWrappedWithAESKey_contextID_uuid_keyclass_state_zoneID_encodedCKRecord_currentkey_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initSelfWrappedWithAESKey:contextID:uuid:keyclass:state:zoneID:encodedCKRecord:currentkey:");
}

id objc_msgSend_initWithCKKSMetrics_altDSID_eventName_testsAreEnabled_category_sendMetric_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithCKKSMetrics:altDSID:eventName:testsAreEnabled:category:sendMetric:");
}

id objc_msgSend_initWithCKKSOperationDependencies_viewState_accessGroup_identifiers_ckoperationGroup_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithCKKSOperationDependencies:viewState:accessGroup:identifiers:ckoperationGroup:");
}

id objc_msgSend_initWithCKKSOperationDependencies_viewState_newItem_hash_accessGroup_identifier_replacing_hash_ckoperationGroup_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithCKKSOperationDependencies:viewState:newItem:hash:accessGroup:identifier:replacing:hash:ckoperationGroup:");
}

id objc_msgSend_initWithCloudkitContainerName_octagonContextID_appleAccountID_altDSID_isPrimaryPersona_personaUniqueString_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithCloudkitContainerName:octagonContextID:appleAccountID:altDSID:isPrimaryPersona:personaUniqueString:");
}

id objc_msgSend_initWithContainer_contextID_activeAccount_accountTracker_lockStateTracker_reachabilityTracker_savedTLKNotifier_cloudKitClassDependencies_personaAdapter_accountsAdapter_cuttlefishAdapter_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithContainer:contextID:activeAccount:accountTracker:lockStateTracker:reachabilityTracker:savedTLKNotifie r:cloudKitClassDependencies:personaAdapter:accountsAdapter:cuttlefishAdapter:");
}

id objc_msgSend_initWithContainer_fetchClass_clientMap_fetchReasons_apnsPushes_forceResync_ckoperationGroup_altDSID_sendMetric_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithContainer:fetchClass:clientMap:fetchReasons:apnsPushes:forceResync:ckoperationGroup:altDSID:sendMetric:");
}

id objc_msgSend_initWithContainer_sosAdapter_accountStateTracker_lockStateTracker_reachabilityTracker_personaAdapter_cloudKitClassDependencies_accountsAdapter_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithContainer:sosAdapter:accountStateTracker:lockStateTracker:reachabilityTracker:personaAdapter:cloudKit ClassDependencies:accountsAdapter:");
}

id objc_msgSend_initWithContainerName_contextID_activeAccount_cuttlefish_ckksAccountSync_sosAdapter_accountsAdapter_authKitAdapter_personaAdapter_tooManyPeersAdapter_tapToRadarAdapter_lockStateTracker_reachabilityTracker_accountStateTracker_deviceInformationAdapter_apsConnectionClass_escrowRequestClass_notifierClass_cdpd_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithContainerName:contextID:activeAccount:cuttlefish:ckksAccountSync:sosAdapter:accountsAdapter:authKitAd apter:personaAdapter:tooManyPeersAdapter:tapToRadarAdapter:lockStateTracker:reachabilityTracker:accountStateT racker:deviceInformationAdapter:apsConnectionClass:escrowRequestClass:notifierClass:cdpd:");
}

id objc_msgSend_initWithContextID_zoneName_zoneCreated_zoneSubscribed_changeToken_moreRecordsInCloudKit_lastFetch_lastScan_lastFixup_encodedRateLimiter_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithContextID:zoneName:zoneCreated:zoneSubscribed:changeToken:moreRecordsInCloudKit:lastFetch:lastScan:la stFixup:encodedRateLimiter:");
}

id objc_msgSend_initWithDependencies_intendedState_ckksConflictState_errorState_deviceInfo_policyOverride_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithDependencies:intendedState:ckksConflictState:errorState:deviceInfo:policyOverride:");
}

id objc_msgSend_initWithDependencies_intendedState_ckksConflictState_peerMissingState_errorState_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithDependencies:intendedState:ckksConflictState:peerMissingState:errorState:");
}

id objc_msgSend_initWithDependencies_intendedState_errorState_accountSettings_accountWide_forceFetch_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithDependencies:intendedState:errorState:accountSettings:accountWide:forceFetch:");
}

id objc_msgSend_initWithDependencies_intendedState_errorState_bottleID_entropy_bottleSalt_saveVoucher_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithDependencies:intendedState:errorState:bottleID:entropy:bottleSalt:saveVoucher:");
}

id objc_msgSend_initWithDependencies_intendedState_errorState_custodianRecoveryKey_saveVoucher_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithDependencies:intendedState:errorState:custodianRecoveryKey:saveVoucher:");
}

id objc_msgSend_initWithDependencies_intendedState_errorState_deviceInfo_peerID_permanentInfo_permanentInfoSig_stableInfo_stableInfoSig_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithDependencies:intendedState:errorState:deviceInfo:peerID:permanentInfo:permanentInfoSig:stableInfo:stableInfoSig:");
}

id objc_msgSend_initWithDependencies_intendedState_errorState_deviceInfo_policyOverride_accountSettings_epoch_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithDependencies:intendedState:errorState:deviceInfo:policyOverride:accountSettings:epoch:");
}

id objc_msgSend_initWithDependencies_intendedState_errorState_deviceInfo_skipRateLimitedCheck_reportRateLimitingError_repair_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithDependencies:intendedState:errorState:deviceInfo:skipRateLimitedCheck:reportRateLimitingError:repair:");
}

id objc_msgSend_initWithDependencies_intendedState_errorState_ik_deviceInfo_policyOverride_isInheritedAccount_epoch_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithDependencies:intendedState:errorState:ik:deviceInfo:policyOverride:isInheritedAccount:epoch:");
}

id objc_msgSend_initWithDependencies_intendedState_listUpdatesState_errorState_retryFlag_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithDependencies:intendedState:listUpdatesState:errorState:retryFlag:");
}

id objc_msgSend_initWithDependencies_intendedState_peerUnknownState_determineCDPState_errorState_forceRefetch_retryFlag_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithDependencies:intendedState:peerUnknownState:determineCDPState:errorState:forceRefetch:retryFlag:");
}

id objc_msgSend_initWithDependencies_intendedViewStatus_intendedState_peerMissingState_errorState_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithDependencies:intendedViewStatus:intendedState:peerMissingState:errorState:");
}

id objc_msgSend_initWithDependencies_intending_pendingClassAItemsRemainingState_errorState_handleMismatchedViewItems_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithDependencies:intending:pendingClassAItemsRemainingState:errorState:handleMismatchedViewItems:");
}

id objc_msgSend_initWithDependencies_rollTLKIfPresent_preexistingPendingKeySets_intendedState_errorState_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithDependencies:rollTLKIfPresent:preexistingPendingKeySets:intendedState:errorState:");
}

id objc_msgSend_initWithDependencies_stateIfCDPCapable_stateIfNotCDPCapable_stateIfNoAccount_errorState_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithDependencies:stateIfCDPCapable:stateIfNotCDPCapable:stateIfNoAccount:errorState:");
}

id objc_msgSend_initWithEngine_peer_localManifest_proposedManifest_confirmedManifest_andMessage_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithEngine:peer:localManifest:proposedManifest:confirmedManifest:andMessage:");
}

id objc_msgSend_initWithFetchRecordZoneChangesOperationClass_fetchRecordsOperationClass_queryOperationClass_modifySubscriptionsOperationClass_modifyRecordZonesOperationClass_apsConnectionClass_nsnotificationCenterClass_nsdistributednotificationCenterClass_notifierClass_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithFetchRecordZoneChangesOperationClass:fetchRecordsOperationClass:queryOperationClass:modifySubscriptio nsOperationClass:modifyRecordZonesOperationClass:apsConnectionClass:nsnotificationCenterClass:nsdistributedno tificationCenterClass:notifierClass:");
}

id objc_msgSend_initWithKeychainCircleMetrics_altDSID_flowID_deviceSessionID_eventName_testsAreEnabled_canSendMetrics_category_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithKeychainCircleMetrics:altDSID:flowID:deviceSessionID:eventName:testsAreEnabled:canSendMetrics:category:");
}

id objc_msgSend_initWithName_initialDelay_continuingDelay_keepProcessAlive_dependencyDescriptionCode_block_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithName:initialDelay:continuingDelay:keepProcessAlive:dependencyDescriptionCode:block:");
}

id objc_msgSend_initWithName_initialDelay_exponentialBackoff_maximumDelay_keepProcessAlive_dependencyDescriptionCode_block_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithName:initialDelay:exponentialBackoff:maximumDelay:keepProcessAlive:dependencyDescriptionCode:block:");
}

id objc_msgSend_initWithName_initialDelay_exponentialBackoff_maximumDelay_keepProcessAlive_dependencyDescriptionCode_qosClass_block_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithName:initialDelay:exponentialBackoff:maximumDelay:keepProcessAlive:dependencyDescriptionCode:qosClass:block:");
}

id objc_msgSend_initWithName_states_flags_initialState_queue_stateEngine_unexpectedStateErrorDomain_lockStateTracker_reachabilityTracker_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithName:states:flags:initialState:queue:stateEngine:unexpectedStateErrorDomain:lockStateTracker:reachabilityTracker:");
}

id objc_msgSend_initWithPeerProviderID_essential_selfPeers_selfPeersError_trustedPeers_trustedPeersError_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithPeerProviderID:essential:selfPeers:selfPeersError:trustedPeers:trustedPeersError:");
}

id objc_msgSend_initWithRecordName_localSettingName_container_database_zoneID_accountTracker_lockStateTracker_reachabilityTracker_fetchRecordRecordsOperationClass_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithRecordName:localSettingName:container:database:zoneID:accountTracker:lockStateTracker:reachabilityTra cker:fetchRecordRecordsOperationClass:");
}

id objc_msgSend_initWithSOSAdapter_accountsAdapter_authKitAdapter_tooManyPeersAdapter_tapToRadarAdapter_deviceInformationAdapter_personaAdapter_apsConnectionClass_escrowRequestClass_notifierClass_loggerClass_lockStateTracker_reachabilityTracker_cloudKitClassDependencies_cuttlefishXPCConnection_cdpd_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithSOSAdapter:accountsAdapter:authKitAdapter:tooManyPeersAdapter:tapToRadarAdapter:deviceInformationAdap ter:personaAdapter:apsConnectionClass:escrowRequestClass:notifierClass:loggerClass:lockStateTracker:reachabil ityTracker:cloudKitClassDependencies:cuttlefishXPCConnection:cdpd:");
}

id objc_msgSend_initWithUUID_parentKeyUUID_contextID_zoneID_encodedCKRecord_encItem_wrappedkey_generationCount_encver_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithUUID:parentKeyUUID:contextID:zoneID:encodedCKRecord:encItem:wrappedkey:generationCount:encver:");
}

id objc_msgSend_initWithUUID_parentKeyUUID_contextID_zoneID_encodedCKRecord_encItem_wrappedkey_generationCount_encver_plaintextPCSServiceIdentifier_plaintextPCSPublicKey_plaintextPCSPublicIdentity_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithUUID:parentKeyUUID:contextID:zoneID:encodedCKRecord:encItem:wrappedkey:generationCount:encver:plainte xtPCSServiceIdentifier:plaintextPCSPublicKey:plaintextPCSPublicIdentity:");
}

id objc_msgSend_initWithViewStates_contextID_activeAccount_ckdatabase_cloudKitClassDependencies_ckoperationGroup_flagHandler_overallLaunch_accountStateTracker_lockStateTracker_reachabilityTracker_peerProviders_databaseProvider_savedTLKNotifier_personaAdapter_sendMetric_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithViewStates:contextID:activeAccount:ckdatabase:cloudKitClassDependencies:ckoperationGroup:flagHandler: overallLaunch:accountStateTracker:lockStateTracker:reachabilityTracker:peerProviders:databaseProvider:savedTL KNotifier:personaAdapter:sendMetric:");
}

id objc_msgSend_initWithWrappedKeyData_contextID_uuid_parentKeyUUID_keyclass_state_zoneID_encodedCKRecord_currentkey_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithWrappedKeyData:contextID:uuid:parentKeyUUID:keyclass:state:zoneID:encodedCKRecord:currentkey:");
}

id objc_msgSend_initWithZoneID_forContextID_ckksManagedView_priorityView_notifyViewChangedScheduler_notifyViewReadyScheduler_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithZoneID:forContextID:ckksManagedView:priorityView:notifyViewChangedScheduler:notifyViewReadyScheduler:");
}

id objc_msgSend_initialSyncCredentials_altDSID_flowID_deviceSessionID_canSendMetrics_complete_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initialSyncCredentials:altDSID:flowID:deviceSessionID:canSendMetrics:complete:");
}

id objc_msgSend_intransactionCreateDeviceStateForView_accountTracker_lockStateTracker_error_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "intransactionCreateDeviceStateForView:accountTracker:lockStateTracker:error:");
}

id objc_msgSend_joinCircleWithBlob_altDSID_flowID_deviceSessionID_canSendMetrics_version_complete_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "joinCircleWithBlob:altDSID:flowID:deviceSessionID:canSendMetrics:version:complete:");
}

id objc_msgSend_joinWithSpecificUser_voucherData_voucherSig_ckksKeys_tlkShares_preapprovedKeys_flowID_deviceSessionID_canSendMetrics_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "joinWithSpecificUser:voucherData:voucherSig:ckksKeys:tlkShares:preapprovedKeys:flowID:deviceSessionID:canSendMetrics:reply:");
}

id objc_msgSend_loadFromKeychainForContainer_contextID_personaAdapter_personaUniqueString_error_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "loadFromKeychainForContainer:contextID:personaAdapter:personaUniqueString:error:");
}

id objc_msgSend_modifyRecordsCompleted_fullUpload_recordsToSave_recordIDsToDelete_recordIDsModified_modifyComplete_savedRecords_deletedRecordIDs_ckerror_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "modifyRecordsCompleted:fullUpload:recordsToSave:recordIDsToDelete:recordIDsModified:modifyComplete:savedRecor ds:deletedRecordIDs:ckerror:");
}

id objc_msgSend_performCKServerUnreadableDataRemovalWithSpecificUser_isGuitarfish_internalAccount_demoAccount_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "performCKServerUnreadableDataRemovalWithSpecificUser:isGuitarfish:internalAccount:demoAccount:reply:");
}

id objc_msgSend_performWithAccountWide_forceFetch_cuttlefishXPCWrapper_activeAccount_containerName_contextID_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "performWithAccountWide:forceFetch:cuttlefishXPCWrapper:activeAccount:containerName:contextID:reply:");
}

id objc_msgSend_prepareInheritancePeerWithSpecificUser_epoch_machineID_bottleSalt_bottleID_modelID_deviceName_serialNumber_osVersion_policyVersion_policySecrets_syncUserControllableViews_secureElementIdentity_signingPrivKeyPersistentRef_encPrivKeyPersistentRef_crk_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "prepareInheritancePeerWithSpecificUser:epoch:machineID:bottleSalt:bottleID:modelID:deviceName:serialNumber:os Version:policyVersion:policySecrets:syncUserControllableViews:secureElementIdentity:signingPrivKeyPersistentR ef:encPrivKeyPersistentRef:crk:reply:");
}

id objc_msgSend_prepareWithSpecificUser_epoch_machineID_bottleSalt_bottleID_modelID_deviceName_serialNumber_osVersion_policyVersion_policySecrets_syncUserControllableViews_secureElementIdentity_setting_signingPrivKeyPersistentRef_encPrivKeyPersistentRef_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "prepareWithSpecificUser:epoch:machineID:bottleSalt:bottleID:modelID:deviceName:serialNumber:osVersion:policyV ersion:policySecrets:syncUserControllableViews:secureElementIdentity:setting:signingPrivKeyPersistentRef:encP rivKeyPersistentRef:reply:");
}

id objc_msgSend_proposeTLKForExternallyManagedView_proposedTLK_wrappedOldTLK_tlkShares_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "proposeTLKForExternallyManagedView:proposedTLK:wrappedOldTLK:tlkShares:reply:");
}

id objc_msgSend_recordRecoveredTLKMetrics_tlkRecoveryResults_uniqueTLKsRecoveredEvent_totalSharesRecoveredEvent_totalRecoverableTLKSharesEvent_totalRecoverableTLKsEvent_totalViewsWithSharesEvent_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "recordRecoveredTLKMetrics:tlkRecoveryResults:uniqueTLKsRecoveredEvent:totalSharesRecoveredEvent:totalRecovera bleTLKSharesEvent:totalRecoverableTLKsEvent:totalViewsWithSharesEvent:");
}

id objc_msgSend_requestHealthCheckWithSpecificUser_requiresEscrowCheck_repair_knownFederations_flowID_deviceSessionID_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "requestHealthCheckWithSpecificUser:requiresEscrowCheck:repair:knownFederations:flowID:deviceSessionID:reply:");
}

id objc_msgSend_resetAccountCDPContentsWithSpecificUser_idmsTargetContext_idmsCuttlefishPassword_notifyIdMS_internalAccount_demoAccount_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "resetAccountCDPContentsWithSpecificUser:idmsTargetContext:idmsCuttlefishPassword:notifyIdMS:internalAccount:d emoAccount:reply:");
}

id objc_msgSend_resetAndEstablish_resetReason_idmsTargetContext_idmsCuttlefishPassword_notifyIdMS_accountSettings_isGuitarfish_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "resetAndEstablish:resetReason:idmsTargetContext:idmsCuttlefishPassword:notifyIdMS:accountSettings:isGuitarfish:reply:");
}

id objc_msgSend_resetWithSpecificUser_resetReason_idmsTargetContext_idmsCuttlefishPassword_notifyIdMS_internalAccount_demoAccount_isGuitarfish_accountType_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "resetWithSpecificUser:resetReason:idmsTargetContext:idmsCuttlefishPassword:notifyIdMS:internalAccount:demoAcc ount:isGuitarfish:accountType:reply:");
}

id objc_msgSend_rpcResetAccountCDPContentsWithIdmsTargetContext_idmsCuttlefishPassword_notifyIdMS_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "rpcResetAccountCDPContentsWithIdmsTargetContext:idmsCuttlefishPassword:notifyIdMS:reply:");
}

id objc_msgSend_rpcResetAndEstablish_idmsTargetContext_idmsCuttlefishPassword_notifyIdMS_accountSettings_isGuitarfish_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "rpcResetAndEstablish:idmsTargetContext:idmsCuttlefishPassword:notifyIdMS:accountSettings:isGuitarfish:reply:");
}

id objc_msgSend_rpcVoucherWithConfiguration_permanentInfo_permanentInfoSig_stableInfo_stableInfoSig_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "rpcVoucherWithConfiguration:permanentInfo:permanentInfoSig:stableInfo:stableInfoSig:reply:");
}

id objc_msgSend_saveToKeychainForContainer_contextID_personaAdapter_personaUniqueString_error_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "saveToKeychainForContainer:contextID:personaAdapter:personaUniqueString:error:");
}

id objc_msgSend_secretAttributesWithAcmContext_accessControl_callerAccessGroups_keyDiversify_error_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "secretAttributesWithAcmContext:accessControl:callerAccessGroups:keyDiversify:error:");
}

id objc_msgSend_setAllowedMachineIDsWithSpecificUser_allowedMachineIDs_userInitiatedRemovals_evictedRemovals_unknownReasonRemovals_honorIDMSListChanges_version_flowID_deviceSessionID_canSendMetrics_altDSID_trustedDeviceHash_deletedDeviceHash_trustedDevicesUpdateTimestamp_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "setAllowedMachineIDsWithSpecificUser:allowedMachineIDs:userInitiatedRemovals:evictedRemovals:unknownReasonRem ovals:honorIDMSListChanges:version:flowID:deviceSessionID:canSendMetrics:altDSID:trustedDeviceHash:deletedDev iceHash:trustedDevicesUpdateTimestamp:reply:");
}

id objc_msgSend_setCurrentItemForAccessGroup_hash_accessGroup_identifier_viewHint_replacing_hash_complete_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setCurrentItemForAccessGroup:hash:accessGroup:identifier:viewHint:replacing:hash:complete:");
}

id objc_msgSend_stashAccountCredential_altDSID_flowID_deviceSessionID_canSendMetrics_complete_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stashAccountCredential:altDSID:flowID:deviceSessionID:canSendMetrics:complete:");
}

id objc_msgSend_tlkMaterialPresentOrRecoverableViaTLKShareForContextID_forTrustStates_error_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "tlkMaterialPresentOrRecoverableViaTLKShareForContextID:forTrustStates:error:");
}

id objc_msgSend_unwrapFromAKS_accessControl_acmContext_callerAccessGroups_delete_keyDiversify_error_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "unwrapFromAKS:accessControl:acmContext:callerAccessGroups:delete:keyDiversify:error:");
}

id objc_msgSend_updateWithSpecificUser_forceRefetch_deviceName_serialNumber_osVersion_policyVersion_policySecrets_syncUserControllableViews_secureElementIdentity_walrusSetting_webAccess_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "updateWithSpecificUser:forceRefetch:deviceName:serialNumber:osVersion:policyVersion:policySecrets:syncUserCon trollableViews:secureElementIdentity:walrusSetting:webAccess:reply:");
}

id objc_msgSend_validatedStashedAccountCredential_flowID_deviceSessionID_canSendMetrics_complete_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "validatedStashedAccountCredential:flowID:deviceSessionID:canSendMetrics:complete:");
}

id objc_msgSend_vouchWithBottleWithSpecificUser_bottleID_entropy_bottleSalt_tlkShares_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "vouchWithBottleWithSpecificUser:bottleID:entropy:bottleSalt:tlkShares:reply:");
}

id objc_msgSend_vouchWithSpecificUser_peerID_permanentInfo_permanentInfoSig_stableInfo_stableInfoSig_ckksKeys_flowID_deviceSessionID_canSendMetrics_reply_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "vouchWithSpecificUser:peerID:permanentInfo:permanentInfoSig:stableInfo:stableInfoSig:ckksKeys:flowID:deviceSe ssionID:canSendMetrics:reply:");
}

id objc_msgSend_waitUntilReadyForRPCForOperation_fast_errorOnNoCloudKitAccount_errorOnPolicyMissing_error_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "waitUntilReadyForRPCForOperation:fast:errorOnNoCloudKitAccount:errorOnPolicyMissing:error:");
}

id objc_msgSend_zonesTimedOutWithoutKeysets(void *a1, const char *a2, ...)
{
  return [a1 zonesTimedOutWithoutKeysets];
}