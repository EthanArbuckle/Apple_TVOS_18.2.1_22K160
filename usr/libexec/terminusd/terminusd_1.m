LABEL_590:
        v617 = _os_log_pack_size(22LL);
        v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        v618 = __error();
        v619 = _os_log_pack_fill( v399,  v617,  *v618,  &_mh_execute_header,  "%{public}s strict_malloc(%zu) failed");
        *(_DWORD *)v619 = 136446466;
        *(void *)(v619 + 4) = "strict_malloc";
        *(_WORD *)(v619 + 12) = 2048;
        *(void *)(v619 + 14) = v653;
        goto LABEL_485;
      }

      if (!v184)
      {
LABEL_506:
        v455 = sub_100070554();
        v456 = _NRLogIsLevelEnabled(v455, 16LL);

        if (v456)
        {
          v457 = sub_100070554();
          _NRLogWithArgs( v457,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 0",  "",  "nrWriteIOVecToBuffer",  313);
        }

        v458 = _os_log_pack_size(12LL);
        v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        v459 = __error();
        v410 = _os_log_pack_fill( v399,  v458,  *v459,  &_mh_execute_header,  "%{public}s Assertion Failed: numIOVecs > 0");
        *(_DWORD *)v410 = 136446210;
        v413 = "nrWriteIOVecToBuffer";
        goto LABEL_484;
      }

      v211 = v210;
      v212 = 0LL;
      v213 = 0LL;
      v214 = (unsigned __int16)v654;
      v215 = 16LL * v184;
      v216 = 3;
      while (2)
      {
        v217 = *(_DWORD *)((char *)&v675 + v212 + 8);
        if (!v216) {
          break;
        }
        if (v216 > v217)
        {
          v216 -= v217;
          goto LABEL_274;
        }

        if (v216 >= v217)
        {
          v216 = 0;
LABEL_274:
          v212 += 16LL;
          if (v215 == v212) {
            goto LABEL_340;
          }
          continue;
        }

        break;
      }

      v218 = v217 - v216;
      else {
        v219 = v218;
      }
      memcpy(&v211[v213], (const void *)(*(void *)((char *)&v675 + v212) + v216), v219);
      v213 = (v219 + v213);
      if (v213 < v214)
      {
        v216 = 0;
        v17 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
        goto LABEL_274;
      }

      v17 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
LABEL_340:
      v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      if ((_DWORD)v213 == (_DWORD)v214)
      {
        v252 = objc_alloc(&OBJC_CLASS___NSData);
        v253 = -[NSData initWithBytesNoCopy:length:freeWhenDone:]( v252,  "initWithBytesNoCopy:length:freeWhenDone:",  v211,  v653,  1LL);
        goto LABEL_342;
      }

      v599 = sub_100070554();
      v600 = _NRLogIsLevelEnabled(v599, 16LL);

      if (v600)
      {
        v601 = sub_100070554();
        v602 = (void *)createIOVecString(&v675, (unsigned __int16)v651);
        _NRLogWithArgs( v601,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@",
          "",
          "nrWriteIOVecToBuffer",
          342LL,
          v213,
          v214,
          3LL,
          v602);
      }

LABEL_593:
      v624 = _os_log_pack_size(40LL);
      v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      v625 = __error();
      v626 = _os_log_pack_fill( v399,  v624,  *v625,  &_mh_execute_header,  "%{public}s Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@");
      v627 = (id)createIOVecString(&v675, (unsigned __int16)v651);
      sub_1000431C4(v626, (uint64_t)"nrWriteIOVecToBuffer", v213, v214, 3, (uint64_t)v627);

LABEL_485:
      v414 = sub_100070554();
      _NRLogAbortWithPack(v414, v399);
LABEL_486:
      v653 = v73;
      v654 = v49;
LABEL_487:
      v8 = (void *)createIOVecStringWithContents(&v675, 16LL);
      sub_1000749CC( (void *)v3,  @"LtN not enough ioVecs %@ for %u",  v415,  v416,  v417,  v418,  v419,  v420,  (uint64_t)v8);
LABEL_462:

LABEL_463:
      return;
    case 5u:
      if (v184 == 1 && DWORD2(v675) >= 5 && !HIWORD(DWORD2(v675)))
      {
        sub_10008BFD0((void *)v3, (unsigned __int8 *)(v675 + 3), (unsigned __int16)(WORD4(v675) - 5));
        goto LABEL_308;
      }

      if (!v653)
      {
        v609 = sub_100070554();
        v610 = _NRLogIsLevelEnabled(v609, 16LL);

        if (v610)
        {
          v611 = sub_100070554();
          _NRLogWithArgs(v611, 16LL, "%s%.30s:%-4d ABORTING: strict_malloc called with size 0", "", "strict_malloc", 74);
        }

        v612 = _os_log_pack_size(12LL);
        v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        v613 = __error();
        v410 = _os_log_pack_fill( v399,  v612,  *v613,  &_mh_execute_header,  "%{public}s strict_malloc called with size 0");
        *(_DWORD *)v410 = 136446210;
        v413 = "strict_malloc";
        goto LABEL_484;
      }

      v243 = (unsigned __int8 *)malloc(v653);
      if (!v243)
      {
        v614 = sub_100070554();
        v615 = _NRLogIsLevelEnabled(v614, 16LL);

        if (v615)
        {
          v616 = sub_100070554();
          _NRLogWithArgs(v616, 16LL, "%s%.30s:%-4d ABORTING: strict_malloc(%zu) failed", "", "strict_malloc", 79, v653);
        }

        goto LABEL_590;
      }

      v244 = v243;
      v214 = (unsigned __int16)v654;
      if (!(_WORD)v654)
      {

        goto LABEL_338;
      }

      v656 = (unint64_t)&v636;
      if (!v184) {
        goto LABEL_506;
      }
      v245 = 0LL;
      v213 = 0LL;
      v246 = 16LL * v184;
      v247 = 3;
      v248 = v654;
      while (2)
      {
        v249 = *(_DWORD *)((char *)&v675 + v245 + 8);
        if (!v247) {
          goto LABEL_331;
        }
        if (v247 > v249)
        {
          v247 -= v249;
          goto LABEL_327;
        }

        if (v247 >= v249) {
          goto LABEL_335;
        }
LABEL_331:
        v250 = v249 - v247;
        else {
          v251 = v250;
        }
        memcpy(&v244[v213], (const void *)(*(void *)((char *)&v675 + v245) + v247), v251);
        v213 = (v251 + v213);
        if (v213 < v214)
        {
LABEL_335:
          v247 = 0;
LABEL_327:
          v245 += 16LL;
          if (v246 == v245) {
            break;
          }
          continue;
        }

        break;
      }

      if ((_DWORD)v213 != (_DWORD)v214)
      {
        v620 = sub_100070554();
        v621 = _NRLogIsLevelEnabled(v620, 16LL);

        if (v621)
        {
          v622 = sub_100070554();
          v623 = (void *)createIOVecString(&v675, (unsigned __int16)v651);
          _NRLogWithArgs( v622,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@",
            "",
            "nrWriteIOVecToBuffer",
            342LL,
            v213,
            v214,
            3LL,
            v623);
        }

        goto LABEL_593;
      }

      sub_10008BFD0((void *)v3, v244, v248);
      v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      v17 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
LABEL_338:
      free(v244);
      v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      v189 = v655;
LABEL_308:
      *(void *)(v3 + v189) |= 0x40000000uLL;
      if (*(void *)(v3 + 1887))
      {
        if (*(void *)(v3 + 1895))
        {
          *(_BYTE *)(v3 + 253) %= *(_BYTE *)(v3 + 252);
          v237 = *(void *)(v3 + 1895);
          v238 = (void *)(v237 + 8LL * *(unsigned __int8 *)(v3 + 253));
          if ((unint64_t)(v238 + 1) <= v237 + 8 * (unint64_t)*(unsigned __int8 *)(v3 + 252))
          {
            v19 = v647;
            if ((v238 & 7) == 0)
            {
              *v238 = *(void *)(v3 + 1887);
              v19 = v647;
              ++*(_BYTE *)(v3 + 253);
              *(void *)(v3 + 1887) = 0LL;
            }
          }

          else
          {
            v239 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
            v240 = _NRLogIsLevelEnabled(v239, 17LL);

            if (v240)
            {
              v241 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              v242 = [(id)v3 copyDescription];
              _NRLogWithArgs( v241,  17LL,  "%@: invalid index for link log list (curIdx: %u)",  v242,  *(unsigned __int8 *)(v3 + 253));
            }

            v19 = v647;
          }
        }

        else
        {
          v19 = v647;
        }
      }

      else
      {
        v19 = v647;
      }

      goto LABEL_15;
    case 0x64u:
      v190 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_ESP;
      goto LABEL_294;
    case 0x65u:
      v190 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_ESP_ECT0;
      goto LABEL_294;
    case 0x66u:
      v190 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_TCP;
      goto LABEL_294;
    case 0x67u:
      v190 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_TCP_ECT0;
      goto LABEL_294;
    case 0x68u:
      v190 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_ESP_ClassC;
      goto LABEL_294;
    case 0x69u:
      v190 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_ESP_ClassC_ECT0;
LABEL_294:
      ++*(void *)(v3 + *v190);
      v220 = nrTLVToPacket(&v675, v184, v649, (unsigned __int16)v654, v660, WORD1(v659), v3 + 1967, v3 + 1951);
      if ((_DWORD)v220)
      {
        v222 = v220;
        *(void *)(v3 + v189) |= 0x8000000uLL;
        WORD1(v659) = v220;
        if (gNRPacketLoggingEnabled)
        {
          ESPSequenceNumberFromPacket = getESPSequenceNumberFromPacket(v660, v220);
          if (gNRPacketLoggingEnabled)
          {
            getESPSPIFromPacket(v660, WORD1(v659));
            if (gNRPacketLoggingEnabled)
            {
              v266 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v265);
              v267 = _NRLogIsLevelEnabled(v266, 1LL);

              if (v267)
              {
                v269 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v268);
                v270 = [(id)v3 copyDescription];
                _NRLogWithArgs( v269,  1LL,  "%s%.30s:%-4d %@: UrgentLink:Received ESP sequence number: %u",  "",  "NRLinkLinkToNexusLoopUrgent",  4947LL,  v270,  ESPSequenceNumberFromPacket);
              }

              v17 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            }
          }
        }

        else
        {
          ESPSequenceNumberFromPacket = 0LL;
        }

        v224 = os_channel_slot_get_packet(*(void *)(v3 + 687), v188);
        if ((v650 & 1) != 0)
        {
          v225 = v637;
          *(void *)(v637 + 7) = 0LL;
          *v225 = 0LL;
          v673 = 1;
          if (v224)
          {
            os_packet_set_flow_uuid(v224, &v673);
            *(void *)(v3 + v189) |= 0x10000000uLL;
            if (gNRPacketLoggingEnabled)
            {
              v276 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v226);
              v277 = _NRLogIsLevelEnabled(v276, 1LL);

              if (v277)
              {
                v279 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v278);
                v280 = [(id)v3 copyDescription];
                _NRLogWithArgs( v279,  1LL,  "%s%.30s:%-4d %@: UrgentLink:Set waking metadata for packet w/ ESP sequence number: %u",  "",  "NRLinkLinkToNexusLoopUrgent",  4955LL,  v280,  ESPSequenceNumberFromPacket);
              }
            }
          }

          v227 = v660;
          v228 = WORD1(v659);
          v229 = getESPSequenceNumberFromPacket(v660, WORD1(v659));
          ESPSPIFromPacket = getESPSPIFromPacket(v227, v228);
          if (qword_1001DC9E8 != -1) {
            dispatch_once(&qword_1001DC9E8, &stru_1001AFB78);
          }
          v231 = (dispatch_queue_s *)(id)qword_1001DC9E0;
          v668 = _NSConcreteStackBlock;
          v669 = 3221225472LL;
          v670 = sub_10008BBD0;
          v671 = &unk_1001B0578;
          v672 = __PAIR64__(v229, ESPSPIFromPacket);
          dispatch_async(v231, &v668);

          v17 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
        }

        else if (v224)
        {
          os_packet_clear_flow_uuid();
        }

        os_channel_set_slot_properties(*(void *)(v3 + 687), v188, &v659);
        LODWORD(v650) = 0;
        ++*(void *)(v3 + 783);
        *(void *)(v3 + 799) += v222;
        v639 += v222;
        ++v640;
        *(void *)&v646 = v188;
      }

      else
      {
        v232 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v221);
        v233 = _NRLogIsLevelEnabled(v232, 17LL);

        if (v233)
        {
          v234 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
          v235 = [(id)v3 copyDescription];
          v236 = (void *)createStringFromNRTLVType(v649);
          _NRLogWithArgs( v234,  17LL,  "%@: failed to reinject %@ tlvLen=%u slotLen=%u",  v235,  v236,  (unsigned __int16)v654,  WORD1(v659));
        }
      }

      goto LABEL_308;
    default:
      goto LABEL_308;
  }

double sub_10008BB5C(uint64_t a1, uint64_t a2, int a3, int a4, int a5)
{
  *(void *)&double result = 136446978LL;
  *(_DWORD *)a1 = 136446978;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 1024;
  *(_DWORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 18) = 1024;
  *(_DWORD *)(a1 + 20) = a4;
  *(_WORD *)(a1 + 24) = 1024;
  *(_DWORD *)(a1 + 26) = a5;
  return result;
}

double sub_10008BB8C(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, int a6, int a7)
{
  *(void *)&double result = 136447490LL;
  *(_DWORD *)a1 = 136447490;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 1024;
  *(_DWORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 18) = 1024;
  *(_DWORD *)(a1 + 20) = a4;
  *(_WORD *)(a1 + 24) = 2112;
  *(void *)(a1 + 26) = a5;
  *(_WORD *)(a1 + 34) = 1024;
  *(_DWORD *)(a1 + 36) = a6;
  *(_WORD *)(a1 + 40) = 1024;
  *(_DWORD *)(a1 + 42) = a7;
  return result;
}

void sub_10008BBD0(uint64_t a1)
{
  v4 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  v2 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a1 + 32)));
  -[NSMutableDictionary setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", v2, @"Packet SPI");

  v3 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *(unsigned int *)(a1 + 36)));
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v4,  "setObject:forKeyedSubscript:",  v3,  @"Packet sequence number");

  sub_100101A04(@"NetworkRelay waking packet", v4);
}

void sub_10008BC7C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    v33 = v3;
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 1655);
      IKEv2PacketString = (void *)createIKEv2PacketString();
      [(id)a1 reportEvent:3007, @"Receiving IKEv2 packet #%llu %@ len %llu", v4, IKEv2PacketString, objc_msgSend(v33, "length") detailsFormat];

      ++*(void *)(a1 + 1655);
      v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v6);
      LODWORD(v4) = _NRLogIsLevelEnabled(v7, 1LL);

      if ((_DWORD)v4)
      {
        v32 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v8);
        id v9 = [(id)a1 copyDescription];
        uint64_t v30 = *(void *)(a1 + 1655);
        v31 = v9;
        id v29 = [v33 length];
        id v10 = v33;
        unsigned int v11 = [v10 length];
        v12 = (unsigned __int8 *)[v10 bytes];
        v13 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
        if (v11)
        {
          uint64_t v14 = 0LL;
          do
          {
            -[NSMutableString appendFormat:](v13, "appendFormat:", @"%02X", v12[v14]);
            if ((~(_DWORD)v14 & 0xF) == 0 || (~(_DWORD)v14 & 3) == 0) {
              -[NSMutableString appendString:](v13, "appendString:");
            }
            ++v14;
          }

          while (v11 != v14);
        }

        _NRLogWithArgs( v32,  1LL,  "%s%.30s:%-4d %@: IKE #%llu RECEIVING dataLen=%u data=[\n%@]",  "",  "-[NRLinkBluetooth handleIncomingIKEData:]",  7254LL,  v31,  v30,  v29,  v13);
      }

      uint64_t v15 = *(void *)(a1 + 1255);
      uint64_t v16 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v8);
      v17 = (void *)v16;
      if (v15)
      {
        int IsLevelEnabled = _NRLogIsLevelEnabled(v16, 1LL);

        if (IsLevelEnabled)
        {
          v20 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v19);
          id v21 = [(id)a1 copyDescription];
          _NRLogWithArgs( v20,  1,  "%s%.30s:%-4d %@: handling uIKE packet of %llu bytes",  "",  "-[NRLinkBluetooth handleIncomingIKEData:]",  7261,  v21,  [v33 length]);
        }

        [*(id *)(a1 + 1255) receivePacketData:v33];
      }

      else
      {
        int v22 = _NRLogIsLevelEnabled(v16, 16LL);

        if (v22)
        {
          v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v23);
          id v25 = [(id)a1 copyDescription];
          _NRLogWithArgs( v24,  16LL,  "%s%.30s:%-4d %@: not ready to handle IKE yet",  "",  "-[NRLinkBluetooth handleIncomingIKEData:]",  7257LL,  v25);
        }

        [*(id *)(a1 + 1199) addObject:v33];
      }
    }

    else
    {
      id v26 = sub_100070554();
      int v27 = _NRLogIsLevelEnabled(v26, 17LL);

      id v3 = 0LL;
      if (!v27) {
        goto LABEL_20;
      }
      id v28 = sub_100070554();
      _NRLogWithArgs(v28, 17LL, "%s called with null data", "-[NRLinkBluetooth handleIncomingIKEData:]");
    }

    id v3 = v33;
  }

void sub_10008BFD0(void *a1, unsigned __int8 *a2, unsigned int a3)
{
  v5 = a1;
  if (a2 && a3)
  {
    uint64_t v7 = *a2;
    id v21 = v5;
    if ((_DWORD)v7 == 2)
    {
      uint64_t v9 = mach_absolute_time();
      if (a3 < 9) {
        unint64_t v10 = 0LL;
      }
      else {
        unint64_t v10 = *(void *)(a2 + 1);
      }
      uint64_t v16 = (void *)_NRCopyLogObjectForNRUUID(v21[4], v8);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v16, 1LL);

      if (IsLevelEnabled)
      {
        uint64_t v19 = (void *)_NRCopyLogObjectForNRUUID(v21[4], v18);
        id v20 = [v21 copyDescription];
        _NRLogWithArgs( v19,  1LL,  "%s%.30s:%-4d %@: Received pong seq %llu",  "",  "NRLBTHandleIncomingControlMessage",  2905LL,  v20,  v10);
      }

      sub_10008C564((uint64_t)v21, bswap64(v10), v9);
      goto LABEL_14;
    }

    if ((_DWORD)v7 == 1)
    {
      *a2 = 2;
      sub_10008C174(v5, a2, a3, 0);
LABEL_14:
      v5 = v21;
      goto LABEL_15;
    }

    unsigned int v11 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v6);
    int v12 = _NRLogIsLevelEnabled(v11, 16LL);

    v5 = v21;
    if (v12)
    {
      uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(v21[4], v13);
      id v15 = [v21 copyDescription];
      _NRLogWithArgs( v14,  16LL,  "%s%.30s:%-4d %@: Received unknown message type %u",  "",  "NRLBTHandleIncomingControlMessage",  2911LL,  v15,  v7);

      goto LABEL_14;
    }
  }

uint64_t sub_10008C174(void *a1, const void *a2, unsigned int a3, int a4)
{
  uint64_t v7 = a1;
  uint64_t v9 = (char *)v7;
  if (!a2)
  {
    id v32 = sub_100070554();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v32, 17LL);

    if (IsLevelEnabled)
    {
      id v17 = sub_100070554();
      _NRLogWithArgs(v17, 17LL, "%s called with null messageData", "NRLBTSendControlMessage");
      goto LABEL_20;
    }

    goto LABEL_31;
  }

  if (*((unsigned __int8 *)v7 + 16) == 255)
  {
    uint64_t v19 = (void *)_NRCopyLogObjectForNRUUID(v7[4], v8);
    int v20 = _NRLogIsLevelEnabled(v19, 16LL);

    if (v20)
    {
      id v17 = (id)_NRCopyLogObjectForNRUUID(*((void *)v9 + 4), v21);
      id v18 = [v9 copyDescription];
      _NRLogWithArgs( v17,  16LL,  "%s%.30s:%-4d %@: NRLBTSendControlMessage but cancelled",  "",  "NRLBTSendControlMessage",  2824LL,  v18);
      goto LABEL_19;
    }

void sub_10008C564(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    if (qword_1001DC830 != -1) {
      dispatch_once(&qword_1001DC830, &stru_1001AEB68);
    }
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    id v6 = objc_msgSend(*(id *)(a1 + 1207), "copy", 0);
    id v7 = [v6 countByEnumeratingWithState:&v16 objects:v20 count:16];
    if (v7)
    {
      id v8 = v7;
      uint64_t v9 = *(void *)v17;
      do
      {
        for (i = 0LL; i != v8; i = (char *)i + 1)
        {
          if (*(void *)v17 != v9) {
            objc_enumerationMutation(v6);
          }
          unsigned int v13 = *(void **)(*((void *)&v16 + 1) + 8LL * (void)i);
          if (v13)
          {
            if (v13[2] == a2)
            {
              uint64_t v14 = v13[1];
              if (v14)
              {
                if (a3) {
                  unint64_t v11 = (a3 - v13[3])
                }
                      * (unint64_t)dword_1001DC828
                      / *(unsigned int *)algn_1001DC82C;
                else {
                  unint64_t v11 = 0LL;
                }
                (*(void (**)(uint64_t, unint64_t))(v14 + 16))(v14, v11);
                objc_setProperty_nonatomic_copy(v13, v12, 0LL, 8LL);
              }

void sub_10008C730(id a1)
{
}

void sub_10008C73C(uint64_t a1, void *__src, size_t __n, uint64_t a4)
{
  if (gNRPacketLoggingEnabled)
  {
    uint64_t v10 = objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
    unint64_t v11 = *(void **)(a1 + 1679);
    *(void *)(a1 + 1679) = v10;

    if (!__src) {
      goto LABEL_13;
    }
  }

  else if (!__src)
  {
    goto LABEL_13;
  }

  if (__n)
  {
    if ((_DWORD)a4)
    {
      *(void *)(a1 + 1407) += __n;
      if (!gNRPacketLoggingEnabled)
      {
        id v8 = &OBJC_IVAR___NRLinkBluetooth__filledInUrgentLinkReadBufferBytes;
LABEL_7:
        uint64_t v9 = &OBJC_IVAR___NRLinkBluetooth__urgentLinkReadBuffer;
LABEL_11:
        memcpy((void *)(*(void *)(a1 + *v9) + *(unsigned int *)(a1 + *v8)), __src, __n);
        *(_DWORD *)(a1 + *v8) += __n;
        sub_10008CA34(a1, a4);
        return;
      }

      __int128 v19 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), __src);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v19, 1LL);

      id v8 = &OBJC_IVAR___NRLinkBluetooth__filledInUrgentLinkReadBufferBytes;
      if (!IsLevelEnabled) {
        goto LABEL_7;
      }
      int v22 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v21);
      id v23 = [(id)a1 copyDescription];
      _NRLogWithArgs( v22,  1LL,  "%s%.30s:%-4d %@: filling in urgentLinkReadBuffer by %u from %u to %u (handled %u)",  "",  "-[NRLinkBluetooth readIncomingData:length:isUrgentLink:]",  6911LL,  v23,  __n,  *(unsigned int *)(a1 + 319),  (*(_DWORD *)(a1 + 319) + __n),  *(unsigned int *)(a1 + 323));
      uint64_t v9 = &OBJC_IVAR___NRLinkBluetooth__urgentLinkReadBuffer;
LABEL_22:

      goto LABEL_11;
    }

    *(void *)(a1 + 1375) += __n;
    if (gNRPacketLoggingEnabled)
    {
      uint64_t v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), __src);
      int v25 = _NRLogIsLevelEnabled(v24, 1LL);

      id v8 = &OBJC_IVAR___NRLinkBluetooth__filledInLinkReadBufferBytes;
      if (v25)
      {
        int v22 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v26);
        id v23 = [(id)a1 copyDescription];
        _NRLogWithArgs( v22,  1LL,  "%s%.30s:%-4d %@: filling in linkReadBuffer by %u from %u to %u (handled %u)",  "",  "-[NRLinkBluetooth readIncomingData:length:isUrgentLink:]",  6920LL,  v23,  __n,  *(unsigned int *)(a1 + 311),  (*(_DWORD *)(a1 + 311) + __n),  *(unsigned int *)(a1 + 315));
        uint64_t v9 = &OBJC_IVAR___NRLinkBluetooth__linkReadBuffer;
        goto LABEL_22;
      }
    }

    else
    {
      id v8 = &OBJC_IVAR___NRLinkBluetooth__filledInLinkReadBufferBytes;
    }

    uint64_t v9 = &OBJC_IVAR___NRLinkBluetooth__linkReadBuffer;
    goto LABEL_11;
  }

void sub_10008CA34(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  v5 = &OBJC_IVAR___NRLinkBluetooth__filledInUrgentLinkReadBufferBytes;
  if (!(_DWORD)a2) {
    v5 = &OBJC_IVAR___NRLinkBluetooth__filledInLinkReadBufferBytes;
  }
  id v6 = &OBJC_IVAR___NRLinkBluetooth__handledUrgentLinkReadBufferBytes;
  if (!(_DWORD)a2) {
    id v6 = &OBJC_IVAR___NRLinkBluetooth__handledLinkReadBufferBytes;
  }
  id v7 = &OBJC_IVAR___NRLinkBluetooth__linkReadBuffer;
  if ((_DWORD)a2) {
    id v7 = &OBJC_IVAR___NRLinkBluetooth__urgentLinkReadBuffer;
  }
  unint64_t v8 = *v6;
  id v9 = (id)*v5;
  if (*(_DWORD *)(a1 + v8) > *(_DWORD *)((char *)v9 + a1))
  {
    id v208 = sub_100070554();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v208, 16LL);

    if (IsLevelEnabled)
    {
      id v210 = sub_100070554();
      _NRLogWithArgs( v210,  16LL,  "%s%.30s:%-4d ABORTING: handledLinkReadBufferBytes=%u > filledInLinkReadBufferBytes=%u",  "",  "-[NRLinkBluetooth handleReadData:]",  6448,  *(_DWORD *)(v4 + v8),  *(_DWORD *)((char *)v9 + v4));
    }

    uint64_t v10 = _os_log_pack_size(24LL);
    v211 = (char *)&v273 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    v212 = __error();
    uint64_t v213 = _os_log_pack_fill( v211,  v10,  *v212,  &_mh_execute_header,  "%{public}s handledLinkReadBufferBytes=%u > filledInLinkReadBufferBytes=%u");
    int v214 = *(_DWORD *)(v4 + v8);
    int v215 = *(_DWORD *)((char *)v9 + v4);
    *(_DWORD *)uint64_t v213 = 136446722;
    *(void *)(v213 + 4) = "-[NRLinkBluetooth handleReadData:]";
    *(_WORD *)(v213 + 12) = 1024;
    *(_DWORD *)(v213 + 14) = v214;
    *(_WORD *)(v213 + 18) = 1024;
    *(_DWORD *)(v213 + 20) = v215;
LABEL_252:
    id v216 = sub_100070554();
    _NRLogAbortWithPack(v216, v211);
  }

  else
  {
    LODWORD(v10) = a2;
    v2 = *(char **)(a1 + *v7);
    id v3 = &gNRPacketLoggingEnabled;
    if (!gNRPacketLoggingEnabled) {
      goto LABEL_9;
    }
  }

  v217 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), a2);
  int v218 = _NRLogIsLevelEnabled(v217, 1LL);

  if (v218)
  {
    v219 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), a2);
    id v220 = [(id)v4 copyDescription];
    _NRLogWithArgs( v219,  1LL,  "%s%.30s:%-4d %@: handling %u bytes (handled %u)",  "",  "-[NRLinkBluetooth handleReadData:]",  6450LL,  v220,  *(unsigned int *)((char *)v9 + v4),  *(unsigned int *)(v4 + v8));
  }

LABEL_247:
        return;
      }

      if (*(_BYTE *)v134 == 4) {
        break;
      }
LABEL_142:
      v134 += (v136 + 3);
LABEL_143:
      if (v134 >= v8) {
        goto LABEL_230;
      }
    }

    if (v135 != 4096)
    {
      v154 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v127);
      int v155 = _NRLogIsLevelEnabled(v154, 16LL);

      if (v155)
      {
        v156 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v127);
        id v157 = [(id)v4 copyDescription];
        _NRLogWithArgs( v156,  16LL,  "%s%.30s:%-4d %@: ignoring RandomUUID with invalid length %u",  "",  "-[NRLinkBluetooth handleReadData:]",  6651LL,  v157,  v136);
      }

      goto LABEL_142;
    }

    [*(id *)(v4 + 1359) getUUIDBytes:&v285];
    unsigned int v138 = *(unsigned __int8 *)(v134 + 3);
    v301.i8[0] = v138 ^ v285;
    if (v285 == v138)
    {
      unsigned int v139 = *(unsigned __int8 *)(v134 + 4);
      v301.i8[1] = v139 ^ v286;
      if (v286 == v139)
      {
        unsigned int v140 = *(unsigned __int8 *)(v134 + 5);
        v301.i8[2] = v140 ^ v287;
        if (v287 == v140)
        {
          unsigned int v141 = *(unsigned __int8 *)(v134 + 6);
          v301.i8[3] = v141 ^ v288;
          if (v288 == v141)
          {
            unsigned int v142 = *(unsigned __int8 *)(v134 + 7);
            v301.i8[4] = v142 ^ v289;
            if (v289 == v142)
            {
              unsigned int v143 = *(unsigned __int8 *)(v134 + 8);
              v301.i8[5] = v143 ^ v290;
              if (v290 == v143)
              {
                unsigned int v144 = *(unsigned __int8 *)(v134 + 9);
                v301.i8[6] = v144 ^ v291;
                if (v291 == v144)
                {
                  unsigned int v145 = *(unsigned __int8 *)(v134 + 10);
                  v301.i8[7] = v145 ^ v292;
                  if (v292 == v145)
                  {
                    unsigned int v146 = *(unsigned __int8 *)(v134 + 11);
                    v301.i8[8] = v146 ^ v293;
                    if (v293 == v146)
                    {
                      unsigned int v147 = *(unsigned __int8 *)(v134 + 12);
                      v301.i8[9] = v147 ^ v294;
                      if (v294 == v147)
                      {
                        unsigned int v148 = *(unsigned __int8 *)(v134 + 13);
                        v301.i8[10] = v148 ^ v295;
                        if (v295 == v148)
                        {
                          unsigned int v149 = *(unsigned __int8 *)(v134 + 14);
                          v301.i8[11] = v149 ^ v296;
                          if (v296 == v149)
                          {
                            unsigned int v150 = *(unsigned __int8 *)(v134 + 15);
                            v301.i8[12] = v150 ^ v297;
                            if (v297 == v150)
                            {
                              unsigned int v151 = *(unsigned __int8 *)(v134 + 16);
                              v301.i8[13] = v151 ^ v298;
                              if (v298 == v151)
                              {
                                unsigned int v152 = *(unsigned __int8 *)(v134 + 17);
                                v301.i8[14] = v152 ^ v299;
                                if (v299 == v152)
                                {
                                  unsigned int v153 = *(unsigned __int8 *)(v134 + 18);
                                  v301.i8[15] = v153 ^ v300;
                                  v133 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                                  if (v300 > v153) {
                                    *(_BYTE *)(v4 + 242) = 1;
                                  }
                                  goto LABEL_185;
                                }

                                v133 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                                if (v299 > v152) {
                                  *(_BYTE *)(v4 + 242) = 1;
                                }
LABEL_184:
                                v301.i8[15] = *(_BYTE *)(v134 + 18) ^ v300;
LABEL_185:
                                v158 = objc_alloc(&OBJC_CLASS___NSString);
                                v159 = (void *)sub_10010BAC0(&v301);
                                v160 = -[NSString initWithFormat:](v158, "initWithFormat:", @" %@", v159);
                                v161 = *(void **)(v4 + 1367);
                                *(void *)(v4 + 1367) = v160;

                                v163 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v162);
                                LODWORD(v159) = _NRLogIsLevelEnabled(v163, 1LL);

                                if ((_DWORD)v159)
                                {
                                  uint64_t v274 = _NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v127);
                                  id v164 = [(id)v4 copyDescription];
                                  id v273 = v164;
                                  v275 = -[NSUUID initWithUUIDBytes:]( objc_alloc(&OBJC_CLASS___NSUUID),  "initWithUUIDBytes:",  v134 + 3);
                                  v165 = (void *)objc_claimAutoreleasedReturnValue(-[NSUUID UUIDString](v275, "UUIDString"));
                                  v166 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v4 + 1359) UUIDString]);
                                  v167 = -[NSUUID initWithUUIDBytes:]( objc_alloc(&OBJC_CLASS___NSUUID),  "initWithUUIDBytes:",  &v301);
                                  uint64_t v168 = objc_claimAutoreleasedReturnValue(-[NSUUID UUIDString](v167, "UUIDString"));
                                  v169 = (void *)v168;
                                  v170 = "Responder";
                                  if (!*(_BYTE *)(v4 + 242)) {
                                    v170 = "Initiator";
                                  }
                                  id v267 = v164;
                                  v171 = (void *)v274;
                                  _NRLogWithArgs( v274,  1LL,  "%s%.30s:%-4d %@: received randomUUID %@, local %@, joint %@ hash%@, we are %s",  "",  "-[NRLinkBluetooth handleReadData:]",  6649LL,  v267,  v165,  v166,  v168,  *(void *)(v4 + 1367),  v170);

                                  v133 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                                }

                                uint64_t v113 = v276;
                                unint64_t v8 = (unint64_t)v280;
                                goto LABEL_142;
                              }

                              v133 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                              if (v298 > v151) {
                                *(_BYTE *)(v4 + 242) = 1;
                              }
LABEL_183:
                              v301.i8[14] = *(_BYTE *)(v134 + 17) ^ v299;
                              goto LABEL_184;
                            }

                            v133 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                            if (v297 > v150) {
                              *(_BYTE *)(v4 + 242) = 1;
                            }
LABEL_182:
                            v301.i8[13] = *(_BYTE *)(v134 + 16) ^ v298;
                            goto LABEL_183;
                          }

                          v133 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                          if (v296 > v149) {
                            *(_BYTE *)(v4 + 242) = 1;
                          }
LABEL_181:
                          v301.i8[12] = *(_BYTE *)(v134 + 15) ^ v297;
                          goto LABEL_182;
                        }

                        v133 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                        if (v295 > v148) {
                          *(_BYTE *)(v4 + 242) = 1;
                        }
LABEL_180:
                        v301.i8[11] = *(_BYTE *)(v134 + 14) ^ v296;
                        goto LABEL_181;
                      }

                      v133 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                      if (v294 > v147) {
                        *(_BYTE *)(v4 + 242) = 1;
                      }
LABEL_179:
                      v301.i8[10] = *(_BYTE *)(v134 + 13) ^ v295;
                      goto LABEL_180;
                    }

                    v133 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                    if (v293 > v146) {
                      *(_BYTE *)(v4 + 242) = 1;
                    }
LABEL_178:
                    v301.i8[9] = *(_BYTE *)(v134 + 12) ^ v294;
                    goto LABEL_179;
                  }

                  v133 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                  if (v292 > v145) {
                    *(_BYTE *)(v4 + 242) = 1;
                  }
LABEL_177:
                  v301.i8[8] = *(_BYTE *)(v134 + 11) ^ v293;
                  goto LABEL_178;
                }

                if (v291 > v144) {
                  *(_BYTE *)(v4 + 242) = 1;
                }
LABEL_176:
                v301.i8[7] = *(_BYTE *)(v134 + 10) ^ v292;
                goto LABEL_177;
              }

              if (v290 > v143) {
                *(_BYTE *)(v4 + 242) = 1;
              }
LABEL_175:
              v301.i8[6] = *(_BYTE *)(v134 + 9) ^ v291;
              goto LABEL_176;
            }

            if (v289 > v142) {
              *(_BYTE *)(v4 + 242) = 1;
            }
LABEL_174:
            v301.i8[5] = *(_BYTE *)(v134 + 8) ^ v290;
            goto LABEL_175;
          }

          if (v288 > v141) {
            *(_BYTE *)(v4 + 242) = 1;
          }
LABEL_173:
          v301.i8[4] = *(_BYTE *)(v134 + 7) ^ v289;
          goto LABEL_174;
        }

        if (v287 > v140) {
          *(_BYTE *)(v4 + 242) = 1;
        }
LABEL_172:
        v301.i8[3] = *(_BYTE *)(v134 + 6) ^ v288;
        goto LABEL_173;
      }

      if (v286 > v139) {
        *(_BYTE *)(v4 + 242) = 1;
      }
    }

    else
    {
      if (v285 > v138) {
        *(_BYTE *)(v4 + 242) = 1;
      }
      v301.i8[1] = *(_BYTE *)(v134 + 4) ^ v286;
    }

    v301.i8[2] = *(_BYTE *)(v134 + 5) ^ v287;
    goto LABEL_172;
  }

  *(_BYTE *)(v4 + 229) = 1;
  [(id)v4 reportEvent:4217];
  unsigned int v33 = *(_DWORD *)((char *)v9 + v4) - *(_DWORD *)(v4 + v8);
  uint64_t v34 = (unsigned __int16)v31;
  if (v33 > (unsigned __int16)v31)
  {
    if (*v3)
    {
      v228 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v32);
      int v229 = _NRLogIsLevelEnabled(v228, 1LL);

      if (v229)
      {
        v231 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v230);
        id v232 = [(id)v4 copyDescription];
        _NRLogWithArgs( v231,  1LL,  "%s%.30s:%-4d %@: memmoving the urgent linkReadBuffer by preludeLenFull=%u filledIn=%u handled=%u",  "",  "-[NRLinkBluetooth handleReadData:]",  6490LL,  v232,  (unsigned __int16)v31,  *(unsigned int *)(v4 + 311),  *(unsigned int *)(v4 + 315));
      }
    }

    memmove( v2,  &v27[(unsigned __int16)v31],  *(_DWORD *)((char *)v9 + v4) - *(_DWORD *)(v4 + v8) - (unsigned __int16)v31);
    int v35 = *(_DWORD *)((char *)v9 + v4) - *(_DWORD *)(v4 + v8) - (unsigned __int16)v31;
    goto LABEL_66;
  }

  if (v33 != (unsigned __int16)v31)
  {
    id v233 = sub_100070554();
    int v234 = _NRLogIsLevelEnabled(v233, 16LL);

    if (v234)
    {
      id v235 = sub_100070554();
      _NRLogWithArgs( v235,  16LL,  "%s%.30s:%-4d ABORTING: Bad prelude post-processing preludeLenFull=%u filledIn=%u handled=%u",  "",  "-[NRLinkBluetooth handleReadData:]",  6499,  (unsigned __int16)v31,  *(_DWORD *)((char *)v9 + v4),  *(_DWORD *)(v4 + v8));
    }

    uint64_t v236 = _os_log_pack_size(30LL);
    v237 = (char *)&v273 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    v238 = __error();
    uint64_t v239 = _os_log_pack_fill( v237,  v236,  *v238,  &_mh_execute_header,  "%{public}s Bad prelude post-processing preludeLenFull=%u filledIn=%u handled=%u");
    sub_10008BB5C( v239,  (uint64_t)"-[NRLinkBluetooth handleReadData:]",  (unsigned __int16)v31,  *(_DWORD *)((char *)v9 + v4),  *(_DWORD *)(v4 + v8));
    id v240 = sub_100070554();
    _NRLogAbortWithPack(v240, v237);
LABEL_262:
    v112 = (int *)v4;
    v241 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v32);
    int v242 = _NRLogIsLevelEnabled(v241, 1LL);

    if (v242)
    {
      v243 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v32);
      id v244 = [(id)v4 copyDescription];
      _NRLogWithArgs( v243,  1LL,  "%s%.30s:%-4d %@: not memmoving the urgent linkReadBuffer by preludeLenFull=%u filledIn=%u handled=%u",  "",  "-[NRLinkBluetooth handleReadData:]",  6502LL,  v244,  (unsigned __int16)v31,  *(unsigned int *)((char *)v9 + v4),  *(unsigned int *)(v4 + v8));

      int v35 = 0;
      goto LABEL_66;
    }

LABEL_267:
    int v35 = 0;
    uint64_t v4 = (uint64_t)v112;
    goto LABEL_66;
  }

  int v35 = *v3;
  if (*v3) {
    goto LABEL_262;
  }
LABEL_66:
  *(_DWORD *)((char *)v9 + v4) = v35;
  *(_DWORD *)(v4 + v8) = 0;
  v78 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v32);
  int v79 = _NRLogIsLevelEnabled(v78, 1LL);

  if (v79)
  {
    v81 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v80);
    id v82 = [(id)v4 copyDescription];
    _NRLogWithArgs( v81,  1LL,  "%s%.30s:%-4d %@: Successfully received prelude for urgent link",  "",  "-[NRLinkBluetooth handleReadData:]",  6507LL,  v82);
  }

  if (*(_BYTE *)(v4 + 246))
  {
    sub_10008F364((void *)v4, v34, &off_1001BC640);
  }

  else
  {
    v92 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v80);
    int v93 = _NRLogIsLevelEnabled(v92, 1LL);

    if (v93)
    {
      v95 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v94);
      id v96 = [(id)v4 copyDescription];
      _NRLogWithArgs( v95,  1LL,  "%s%.30s:%-4d %@: Starting LtN-U since received prelude, about to async",  "",  "-[NRLinkBluetooth handleReadData:]",  6513LL,  v96);
    }

    v97 = *(dispatch_queue_s **)(v4 + 8);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10008F550;
    block[3] = &unk_1001B0A88;
    block[4] = v4;
    dispatch_async(v97, block);
  }

void sub_10008F364(void *a1, uint64_t a2, void *a3)
{
  id v22 = a3;
  v5 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v6 = -[NSNumber initWithUnsignedInt:](objc_alloc(&OBJC_CLASS___NSNumber), "initWithUnsignedInt:", a2);
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v5,  "setObject:forKeyedSubscript:",  v6,  @"activate-datapath-offset");

  -[NSMutableDictionary setObject:forKeyedSubscript:](v5, "setObject:forKeyedSubscript:", v22, @"channel-id");
  id v7 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v5,  @"activate-datapath");
  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v8 = (id)qword_1001DC870;
  id v9 = v8;
  if (v8)
  {
    uint64_t v10 = a1[4];
    int v11 = (void *)*((void *)v8 + 27);
    uint64_t v12 = v7;
    int v13 = (void *)objc_claimAutoreleasedReturnValue([v11 objectForKeyedSubscript:v10]);
    sub_1000EFBC8((uint64_t)v13, v12);
  }

  id v14 = [v22 integerValue];
  if (v14 == (id)3)
  {
    uint64_t v16 = 249LL;
    goto LABEL_11;
  }

  if (v14 == (id)2)
  {
    uint64_t v16 = 248LL;
    goto LABEL_11;
  }

  if (v14 == (id)1)
  {
    uint64_t v16 = 247LL;
LABEL_11:
    *((_BYTE *)a1 + v16) = 1;
    goto LABEL_12;
  }

  __int128 v17 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v15);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v17, 17LL);

  if (IsLevelEnabled)
  {
    int v20 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v19);
    id v21 = [a1 copyDescription];
    _NRLogWithArgs(v20, 17LL, "%@: unsupported channel id %@", v21, v22);
  }

void sub_10008F550(uint64_t a1, uint64_t a2)
{
  id v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1LL);

  if (IsLevelEnabled)
  {
    id v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v5);
    id v7 = [*(id *)(a1 + 32) copyDescription];
    _NRLogWithArgs( v6,  1LL,  "%s%.30s:%-4d %@: Starting LtN-U since received prelude, in async block",  "",  "-[NRLinkBluetooth handleReadData:]_block_invoke",  6517LL,  v7);
  }

  sub_1000869EC(*(void **)(a1 + 32));
}

CFStringRef sub_10008F5F8(unsigned int a1)
{
  uint64_t v1 = a1;
  double result = @"Invalid";
  switch(a1)
  {
    case 0u:
      return result;
    case 0xAu:
      double result = @"PairWithOOBKey";
      break;
    case 0xBu:
      double result = @"PairWithIDSKeys";
      break;
    case 0xCu:
      double result = @"PairWithOOBKeyOrIDSKeys";
      break;
    case 0x14u:
      double result = @"HasCompletedPairing";
      break;
    default:
      double result = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown(%lld)",  v1);
      break;
  }

  return result;
}

void sub_10008F690(uint64_t a1, void *a2)
{
}

uint64_t sub_10008F6A0(char *a1, uint64_t a2)
{
  v2 = a1;
  id v3 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1LL);

  if (IsLevelEnabled)
  {
    id v6 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v5);
    id v7 = [v2 copyDescription];
    _NRLogWithArgs(v6, 1LL, "%s%.30s:%-4d %@: setting up nexus", "", "-[NRLinkBluetooth setupNexus]", 5877LL, v7);
  }

  uint64_t v8 = *(void *)(v2 + 343);
  id v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v2 + 335) peer]);
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 identifier]);
  int v11 = (void *)objc_claimAutoreleasedReturnValue([v10 UUIDString]);
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Terminus Bluetooth link to %@ <%@>",  v8,  v11));

  id v14 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v13);
  LODWORD(v10) = _NRLogIsLevelEnabled(v14, 0LL);

  if ((_DWORD)v10)
  {
    uint64_t v16 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v15);
    id v17 = [v2 copyDescription];
    _NRLogWithArgs( v16,  0LL,  "%s%.30s:%-4d %@: setup IPsec over BT with ring sizes if: %u kpipe tx: %u kpipe rx: %u",  "",  "-[NRLinkBluetooth setupNexus]",  5883LL,  v17,  dword_1001DC230,  dword_1001DC234,  dword_1001DC238);
  }

  if (v2[246])
  {
    unsigned int v18 = objc_alloc(&OBJC_CLASS___NEIPsecNexus);
    uint64_t v19 = dword_1001DC230;
    uint64_t v20 = dword_1001DC234;
    uint64_t v21 = dword_1001DC238;
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v22 = (id *)(id)qword_1001DC870;
    id v23 = v22;
    if (v22) {
      id v24 = v22[32];
    }
    else {
      id v24 = 0LL;
    }
    uint64_t v25 = -[NEIPsecNexus initWithName:delegate:enableWithChannelCount:netifRingSize:kernelPipeTxRingSize:kernelPipeRxRingSize:execUUID:]( v18,  "initWithName:delegate:enableWithChannelCount:netifRingSize:kernelPipeTxRingSize:kernelPipeRxRingSize:execUUID:",  v12,  v2,  4LL,  v19,  v20,  v21,  v24);
    id v26 = *(void **)(v2 + 1335);
    *(void *)(v2 + 1335) = v25;

    uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v2 + 1335) nexusInstances]);
    sub_10009597C((uint64_t)v2, v27);
  }

  else
  {
    uint64_t v28 = sub_10010D5C4( v12,  v2,  4LL,  dword_1001DC230,  dword_1001DC234,  (const char *)dword_1001DC238);
    uint64_t v27 = *(void **)(v2 + 1335);
    *(void *)(v2 + 1335) = v28;
  }

  objc_msgSend(v2, "setVirtualInterface:", objc_msgSend(*(id *)(v2 + 1335), "virtualInterface"));
  if ([v2 setInterfaceSubfamily])
  {
    if ((sub_100095B68(v2) & 1) == 0)
    {
      uint64_t v55 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v30);
      int v56 = _NRLogIsLevelEnabled(v55, 16LL);

      if (!v56) {
        goto LABEL_68;
      }
      uint64_t v52 = (char *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v57);
      id v53 = [v2 copyDescription];
      _NRLogWithArgs( v52,  16LL,  "%s%.30s:%-4d %@: failed to setup QoS marking",  "",  "-[NRLinkBluetooth setupNexus]",  5916LL,  v53);
      goto LABEL_32;
    }

    if ([v2 setNoACKPrioritization])
    {
      unsigned int v31 = *(void **)(v2 + 1335);
      if (v31)
      {
        if (v2[246])
        {
          uint64_t v32 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v29);
          int v33 = _NRLogIsLevelEnabled(v32, 0LL);

          if (!v33)
          {
LABEL_20:
            int v37 = v2[210];
            if (!v2[242] || *(void *)(v2 + 1215))
            {
LABEL_26:
              if ((v37 - 10) > 9)
              {
                sub_100076FE0((uint64_t)v2, 4LL);
                objc_initWeak(&location, v2);
                objc_opt_self(&OBJC_CLASS___NRDKeyManager);
                if (qword_1001DCC18 != -1) {
                  goto LABEL_63;
                }
                goto LABEL_45;
              }

              sub_100099058((uint64_t)v2);
              while (1)
              {
                v70 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *((void **)v2 + 4));
                if (v70) {
                  break;
                }
                id v88 = sub_100070554();
                int v89 = _NRLogIsLevelEnabled(v88, 16LL);

                if (v89)
                {
                  id v90 = sub_100070554();
                  _NRLogWithArgs( v90,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRLinkBluetooth setupNexus]",  5947);
                }

                uint64_t v12 = (void *)_os_log_pack_size(12LL);
                v2 = (char *)&v104[-1] - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                v91 = __error();
                uint64_t v92 = _os_log_pack_fill( v2,  v12,  *v91,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
                *(_DWORD *)uint64_t v92 = 136446210;
                *(void *)(v92 + 4) = "-[NRLinkBluetooth setupNexus]";
                id v93 = sub_100070554();
                _NRLogAbortWithPack(v93, v2);
                __break(1u);
LABEL_63:
                dispatch_once(&qword_1001DCC18, &stru_1001B0910);
LABEL_45:
                id v69 = (id)qword_1001DCC10;
                v104[0] = _NSConcreteStackBlock;
                v104[1] = 3221225472LL;
                v104[2] = sub_100099370;
                v104[3] = &unk_1001AFED0;
                objc_copyWeak(&v105, &location);
                sub_100144478((uint64_t)v69, v104);

                objc_destroyWeak(&v105);
                objc_destroyWeak(&location);
              }

              uint64_t v52 = v70;
              id v53 = (id)sub_100137060(v70);
              [*(id *)(v2 + 1335) setLocalAddresses:v53];
              sub_10007B498((uint64_t)v2);
              sub_100096308((uint64_t)v2, 0);
              v72 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v71);
              int v73 = _NRLogIsLevelEnabled(v72, 1LL);

              if (v73)
              {
                uint64_t v75 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v74);
                id v76 = [v2 copyDescription];
                v77 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v2 + 1335) interfaceName]);
                _NRLogWithArgs( v75,  1LL,  "%s%.30s:%-4d %@: created interface %@ with addresses %@ for nexus %@",  "",  "-[NRLinkBluetooth setupNexus]",  5957LL,  v76,  v77,  v53,  v12);
              }

              sub_100096514((uint64_t)v2);
              uint64_t v54 = 1LL;
              goto LABEL_50;
            }

            id v38 = sub_10010C0B8();
            [v38 setRequestChildlessSA:1];
            uint64_t v39 = -[NEIKEv2Listener initWithListenerIKEConfig:kernelSASessionName:packetDelegate:listenerQueue:delegate:delegateQueue:]( objc_alloc(&OBJC_CLASS___NEIKEv2Listener),  "initWithListenerIKEConfig:kernelSASessionName:packetDelegate:listenerQueue:delegate:delegateQueue:",  v38,  @"terminusIKE-Bluetooth-Listener",  v2,  *((void *)v2 + 1),  v2,  *((void *)v2 + 1));
            uint64_t v40 = *(void **)(v2 + 1215);
            *(void *)(v2 + 1215) = v39;

            uint64_t v41 = *(void *)(v2 + 1215);
            uint64_t v43 = _NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v42);
            int v44 = (void *)v43;
            if (v41)
            {
              int v45 = _NRLogIsLevelEnabled(v43, 0LL);

              if (v45)
              {
                int v47 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v46);
                id v48 = [v2 copyDescription];
                _NRLogWithArgs( v47,  0LL,  "%s%.30s:%-4d %@: Created IKE listener",  "",  "-[NRLinkBluetooth setupIPsec]",  9081LL,  v48);
              }

              goto LABEL_26;
            }

            int v94 = _NRLogIsLevelEnabled(v43, 17LL);

            if (v94)
            {
              id v96 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v95);
              id v97 = [v2 copyDescription];
              _NRLogWithArgs(v96, 17LL, "%@: Failed to create IKE listener", v97);
            }

            uint64_t v99 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v98);
            int v100 = _NRLogIsLevelEnabled(v99, 16LL);

            if (v100)
            {
              uint64_t v52 = (char *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v101);
              id v53 = [v2 copyDescription];
              _NRLogWithArgs( v52,  16LL,  "%s%.30s:%-4d %@: failed to setup IPsec",  "",  "-[NRLinkBluetooth setupNexus]",  5942LL,  v53);
              goto LABEL_32;
            }

void sub_100090274(_Unwind_Exception *a1)
{
}

void sub_1000902A0(uint64_t a1, uint64_t a2)
{
  id v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1LL);

  if (IsLevelEnabled)
  {
    id v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v5);
    id v7 = [*(id *)(a1 + 32) copyDescription];
    _NRLogWithArgs( v6,  1LL,  "%s%.30s:%-4d %@: Starting LtN since received prelude, in async block",  "",  "-[NRLinkBluetooth handleReadData:]_block_invoke",  6695LL,  v7);
  }

  sub_1000909CC(*(void **)(a1 + 32));
}

void sub_100090348(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 315);
  else {
    int v4 = a2;
  }
  uint64_t v5 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
  unsigned int v6 = *(_DWORD *)(a1 + 311);
  if (v3 == v6)
  {
    if (gNRPacketLoggingEnabled)
    {
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 1LL);

      if (IsLevelEnabled)
      {
        int v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v10);
        id v12 = [(id)a1 copyDescription];
        _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d %@: resetting the linkReadBuffer",  "",  "-[NRLinkBluetooth cleanupLinkReadBufferWithExtra:]",  6406LL,  v12);
      }
    }

    *(_DWORD *)(a1 + 315) = 0;
    id v7 = &OBJC_IVAR___NRLinkBluetooth__filledInLinkReadBufferBytes;
LABEL_11:
    *(_DWORD *)(a1 + *v7) = 0;
    return;
  }

  if (v6 > v3 && v3 + v4 >= *(_DWORD *)(a1 + 263))
  {
    if (gNRPacketLoggingEnabled)
    {
      uint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      int v14 = _NRLogIsLevelEnabled(v13, 1LL);

      uint64_t v5 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      if (v14)
      {
        uint64_t v16 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v15);
        id v17 = [(id)a1 copyDescription];
        _NRLogWithArgs( v16,  1LL,  "%s%.30s:%-4d %@: memmoving the linkReadBuffer by %u",  "",  "-[NRLinkBluetooth cleanupLinkReadBufferWithExtra:]",  6411LL,  v17,  *(unsigned int *)(a1 + 315));

        uint64_t v5 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      }
    }

    id v7 = &OBJC_IVAR___NRLinkBluetooth__handledLinkReadBufferBytes;
    memmove( *(void **)(a1 + 1311),  (const void *)(*(void *)(a1 + 1311) + *(unsigned int *)(a1 + 315)),  (*(_DWORD *)(a1 + v5[185]) - *(_DWORD *)(a1 + 315)));
    *(_DWORD *)(a1 + v5[185]) -= *(_DWORD *)(a1 + 315);
    goto LABEL_11;
  }

void sub_100090540(uint64_t a1, void *a2)
{
  id v3 = a2;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  uint64_t next_slot = os_channel_get_next_slot(*(void *)(a1 + 383), 0LL, &v8);
  if (next_slot)
  {
    uint64_t v5 = next_slot;
    unsigned __int16 v6 = (unsigned __int16)[v3 length];
    unsigned __int16 v7 = WORD1(v8);
    memcpy((void *)v9, [v3 bytes], v7);
    WORD1(v8) = v7;
    os_channel_set_slot_properties(*(void *)(a1 + 383), v5, &v8);
    os_channel_advance_slot(*(void *)(a1 + 383), v5);
    os_channel_sync(*(void *)(a1 + 367), 0LL);
  }
}

void sub_100090624(char *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v37 = a2;
  int v38 = a3;
  int v39 = 0;
  unsigned int v8 = nrMaxPacketLengthForTLV(a5, a4);
  if (!v8)
  {
    id v22 = sub_100070554();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v22, 16LL);

    if (IsLevelEnabled)
    {
      id v24 = sub_100070554();
      _NRLogWithArgs(v24, 16LL, "%s%.30s:%-4d ABORTING: strict_malloc called with size 0", "", "strict_malloc", 74);
    }

    uint64_t v25 = _os_log_pack_size(12LL);
    id v26 = (char *)&v36 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v27 = __error();
    uint64_t v28 = _os_log_pack_fill( v26,  v25,  *v27,  &_mh_execute_header,  "%{public}s strict_malloc called with size 0");
    *(_DWORD *)uint64_t v28 = 136446210;
    *(void *)(v28 + 4) = "strict_malloc";
LABEL_24:
    id v35 = sub_100070554();
    _NRLogAbortWithPack(v35, v26);
  }

  uint64_t v9 = v8;
  __int128 v10 = malloc(v8);
  if (!v10)
  {
    id v29 = sub_100070554();
    int v30 = _NRLogIsLevelEnabled(v29, 16LL);

    if (v30)
    {
      id v31 = sub_100070554();
      _NRLogWithArgs(v31, 16LL, "%s%.30s:%-4d ABORTING: strict_malloc(%zu) failed", "", "strict_malloc", 79, v9);
    }

    uint64_t v32 = _os_log_pack_size(22LL);
    id v26 = (char *)&v36 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v33 = __error();
    uint64_t v34 = _os_log_pack_fill(v26, v32, *v33, &_mh_execute_header, "%{public}s strict_malloc(%zu) failed");
    *(_DWORD *)uint64_t v34 = 136446466;
    *(void *)(v34 + 4) = "strict_malloc";
    *(_WORD *)(v34 + 12) = 2048;
    *(void *)(v34 + 14) = v9;
    goto LABEL_24;
  }

  __int128 v11 = v10;
  unsigned int v12 = nrTLVToPacket(&v37, 1LL, a5, a4, v10, v9, a1 + 1967, a1 + 1951);
  if (v12)
  {
    int v14 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", v11, v12);
    switch((int)a5)
    {
      case 'd':
        uint64_t v15 = 1607LL;
        goto LABEL_13;
      case 'e':
        uint64_t v15 = 1615LL;
        goto LABEL_13;
      case 'f':
        uint64_t v15 = 1639LL;
        goto LABEL_13;
      case 'g':
        uint64_t v15 = 1647LL;
        goto LABEL_13;
      case 'h':
        uint64_t v15 = 1623LL;
        goto LABEL_13;
      case 'i':
        uint64_t v15 = 1631LL;
        goto LABEL_13;
      default:
        if ((_DWORD)a5 == 3)
        {
          uint64_t v15 = 1599LL;
LABEL_13:
          ++*(void *)&a1[v15];
        }

        else
        {
          uint64_t v16 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v13);
          int v17 = _NRLogIsLevelEnabled(v16, 17LL);

          if (v17)
          {
            uint64_t v19 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v18);
            id v20 = [a1 copyDescription];
            StringFromNRTLVType = (void *)createStringFromNRTLVType(a5);
            _NRLogWithArgs(v19, 17LL, "%@: Invalid type %@", v20, StringFromNRTLVType);
          }
        }

        sub_100090540((uint64_t)a1, v14);

        break;
    }
  }

  free(v11);
}

void sub_1000909CC(void *a1)
{
  uint64_t v1 = a1;
  uint64_t v3 = (uint64_t)v1;
  int v4 = *((unsigned __int8 *)v1 + 16);
  if (v4 == 255)
  {
    uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(v1[4], v2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16LL);

    if (!IsLevelEnabled) {
      goto LABEL_454;
    }
    StringFromNRTLVType = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v7);
    id v9 = [(id)v3 copyDescription];
    _NRLogWithArgs( StringFromNRTLVType,  16LL,  "%s%.30s:%-4d %@: LinkToNexusLoop but cancelled",  "",  "NRLinkLinkToNexusLoop",  5094LL,  v9);
    goto LABEL_452;
  }

  if (!*(void *)((char *)v1 + 967))
  {
    int v14 = (void *)_NRCopyLogObjectForNRUUID(v1[4], v2);
    int v15 = _NRLogIsLevelEnabled(v14, 17LL);

    if (!v15) {
      goto LABEL_454;
    }
    StringFromNRTLVType = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v16);
    id v13 = [(id)v3 copyDescription];
    _NRLogWithArgs(StringFromNRTLVType, 17LL, "%@: Tried to linkToNexusLoop but _linkInputRing is NULL", v13);
    goto LABEL_10;
  }

  if ((v4 - 1) < 2)
  {
    __int128 v10 = (void *)_NRCopyLogObjectForNRUUID(v1[4], v2);
    int v11 = _NRLogIsLevelEnabled(v10, 17LL);

    if (!v11) {
      goto LABEL_454;
    }
    StringFromNRTLVType = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v12);
    id v13 = [(id)v3 copyDescription];
    _NRLogWithArgs(StringFromNRTLVType, 17LL, "%@: Tried to linkToNexusLoop but bad state", v13);
LABEL_10:

    goto LABEL_453;
  }

  uint64_t v624 = 0LL;
  uint64_t v625 = 0LL;
  v622 = v659;
  v623 = (char *)&v661 + 8;
  v626 = (char *)&v660 + 8;
  int v17 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
  uint64_t v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
  uint64_t v19 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
  uint64_t v631 = (uint64_t)v1;
LABEL_15:
  uint64_t v20 = 0LL;
  uint64_t v21 = 0LL;
  uint64_t v641 = 0LL;
  __int128 v630 = 0uLL;
  uint64_t v635 = 0LL;
  v648[0] = 0LL;
  v648[1] = 0LL;
  LODWORD(v633) = *(_BYTE *)(v3 + v17[360]) != 0;
  while (1)
  {
    while (1)
    {
LABEL_16:
      *(void *)(v3 + 1871) = 4LL;
      uint64_t v639 = 1871LL;
      if ((_WORD)v20 && (unsigned __int16)v20 >= (unsigned __int16)v21)
      {
        *(void *)(v3 + 1871) = 12LL;
      }

      else if ((_WORD)v20)
      {
        *(void *)(v3 + 1871) = 36LL;
        if (!v635) {
          goto LABEL_367;
        }
        uint64_t v22 = v639;
        goto LABEL_29;
      }

      uint64_t next_slot = os_channel_get_next_slot(*(void *)(v3 + 967), *((void *)&v630 + 1), &v649);
      *(void *)(v3 + 1871) |= 0x10uLL;
      if (!next_slot)
      {
LABEL_367:
        uint64_t v275 = v639;
        if (*(_BYTE *)(v3 + 221) && *(void *)(v3 + 983))
        {
          *(_BYTE *)(v3 + 221) = 0;
          ++*(void *)(v3 + 999);
          if (gNRPacketLoggingEnabled)
          {
            v344 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
            int v345 = _NRLogIsLevelEnabled(v344, 1LL);

            if (v345)
            {
              v347 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v346);
              id v348 = [(id)v3 copyDescription];
              _NRLogWithArgs( v347,  1LL,  "%s%.30s:%-4d %@: source-resume: LinkInput",  "",  "NRLinkResumeLinkInputSource",  822LL,  v348);
            }
          }

          dispatch_resume(*(dispatch_object_t *)(v3 + 983));
        }

        if (!*(_BYTE *)(v3 + 213) && *(void *)(v3 + 399))
        {
          *(_BYTE *)(v3 + 213) = 1;
          ++*(void *)(v3 + 423);
          if (gNRPacketLoggingEnabled)
          {
            v354 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
            int v355 = _NRLogIsLevelEnabled(v354, 1LL);

            if (v355)
            {
              v357 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v356);
              id v358 = [(id)v3 copyDescription];
              _NRLogWithArgs( v357,  1LL,  "%s%.30s:%-4d %@: source-suspend: NexusOutput",  "",  "NRLinkSuspendNexusOutputSource",  833LL,  v358);
            }
          }

          dispatch_suspend(*(dispatch_object_t *)(v3 + 399));
        }

        *(void *)(v3 + v275) |= 0x40uLL;
        goto LABEL_389;
      }

      uint64_t v24 = next_slot;
      uint64_t v25 = *(void *)(v3 + 967);
      uint64_t v635 = v24;
      uint64_t packet = os_channel_slot_get_packet(v25, v24);
      uint64_t next_buflet = os_packet_get_next_buflet(packet, 0LL);
      uint64_t object_address = os_buflet_get_object_address();
      unsigned int data_offset = os_buflet_get_data_offset(next_buflet);
      uint64_t data_length = os_buflet_get_data_length(next_buflet);
      if (data_length >= 0x10000)
      {
        id v410 = sub_100070554();
        int v411 = _NRLogIsLevelEnabled(v410, 16LL);

        if (v411)
        {
          id v412 = sub_100070554();
          _NRLogWithArgs( v412,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: inputBufferLength <= 65535",  "",  "NRLinkLinkToNexusLoop",  5154);
        }

        goto LABEL_467;
      }

      uint64_t v31 = data_length;
      uint64_t v641 = object_address + data_offset;
      os_packet_get_flow_uuid(packet, v648);
      uint64_t v19 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      uint64_t v20 = 0LL;
      if (*(_BYTE *)(v3 + 245))
      {
        *(_BYTE *)(v3 + 245) = 0;
        LODWORD(v633) = 1;
      }

      else
      {
        LODWORD(v633) = v633 | BYTE2(v648[0]);
      }

      uint64_t v22 = v639;
      uint64_t v21 = v31;
LABEL_29:
      int v32 = *(unsigned __int8 *)(v3 + 221);
      LODWORD(v643) = v21;
      if (!v32 && *(void *)(v3 + 983))
      {
        *(_BYTE *)(v3 + 221) = 1;
        ++*(void *)(v3 + 999);
        if (gNRPacketLoggingEnabled)
        {
          uint64_t v248 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
          int v249 = _NRLogIsLevelEnabled(v248, 1LL);

          uint64_t v21 = v643;
          if (v249)
          {
            id v251 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v250);
            id v252 = [(id)v3 copyDescription];
            _NRLogWithArgs( v251,  1LL,  "%s%.30s:%-4d %@: source-suspend: LinkInput",  "",  "NRLinkSuspendLinkInputSource",  814LL,  v252);

            uint64_t v21 = v643;
          }
        }

        dispatch_suspend(*(dispatch_object_t *)(v3 + 983));
      }

      unsigned int v33 = *(_DWORD *)(v3 + v18[185]);
      uint64_t v34 = *(unsigned int *)(v3 + v19[186]);
      uint64_t v35 = *(void *)(v3 + 1311);
      unsigned int v36 = *(unsigned __int8 *)(v35 + v34);
      if (*(_BYTE *)(v35 + v34))
      {
        uint64_t v21 = v643;
        goto LABEL_46;
      }

      while (1)
      {
        uint64_t v41 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
        int v42 = _NRLogIsLevelEnabled(v41, 1LL);

        if (v42)
        {
          uint64_t v43 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
          id v44 = [(id)v3 copyDescription];
          _NRLogWithArgs( v43,  1LL,  "%s%.30s:%-4d %@: Handling Pad0 in linkReadBuffer",  "",  "NRLinkLinkToNexusLoop",  5203LL,  v44);
        }

        ++*(_DWORD *)(v3 + v19[186]);
        unsigned int v33 = *(_DWORD *)(v3 + v18[185]);
        uint64_t v45 = *(unsigned int *)(v3 + v19[186]);
        uint64_t v46 = *(void *)(v3 + 1311);
        unsigned int v36 = *(unsigned __int8 *)(v46 + v45);
        if (*(_BYTE *)(v46 + v45))
        {
          uint64_t v34 = *(unsigned int *)(v3 + v19[186]);
          uint64_t v21 = v643;
          goto LABEL_46;
        }
      }

      if (v33 != (_DWORD)v45)
      {
        id v518 = sub_100070554();
        int v519 = _NRLogIsLevelEnabled(v518, 16LL);

        if (v519)
        {
          id v520 = sub_100070554();
          _NRLogWithArgs( v520,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: self->_filledInLinkReadBufferBytes == self->_handledLinkReadBufferBytes",  "",  "NRLinkLinkToNexusLoop",  5207);
        }

        uint64_t v521 = _os_log_pack_size(12LL);
        v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v522 = *__error();
        uint64_t v393 = _os_log_pack_fill( v382,  v521,  v522,  &_mh_execute_header,  "%{public}s Assertion Failed: self->_filledInLinkReadBufferBytes == self->_handledLinkReadBufferBytes");
        goto LABEL_475;
      }

      uint64_t v54 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
      int v55 = _NRLogIsLevelEnabled(v54, 1LL);

      uint64_t v21 = v643;
      if (v55)
      {
        int v56 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
        id v57 = [(id)v3 copyDescription];
        _NRLogWithArgs( v56,  1LL,  "%s%.30s:%-4d %@: Ended linkReadBuffer on a Pad0 handled=%u filledIn=%u",  "",  "NRLinkLinkToNexusLoop",  5209LL,  v57,  *(unsigned int *)(v3 + v19[186]),  *(unsigned int *)(v3 + v18[185]));
        goto LABEL_311;
      }
    }

    while (1)
    {
      unsigned int v36 = *(unsigned __int8 *)(v641 + (unsigned __int16)v20);
      uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
      int v38 = _NRLogIsLevelEnabled(v37, 1LL);

      if (v38)
      {
        int v39 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
        id v40 = [(id)v3 copyDescription];
        _NRLogWithArgs( v39,  1LL,  "%s%.30s:%-4d %@: Handling Pad0 in linkInputSlot alreadyRead=%u",  "",  "NRLinkLinkToNexusLoop",  5227LL,  v40,  (unsigned __int16)v20);
      }

      uint64_t v20 = (v20 + 1);
      uint64_t v21 = v643;
      if ((unsigned __int16)v20 >= (unsigned __int16)v643)
      {
        if ((unsigned __int16)v20 != (unsigned __int16)v643)
        {
          id v462 = sub_100070554();
          int v463 = _NRLogIsLevelEnabled(v462, 16LL);

          if (v463)
          {
            id v464 = sub_100070554();
            _NRLogWithArgs( v464,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: curLinkInputSlotPartialBytesAlreadyRead == linkInputBufferLength",  "",  "NRLinkLinkToNexusLoop",  5231);
          }

LABEL_490:
          uint64_t v422 = _os_log_pack_size(12LL);
          v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v423 = *__error();
          uint64_t v393 = _os_log_pack_fill( v382,  v422,  v423,  &_mh_execute_header,  "%{public}s Assertion Failed: curLinkInputSlotPartialBytesAlreadyRead == linkInputBufferLength");
LABEL_475:
          *(_DWORD *)uint64_t v393 = 136446210;
          v396 = "NRLinkLinkToNexusLoop";
          goto LABEL_476;
        }

        uint64_t v271 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
        int v272 = _NRLogIsLevelEnabled(v271, 1LL);

        if (v272)
        {
          id v273 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
          id v274 = [(id)v3 copyDescription];
          _NRLogWithArgs( v273,  1LL,  "%s%.30s:%-4d %@: Ended linkInputSlot on a Pad0 handled=%u filledIn=%u",  "",  "NRLinkLinkToNexusLoop",  5233LL,  v274,  *(unsigned int *)(v3 + v19[186]),  *(unsigned int *)(v3 + v18[185]));
        }

LABEL_389:
        if (*((void *)&v630 + 1))
        {
          unsigned int v285 = *(_DWORD *)(v3 + v18[185]);
          unsigned int v286 = *(_DWORD *)(v3 + v19[186]);
          if (v285 <= v286)
          {
            if (v286 != v285)
            {
              id v513 = sub_100070554();
              int v514 = _NRLogIsLevelEnabled(v513, 16LL);

              if (v514)
              {
                id v515 = sub_100070554();
                _NRLogWithArgs( v515,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: self->_handledLinkReadBufferBytes == self->_filledInLinkReadBufferBytes",  "",  "NRLinkLinkToNexusLoop",  5752);
              }

              uint64_t v516 = _os_log_pack_size(12LL);
              v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v517 = *__error();
              uint64_t v393 = _os_log_pack_fill( v382,  v516,  v517,  &_mh_execute_header,  "%{public}s Assertion Failed: self->_handledLinkReadBufferBytes == self->_filledInLinkReadBufferBytes");
              goto LABEL_475;
            }

            *(void *)(v3 + 1871) |= 0x400000000uLL;
            if (gNRPacketLoggingEnabled)
            {
              v324 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              int v325 = _NRLogIsLevelEnabled(v324, 1LL);

              if (v325)
              {
                v326 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
                id v327 = [(id)v3 copyDescription];
                _NRLogWithArgs( v326,  1LL,  "%s%.30s:%-4d %@: resetting the linkReadBuffer (filledIn=%u)",  "",  "NRLinkLinkToNexusLoop",  5754LL,  v327,  *(unsigned int *)(v3 + v18[185]));
              }
            }

            *(_DWORD *)(v3 + v18[185]) = 0;
LABEL_397:
            *(_DWORD *)(v3 + v19[186]) = 0;
            goto LABEL_398;
          }

          if (v286 > *(_DWORD *)(v3 + 271))
          {
            *(void *)(v3 + 1871) |= 0x80000000uLL;
            if (gNRPacketLoggingEnabled)
            {
              v328 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              int v329 = _NRLogIsLevelEnabled(v328, 1LL);

              if (v329)
              {
                v331 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v330);
                id v332 = [(id)v3 copyDescription];
                _NRLogWithArgs( v331,  1LL,  "%s%.30s:%-4d %@: memmoving the linkReadBuffer by handled=%u (filledIn=%u) thresh=%u",  "",  "NRLinkLinkToNexusLoop",  5734LL,  v332,  *(unsigned int *)(v3 + v19[186]),  *(unsigned int *)(v3 + v18[185]),  *(unsigned int *)(v3 + 271));
              }
            }

            uint64_t v287 = *(unsigned int *)(v3 + v19[186]);
            memmove( *(void **)(v3 + 1311),  (const void *)(*(void *)(v3 + 1311) + v287),  (*(_DWORD *)(v3 + v18[185]) - v287));
            *(_DWORD *)(v3 + v18[185]) -= *(_DWORD *)(v3 + v19[186]);
            goto LABEL_397;
          }

          uint64_t v294 = *(void *)(v3 + 1871);
          if (v286)
          {
            unint64_t v295 = v294 | (unint64_t)&_mh_execute_header;
            *(void *)(v3 + 1871) = v294 | (unint64_t)&_mh_execute_header;
            if (gNRPacketLoggingEnabled)
            {
              unsigned __int8 v296 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              int v297 = _NRLogIsLevelEnabled(v296, 1LL);

              if (v297)
              {
                unsigned __int8 v298 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
                id v299 = [(id)v3 copyDescription];
                _NRLogWithArgs( v298,  1LL,  "%s%.30s:%-4d %@: not memmoving the linkReadBuffer thresh handled=%u filledIn=%u thresh=%u",  "",  "NRLinkLinkToNexusLoop",  5743LL,  v299,  *(unsigned int *)(v3 + v19[186]),  *(unsigned int *)(v3 + v18[185]),  *(unsigned int *)(v3 + 271));
                goto LABEL_440;
              }

              goto LABEL_398;
            }

LABEL_406:
            *(void *)(v3 + 1871) = v295 | 0x800000000LL;
          }

          else
          {
            unint64_t v295 = v294 | 0x200000000LL;
            *(void *)(v3 + 1871) = v294 | 0x200000000LL;
            if (!gNRPacketLoggingEnabled) {
              goto LABEL_406;
            }
            v342 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
            int v343 = _NRLogIsLevelEnabled(v342, 1LL);

            if (v343)
            {
              unsigned __int8 v298 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              id v299 = [(id)v3 copyDescription];
              _NRLogWithArgs( v298,  1LL,  "%s%.30s:%-4d %@: not memmoving the linkReadBuffer zero handled=%u filledIn=%u thresh=%u",  "",  "NRLinkLinkToNexusLoop",  5749LL,  v299,  *(unsigned int *)(v3 + v19[186]),  *(unsigned int *)(v3 + v18[185]),  *(unsigned int *)(v3 + 271));
LABEL_440:
            }

LABEL_398:
            int v288 = gNRPacketLoggingEnabled;
            *(void *)(v3 + 1871) |= 0x800000000uLL;
            if (v288)
            {
              unsigned __int8 v289 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              int v290 = _NRLogIsLevelEnabled(v289, 1LL);

              if (v290)
              {
                unsigned __int8 v292 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v291);
                id v293 = [(id)v3 copyDescription];
                _NRLogWithArgs( v292,  1LL,  "%s%.30s:%-4d %@: advancing past linkInputSlot=%p and syncing link input",  "",  "NRLinkLinkToNexusLoop",  5758LL,  v293,  *((void *)&v630 + 1));
              }
            }
          }

          if (gNRPacketLoggingEnabled)
          {
            uint64_t v311 = objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
            v312 = *(void **)(v3 + 1679);
            *(void *)(v3 + 1679) = v311;
          }

          os_channel_advance_slot(*(void *)(v3 + 967), *((void *)&v630 + 1));
          os_channel_sync(*(void *)(v3 + 959), 1LL);
          ++*(void *)(v3 + 1423);
        }

        if ((void)v630)
        {
          if (*(void *)(v3 + 383))
          {
            *(void *)(v3 + 1871) |= 0x1000000000uLL;
            if (gNRPacketLoggingEnabled)
            {
              v313 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              int v314 = _NRLogIsLevelEnabled(v313, 1LL);

              if (v314)
              {
                v316 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v315);
                id v317 = [(id)v3 copyDescription];
                _NRLogWithArgs( v316,  1LL,  "%s%.30s:%-4d %@: advancing past nexusOutputSlot=%p and syncing nexus output",  "",  "NRLinkLinkToNexusLoop",  5769LL,  v317,  (void)v630);
              }

              if (gNRPacketLoggingEnabled)
              {
                uint64_t v318 = objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
                v319 = *(void **)(v3 + 1671);
                *(void *)(v3 + 1671) = v318;
              }
            }

            os_channel_advance_slot(*(void *)(v3 + 383), v630);
            os_channel_sync(*(void *)(v3 + 367), 0LL);
            if (gNRPacketLoggingEnabled)
            {
              v320 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              int v321 = _NRLogIsLevelEnabled(v320, 1LL);

              if (v321)
              {
                v322 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
                id v323 = [(id)v3 copyDescription];
                _NRLogWithArgs( v322,  1LL,  "%s%.30s:%-4d %@: Read %llu packets, %llu bytes",  "",  "NRLinkLinkToNexusLoop",  5773LL,  v323,  v624,  v625);
              }
            }

            ++*(void *)(v3 + 479);
          }

          else
          {
            v307 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
            int v308 = _NRLogIsLevelEnabled(v307, 17LL);

            if (v308)
            {
              v309 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              id v310 = [(id)v3 copyDescription];
              _NRLogWithArgs(v309, 17LL, "%@: Tried to sync nexus output but _nexusOutputRing is NULL", v310);
            }
          }
        }

        if (*(void *)(v3 + 1871) && *(void *)(v3 + 1879))
        {
          *(_BYTE *)(v3 + 251) %= *(_BYTE *)(v3 + 250);
          uint64_t v300 = *(void *)(v3 + 1879);
          int8x16_t v301 = (void *)(v300 + 8LL * *(unsigned __int8 *)(v3 + 251));
          if ((unint64_t)(v301 + 1) <= v300 + 8 * (unint64_t)*(unsigned __int8 *)(v3 + 250))
          {
            if ((v301 & 7) == 0)
            {
              *int8x16_t v301 = *(void *)(v3 + 1871);
              ++*(_BYTE *)(v3 + 251);
              *(void *)(v3 + 1871) = 0LL;
            }
          }

          else
          {
            v302 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
            int v303 = _NRLogIsLevelEnabled(v302, 17LL);

            if (v303)
            {
              v304 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              id v305 = [(id)v3 copyDescription];
              _NRLogWithArgs( v304,  17LL,  "%@: invalid index for link log list (curIdx: %u)",  v305,  *(unsigned __int8 *)(v3 + 251));
            }
          }
        }

        int v17 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
        *(_BYTE *)(v3 + 220) = v633 & 1;
        if (v630 == 0) {
          goto LABEL_454;
        }
        goto LABEL_15;
      }
    }

    uint64_t v34 = *(unsigned int *)(v3 + v19[186]);
    unsigned int v33 = *(_DWORD *)(v3 + v18[185]);
LABEL_46:
    if (v33 <= (int)v34 + 2)
    {
      if (v33 == (_DWORD)v34 + 2)
      {
        id v49 = (uint64_t *)*(unsigned __int8 *)(*(void *)(v3 + 1311) + (v34 + 1));
        if ((unsigned __int16)v20 >= (unsigned __int16)v21)
        {
          uint64_t v48 = 0LL;
          int v50 = 0;
          uint64_t v51 = 512LL;
        }

        else
        {
          uint64_t v48 = *(unsigned __int8 *)(v641 + (unsigned __int16)v20);
          int v50 = 1;
          uint64_t v51 = 256LL;
        }
      }

      else
      {
        if (v33 == (_DWORD)v34 + 1) {
          unsigned __int16 v52 = v20;
        }
        else {
          unsigned __int16 v52 = v20 + 1;
        }
        if (v52 + 2 >= (unsigned __int16)v21)
        {
          id v49 = 0LL;
          uint64_t v48 = 0LL;
          int v50 = 0;
          uint64_t v51 = 2048LL;
        }

        else
        {
          unsigned int v53 = bswap32(*(unsigned __int16 *)(v641 + v52));
          uint64_t v48 = BYTE2(v53);
          id v49 = (uint64_t *)HIBYTE(v53);
          int v50 = 1;
          uint64_t v51 = 1024LL;
        }
      }
    }

    else
    {
      unsigned int v47 = bswap32(*(unsigned __int16 *)(*(void *)(v3 + 1311) + (v34 + 1)));
      uint64_t v48 = BYTE2(v47);
      id v49 = (uint64_t *)HIBYTE(v47);
      int v50 = 1;
      uint64_t v51 = 128LL;
    }

    unsigned int v632 = v36;
    uint64_t v58 = *(void *)(v3 + v22) | v51;
    *(void *)(v3 + v22) = v58;
    __int128 v674 = 0u;
    __int128 v675 = 0u;
    __int128 v672 = 0u;
    __int128 v673 = 0u;
    __int128 v670 = 0u;
    __int128 v671 = 0u;
    __int128 v668 = 0u;
    __int128 v669 = 0u;
    __int128 v666 = 0u;
    __int128 v667 = 0u;
    __int128 v664 = 0u;
    __int128 v665 = 0u;
    __int128 v662 = 0u;
    __int128 v663 = 0u;
    __int128 v660 = 0u;
    __int128 v661 = 0u;
    unsigned int v628 = v33;
    unint64_t v59 = v33 - v34;
    uint64_t v642 = v20;
    uint64_t v627 = v34;
    v636 = v49;
    if (v33 <= v34)
    {
      v640 = 0LL;
      uint64_t v61 = 0LL;
    }

    else
    {
      *(void *)&__int128 v660 = *(void *)(v3 + 1311) + v34;
      uint64_t v60 = v48 | ((_DWORD)v49 << 8);
      if (v60 + 5 < v59) {
        unint64_t v59 = v60 + 5;
      }
      if (!(_DWORD)v59)
      {
        id v424 = sub_100070554();
        char v425 = _NRLogIsLevelEnabled(v424, 16LL);

        if ((v425 & 1) != 0)
        {
          id v426 = sub_100070554();
          _NRLogWithArgs( v426,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: lrbIOVecLen > 0; tlvLen=%u filledInLinkReadBufferBytes=%u handledLi"
            "nkReadBufferBytes=%u",
            "",
            "NRLinkLinkToNexusLoop",
            5312,
            v60,
            *(_DWORD *)(v3 + v18[185]),
            *(_DWORD *)(v3 + v19[186]));
        }

        uint64_t v427 = _os_log_pack_size(30LL);
        v428 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        v429 = __error();
        uint64_t v430 = _os_log_pack_fill( v428,  v427,  *v429,  &_mh_execute_header,  "%{public}s Assertion Failed: lrbIOVecLen > 0; tlvLen=%u filledInLinkReadBufferBytes=%u handledLinkReadBufferBytes=%u");
        sub_10008BB5C( v430,  (uint64_t)"NRLinkLinkToNexusLoop",  v60,  *(_DWORD *)(v3 + v18[185]),  *(_DWORD *)(v3 + v19[186]));
        goto LABEL_544;
      }

      v640 = (uint64_t *)v59;
      DWORD2(v660) = v59;
      v58 |= 0x1000uLL;
      *(void *)(v3 + v22) = v58;
      uint64_t v61 = 1LL;
    }

    int v62 = (unsigned __int16)v642;
    uint64_t v63 = (unsigned __int16)v21;
    BOOL v64 = (unsigned __int16)v642 < (unsigned __int16)v21;
    if ((unsigned __int16)v642 >= (unsigned __int16)v21)
    {
      if (v50)
      {
LABEL_79:
        BOOL v64 = 0;
        v72 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
        uint64_t v71 = v636;
        goto LABEL_98;
      }

      uint64_t v638 = v48;
      LODWORD(v68) = v61;
LABEL_84:
      v72 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      LODWORD(v637) = 0;
      unint64_t v634 = v68;
      goto LABEL_104;
    }

    unsigned __int16 v65 = v642;
    *((void *)&v660 + 2 * v61) = v641 + (unsigned __int16)v642;
    if ((unsigned __int16)v21 == v65)
    {
      id v456 = sub_100070554();
      int v457 = _NRLogIsLevelEnabled(v456, 16LL);

      if (v457)
      {
        id v458 = sub_100070554();
        _NRLogWithArgs( v458,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: clisIOVecLen > 0; linkInputBufferLength=%u curLinkInputSlotPartialByt"
          "esAlreadyRead=%u",
          "",
          "NRLinkLinkToNexusLoop",
          5326,
          v63,
          v62);
      }

      uint64_t v459 = _os_log_pack_size(24LL);
      v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      v460 = __error();
      uint64_t v461 = _os_log_pack_fill( v382,  v459,  *v460,  &_mh_execute_header,  "%{public}s Assertion Failed: clisIOVecLen > 0; linkInputBufferLength=%u curLinkInputSlotPartialBytesAlreadyRead=%u");
      *(_DWORD *)uint64_t v461 = 136446722;
      *(void *)(v461 + 4) = "NRLinkLinkToNexusLoop";
      *(_WORD *)(v461 + 12) = 1024;
      *(_DWORD *)(v461 + 14) = v63;
      *(_WORD *)(v461 + 18) = 1024;
      *(_DWORD *)(v461 + 20) = v62;
      goto LABEL_477;
    }

    unint64_t v66 = (unint64_t)(&v660 + v61);
    *(_DWORD *)(v66 + 8) = (unsigned __int16)v21 - v62;
    id v67 = (uint64_t *)(v640 + (unsigned __int16)v21 - v62);
    *(void *)(v3 + v22) = v58 | 0x2000;
    uint64_t v68 = (v61 + 1);
    v640 = v67;
    else {
      char v69 = v50;
    }
    if ((v69 & 1) == 0)
    {
      if (DWORD2(v660) >= 3)
      {
        int v73 = *(_WORD *)(v660 + 1);
        int v74 = HIBYTE(*(unsigned __int16 *)(v660 + 1));
        v70 = v640;
LABEL_92:
        unsigned int v75 = bswap32(v73 | (v74 << 8));
        uint64_t v48 = BYTE2(v75);
        uint64_t v71 = (uint64_t *)HIBYTE(v75);
        goto LABEL_93;
      }

      if (DWORD2(v660) == 2)
      {
        v70 = v640;
        int v73 = *(unsigned __int8 *)(v660 + 1);
        int v74 = *(unsigned __int8 *)v661;
        goto LABEL_92;
      }

      if (DWORD2(v660) == 1)
      {
        v70 = v640;
        if (DWORD2(v661) < 2)
        {
          id v612 = sub_100070554();
          int v613 = _NRLogIsLevelEnabled(v612, 16LL);

          if (v613)
          {
            id v614 = sub_100070554();
            v615 = (void *)createIOVecString(&v660, v68);
            _NRLogWithArgs( v614,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 2; %@",
              "",
              "nrReadTLVLenHBOFromIOVec",
              274LL,
              v615);
          }

          uint64_t v616 = _os_log_pack_size(22LL);
          v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v617 = *__error();
          uint64_t v551 = _os_log_pack_fill( v382,  v616,  v617,  &_mh_execute_header,  "%{public}s Assertion Failed: numIOVecs > 2; %@");
        }

        else
        {
          if (v628 > v627)
          {
            int v73 = *(_WORD *)v661;
            int v74 = HIBYTE(*(unsigned __int16 *)v661);
            goto LABEL_92;
          }

          id v552 = sub_100070554();
          int v553 = _NRLogIsLevelEnabled(v552, 16LL);

          if (v553)
          {
            id v554 = sub_100070554();
            v555 = (void *)createIOVecString(&v660, v68);
            _NRLogWithArgs( v554,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 1; %@",
              "",
              "nrReadTLVLenHBOFromIOVec",
              271LL,
              v555);
          }

          uint64_t v556 = _os_log_pack_size(22LL);
          v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v557 = *__error();
          uint64_t v551 = _os_log_pack_fill( v382,  v556,  v557,  &_mh_execute_header,  "%{public}s Assertion Failed: numIOVecs > 1; %@");
        }
      }

      else
      {
        id v545 = sub_100070554();
        int v546 = _NRLogIsLevelEnabled(v545, 16LL);

        if (v546)
        {
          id v547 = sub_100070554();
          v548 = (void *)createIOVecString(&v660, v68);
          _NRLogWithArgs( v547,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[0].len == 1; %@",
            "",
            "nrReadTLVLenHBOFromIOVec",
            269LL,
            v548);
        }

        uint64_t v549 = _os_log_pack_size(22LL);
        v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v550 = *__error();
        uint64_t v551 = _os_log_pack_fill( v382,  v549,  v550,  &_mh_execute_header,  "%{public}s Assertion Failed: ioVecs[0].len == 1; %@");
      }

      uint64_t v558 = v551;
      uint64_t v559 = v68;
      goto LABEL_577;
    }

    if (!v50)
    {
      uint64_t v638 = v48;
      *(void *)(v3 + v22) = v58 | 0xA000;
      uint64_t v642 = v21;
      goto LABEL_84;
    }

    v70 = v640;
    uint64_t v71 = v636;
LABEL_93:
    unint64_t v76 = (v48 | ((unint64_t)v71 << 8)) + 5;
    if (v76 >= v70)
    {
      uint64_t v58 = *(void *)(v3 + v22) | 0x8000LL;
      *(void *)(v3 + v22) = v58;
      BOOL v64 = 1;
      uint64_t v642 = v21;
      uint64_t v61 = (v61 + 1);
    }

    else
    {
      v77 = (_DWORD *)(v66 | 8);
      uint64_t v78 = ((_DWORD)v70 - v76);
      uint64_t v58 = *(void *)(v3 + v22) | 0x4000LL;
      *(void *)(v3 + v22) = v58;
      BOOL v79 = *v77 == (_DWORD)v78;
      *v77 -= v78;
      if (v79)
      {
        uint64_t v523 = v61;
        id v524 = sub_100070554();
        int v525 = _NRLogIsLevelEnabled(v524, 16LL);

        if (v525)
        {
          id v526 = sub_100070554();
          v527 = (void *)createIOVecString(&v660, v68);
          _NRLogWithArgs( v526,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[iovecIndex - 1].len > 0; Shrunk ioVecs[%u] down by %u to 0 -"
            " %@ ioVecContentLen=%u alreadyRead=%u",
            "",
            "NRLinkLinkToNexusLoop",
            5350LL,
            v523,
            v78,
            v527,
            v70,
            v63);
        }

        uint64_t v528 = _os_log_pack_size(46LL);
        v428 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        v529 = __error();
        uint64_t v530 = _os_log_pack_fill( v428,  v528,  *v529,  &_mh_execute_header,  "%{public}s Assertion Failed: ioVecs[iovecIndex - 1].len > 0; Shrunk ioVecs[%u] down by %u to 0 - %@ ioV"
                 "ecContentLen=%u alreadyRead=%u");
        uint64_t v531 = createIOVecString(&v660, v68);
        sub_10008BB8C(v530, (uint64_t)"NRLinkLinkToNexusLoop", v523, v78, v531, (int)v70, v63);
        goto LABEL_544;
      }

      uint64_t v642 = (v21 - v78);
      BOOL v64 = 1;
      uint64_t v61 = (v61 + 1);
      v640 = (uint64_t *)((v48 | ((unint64_t)v71 << 8)) + 5);
      uint64_t v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
    }

    v72 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
LABEL_98:
    if (v632 - 100 < 6 || v632 - 2 < 4)
    {
      unsigned int v80 = 2000;
      goto LABEL_101;
    }

    if (v632 == 1)
    {
      unsigned int v80 = 255;
LABEL_101:
      uint64_t v81 = v48 | ((_DWORD)v71 << 8);
      if (v81 > v80)
      {
        uint64_t v370 = v61;
        StringFromNRTLVType = (void *)createStringFromNRTLVType(v632);
        id v9 = (id)createIOVecStringWithContents(&v660, v370);
        sub_1000749CC( (void *)v3,  @"Received invalid TLV len %u for %@ (max=%u) %@",  v371,  v372,  v373,  v374,  v375,  v376,  v81);
        goto LABEL_452;
      }
    }

    uint64_t v82 = v61;
    if ((v48 | ((unint64_t)v71 << 8)) + 5 <= v640)
    {
      uint64_t v93 = v635;
      uint64_t v94 = v635;
      uint64_t v22 = v639;
      uint64_t v95 = v642;
LABEL_109:
      uint64_t v96 = v93;
      uint64_t v635 = v94;
      goto LABEL_180;
    }

    LODWORD(v68) = v61;
    v636 = v71;
    uint64_t v638 = v48;
    unint64_t v634 = v61;
    LODWORD(v637) = 1;
    uint64_t v22 = v639;
LABEL_104:
    uint64_t v83 = v635;
    uint64_t v84 = os_channel_get_next_slot(*(void *)(v3 + v72[120]), v635, &v644);
    if (!v84)
    {
      uint64_t v96 = v83;
      uint64_t v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      goto LABEL_179;
    }

    uint64_t v85 = v84;
    uint64_t v86 = os_channel_slot_get_packet(*(void *)(v3 + v72[120]), v84);
    uint64_t v87 = os_packet_get_next_buflet(v86, 0LL);
    uint64_t v88 = os_buflet_get_object_address();
    unsigned int v89 = os_buflet_get_data_offset(v87);
    unsigned int v90 = os_buflet_get_data_length(v87);
    if (HIWORD(v90))
    {
LABEL_461:
      if (qword_1001DC840 != -1) {
        dispatch_once(&qword_1001DC840, &stru_1001AEE08);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC838, 16LL))
      {
        if (qword_1001DC840 != -1) {
          dispatch_once(&qword_1001DC840, &stru_1001AEE08);
        }
        _NRLogWithArgs( qword_1001DC838,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: inputBufferLength <= 65535",  "",  "NRLinkLinkToNexusLoop",  5391);
      }

LABEL_467:
      uint64_t v391 = _os_log_pack_size(12LL);
      v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v392 = *__error();
      uint64_t v393 = _os_log_pack_fill( v382,  v391,  v392,  &_mh_execute_header,  "%{public}s Assertion Failed: inputBufferLength <= 65535");
      goto LABEL_475;
    }

    unsigned int v91 = v90;
    os_packet_get_flow_uuid(v86, v648);
    if (*(_BYTE *)(v3 + 245))
    {
      *(_BYTE *)(v3 + 245) = 0;
      LOBYTE(v92) = 1;
    }

    else
    {
      LOBYTE(v92) = (v633 | BYTE2(v648[0])) & 1;
    }

    id v97 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
    uint64_t v48 = v638;
    uint64_t v98 = v639;
    uint64_t v2 = v85;
    uint64_t v99 = v88 + v89;
    *((void *)&v660 + 2 * v634) = v99;
    if (!v91)
    {
LABEL_468:
      if (qword_1001DC840 != -1) {
        dispatch_once(&qword_1001DC840, &stru_1001AEE08);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC838, 16LL))
      {
        if (qword_1001DC840 != -1) {
          dispatch_once(&qword_1001DC840, &stru_1001AEE08);
        }
        _NRLogWithArgs( qword_1001DC838,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: lookAheadLinkInputBufferLength > 0",  "",  "NRLinkLinkToNexusLoop",  5403);
      }

      uint64_t v394 = _os_log_pack_size(12LL);
      v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v395 = *__error();
      uint64_t v393 = _os_log_pack_fill( v382,  v394,  v395,  &_mh_execute_header,  "%{public}s Assertion Failed: lookAheadLinkInputBufferLength > 0");
      goto LABEL_475;
    }

    unint64_t v100 = v634;
    *((_DWORD *)&v660 + 4 * v634 + 2) = v91;
    uint64_t v101 = *(void *)(v3 + v98) | 0x20000LL;
    *(void *)(v3 + v98) = v101;
    unint64_t v102 = v91 + v640;
    unint64_t v103 = v100 + 1;
    else {
      char v104 = v637;
    }
    if ((v104 & 1) != 0)
    {
      uint64_t v93 = v635;
      if (!(_DWORD)v637)
      {
        int v109 = 0;
        uint64_t v95 = v642;
        uint64_t v71 = v636;
        goto LABEL_135;
      }

      uint64_t v95 = v642;
      uint64_t v71 = v636;
      goto LABEL_133;
    }

    uint64_t v93 = v635;
    uint64_t v105 = v632;
    if (DWORD2(v660) <= 2)
    {
      if (DWORD2(v660) == 2)
      {
        if (!(_DWORD)v68) {
          goto LABEL_545;
        }
        int v107 = *(unsigned __int8 *)(v660 + 1);
        unsigned int v108 = *(unsigned __int8 *)v661;
        goto LABEL_128;
      }

      if (DWORD2(v660) != 1)
      {
        uint64_t v635 = v100 + 1;
LABEL_549:
        id v538 = sub_100070554();
        int v539 = _NRLogIsLevelEnabled(v538, 16LL);

        if (v539)
        {
          id v540 = sub_100070554();
          v541 = (void *)createIOVecString(&v660, (unsigned __int16)v635);
          _NRLogWithArgs( v540,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[0].len == 1; %@",
            "",
            "nrReadTLVLenHBOFromIOVec",
            269LL,
            v541);
        }

        uint64_t v542 = _os_log_pack_size(22LL);
        v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v543 = *__error();
        uint64_t v544 = _os_log_pack_fill( v382,  v542,  v543,  &_mh_execute_header,  "%{public}s Assertion Failed: ioVecs[0].len == 1; %@");
        goto LABEL_576;
      }

      if (DWORD2(v661) <= 1)
      {
        if (v68 < 2)
        {
          uint64_t v635 = v100 + 1;
LABEL_569:
          id v581 = sub_100070554();
          int v582 = _NRLogIsLevelEnabled(v581, 16LL);

          if (v582)
          {
            id v583 = sub_100070554();
            v584 = (void *)createIOVecString(&v660, (unsigned __int16)v635);
            _NRLogWithArgs( v583,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 2; %@",
              "",
              "nrReadTLVLenHBOFromIOVec",
              274LL,
              v584);
          }

          uint64_t v585 = _os_log_pack_size(22LL);
          v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v586 = *__error();
          uint64_t v544 = _os_log_pack_fill( v382,  v585,  v586,  &_mh_execute_header,  "%{public}s Assertion Failed: numIOVecs > 2; %@");
          goto LABEL_576;
        }

        uint64_t v95 = v642;
        if (DWORD2(v661) != 1)
        {
          uint64_t v635 = v100 + 1;
LABEL_573:
          id v587 = sub_100070554();
          int v588 = _NRLogIsLevelEnabled(v587, 16LL);

          if (v588)
          {
            id v589 = sub_100070554();
            v590 = (void *)createIOVecString(&v660, (unsigned __int16)v635);
            _NRLogWithArgs( v589,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[1].len == 1; %@",
              "",
              "nrReadTLVLenHBOFromIOVec",
              275LL,
              v590);
          }

          uint64_t v591 = _os_log_pack_size(22LL);
          v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v592 = *__error();
          uint64_t v544 = _os_log_pack_fill( v382,  v591,  v592,  &_mh_execute_header,  "%{public}s Assertion Failed: ioVecs[1].len == 1; %@");
LABEL_576:
          uint64_t v558 = v544;
          uint64_t v559 = (unsigned __int16)v635;
LABEL_577:
          uint64_t v580 = createIOVecString(&v660, v559);
          *(_DWORD *)uint64_t v558 = 136446466;
          *(void *)(v558 + 4) = "nrReadTLVLenHBOFromIOVec";
          goto LABEL_578;
        }

        int v107 = *(unsigned __int8 *)v661;
        unsigned int v108 = *(unsigned __int8 *)v662;
        goto LABEL_129;
      }

      if (!(_DWORD)v68) {
        goto LABEL_565;
      }
      unsigned int v106 = *(unsigned __int16 *)v661;
    }

    else
    {
      unsigned int v106 = *(unsigned __int16 *)(v660 + 1);
    }

    int v107 = v106;
    unsigned int v108 = v106 >> 8;
LABEL_128:
    uint64_t v95 = v642;
LABEL_129:
    unsigned int v110 = v107 | (v108 << 8);
    unsigned int v111 = bswap32(v110);
    uint64_t v48 = BYTE2(v111);
    uint64_t v71 = (uint64_t *)HIBYTE(v111);
    if (v632 - 100 < 6 || v632 - 2 < 4)
    {
      unsigned int v112 = 2000;
      goto LABEL_132;
    }

    if (v632 == 1)
    {
      unsigned int v112 = 255;
LABEL_132:
      unsigned int v113 = __rev16(v110);
      if (v113 > v112)
      {
        uint64_t v635 = v100 + 1;
LABEL_450:
        StringFromNRTLVType = (void *)createStringFromNRTLVType(v105);
        id v9 = (id)createIOVecStringWithContents(&v660, (unsigned __int16)v635);
        sub_1000749CC( (void *)v3,  @"LookAhead received invalid TLV len %u for %@ (max=%u) %@",  v364,  v365,  v366,  v367,  v368,  v369,  v113);
LABEL_452:

        goto LABEL_453;
      }
    }

LABEL_133:
    unint64_t v114 = (v48 | ((unint64_t)v71 << 8)) + 5;
    uint64_t v98 = v639;
    uint64_t v101 = *(void *)(v3 + v639);
    if (v114 <= v102)
    {
      uint64_t v58 = v101 | 0x40000;
      *(void *)(v3 + v639) = v58;
      uint64_t v115 = (v102 - v114);
      uint64_t v116 = v100;
      v117 = &v660 + v100;
      int v118 = *((_DWORD *)v117 + 2) - v115;
      *((_DWORD *)v117 + 2) = v118;
      if (!v118)
      {
        unint64_t v404 = v102;
LABEL_481:
        id v405 = sub_100070554();
        char v406 = _NRLogIsLevelEnabled(v405, 16LL);

        if ((v406 & 1) != 0)
        {
          id v407 = sub_100070554();
          v408 = (void *)createIOVecString(&v660, (unsigned __int16)v103);
          int v409 = (unsigned __int16)v642;
          _NRLogWithArgs( v407,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[iovecIndex - 1].len > 0; Shrunk last ioVecs[%u] down by %u t"
            "o 0 - %@ ioVecContentLen=%u alreadyRead=%u",
            "",
            "NRLinkLinkToNexusLoop",
            5440LL,
            v116,
            v115,
            v408,
            v404,
            (unsigned __int16)v642);
        }

        else
        {
          int v409 = (unsigned __int16)v642;
        }

        uint64_t v413 = _os_log_pack_size(46LL);
        v414 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        v415 = __error();
        uint64_t v416 = _os_log_pack_fill( v414,  v413,  *v415,  &_mh_execute_header,  "%{public}s Assertion Failed: ioVecs[iovecIndex - 1].len > 0; Shrunk last ioVecs[%u] down by %u to 0 - %"
                 "@ ioVecContentLen=%u alreadyRead=%u");
        id v417 = (id)createIOVecString(&v660, (unsigned __int16)v103);
        sub_10008BB8C(v416, (uint64_t)"NRLinkLinkToNexusLoop", v116, v115, (uint64_t)v417, v404, v409);

        id v418 = sub_100070554();
        _NRLogAbortWithPack(v418, v414);
LABEL_488:
        id v419 = sub_100070554();
        int v420 = _NRLogIsLevelEnabled(v419, 16LL);

        if (v420)
        {
          id v421 = sub_100070554();
          _NRLogWithArgs( v421,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: curLinkInputSlotPartialBytesAlreadyRead == linkInputBufferLength",  "",  "NRLinkLinkToNexusLoop",  5138);
        }

        goto LABEL_490;
      }

      uint64_t v95 = v91 - v115;
      __int128 v649 = v644;
      __int128 v650 = v645;
      int v109 = 1;
      __int128 v651 = v646;
      __int128 v652 = v647;
      unint64_t v102 = (v48 | ((unint64_t)v71 << 8)) + 5;
      LODWORD(v643) = v91;
      uint64_t v641 = v99;
      uint64_t v629 = v2;
      uint64_t v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      uint64_t v93 = v635;
      goto LABEL_138;
    }

    int v109 = 1;
LABEL_135:
    uint64_t v58 = v101 | 0x80000;
    *(void *)(v3 + v98) = v58;
    uint64_t v629 = v93;
    uint64_t v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
LABEL_138:
    unint64_t v119 = v100 + 2;
    for (i = &v623[16 * v100]; ; i += 16)
    {
      unint64_t v634 = v119 - 1;
      BOOL v121 = v92 != 0;
      v640 = (uint64_t *)v102;
      if ((v109 & 1) != 0
        && ((unint64_t)(unsigned __int16)v71 << 8) + (unsigned __int16)v48 + 5 <= v102)
      {
        LODWORD(v633) = v92 != 0;
        BOOL v64 = 1;
        uint64_t v22 = v639;
        uint64_t v82 = v634;
        uint64_t v94 = v629;
        goto LABEL_109;
      }

      LODWORD(v637) = v109;
      char v122 = v92;
      uint64_t v635 = v119;
      v636 = v71;
      uint64_t v638 = v48;
      uint64_t v642 = v95;
      uint64_t v123 = v2;
      uint64_t v124 = os_channel_get_next_slot(*(void *)(v3 + v97[120]), v2, &v644);
      if (!v124) {
        break;
      }
      uint64_t v125 = v124;
      uint64_t v126 = *(void *)(v3 + v97[120]);
      uint64_t v633 = v125;
      uint64_t v127 = os_channel_slot_get_packet(v126, v125);
      uint64_t v128 = os_packet_get_next_buflet(v127, 0LL);
      uint64_t v129 = v3;
      uint64_t v3 = os_buflet_get_object_address();
      unsigned int v130 = os_buflet_get_data_offset(v128);
      unsigned int v131 = os_buflet_get_data_length(v128);
      if (v131 >= 0x10000) {
        goto LABEL_461;
      }
      unsigned int v132 = v131;
      os_packet_get_flow_uuid(v127, v648);
      if (*(_BYTE *)(v129 + 245))
      {
        *(_BYTE *)(v129 + 245) = 0;
        int v92 = 1;
      }

      else
      {
        int v92 = (v122 != 0) | BYTE2(v648[0]) & 1;
      }

      id v97 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      uint64_t v48 = v638;
      uint64_t v133 = v639;
      uint64_t v96 = v123;
      uint64_t v134 = v3 + v130;
      *((void *)i - 1) = v134;
      uint64_t v3 = v631;
      unint64_t v103 = v635;
      if (!v132) {
        goto LABEL_468;
      }
      *(_DWORD *)i = v132;
      uint64_t v135 = *(void *)(v3 + v133);
      *(void *)(v3 + v133) = v135 | 0x20000;
      unint64_t v102 = v132 + v640;
      if (v637 & 1 | (v102 < 3))
      {
        if ((v637 & 1) == 0)
        {
          uint64_t v58 = v135 | 0xA0000;
          *(void *)(v3 + v133) = v58;
          if (v103 == 16) {
            goto LABEL_479;
          }
          int v109 = 0;
          uint64_t v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          uint64_t v71 = v636;
          uint64_t v2 = v633;
          goto LABEL_142;
        }

        uint64_t v71 = v636;
        goto LABEL_172;
      }

      if (DWORD2(v660) >= 3)
      {
        unsigned int v136 = *(unsigned __int16 *)(v660 + 1);
LABEL_156:
        int v137 = v136;
        unsigned int v138 = v136 >> 8;
        goto LABEL_168;
      }

      if (DWORD2(v660) == 2)
      {
        unsigned int v139 = (unsigned __int8 *)v661;
        int v137 = *(unsigned __int8 *)(v660 + 1);
      }

      else
      {
        if (DWORD2(v660) != 1) {
          goto LABEL_549;
        }
        if (DWORD2(v661) > 1)
        {
          unsigned int v136 = *(unsigned __int16 *)v661;
          goto LABEL_156;
        }

        if (v634 <= 1) {
          goto LABEL_569;
        }
        if (DWORD2(v661) != 1) {
          goto LABEL_573;
        }
        unsigned int v139 = (unsigned __int8 *)v662;
        int v137 = *(unsigned __int8 *)v661;
      }

      unsigned int v138 = *v139;
LABEL_168:
      unsigned int v140 = v137 | (v138 << 8);
      unsigned int v141 = bswap32(v140);
      uint64_t v48 = BYTE2(v141);
      uint64_t v71 = (uint64_t *)HIBYTE(v141);
      if (v632 - 100 < 6 || v632 - 2 < 4)
      {
        unsigned int v142 = 2000;
        goto LABEL_171;
      }

      if (v632 == 1)
      {
        unsigned int v142 = 255;
LABEL_171:
        unsigned int v113 = __rev16(v140);
        if (v113 > v142)
        {
          uint64_t v105 = v632;
          goto LABEL_450;
        }
      }

LABEL_172:
      unint64_t v143 = ((unint64_t)(unsigned __int16)v71 << 8) + (unsigned __int16)v48 + 5;
      uint64_t v22 = v639;
      uint64_t v144 = *(void *)(v3 + v639);
      if (v143 > v102)
      {
        uint64_t v58 = v144 | 0x80000;
        *(void *)(v3 + v639) = v58;
        uint64_t v2 = v633;
        if (v103 == 16)
        {
          BOOL v151 = v143 > v102;
          unint64_t v143 = v102;
          uint64_t v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          unsigned int v149 = v643;
          uint64_t v148 = v629;
          if (v151) {
            goto LABEL_478;
          }
LABEL_193:
          size_t v637 = (unsigned __int16)(v48 | ((_WORD)v71 << 8));
          uint64_t v82 = 16LL;
          LODWORD(v633) = v92 != 0;
          v640 = (uint64_t *)v102;
          if (v637 + 5 <= v143)
          {
            uint64_t v147 = v48 | ((_DWORD)v71 << 8);
            uint64_t v635 = v148;
            uint64_t v95 = v642;
LABEL_195:
            uint64_t v150 = v58 | 0x200000;
            *((void *)&v630 + 1) = v148;
            goto LABEL_196;
          }

LABEL_376:
          uint64_t v276 = v96;
          if (gNRPacketLoggingEnabled)
          {
            unsigned __int16 v333 = v48;
            unsigned __int16 v334 = (unsigned __int16)v71;
            uint64_t v335 = _NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
            unint64_t v634 = v82;
            v336 = (void *)v335;
            int v337 = _NRLogIsLevelEnabled(v335, 1LL);

            LOWORD(v82) = v634;
            if (v337)
            {
              unsigned __int16 v338 = v334;
              v339 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              id v340 = [(id)v3 copyDescription];
              v341 = (void *)createStringFromNRTLVType(v632);
              _NRLogWithArgs( v339,  1LL,  "%s%.30s:%-4d %@: LtN not enough input bytes from linkInputSlot %u to fit %@ tlvLen %u",  "",  "NRLinkLinkToNexusLoop",  5478LL,  v340,  v640,  v341,  v333 | (v338 << 8));

              LOWORD(v82) = v634;
            }
          }

          uint64_t v19 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          if (*(_BYTE *)(v3 + 221) && *(void *)(v3 + 983))
          {
            *(_BYTE *)(v3 + 221) = 0;
            ++*(void *)(v3 + 999);
            if (gNRPacketLoggingEnabled)
            {
              v349 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              int v350 = _NRLogIsLevelEnabled(v349, 1LL);

              if (v350)
              {
                v352 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v351);
                id v353 = [(id)v3 copyDescription];
                _NRLogWithArgs( v352,  1LL,  "%s%.30s:%-4d %@: source-resume: LinkInput",  "",  "NRLinkResumeLinkInputSource",  822LL,  v353);
              }
            }

            dispatch_resume(*(dispatch_object_t *)(v3 + 983));
          }

          if ((v628 > v627) < (unsigned __int16)v82)
          {
            unint64_t v277 = (unsigned __int16)v82 - (unint64_t)(v628 > v627);
            unint64_t v278 = (unsigned int *)&v626[16 * (v628 > v627)];
            do
            {
              if (gNRPacketLoggingEnabled)
              {
                v280 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
                int v281 = _NRLogIsLevelEnabled(v280, 1LL);

                if (v281)
                {
                  v283 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v282);
                  id v284 = [(id)v3 copyDescription];
                  _NRLogWithArgs( v283,  1LL,  "%s%.30s:%-4d %@: partial TLV - consolidating %u bytes from linkInputSlot buf %p to linkReadBuffer fi lledIn=%u handled=%u",  "",  "NRLinkLinkToNexusLoop",  5485LL,  v284,  *v278,  *((void *)v278 - 1),  *(unsigned int *)(v3 + v18[185]),  *(unsigned int *)(v3 + 315));
                }
              }

              memcpy( (void *)(*(void *)(v3 + 1311) + *(unsigned int *)(v3 + v18[185])),  *((const void **)v278 - 1),  *v278);
              unsigned int v279 = *v278;
              v278 += 4;
              *(_DWORD *)(v3 + v18[185]) += v279;
              --v277;
            }

            while (v277);
          }

          *(void *)(v3 + v639) |= 0x100000uLL;
          *((void *)&v630 + 1) = v276;
          goto LABEL_389;
        }

        int v109 = 1;
      }

      else
      {
        uint64_t v58 = v144 | 0x40000;
        *(void *)(v3 + v639) = v58;
        uint64_t v115 = (v102 - v143);
        unsigned int v145 = &v660 + (int)v103 - 1;
        int v146 = *((_DWORD *)v145 + 2) - v115;
        *((_DWORD *)v145 + 2) = v146;
        if (!v146)
        {
          unint64_t v404 = v102;
          uint64_t v116 = (v103 - 1);
          goto LABEL_481;
        }

        uint64_t v642 = v132 - v115;
        __int128 v649 = v644;
        __int128 v650 = v645;
        __int128 v651 = v646;
        __int128 v652 = v647;
        if (v103 == 16)
        {
          uint64_t v148 = v633;
          uint64_t v641 = v134;
          unsigned int v149 = v132;
          unint64_t v102 = ((unint64_t)(unsigned __int16)v71 << 8) + (unsigned __int16)v48 + 5;
          uint64_t v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          goto LABEL_193;
        }

        int v109 = 1;
        uint64_t v2 = v633;
        uint64_t v629 = v633;
        uint64_t v641 = v134;
        LODWORD(v643) = v132;
        unint64_t v102 = ((unint64_t)(unsigned __int16)v71 << 8) + (unsigned __int16)v48 + 5;
      }

      uint64_t v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
LABEL_142:
      unint64_t v119 = v103 + 1;
      uint64_t v93 = v96;
      uint64_t v95 = v642;
    }

    LODWORD(v633) = v121;
    BOOL v64 = 1;
    uint64_t v635 = v629;
    uint64_t v22 = v639;
    uint64_t v96 = v123;
LABEL_179:
    uint64_t v58 = *(void *)(v3 + v22) | 0x10000LL;
    *(void *)(v3 + v22) = v58;
    uint64_t v95 = v642;
    uint64_t v82 = v634;
    LODWORD(v48) = v638;
    LODWORD(v71) = (_DWORD)v636;
    if ((v637 & 1) == 0) {
      goto LABEL_376;
    }
LABEL_180:
    unint64_t v143 = v640;
    uint64_t v147 = v48 | ((_DWORD)v71 << 8);
    size_t v637 = (unsigned __int16)(v48 | ((_WORD)v71 << 8));
    if (v64)
    {
      uint64_t v148 = v635;
      unsigned int v149 = v643;
      goto LABEL_195;
    }

    uint64_t v150 = v58 | 0x400000;
    unsigned int v149 = v643;
LABEL_196:
    LODWORD(v643) = v149;
    uint64_t v642 = v95;
    *(void *)(v3 + v22) = v150;
    *(void *)(v3 + 1375) += v143;
    unint64_t v634 = v82;
    uint64_t v638 = v147;
    if ((char)v632 < 100)
    {
      if (!(_WORD)v82)
      {
        id v436 = sub_100070554();
        int v437 = _NRLogIsLevelEnabled(v436, 16LL);

        if (v437)
        {
          id v438 = sub_100070554();
          _NRLogWithArgs( v438,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 0",  "",  "nrChecksumIOVecInner",  143);
        }

        uint64_t v439 = _os_log_pack_size(12LL);
        v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        v440 = __error();
        uint64_t v393 = _os_log_pack_fill( v382,  v439,  *v440,  &_mh_execute_header,  "%{public}s Assertion Failed: numIOVecs > 0");
        *(_DWORD *)uint64_t v393 = 136446210;
        v396 = "nrChecksumIOVecInner";
        goto LABEL_476;
      }

      LODWORD(v629) = (unsigned __int16)v82;
      v636 = &v621;
      uint64_t v162 = 0LL;
      uint64_t v3 = 0LL;
      int v163 = 0;
      uint64_t v164 = 0LL;
      unsigned int v165 = (unsigned __int16)v147 + 3;
      uint64_t v166 = (unsigned __int16)v82;
      v167 = (unsigned int *)v626;
      while (1)
      {
        unsigned int v168 = v165 - v3;
        if (v165 <= v3)
        {
          uint64_t v169 = 0LL;
          goto LABEL_233;
        }

        if (*v167 >= v168) {
          uint64_t v169 = v168;
        }
        else {
          uint64_t v169 = *v167;
        }
        if (!(_DWORD)v169)
        {
          id v377 = sub_100070554();
          int v378 = _NRLogIsLevelEnabled(v377, 16LL);

          v379 = "nrChecksumUpdate";
          if (v378)
          {
            id v380 = sub_100070554();
            _NRLogWithArgs( v380,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: dataLen > 0",  "",  "nrChecksumUpdate",  69);
          }

          uint64_t v381 = _os_log_pack_size(12LL);
          v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v383 = *__error();
          uint64_t v384 = _os_log_pack_fill(v382, v381, v383, &_mh_execute_header, "%{public}s Assertion Failed: dataLen > 0");
          goto LABEL_459;
        }

        v170 = (unsigned __int8 *)*((void *)v167 - 1);
        if (v163)
        {
          LOWORD(v644) = *v170 << 8;
          uint64_t v164 = os_inet_checksum(&v644, 2LL, v164);
          v171 = v170 + 1;
          uint64_t v172 = (v169 - 1);
        }

        else
        {
          v171 = (unsigned __int8 *)*((void *)v167 - 1);
          uint64_t v172 = v169;
        }

        uint64_t v164 = os_inet_checksum(v171, v172, v164);
LABEL_221:
        if ((v169 & 1) != 0) {
          v163 ^= 1u;
        }
        uint64_t v3 = (v169 + v3);
        ++v162;
        v167 += 4;
        if (v166 == v162)
        {
          LOWORD(v162) = v634;
LABEL_233:
          uint64_t v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          if ((_DWORD)v3 == v165)
          {
            uint64_t v174 = (unsigned __int16)v162;
            unsigned int v175 = ~(_BYTE)v164;
            uint64_t v3 = ((unsigned __int16)~(_WORD)v164 >> 8);
            uint64_t v176 = &v660 + (unsigned __int16)v162;
            unsigned int v177 = *((_DWORD *)v176 + 2);
            if (v177 < (int)v169 + 2)
            {
              unsigned __int16 v173 = v634;
              if (v177 < (int)v169 + 1)
              {
                id v468 = sub_100070554();
                int v469 = _NRLogIsLevelEnabled(v468, 16LL);

                if (v469)
                {
                  id v470 = sub_100070554();
                  v471 = (void *)createIOVecString(&v660, v173);
                  _NRLogWithArgs( v470,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: iovecs[iovecIndex].len >= bytesToCheckThisIOVec + 1; %@, io"
                    "vecIndex=%u bytesToCheckThisIOVec=%u",
                    "",
                    "nrChecksumIOVecInner",
                    189LL,
                    v471,
                    v174,
                    v169);
                }

                uint64_t v472 = _os_log_pack_size(34LL);
                v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                v473 = __error();
                uint64_t v474 = _os_log_pack_fill( v382,  v472,  *v473,  &_mh_execute_header,  "%{public}s Assertion Failed: iovecs[iovecIndex].len >= bytesToCheckThisIOVec + 1; %@, iovecInde"
                         "x=%u bytesToCheckThisIOVec=%u");
                v475 = (void *)createIOVecString(&v660, v173);
              }

              else if ((unsigned __int16)v162 + 1 >= v629)
              {
                id v476 = sub_100070554();
                int v477 = _NRLogIsLevelEnabled(v476, 16LL);

                if (v477)
                {
                  id v478 = sub_100070554();
                  v479 = (void *)createIOVecString(&v660, v173);
                  _NRLogWithArgs( v478,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: iovecIndex + 1 < numIOVecs; %@, iovecIndex=%u bytesToCheckThisIOVec=%u",
                    "",
                    "nrChecksumIOVecInner",
                    191LL,
                    v479,
                    v174,
                    v169);
                }

                uint64_t v480 = _os_log_pack_size(34LL);
                v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                v481 = __error();
                uint64_t v474 = _os_log_pack_fill( v382,  v480,  *v481,  &_mh_execute_header,  "%{public}s Assertion Failed: iovecIndex + 1 < numIOVecs; %@, iovecIndex=%u bytesToCheckThisIOVec=%u");
                v475 = (void *)createIOVecString(&v660, v173);
              }

              else
              {
                uint64_t v178 = (unsigned __int8 **)(&v660 + (unsigned __int16)v162 + 1);
                if (*((_DWORD *)v178 + 2))
                {
                  if (*(unsigned __int8 *)(*(void *)v176 + v169) != v175 || **v178 != (_DWORD)v3)
                  {
                    id v489 = sub_100070554();
                    int v490 = _NRLogIsLevelEnabled(v489, 16LL);

                    LOWORD(v20) = v642;
                    if (v490)
                    {
                      id v467 = sub_100070554();
                      _NRLogWithArgs( v467,  16LL,  "%s%.30s:%-4d checksum failed disjoint IOVec received 0x%02x%02x != computed 0x%02x%02x",  "");
LABEL_526:
                    }

                    goto LABEL_527;
                  }

                  goto LABEL_242;
                }

                id v482 = sub_100070554();
                int v483 = _NRLogIsLevelEnabled(v482, 16LL);

                if (v483)
                {
                  id v484 = sub_100070554();
                  v485 = (void *)createIOVecString(&v660, v173);
                  _NRLogWithArgs( v484,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: iovecs[iovecIndex + 1].len >= 1; %@, iovecIndex=%u bytesToC"
                    "heckThisIOVec=%u",
                    "",
                    "nrChecksumIOVecInner",
                    193LL,
                    v485,
                    v174,
                    v169);
                }

                uint64_t v486 = _os_log_pack_size(34LL);
                v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                v487 = __error();
                uint64_t v474 = _os_log_pack_fill( v382,  v486,  *v487,  &_mh_execute_header,  "%{public}s Assertion Failed: iovecs[iovecIndex + 1].len >= 1; %@, iovecIndex=%u bytesToCheckThisIOVec=%u");
                v475 = (void *)createIOVecString(&v660, v173);
              }

              id v488 = v475;
              sub_100043200(v474, (uint64_t)"nrChecksumIOVecInner", (uint64_t)v488, v174, v169);

              goto LABEL_477;
            }

            unsigned __int16 v173 = v634;
            if (__PAIR64__( *(unsigned __int8 *)(*(void *)v176 + v169 + 1LL),  *(unsigned __int8 *)(*(void *)v176 + v169)) != __PAIR64__(v3, v175))
            {
              id v465 = sub_100070554();
              int v466 = _NRLogIsLevelEnabled(v465, 16LL);

              LOWORD(v20) = v642;
              if (v466)
              {
                id v467 = sub_100070554();
                _NRLogWithArgs( v467,  16LL,  "%s%.30s:%-4d checksum failed same IOVec received 0x%02x%02x != computed 0x%02x%02x",  "");
                goto LABEL_526;
              }

LABEL_527:
              uint64_t v3 = v631;
              unsigned __int16 v173 = v634;
LABEL_528:
              unsigned __int16 v491 = v173;
              v492 = *(id *)(v3 + 1863);
              if (v492) {
                v492[97] = 1;
              }

              v494 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v493);
              char v495 = _NRLogIsLevelEnabled(v494, 17LL);

              if ((v495 & 1) != 0)
              {
                uint64_t v639 = _NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v496);
                size_t v637 = (size_t)[(id)v3 copyDescription];
                uint64_t v497 = createStringFromNRTLVType(v632);
                unsigned __int16 v498 = v638;
                uint64_t v643 = (unsigned __int16)v638;
                v636 = (uint64_t *)*(unsigned int *)(v3 + v18[185]);
                uint64_t v499 = *(unsigned int *)(v3 + 315);
                v500 = (void *)createIOVecString(&v660, v491);
                uint64_t v641 = (unsigned __int16)v20;
                uint64_t v620 = (unsigned __int16)v20;
                uint64_t v619 = v498;
                v501 = (void *)v497;
                uint64_t v618 = v497;
                v502 = (void *)v637;
                v503 = (void *)v639;
                _NRLogWithArgs( v639,  17LL,  "%@: Invalid checksum detected in loop on read type %@ len %u filledIn=%u handled=%u in %@ ioVecContent Len=%u alreadyRead=%u curLinkInputSlot=%p",  v637,  v618,  v619,  v636,  v499,  v500,  v640,  v620,  v635);

                uint64_t v504 = v632;
              }

              else
              {
                uint64_t v643 = (unsigned __int16)v638;
                uint64_t v641 = (unsigned __int16)v20;
                uint64_t v504 = v632;
              }

              v505 = (void *)createStringFromNRTLVType(v504);
              v506 = (void *)createIOVecString(&v660, v491);
              sub_1000749CC( (void *)v3,  @"Invalid checksum detected in loop on read type %@ len %u filledIn=%u handled=%u in %@ ioVecContentLen=%u alreadyRead=%u curLinkInputSlot=%p",  v507,  v508,  v509,  v510,  v511,  v512,  (uint64_t)v505);

              goto LABEL_454;
            }

LABEL_200:
        v152 += 16LL;
        if (v157 == v152) {
          goto LABEL_230;
        }
        continue;
      }

      break;
    }

    unsigned int v160 = v159 - v158;
    else {
      size_t v161 = v160;
    }
    memcpy((char *)&v644 + v153, (const void *)(*(void *)((char *)&v660 + v152) + v158), v161);
    uint64_t v153 = (v161 + v153);
    if (v153 <= 1)
    {
      unsigned int v158 = 0;
      goto LABEL_200;
    }

LABEL_230:
    uint64_t v3 = v631;
    if ((_DWORD)v153 != 2)
    {
      id v441 = sub_100070554();
      int v442 = _NRLogIsLevelEnabled(v441, 16LL);

      unsigned __int16 v443 = v634;
      v444 = v636;
      if (v442)
      {
        id v445 = sub_100070554();
        v446 = (void *)createIOVecString(&v660, v443);
        _NRLogWithArgs( v445,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@",
          "",
          "nrWriteIOVecToBuffer",
          342LL,
          v153,
          2LL,
          v444,
          v446);
      }

      uint64_t v447 = _os_log_pack_size(40LL);
      v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      v448 = __error();
      uint64_t v449 = _os_log_pack_fill( v382,  v447,  *v448,  &_mh_execute_header,  "%{public}s Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@");
      id v450 = (id)createIOVecString(&v660, v443);
      sub_1000431C4(v449, (uint64_t)"nrWriteIOVecToBuffer", v153, 2, (int)v444, (uint64_t)v450);

      goto LABEL_477;
    }

    BOOL v79 = (unsigned __int16)v644 == (unsigned __int16)(v155 | (unsigned __int16)((_WORD)v156 << 8));
    uint64_t v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
    uint64_t v20 = v642;
    unsigned __int16 v173 = v634;
    if (!v79) {
      goto LABEL_528;
    }
LABEL_243:
    uint64_t v179 = os_channel_get_next_slot(*(void *)(v3 + 383), v630, &v644);
    uint64_t v19 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
    if (v179) {
      break;
    }
    uint64_t v187 = v639;
    uint64_t v21 = v643;
    if (*(_BYTE *)(v3 + 213) && *(void *)(v3 + 399))
    {
      *(_BYTE *)(v3 + 213) = 0;
      ++*(void *)(v3 + 423);
      if (gNRPacketLoggingEnabled)
      {
        int v263 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
        LODWORD(v640) = _NRLogIsLevelEnabled(v263, 1LL);

        uint64_t v21 = v643;
        if ((_DWORD)v640)
        {
          v265 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v264);
          v640 = (uint64_t *)[(id)v3 copyDescription];
          _NRLogWithArgs( v265,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusOutput",  "",  "NRLinkResumeNexusOutputSource",  843LL,  v640);

          uint64_t v21 = v643;
        }
      }

      dispatch_resume(*(dispatch_object_t *)(v3 + 399));
    }

    unsigned int v188 = v628;
    unsigned int v189 = v627;
    unsigned int v190 = v628 > v627;
    uint64_t v191 = *(void *)(v3 + v187) | 0x800000LL;
    *(void *)(v3 + v187) = v191;
    if (v190 < v173)
    {
      uint64_t v192 = v188 > v189;
      uint64_t v193 = v173;
      v194 = (unsigned int *)&v626[16 * v192];
      do
      {
        if (gNRPacketLoggingEnabled)
        {
          unsigned int v198 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
          int v199 = _NRLogIsLevelEnabled(v198, 1LL);

          uint64_t v21 = v643;
          if (v199)
          {
            uint64_t v201 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v200);
            id v202 = [(id)v3 copyDescription];
            _NRLogWithArgs( v201,  1LL,  "%s%.30s:%-4d %@: no nexusOutputSlot - consolidating %u bytes from linkInputSlot ioVecs[%u].buf=%p to linkR eadBuffer filledIn=%u handled=%u",  "",  "NRLinkLinkToNexusLoop",  5549LL,  v202,  *v194,  v192,  *((void *)v194 - 1),  *(unsigned int *)(v3 + v18[185]),  *(unsigned int *)(v3 + 315));

            uint64_t v21 = v643;
          }
        }

        uint64_t v195 = *(unsigned int *)(v3 + v18[185]);
        size_t v196 = *v194;
        if ((v196 + v195) >= *(_DWORD *)(v3 + 263))
        {
          *(void *)(v3 + v187) |= 0x1000000uLL;
          StringFromNRTLVType = (void *)createIOVecString(&v660, (unsigned __int16)v634);
          sub_1000749CC( (void *)v3,  @"no nexusOutputSlot and linkReadBuffer is full %@ filledIn=%u handled=%u",  v385,  v386,  v387,  v388,  v389,  v390,  (uint64_t)StringFromNRTLVType);
          goto LABEL_453;
        }

        memcpy((void *)(*(void *)(v3 + 1311) + v195), *((const void **)v194 - 1), v196);
        unsigned int v197 = *v194;
        v194 += 4;
        *(_DWORD *)(v3 + v18[185]) += v197;
        ++v192;
      }

      while (v193 != v192);
      uint64_t v191 = *(void *)(v3 + v187);
      uint64_t v19 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      uint64_t v20 = v642;
      unsigned __int16 v173 = v634;
      unsigned int v188 = v628;
      unsigned int v189 = v627;
    }

    if (v188 > v189 && v173 == 1)
    {
      *(void *)(v3 + v187) = v191 | 0x2000000;
      if ((_WORD)v20 && (unsigned __int16)v21 > (unsigned __int16)v20)
      {
        unsigned __int16 v306 = v21 - v20;
        if (gNRPacketLoggingEnabled)
        {
          v359 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
          int v360 = _NRLogIsLevelEnabled(v359, 1LL);

          if (v360)
          {
            v362 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v361);
            id v363 = [(id)v3 copyDescription];
            _NRLogWithArgs( v362,  1LL,  "%s%.30s:%-4d %@: no nexusOutputSlot - tail consolidating %u bytes from linkInputSlot to linkReadBuffer fil ledIn=%u handled=%u and marking curLinkInputSlot=%p as completed",  "",  "NRLinkLinkToNexusLoop",  5583LL,  v363,  v306,  *(unsigned int *)(v3 + v18[185]),  *(unsigned int *)(v3 + 315),  v635);
          }
        }

        memcpy( (void *)(*(void *)(v3 + 1311) + *(unsigned int *)(v3 + v18[185])),  (const void *)(v641 + (unsigned __int16)v20),  v306);
        *(_DWORD *)(v3 + v18[185]) += v306;
        *((void *)&v630 + 1) = v635;
      }

      goto LABEL_389;
    }

    *(void *)(v3 + v187) = v191 | 0x4000000;
    *((void *)&v630 + 1) = v635;
  }

  uint64_t v180 = v179;
  uint64_t v181 = v639;
  if (v628 > v627)
  {
    if (gNRPacketLoggingEnabled)
    {
      int v253 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
      int v254 = _NRLogIsLevelEnabled(v253, 1LL);

      uint64_t v19 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      if (v254)
      {
        v255 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
        id v256 = [(id)v3 copyDescription];
        _NRLogWithArgs( v255,  1LL,  "%s%.30s:%-4d %@: Advancing linkReadBuffer handled by %u handled=%u filledIn=%u",  "",  "NRLinkLinkToNexusLoop",  5605LL,  v256,  DWORD2(v660),  *(unsigned int *)(v3 + 315),  *(unsigned int *)(v3 + v18[185]));

        uint64_t v19 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      }
    }

    *(_DWORD *)(v3 + v19[186]) += DWORD2(v660);
    uint64_t v20 = v642;
  }

  uint64_t v182 = &OBJC_IVAR___NRLinkBluetooth__recvUncompressedIP;
  switch(v632)
  {
    case 1u:
      v183 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
      int v184 = _NRLogIsLevelEnabled(v183, 1LL);

      if (v184)
      {
        id v185 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
        id v186 = [(id)v3 copyDescription];
        _NRLogWithArgs( v185,  1LL,  "%s%.30s:%-4d %@: Handling PadN %u",  "",  "NRLinkLinkToNexusLoop",  5634LL,  v186,  (unsigned __int16)v638);
      }

      goto LABEL_306;
    case 2u:
      goto LABEL_291;
    case 3u:
      uint64_t v182 = &OBJC_IVAR___NRLinkBluetooth__recvEncapsulated6LoWPAN;
      goto LABEL_291;
    case 4u:
      v640 = &v621;
      if (!(_WORD)v638)
      {
        int v246 = objc_alloc_init(&OBJC_CLASS___NSData);
LABEL_340:
        uint64_t v181 = v639;
        uint64_t v19 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
        if ((v633 & 1) != 0)
        {
          -[NSData bytes](v246, "bytes");
          -[NSData length](v246, "length");
          if (qword_1001DC9E8 != -1) {
            dispatch_once(&qword_1001DC9E8, &stru_1001AFB78);
          }
          id v247 = (dispatch_queue_s *)(id)qword_1001DC9E0;
          v653 = _NSConcreteStackBlock;
          uint64_t v654 = 3221225472LL;
          v655 = sub_10008BBD0;
          v656 = &unk_1001B0578;
          unint64_t v657 = 0LL;
          dispatch_async(v247, &v653);
        }

        *(void *)(v3 + v181) |= 0x20000000uLL;
        sub_10008BC7C(v3, v246);

        LODWORD(v633) = 0;
LABEL_306:
        *(void *)(v3 + v181) |= 0x40000000uLL;
        if (*(void *)(v3 + 1871))
        {
          uint64_t v21 = v643;
          if (*(void *)(v3 + 1879))
          {
            *(_BYTE *)(v3 + 251) %= *(_BYTE *)(v3 + 250);
            uint64_t v230 = *(void *)(v3 + 1879);
            v231 = (void *)(v230 + 8LL * *(unsigned __int8 *)(v3 + 251));
            if ((unint64_t)(v231 + 1) <= v230 + 8 * (unint64_t)*(unsigned __int8 *)(v3 + 250))
            {
              if ((v231 & 7) == 0)
              {
                void *v231 = *(void *)(v3 + 1871);
                ++*(_BYTE *)(v3 + 251);
                *(void *)(v3 + 1871) = 0LL;
              }
            }

            else
            {
              id v232 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              int v233 = _NRLogIsLevelEnabled(v232, 17LL);

              if (v233)
              {
                int v56 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
                id v57 = [(id)v3 copyDescription];
                _NRLogWithArgs( v56,  17LL,  "%@: invalid index for link log list (curIdx: %u)",  v57,  *(unsigned __int8 *)(v3 + 251));
LABEL_311:

                uint64_t v21 = v643;
              }

              else
              {
                uint64_t v21 = v643;
              }
            }
          }
        }

        else
        {
          uint64_t v21 = v643;
        }

        goto LABEL_16;
      }

      int v203 = (char *)malloc(v637);
      if (!v203)
      {
        id v560 = sub_100070554();
        int v561 = _NRLogIsLevelEnabled(v560, 16LL);

        if (v561)
        {
          id v562 = sub_100070554();
          _NRLogWithArgs(v562, 16LL, "%s%.30s:%-4d ABORTING: strict_malloc(%zu) failed", "", "strict_malloc", 79, v637);
        }

LABEL_584:
        uint64_t v601 = _os_log_pack_size(22LL);
        v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        v602 = __error();
        uint64_t v603 = _os_log_pack_fill( v382,  v601,  *v602,  &_mh_execute_header,  "%{public}s strict_malloc(%zu) failed");
        *(_DWORD *)uint64_t v603 = 136446466;
        *(void *)(v603 + 4) = "strict_malloc";
        *(_WORD *)(v603 + 12) = 2048;
        *(void *)(v603 + 14) = v637;
        goto LABEL_477;
      }

      if (!v173)
      {
LABEL_494:
        id v431 = sub_100070554();
        int v432 = _NRLogIsLevelEnabled(v431, 16LL);

        if (v432)
        {
          id v433 = sub_100070554();
          _NRLogWithArgs( v433,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 0",  "",  "nrWriteIOVecToBuffer",  313);
        }

        uint64_t v434 = _os_log_pack_size(12LL);
        v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        v435 = __error();
        uint64_t v393 = _os_log_pack_fill( v382,  v434,  *v435,  &_mh_execute_header,  "%{public}s Assertion Failed: numIOVecs > 0");
        *(_DWORD *)uint64_t v393 = 136446210;
        v396 = "nrWriteIOVecToBuffer";
        goto LABEL_476;
      }

      uint64_t v204 = v203;
      unsigned __int16 v205 = v173;
      uint64_t v206 = 0LL;
      uint64_t v207 = 0LL;
      unint64_t v103 = (unsigned __int16)v638;
      uint64_t v208 = 16LL * v205;
      unsigned int v209 = 3;
      while (1)
      {
        unsigned int v210 = *(_DWORD *)((char *)&v660 + v206 + 8);
        if (!v209) {
          break;
        }
        if (v209 <= v210)
        {
          if (v209 >= v210)
          {
            unsigned int v209 = 0;
            goto LABEL_271;
          }

          break;
        }

        v209 -= v210;
LABEL_271:
        v206 += 16LL;
        if (v208 == v206) {
          goto LABEL_338;
        }
      }

      unsigned int v211 = v210 - v209;
      else {
        size_t v212 = v211;
      }
      memcpy(&v204[v207], (const void *)(*(void *)((char *)&v660 + v206) + v209), v212);
      uint64_t v207 = (v212 + v207);
      if (v207 < v103)
      {
        unsigned int v209 = 0;
        uint64_t v20 = v642;
        goto LABEL_271;
      }

      uint64_t v20 = v642;
LABEL_338:
      uint64_t v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      if ((_DWORD)v207 == (_DWORD)v103)
      {
        id v245 = objc_alloc(&OBJC_CLASS___NSData);
        int v246 = -[NSData initWithBytesNoCopy:length:freeWhenDone:]( v245,  "initWithBytesNoCopy:length:freeWhenDone:",  v204,  v637,  1LL);
        goto LABEL_340;
      }

      id v563 = sub_100070554();
      int v564 = _NRLogIsLevelEnabled(v563, 16LL);

      if (v564)
      {
        id v565 = sub_100070554();
        v566 = (void *)createIOVecString(&v660, (unsigned __int16)v634);
        _NRLogWithArgs( v565,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@",
          "",
          "nrWriteIOVecToBuffer",
          342LL,
          v207,
          v103,
          3LL,
          v566);
      }

      uint64_t v567 = _os_log_pack_size(40LL);
      v568 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      v569 = __error();
      uint64_t v570 = _os_log_pack_fill( v568,  v567,  *v569,  &_mh_execute_header,  "%{public}s Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@");
      id v571 = (id)createIOVecString(&v660, (unsigned __int16)v634);
      sub_1000431C4(v570, (uint64_t)"nrWriteIOVecToBuffer", v207, v103, 3, (uint64_t)v571);

      id v572 = sub_100070554();
      _NRLogAbortWithPack(v572, v568);
LABEL_565:
      unint64_t v573 = v103;
      id v574 = sub_100070554();
      int v575 = _NRLogIsLevelEnabled(v574, 16LL);

      if (v575)
      {
        id v576 = sub_100070554();
        v577 = (void *)createIOVecString(&v660, v573);
        _NRLogWithArgs( v576,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 1; %@",
          "",
          "nrReadTLVLenHBOFromIOVec",
          271LL,
          v577);
      }

      uint64_t v578 = _os_log_pack_size(22LL);
      v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      v579 = __error();
      uint64_t v558 = _os_log_pack_fill( v382,  v578,  *v579,  &_mh_execute_header,  "%{public}s Assertion Failed: numIOVecs > 1; %@");
      uint64_t v580 = createIOVecString(&v660, v573);
      *(_DWORD *)uint64_t v558 = 136446466;
      *(void *)(v558 + 4) = "nrReadTLVLenHBOFromIOVec";
LABEL_578:
      *(_WORD *)(v558 + 12) = 2112;
      *(void *)(v558 + 14) = v580;
LABEL_477:
      id v397 = sub_100070554();
      _NRLogAbortWithPack(v397, v382);
LABEL_478:
      v636 = v71;
      uint64_t v638 = v48;
LABEL_479:
      StringFromNRTLVType = (void *)createIOVecStringWithContents(&v660, 16LL);
      sub_1000749CC( (void *)v3,  @"LtN not enough ioVecs %@ for %u",  v398,  v399,  v400,  v401,  v402,  v403,  (uint64_t)StringFromNRTLVType);
LABEL_453:

LABEL_454:
      return;
    case 5u:
      if (v173 != 1 || DWORD2(v660) < 5 || HIWORD(DWORD2(v660)))
      {
        if (!v637)
        {
          id v593 = sub_100070554();
          int v594 = _NRLogIsLevelEnabled(v593, 16LL);

          if (v594)
          {
            id v595 = sub_100070554();
            _NRLogWithArgs( v595,  16LL,  "%s%.30s:%-4d ABORTING: strict_malloc called with size 0",  "",  "strict_malloc",  74);
          }

          uint64_t v596 = _os_log_pack_size(12LL);
          v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          v597 = __error();
          uint64_t v393 = _os_log_pack_fill( v382,  v596,  *v597,  &_mh_execute_header,  "%{public}s strict_malloc called with size 0");
          *(_DWORD *)uint64_t v393 = 136446210;
          v396 = "strict_malloc";
          goto LABEL_476;
        }

        int v234 = (unsigned __int8 *)malloc(v637);
        if (!v234)
        {
          id v598 = sub_100070554();
          int v599 = _NRLogIsLevelEnabled(v598, 16LL);

          if (v599)
          {
            id v600 = sub_100070554();
            _NRLogWithArgs( v600,  16LL,  "%s%.30s:%-4d ABORTING: strict_malloc(%zu) failed",  "",  "strict_malloc",  79,  v637);
          }

          goto LABEL_584;
        }

        id v235 = v234;
        v640 = &v621;
        uint64_t v236 = (unsigned __int16)v638;
        if ((_WORD)v638)
        {
          if (!v173) {
            goto LABEL_494;
          }
          unsigned __int16 v237 = v173;
          uint64_t v238 = 0LL;
          uint64_t v239 = 0LL;
          uint64_t v240 = 16LL * v237;
          unsigned int v241 = 3;
          while (2)
          {
            unsigned int v242 = *(_DWORD *)((char *)&v660 + v238 + 8);
            if (v241)
            {
              if (v241 > v242)
              {
                v241 -= v242;
              }

              else
              {
                if (v241 < v242) {
                  goto LABEL_331;
                }
                unsigned int v241 = 0;
              }
            }

            else
            {
LABEL_331:
              unsigned int v243 = v242 - v241;
              else {
                size_t v244 = v243;
              }
              memcpy(&v235[v239], (const void *)(*(void *)((char *)&v660 + v238) + v241), v244);
              uint64_t v239 = (v244 + v239);
              if (v239 >= v236)
              {
                uint64_t v19 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
LABEL_346:
                if ((_DWORD)v239 == (_DWORD)v236)
                {
                  sub_10008BFD0((void *)v3, v235, (unsigned __int16)v638);
                  uint64_t v20 = v642;
                  goto LABEL_348;
                }

                id v604 = sub_100070554();
                int v605 = _NRLogIsLevelEnabled(v604, 16LL);

                if (v605)
                {
                  id v606 = sub_100070554();
                  v607 = (void *)createIOVecString(&v660, (unsigned __int16)v634);
                  _NRLogWithArgs( v606,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), o"
                    "ffset: %u, ioVec: %@",
                    "",
                    "nrWriteIOVecToBuffer",
                    342LL,
                    v239,
                    v236,
                    3LL,
                    v607);
                }

                uint64_t v608 = _os_log_pack_size(40LL);
                v428 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                v609 = __error();
                uint64_t v610 = _os_log_pack_fill( v428,  v608,  *v609,  &_mh_execute_header,  "%{public}s Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@");
                id v611 = (id)createIOVecString(&v660, (unsigned __int16)v634);
                sub_1000431C4(v610, (uint64_t)"nrWriteIOVecToBuffer", v239, v236, 3, (uint64_t)v611);

LABEL_544:
                id v532 = sub_100070554();
                _NRLogAbortWithPack(v532, v428);
LABEL_545:
                id v533 = sub_100070554();
                int v534 = _NRLogIsLevelEnabled(v533, 16LL);

                if (v534)
                {
                  id v535 = sub_100070554();
                  _NRLogWithArgs( v535,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 1",  "",  "nrReadTLVLenHBOFromIOVec",  265);
                }

                uint64_t v536 = _os_log_pack_size(12LL);
                v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                v537 = __error();
                uint64_t v393 = _os_log_pack_fill( v382,  v536,  *v537,  &_mh_execute_header,  "%{public}s Assertion Failed: numIOVecs > 1");
                *(_DWORD *)uint64_t v393 = 136446210;
                v396 = "nrReadTLVLenHBOFromIOVec";
LABEL_476:
                *(void *)(v393 + 4) = v396;
                goto LABEL_477;
              }

              unsigned int v241 = 0;
              uint64_t v19 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            }

            v238 += 16LL;
            if (v240 == v238) {
              goto LABEL_346;
            }
            continue;
          }
        }

LABEL_348:
        free(v235);
        uint64_t v181 = v639;
      }

      else
      {
        sub_10008BFD0((void *)v3, (unsigned __int8 *)(v660 + 3), (unsigned __int16)(WORD4(v660) - 5));
      }

      goto LABEL_306;
    case 0x64u:
      uint64_t v182 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_ESP;
      goto LABEL_291;
    case 0x65u:
      uint64_t v182 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_ESP_ECT0;
      goto LABEL_291;
    case 0x66u:
      uint64_t v182 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_TCP;
      goto LABEL_291;
    case 0x67u:
      uint64_t v182 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_TCP_ECT0;
      goto LABEL_291;
    case 0x68u:
      uint64_t v182 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_ESP_ClassC;
      goto LABEL_291;
    case 0x69u:
      uint64_t v182 = &OBJC_IVAR___NRLinkBluetooth__recvKnownIPv6Hdr_ESP_ClassC_ECT0;
LABEL_291:
      ++*(void *)(v3 + *v182);
      uint64_t v213 = nrTLVToPacket(&v660, v173, v632, (unsigned __int16)v638, v645, WORD1(v644), v3 + 1967, v3 + 1951);
      if ((_DWORD)v213)
      {
        unsigned int v215 = v213;
        *(void *)(v3 + v181) |= 0x8000000uLL;
        WORD1(v644) = v213;
        if (gNRPacketLoggingEnabled)
        {
          uint64_t ESPSequenceNumberFromPacket = getESPSequenceNumberFromPacket(v645, v213);
          if (gNRPacketLoggingEnabled)
          {
            int v258 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v257);
            int v259 = _NRLogIsLevelEnabled(v258, 1LL);

            if (v259)
            {
              uint64_t v261 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v260);
              id v262 = [(id)v3 copyDescription];
              _NRLogWithArgs( v261,  1LL,  "%s%.30s:%-4d %@: Received ESP sequence number: %u",  "",  "NRLinkLinkToNexusLoop",  5661LL,  v262,  ESPSequenceNumberFromPacket);
            }
          }

          uint64_t v19 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          uint64_t v181 = v639;
          uint64_t v20 = v642;
        }

        else
        {
          uint64_t ESPSequenceNumberFromPacket = 0LL;
          uint64_t v19 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
        }

        uint64_t v217 = os_channel_slot_get_packet(*(void *)(v3 + 383), v180);
        if ((v633 & 1) != 0)
        {
          int v218 = v622;
          *(void *)(v622 + 7) = 0LL;
          *int v218 = 0LL;
          char v658 = 1;
          if (v217)
          {
            os_packet_set_flow_uuid(v217, &v658);
            *(void *)(v3 + v181) |= 0x10000000uLL;
            if (gNRPacketLoggingEnabled)
            {
              id v266 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v219);
              int v267 = _NRLogIsLevelEnabled(v266, 1LL);

              if (v267)
              {
                uint64_t v269 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v268);
                id v270 = [(id)v3 copyDescription];
                _NRLogWithArgs( v269,  1LL,  "%s%.30s:%-4d %@: Set waking metadata for packet w/ ESP sequence number: %u",  "",  "NRLinkLinkToNexusLoop",  5669LL,  v270,  ESPSequenceNumberFromPacket);
              }
            }
          }

          uint64_t v220 = v645;
          uint64_t v221 = WORD1(v644);
          unsigned int v222 = getESPSequenceNumberFromPacket(v645, WORD1(v644));
          unsigned int ESPSPIFromPacket = getESPSPIFromPacket(v220, v221);
          if (qword_1001DC9E8 != -1) {
            dispatch_once(&qword_1001DC9E8, &stru_1001AFB78);
          }
          uint64_t v224 = (dispatch_queue_s *)(id)qword_1001DC9E0;
          v653 = _NSConcreteStackBlock;
          uint64_t v654 = 3221225472LL;
          v655 = sub_10008BBD0;
          v656 = &unk_1001B0578;
          unint64_t v657 = __PAIR64__(v222, ESPSPIFromPacket);
          dispatch_async(v224, &v653);

          uint64_t v19 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          uint64_t v20 = v642;
        }

        else if (v217)
        {
          os_packet_clear_flow_uuid();
        }

        os_channel_set_slot_properties(*(void *)(v3 + 383), v180, &v644);
        LODWORD(v633) = 0;
        ++*(void *)(v3 + 495);
        *(void *)(v3 + 511) += v215;
        ++v624;
        v625 += v215;
        *(void *)&__int128 v630 = v180;
      }

      else
      {
        v225 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v214);
        int v226 = _NRLogIsLevelEnabled(v225, 17LL);

        if (v226)
        {
          v227 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
          id v228 = [(id)v3 copyDescription];
          int v229 = (void *)createStringFromNRTLVType(v632);
          _NRLogWithArgs( v227,  17LL,  "%@: failed to reinject %@ tlvLen=%u slotLen=%u",  v228,  v229,  (unsigned __int16)v638,  WORD1(v644));
        }

        uint64_t v19 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      }

      goto LABEL_306;
    default:
      goto LABEL_306;
  }

void sub_10009597C(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  id v6 = v3;
  id v7 = [v6 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v19;
    do
    {
      for (i = 0LL; i != v8; i = (char *)i + 1)
      {
        if (*(void *)v19 != v9) {
          objc_enumerationMutation(v6);
        }
        int v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((void *)&v18 + 1) + 8 * (void)i), "UUIDString", (void)v18));
        -[NSMutableArray addObject:](v5, "addObject:", v11);
      }

      id v8 = [v6 countByEnumeratingWithState:&v18 objects:v22 count:16];
    }

    while (v8);
  }

  -[NSMutableDictionary setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", v5, @"nexus-instances");
  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v12 = (id)qword_1001DC870;
  id v13 = v12;
  if (v12)
  {
    uint64_t v14 = *(void *)(a1 + 32);
    int v15 = (void *)*((void *)v12 + 27);
    uint64_t v16 = v4;
    int v17 = (void *)objc_claimAutoreleasedReturnValue([v15 objectForKeyedSubscript:v14]);
    sub_1000EFBC8((uint64_t)v17, v16);
  }

  sub_10007B330(a1);
}

uint64_t sub_100095B68(void *a1)
{
  if ([a1 virtualInterface])
  {
    int v4 = socket(2, 2, 0);
    if ((v4 & 0x80000000) == 0)
    {
      LODWORD(v5) = v4;
      id v6 = (char *)NEVirtualInterfaceCopyName([a1 virtualInterface]);
      id v7 = v6;
      if (v6)
      {
        id v8 = (char *)objc_msgSend(v6, "UTF8String", 0, 0, 0, 0);
        if (v8)
        {
          char v31 = *v8;
          if (v31)
          {
            char v32 = v8[1];
            if (v32)
            {
              char v33 = v8[2];
              if (v33)
              {
                char v34 = v8[3];
                if (v34)
                {
                  char v35 = v8[4];
                  if (v35)
                  {
                    char v36 = v8[5];
                    if (v36)
                    {
                      char v37 = v8[6];
                      if (v37)
                      {
                        char v38 = v8[7];
                        if (v38)
                        {
                          char v39 = v8[8];
                          if (v39)
                          {
                            char v40 = v8[9];
                            if (v40)
                            {
                              char v41 = v8[10];
                              if (v41)
                              {
                                char v42 = v8[11];
                                if (v42)
                                {
                                  char v43 = v8[12];
                                  if (v43)
                                  {
                                    char v44 = v8[13];
                                    if (v44)
                                    {
                                      char v45 = v8[14];
                                      if (v45) {
                                        char v46 = 0;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }

          LODWORD(v47) = 2;
          if (ioctl(v5, 0xC02069B4uLL, &v31) < 0)
          {
            int v17 = __error();
            if (strerror_r(*v17, __strerrbuf, 0x80uLL)) {
              __strerrbuf[0] = 0;
            }
            if (qword_1001DC840 != -1) {
              dispatch_once(&qword_1001DC840, &stru_1001AEE08);
            }
            if (_NRLogIsLevelEnabled(qword_1001DC838, 17LL))
            {
              if (qword_1001DC840 != -1) {
                dispatch_once(&qword_1001DC840, &stru_1001AEE08);
              }
              _NRLogWithArgs(qword_1001DC838, 17LL, "ioctl SIOCSQOSMARKINGMODE failed: [%d] %s");
            }

            goto LABEL_78;
          }

          uint64_t v9 = (char *)objc_msgSend(v7, "UTF8String", 0, 0, 0, 0);
          if (v9)
          {
            char v31 = *v9;
            if (v31)
            {
              char v32 = v9[1];
              if (v32)
              {
                char v33 = v9[2];
                if (v33)
                {
                  char v34 = v9[3];
                  if (v34)
                  {
                    char v35 = v9[4];
                    if (v35)
                    {
                      char v36 = v9[5];
                      if (v36)
                      {
                        char v37 = v9[6];
                        if (v37)
                        {
                          char v38 = v9[7];
                          if (v38)
                          {
                            char v39 = v9[8];
                            if (v39)
                            {
                              char v40 = v9[9];
                              if (v40)
                              {
                                char v41 = v9[10];
                                if (v41)
                                {
                                  char v42 = v9[11];
                                  if (v42)
                                  {
                                    char v43 = v9[12];
                                    if (v43)
                                    {
                                      char v44 = v9[13];
                                      if (v44)
                                      {
                                        char v45 = v9[14];
                                        if (v45) {
                                          char v46 = 0;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }

            LODWORD(v47) = 1;
            if ((ioctl(v5, 0xC02069B5uLL, &v31) & 0x80000000) == 0)
            {
              if (qword_1001DC840 != -1) {
                dispatch_once(&qword_1001DC840, &stru_1001AEE08);
              }
              uint64_t v10 = 1LL;
              if (_NRLogIsLevelEnabled(qword_1001DC838, 1LL))
              {
                if (qword_1001DC840 != -1) {
                  dispatch_once(&qword_1001DC840, &stru_1001AEE08);
                }
                id v11 = (id)qword_1001DC838;
                _NRLogWithArgs( v11,  1,  "%s%.30s:%-4d Successfully enabled QoS marking on interface %s",  "",  "-[NRLinkBluetooth setQosMarkingEnabled]",  2390,  (const char *)[v7 UTF8String]);
              }

              goto LABEL_79;
            }

            __int128 v18 = __error();
            if (strerror_r(*v18, __strerrbuf, 0x80uLL)) {
              __strerrbuf[0] = 0;
            }
            if (qword_1001DC840 != -1) {
              dispatch_once(&qword_1001DC840, &stru_1001AEE08);
            }
            if (_NRLogIsLevelEnabled(qword_1001DC838, 17LL))
            {
              if (qword_1001DC840 != -1) {
                dispatch_once(&qword_1001DC840, &stru_1001AEE08);
              }
              _NRLogWithArgs(qword_1001DC838, 17LL, "ioctl SIOCSQOSMARKINGENABLED failed: [%d] %s");
            }

void sub_100096308(uint64_t a1, unsigned int a2)
{
  if (!*(void *)(a1 + 1327))
  {
    if (!*(_BYTE *)(a1 + 222))
    {
      int v4 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      if (*(void *)(a1 + 991))
      {
        *(_BYTE *)(a1 + 222) = 1;
        ++*(void *)(a1 + 1007);
        if (gNRPacketLoggingEnabled)
        {
          id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v3);
          int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 1LL);

          int v4 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          if (IsLevelEnabled)
          {
            id v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v14);
            id v16 = [(id)a1 copyDescription];
            _NRLogWithArgs( v15,  1LL,  "%s%.30s:%-4d %@: source-suspend: LinkOutput",  "",  "NRLinkSuspendLinkOutputSource",  815LL,  v16);

            int v4 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          }
        }

        dispatch_suspend(*(dispatch_object_t *)(a1 + v4[123]));
      }
    }

    if (*(_BYTE *)(a1 + 212))
    {
      uint64_t v5 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      if (*(void *)(a1 + 391))
      {
        *(_BYTE *)(a1 + 212) = 0;
        ++*(void *)(a1 + 415);
        if (gNRPacketLoggingEnabled)
        {
          id v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v3);
          int v8 = _NRLogIsLevelEnabled(v7, 1LL);

          uint64_t v5 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          if (v8)
          {
            uint64_t v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v9);
            id v11 = [(id)a1 copyDescription];
            _NRLogWithArgs( v10,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusInput",  "",  "NRLinkResumeNexusInputSource",  842LL,  v11);

            uint64_t v5 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          }
        }

        dispatch_resume(*(dispatch_object_t *)(a1 + v5[251]));
      }
    }

    id v6 = *(void **)(a1 + 1351);
    if (v6) {
      [v6 setReceiveWindowPacketCount:32];
    }
  }

void sub_100096514(uint64_t a1)
{
  if (!*(void *)(a1 + 1727))
  {
    uint64_t v2 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([(id)a1 queue]);
    dispatch_source_t v3 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v2);
    int v4 = *(void **)(a1 + 1727);
    *(void *)(a1 + 1727) = v3;

    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 1727), 0LL, 0x12A05F200uLL, 0x2FAF080uLL);
    objc_initWeak(&location, (id)a1);
    uint64_t v5 = *(dispatch_source_s **)(a1 + 1727);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_100096630;
    handler[3] = &unk_1001B0770;
    objc_copyWeak(v7, &location);
    v7[1] = (id)5;
    dispatch_source_set_event_handler(v5, handler);
    dispatch_resume(*(dispatch_object_t *)(a1 + 1727));
    objc_destroyWeak(v7);
    objc_destroyWeak(&location);
  }

void sub_100096630(uint64_t a1)
{
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  dispatch_source_t v3 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v80 = (uint64_t)WeakRetained;
    unsigned int v4 = [WeakRetained state];
    dispatch_source_t v3 = (void *)v80;
    if (v4 != 255)
    {
      uint64_t v79 = a1;
      uint64_t v5 = *(void *)(v80 + 1383);
      uint64_t v6 = *(void *)(v80 + 1735);
      *(void *)(v80 + 1735) = v5;
      uint64_t v7 = *(void *)(v80 + 1375);
      uint64_t v8 = *(void *)(v80 + 1759);
      *(void *)(v80 + 1759) = v7;
      uint64_t v68 = *(void *)(v80 + 1743);
      uint64_t v69 = *(void *)(v80 + 1415);
      *(void *)(v80 + 1743) = v69;
      uint64_t v78 = *(void *)(v80 + 1767);
      uint64_t v67 = *(void *)(v80 + 1407);
      *(void *)(v80 + 1767) = v67;
      uint64_t v72 = *(void *)(v80 + 1751);
      uint64_t v73 = *(void *)(v80 + 1399);
      *(void *)(v80 + 1751) = v73;
      uint64_t v70 = *(void *)(v80 + 1775);
      uint64_t v71 = *(void *)(v80 + 1391);
      *(void *)(v80 + 1775) = v71;
      uint64_t v9 = *(void *)(v80 + 487);
      uint64_t v10 = *(void *)(v80 + 1815);
      *(void *)(v80 + 1815) = v9;
      uint64_t v11 = *(void *)(v80 + 495);
      uint64_t v12 = *(void *)(v80 + 1823);
      *(void *)(v80 + 1823) = v11;
      uint64_t v13 = *(void *)(v80 + 919);
      uint64_t v14 = *(void *)(v80 + 1831);
      *(void *)(v80 + 1831) = v13;
      uint64_t v15 = *(void *)(v80 + 927);
      uint64_t v16 = *(void *)(v80 + 1839);
      *(void *)(v80 + 1839) = v15;
      uint64_t v17 = *(void *)(v80 + 631);
      uint64_t v18 = *(void *)(v80 + 1783);
      *(void *)(v80 + 1783) = v17;
      uint64_t v19 = *(void *)(v80 + 1791);
      uint64_t v66 = *(void *)(v80 + 639);
      *(void *)(v80 + 1791) = v66;
      uint64_t v76 = *(void *)(v80 + 1799);
      uint64_t v77 = *(void *)(v80 + 775);
      *(void *)(v80 + 1799) = v77;
      uint64_t v74 = *(void *)(v80 + 1807);
      uint64_t v75 = *(void *)(v80 + 783);
      *(void *)(v80 + 1807) = v75;
      unint64_t v62 = v5 - v6;
      if (v5 != v6 || v7 != v8 || v9 != v10 || v13 != v14 || v11 != v12 || v15 != v16)
      {
        uint64_t v60 = v8;
        uint64_t v61 = v12;
        uint64_t v63 = v18;
        uint64_t v64 = v19;
        uint64_t v59 = v10;
        uint64_t v20 = v17;
        uint64_t v21 = v16;
        id v22 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v80 + 32), v80);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v22, 0LL);

        uint64_t v24 = v21;
        uint64_t v17 = v20;
        uint64_t v18 = v63;
        uint64_t v19 = v64;
        dispatch_source_t v3 = (void *)v80;
        if (IsLevelEnabled)
        {
          uint64_t v25 = v15 - v24;
          id v26 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v80 + 32), v80);
          _NRLogWithArgs( v26,  0LL,  "LinkStats - BT(M): Tx [ be %3llu, bk %3llu, %7llu B, %7llu B/s ] Rx [ be %3llu, bk %3llu, %7llu B, %7llu B/s ]",  v9 - v59,  v13 - v14,  v62,  v62 / *(void *)(v79 + 40),  v11 - v61,  v25,  v7 - v60,  (unint64_t)(v7 - v60) / *(void *)(v79 + 40));

          uint64_t v18 = v63;
          uint64_t v19 = v64;
          dispatch_source_t v3 = (void *)v80;
        }
      }

      uint64_t v65 = v17 - v18;
      uint64_t v27 = v66 - v19;
      if (v69 != v68 || v67 != v78 || v77 != v76 || v17 != v18 || v75 != v74 || v66 != v19)
      {
        uint64_t v28 = v19;
        uint64_t v29 = (void *)_NRCopyLogObjectForNRUUID(v3[4], v3);
        int v30 = _NRLogIsLevelEnabled(v29, 0LL);

        uint64_t v19 = v28;
        uint64_t v12 = v80;
        if (v30)
        {
          char v31 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v80 + 32), v3);
          _NRLogWithArgs( v31,  0LL,  "LinkStats - BT(U): Tx [ vo %3llu, vi %3llu, %7llu B, %7llu B/s ] Rx [ vo %3llu, vi %3llu, %7llu B, %7llu B/s ]",  v65,  v77 - v76,  v69 - v68,  (unint64_t)(v69 - v68) / *(void *)(v79 + 40),  v27,  v75 - v74,  v67 - v78,  (unint64_t)(v67 - v78) / *(void *)(v79 + 40));

          uint64_t v19 = v28;
        }
      }

      if (v73 != v72 || v71 != v70 || v66 != v19)
      {
        char v32 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v80 + 32), v3);
        int v33 = _NRLogIsLevelEnabled(v32, 0LL);

        if (v33)
        {
          char v35 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v80 + 32), v34);
          _NRLogWithArgs( v35,  0LL,  "LinkStats - BT(D): Tx [ vo %3llu, %7llu B, %7llu B/s ] Rx [ vo %3llu, %7llu B, %7llu B/s ]",  v65,  v73 - v72,  (unint64_t)(v73 - v72) / *(void *)(v79 + 40),  v27,  v71 - v70,  (unint64_t)(v71 - v70) / *(void *)(v79 + 40));
        }
      }

      if (_NRIsAppleInternal(v12))
      {
        objc_opt_self(&OBJC_CLASS___NRLinkDirector);
        if (qword_1001DC878 != -1) {
          dispatch_once(&qword_1001DC878, &stru_1001AEED0);
        }
        char v36 = (unsigned __int8 *)(id)qword_1001DC870;
        if (v36)
        {
          int v37 = v36[9];

          if (v37)
          {
            if (gNRPacketLoggingEnabled)
            {
              id v56 = sub_100070554();
              int v57 = _NRLogIsLevelEnabled(v56, 1LL);

              if (v57)
              {
                id v58 = sub_100070554();
                _NRLogWithArgs( v58,  1LL,  "%s%.30s:%-4d force sending wake packet to ESP",  "",  "-[NRLinkBluetooth armLinkStatsTimer]_block_invoke",  6272);
              }
            }

            *(_BYTE *)(v80 + 245) = 1;
          }
        }
      }

      dispatch_source_t v3 = (void *)v80;
      uint64_t v38 = *(void *)(v80 + 1847);
      char v39 = objc_alloc_init(&OBJC_CLASS___NRAnalyticsDataStall);
      uint64_t v41 = v80;
      char v42 = v39;
      if (!*(_BYTE *)(v80 + 215) && (uint64_t v47 = *(void *)(v80 + 591)) != 0 && v47 == *(void *)(v80 + 575))
      {
        BOOL v44 = sub_100097034((void *)v80, "NexusVO");
        if (v42) {
          v42->_stalledNexusVOOutput = 1;
        }
        int v43 = 1;
        uint64_t v41 = v80;
      }

      else
      {
        int v43 = 0;
        BOOL v44 = 0;
      }

      *(void *)(v41 + 591) = *(void *)(v41 + 575);
      if (!*(_BYTE *)(v41 + 217))
      {
        uint64_t v48 = *(void *)(v41 + 735);
        if (v48)
        {
          if (v48 == *(void *)(v41 + 719))
          {
            if (v44)
            {
              BOOL v44 = 1;
            }

            else
            {
              BOOL v44 = sub_100097034((void *)v41, "NexusVI");
              uint64_t v41 = v80;
            }

            if (v42) {
              v42->_stalledNexusVIOutput = 1;
            }
            int v43 = 1;
          }
        }
      }

      *(void *)(v41 + 735) = *(void *)(v41 + 719);
      if (!*(_BYTE *)(v41 + 213))
      {
        uint64_t v49 = *(void *)(v41 + 439);
        if (v49)
        {
          if (v49 == *(void *)(v41 + 423))
          {
            if (v44)
            {
              BOOL v44 = 1;
            }

            else
            {
              BOOL v44 = sub_100097034((void *)v41, "Nexus");
              uint64_t v41 = v80;
            }

            if (v42) {
              v42->_stalledNexusOutput = 1;
            }
            int v43 = 1;
          }
        }
      }

      *(void *)(v41 + 439) = *(void *)(v41 + 423);
      if (!*(_BYTE *)(v41 + 219))
      {
        uint64_t v50 = *(void *)(v41 + 879);
        if (v50)
        {
          if (v50 == *(void *)(v41 + 863))
          {
            if (v44)
            {
              BOOL v44 = 1;
            }

            else
            {
              BOOL v44 = sub_100097034((void *)v41, "NexusBK");
              uint64_t v41 = v80;
            }

            if (v42) {
              v42->_stalledNexusBKOutput = 1;
            }
            int v43 = 1;
          }
        }
      }

      *(void *)(v41 + 879) = *(void *)(v41 + 863);
      if (!*(_BYTE *)(v41 + 222))
      {
        uint64_t v51 = *(void *)(v41 + 1023);
        if (v51)
        {
          if (v51 == *(void *)(v41 + 1007))
          {
            if (v44)
            {
              BOOL v44 = 1;
            }

            else
            {
              BOOL v44 = sub_100097034((void *)v41, "Link");
              uint64_t v41 = v80;
            }

            if (v42) {
              v42->_stalledLinkOutput = 1;
            }
            int v43 = 1;
          }
        }
      }

      *(void *)(v41 + 1023) = *(void *)(v41 + 1007);
      if (!*(_BYTE *)(v41 + 228))
      {
        uint64_t v52 = *(void *)(v41 + 1183);
        if (v52)
        {
          if (v52 == *(void *)(v41 + 1167))
          {
            if (v44)
            {
              BOOL v44 = 1;
            }

            else
            {
              BOOL v44 = sub_100097034((void *)v41, "UrgentLink");
              uint64_t v41 = v80;
            }

            if (v42) {
              v42->_stalledUrgentLinkOutput = 1;
            }
            int v43 = 1;
          }
        }
      }

      *(void *)(v41 + 1183) = *(void *)(v41 + 1167);
      if (!*(_BYTE *)(v41 + 224) && (uint64_t v53 = *(void *)(v41 + 1103)) != 0 && v53 == *(void *)(v41 + 1087))
      {
        BOOL v54 = v44 || sub_100097034((void *)v41, "DatagramLink");
        if (v42) {
          v42->_stalledDatagramLinkOutput = 1;
        }
        uint64_t v41 = v80;
        *(void *)(v80 + 1103) = *(void *)(v80 + 1087);
        *(void *)(v80 + 1847) = 0LL;
        if (v54)
        {
          sub_1000972D4(v80, v40);
          uint64_t v41 = v80;
          char v45 = 1;
        }

        else
        {
          char v45 = 0;
        }
      }

      else
      {
        *(void *)(v41 + 1103) = *(void *)(v41 + 1087);
        *(void *)(v41 + 1847) = 0LL;
        if (v44)
        {
          sub_1000972D4(v41, v40);
          char v45 = 1;
          if ((v43 & 1) == 0) {
            goto LABEL_104;
          }
          uint64_t v41 = v80;
        }

        else
        {
          char v45 = 0;
          int v46 = 0;
          if (!v43)
          {
LABEL_106:
            *(void *)(v41 + 1855) = 0LL;
            if ((v45 & 1) != 0) {
              goto LABEL_110;
            }
LABEL_109:
            if (!v46)
            {
LABEL_111:

              dispatch_source_t v3 = (void *)v80;
              uint64_t v38 = *(void *)(v80 + 1847);
LABEL_112:
              *(void *)((char *)v3 + 1847) = v38 + 1;
              goto LABEL_113;
            }

LABEL_104:
      int v46 = 0;
LABEL_105:
      uint64_t v41 = v80;
      goto LABEL_106;
    }
  }

LABEL_113:
}

    uint64_t v70 = 6;
    goto LABEL_114;
  }

  uint64_t v68 = v8->_pathEvaluator;
  v87[0] = _NSConcreteStackBlock;
  v87[1] = 3221225472LL;
  v87[2] = sub_1000B37B4;
  v87[3] = &unk_1001AF8C0;
  objc_copyWeak(&v88, __strerrbuf);
  nw_path_evaluator_set_update_handler(v68, v52, v87);
  uint64_t v69 = v8;
  objc_destroyWeak(&v88);
  uint64_t v70 = 1;
LABEL_114:

LABEL_115:
  objc_destroyWeak(&v90);
  objc_destroyWeak(&v92);
  objc_destroyWeak(__strerrbuf);

  uint64_t v85 = v8;
  if (v70 == 6)
  {
LABEL_116:
    close(v13);
LABEL_117:
    uint64_t v85 = 0LL;
  }

  return v85;
}

BOOL sub_100097034(void *a1, const char *a2)
{
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  unsigned int v4 = (id)qword_1001DC870;
  if (v4
    && ((uint64_t v5 = sub_100146AFC(),
         dispatch_assert_queue_V2((dispatch_queue_t)v5),
         v5,
         uint64_t v6 = v4[33],
         uint64_t v7 = mach_absolute_time(),
         v6)
      ? (BOOL v10 = v7 > v6)
      : (BOOL v10 = 0),
        v10))
  {
    uint64_t v11 = v7;
    if (qword_1001DC9F0 != -1) {
      dispatch_once(&qword_1001DC9F0, &stru_1001AFB98);
    }
    LODWORD(v8) = dword_1001DC9F8;
    LODWORD(v9) = *(_DWORD *)algn_1001DC9FC;
    double v12 = (double)(v11 - v6) * (0.000000001 * (double)v8) / (double)v9;

    if (v12 > 0.0 && v12 < 3600.0) {
      return 0LL;
    }
  }

  else
  {
  }

  BOOL v14 = a2 != 0LL;
  if (a2)
  {
    uint64_t v29 = a2;
    uint64_t v15 = -[NSString initWithFormat:](objc_alloc(&OBJC_CLASS___NSString), "initWithFormat:", @"%sOutput");
    uint64_t v17 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v16);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v17, 0LL);

    if (IsLevelEnabled)
    {
      id v23 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v19);
      id v30 = [a1 copyDescription];
      uint64_t v29 = "";
      _NRLogWithArgs(v23, 0LL, "%s%.30s:%-4d %@: Data stall detected for %@");
    }

    sub_1001030D0(@"NRLinkBluetooth", @"Data stall", v15, 0, 0LL, v20, v21, v22, (uint64_t)v29);
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    uint64_t v24 = (id)qword_1001DC870;
    if (v24)
    {
      uint64_t v25 = sub_100146AFC();
      dispatch_assert_queue_V2((dispatch_queue_t)v25);

      v24[33] = mach_absolute_time();
    }

    goto LABEL_23;
  }

  id v26 = sub_100070554();
  int v27 = _NRLogIsLevelEnabled(v26, 17LL);

  if (!v27) {
    return 0LL;
  }
  uint64_t v15 = (NSString *)sub_100070554();
  _NRLogWithArgs(v15, 17LL, "%s called with null srcName", "-[NRLinkBluetooth reportDataStallForOutputSource:]");
LABEL_23:

  return v14;
}

void sub_1000972D4(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 1879))
  {
    unint64_t v3 = *(unsigned __int8 *)(a1 + 251);
    unint64_t v4 = *(unsigned __int8 *)(a1 + 250);
    uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      _NRLogWithArgs(v7, 0LL, "LinkStats: ------ %s datapath snapshot ------", "Rx(M)");
    }

    if (*(_BYTE *)(a1 + 250))
    {
      unsigned int v8 = 0;
      uint64_t v9 = v3 - (v3 / v4) * (unint64_t)v4;
      do
      {
        BOOL v10 = (uint64_t *)(*(void *)(a1 + 1879) + 8 * v9);
        sub_1000978E8(*v10, *(void **)(a1 + 32));
        *BOOL v10 = 0LL;
        unsigned int v11 = *(unsigned __int8 *)(a1 + 250);
        uint64_t v9 = (v9 + 1) % v11;
        ++v8;
      }

      while (v8 < v11);
    }
  }

  if (*(void *)(a1 + 1927))
  {
    unint64_t v12 = *(unsigned __int8 *)(a1 + 257);
    unint64_t v13 = *(unsigned __int8 *)(a1 + 256);
    BOOL v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
    int v15 = _NRLogIsLevelEnabled(v14, 0LL);

    if (v15)
    {
      uint64_t v16 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      _NRLogWithArgs(v16, 0LL, "LinkStats: ------ %s datapath snapshot ------", "Tx(M)");
    }

    if (*(_BYTE *)(a1 + 256))
    {
      unsigned int v17 = 0;
      uint64_t v18 = v12 - (v12 / v13) * (unint64_t)v13;
      do
      {
        uint64_t v19 = (uint64_t *)(*(void *)(a1 + 1927) + 8 * v18);
        sub_1000982F8(*v19, *(void **)(a1 + 32));
        *uint64_t v19 = 0LL;
        unsigned int v20 = *(unsigned __int8 *)(a1 + 256);
        uint64_t v18 = (v18 + 1) % v20;
        ++v17;
      }

      while (v17 < v20);
    }
  }

  if (*(void *)(a1 + 1895))
  {
    unint64_t v21 = *(unsigned __int8 *)(a1 + 253);
    unint64_t v22 = *(unsigned __int8 *)(a1 + 252);
    id v23 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
    int v24 = _NRLogIsLevelEnabled(v23, 0LL);

    if (v24)
    {
      uint64_t v25 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      _NRLogWithArgs(v25, 0LL, "LinkStats: ------ %s datapath snapshot ------", "Rx(U)");
    }

    if (*(_BYTE *)(a1 + 252))
    {
      unsigned int v26 = 0;
      uint64_t v27 = v21 - (v21 / v22) * (unint64_t)v22;
      do
      {
        uint64_t v28 = (uint64_t *)(*(void *)(a1 + 1895) + 8 * v27);
        sub_1000978E8(*v28, *(void **)(a1 + 32));
        *uint64_t v28 = 0LL;
        unsigned int v29 = *(unsigned __int8 *)(a1 + 252);
        uint64_t v27 = (v27 + 1) % v29;
        ++v26;
      }

      while (v26 < v29);
    }
  }

  if (*(void *)(a1 + 1943))
  {
    unint64_t v30 = *(unsigned __int8 *)(a1 + 259);
    unint64_t v31 = *(unsigned __int8 *)(a1 + 258);
    char v32 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
    int v33 = _NRLogIsLevelEnabled(v32, 0LL);

    if (v33)
    {
      uint64_t v34 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      _NRLogWithArgs(v34, 0LL, "LinkStats: ------ %s datapath snapshot ------", "Tx(U)");
    }

    if (*(_BYTE *)(a1 + 258))
    {
      unsigned int v35 = 0;
      uint64_t v36 = v30 - (v30 / v31) * (unint64_t)v31;
      do
      {
        int v37 = (uint64_t *)(*(void *)(a1 + 1943) + 8 * v36);
        sub_1000982F8(*v37, *(void **)(a1 + 32));
        uint64_t *v37 = 0LL;
        unsigned int v38 = *(unsigned __int8 *)(a1 + 258);
        uint64_t v36 = (v36 + 1) % v38;
        ++v35;
      }

      while (v35 < v38);
    }
  }

  if (*(void *)(a1 + 1911))
  {
    unint64_t v39 = *(unsigned __int8 *)(a1 + 255);
    unint64_t v40 = *(unsigned __int8 *)(a1 + 254);
    uint64_t v41 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
    int v42 = _NRLogIsLevelEnabled(v41, 0LL);

    if (v42)
    {
      BOOL v44 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v43);
      _NRLogWithArgs(v44, 0LL, "LinkStats: ------ %s datapath snapshot ------", "Rx(D)");
    }

    if (*(_BYTE *)(a1 + 254))
    {
      unsigned int v45 = 0;
      uint64_t v46 = v39 - (v39 / v40) * (unint64_t)v40;
      do
      {
        uint64_t v47 = (uint64_t *)(*(void *)(a1 + 1911) + 8 * v46);
        sub_1000978E8(*v47, *(void **)(a1 + 32));
        *uint64_t v47 = 0LL;
        unsigned int v48 = *(unsigned __int8 *)(a1 + 254);
        uint64_t v46 = (v46 + 1) % v48;
        ++v45;
      }

      while (v45 < v48);
    }
  }

uint64_t sub_100097734(uint64_t a1)
{
  if (*(void *)(a1 + 1031)) {
    return 0LL;
  }
  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  unint64_t v3 = (id)qword_1001DC870;
  if (v3
    && ((unint64_t v4 = sub_100146AFC(),
         dispatch_assert_queue_V2((dispatch_queue_t)v4),
         v4,
         unint64_t v5 = v3[34],
         uint64_t v6 = mach_absolute_time(),
         v5)
      ? (BOOL v9 = v6 > v5)
      : (BOOL v9 = 0),
        v9))
  {
    if (qword_1001DC9F0 != -1)
    {
      uint64_t v21 = v6;
      dispatch_once(&qword_1001DC9F0, &stru_1001AFB98);
      uint64_t v6 = v21;
    }

    LODWORD(v7) = dword_1001DC9F8;
    LODWORD(v8) = *(_DWORD *)algn_1001DC9FC;
    double v10 = (double)(v6 - v5) * (0.000000001 * (double)v7) / (double)v8;

    if (v10 > 0.0 && v10 < 3600.0) {
      return 0LL;
    }
  }

  else
  {
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  unint64_t v12 = (id)qword_1001DC870;
  if (v12)
  {
    unint64_t v13 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v13);

    v12[34] = mach_absolute_time();
  }

  sub_1000749CC((void *)a1, @"LinkStats - Remediating data stall", v14, v15, v16, v17, v18, v19, v20);
  return 1LL;
}

void sub_1000978E8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v117 = v3;
    if ((a1 & 2) != 0)
    {
      unint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(v3, v4);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

      if (IsLevelEnabled)
      {
        unint64_t v7 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v7, 0LL, "LinkStats: LTNStartOuterLoop");
      }
    }

    if ((a1 & 4) != 0)
    {
      unint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v9 = _NRLogIsLevelEnabled(v8, 0LL);

      if (v9)
      {
        double v10 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v10, 0LL, "LinkStats: LTNStartInnerLoop");
      }
    }

    if ((a1 & 8) != 0)
    {
      unsigned int v11 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v12 = _NRLogIsLevelEnabled(v11, 0LL);

      if (v12)
      {
        unint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v13, 0LL, "LinkStats: LTNReadAllCurLinkInputSlot");
      }
    }

    if ((a1 & 0x10) != 0)
    {
      uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v15 = _NRLogIsLevelEnabled(v14, 0LL);

      if (v15)
      {
        uint64_t v16 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v16, 0LL, "LinkStats: LTNGotNewSlot");
      }
    }

    if ((a1 & 0x20) != 0)
    {
      uint64_t v17 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v18 = _NRLogIsLevelEnabled(v17, 0LL);

      if (v18)
      {
        uint64_t v19 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v19, 0LL, "LinkStats: LTNReuseExistingSlot");
      }
    }

    if ((a1 & 0x40) != 0)
    {
      uint64_t v20 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v21 = _NRLogIsLevelEnabled(v20, 0LL);

      if (v21)
      {
        unint64_t v22 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v22, 0LL, "LinkStats: LTNNoLinkInputSlot");
      }
    }

    if ((a1 & 0x80) != 0)
    {
      id v23 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v24 = _NRLogIsLevelEnabled(v23, 0LL);

      if (v24)
      {
        uint64_t v25 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v25, 0LL, "LinkStats: LTNIncomingTLV1");
      }
    }

    if ((a1 & 0x100) != 0)
    {
      unsigned int v26 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v27 = _NRLogIsLevelEnabled(v26, 0LL);

      if (v27)
      {
        uint64_t v28 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v28, 0LL, "LinkStats: LTNIncomingTLV2");
      }
    }

    if ((a1 & 0x200) != 0)
    {
      unsigned int v29 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v30 = _NRLogIsLevelEnabled(v29, 0LL);

      if (v30)
      {
        unint64_t v31 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v31, 0LL, "LinkStats: LTNIncomingTLV3");
      }
    }

    if ((a1 & 0x400) != 0)
    {
      char v32 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v33 = _NRLogIsLevelEnabled(v32, 0LL);

      if (v33)
      {
        uint64_t v34 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v34, 0LL, "LinkStats: LTNIncomingTLV4");
      }
    }

    if ((a1 & 0x800) != 0)
    {
      unsigned int v35 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v36 = _NRLogIsLevelEnabled(v35, 0LL);

      if (v36)
      {
        int v37 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v37, 0LL, "LinkStats: LTNIncomingTLV5");
      }
    }

    if ((a1 & 0x1000) != 0)
    {
      unsigned int v38 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v39 = _NRLogIsLevelEnabled(v38, 0LL);

      if (v39)
      {
        unint64_t v40 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v40, 0LL, "LinkStats: LTNPlacingLinkReadBuffer");
      }
    }

    if ((a1 & 0x2000) != 0)
    {
      uint64_t v41 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v42 = _NRLogIsLevelEnabled(v41, 0LL);

      if (v42)
      {
        uint64_t v43 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v43, 0LL, "LinkStats: LTNPlacingCurLinkInputSlot");
      }
    }

    if ((a1 & 0x4000) != 0)
    {
      BOOL v44 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v45 = _NRLogIsLevelEnabled(v44, 0LL);

      if (v45)
      {
        uint64_t v46 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v46, 0LL, "LinkStats: LTNShrinkingIOVec");
      }
    }

    if ((a1 & 0x8000) != 0)
    {
      uint64_t v47 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v48 = _NRLogIsLevelEnabled(v47, 0LL);

      if (v48)
      {
        uint64_t v49 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v49, 0LL, "LinkStats: LTNNotShrinkingIOVec");
      }
    }

    if ((a1 & 0x10000) != 0)
    {
      uint64_t v50 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v51 = _NRLogIsLevelEnabled(v50, 0LL);

      if (v51)
      {
        uint64_t v52 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v52, 0LL, "LinkStats: LTNNoLookAheadSlots");
      }
    }

    if ((a1 & 0x20000) != 0)
    {
      uint64_t v53 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v54 = _NRLogIsLevelEnabled(v53, 0LL);

      if (v54)
      {
        uint64_t v55 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v55, 0LL, "LinkStats: LTNPlacingLookAheadSlots");
      }
    }

    if ((a1 & 0x40000) != 0)
    {
      id v56 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v57 = _NRLogIsLevelEnabled(v56, 0LL);

      if (v57)
      {
        id v58 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v58, 0LL, "LinkStats: LTNShrinkingLastIOVec");
      }
    }

    if ((a1 & 0x80000) != 0)
    {
      uint64_t v59 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v60 = _NRLogIsLevelEnabled(v59, 0LL);

      if (v60)
      {
        uint64_t v61 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v61, 0LL, "LinkStats: LTNNotShrinkingLastIOVec");
      }
    }

    if ((a1 & 0x100000) != 0)
    {
      unint64_t v62 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v63 = _NRLogIsLevelEnabled(v62, 0LL);

      if (v63)
      {
        uint64_t v64 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v64, 0LL, "LinkStats: LTNNotEnoughInputBytes");
      }
    }

    if ((a1 & 0x200000) != 0)
    {
      uint64_t v65 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v66 = _NRLogIsLevelEnabled(v65, 0LL);

      if (v66)
      {
        uint64_t v67 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v67, 0LL, "LinkStats: LTNCurInputSlotComplete");
      }
    }

    if ((a1 & 0x400000) != 0)
    {
      uint64_t v68 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v69 = _NRLogIsLevelEnabled(v68, 0LL);

      if (v69)
      {
        uint64_t v70 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v70, 0LL, "LinkStats: LTNCurInputSlotCompleteLRB");
      }
    }

    if ((a1 & 0x800000) != 0)
    {
      uint64_t v71 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v72 = _NRLogIsLevelEnabled(v71, 0LL);

      if (v72)
      {
        uint64_t v73 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v73, 0LL, "LinkStats: LTNNoNexusOutputSlot");
      }
    }

    if ((a1 & 0x1000000) != 0)
    {
      uint64_t v74 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v75 = _NRLogIsLevelEnabled(v74, 0LL);

      if (v75)
      {
        uint64_t v76 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v76, 0LL, "LinkStats: LTNNoNexusOutputSlotAndFullLRB");
      }
    }

    if ((a1 & 0x2000000) != 0)
    {
      uint64_t v77 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v78 = _NRLogIsLevelEnabled(v77, 0LL);

      if (v78)
      {
        uint64_t v79 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v79, 0LL, "LinkStats: LTNNoNexusOutputSlotWithAllInLRB");
      }
    }

    if ((a1 & 0x4000000) != 0)
    {
      uint64_t v80 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v81 = _NRLogIsLevelEnabled(v80, 0LL);

      if (v81)
      {
        uint64_t v82 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v82, 0LL, "LinkStats: LTNCurInputSlotCompleteWithNoNexusOutputSlot");
      }
    }

    if ((a1 & 0x8000000) != 0)
    {
      uint64_t v83 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v84 = _NRLogIsLevelEnabled(v83, 0LL);

      if (v84)
      {
        uint64_t v85 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v85, 0LL, "LinkStats: LTNReinjectingPacketToNexus");
      }
    }

    if ((a1 & 0x10000000) != 0)
    {
      uint64_t v86 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v87 = _NRLogIsLevelEnabled(v86, 0LL);

      if (v87)
      {
        uint64_t v88 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v88, 0LL, "LinkStats: LTNMarkedWakePacketFlag");
      }
    }

    if ((a1 & 0x20000000) != 0)
    {
      unsigned int v89 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v90 = _NRLogIsLevelEnabled(v89, 0LL);

      if (v90)
      {
        unsigned int v91 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v91, 0LL, "LinkStats: LTNReinjectingIKEv2Packet");
      }
    }

    if ((a1 & 0x40000000) != 0)
    {
      int v92 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v93 = _NRLogIsLevelEnabled(v92, 0LL);

      if (v93)
      {
        uint64_t v94 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v94, 0LL, "LinkStats: LTNEndInnerLoop");
      }
    }

    if ((a1 & 0x80000000) != 0)
    {
      uint64_t v95 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v96 = _NRLogIsLevelEnabled(v95, 0LL);

      if (v96)
      {
        id v97 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v97, 0LL, "LinkStats: LTNMemmovingLRB");
      }
    }

    if ((a1 & 0x100000000LL) != 0)
    {
      uint64_t v98 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v99 = _NRLogIsLevelEnabled(v98, 0LL);

      if (v99)
      {
        unint64_t v100 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v100, 0LL, "LinkStats: LTNNotMemmovingLRBWithHandled");
      }
    }

    if ((a1 & 0x200000000LL) != 0)
    {
      uint64_t v101 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v102 = _NRLogIsLevelEnabled(v101, 0LL);

      if (v102)
      {
        unint64_t v103 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v103, 0LL, "LinkStats: LTNNotMemmovingLRBWithNoHandled");
      }
    }

    if ((a1 & 0x400000000LL) != 0)
    {
      char v104 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v105 = _NRLogIsLevelEnabled(v104, 0LL);

      if (v105)
      {
        unsigned int v106 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v106, 0LL, "LinkStats: LTNResettingLRB");
      }
    }

    if ((a1 & 0x800000000LL) != 0)
    {
      int v107 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v108 = _NRLogIsLevelEnabled(v107, 0LL);

      if (v108)
      {
        int v109 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v109, 0LL, "LinkStats: LTNLinkChannelSync");
      }
    }

    if ((a1 & 0x1000000000LL) != 0)
    {
      unsigned int v110 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
      int v111 = _NRLogIsLevelEnabled(v110, 0LL);

      if (v111)
      {
        unsigned int v112 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
        _NRLogWithArgs(v112, 0LL, "LinkStats: LTNNexusOutputSync");
      }
    }

    unsigned int v113 = (void *)_NRCopyLogObjectForNRUUID(v117, v4);
    int v114 = _NRLogIsLevelEnabled(v113, 0LL);

    id v3 = v117;
    if (v114)
    {
      uint64_t v116 = (void *)_NRCopyLogObjectForNRUUID(v117, v115);
      _NRLogWithArgs(v116, 0LL, "LinkStats: ------------------------------");

      id v3 = v117;
    }
  }
}

void sub_1000982F8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v81 = v3;
    if ((a1 & 2) != 0)
    {
      unint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(v3, v4);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

      if (IsLevelEnabled)
      {
        unint64_t v7 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v7, 0LL, "LinkStats: NTLStartInnerLoop");
      }
    }

    if ((a1 & 4) != 0)
    {
      unint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v9 = _NRLogIsLevelEnabled(v8, 0LL);

      if (v9)
      {
        double v10 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v10, 0LL, "LinkStats: NTLNoDatagramLinkInputSlot");
      }
    }

    if ((a1 & 8) != 0)
    {
      unsigned int v11 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v12 = _NRLogIsLevelEnabled(v11, 0LL);

      if (v12)
      {
        unint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v13, 0LL, "LinkStats: NTLNoNexusInputSlotForDatagramLink");
      }
    }

    if ((a1 & 0x10) != 0)
    {
      uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v15 = _NRLogIsLevelEnabled(v14, 0LL);

      if (v15)
      {
        uint64_t v16 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v16, 0LL, "LinkStats: NTLWroteToDatagramLink");
      }
    }

    if ((a1 & 0x20) != 0)
    {
      uint64_t v17 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v18 = _NRLogIsLevelEnabled(v17, 0LL);

      if (v18)
      {
        uint64_t v19 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v19, 0LL, "LinkStats: NTLGotLinkOutputSlot");
      }
    }

    if ((a1 & 0x40) != 0)
    {
      uint64_t v20 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v21 = _NRLogIsLevelEnabled(v20, 0LL);

      if (v21)
      {
        unint64_t v22 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v22, 0LL, "LinkStats: NTLReuseExistingSlot");
      }
    }

    if ((a1 & 0x80) != 0)
    {
      id v23 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v24 = _NRLogIsLevelEnabled(v23, 0LL);

      if (v24)
      {
        uint64_t v25 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v25, 0LL, "LinkStats: NTLNoLinkOutputSlot");
      }
    }

    if ((a1 & 0x100) != 0)
    {
      unsigned int v26 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v27 = _NRLogIsLevelEnabled(v26, 0LL);

      if (v27)
      {
        uint64_t v28 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v28, 0LL, "LinkStats: NTLWroteBytesFromLWB");
      }
    }

    if ((a1 & 0x200) != 0)
    {
      unsigned int v29 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v30 = _NRLogIsLevelEnabled(v29, 0LL);

      if (v30)
      {
        unint64_t v31 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v31, 0LL, "LinkStats: NTLFilledLinkOutputWithLWB");
      }
    }

    if ((a1 & 0x400) != 0)
    {
      char v32 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v33 = _NRLogIsLevelEnabled(v32, 0LL);

      if (v33)
      {
        uint64_t v34 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v34, 0LL, "LinkStats: NTLNilNexusInputRing");
      }
    }

    if ((a1 & 0x800) != 0)
    {
      unsigned int v35 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v36 = _NRLogIsLevelEnabled(v35, 0LL);

      if (v36)
      {
        int v37 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v37, 0LL, "LinkStats: NTLNoNexusInput");
      }
    }

    if ((a1 & 0x1000) != 0)
    {
      unsigned int v38 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v39 = _NRLogIsLevelEnabled(v38, 0LL);

      if (v39)
      {
        unint64_t v40 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v40, 0LL, "LinkStats: NTLGotLookaheadOutputSlot");
      }
    }

    if ((a1 & 0x2000) != 0)
    {
      uint64_t v41 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v42 = _NRLogIsLevelEnabled(v41, 0LL);

      if (v42)
      {
        uint64_t v43 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v43, 0LL, "LinkStats: NTLNotEnoughRoomInLinkOutputSlot");
      }
    }

    if ((a1 & 0x4000) != 0)
    {
      BOOL v44 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v45 = _NRLogIsLevelEnabled(v44, 0LL);

      if (v45)
      {
        uint64_t v46 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v46, 0LL, "LinkStats: NTLWroteToLinkOutputSlot");
      }
    }

    if ((a1 & 0x8000) != 0)
    {
      uint64_t v47 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v48 = _NRLogIsLevelEnabled(v47, 0LL);

      if (v48)
      {
        uint64_t v49 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v49, 0LL, "LinkStats: NTLWroteToLookaheadOutputSlot");
      }
    }

    if ((a1 & 0x10000) != 0)
    {
      uint64_t v50 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v51 = _NRLogIsLevelEnabled(v50, 0LL);

      if (v51)
      {
        uint64_t v52 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v52, 0LL, "LinkStats: NTLWroteNexusPacket");
      }
    }

    if ((a1 & 0x20000) != 0)
    {
      uint64_t v53 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v54 = _NRLogIsLevelEnabled(v53, 0LL);

      if (v54)
      {
        uint64_t v55 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v55, 0LL, "LinkStats: NTLWrotePartialBytesToLinkOutput");
      }
    }

    if ((a1 & 0x40000) != 0)
    {
      id v56 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v57 = _NRLogIsLevelEnabled(v56, 0LL);

      if (v57)
      {
        id v58 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v58, 0LL, "LinkStats: NTLWroteAllBytesToLinkOutput");
      }
    }

    if ((a1 & 0x80000) != 0)
    {
      uint64_t v59 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v60 = _NRLogIsLevelEnabled(v59, 0LL);

      if (v60)
      {
        uint64_t v61 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v61, 0LL, "LinkStats: NTLMemmovingLWB");
      }
    }

    if ((a1 & 0x100000) != 0)
    {
      unint64_t v62 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v63 = _NRLogIsLevelEnabled(v62, 0LL);

      if (v63)
      {
        uint64_t v64 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v64, 0LL, "LinkStats: NTLResettingLWB");
      }
    }

    if ((a1 & 0x200000) != 0)
    {
      uint64_t v65 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v66 = _NRLogIsLevelEnabled(v65, 0LL);

      if (v66)
      {
        uint64_t v67 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v67, 0LL, "LinkStats: NTLLinkOutputSync");
      }
    }

    if ((a1 & 0x400000) != 0)
    {
      uint64_t v68 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v69 = _NRLogIsLevelEnabled(v68, 0LL);

      if (v69)
      {
        uint64_t v70 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v70, 0LL, "LinkStats: NTLLinkChannelSync");
      }
    }

    if ((a1 & 0x800000) != 0)
    {
      uint64_t v71 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v72 = _NRLogIsLevelEnabled(v71, 0LL);

      if (v72)
      {
        uint64_t v73 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v73, 0LL, "LinkStats: NTLDatagramLinkChannelSync");
      }
    }

    if ((a1 & 0x1000000) != 0)
    {
      uint64_t v74 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
      int v75 = _NRLogIsLevelEnabled(v74, 0LL);

      if (v75)
      {
        uint64_t v76 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
        _NRLogWithArgs(v76, 0LL, "LinkStats: NTLNexusInputSync");
      }
    }

    uint64_t v77 = (void *)_NRCopyLogObjectForNRUUID(v81, v4);
    int v78 = _NRLogIsLevelEnabled(v77, 0LL);

    id v3 = v81;
    if (v78)
    {
      uint64_t v80 = (void *)_NRCopyLogObjectForNRUUID(v81, v79);
      _NRLogWithArgs(v80, 0LL, "LinkStats: ------------------------------");

      id v3 = v81;
    }
  }
}

void sub_1000989D8(uint64_t a1, unsigned int a2)
{
  if (!a1) {
    return;
  }
  id v3 = *(void **)(a1 + 1327);
  if (a2 >= 0x41)
  {
    unint64_t v5 = *(dispatch_queue_s **)(a1 + 8);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10009904C;
    block[3] = &unk_1001B0A88;
    block[4] = a1;
    dispatch_async(v5, block);
    return;
  }

  id v6 = [v3 length];
  id v49 = *(id *)(a1 + 1327);
  unint64_t v7 = (char *)[v49 bytes];
  if (*(void *)(a1 + 975))
  {
    if (*(void *)(a1 + 959))
    {
      if (v6)
      {
        int v9 = v7;
        unint64_t v10 = 0LL;
        uint64_t v11 = 0LL;
        while (1)
        {
          __int128 v53 = 0u;
          __int128 v54 = 0u;
          __int128 v51 = 0u;
          *(_OWORD *)__dst = 0u;
          uint64_t next_slot = os_channel_get_next_slot(*(void *)(a1 + 975), v11, &v51);
          if (!next_slot) {
            break;
          }
          uint64_t v13 = next_slot;
          else {
            size_t v14 = (unsigned __int16)((_WORD)v6 - v10);
          }
          memcpy(__dst[0], &v9[v10], v14);
          WORD1(v51) = v14;
          v10 += v14;
          os_channel_set_slot_properties(*(void *)(a1 + 975), v13, &v51);
          uint64_t v11 = v13;
        }

        uint64_t v13 = v11;
        if (!v11) {
          goto LABEL_27;
        }
LABEL_26:
        os_channel_advance_slot(*(void *)(a1 + 975), v13);
      }

      else
      {
        unint64_t v10 = 0LL;
      }

uint64_t sub_10009904C(uint64_t a1)
{
  return sub_1000989D8(*(void *)(a1 + 32), 0LL);
}

void sub_100099058(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 242) && *(unsigned __int8 *)(a1 + 210) - 10 <= 9)
  {
    uint64_t v2 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 32));
    if (!v2)
    {
      id v18 = sub_100070554();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 16LL);

      if (IsLevelEnabled)
      {
        id v20 = sub_100070554();
        _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]",  8735);
      }

      uint64_t v21 = _os_log_pack_size(12LL);
      unint64_t v22 = (char *)&v27[-1] - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v23 = __error();
      uint64_t v24 = _os_log_pack_fill( v22,  v21,  *v23,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)uint64_t v24 = 136446210;
      *(void *)(v24 + 4) = "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]";
      id v25 = sub_100070554();
      _NRLogAbortWithPack(v25, v22);
    }

    uint64_t v4 = v2;
    int v5 = *(unsigned __int8 *)(a1 + 210);
    id v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v3);
    int v7 = _NRLogIsLevelEnabled(v6, 0LL);

    if (v5 == 11)
    {
      if (v7)
      {
        int v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v8);
        id v10 = [(id)a1 copyDescription];
        _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: Initiator querying IDS keys for pairing",  "",  "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]",  8738LL,  v10);
      }

      uint64_t v11 = *(void **)(a1 + 32);
      v29[0] = _NSConcreteStackBlock;
      v29[1] = 3221225472LL;
      v29[2] = sub_1000994F4;
      v29[3] = &unk_1001AED48;
      int v12 = (id *)&v30;
      v29[4] = a1;
      int v30 = v4;
      uint64_t v13 = v4;
      sub_100132BC0((uint64_t)&OBJC_CLASS___NRDLocalDevice, v11, 4, v29);
    }

    else
    {
      if (v7)
      {
        size_t v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v8);
        id v15 = [(id)a1 copyDescription];
        _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d %@: Querying for pairing keys for OOBK pairing",  "",  "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]",  8802LL,  v15);
      }

      int v16 = *(void **)(a1 + 32);
      v27[0] = _NSConcreteStackBlock;
      v27[1] = 3221225472LL;
      v27[2] = sub_100099A7C;
      v27[3] = &unk_1001AED70;
      int v12 = (id *)&v28;
      v27[4] = a1;
      uint64_t v28 = v4;
      uint64_t v17 = v4;
      sub_1001320DC((uint64_t)&OBJC_CLASS___NRDLocalDevice, v16, 1, v27);
    }
  }

void sub_100099370(uint64_t a1)
{
  WeakRetained = (void **)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v13 = WeakRetained;
    sub_100076FE0((uint64_t)WeakRetained, 3LL);
    uint64_t v2 = v13;
    if (!*((_BYTE *)v13 + 242))
    {
      uint64_t v3 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v13[4]);
      if (!v3)
      {
        id v5 = sub_100070554();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16LL);

        if (IsLevelEnabled)
        {
          id v7 = sub_100070554();
          _NRLogWithArgs( v7,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRLinkBluetooth setupIPsec]_block_invoke",  9099);
        }

        uint64_t v8 = _os_log_pack_size(12LL);
        int v9 = (char *)&v13 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        id v10 = __error();
        uint64_t v11 = _os_log_pack_fill( v9,  v8,  *v10,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
        *(_DWORD *)uint64_t v11 = 136446210;
        *(void *)(v11 + 4) = "-[NRLinkBluetooth setupIPsec]_block_invoke";
        id v12 = sub_100070554();
        _NRLogAbortWithPack(v12, v9);
      }

      uint64_t v4 = v3;

      uint64_t v2 = v13;
    }
  }
}

void sub_1000994F4(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6)
{
  id v65 = a4;
  id v12 = a5;
  id v13 = a6;
  if ([*(id *)(a1 + 32) state] != 255)
  {
    if (a2)
    {
      if (a3)
      {
        if (v65)
        {
          id v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v14);
          int IsLevelEnabled = _NRLogIsLevelEnabled(v15, 0LL);

          if (IsLevelEnabled)
          {
            id v18 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v17);
            id v19 = [*(id *)(a1 + 32) copyDescription];
            _NRLogWithArgs( v18,  0LL,  "%s%.30s:%-4d %@: Initiator queried IDS keys for pairing",  "",  "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]_block_invoke",  8756LL,  v19);
          }

          uint64_t v20 = *(void *)(a1 + 32);
          if (v20) {
            objc_storeStrong((id *)(v20 + 1287), a4);
          }
          if (v12)
          {
            uint64_t v21 = *(void *)(a1 + 32);
            if (v21) {
              objc_storeStrong((id *)(v21 + 1295), a5);
            }
          }

          if (v13)
          {
            uint64_t v22 = *(void *)(a1 + 32);
            if (v22) {
              objc_storeStrong((id *)(v22 + 1303), a6);
            }
          }

          id v23 = [[NEIKEv2AuthenticationProtocol alloc] initWithNonStandardDigitalSignature:2];
          if (qword_1001DCA98 != -1) {
            dispatch_once(&qword_1001DCA98, &stru_1001AFD90);
          }
          id v24 = (id)qword_1001DCA90;
          id v25 = sub_10010C5AC(1, v24, v23);

          -[NEIKEv2SessionConfiguration setLocalPrivateKeyRef:](v25, "setLocalPrivateKeyRef:", a3);
          -[NEIKEv2SessionConfiguration setRemotePublicKeyRef:](v25, "setRemotePublicKeyRef:", a2);
          [*(id *)(a1 + 32) reportEvent:3011];
          uint64_t v26 = mach_absolute_time();
          uint64_t v27 = *(void *)(a1 + 32);
          if (v27
            && ((v28 = *(void *)(v27 + 1863)) == 0 || (*(void *)(v28 + 112) = v26, (uint64_t v27 = *(void *)(a1 + 32)) != 0)))
          {
            uint64_t v29 = *(id *)(v27 + 1863);
            if (v29) {
              ++v29[13];
            }
          }

          else
          {
            uint64_t v29 = 0LL;
          }

          id v30 = sub_10010C0B8();
          [v30 setRequestChildlessSA:1];
          unint64_t v31 = objc_alloc(&OBJC_CLASS___NEIKEv2Session);
          char v32 = sub_10010C340();
          -[NEIKEv2ChildSAConfiguration setSequencePerTrafficClass:](v32, "setSequencePerTrafficClass:", 1LL);
          -[NEIKEv2ChildSAConfiguration setReplayWindowSize:](v32, "setReplayWindowSize:", 16LL);
          int v33 = -[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName:packetDelegate:]( v31,  "initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASession Name:packetDelegate:",  v30,  v32,  v25,  *(void *)(*(void *)(a1 + 32) + 8LL),  0LL,  0LL,  @"terminusIKEForPairingWithIDS",  *(void *)(a1 + 32));
          uint64_t v34 = *(void *)(a1 + 32);
          unsigned int v35 = *(void **)(v34 + 1247);
          *(void *)(v34 + 1247) = v33;

          uint64_t v36 = *(void *)(a1 + 32);
          uint64_t v37 = *(void *)(v36 + 1247);
          uint64_t v39 = _NRCopyLogObjectForNRUUID(*(void *)(v36 + 32), v38);
          int v40 = (void *)v39;
          if (v37)
          {
            int v41 = _NRLogIsLevelEnabled(v39, 0LL);

            if (v41)
            {
              id v43 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v42);
              id v44 = [*(id *)(a1 + 32) copyDescription];
              _NRLogWithArgs( v43,  0LL,  "%s%.30s:%-4d %@: Created initiator IDS pairing IKE session",  "",  "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]_block_invoke",  8794LL,  v44);
            }

            sub_1000751DC(*(void *)(a1 + 32));
            uint64_t v46 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v45);
            int v47 = _NRLogIsLevelEnabled(v46, 0LL);

            if (v47)
            {
              id v49 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v48);
              id v50 = [*(id *)(a1 + 32) copyDescription];
              _NRLogWithArgs( v49,  0LL,  "%s%.30s:%-4d %@: Connecting initiator IDS pairing session",  "",  "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]_block_invoke",  8798LL,  v50);
            }

            [*(id *)(*(void *)(a1 + 32) + 1247) connect];
          }

          else
          {
            int v61 = _NRLogIsLevelEnabled(v39, 17LL);

            if (v61)
            {
              int v63 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v62);
              id v64 = [*(id *)(a1 + 32) copyDescription];
              _NRLogWithArgs(v63, 17LL, "%@: Failed to create initiator IDS pairing IKE session", v64);
            }
          }
        }

        else
        {
          id v59 = sub_100070554();
          int v60 = _NRLogIsLevelEnabled(v59, 17LL);

          if (!v60) {
            goto LABEL_32;
          }
          id v23 = sub_100070554();
          _NRLogWithArgs(v23, 17LL, "%s called with null localPublicClassDKeysEncryptedWithIDS");
        }
      }

      else
      {
        id v57 = sub_100070554();
        int v58 = _NRLogIsLevelEnabled(v57, 17LL);

        if (!v58) {
          goto LABEL_32;
        }
        id v23 = sub_100070554();
        _NRLogWithArgs(v23, 17LL, "%s called with null localPrivateIDSClassDSigningKey");
      }
    }

    else
    {
      id v55 = sub_100070554();
      int v56 = _NRLogIsLevelEnabled(v55, 17LL);

      if (!v56) {
        goto LABEL_32;
      }
      id v23 = sub_100070554();
      _NRLogWithArgs(v23, 17LL, "%s called with null remotePublicIDSClassDSigningKey");
    }

    goto LABEL_31;
  }

  __int128 v51 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v14);
  int v52 = _NRLogIsLevelEnabled(v51, 0LL);

  if (v52)
  {
    id v23 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v53);
    id v54 = [*(id *)(a1 + 32) copyDescription];
    _NRLogWithArgs( v23,  0LL,  "%s%.30s:%-4d %@: Ignoring result as link is cancelled",  "",  "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]_block_invoke",  8749LL,  v54);

LABEL_31:
  }

void sub_100099A7C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v71 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v10);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0LL);

  if (IsLevelEnabled)
  {
    uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v13);
    id v15 = [*(id *)(a1 + 32) copyDescription];
    LogString = (void *)_NRKeyCreateLogString(v71);
    uint64_t v70 = a3;
    id v17 = v8;
    id v18 = (void *)_NRKeyCreateLogString(v8);
    id v19 = a4;
    uint64_t v20 = (void *)_NRKeyCreateLogString(v9);
    _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d %@: Queryied for pairing keys for OOBK pairing D %@ C %@ A %@",  "",  "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]_block_invoke_2",  8812LL,  v15,  LogString,  v18,  v20);

    a4 = v19;
    id v8 = v17;
    a3 = v70;
  }

  unsigned int v21 = [*(id *)(a1 + 32) state];
  uint64_t v23 = *(void *)(a1 + 32);
  if (v21 != 255)
  {
    if (v23)
    {
      objc_storeStrong((id *)(v23 + 1263), a2);
      uint64_t v24 = *(void *)(a1 + 32);
      if (v24)
      {
        objc_storeStrong((id *)(v24 + 1271), a3);
        uint64_t v25 = *(void *)(a1 + 32);
        if (v25) {
          objc_storeStrong((id *)(v25 + 1279), a4);
        }
      }
    }

    id v26 = [[NEIKEv2AuthenticationProtocol alloc] initWithMethod:2];
    if (qword_1001DCAA8 != -1) {
      dispatch_once(&qword_1001DCAA8, &stru_1001AFDB0);
    }
    id v27 = (id)qword_1001DCAA0;
    uint64_t v28 = sub_10010C5AC(1, v27, v26);

    uint64_t v29 = *(void *)(a1 + 40);
    if (v29)
    {
      id v30 = *(void **)(v29 + 152);
      if (v30) {
        id v30 = (void *)v30[2];
      }
      unint64_t v31 = v30;
    }

    else
    {
      unint64_t v31 = 0LL;
    }

    -[NEIKEv2SessionConfiguration setSharedSecret:](v28, "setSharedSecret:", v31);

    char v32 = (void *)objc_claimAutoreleasedReturnValue(-[NEIKEv2SessionConfiguration sharedSecret](v28, "sharedSecret"));
    if (v32)
    {
      int v33 = *(void **)(a1 + 32);
      uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue(-[NEIKEv2SessionConfiguration sharedSecret](v28, "sharedSecret"));
      unsigned int v35 = (void *)_NRKeyCreateLogString(v34);
      [v33 reportEvent:3013 details:v35];

      uint64_t v36 = mach_absolute_time();
      uint64_t v37 = *(void *)(a1 + 32);
      if (v37
        && ((v38 = *(void *)(v37 + 1863)) == 0 || (*(void *)(v38 + 112) = v36, (uint64_t v37 = *(void *)(a1 + 32)) != 0)))
      {
        uint64_t v39 = *(id *)(v37 + 1863);
        if (v39) {
          ++v39[13];
        }
      }

      else
      {
        uint64_t v39 = 0LL;
      }

      id v40 = sub_10010C0B8();
      [v40 setRequestChildlessSA:1];
      int v41 = objc_alloc(&OBJC_CLASS___NEIKEv2Session);
      uint64_t v42 = sub_10010C340();
      -[NEIKEv2ChildSAConfiguration setSequencePerTrafficClass:](v42, "setSequencePerTrafficClass:", 1LL);
      -[NEIKEv2ChildSAConfiguration setReplayWindowSize:](v42, "setReplayWindowSize:", 16LL);
      id v43 = -[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName:packetDelegate:]( v41,  "initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName :packetDelegate:",  v40,  v42,  v28,  *(void *)(*(void *)(a1 + 32) + 8LL),  0LL,  0LL,  @"terminusIKEForPairingWithOOBKey",  *(void *)(a1 + 32));
      uint64_t v44 = *(void *)(a1 + 32);
      uint64_t v45 = *(void **)(v44 + 1247);
      *(void *)(v44 + 1247) = v43;

      uint64_t v46 = *(void *)(a1 + 32);
      uint64_t v47 = *(void *)(v46 + 1247);
      uint64_t v49 = _NRCopyLogObjectForNRUUID(*(void *)(v46 + 32), v48);
      id v50 = (void *)v49;
      if (v47)
      {
        int v51 = _NRLogIsLevelEnabled(v49, 0LL);

        if (v51)
        {
          uint64_t v53 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v52);
          id v54 = [*(id *)(a1 + 32) copyDescription];
          _NRLogWithArgs( v53,  0LL,  "%s%.30s:%-4d %@: Created initiator OOBK pairing IKE session",  "",  "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]_block_invoke_2",  8852LL,  v54);
        }

        sub_1000751DC(*(void *)(a1 + 32));
        int v56 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v55);
        int v57 = _NRLogIsLevelEnabled(v56, 0LL);

        if (v57)
        {
          id v59 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v58);
          id v60 = [*(id *)(a1 + 32) copyDescription];
          _NRLogWithArgs( v59,  0LL,  "%s%.30s:%-4d %@: Connecting initiator OOBK pairing session",  "",  "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]_block_invoke_2",  8856LL,  v60);
        }

        [*(id *)(*(void *)(a1 + 32) + 1247) connect];
      }

      else
      {
        int v66 = _NRLogIsLevelEnabled(v49, 17LL);

        if (v66)
        {
          uint64_t v68 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v67);
          id v69 = [*(id *)(a1 + 32) copyDescription];
          _NRLogWithArgs(v68, 17LL, "%@: Failed to create initiator OOBK pairing IKE session", v69);
        }
      }
    }

    else
    {
      id v64 = sub_100070554();
      int v65 = _NRLogIsLevelEnabled(v64, 17LL);

      if (!v65) {
        goto LABEL_29;
      }
      id v40 = sub_100070554();
      _NRLogWithArgs(v40, 17LL, "Missing out of band key for %@, %@", *(void *)(a1 + 40), *(void *)(a1 + 32));
    }

LABEL_29:
    goto LABEL_30;
  }

  int v61 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v23 + 32), v22);
  int v62 = _NRLogIsLevelEnabled(v61, 0LL);

  if (v62)
  {
    id v26 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v63);
    uint64_t v28 = (NEIKEv2SessionConfiguration *)[*(id *)(a1 + 32) copyDescription];
    _NRLogWithArgs( v26,  0LL,  "%s%.30s:%-4d %@: Ignoring result as link is cancelled",  "",  "-[NRLinkBluetooth setupIPsecForPairingInitiatorIfNecessary]_block_invoke_2",  8815LL,  v28);
    goto LABEL_29;
  }

uint64_t sub_10009A014(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = os_channel_attr_create();
  if (!v4)
  {
    unsigned int v35 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
    uint64_t IsLevelEnabled = _NRLogIsLevelEnabled(v35, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_18;
    }
    uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v36);
    id v38 = [(id)a1 copyDescription];
    _NRLogWithArgs(v37, 17LL, "%@: os_channel_attr_create failed", v38);
    goto LABEL_13;
  }

  uint64_t v6 = v4;
  os_channel_attr_set(v4, 7LL, 1LL);
  [v3 getUUIDBytes:v78];
  uint64_t extended = os_channel_create_extended(v78, 0LL, 0LL, 0xFFFFFFFFLL, v6);
  if (!extended)
  {
    uint64_t v39 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v8);
    int v40 = _NRLogIsLevelEnabled(v39, 16LL);

    if (v40)
    {
      uint64_t v42 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v41);
      id v43 = [(id)a1 copyDescription];
      uint64_t v44 = __error();
      _NRLogWithArgs( v42,  16LL,  "%s%.30s:%-4d %@: os_channel_create_extended for %@ failed (errno %d)\n",  "",  "-[NRLinkBluetooth setupNexusChannelVoice:]",  2213LL,  v43,  v3,  *v44);
    }

    NEVirtualInterfaceDisableChannel([(id)a1 virtualInterface]);
    os_channel_attr_destroy(v6);
    goto LABEL_17;
  }

  uint64_t v9 = extended;
  *(void *)(a1 + 527) = extended;
  if (!sub_1000821D4((void *)a1, v6))
  {
LABEL_17:
    uint64_t IsLevelEnabled = 0LL;
    goto LABEL_18;
  }

  os_channel_attr_destroy(v6);
  uint64_t v10 = os_channel_ring_id(*(void *)(a1 + 527), 2LL);
  uint64_t v11 = os_channel_rx_ring(*(void *)(a1 + 527), v10);
  *(void *)(a1 + 535) = v11;
  if (!v11)
  {
    uint64_t v46 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v12);
    uint64_t IsLevelEnabled = _NRLogIsLevelEnabled(v46, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_18;
    }
    uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v47);
    id v38 = [(id)a1 copyDescription];
    _NRLogWithArgs(v37, 17LL, "%@: _nexusVOInputRing is NULL", v38);
    goto LABEL_13;
  }

  uint64_t v13 = os_channel_ring_id(*(void *)(a1 + 527), 0LL);
  uint64_t v14 = os_channel_tx_ring(*(void *)(a1 + 527), v13);
  *(void *)(a1 + 543) = v14;
  if (!v14)
  {
    uint64_t v48 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v15);
    uint64_t IsLevelEnabled = _NRLogIsLevelEnabled(v48, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_18;
    }
    uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v49);
    id v38 = [(id)a1 copyDescription];
    _NRLogWithArgs(v37, 17LL, "%@: _nexusVOOutputRing is NULL", v38);
    goto LABEL_13;
  }

  unsigned int fd = os_channel_get_fd(*(void *)(a1 + 527));
  if ((fd & 0x80000000) != 0)
  {
    id v50 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v17);
    uint64_t IsLevelEnabled = _NRLogIsLevelEnabled(v50, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_18;
    }
    uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v51);
    id v38 = [(id)a1 copyDescription];
    _NRLogWithArgs(v37, 17LL, "%@: os_channel_get_fd failed", v38);
LABEL_13:

    goto LABEL_17;
  }

  unsigned int v18 = fd;
  dispatch_group_t v19 = dispatch_group_create();
  if (!v19)
  {
    id v52 = sub_100070554();
    int v53 = _NRLogIsLevelEnabled(v52, 16LL);

    if (v53)
    {
      id v54 = sub_100070554();
      _NRLogWithArgs( v54,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nexusGroup) != ((void *)0)",  "",  "-[NRLinkBluetooth setupNexusChannelVoice:]",  2249);
    }

    uint64_t v55 = _os_log_pack_size(12LL);
    int v56 = (char *)block - ((v55 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v57 = *__error();
    uint64_t v58 = _os_log_pack_fill( v56,  v55,  v57,  &_mh_execute_header,  "%{public}s Assertion Failed: (nexusGroup) != ((void *)0)");
    goto LABEL_31;
  }

  uint64_t v20 = v19;
  dispatch_source_t v21 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_read,  v18,  0LL,  *(dispatch_queue_t *)(a1 + 8));
  uint64_t v22 = *(void **)(a1 + 551);
  *(void *)(a1 + 551) = v21;

  uint64_t v23 = *(dispatch_source_s **)(a1 + 551);
  if (!v23)
  {
    id v59 = sub_100070554();
    int v60 = _NRLogIsLevelEnabled(v59, 16LL);

    if (v60)
    {
      id v61 = sub_100070554();
      _NRLogWithArgs( v61,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusVOInputSource) != ((void *)0)",  "",  "-[NRLinkBluetooth setupNexusChannelVoice:]",  2253);
    }

    uint64_t v62 = _os_log_pack_size(12LL);
    int v56 = (char *)block - ((v62 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v63 = *__error();
    uint64_t v58 = _os_log_pack_fill( v56,  v62,  v63,  &_mh_execute_header,  "%{public}s Assertion Failed: (_dNexusVOInputSource) != ((void *)0)");
LABEL_31:
    *(_DWORD *)uint64_t v58 = 136446210;
    *(void *)(v58 + 4) = "-[NRLinkBluetooth setupNexusChannelVoice:]";
    goto LABEL_35;
  }

  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_10009C668;
  handler[3] = &unk_1001B0A88;
  void handler[4] = a1;
  dispatch_source_set_event_handler(v23, handler);
  dispatch_group_enter(v20);
  uint64_t v24 = *(dispatch_source_s **)(a1 + 551);
  v75[0] = _NSConcreteStackBlock;
  v75[1] = 3221225472LL;
  v75[2] = sub_10009C7F0;
  v75[3] = &unk_1001B0A88;
  uint64_t v25 = v20;
  uint64_t v76 = v25;
  dispatch_source_set_cancel_handler(v24, v75);
  dispatch_activate(*(dispatch_object_t *)(a1 + 551));
  dispatch_source_t v26 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_write,  v18,  0LL,  *(dispatch_queue_t *)(a1 + 8));
  id v27 = *(void **)(a1 + 559);
  *(void *)(a1 + 559) = v26;

  uint64_t v28 = *(dispatch_source_s **)(a1 + 559);
  if (!v28)
  {
    id v64 = sub_100070554();
    int v65 = _NRLogIsLevelEnabled(v64, 16LL);

    if (v65)
    {
      id v66 = sub_100070554();
      _NRLogWithArgs( v66,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusVOOutputSource) != ((void *)0)",  "",  "-[NRLinkBluetooth setupNexusChannelVoice:]",  2271);
    }

    uint64_t v67 = _os_log_pack_size(12LL);
    int v56 = (char *)block - ((v67 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v68 = __error();
    uint64_t v69 = _os_log_pack_fill( v56,  v67,  *v68,  &_mh_execute_header,  "%{public}s Assertion Failed: (_dNexusVOOutputSource) != ((void *)0)");
    *(_DWORD *)uint64_t v69 = 136446210;
    *(void *)(v69 + 4) = "-[NRLinkBluetooth setupNexusChannelVoice:]";
LABEL_35:
    id v70 = sub_100070554();
    _NRLogAbortWithPack(v70, v56);
  }

  v74[0] = _NSConcreteStackBlock;
  v74[1] = 3221225472LL;
  v74[2] = sub_10009C7F8;
  v74[3] = &unk_1001B0A88;
  v74[4] = a1;
  dispatch_source_set_event_handler(v28, v74);
  dispatch_group_enter(v25);
  uint64_t v29 = *(dispatch_source_s **)(a1 + 559);
  v72[0] = _NSConcreteStackBlock;
  v72[1] = 3221225472LL;
  v72[2] = sub_10009C974;
  v72[3] = &unk_1001B0A88;
  id v30 = v25;
  uint64_t v73 = v30;
  dispatch_source_set_cancel_handler(v29, v72);
  uint64_t IsLevelEnabled = 1LL;
  *(_BYTE *)(a1 + 215) = 1;
  char v32 = *(dispatch_queue_s **)(a1 + 8);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10009C97C;
  block[3] = &unk_1001B0578;
  block[4] = v9;
  dispatch_group_notify(v30, v32, block);
  int v33 = *(void **)(a1 + 519);
  *(void *)(a1 + 519) = v30;
  uint64_t v34 = v30;

LABEL_18:
  return IsLevelEnabled;
}

uint64_t sub_10009A754(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = os_channel_attr_create();
  if (!v4)
  {
    unsigned int v35 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
    uint64_t IsLevelEnabled = _NRLogIsLevelEnabled(v35, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_18;
    }
    uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v36);
    id v38 = [(id)a1 copyDescription];
    _NRLogWithArgs(v37, 17LL, "%@: os_channel_attr_create failed", v38);
    goto LABEL_13;
  }

  uint64_t v6 = v4;
  os_channel_attr_set(v4, 7LL, 1LL);
  [v3 getUUIDBytes:v78];
  uint64_t extended = os_channel_create_extended(v78, 0LL, 0LL, 0xFFFFFFFFLL, v6);
  if (!extended)
  {
    uint64_t v39 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v8);
    int v40 = _NRLogIsLevelEnabled(v39, 16LL);

    if (v40)
    {
      uint64_t v42 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v41);
      id v43 = [(id)a1 copyDescription];
      uint64_t v44 = __error();
      _NRLogWithArgs( v42,  16LL,  "%s%.30s:%-4d %@: os_channel_create_extended for %@ failed (errno %d)\n",  "",  "-[NRLinkBluetooth setupNexusChannelVideo:]",  1923LL,  v43,  v3,  *v44);
    }

    NEVirtualInterfaceDisableChannel([(id)a1 virtualInterface]);
    os_channel_attr_destroy(v6);
    goto LABEL_17;
  }

  uint64_t v9 = extended;
  *(void *)(a1 + 671) = extended;
  if (!sub_1000821D4((void *)a1, v6))
  {
LABEL_17:
    uint64_t IsLevelEnabled = 0LL;
    goto LABEL_18;
  }

  os_channel_attr_destroy(v6);
  uint64_t v10 = os_channel_ring_id(*(void *)(a1 + 671), 2LL);
  uint64_t v11 = os_channel_rx_ring(*(void *)(a1 + 671), v10);
  *(void *)(a1 + 679) = v11;
  if (!v11)
  {
    uint64_t v46 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v12);
    uint64_t IsLevelEnabled = _NRLogIsLevelEnabled(v46, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_18;
    }
    uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v47);
    id v38 = [(id)a1 copyDescription];
    _NRLogWithArgs(v37, 17LL, "%@: _nexusVIInputRing is NULL", v38);
    goto LABEL_13;
  }

  uint64_t v13 = os_channel_ring_id(*(void *)(a1 + 671), 0LL);
  uint64_t v14 = os_channel_tx_ring(*(void *)(a1 + 671), v13);
  *(void *)(a1 + 687) = v14;
  if (!v14)
  {
    uint64_t v48 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v15);
    uint64_t IsLevelEnabled = _NRLogIsLevelEnabled(v48, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_18;
    }
    uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v49);
    id v38 = [(id)a1 copyDescription];
    _NRLogWithArgs(v37, 17LL, "%@: _nexusVIOutputRing is NULL", v38);
    goto LABEL_13;
  }

  unsigned int fd = os_channel_get_fd(*(void *)(a1 + 671));
  if ((fd & 0x80000000) != 0)
  {
    id v50 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v17);
    uint64_t IsLevelEnabled = _NRLogIsLevelEnabled(v50, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_18;
    }
    uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v51);
    id v38 = [(id)a1 copyDescription];
    _NRLogWithArgs(v37, 17LL, "%@: os_channel_get_fd failed", v38);
LABEL_13:

    goto LABEL_17;
  }

  unsigned int v18 = fd;
  dispatch_group_t v19 = dispatch_group_create();
  if (!v19)
  {
    id v52 = sub_100070554();
    int v53 = _NRLogIsLevelEnabled(v52, 16LL);

    if (v53)
    {
      id v54 = sub_100070554();
      _NRLogWithArgs( v54,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nexusGroup) != ((void *)0)",  "",  "-[NRLinkBluetooth setupNexusChannelVideo:]",  1959);
    }

    uint64_t v55 = _os_log_pack_size(12LL);
    int v56 = (char *)block - ((v55 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v57 = *__error();
    uint64_t v58 = _os_log_pack_fill( v56,  v55,  v57,  &_mh_execute_header,  "%{public}s Assertion Failed: (nexusGroup) != ((void *)0)");
    goto LABEL_31;
  }

  uint64_t v20 = v19;
  dispatch_source_t v21 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_read,  v18,  0LL,  *(dispatch_queue_t *)(a1 + 8));
  uint64_t v22 = *(void **)(a1 + 695);
  *(void *)(a1 + 695) = v21;

  uint64_t v23 = *(dispatch_source_s **)(a1 + 695);
  if (!v23)
  {
    id v59 = sub_100070554();
    int v60 = _NRLogIsLevelEnabled(v59, 16LL);

    if (v60)
    {
      id v61 = sub_100070554();
      _NRLogWithArgs( v61,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusVIInputSource) != ((void *)0)",  "",  "-[NRLinkBluetooth setupNexusChannelVideo:]",  1963);
    }

    uint64_t v62 = _os_log_pack_size(12LL);
    int v56 = (char *)block - ((v62 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v63 = *__error();
    uint64_t v58 = _os_log_pack_fill( v56,  v62,  v63,  &_mh_execute_header,  "%{public}s Assertion Failed: (_dNexusVIInputSource) != ((void *)0)");
LABEL_31:
    *(_DWORD *)uint64_t v58 = 136446210;
    *(void *)(v58 + 4) = "-[NRLinkBluetooth setupNexusChannelVideo:]";
    goto LABEL_35;
  }

  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_10009C34C;
  handler[3] = &unk_1001B0A88;
  void handler[4] = a1;
  dispatch_source_set_event_handler(v23, handler);
  dispatch_group_enter(v20);
  uint64_t v24 = *(dispatch_source_s **)(a1 + 695);
  v75[0] = _NSConcreteStackBlock;
  v75[1] = 3221225472LL;
  v75[2] = sub_10009C4D4;
  v75[3] = &unk_1001B0A88;
  uint64_t v25 = v20;
  uint64_t v76 = v25;
  dispatch_source_set_cancel_handler(v24, v75);
  dispatch_activate(*(dispatch_object_t *)(a1 + 695));
  dispatch_source_t v26 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_write,  v18,  0LL,  *(dispatch_queue_t *)(a1 + 8));
  id v27 = *(void **)(a1 + 703);
  *(void *)(a1 + 703) = v26;

  uint64_t v28 = *(dispatch_source_s **)(a1 + 703);
  if (!v28)
  {
    id v64 = sub_100070554();
    int v65 = _NRLogIsLevelEnabled(v64, 16LL);

    if (v65)
    {
      id v66 = sub_100070554();
      _NRLogWithArgs( v66,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusVIOutputSource) != ((void *)0)",  "",  "-[NRLinkBluetooth setupNexusChannelVideo:]",  1981);
    }

    uint64_t v67 = _os_log_pack_size(12LL);
    int v56 = (char *)block - ((v67 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v68 = __error();
    uint64_t v69 = _os_log_pack_fill( v56,  v67,  *v68,  &_mh_execute_header,  "%{public}s Assertion Failed: (_dNexusVIOutputSource) != ((void *)0)");
    *(_DWORD *)uint64_t v69 = 136446210;
    *(void *)(v69 + 4) = "-[NRLinkBluetooth setupNexusChannelVideo:]";
LABEL_35:
    id v70 = sub_100070554();
    _NRLogAbortWithPack(v70, v56);
  }

  v74[0] = _NSConcreteStackBlock;
  v74[1] = 3221225472LL;
  v74[2] = sub_10009C4DC;
  v74[3] = &unk_1001B0A88;
  v74[4] = a1;
  dispatch_source_set_event_handler(v28, v74);
  dispatch_group_enter(v25);
  uint64_t v29 = *(dispatch_source_s **)(a1 + 703);
  v72[0] = _NSConcreteStackBlock;
  v72[1] = 3221225472LL;
  v72[2] = sub_10009C658;
  v72[3] = &unk_1001B0A88;
  id v30 = v25;
  uint64_t v73 = v30;
  dispatch_source_set_cancel_handler(v29, v72);
  uint64_t IsLevelEnabled = 1LL;
  *(_BYTE *)(a1 + 217) = 1;
  char v32 = *(dispatch_queue_s **)(a1 + 8);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10009C660;
  block[3] = &unk_1001B0578;
  block[4] = v9;
  dispatch_group_notify(v30, v32, block);
  int v33 = *(void **)(a1 + 663);
  *(void *)(a1 + 663) = v30;
  uint64_t v34 = v30;

LABEL_18:
  return IsLevelEnabled;
}

uint64_t sub_10009AE94(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = os_channel_attr_create();
  if (!v4)
  {
    unsigned int v35 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
    uint64_t IsLevelEnabled = _NRLogIsLevelEnabled(v35, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_18;
    }
    uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v36);
    id v38 = [(id)a1 copyDescription];
    _NRLogWithArgs(v37, 17LL, "%@: os_channel_attr_create failed", v38);
    goto LABEL_13;
  }

  uint64_t v6 = v4;
  os_channel_attr_set(v4, 7LL, 1LL);
  [v3 getUUIDBytes:v78];
  uint64_t extended = os_channel_create_extended(v78, 0LL, 0LL, 0xFFFFFFFFLL, v6);
  if (!extended)
  {
    uint64_t v39 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v8);
    int v40 = _NRLogIsLevelEnabled(v39, 16LL);

    if (v40)
    {
      uint64_t v42 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v41);
      id v43 = [(id)a1 copyDescription];
      uint64_t v44 = __error();
      _NRLogWithArgs( v42,  16LL,  "%s%.30s:%-4d %@: os_channel_create_extended for %@ failed (errno %d)\n",  "",  "-[NRLinkBluetooth setupNexusChannelBestEffort:]",  2117LL,  v43,  v3,  *v44);
    }

    NEVirtualInterfaceDisableChannel([(id)a1 virtualInterface]);
    os_channel_attr_destroy(v6);
    goto LABEL_17;
  }

  uint64_t v9 = extended;
  *(void *)(a1 + 367) = extended;
  if (!sub_1000821D4((void *)a1, v6))
  {
LABEL_17:
    uint64_t IsLevelEnabled = 0LL;
    goto LABEL_18;
  }

  os_channel_attr_destroy(v6);
  uint64_t v10 = os_channel_ring_id(*(void *)(a1 + 367), 2LL);
  uint64_t v11 = os_channel_rx_ring(*(void *)(a1 + 367), v10);
  *(void *)(a1 + 375) = v11;
  if (!v11)
  {
    uint64_t v46 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v12);
    uint64_t IsLevelEnabled = _NRLogIsLevelEnabled(v46, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_18;
    }
    uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v47);
    id v38 = [(id)a1 copyDescription];
    _NRLogWithArgs(v37, 17LL, "%@: _nexusInputRing is NULL", v38);
    goto LABEL_13;
  }

  uint64_t v13 = os_channel_ring_id(*(void *)(a1 + 367), 0LL);
  uint64_t v14 = os_channel_tx_ring(*(void *)(a1 + 367), v13);
  *(void *)(a1 + 383) = v14;
  if (!v14)
  {
    uint64_t v48 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v15);
    uint64_t IsLevelEnabled = _NRLogIsLevelEnabled(v48, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_18;
    }
    uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v49);
    id v38 = [(id)a1 copyDescription];
    _NRLogWithArgs(v37, 17LL, "%@: _nexusOutputRing is NULL", v38);
    goto LABEL_13;
  }

  unsigned int fd = os_channel_get_fd(*(void *)(a1 + 367));
  if ((fd & 0x80000000) != 0)
  {
    id v50 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v17);
    uint64_t IsLevelEnabled = _NRLogIsLevelEnabled(v50, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_18;
    }
    uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v51);
    id v38 = [(id)a1 copyDescription];
    _NRLogWithArgs(v37, 17LL, "%@: os_channel_get_fd failed", v38);
LABEL_13:

    goto LABEL_17;
  }

  unsigned int v18 = fd;
  dispatch_group_t v19 = dispatch_group_create();
  if (!v19)
  {
    id v52 = sub_100070554();
    int v53 = _NRLogIsLevelEnabled(v52, 16LL);

    if (v53)
    {
      id v54 = sub_100070554();
      _NRLogWithArgs( v54,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nexusGroup) != ((void *)0)",  "",  "-[NRLinkBluetooth setupNexusChannelBestEffort:]",  2153);
    }

    uint64_t v55 = _os_log_pack_size(12LL);
    int v56 = (char *)block - ((v55 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v57 = *__error();
    uint64_t v58 = _os_log_pack_fill( v56,  v55,  v57,  &_mh_execute_header,  "%{public}s Assertion Failed: (nexusGroup) != ((void *)0)");
    goto LABEL_31;
  }

  uint64_t v20 = v19;
  dispatch_source_t v21 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_read,  v18,  0LL,  *(dispatch_queue_t *)(a1 + 8));
  uint64_t v22 = *(void **)(a1 + 391);
  *(void *)(a1 + 391) = v21;

  uint64_t v23 = *(dispatch_source_s **)(a1 + 391);
  if (!v23)
  {
    id v59 = sub_100070554();
    int v60 = _NRLogIsLevelEnabled(v59, 16LL);

    if (v60)
    {
      id v61 = sub_100070554();
      _NRLogWithArgs( v61,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusInputSource) != ((void *)0)",  "",  "-[NRLinkBluetooth setupNexusChannelBestEffort:]",  2156);
    }

    uint64_t v62 = _os_log_pack_size(12LL);
    int v56 = (char *)block - ((v62 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v63 = *__error();
    uint64_t v58 = _os_log_pack_fill( v56,  v62,  v63,  &_mh_execute_header,  "%{public}s Assertion Failed: (_dNexusInputSource) != ((void *)0)");
LABEL_31:
    *(_DWORD *)uint64_t v58 = 136446210;
    *(void *)(v58 + 4) = "-[NRLinkBluetooth setupNexusChannelBestEffort:]";
    goto LABEL_35;
  }

  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_10009C030;
  handler[3] = &unk_1001B0A88;
  void handler[4] = a1;
  dispatch_source_set_event_handler(v23, handler);
  dispatch_group_enter(v20);
  uint64_t v24 = *(dispatch_source_s **)(a1 + 391);
  v75[0] = _NSConcreteStackBlock;
  v75[1] = 3221225472LL;
  v75[2] = sub_10009C1B8;
  v75[3] = &unk_1001B0A88;
  uint64_t v25 = v20;
  uint64_t v76 = v25;
  dispatch_source_set_cancel_handler(v24, v75);
  dispatch_activate(*(dispatch_object_t *)(a1 + 391));
  dispatch_source_t v26 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_write,  v18,  0LL,  *(dispatch_queue_t *)(a1 + 8));
  id v27 = *(void **)(a1 + 399);
  *(void *)(a1 + 399) = v26;

  uint64_t v28 = *(dispatch_source_s **)(a1 + 399);
  if (!v28)
  {
    id v64 = sub_100070554();
    int v65 = _NRLogIsLevelEnabled(v64, 16LL);

    if (v65)
    {
      id v66 = sub_100070554();
      _NRLogWithArgs( v66,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusOutputSource) != ((void *)0)",  "",  "-[NRLinkBluetooth setupNexusChannelBestEffort:]",  2174);
    }

    uint64_t v67 = _os_log_pack_size(12LL);
    int v56 = (char *)block - ((v67 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v68 = __error();
    uint64_t v69 = _os_log_pack_fill( v56,  v67,  *v68,  &_mh_execute_header,  "%{public}s Assertion Failed: (_dNexusOutputSource) != ((void *)0)");
    *(_DWORD *)uint64_t v69 = 136446210;
    *(void *)(v69 + 4) = "-[NRLinkBluetooth setupNexusChannelBestEffort:]";
LABEL_35:
    id v70 = sub_100070554();
    _NRLogAbortWithPack(v70, v56);
  }

  v74[0] = _NSConcreteStackBlock;
  v74[1] = 3221225472LL;
  v74[2] = sub_10009C1C0;
  v74[3] = &unk_1001B0A88;
  v74[4] = a1;
  dispatch_source_set_event_handler(v28, v74);
  dispatch_group_enter(v25);
  uint64_t v29 = *(dispatch_source_s **)(a1 + 399);
  v72[0] = _NSConcreteStackBlock;
  v72[1] = 3221225472LL;
  v72[2] = sub_10009C33C;
  v72[3] = &unk_1001B0A88;
  id v30 = v25;
  uint64_t v73 = v30;
  dispatch_source_set_cancel_handler(v29, v72);
  uint64_t IsLevelEnabled = 1LL;
  *(_BYTE *)(a1 + 213) = 1;
  char v32 = *(dispatch_queue_s **)(a1 + 8);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10009C344;
  block[3] = &unk_1001B0578;
  block[4] = v9;
  dispatch_group_notify(v30, v32, block);
  int v33 = *(void **)(a1 + 407);
  *(void *)(a1 + 407) = v30;
  uint64_t v34 = v30;

LABEL_18:
  return IsLevelEnabled;
}

uint64_t sub_10009B5D4(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = os_channel_attr_create();
  if (!v4)
  {
    unsigned int v35 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
    uint64_t IsLevelEnabled = _NRLogIsLevelEnabled(v35, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_18;
    }
    uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v36);
    id v38 = [(id)a1 copyDescription];
    _NRLogWithArgs(v37, 17LL, "%@: os_channel_attr_create failed", v38);
    goto LABEL_13;
  }

  uint64_t v6 = v4;
  os_channel_attr_set(v4, 7LL, 1LL);
  [v3 getUUIDBytes:v78];
  uint64_t extended = os_channel_create_extended(v78, 0LL, 0LL, 0xFFFFFFFFLL, v6);
  if (!extended)
  {
    uint64_t v39 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v8);
    int v40 = _NRLogIsLevelEnabled(v39, 16LL);

    if (v40)
    {
      uint64_t v42 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v41);
      id v43 = [(id)a1 copyDescription];
      uint64_t v44 = __error();
      _NRLogWithArgs( v42,  16LL,  "%s%.30s:%-4d %@: os_channel_create_extended for %@ failed (errno %d)\n",  "",  "-[NRLinkBluetooth setupNexusChannelBackground:]",  2020LL,  v43,  v3,  *v44);
    }

    NEVirtualInterfaceDisableChannel([(id)a1 virtualInterface]);
    os_channel_attr_destroy(v6);
    goto LABEL_17;
  }

  uint64_t v9 = extended;
  *(void *)(a1 + 815) = extended;
  if (!sub_1000821D4((void *)a1, v6))
  {
LABEL_17:
    uint64_t IsLevelEnabled = 0LL;
    goto LABEL_18;
  }

  os_channel_attr_destroy(v6);
  uint64_t v10 = os_channel_ring_id(*(void *)(a1 + 815), 2LL);
  uint64_t v11 = os_channel_rx_ring(*(void *)(a1 + 815), v10);
  *(void *)(a1 + 823) = v11;
  if (!v11)
  {
    uint64_t v46 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v12);
    uint64_t IsLevelEnabled = _NRLogIsLevelEnabled(v46, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_18;
    }
    uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v47);
    id v38 = [(id)a1 copyDescription];
    _NRLogWithArgs(v37, 17LL, "%@: _nexusBKInputRing is NULL", v38);
    goto LABEL_13;
  }

  uint64_t v13 = os_channel_ring_id(*(void *)(a1 + 815), 0LL);
  uint64_t v14 = os_channel_tx_ring(*(void *)(a1 + 815), v13);
  *(void *)(a1 + 831) = v14;
  if (!v14)
  {
    uint64_t v48 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v15);
    uint64_t IsLevelEnabled = _NRLogIsLevelEnabled(v48, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_18;
    }
    uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v49);
    id v38 = [(id)a1 copyDescription];
    _NRLogWithArgs(v37, 17LL, "%@: _nexusBKOutputRing is NULL", v38);
    goto LABEL_13;
  }

  unsigned int fd = os_channel_get_fd(*(void *)(a1 + 815));
  if ((fd & 0x80000000) != 0)
  {
    id v50 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v17);
    uint64_t IsLevelEnabled = _NRLogIsLevelEnabled(v50, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_18;
    }
    uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v51);
    id v38 = [(id)a1 copyDescription];
    _NRLogWithArgs(v37, 17LL, "%@: os_channel_get_fd failed", v38);
LABEL_13:

    goto LABEL_17;
  }

  unsigned int v18 = fd;
  dispatch_group_t v19 = dispatch_group_create();
  if (!v19)
  {
    id v52 = sub_100070554();
    int v53 = _NRLogIsLevelEnabled(v52, 16LL);

    if (v53)
    {
      id v54 = sub_100070554();
      _NRLogWithArgs( v54,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nexusGroup) != ((void *)0)",  "",  "-[NRLinkBluetooth setupNexusChannelBackground:]",  2056);
    }

    uint64_t v55 = _os_log_pack_size(12LL);
    int v56 = (char *)block - ((v55 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v57 = *__error();
    uint64_t v58 = _os_log_pack_fill( v56,  v55,  v57,  &_mh_execute_header,  "%{public}s Assertion Failed: (nexusGroup) != ((void *)0)");
    goto LABEL_31;
  }

  uint64_t v20 = v19;
  dispatch_source_t v21 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_read,  v18,  0LL,  *(dispatch_queue_t *)(a1 + 8));
  uint64_t v22 = *(void **)(a1 + 839);
  *(void *)(a1 + 839) = v21;

  uint64_t v23 = *(dispatch_source_s **)(a1 + 839);
  if (!v23)
  {
    id v59 = sub_100070554();
    int v60 = _NRLogIsLevelEnabled(v59, 16LL);

    if (v60)
    {
      id v61 = sub_100070554();
      _NRLogWithArgs( v61,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusBKInputSource) != ((void *)0)",  "",  "-[NRLinkBluetooth setupNexusChannelBackground:]",  2060);
    }

    uint64_t v62 = _os_log_pack_size(12LL);
    int v56 = (char *)block - ((v62 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v63 = *__error();
    uint64_t v58 = _os_log_pack_fill( v56,  v62,  v63,  &_mh_execute_header,  "%{public}s Assertion Failed: (_dNexusBKInputSource) != ((void *)0)");
LABEL_31:
    *(_DWORD *)uint64_t v58 = 136446210;
    *(void *)(v58 + 4) = "-[NRLinkBluetooth setupNexusChannelBackground:]";
    goto LABEL_35;
  }

  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_10009BD14;
  handler[3] = &unk_1001B0A88;
  void handler[4] = a1;
  dispatch_source_set_event_handler(v23, handler);
  dispatch_group_enter(v20);
  uint64_t v24 = *(dispatch_source_s **)(a1 + 839);
  v75[0] = _NSConcreteStackBlock;
  v75[1] = 3221225472LL;
  v75[2] = sub_10009BE9C;
  v75[3] = &unk_1001B0A88;
  uint64_t v25 = v20;
  uint64_t v76 = v25;
  dispatch_source_set_cancel_handler(v24, v75);
  dispatch_activate(*(dispatch_object_t *)(a1 + 839));
  dispatch_source_t v26 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_write,  v18,  0LL,  *(dispatch_queue_t *)(a1 + 8));
  id v27 = *(void **)(a1 + 847);
  *(void *)(a1 + 847) = v26;

  uint64_t v28 = *(dispatch_source_s **)(a1 + 847);
  if (!v28)
  {
    id v64 = sub_100070554();
    int v65 = _NRLogIsLevelEnabled(v64, 16LL);

    if (v65)
    {
      id v66 = sub_100070554();
      _NRLogWithArgs( v66,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusBKOutputSource) != ((void *)0)",  "",  "-[NRLinkBluetooth setupNexusChannelBackground:]",  2078);
    }

    uint64_t v67 = _os_log_pack_size(12LL);
    int v56 = (char *)block - ((v67 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v68 = __error();
    uint64_t v69 = _os_log_pack_fill( v56,  v67,  *v68,  &_mh_execute_header,  "%{public}s Assertion Failed: (_dNexusBKOutputSource) != ((void *)0)");
    *(_DWORD *)uint64_t v69 = 136446210;
    *(void *)(v69 + 4) = "-[NRLinkBluetooth setupNexusChannelBackground:]";
LABEL_35:
    id v70 = sub_100070554();
    _NRLogAbortWithPack(v70, v56);
  }

  v74[0] = _NSConcreteStackBlock;
  v74[1] = 3221225472LL;
  v74[2] = sub_10009BEA4;
  v74[3] = &unk_1001B0A88;
  v74[4] = a1;
  dispatch_source_set_event_handler(v28, v74);
  dispatch_group_enter(v25);
  uint64_t v29 = *(dispatch_source_s **)(a1 + 847);
  v72[0] = _NSConcreteStackBlock;
  v72[1] = 3221225472LL;
  v72[2] = sub_10009C020;
  v72[3] = &unk_1001B0A88;
  id v30 = v25;
  uint64_t v73 = v30;
  dispatch_source_set_cancel_handler(v29, v72);
  uint64_t IsLevelEnabled = 1LL;
  *(_BYTE *)(a1 + 219) = 1;
  char v32 = *(dispatch_queue_s **)(a1 + 8);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10009C028;
  block[3] = &unk_1001B0578;
  block[4] = v9;
  dispatch_group_notify(v30, v32, block);
  int v33 = *(void **)(a1 + 807);
  *(void *)(a1 + 807) = v30;
  uint64_t v34 = v30;

LABEL_18:
  return IsLevelEnabled;
}

void sub_10009BD14(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16LL);

    if (IsLevelEnabled)
    {
      id v13 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
      id v7 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d %@: Nexus BK input available but cancelled",  "",  "-[NRLinkBluetooth setupNexusChannelBackground:]_block_invoke",  2063LL,  v7);
    }
  }

  else
  {
    ++*(void *)(v3 + 887);
    if (gNRPacketLoggingEnabled)
    {
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), a2);
      int v9 = _NRLogIsLevelEnabled(v8, 1LL);

      if (v9)
      {
        uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v10);
        id v12 = [*(id *)(a1 + 32) copyDescription];
        _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d %@: Nexus BK input available",  "",  "-[NRLinkBluetooth setupNexusChannelBackground:]_block_invoke",  2067LL,  v12);
      }
    }

    sub_100070E0C(*(void **)(a1 + 32), *(void *)(*(void *)(a1 + 32) + 815LL));
  }

void sub_10009BE9C(uint64_t a1)
{
}

void sub_10009BEA4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16LL);

    if (IsLevelEnabled)
    {
      id v13 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
      id v7 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d %@: Nexus BK output available but cancelled",  "",  "-[NRLinkBluetooth setupNexusChannelBackground:]_block_invoke",  2081LL,  v7);
    }
  }

  else
  {
    ++*(void *)(v3 + 895);
    if (gNRPacketLoggingEnabled)
    {
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), a2);
      int v9 = _NRLogIsLevelEnabled(v8, 1LL);

      if (v9)
      {
        uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v10);
        id v12 = [*(id *)(a1 + 32) copyDescription];
        _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d %@: Nexus BK output available",  "",  "-[NRLinkBluetooth setupNexusChannelBackground:]_block_invoke",  2085LL,  v12);
      }
    }

    sub_1000909CC(*(void **)(a1 + 32));
  }

void sub_10009C020(uint64_t a1)
{
}

uint64_t sub_10009C028(uint64_t a1)
{
  return os_channel_destroy(*(void *)(a1 + 32));
}

void sub_10009C030(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16LL);

    if (IsLevelEnabled)
    {
      id v13 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
      id v7 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d %@: Nexus input available but cancelled",  "",  "-[NRLinkBluetooth setupNexusChannelBestEffort:]_block_invoke",  2159LL,  v7);
    }
  }

  else
  {
    ++*(void *)(v3 + 455);
    if (gNRPacketLoggingEnabled)
    {
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), a2);
      int v9 = _NRLogIsLevelEnabled(v8, 1LL);

      if (v9)
      {
        uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v10);
        id v12 = [*(id *)(a1 + 32) copyDescription];
        _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d %@: Nexus input available",  "",  "-[NRLinkBluetooth setupNexusChannelBestEffort:]_block_invoke",  2163LL,  v12);
      }
    }

    sub_100070E0C(*(void **)(a1 + 32), *(void *)(*(void *)(a1 + 32) + 367LL));
  }

void sub_10009C1B8(uint64_t a1)
{
}

void sub_10009C1C0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16LL);

    if (IsLevelEnabled)
    {
      id v13 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
      id v7 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d %@: Nexus output available but cancelled",  "",  "-[NRLinkBluetooth setupNexusChannelBestEffort:]_block_invoke",  2177LL,  v7);
    }
  }

  else
  {
    ++*(void *)(v3 + 463);
    if (gNRPacketLoggingEnabled)
    {
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), a2);
      int v9 = _NRLogIsLevelEnabled(v8, 1LL);

      if (v9)
      {
        uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v10);
        id v12 = [*(id *)(a1 + 32) copyDescription];
        _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d %@: Nexus output available",  "",  "-[NRLinkBluetooth setupNexusChannelBestEffort:]_block_invoke",  2181LL,  v12);
      }
    }

    sub_1000909CC(*(void **)(a1 + 32));
  }

void sub_10009C33C(uint64_t a1)
{
}

uint64_t sub_10009C344(uint64_t a1)
{
  return os_channel_destroy(*(void *)(a1 + 32));
}

void sub_10009C34C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16LL);

    if (IsLevelEnabled)
    {
      id v13 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
      id v7 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d %@: Nexus VI input available but cancelled",  "",  "-[NRLinkBluetooth setupNexusChannelVideo:]_block_invoke",  1966LL,  v7);
    }
  }

  else
  {
    ++*(void *)(v3 + 743);
    if (gNRPacketLoggingEnabled)
    {
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), a2);
      int v9 = _NRLogIsLevelEnabled(v8, 1LL);

      if (v9)
      {
        uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v10);
        id v12 = [*(id *)(a1 + 32) copyDescription];
        _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d %@: Nexus VI input available",  "",  "-[NRLinkBluetooth setupNexusChannelVideo:]_block_invoke",  1970LL,  v12);
      }
    }

    sub_100083874(*(void **)(a1 + 32), *(void *)(*(void *)(a1 + 32) + 671LL));
  }

void sub_10009C4D4(uint64_t a1)
{
}

void sub_10009C4DC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16LL);

    if (IsLevelEnabled)
    {
      id v13 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
      id v7 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d %@: Nexus VI output available but cancelled",  "",  "-[NRLinkBluetooth setupNexusChannelVideo:]_block_invoke",  1984LL,  v7);
    }
  }

  else
  {
    ++*(void *)(v3 + 751);
    if (gNRPacketLoggingEnabled)
    {
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), a2);
      int v9 = _NRLogIsLevelEnabled(v8, 1LL);

      if (v9)
      {
        uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v10);
        id v12 = [*(id *)(a1 + 32) copyDescription];
        _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d %@: Nexus VI output available",  "",  "-[NRLinkBluetooth setupNexusChannelVideo:]_block_invoke",  1988LL,  v12);
      }
    }

    sub_1000869EC(*(void **)(a1 + 32));
  }

void sub_10009C658(uint64_t a1)
{
}

uint64_t sub_10009C660(uint64_t a1)
{
  return os_channel_destroy(*(void *)(a1 + 32));
}

void sub_10009C668(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16LL);

    if (IsLevelEnabled)
    {
      id v13 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
      id v7 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d %@: Nexus VO input available but cancelled",  "",  "-[NRLinkBluetooth setupNexusChannelVoice:]_block_invoke",  2256LL,  v7);
    }
  }

  else
  {
    ++*(void *)(v3 + 599);
    if (gNRPacketLoggingEnabled)
    {
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), a2);
      int v9 = _NRLogIsLevelEnabled(v8, 1LL);

      if (v9)
      {
        uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v10);
        id v12 = [*(id *)(a1 + 32) copyDescription];
        _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d %@: Nexus VO input available",  "",  "-[NRLinkBluetooth setupNexusChannelVoice:]_block_invoke",  2260LL,  v12);
      }
    }

    sub_100083874(*(void **)(a1 + 32), *(void *)(*(void *)(a1 + 32) + 527LL));
  }

void sub_10009C7F0(uint64_t a1)
{
}

void sub_10009C7F8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16LL);

    if (IsLevelEnabled)
    {
      id v13 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
      id v7 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d %@: Nexus VO output available but cancelled",  "",  "-[NRLinkBluetooth setupNexusChannelVoice:]_block_invoke",  2274LL,  v7);
    }
  }

  else
  {
    ++*(void *)(v3 + 607);
    if (gNRPacketLoggingEnabled)
    {
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), a2);
      int v9 = _NRLogIsLevelEnabled(v8, 1LL);

      if (v9)
      {
        uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v10);
        id v12 = [*(id *)(a1 + 32) copyDescription];
        _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d %@: Nexus VO output available",  "",  "-[NRLinkBluetooth setupNexusChannelVoice:]_block_invoke",  2278LL,  v12);
      }
    }

    sub_10009C984(*(void **)(a1 + 32));
  }

void sub_10009C974(uint64_t a1)
{
}

uint64_t sub_10009C97C(uint64_t a1)
{
  return os_channel_destroy(*(void *)(a1 + 32));
}

void sub_10009C984(void *a1)
{
  uint64_t v1 = a1;
  uint64_t v3 = (char *)v1;
  int v4 = *((unsigned __int8 *)v1 + 16);
  if (v4 == 255)
  {
    uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(v1[4], v2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16LL);

    if (IsLevelEnabled)
    {
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v7);
      id v9 = [v3 copyDescription];
      _NRLogWithArgs( v8,  16LL,  "%s%.30s:%-4d %@: LinkToNexusLoop but cancelled",  "",  "NRLinkDatagramLinkToNexusLoop",  4188LL,  v9);
LABEL_11:

      goto LABEL_12;
    }

    goto LABEL_12;
  }

  uint64_t v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
  if (!*(void *)((char *)v1 + 1047))
  {
    if (*((_BYTE *)v1 + 225))
    {
      uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(v1[4], v2);
      int v15 = _NRLogIsLevelEnabled(v14, 17LL);

      if (v15)
      {
        uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v16);
        id v9 = [v3 copyDescription];
        _NRLogWithArgs(v8, 17LL, "%@: Tried to linkToNexusLoop but _datagramLinkInputRing is NULL", v9);
        goto LABEL_11;
      }
    }

    goto LABEL_12;
  }

  if ((v4 - 1) >= 2)
  {
    unsigned int v139 = v153;
    uint64_t v17 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
    while (1)
    {
      uint64_t v18 = 0LL;
      uint64_t v19 = 0LL;
      v147[0] = 0LL;
      v147[1] = 0LL;
      while (1)
      {
        uint64_t v20 = v17[388];
        *(void *)&v3[v20] = 4LL;
        uint64_t v21 = v18;
        uint64_t next_slot = os_channel_get_next_slot(*(void *)(v3 + 543), v18, v144);
        if (!next_slot) {
          break;
        }
        uint64_t v18 = next_slot;
        uint64_t v24 = os_channel_get_next_slot(*(void *)&v3[v10[125]], v19, v148);
        if (!v24)
        {
          uint64_t v84 = v21;
          if (v3[223] && *(void *)(v3 + 1063))
          {
            uint64_t v88 = v19;
            v3[223] = 0;
            ++*(void *)(v3 + 1079);
            if (gNRPacketLoggingEnabled)
            {
              uint64_t v115 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v23);
              int v116 = _NRLogIsLevelEnabled(v115, 1LL);

              if (v116)
              {
                int v118 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v117);
                id v119 = [v3 copyDescription];
                _NRLogWithArgs( v118,  1LL,  "%s%.30s:%-4d %@: source-resume: DatagramLinkInput",  "",  "NRLinkResumeDatagramLinkInputSource",  824LL,  v119);
              }
            }

            dispatch_resume(*(dispatch_object_t *)(v3 + 1063));
            uint64_t v19 = v88;
          }

          if (v3[215] || !*(void *)(v3 + 559))
          {
            uint64_t v87 = 64LL;
            goto LABEL_94;
          }

          uint64_t v86 = v19;
          v3[215] = 1;
          ++*(void *)(v3 + 575);
          if (gNRPacketLoggingEnabled)
          {
            uint64_t v125 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v23);
            int v126 = _NRLogIsLevelEnabled(v125, 1LL);

            if (v126)
            {
              uint64_t v128 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v127);
              id v129 = [v3 copyDescription];
              _NRLogWithArgs( v128,  1LL,  "%s%.30s:%-4d %@: source-suspend: NexusVOOutput",  "",  "NRLinkSuspendNexusVOOutputSource",  835LL,  v129);
            }
          }

          dispatch_suspend(*(dispatch_object_t *)(v3 + 559));
          uint64_t v87 = 64LL;
          goto LABEL_93;
        }

        uint64_t v25 = v17;
        uint64_t v26 = v24;
        uint64_t v27 = *(void *)&v3[v10[125]];
        uint64_t v140 = v26;
        uint64_t packet = os_channel_slot_get_packet(v27, v26);
        uint64_t next_buflet = os_packet_get_next_buflet(packet, 0LL);
        uint64_t object_address = os_buflet_get_object_address();
        unsigned int data_offset = os_buflet_get_data_offset(next_buflet);
        uint64_t data_length = os_buflet_get_data_length(next_buflet);
        if (data_length >= 0x10000)
        {
          if (qword_1001DC840 != -1) {
            goto LABEL_123;
          }
          while (1)
          {
            if (_NRLogIsLevelEnabled(qword_1001DC838, 16LL))
            {
              id v130 = sub_100070554();
              _NRLogWithArgs( v130,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: inputBufferLength <= 65535",  "",  "NRLinkDatagramLinkToNexusLoop",  4257);
            }

            uint64_t v131 = _os_log_pack_size(12LL);
            unsigned int v132 = (char *)&v136 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v133 = __error();
            uint64_t v134 = _os_log_pack_fill( v132,  v131,  *v133,  &_mh_execute_header,  "%{public}s Assertion Failed: inputBufferLength <= 65535");
            *(_DWORD *)uint64_t v134 = 136446210;
            *(void *)(v134 + 4) = "NRLinkDatagramLinkToNexusLoop";
            id v135 = sub_100070554();
            _NRLogAbortWithPack(v135, v132);
LABEL_123:
            dispatch_once(&qword_1001DC840, &stru_1001AEE08);
          }
        }

        uint64_t v33 = data_length;
        os_packet_get_flow_uuid(packet, v147);
        if (!v3[223] && *(void *)(v3 + 1063))
        {
          v3[223] = 1;
          ++*(void *)(v3 + 1079);
          if (gNRPacketLoggingEnabled)
          {
            uint64_t v67 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v34);
            LODWORD(v138) = _NRLogIsLevelEnabled(v67, 1LL);

            if ((_DWORD)v138)
            {
              uint64_t v69 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v68);
              id v138 = [v3 copyDescription];
              _NRLogWithArgs( v69,  1LL,  "%s%.30s:%-4d %@: source-suspend: DatagramLinkInput",  "",  "NRLinkSuspendDatagramLinkInputSource",  816LL,  v138);
            }
          }

          dispatch_suspend(*(dispatch_object_t *)(v3 + 1063));
        }

        if (v33 > v145)
        {
          uint64_t v17 = v25;
LABEL_30:
          uint64_t v18 = v21;
          goto LABEL_54;
        }

        unsigned int v35 = (unsigned __int8 *)(object_address + data_offset);
        int v143 = 0;
        unsigned int v141 = v35;
        unsigned int v142 = v33;
        if (v33 < 3)
        {
          if (!gNRPacketLoggingEnabled)
          {
            uint64_t v18 = v21;
            uint64_t v17 = v25;
            goto LABEL_54;
          }

          uint64_t v63 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v34);
          int v64 = _NRLogIsLevelEnabled(v63, 1LL);

          uint64_t v17 = v25;
          if (!v64) {
            goto LABEL_30;
          }
          int v65 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v34);
          id v66 = [v3 copyDescription];
          _NRLogWithArgs( v65,  1LL,  "%s%.30s:%-4d %@: received unexpected packet length: %u",  "",  "NRLinkDatagramLinkToNexusLoop",  4327LL,  v66,  v142);
LABEL_67:

          goto LABEL_30;
        }

        unsigned int v36 = bswap32(*(unsigned __int16 *)(v35 + 1));
        uint64_t v37 = HIWORD(v36);
        uint64_t v38 = v37 + 5;
        if (v37 + 5 != v33)
        {
          if (!gNRPacketLoggingEnabled) {
            goto LABEL_45;
          }
          id v70 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v34);
          int v71 = _NRLogIsLevelEnabled(v70, 1LL);

          uint64_t v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          uint64_t v17 = v25;
          if (!v71) {
            goto LABEL_30;
          }
          int v65 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v34);
          id v66 = [v3 copyDescription];
          _NRLogWithArgs( v65,  1LL,  "%s%.30s:%-4d %@: DatagramLink:Ignoring truncated packet (%zu + %zu + %u + %zu != %u)",  "",  "NRLinkDatagramLinkToNexusLoop",  4282LL,  v66,  1LL,  2LL,  v37,  2LL,  v142);
          goto LABEL_67;
        }

        uint64_t v39 = *v35;
        uint64_t v41 = nrTLVToPacket(&v141, 1LL, v39, HIWORD(v36), v146, v145, v3 + 1967, v3 + 1951);
        if (gNRPacketLoggingEnabled)
        {
          id v138 = (id)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v40);
          LODWORD(v137) = _NRLogIsLevelEnabled(v138, 1LL);

          if ((_DWORD)v137)
          {
            id v138 = (id)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v40);
            id v137 = [v3 copyDescription];
            _NRLogWithArgs( v138,  1LL,  "%s%.30s:%-4d %@: DatagramLink:read %u bytes from datagram link, uncompressedLen = %u",  "",  "NRLinkDatagramLinkToNexusLoop",  4290LL,  v137,  v33,  v41);
          }
        }

        if (!(_DWORD)v41)
        {
          uint64_t v44 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v40);
          int v45 = _NRLogIsLevelEnabled(v44, 17LL);

          if (v45)
          {
            uint64_t v46 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v34);
            id v47 = [v3 copyDescription];
            StringFromNRTLVType = (void *)createStringFromNRTLVType(v39);
            _NRLogWithArgs( v46,  17LL,  "%@: failed to reinject %@ tlvLen=%u slotLen=%u",  v47,  StringFromNRTLVType,  v37,  v145);
          }

void sub_10009DBD0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    id v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 16LL);

    if (IsLevelEnabled)
    {
      id v17 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v11);
      id v8 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v17,  16LL,  "%s%.30s:%-4d %@: Datagram link input available but cancelled",  "",  "-[NRLinkBluetooth updateDatagramPipe:]_block_invoke",  2714LL,  v8);
      goto LABEL_7;
    }
  }

  else
  {
    ++*(void *)(v3 + 1487);
    uint64_t v4 = *(void *)(a1 + 32);
    if (*(unsigned __int8 *)(v4 + 16) - 1 > 1)
    {
      if (gNRPacketLoggingEnabled)
      {
        int v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), a2);
        int v13 = _NRLogIsLevelEnabled(v12, 1LL);

        uint64_t v4 = *(void *)(a1 + 32);
        if (v13)
        {
          int v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v14);
          id v16 = [*(id *)(a1 + 32) copyDescription];
          _NRLogWithArgs( v15,  1LL,  "%s%.30s:%-4d %@: Datagram link input available after prelude",  "",  "-[NRLinkBluetooth updateDatagramPipe:]_block_invoke",  2721LL,  v16);

          uint64_t v4 = *(void *)(a1 + 32);
        }
      }

      sub_10009C984((void *)v4);
    }

    else
    {
      uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), a2);
      int v6 = _NRLogIsLevelEnabled(v5, 17LL);

      if (v6)
      {
        id v17 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v7);
        id v8 = [*(id *)(a1 + 32) copyDescription];
        _NRLogWithArgs(v17, 17LL, "%@: Datagram link input available before prelude", v8);
LABEL_7:
      }
    }
  }

void sub_10009DDB4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16LL);

    if (IsLevelEnabled)
    {
      id v13 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
      id v7 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d %@: Datagram link output available but cancelled",  "",  "-[NRLinkBluetooth updateDatagramPipe:]_block_invoke_3",  2740LL,  v7);
    }
  }

  else
  {
    ++*(void *)(v3 + 1495);
    if (gNRPacketLoggingEnabled)
    {
      id v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), a2);
      int v9 = _NRLogIsLevelEnabled(v8, 1LL);

      if (v9)
      {
        uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v10);
        id v12 = [*(id *)(a1 + 32) copyDescription];
        _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d %@: Datagram link output available",  "",  "-[NRLinkBluetooth updateDatagramPipe:]_block_invoke_3",  2744LL,  v12);
      }
    }

    sub_100083874(*(void **)(a1 + 32), *(void *)(*(void *)(a1 + 32) + 527LL));
  }

void sub_10009DF40(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16LL);

    if (IsLevelEnabled)
    {
      id v19 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v7);
      id v8 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v19,  16LL,  "%s%.30s:%-4d %@: Link input available but cancelled",  "",  "-[NRLinkBluetooth start]_block_invoke",  1276LL,  v8);
    }
  }

  else
  {
    ++*(void *)(v3 + 1471);
    uint64_t v4 = *(void *)(a1 + 32);
    if (*(unsigned __int8 *)(v4 + 16) - 1 > 1)
    {
      if (gNRPacketLoggingEnabled)
      {
        uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), a2);
        int v15 = _NRLogIsLevelEnabled(v14, 1LL);

        uint64_t v4 = *(void *)(a1 + 32);
        if (v15)
        {
          id v17 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v16);
          id v18 = [*(id *)(a1 + 32) copyDescription];
          _NRLogWithArgs( v17,  1LL,  "%s%.30s:%-4d %@: Link input available after prelude",  "",  "-[NRLinkBluetooth start]_block_invoke",  1284LL,  v18);

          uint64_t v4 = *(void *)(a1 + 32);
        }
      }

      sub_1000909CC((void *)v4);
    }

    else
    {
      if (gNRPacketLoggingEnabled)
      {
        int v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), a2);
        int v10 = _NRLogIsLevelEnabled(v9, 1LL);

        uint64_t v4 = *(void *)(a1 + 32);
        if (v10)
        {
          id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v11);
          id v13 = [*(id *)(a1 + 32) copyDescription];
          _NRLogWithArgs( v12,  1LL,  "%s%.30s:%-4d %@: Link input available before prelude",  "",  "-[NRLinkBluetooth start]_block_invoke",  1281LL,  v13);

          uint64_t v4 = *(void *)(a1 + 32);
        }
      }

      sub_10008673C(v4, 0LL);
    }
  }

void sub_10009E168(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    uint64_t v16 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v16, 16LL);

    if (IsLevelEnabled)
    {
      id v25 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v18);
      id v19 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v25,  16LL,  "%s%.30s:%-4d %@: Link output available but cancelled",  "",  "-[NRLinkBluetooth start]_block_invoke_3",  1302LL,  v19);
    }
  }

  else
  {
    ++*(void *)(v3 + 1479);
    if (gNRPacketLoggingEnabled)
    {
      uint64_t v20 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), a2);
      int v21 = _NRLogIsLevelEnabled(v20, 1LL);

      if (v21)
      {
        uint64_t v23 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v22);
        id v24 = [*(id *)(a1 + 32) copyDescription];
        _NRLogWithArgs( v23,  1LL,  "%s%.30s:%-4d %@: Link output available",  "",  "-[NRLinkBluetooth start]_block_invoke_3",  1306LL,  v24);
      }
    }

    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = *(void *)(v4 + 1111);
    int v6 = *(unsigned __int8 *)(v4 + 230);
    if (v5) {
      int v7 = 2;
    }
    else {
      int v7 = 4;
    }
    do
    {
      if ((v6 & 0xFC) != 0) {
        int v8 = 0;
      }
      else {
        int v8 = v6;
      }
      uint64_t v9 = *(void *)(a1 + 32);
      uint64_t v10 = *(void *)(v9 + 1111);
      if (v10) {
        BOOL v11 = 0;
      }
      else {
        BOOL v11 = v8 == 1;
      }
      if (v11) {
        id v12 = &OBJC_IVAR___NRLinkBluetooth__nexusVIChannel;
      }
      else {
        id v12 = &OBJC_IVAR___NRLinkBluetooth__nexusBKChannel;
      }
      if (v10) {
        BOOL v13 = 0;
      }
      else {
        BOOL v13 = v8 == 0;
      }
      if (v13) {
        uint64_t v14 = &OBJC_IVAR___NRLinkBluetooth__nexusVOChannel;
      }
      else {
        uint64_t v14 = &OBJC_IVAR___NRLinkBluetooth__nexusChannel;
      }
      if ((v8 & 1) != 0) {
        uint64_t v14 = v12;
      }
      sub_100070E0C((void *)v9, *(void *)(v9 + *v14));
      int v6 = v8 + 1;
      --v7;
    }

    while (v7);
    ++*(_BYTE *)(*(void *)(a1 + 32) + 230LL);
    uint64_t v15 = *(void *)(a1 + 32);
  }

void sub_10009E3B4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1LL);

  if (IsLevelEnabled)
  {
    int v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v5);
    id v7 = [*(id *)(a1 + 32) copyDescription];
    _NRLogWithArgs( v6,  1LL,  "%s%.30s:%-4d %@: NtL LOOP async start after async",  "",  "-[NRLinkBluetooth start]_block_invoke",  1393LL,  v7);
  }

  sub_100070E0C(*(void **)(a1 + 32), 0LL);
  objc_initWeak(&location, *(id *)(a1 + 32));
  dispatch_time_t v8 = dispatch_time(0x8000000000000000LL, 10000000000LL);
  uint64_t v9 = *(dispatch_queue_s **)(*(void *)(a1 + 32) + 8LL);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10009E4F0;
  block[3] = &unk_1001AFED0;
  objc_copyWeak(&v11, &location);
  dispatch_after(v8, v9, block);
  objc_destroyWeak(&v11);
  objc_destroyWeak(&location);
}

void sub_10009E4F0(uint64_t a1)
{
  WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v10 = WeakRetained;
    BOOL v2 = [WeakRetained state] == 2;
    WeakRetained = v10;
    if (v2)
    {
      uint64_t v9 = *(void *)(v10 + 1863);
      if (v9) {
        *(_BYTE *)(v9 + 101) = 1;
      }
      sub_1000749CC(v10, @"Did not receive prelude after %ds", v3, v4, v5, v6, v7, v8, 10LL);
      WeakRetained = v10;
    }
  }
}

char *sub_10009E564(char *a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  uint64_t v14 = a5;
  uint64_t v15 = a6;
  if (!a1) {
    goto LABEL_51;
  }
  if (!v11)
  {
    id v35 = sub_100070554();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v35, 17LL);

    if (!IsLevelEnabled) {
      goto LABEL_51;
    }
    id v37 = sub_100070554();
    _NRLogWithArgs(v37, 17LL, "%s called with null queue");
LABEL_50:

    char v32 = 0LL;
    goto LABEL_35;
  }

  dispatch_assert_queue_V2(v11);
  if (!v13)
  {
    id v38 = sub_100070554();
    int v39 = _NRLogIsLevelEnabled(v38, 17LL);

    if (!v39) {
      goto LABEL_51;
    }
    id v37 = sub_100070554();
    _NRLogWithArgs(v37, 17LL, "%s called with null nrUUID");
    goto LABEL_50;
  }

  if ((_NRIsUUIDNonZero(v13) & 1) == 0)
  {
    id v40 = sub_100070554();
    int v41 = _NRLogIsLevelEnabled(v40, 17LL);

    if (!v41) {
      goto LABEL_51;
    }
    id v37 = sub_100070554();
    _NRLogWithArgs(v37, 17LL, "called with all-zero nrUUID");
    goto LABEL_50;
  }

  if (!v15)
  {
    id v42 = sub_100070554();
    int v43 = _NRLogIsLevelEnabled(v42, 17LL);

    if (v43)
    {
      id v37 = sub_100070554();
      _NRLogWithArgs(v37, 17LL, "%s called with null remoteDeviceName");
      goto LABEL_50;
    }

void sub_10009EC60(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (!*(void *)(a1 + 1207))
  {
    uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    uint64_t v5 = *(void **)(a1 + 1207);
    *(void *)(a1 + 1207) = v4;

    if (!*(void *)(a1 + 1207))
    {
      id v25 = sub_100070554();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v25, 16LL);

      if (IsLevelEnabled)
      {
        id v27 = sub_100070554();
        _NRLogWithArgs( v27,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (self.latencyContexts) != ((void *)0)",  "",  "-[NRLinkBluetooth measureLatencyWithCompletion:]",  2922);
      }

      uint64_t v28 = _os_log_pack_size(12LL);
      uint64_t v22 = (char *)&block[-1] - ((__chkstk_darwin(v28) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v29 = *__error();
      uint64_t v24 = _os_log_pack_fill( v22,  v28,  v29,  &_mh_execute_header,  "%{public}s Assertion Failed: (self.latencyContexts) != ((void *)0)");
LABEL_13:
      *(_DWORD *)uint64_t v24 = 136446210;
      *(void *)(v24 + 4) = "-[NRLinkBluetooth measureLatencyWithCompletion:]";
      id v30 = sub_100070554();
      _NRLogAbortWithPack(v30, v22);
    }
  }

  uint64_t v6 = objc_alloc_init(&OBJC_CLASS___NRDLatencyContext);
  if (!v6)
  {
    id v18 = sub_100070554();
    int v19 = _NRLogIsLevelEnabled(v18, 16LL);

    if (v19)
    {
      id v20 = sub_100070554();
      _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (latencyContext) != ((void *)0)",  "",  "-[NRLinkBluetooth measureLatencyWithCompletion:]",  2926);
    }

    uint64_t v21 = _os_log_pack_size(12LL);
    uint64_t v22 = (char *)&block[-1] - ((__chkstk_darwin(v21) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v23 = *__error();
    uint64_t v24 = _os_log_pack_fill( v22,  v21,  v23,  &_mh_execute_header,  "%{public}s Assertion Failed: (latencyContext) != ((void *)0)");
    goto LABEL_13;
  }

  uint64_t v8 = v6;
  objc_setProperty_nonatomic_copy(v6, v7, v3, 8LL);
  unint64_t v9 = ++qword_1001DC820;
  v8->_sequenceNumber = qword_1001DC820;
  id v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v10);
  int v12 = _NRLogIsLevelEnabled(v11, 1LL);

  if (v12)
  {
    uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v13);
    id v15 = [(id)a1 copyDescription];
    _NRLogWithArgs( v14,  1LL,  "%s%.30s:%-4d %@: Sending ping seq %llu",  "",  "-[NRLinkBluetooth measureLatencyWithCompletion:]",  2933LL,  v15,  v8->_sequenceNumber);
  }

  char v33 = 1;
  unint64_t v34 = bswap64(v9);
  v8->_startTime = sub_10008C174((void *)a1, &v33, 9u, 1);
  [*(id *)(a1 + 1207) addObject:v8];
  dispatch_time_t v16 = dispatch_time(0x8000000000000000LL, 10000000000LL);
  id v17 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([(id)a1 queue]);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_10009EFE4;
  block[3] = &unk_1001AF588;
  void block[4] = a1;
  void block[5] = v9;
  dispatch_after(v16, v17, block);
}

void sub_10009EFE4(uint64_t a1)
{
}

void sub_10009EFF4(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  id v41 = v5;
  if (!a3)
  {
    if (*(unsigned __int8 *)(a1 + 16) - 1 > 1)
    {
      sub_10008BC7C(a1, v5);
      uint64_t v6 = 311LL;
      goto LABEL_12;
    }

    int v7 = *(_DWORD *)(a1 + 311);
    size_t v9 = v7 + [v5 length];
    if (*(_DWORD *)(a1 + 263) < v9)
    {
      uint64_t v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v8);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 0LL);

      if (IsLevelEnabled)
      {
        uint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v12);
        id v14 = [(id)a1 copyDescription];
        _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d %@: increasing size of _linkReadBuffer %u -> %u",  "",  "-[NRLinkBluetooth processXPCCommMessage:isUrgentLink:]",  6084LL,  v14,  *(unsigned int *)(a1 + 263),  v9);
      }

      id v15 = reallocf(*(void **)(a1 + 1311), v9);
      if (!v15)
      {
        id v30 = sub_100070554();
        int v31 = _NRLogIsLevelEnabled(v30, 16LL);

        if (v31)
        {
          id v32 = sub_100070554();
          _NRLogWithArgs( v32,  16LL,  "%s%.30s:%-4d ABORTING: _strict_reallocf(%zu) failed",  "",  "_strict_reallocf",  139,  v9);
        }

        goto LABEL_26;
      }

      *(void *)(a1 + 1311) = 0LL;
      *(void *)(a1 + 1311) = v15;
      *(_DWORD *)(a1 + 263) = v9;
      *(_DWORD *)(a1 + 271) = (*(_DWORD *)(a1 + 263) + 1) >> 1;
    }

    dispatch_time_t v16 = (void *)(*(void *)(a1 + 1311) + *(unsigned int *)(a1 + 311));
    id v17 = objc_msgSend(v41, "bytes", v41);
    memcpy(v16, v17, (size_t)[v41 length]);
    *(_DWORD *)(a1 + 311) += [v41 length];
    uint64_t v18 = a1;
    uint64_t v19 = 0LL;
LABEL_19:
    sub_10008CA34(v18, v19);
    goto LABEL_20;
  }

  if (!*(_BYTE *)(a1 + 229))
  {
    int v20 = *(_DWORD *)(a1 + 319);
    size_t v9 = v20 + [v5 length];
    if (*(_DWORD *)(a1 + 267) >= v9)
    {
LABEL_18:
      uint64_t v28 = (void *)(*(void *)(a1 + 1319) + *(unsigned int *)(a1 + 319));
      id v29 = objc_msgSend(v41, "bytes", v41);
      memcpy(v28, v29, (size_t)[v41 length]);
      *(_DWORD *)(a1 + 319) += [v41 length];
      uint64_t v18 = a1;
      uint64_t v19 = 1LL;
      goto LABEL_19;
    }

    uint64_t v22 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v21);
    int v23 = _NRLogIsLevelEnabled(v22, 0LL);

    if (v23)
    {
      id v25 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v24);
      id v26 = [(id)a1 copyDescription];
      _NRLogWithArgs( v25,  0LL,  "%s%.30s:%-4d %@: increasing size of _urgentLinkReadBuffer %u -> %u",  "",  "-[NRLinkBluetooth processXPCCommMessage:isUrgentLink:]",  6068LL,  v26,  *(unsigned int *)(a1 + 267),  v9);
    }

    id v27 = reallocf(*(void **)(a1 + 1319), v9);
    if (v27)
    {
      *(void *)(a1 + 1319) = 0LL;
      *(void *)(a1 + 1319) = v27;
      *(_DWORD *)(a1 + 267) = v9;
      *(_DWORD *)(a1 + 275) = (*(_DWORD *)(a1 + 267) + 1) >> 1;
      goto LABEL_18;
    }

    id v33 = sub_100070554();
    int v34 = _NRLogIsLevelEnabled(v33, 16LL);

    if (v34)
    {
      id v35 = sub_100070554();
      _NRLogWithArgs(v35, 16LL, "%s%.30s:%-4d ABORTING: _strict_reallocf(%zu) failed", "", "_strict_reallocf", 139, v9);
    }

uint64_t sub_10009F51C(uint64_t a1)
{
  uint64_t result = (uint64_t)[(id)a1 ikeClassDEstablished];
  if ((_DWORD)result)
  {
    objc_opt_self(&OBJC_CLASS___NRLinkManagerWiFi);
    char v11 = 1;
    id v3 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v11, 1LL);
    id v4 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:51401 notifyData:v3];
    objc_initWeak(&location, (id)a1);
    id v5 = *(void **)(a1 + 1223);
    id v12 = v4;
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v12, 1LL));
    int v7 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 queue]);
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472LL;
    v8[2] = sub_10009F6DC;
    v8[3] = &unk_1001AF950;
    objc_copyWeak(&v9, &location);
    [v5 sendPrivateNotifies:v6 maxRetries:10 retryIntervalInMilliseconds:10000 callbackQueue:v7 callback:v8];

    objc_destroyWeak(&v9);
    objc_destroyWeak(&location);

    return 1LL;
  }

  return result;
}

void sub_10009F6B0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

void sub_10009F6DC(uint64_t a1, int a2)
{
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v13 = WeakRetained;
    uint64_t v5 = _NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    uint64_t v6 = (void *)v5;
    if (a2)
    {
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

      WeakRetained = v13;
      if (IsLevelEnabled)
      {
        id v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v8);
        id v10 = [v13 copyDescription];
        _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: Received response to notify payloads",  "",  "-[NRLinkBluetooth sendAlwaysOnWiFiUpdate]_block_invoke",  7490LL,  v10);
LABEL_7:

        WeakRetained = v13;
      }
    }

    else
    {
      int v11 = _NRLogIsLevelEnabled(v5, 16LL);

      WeakRetained = v13;
      if (v11)
      {
        id v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v12);
        id v10 = [v13 copyDescription];
        _NRLogWithArgs( v9,  16LL,  "%s%.30s:%-4d %@: Did not receive response to notify payloads",  "",  "-[NRLinkBluetooth sendAlwaysOnWiFiUpdate]_block_invoke",  7492LL,  v10);
        goto LABEL_7;
      }
    }
  }
}

void sub_10009F7EC(id a1)
{
}

void sub_10009F7F8(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  BOOL v2 = (void *)qword_1001DC860;
  qword_1001DC860 = (uint64_t)v1;
}

void sub_10009F828(id a1)
{
  id v10 = -[NSString initWithFormat:](objc_alloc(&OBJC_CLASS___NSString), "initWithFormat:", @"-%s", "563.60.14");
  if ((-[__CFString isEqualToString:](v10, "isEqualToString:", @"-") & 1) != 0
    || -[__CFString isEqualToString:](v10, "isEqualToString:", @"-$RC_ProjectSourceVersion"))
  {

    id v10 = &stru_1001B1528;
  }

  os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
  uint64_t v2 = getpid();
  if (qword_1001DC998 != -1) {
    dispatch_once(&qword_1001DC998, &stru_1001AFAD8);
  }
  id v3 = (id)qword_1001DC990;
  if (qword_1001DC9A8 != -1) {
    dispatch_once(&qword_1001DC9A8, &stru_1001AFAF8);
  }
  id v4 = (id)qword_1001DC9A0;
  else {
    uint64_t v5 = "";
  }
  int v6 = _NRShouldDebugAutoRelease();
  int v7 = " (NR_DEBUG_AUTORELEASE)";
  if (!v6) {
    int v7 = "";
  }
  uint64_t v8 = -[NSString initWithFormat:]( v1,  "initWithFormat:",  @"terminusd%@ pid %d built on %s %s, tvOS %@ %@%s%s",  v10,  v2,  "Nov 10 2024",  "01:42:59",  v3,  v4,  v5,  v7);
  id v9 = (void *)qword_1001DC850;
  qword_1001DC850 = (uint64_t)v8;
}

uint64_t sub_10009F9C0(uint64_t a1)
{
  os_log_t v1 = -[NSDictionary initWithContentsOfFile:]( objc_alloc(&OBJC_CLASS___NSDictionary),  "initWithContentsOfFile:",  @"/var/mobile/Library/terminus/com.apple.terminus.plist");
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = (void *)objc_claimAutoreleasedReturnValue( -[NSDictionary objectForKeyedSubscript:]( v1,  "objectForKeyedSubscript:",  @"companionLinkEnabled"));
    uint64_t v4 = objc_opt_class(&OBJC_CLASS___NSNumber);
    if ((objc_opt_isKindOfClass(v3, v4) & 1) != 0) {
      unsigned __int8 v5 = [v3 intValue];
    }
    else {
      unsigned __int8 v5 = 0;
    }
  }

  else
  {
    unsigned __int8 v5 = 0;
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001DC848);
  BOOL v6 = v5 != 2;

  return v6;
}

void sub_10009FA90(uint64_t a1)
{
  uint64_t v2 = -[NSMutableDictionary initWithContentsOfFile:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithContentsOfFile:",  @"/var/mobile/Library/terminus/com.apple.terminus.plist");
  if (!v2) {
    uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  }
  id v17 = v2;
  id v3 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v2,  "objectForKeyedSubscript:",  @"companionLinkEnabled"));
  uint64_t v4 = objc_opt_class(&OBJC_CLASS___NSNumber);
  if ((objc_opt_isKindOfClass(v3, v4) & 1) != 0) {
    unsigned int v5 = [v3 intValue];
  }
  else {
    unsigned int v5 = 0;
  }
  BOOL v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", a1));
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v17,  "setObject:forKeyedSubscript:",  v6,  @"companionLinkEnabled");

  int v7 = sub_1001013AC(@"/var/mobile/Library/terminus/com.apple.terminus.plist", v17, 1);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001DC848);
  uint64_t v8 = sub_100146AFC();
  dispatch_async((dispatch_queue_t)v8, &stru_1001AEA60);

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v9 = (id)qword_1001DC870;
  if (v9)
  {
    id v10 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v10);

    else {
      sub_1000A404C((uint64_t)v9);
    }
  }

  uint64_t v12 = objc_alloc(&OBJC_CLASS___NSString);
  uint64_t v13 = *(&off_1001AEEB8 + a1);
  if (v5 >= 3) {
    id v14 = -[NSString initWithFormat:](objc_alloc(&OBJC_CLASS___NSString), "initWithFormat:", @"Unknown[%lld]", v5);
  }
  else {
    id v14 = (NSString *)*(&off_1001AEEB8 + v5);
  }
  id v15 = " (WRITE FAILED)";
  if (v7) {
    id v15 = "";
  }
  dispatch_time_t v16 = -[NSString initWithFormat:]( v12,  "initWithFormat:",  @"Set companion link to %@ (previously was %@)%s",  v13,  v14,  v15);

  sub_10011BB18(0LL, 9001, &stru_1001B1528, v16);
}

void sub_10009FCD0(void *a1, void *a2, void *a3)
{
  id v15 = a1;
  id v5 = a2;
  id v6 = a3;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1001DC848);
  int v7 = -[NSMutableDictionary initWithContentsOfFile:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithContentsOfFile:",  @"/var/mobile/Library/terminus/com.apple.terminus.plist");
  if (!v7)
  {
    int v7 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    uint64_t v8 = v15;
    if (v15) {
      goto LABEL_3;
    }
LABEL_6:
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v6, v5);
    goto LABEL_9;
  }

  uint64_t v8 = v15;
  if (!v15) {
    goto LABEL_6;
  }
LABEL_3:
  id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 UUIDString]);
  id v10 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v7, "objectForKeyedSubscript:", v9));

  if (v10) {
    uint64_t v11 = (NSMutableDictionary *)[v10 mutableCopy];
  }
  else {
    uint64_t v11 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  }
  uint64_t v12 = v11;
  -[NSMutableDictionary setObject:forKeyedSubscript:](v11, "setObject:forKeyedSubscript:", v6, v5);
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v15 UUIDString]);
  -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v12, v13);

LABEL_9:
  int v14 = sub_1001013AC(@"/var/mobile/Library/terminus/com.apple.terminus.plist", v7, 1);
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001DC848);
  if (v14)
  {
    if (qword_1001DC868 != -1) {
      dispatch_once(&qword_1001DC868, &stru_1001AEE98);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC860, 0LL))
    {
      if (qword_1001DC868 != -1) {
        dispatch_once(&qword_1001DC868, &stru_1001AEE98);
      }
      _NRLogWithArgs( qword_1001DC860,  0LL,  "%s%.30s:%-4d Successfully wrote '%@':%@",  "",  "terminusdSettingsSetValueForKey",  279LL,  v5,  v6);
    }
  }

  else
  {
    if (qword_1001DC868 != -1) {
      dispatch_once(&qword_1001DC868, &stru_1001AEE98);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC860, 17LL))
    {
      if (qword_1001DC868 != -1) {
        dispatch_once(&qword_1001DC868, &stru_1001AEE98);
      }
      _NRLogWithArgs(qword_1001DC860, 17LL, "Failed to write '%@':%@", v5, v6);
    }
  }
}

void sub_10009FF2C(void *a1, void *a2)
{
  id v13 = a1;
  id v3 = a2;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1001DC848);
  uint64_t v4 = -[NSMutableDictionary initWithContentsOfFile:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithContentsOfFile:",  @"/var/mobile/Library/terminus/com.apple.terminus.plist");
  if (v4)
  {
    if (v13)
    {
      id v5 = (void *)objc_claimAutoreleasedReturnValue([v13 UUIDString]);
      id v6 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v4, "objectForKeyedSubscript:", v5));

      if (v6)
      {
        if (v3)
        {
          id v7 = [v6 mutableCopy];
          [v7 removeObjectForKey:v3];
        }

        else
        {
          id v7 = 0LL;
        }

        id v8 = [v7 count];
        id v9 = (void *)objc_claimAutoreleasedReturnValue([v13 UUIDString]);
        if (v8) {
          -[NSMutableDictionary setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", v7, v9);
        }
        else {
          -[NSMutableDictionary removeObjectForKey:](v4, "removeObjectForKey:", v9);
        }
      }
    }

    else
    {
      -[NSMutableDictionary removeObjectForKey:](v4, "removeObjectForKey:", v3);
    }

    int v10 = sub_1001013AC(@"/var/mobile/Library/terminus/com.apple.terminus.plist", v4, 1);
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001DC848);
    if (v10)
    {
      if (qword_1001DC868 != -1) {
        dispatch_once(&qword_1001DC868, &stru_1001AEE98);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC860, 0LL))
      {
        if (qword_1001DC868 != -1) {
          dispatch_once(&qword_1001DC868, &stru_1001AEE98);
        }
        if (v3) {
          id v11 = v3;
        }
        else {
          id v11 = v13;
        }
        _NRLogWithArgs( qword_1001DC860,  0LL,  "%s%.30s:%-4d Successfully removed value for '%@'",  "",  "terminusdSettingsRemoveValueForKey",  318LL,  v11);
      }
    }

    else
    {
      if (qword_1001DC868 != -1) {
        dispatch_once(&qword_1001DC868, &stru_1001AEE98);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC860, 17LL))
      {
        if (qword_1001DC868 != -1) {
          dispatch_once(&qword_1001DC868, &stru_1001AEE98);
        }
        if (v3) {
          id v12 = v3;
        }
        else {
          id v12 = v13;
        }
        _NRLogWithArgs(qword_1001DC860, 17LL, "Failed to write '%@'", v12);
      }
    }
  }

  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001DC848);
  }
}

id sub_1000A019C(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1001DC848);
  id v5 = -[NSMutableDictionary initWithContentsOfFile:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithContentsOfFile:",  @"/var/mobile/Library/terminus/com.apple.terminus.plist");
  id v6 = v5;
  if (v3)
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v3 UUIDString]);
    id v8 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v6, "objectForKeyedSubscript:", v7));

    id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKeyedSubscript:v4]);
  }

  else
  {
    id v9 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", v4));
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001DC848);
  if (v9)
  {
    if (qword_1001DC868 != -1) {
      dispatch_once(&qword_1001DC868, &stru_1001AEE98);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC860, 0LL))
    {
      if (qword_1001DC868 != -1) {
        dispatch_once(&qword_1001DC868, &stru_1001AEE98);
      }
      _NRLogWithArgs( qword_1001DC860,  0LL,  "%s%.30s:%-4d Successfully fetched '%@':%@",  "",  "terminusdSettingsGetValueForKey",  339LL,  v4,  v9);
    }
  }

  else
  {
    if (qword_1001DC868 != -1) {
      dispatch_once(&qword_1001DC868, &stru_1001AEE98);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC860, 0LL))
    {
      if (qword_1001DC868 != -1) {
        dispatch_once(&qword_1001DC868, &stru_1001AEE98);
      }
      _NRLogWithArgs( qword_1001DC860,  0LL,  "%s%.30s:%-4d No value for '%@'",  "",  "terminusdSettingsGetValueForKey",  341LL,  v4);
    }
  }

  return v9;
}

void sub_1000A2084( uint64_t a1, int a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1)
  {
    id v10 = a3;
    id v11 = -[NSString initWithFormat:arguments:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:arguments:",  v10,  &a9);

    sub_10011BB18(0LL, a2, 0LL, v11);
  }

id sub_1000A2100()
{
  if (qword_1001DC8A0 != -1) {
    dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
  }
  return (id)qword_1001DC898;
}

void sub_1000A2140(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC898;
  qword_1001DC898 = (uint64_t)v1;
}

void sub_1000A2170(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v2 = (id)qword_1001DCB58;
    sub_10012114C((uint64_t)v2, @"NRLinkDirector-AppVPN");

    uint64_t v77 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    __int128 v101 = 0u;
    __int128 v102 = 0u;
    __int128 v103 = 0u;
    __int128 v104 = 0u;
    id obj = *(id *)(v1 + 216);
    id v68 = [obj countByEnumeratingWithState:&v101 objects:v113 count:16];
    if (v68)
    {
      uint64_t v67 = *(void *)v102;
      uint64_t v74 = v1;
      do
      {
        uint64_t v3 = 0LL;
        do
        {
          if (*(void *)v102 != v67) {
            objc_enumerationMutation(obj);
          }
          uint64_t v69 = v3;
          int v73 = *(void **)(*((void *)&v101 + 1) + 8 * v3);
          id v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 216), "objectForKeyedSubscript:"));
          id v5 = sub_1000E0378((uint64_t)v4);

          __int128 v99 = 0u;
          __int128 v100 = 0u;
          __int128 v97 = 0u;
          __int128 v98 = 0u;
          id v70 = v5;
          id v76 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v70,  "countByEnumeratingWithState:objects:count:",  &v97,  v112,  16LL);
          if (v76)
          {
            uint64_t v75 = *(void *)v98;
            do
            {
              for (i = 0LL; i != v76; i = (char *)i + 1)
              {
                if (*(void *)v98 != v75) {
                  objc_enumerationMutation(v70);
                }
                uint64_t v7 = *(void *)(*((void *)&v97 + 1) + 8LL * (void)i);
                id v78 = i;
                if (*(void *)(v1 + 312))
                {
                  id v8 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  6LL,  7LL));
                  [v8 setNetworkAgentUUID:v7];
                  -[NSMutableArray addObject:](v77, "addObject:", v8);
                  id v9 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v73);
                  id v10 = v9;
                  if (v9) {
                    id v11 = (void *)*((void *)v9 + 16);
                  }
                  else {
                    id v11 = 0LL;
                  }
                  id v12 = v11;
                  id v13 = (void *)objc_claimAutoreleasedReturnValue([v12 proxyProviderCriteria]);
                  unsigned int v14 = [v13 excludeVPNClients];

                  if (v14)
                  {
                    int v71 = v10;
                    uint64_t v72 = v8;
                    id v15 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult removeNetworkAgentUUID:]( &OBJC_CLASS___NEPolicyResult,  "removeNetworkAgentUUID:",  v7));
                    __int128 v93 = 0u;
                    __int128 v94 = 0u;
                    __int128 v95 = 0u;
                    __int128 v96 = 0u;
                    id v79 = *(id *)(v1 + 312);
                    id v16 = [v79 countByEnumeratingWithState:&v93 objects:v111 count:16];
                    if (v16)
                    {
                      id v17 = v16;
                      uint64_t v18 = *(void *)v94;
                      do
                      {
                        for (j = 0LL; j != v17; j = (char *)j + 1)
                        {
                          if (*(void *)v94 != v18) {
                            objc_enumerationMutation(v79);
                          }
                          uint64_t v20 = *(void *)(*((void *)&v93 + 1) + 8LL * (void)j);
                          id v21 = objc_alloc(&OBJC_CLASS___NEPolicy);
                          uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition allInterfaces]( &OBJC_CLASS___NEPolicyCondition,  "allInterfaces"));
                          v110[0] = v22;
                          int v23 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition effectiveApplication:]( &OBJC_CLASS___NEPolicyCondition,  "effectiveApplication:",  v20));
                          v110[1] = v23;
                          uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v110,  2LL));
                          id v25 = [v21 initWithOrder:5 result:v15 conditions:v24];

                          objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                          if (qword_1001DCB60 != -1) {
                            dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                          }
                          id v26 = (id)qword_1001DCB58;
                          id v27 = sub_100120E44((uint64_t)v26, @"NRLinkDirector-AppVPN", v25);
                        }

                        id v17 = [v79 countByEnumeratingWithState:&v93 objects:v111 count:16];
                      }

                      while (v17);
                    }

                    uint64_t v1 = v74;
                    i = v78;
                    id v10 = v71;
                    id v8 = v72;
                  }
                }

                if (*(void *)(v1 + 296))
                {
                  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forNetworkAgent:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forNetworkAgent:",  6LL));
                  [v28 setNetworkAgentUUID:v7];
                  id v80 = v28;
                  -[NSMutableArray addObject:](v77, "addObject:", v28);
                  __int128 v91 = 0u;
                  __int128 v92 = 0u;
                  __int128 v89 = 0u;
                  __int128 v90 = 0u;
                  id v29 = *(id *)(v1 + 304);
                  id v30 = [v29 countByEnumeratingWithState:&v89 objects:v109 count:16];
                  if (v30)
                  {
                    id v31 = v30;
                    uint64_t v32 = *(void *)v90;
                    do
                    {
                      for (k = 0LL; k != v31; k = (char *)k + 1)
                      {
                        if (*(void *)v90 != v32) {
                          objc_enumerationMutation(v29);
                        }
                        int v34 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition effectiveApplication:]( &OBJC_CLASS___NEPolicyCondition,  "effectiveApplication:",  *(void *)(*((void *)&v89 + 1) + 8LL * (void)k)));
                        id v35 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult removeNetworkAgentUUID:]( &OBJC_CLASS___NEPolicyResult,  "removeNetworkAgentUUID:",  v7));
                        id v36 = objc_alloc(&OBJC_CLASS___NEPolicy);
                        id v37 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition allInterfaces]( &OBJC_CLASS___NEPolicyCondition,  "allInterfaces"));
                        v108[0] = v37;
                        v108[1] = v34;
                        id v38 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v108,  2LL));
                        id v39 = [v36 initWithOrder:5 result:v35 conditions:v38];

                        objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                        if (qword_1001DCB60 != -1) {
                          dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                        }
                        id v40 = (id)qword_1001DCB58;
                        id v41 = sub_100120E44((uint64_t)v40, @"NRLinkDirector-AppVPN", v39);
                      }

                      id v31 = [v29 countByEnumeratingWithState:&v89 objects:v109 count:16];
                    }

                    while (v31);
                  }

                  uint64_t v1 = v74;
                  i = v78;
                }
              }

              id v76 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v70,  "countByEnumeratingWithState:objects:count:",  &v97,  v112,  16LL);
            }

            while (v76);
          }

          uint64_t v3 = v69 + 1;
        }

        while ((id)(v69 + 1) != v68);
        id v68 = [obj countByEnumeratingWithState:&v101 objects:v113 count:16];
      }

      while (v68);
    }

    if (-[NSMutableArray count](v77, "count"))
    {
      __int128 v87 = 0uLL;
      __int128 v88 = 0uLL;
      __int128 v85 = 0uLL;
      __int128 v86 = 0uLL;
      id v42 = *(id *)(v1 + 216);
      id v43 = [v42 countByEnumeratingWithState:&v85 objects:v107 count:16];
      if (v43)
      {
        id v44 = v43;
        uint64_t v45 = *(void *)v86;
        do
        {
          for (m = 0LL; m != v44; m = (char *)m + 1)
          {
            if (*(void *)v86 != v45) {
              objc_enumerationMutation(v42);
            }
            id v47 = (_BYTE *)objc_claimAutoreleasedReturnValue( [*(id *)(v1 + 216) objectForKeyedSubscript:*(void *)(*((void *)&v85 + 1) + 8 * (void)m)]);
            sub_1000F0258(v47, 1);
          }

          id v44 = [v42 countByEnumeratingWithState:&v85 objects:v107 count:16];
        }

        while (v44);
      }

      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC898, 2LL))
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        _NRLogWithArgs( qword_1001DC898,  2LL,  "%s%.30s:%-4d adding VPN route-rule(s) %@",  "",  "-[NRLinkDirector updateVPNPolicies]",  2514LL,  v77);
      }

      id v48 = objc_alloc(&OBJC_CLASS___NEPolicy);
      id v49 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v77));
      uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      int v106 = v50;
      uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v106, 1LL));
      id v52 = [v48 initWithOrder:5 result:v49 conditions:v51];

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v53 = (id)qword_1001DCB58;
      id v54 = sub_100120E44((uint64_t)v53, @"NRLinkDirector-AppVPN", v52);
    }

    else
    {
      __int128 v83 = 0uLL;
      __int128 v84 = 0uLL;
      __int128 v81 = 0uLL;
      __int128 v82 = 0uLL;
      id v52 = *(id *)(v1 + 216);
      id v60 = [v52 countByEnumeratingWithState:&v81 objects:v105 count:16];
      if (v60)
      {
        id v61 = v60;
        uint64_t v62 = *(void *)v82;
        do
        {
          for (n = 0LL; n != v61; n = (char *)n + 1)
          {
            if (*(void *)v82 != v62) {
              objc_enumerationMutation(v52);
            }
            int v64 = (_BYTE *)objc_claimAutoreleasedReturnValue( [*(id *)(v1 + 216) objectForKeyedSubscript:*(void *)(*((void *)&v81 + 1) + 8 * (void)n)]);
            sub_1000F0258(v64, 0);
          }

          id v61 = [v52 countByEnumeratingWithState:&v81 objects:v105 count:16];
        }

        while (v61);
      }
    }

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v55 = (id)qword_1001DCB58;
    objc_super v56 = (id *)v55;
    if (v55)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v55 + 1));
      if (([v56[2] apply] & 1) == 0) {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v57,  v58,  v59,  v65);
      }
    }
  }

NSString *sub_1000A2B20(uint64_t a1)
{
  switch((int)a1)
  {
    case 1001:
      uint64_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      id v2 = "Initial";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 1002:
      uint64_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      id v2 = "Start";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 1003:
      uint64_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      id v2 = "Ready";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 1004:
      uint64_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      id v2 = "Cancelled";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    default:
      if ((_DWORD)a1) {
        return -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown(%u)",  a1);
      }
      uint64_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      id v2 = "Invalid";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
  }

id sub_1000A2C08(uint64_t a1)
{
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  return (id)qword_1001DC870;
}

void sub_1000A2C4C(id a1)
{
  uint64_t v1 = sub_1000A2C78(objc_alloc(&OBJC_CLASS___NRLinkDirector));
  id v2 = (void *)qword_1001DC870;
  qword_1001DC870 = (uint64_t)v1;
}

_BYTE *sub_1000A2C78(_BYTE *a1)
{
  uint64_t v1 = a1;
  if (a1)
  {
    id v2 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v2);

    v34.receiver = v1;
    v34.super_class = (Class)&OBJC_CLASS___NRLinkDirector;
    uint64_t v3 = objc_msgSendSuper2(&v34, "init");
    if (!v3)
    {
      id v24 = sub_1000A2100();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v24, 16LL);

      if (IsLevelEnabled)
      {
        id v26 = sub_1000A2100();
        _NRLogWithArgs( v26,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRLinkDirector initDirector]",  250);
      }

      uint64_t v27 = _os_log_pack_size(12LL);
      uint64_t v28 = (char *)v32 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v29 = __error();
      uint64_t v30 = _os_log_pack_fill(v28, v27, *v29, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v30 = 136446210;
      *(void *)(v30 + 4) = "-[NRLinkDirector initDirector]";
      id v31 = sub_1000A2100();
      _NRLogAbortWithPack(v31, v28);
    }

    id v4 = v3;
    id v5 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    id v6 = (void *)v4[27];
    v4[27] = v5;

    uint64_t v7 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
    id v8 = (void *)v4[28];
    v4[28] = v7;

    id v9 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
    id v10 = (void *)v4[29];
    v4[29] = v9;

    id v11 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
    id v12 = (void *)v4[30];
    v4[30] = v11;

    sub_10011BB18(0LL, 1000, 0LL, 0LL);
    v4[3] = -1LL;
    id v13 = sub_100146AFC();
    unsigned int v14 = (void *)v4[17];
    v4[17] = v13;

    id v15 = (void *)v4[17];
    v32[0] = _NSConcreteStackBlock;
    v32[1] = 3221225472LL;
    v32[2] = sub_1000A2EE0;
    v32[3] = &unk_1001AEEF8;
    id v16 = v4;
    id v33 = v16;
    id v17 = v15;
    v16[16] = ne_session_is_always_on_vpn_enabled(v17, v32, v18, v19);

    uint64_t v20 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v20);

    else {
      sub_1000A404C((uint64_t)v16);
    }
    uint64_t v22 = v33;
    uint64_t v1 = v16;
  }

  return v1;
}

void sub_1000A2EE0(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 32))
  {
    int v4 = a2 ? 1037 : 1038;
    sub_10011BB18(0LL, v4, 0LL, 0LL);
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5)
    {
      if ((*(_BYTE *)(v5 + 16) != 0) != a2)
      {
        *(_BYTE *)(v5 + 16) = a2;
        uint64_t v6 = *(void *)(a1 + 32);
        if (v6)
        {
          uint64_t v7 = sub_100146AFC();
          dispatch_assert_queue_V2((dispatch_queue_t)v7);

          if (qword_1001DC8A0 != -1) {
            dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC898, 0LL))
          {
            if (qword_1001DC8A0 != -1) {
              dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
            }
            _NRLogWithArgs( qword_1001DC898,  0LL,  "%s%.30s:%-4d Restarting link director",  "",  "-[NRLinkDirector restartDirector]",  334);
          }

          sub_1000A404C(v6);
          id v8 = sub_100146AFC();
          dispatch_assert_queue_V2((dispatch_queue_t)v8);

          else {
            sub_1000A404C(v6);
          }
        }
      }
    }
  }

void sub_1000A304C(uint64_t a1)
{
  uint64_t v3 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v3);

  if (*(_BYTE *)(a1 + 12))
  {
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC898, 1LL))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      _NRLogWithArgs( qword_1001DC898,  1LL,  "%s%.30s:%-4d Skipping start as director is already enabled",  "",  "-[NRLinkDirector startDirector]",  285);
    }

    return;
  }

  *(_BYTE *)(a1 + 12) = 1;
  sub_10011BB18(0LL, 1001, 0LL, 0LL);
  *(_BYTE *)(a1 + 10) = 0;
  if (_os_feature_enabled_impl("terminus", "BluetoothPacketParser"))
  {
    *(_BYTE *)(a1 + 10) = 1;
    dword_1001DC234 = 64;
  }

  if (*(_BYTE *)(a1 + 16)) {
    sub_10011BB18(0LL, 1032, 0LL, 0LL);
  }
  int v4 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v4);

  if (_NRIsAppleInternal(v5))
  {
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC898, 0LL))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      _NRLogWithArgs( qword_1001DC898,  0LL,  "%s%.30s:%-4d starting test server",  "",  "-[NRLinkDirector setupManagers]",  443);
    }

    uint64_t v6 = objc_alloc(&OBJC_CLASS___NRDTestServer);
    id v7 = *(id *)(a1 + 136);
    id v8 = sub_10005B360((id *)&v6->super.isa, v7);
    uint64_t v9 = *(void **)(a1 + 200);
    *(void *)(a1 + 200) = v8;

    uint64_t v10 = *(void *)(a1 + 200);
    if (v10) {
      goto LABEL_116;
    }
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC898, 17LL))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      _NRLogWithArgs(qword_1001DC898, 17LL, "[[NRDTestServer alloc] initTestServerWithQueue:] failed");
    }

    uint64_t v10 = *(void *)(a1 + 200);
    if (v10)
    {
LABEL_116:
      if (*(_BYTE *)(v10 + 8))
      {
        if (qword_1001DC788 != -1) {
          dispatch_once(&qword_1001DC788, &stru_1001AE940);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC780, 16LL))
        {
          if (qword_1001DC788 != -1) {
            dispatch_once(&qword_1001DC788, &stru_1001AE940);
          }
          _NRLogWithArgs( qword_1001DC780,  16LL,  "%s%.30s:%-4d Already started. Ignoring",  "",  "-[NRDTestServer start]",  251);
        }
      }

      else
      {
        *(_BYTE *)(v10 + 8) = 1;
        sub_10011BB18(0LL, 9002, 0LL, 0LL);
        if (!*(void *)(v10 + 24))
        {
          id v11 = sub_10005C39C(v10, 0);
          id v12 = *(void **)(v10 + 24);
          *(void *)(v10 + 24) = v11;
        }

        if (!*(void *)(v10 + 32))
        {
          id v13 = sub_10005C39C(v10, 1);
          unsigned int v14 = *(void **)(v10 + 32);
          *(void *)(v10 + 32) = v13;
        }
      }
    }

    id v15 = sub_1000A019C(0LL, @"FixedInterfacePeerIDSDeviceID");
    id v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
    id v17 = sub_1000A019C(0LL, @"FixedInterfaceName");
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
    id v19 = sub_1000A019C(0LL, @"FixedInterfacePeerAddress");
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
    if (v16 && (uint64_t v21 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(v16, v21) & 1) != 0)
      || v18
      && v20
      && (p_class_meths = &APSConnectionOverrideNamedDelegatePort_ptr,
          uint64_t v22 = objc_opt_class(&OBJC_CLASS___NSString),
          (objc_opt_isKindOfClass(v18, v22) & 1) != 0)
      && (uint64_t v23 = objc_opt_class(&OBJC_CLASS___NSString), (objc_opt_isKindOfClass(v20, v23) & 1) != 0))
    {
      *(_BYTE *)(a1 + 8) = 1;
      objc_storeStrong((id *)(a1 + 80), v20);
      objc_storeStrong((id *)(a1 + 72), v18);
      objc_storeStrong((id *)(a1 + 88), v16);
      p_class_meths = (_UNKNOWN **)sub_1001314D4((uint64_t)&OBJC_CLASS___NRDLocalDevice);
      if ([p_class_meths count])
      {
        objc_opt_self(&OBJC_CLASS___NRDKeyManager);
        if (qword_1001DCC18 != -1) {
          dispatch_once(&qword_1001DCC18, &stru_1001B0910);
        }
        id v24 = (id)qword_1001DCC10;
        block.receiver = _NSConcreteStackBlock;
        block.super_class = (Class)3221225472LL;
        __int128 v95 = sub_1000ADA90;
        __int128 v96 = &unk_1001B0A88;
        v97[0] = (id)a1;
        sub_100144478((uint64_t)v24, &block);

        sub_1000ADAF0(a1);
      }

      else
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC898, 16LL))
        {
          if (qword_1001DC8A0 != -1) {
            dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
          }
          _NRLogWithArgs( qword_1001DC898,  16LL,  "%s%.30s:%-4d Fixed interface mode cannot be started as there are no enabled devices",  "",  "-[NRLinkDirector setupManagers]",  469);
        }
      }

      goto LABEL_85;
    }
  }

  if (*(_BYTE *)(a1 + 16))
  {
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC898, 0LL))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      _NRLogWithArgs( qword_1001DC898,  0LL,  "%s%.30s:%-4d Not initializing managers as AOVPN is configured",  "",  "-[NRLinkDirector setupManagers]",  491);
    }

    goto LABEL_85;
  }

  if (qword_1001DC9B8 != -1) {
    dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
  }
  if (!byte_1001DC9B0)
  {
    id v25 = objc_alloc(&OBJC_CLASS___NRLinkManagerBluetooth);
    id v26 = (dispatch_queue_s *)*(id *)(a1 + 136);
    uint64_t v27 = (id)a1;
    if (!v25) {
      goto LABEL_113;
    }
    if (v26)
    {
      dispatch_assert_queue_V2(v26);
      block.receiver = v25;
      block.super_class = (Class)&OBJC_CLASS___NRLinkManagerBluetooth;
      uint64_t v28 = objc_msgSendSuper2(&block, "initManagerWithQueue:managerDelegate:", v26, v27);
      uint64_t v29 = (uint64_t)v28;
      if (v28)
      {
        v28[3] = 1001;
        *((_BYTE *)v28 + 8) = 1;
        uint64_t v30 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
        id v31 = *(void **)(v29 + 40);
        *(void *)(v29 + 40) = v30;

        [(id)v29 reportEvent:2001];
        sub_10002DFF0(v29);
        [(id)v29 reportEvent:2002];
        *(_DWORD *)(v29 + 12) = 1003;
        uint64_t v32 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  3LL);
        id v33 = *(void **)(v29 + 80);
        *(void *)(v29 + 80) = v32;

        objc_super v34 = -[NSMutableDictionary initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithCapacity:",  3LL);
        id v35 = *(void **)(v29 + 88);
        *(void *)(v29 + 88) = v34;

        id v36 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        id v37 = *(void **)(v29 + 104);
        *(void *)(v29 + 104) = v36;

        id v38 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        id v39 = *(void **)(v29 + 112);
        *(void *)(v29 + 112) = v38;

        objc_storeWeak((id *)(v29 + 120), v27);
        id v25 = (NRLinkManagerBluetooth *)(id)v29;
        p_class_meths = (_UNKNOWN **)v25;
      }

      else
      {
        id v89 = sub_100024E28();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v89, 17LL);

        if (IsLevelEnabled)
        {
          id v91 = sub_100024E28();
          _NRLogWithArgs(v91, 17LL, "[NRLinkManager initManagerWithQueue:] failed");
        }

        id v25 = 0LL;
        p_class_meths = 0LL;
      }

      goto LABEL_63;
    }

    id v86 = sub_100024E28();
    int v87 = _NRLogIsLevelEnabled(v86, 17LL);

    if (v87)
    {
      id v88 = sub_100024E28();
      _NRLogWithArgs( v88,  17LL,  "%s called with null queue",  "-[NRLinkManagerBluetooth initManagerWithQueue:managerDelegate:bluetoothManagerDelegate:]");

      p_class_meths = 0LL;
    }

    else
    {
LABEL_113:
      p_class_meths = 0LL;
    }

void sub_1000A4028(_Unwind_Exception *a1)
{
}

void sub_1000A404C(uint64_t a1)
{
  uint64_t v2 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v2);

  if (*(_BYTE *)(a1 + 12))
  {
    *(_BYTE *)(a1 + 12) = 0;
    sub_10011BB18(0LL, 1003, 0LL, 0LL);
    *(_BYTE *)(a1 + 10) = 0;
    [*(id *)(a1 + 40) cancel];
    uint64_t v3 = *(void **)(a1 + 40);
    *(void *)(a1 + 40) = 0LL;

    int v4 = *(void **)(a1 + 56);
    if (v4)
    {
      [v4 cancel];
      uint64_t v5 = *(void **)(a1 + 56);
      *(void *)(a1 + 56) = 0LL;
    }

    uint64_t v6 = *(void **)(a1 + 48);
    if (v6)
    {
      [v6 cancel];
      id v7 = *(void **)(a1 + 48);
      *(void *)(a1 + 48) = 0LL;
    }

    id v8 = *(void **)(a1 + 184);
    if (v8)
    {
      [v8 cancel];
      uint64_t v9 = *(void **)(a1 + 184);
      *(void *)(a1 + 184) = 0LL;
    }

    uint64_t v10 = *(void *)(a1 + 192);
    if (v10)
    {
      if (!*(_BYTE *)(v10 + 9))
      {
        *(_BYTE *)(v10 + 9) = 1;
        id v11 = *(void **)(v10 + 48);
        if (v11)
        {
          [v11 invalidate];
          id v12 = *(void **)(v10 + 48);
          *(void *)(v10 + 48) = 0LL;
        }

        sub_1000127B8(v10);
        uint64_t v10 = *(void *)(a1 + 192);
      }

      *(void *)(a1 + 192) = 0LL;
    }

    id v13 = *(void **)(a1 + 64);
    if (v13)
    {
      [v13 cancel];
      unsigned int v14 = *(void **)(a1 + 64);
      *(void *)(a1 + 64) = 0LL;
    }

    sub_1000A441C(a1);
    sub_1000A45F8(a1);
    uint64_t v15 = *(void *)(a1 + 208);
    if (v15)
    {
      sub_1001482DC(v15);
      id v16 = *(void **)(a1 + 208);
      *(void *)(a1 + 208) = 0LL;
    }

    uint64_t v17 = *(void *)(a1 + 96);
    if (v17)
    {
      sub_100060F1C(v17);
      uint64_t v18 = *(void **)(a1 + 96);
      *(void *)(a1 + 96) = 0LL;
    }

    __int128 v36 = 0u;
    __int128 v37 = 0u;
    __int128 v34 = 0u;
    __int128 v35 = 0u;
    id v19 = *(id *)(a1 + 216);
    id v20 = [v19 countByEnumeratingWithState:&v34 objects:v38 count:16];
    if (v20)
    {
      id v21 = v20;
      uint64_t v22 = *(void *)v35;
      do
      {
        for (i = 0LL; i != v21; i = (char *)i + 1)
        {
          if (*(void *)v35 != v22) {
            objc_enumerationMutation(v19);
          }
          id v24 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(a1 + 216) objectForKeyedSubscript:*(void *)(*((void *)&v34 + 1) + 8 * (void)i)]);
          sub_1000EED00((uint64_t)v24);
        }

        id v21 = [v19 countByEnumeratingWithState:&v34 objects:v38 count:16];
      }

      while (v21);
    }

    [*(id *)(a1 + 216) removeAllObjects];
    sub_1000A46D4(a1);
    sub_1000A4910(a1);
    id v25 = *(dispatch_source_s **)(a1 + 280);
    if (v25)
    {
      dispatch_source_cancel(v25);
      id v26 = *(void **)(a1 + 280);
      *(void *)(a1 + 280) = 0LL;
    }

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v27 = (id)qword_1001DCB58;
    sub_10012114C((uint64_t)v27, @"NRLinkDirector-Drop");

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v28 = (id)qword_1001DCB58;
    uint64_t v29 = (id *)v28;
    if (v28)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v28 + 1));
      if (([v29[2] apply] & 1) == 0) {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v30,  v31,  v32,  v33);
      }
    }
  }

  else
  {
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC898, 1LL))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      _NRLogWithArgs( qword_1001DC898,  1LL,  "%s%.30s:%-4d Skipping cancel as director is already disabled",  "",  "-[NRLinkDirector cancelDirector]",  344);
    }
  }

void sub_1000A441C(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(dispatch_source_s **)(a1 + 168);
    if (v2)
    {
      dispatch_source_cancel(v2);
      uint64_t v3 = *(void **)(a1 + 168);
      *(void *)(a1 + 168) = 0LL;
    }

    if (*(void *)(a1 + 144))
    {
      nw_shoes_server_cancel();
      int v4 = *(void **)(a1 + 144);
      *(void *)(a1 + 144) = 0LL;

      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC898, 0LL))
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        _NRLogWithArgs( qword_1001DC898,  0LL,  "%s%.30s:%-4d socksServer cancelled",  "",  "-[NRLinkDirector cancelSocksServer]",  1928);
      }

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v5 = (id)qword_1001DCB58;
      sub_10012114C((uint64_t)v5, @"NRLinkDirector-skip-privacy-proxy");

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      uint64_t v6 = (dispatch_queue_t *)(id)qword_1001DCB58;
      id v7 = v6;
      if (v6)
      {
        id v13 = (id *)v6;
        dispatch_assert_queue_V2(v6[1]);
        unsigned __int8 v8 = [v13[2] apply];
        id v7 = v13;
        if ((v8 & 1) == 0)
        {
          sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v9,  v10,  v11,  v12);
          id v7 = v13;
        }
      }
    }
  }

void sub_1000A45F8(uint64_t a1)
{
  if (*(void *)(a1 + 152))
  {
    nw_masque_server_cancel();
    uint64_t v2 = *(void **)(a1 + 152);
    *(void *)(a1 + 152) = 0LL;

    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC898, 0LL))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      _NRLogWithArgs( qword_1001DC898,  0LL,  "%s%.30s:%-4d MASQUE server cancelled",  "",  "-[NRLinkDirector cancelMASQUEProxyServer]",  2298);
    }
  }

  uint64_t v3 = *(void **)(a1 + 160);
  *(void *)(a1 + 160) = 0LL;
}

uint64_t sub_1000A46D4(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v2);

  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  id obj = *(id *)(a1 + 216);
  id v22 = [obj countByEnumeratingWithState:&v23 objects:v31 count:16];
  uint64_t v3 = 0LL;
  if (v22)
  {
    uint64_t v21 = *(void *)v24;
    do
    {
      for (i = 0LL; i != v22; i = (char *)i + 1)
      {
        if (*(void *)v24 != v21) {
          objc_enumerationMutation(obj);
        }
        uint64_t v5 = objc_claimAutoreleasedReturnValue( [*(id *)(a1 + 216) objectForKeyedSubscript:*(void *)(*((void *)&v23 + 1) + 8 * (void)i)]);
        uint64_t v6 = (id *)v5;
        if (v5)
        {
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(v5 + 104));
          id v7 = [v6[14] count];
          int v8 = (int)v7;
          sub_1000D4F78((uint64_t)v6, 1013, @"%u available", v9, v10, v11, v12, v13, (uint64_t)v7);
          __int128 v29 = 0u;
          __int128 v30 = 0u;
          __int128 v27 = 0u;
          __int128 v28 = 0u;
          id v14 = v6[14];
          id v15 = [v14 countByEnumeratingWithState:&v27 objects:v32 count:16];
          if (v15)
          {
            id v16 = v15;
            uint64_t v17 = *(void *)v28;
            do
            {
              for (j = 0LL; j != v16; j = (char *)j + 1)
              {
                if (*(void *)v28 != v17) {
                  objc_enumerationMutation(v14);
                }
                [*(id *)(*((void *)&v27 + 1) + 8 * (void)j) cancelWithReason:@"Cancelling all links"];
              }

              id v16 = [v14 countByEnumeratingWithState:&v27 objects:v32 count:16];
            }

            while (v16);
          }

          sub_1000E1E9C((uint64_t)v6, 0LL);
          [v6[14] removeAllObjects];
        }

        else
        {
          int v8 = 0;
        }

        uint64_t v3 = (v8 + v3);
      }

      id v22 = [obj countByEnumeratingWithState:&v23 objects:v31 count:16];
    }

    while (v22);
  }

  return v3;
}

uint64_t sub_1000A4910(uint64_t result)
{
  if (*(_DWORD *)(result + 24) != -1)
  {
    uint64_t v1 = result;
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC898, 0LL))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      _NRLogWithArgs( qword_1001DC898,  0LL,  "%s%.30s:%-4d unregistering thermal pressure level watcher",  "",  "-[NRLinkDirector removeThermalStateWatcher]",  2848);
    }

    uint64_t result = notify_cancel(*(_DWORD *)(v1 + 24));
    *(_DWORD *)(v1 + 24) = -1;
  }

  return result;
}

void sub_1000A49E8(char *a1)
{
  if (!a1) {
    return;
  }
  if (!a1[12])
  {
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC898, 1LL))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      _NRLogWithArgs( qword_1001DC898,  1LL,  "%s%.30s:%-4d Ignoring enabled device check since director is not enabled",  "",  "-[NRLinkDirector checkEnabledDevices]",  783);
    }

    return;
  }

  uint64_t v2 = sub_1001314D4((uint64_t)&OBJC_CLASS___NRDLocalDevice);
  val = a1;
  uint64_t v3 = (void *)*((void *)a1 + 24);
  if (v3)
  {
    v396 = sub_1000128DC(*((void *)a1 + 24));
    if (-[NSMutableArray count](v396, "count"))
    {
      int v4 = sub_100146AFC();
      objc_super block = _NSConcreteStackBlock;
      uint64_t v464 = 3221225472LL;
      id v465 = sub_100014684;
      int v466 = &unk_1001B0A88;
      id v467 = v3;
      dispatch_async((dispatch_queue_t)v4, &block);
    }

    if (-[NSMutableArray count](v396, "count"))
    {
      uint64_t v5 = -[NSMutableArray initWithArray:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithArray:", v2);
      -[NSMutableArray removeObjectsInArray:](v5, "removeObjectsInArray:", v396);

      uint64_t v2 = v5;
    }
  }

  else
  {
    v396 = 0LL;
  }

  _NRUpdateNRUUIDsEligibleForLogObjects(v2);
  *(_OWORD *)id location = 0u;
  __int128 v452 = 0u;
  __int128 v453 = 0u;
  __int128 v454 = 0u;
  id obj = v2;
  id v6 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  location,  &block,  16LL);
  if (v6)
  {
    uint64_t v7 = *(void *)v452;
LABEL_17:
    uint64_t v8 = 0LL;
    while (1)
    {
      if (*(void *)v452 != v7) {
        objc_enumerationMutation(obj);
      }
      uint64_t v9 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *((void **)location[1] + v8));
      uint64_t v10 = (id *)v9;
      if (!v9 || !v9[9] || !v9[8]) {
        goto LABEL_27;
      }
      id v11 = *((id *)v9 + 16);
      if ([v11 proxyCapability] == (id)2)
      {
      }

      else
      {
        id v12 = v10[16];
        BOOL v13 = [v12 proxyCapability] == (id)1;

        if (!v13) {
          goto LABEL_27;
        }
      }

      id v14 = v10[16];
      unsigned int v15 = [v14 usesTLS];

      if (v15)
      {
        id v16 = v10[16];
        id v17 = [v16 proxyCapability];

        if (*((void *)val + 40)) {
          goto LABEL_94;
        }
        v449[0] = kSecAttrKeyType;
        v449[1] = kSecAttrKeySizeInBits;
        v450[0] = kSecAttrKeyTypeECSECPrimeRandom;
        v450[1] = &off_1001BC6A0;
        uint64_t v18 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v450,  v449,  2LL));
        RandomKey = SecKeyCreateRandomKey(v18, 0LL);
        SecKeyRef v20 = SecKeyCopyPublicKey(RandomKey);
        SecKeyRef v21 = v20;
        if (RandomKey)
        {
          if (v20)
          {
            SelfSignedCertificate = (void *)SecGenerateSelfSignedCertificate( &__NSArray0__struct,  &__NSDictionary0__struct,  v20,  RandomKey);
            if (SelfSignedCertificate)
            {
              __int128 v23 = (__SecIdentity *)SecIdentityCreate(0LL, SelfSignedCertificate, RandomKey);
              if (v23)
              {
                from[0] = SelfSignedCertificate;
                sec_identity_t v24 = sec_identity_create_with_certificates( v23,  (CFArrayRef)+[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  from,  1LL));
                CFRelease(v23);
                CFRelease(SelfSignedCertificate);
                goto LABEL_50;
              }

              if (qword_1001DCA58 != -1) {
                dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
              }
              if (_NRLogIsLevelEnabled(qword_1001DCA50, 16LL))
              {
                if (qword_1001DCA58 != -1) {
                  dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
                }
                _NRLogWithArgs( qword_1001DCA50,  16LL,  "%s%.30s:%-4d SecIdentityCreate() failed",  "",  "NRCreateLocalIdentity",  1434);
              }

              CFRelease(SelfSignedCertificate);
            }

            else
            {
              if (qword_1001DCA58 != -1) {
                dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
              }
              if (_NRLogIsLevelEnabled(qword_1001DCA50, 16LL))
              {
                if (qword_1001DCA58 != -1) {
                  dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
                }
                _NRLogWithArgs( qword_1001DCA50,  16LL,  "%s%.30s:%-4d SecGenerateSelfSignedCertificate() failed",  "",  "NRCreateLocalIdentity",  1428);
              }
            }
          }

          else
          {
            id v390 = sub_100100C84();
            int IsLevelEnabled = _NRLogIsLevelEnabled(v390, 17LL);

            if (IsLevelEnabled)
            {
              id v392 = sub_100100C84();
              _NRLogWithArgs(v392, 17LL, "%s called with null publicKey", "NRCreateLocalIdentity");
            }
          }
        }

        else
        {
          id v387 = sub_100100C84();
          int v388 = _NRLogIsLevelEnabled(v387, 17LL);

          if (v388)
          {
            id v389 = sub_100100C84();
            _NRLogWithArgs(v389, 17LL, "%s called with null privateKey", "NRCreateLocalIdentity");
          }
        }

        sec_identity_t v24 = 0LL;
LABEL_50:
        __int128 v25 = (void *)*((void *)val + 40);
        *((void *)val + 40) = v24;

        __int128 v26 = (sec_identity *)*((void *)val + 40);
        if (v26)
        {
          SecIdentityRef v27 = sec_identity_copy_ref(v26);
          if (v27)
          {
            if (v17 != (id)2) {
              goto LABEL_431;
            }
            objc_opt_self(&OBJC_CLASS___NRDKeyManager);
            if (qword_1001DCC18 != -1) {
              dispatch_once(&qword_1001DCC18, &stru_1001B0910);
            }
            __int128 v28 = (dispatch_queue_t *)(id)qword_1001DCC10;
            __int128 v29 = v28;
            if (v28)
            {
              dispatch_assert_queue_V2(v28[2]);
              if (qword_1001DCC28 != -1) {
                dispatch_once(&qword_1001DCC28, &stru_1001B0980);
              }
              if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
              {
                if (qword_1001DCC28 != -1) {
                  dispatch_once(&qword_1001DCC28, &stru_1001B0980);
                }
                _NRLogWithArgs( qword_1001DCC20,  0LL,  "%s%.30s:%-4d Adding local identity %@",  "",  "-[NRDKeyManager saveEphemeralLocalIdentityToKeychain:persistentReference:]",  368LL,  @"local-identity",  v396);
              }

              *(void *)&__int128 v455 = kSecClass;
              *((void *)&v455 + 1) = kSecAttrLabel;
              from[0] = (id)kSecClassIdentity;
              from[1] = @"local-identity";
              unsigned __int128 v456 = __PAIR128__((unint64_t)kSecAttrAccessible, (unint64_t)kSecAttrAccessGroup);
              *(void *)&__int128 v460 = @"com.apple.terminusd.local-identity";
              *((void *)&v460 + 1) = kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate;
              *(void *)&__int128 v457 = kSecValueRef;
              *((void *)&v457 + 1) = kSecReturnPersistentRef;
              *(void *)&__int128 v461 = v27;
              *((void *)&v461 + 1) = &__kCFBooleanTrue;
              __int128 v30 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  from,  &v455,  6LL));
              CFTypeRef result = 0LL;
              OSStatus v31 = SecItemAdd(v30, &result);
              if (v31 == -25299 || !result)
              {
                sub_100144A74((uint64_t)v29);
                CFTypeRef result = 0LL;
                OSStatus v31 = SecItemAdd(v30, &result);
              }

              if (v31)
              {
                if (v31 == -25308)
                {
                  if (qword_1001DCC28 != -1) {
                    dispatch_once(&qword_1001DCC28, &stru_1001B0980);
                  }
                  if (_NRLogIsLevelEnabled(qword_1001DCC20, 16LL))
                  {
                    if (qword_1001DCC28 != -1) {
                      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
                    }
                    _NRLogWithArgs( qword_1001DCC20,  16LL,  "%s%.30s:%-4d Failed to add local identity: keychain locked",  "",  "-[NRDKeyManager saveEphemeralLocalIdentityToKeychain:persistentReference:]",  403);
                  }
                }

                else
                {
                  if (qword_1001DCC28 != -1) {
                    dispatch_once(&qword_1001DCC28, &stru_1001B0980);
                  }
                  if (_NRLogIsLevelEnabled(qword_1001DCC20, 17LL))
                  {
                    if (qword_1001DCC28 != -1) {
                      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
                    }
                    _NRLogWithArgs(qword_1001DCC20, 17LL, "Failed to add local identity: %d", v31);
                  }
                }
              }

              else
              {
                if (qword_1001DCC28 != -1) {
                  dispatch_once(&qword_1001DCC28, &stru_1001B0980);
                }
                if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
                {
                  if (qword_1001DCC28 != -1) {
                    dispatch_once(&qword_1001DCC28, &stru_1001B0980);
                  }
                  _NRLogWithArgs( qword_1001DCC20,  0LL,  "%s%.30s:%-4d Successfully added local identity %@",  "",  "-[NRDKeyManager saveEphemeralLocalIdentityToKeychain:persistentReference:]",  394LL,  result);
                }

                if (result)
                {
                  CFTypeID v358 = CFGetTypeID(result);
                  if (v358 == CFDataGetTypeID())
                  {
                    v359 = (void *)*((void *)val + 15);
                    *((void *)val + 15) = result;
                  }
                }
              }
            }

            if (*((void *)val + 15))
            {
              if (qword_1001DC8A0 != -1) {
                dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
              }
              if (_NRLogIsLevelEnabled(qword_1001DC898, 0LL))
              {
                id v360 = sub_1000A2100();
                uint64_t v394 = "";
                _NRLogWithArgs(v360, 0LL, "%s%.30s:%-4d Successfully added identity to keychain %@");
              }

LABEL_431:
              uint64_t v361 = SecKeyCopySubjectPublicKeyInfo(v21);
              v362 = (void *)*((void *)val + 13);
              *((void *)val + 13) = v361;

              if ([*((id *)val + 13) length])
              {
                notify_post("com.apple.networkrelay.referencesChanged");
                if (qword_1001DC8A0 != -1) {
                  dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
                }
                if (_NRLogIsLevelEnabled(qword_1001DC898, 0LL))
                {
                  if (qword_1001DC8A0 != -1) {
                    dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
                  }
                  id v363 = (void *)qword_1001DC898;
                  id v364 = *((id *)val + 13);
                  id v365 = v363;
                  LogString = (void *)_NRKeyCreateLogString(v364);
                  uint64_t v394 = "";
                  _NRLogWithArgs(v365, 0LL, "%s%.30s:%-4d generated local identity SPKI: %@");
                }

                goto LABEL_87;
              }

              if (qword_1001DC8A0 != -1) {
                dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
              }
              if (_NRLogIsLevelEnabled(qword_1001DC898, 17LL))
              {
                id v366 = sub_1000A2100();
                _NRLogWithArgs(v366, 17LL, "SecKeyCopySubjectPublicKeyInfo failed");
              }
            }

            else
            {
              id v367 = sub_1000A2100();
              int v368 = _NRLogIsLevelEnabled(v367, 16LL);

              if (v368)
              {
                id v369 = sub_1000A2100();
                uint64_t v394 = "";
                _NRLogWithArgs(v369, 16LL, "%s%.30s:%-4d Failed to add identity to keychain %@");
              }
            }

LABEL_378:
    if ((v222 & 1) != 0) {
      goto LABEL_373;
    }
    goto LABEL_379;
  }

  v231 = val;
  if (*((void *)val + 26)) {
    goto LABEL_378;
  }
  id v232 = objc_alloc(&OBJC_CLASS___NRPhoneCallRelayAgent);
  id v233 = *((id *)val + 17);
  int v234 = sub_100148544((id *)&v232->super.isa, v233, val);
  id v235 = (void *)*((void *)val + 26);
  *((void *)val + 26) = v234;

  uint64_t v239 = *((void *)val + 26);
  if (v239)
  {
    if (!*(_BYTE *)(v239 + 14))
    {
      uint64_t v240 = -[NWNetworkAgentRegistration initWithNetworkAgentClass:]( objc_alloc(&OBJC_CLASS___NWNetworkAgentRegistration),  "initWithNetworkAgentClass:",  objc_opt_class(v239));
      unsigned int v241 = *(void **)(v239 + 48);
      *(void *)(v239 + 48) = v240;

      id v245 = *(void **)(v239 + 48);
      if (!v245)
      {
        sub_1001030D0( @"NRPhoneCallRelayAgent",  @"RegisterAgent",  @"Create Failed",  1,  @"Failed to create phone call relay network agent",  v242,  v243,  v244,  (uint64_t)v394);
        id v245 = *(void **)(v239 + 48);
      }

      if (([v245 registerNetworkAgent:v239] & 1) == 0) {
        sub_1001030D0( @"NRPhoneCallRelayAgent",  @"RegisterAgent",  @"Register Failed",  1,  @"Failed to register phone call relay network agent",  v246,  v247,  v248,  (uint64_t)v394);
      }
      int v249 = (void *)objc_claimAutoreleasedReturnValue([(id)v239 agentUUID]);
      id objb = (id)objc_claimAutoreleasedReturnValue(+[NEPolicyResult netAgentUUID:](&OBJC_CLASS___NEPolicyResult, "netAgentUUID:", v249));

      uint64_t v250 = (void *)objc_claimAutoreleasedReturnValue(+[NRPhoneCallRelayAgent agentDomain](&OBJC_CLASS___NRPhoneCallRelayAgent, "agentDomain"));
      id v251 = (void *)objc_claimAutoreleasedReturnValue(+[NRPhoneCallRelayAgent agentType](&OBJC_CLASS___NRPhoneCallRelayAgent, "agentType"));
      unint64_t v404 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition requiredAgentDomain:agentType:]( &OBJC_CLASS___NEPolicyCondition,  "requiredAgentDomain:agentType:",  v250,  v251));

      id v252 = objc_alloc(&OBJC_CLASS___NEPolicy);
      from[0] = v404;
      int v253 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      from[1] = v253;
      int v254 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", from, 2LL));
      id v255 = [v252 initWithOrder:10 result:objb conditions:v254];

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v256 = (id)qword_1001DCB58;
      id v257 = sub_100120E44((uint64_t)v256, *(void **)(v239 + 64), v255);

      int v411 = (void **)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition trafficClassStart:end:]( &OBJC_CLASS___NEPolicyCondition,  "trafficClassStart:end:",  800LL,  900LL));
      int v409 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition ipProtocol:](&OBJC_CLASS___NEPolicyCondition, "ipProtocol:", 17LL));
      id v406 = (id)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition platformBinary](&OBJC_CLASS___NEPolicyCondition, "platformBinary"));
      uint64_t v401 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition accountIdentifier:]( &OBJC_CLASS___NEPolicyCondition,  "accountIdentifier:",  @"com.apple.networkrelay.companion_proxy"));
      id v258 = objc_alloc(&OBJC_CLASS___NEPolicy);
      objc_super block = v411;
      uint64_t v464 = (uint64_t)v409;
      id v465 = v406;
      int v466 = v401;
      int v259 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      id v467 = v259;
      uint64_t v260 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &block, 5LL));
      id v261 = [v258 initWithOrder:10 result:objb conditions:v260];

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v262 = (id)qword_1001DCB58;
      id v263 = sub_100120E44((uint64_t)v262, *(void **)(v239 + 64), v261);

      objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
      uint64_t v264 = sub_100146AFC();
      dispatch_assert_queue_V2((dispatch_queue_t)v264);

      *(_OWORD *)id location = xmmword_100156950;
      v265 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", location, 16LL);
      id v266 = sub_10012D958((uint64_t)&OBJC_CLASS___NRDLocalDevice, v265, @"0");
      int v267 = (void *)objc_claimAutoreleasedReturnValue(v266);

      uint64_t v268 = (void *)objc_claimAutoreleasedReturnValue([v267 hostname]);
      uint64_t v269 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v268,  @"62742"));

      id v270 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition flowRemoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "flowRemoteAddress:prefix:",  v269,  64LL));
      id v271 = objc_alloc(&OBJC_CLASS___NEPolicy);
      location[0] = v411;
      location[1] = v409;
      *(void *)&__int128 v452 = v406;
      *((void *)&v452 + 1) = v270;
      int v272 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      *(void *)&__int128 v453 = v272;
      id v273 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  location,  5LL));
      id v274 = [v271 initWithOrder:10 result:objb conditions:v273];

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v275 = (id)qword_1001DCB58;
      id v276 = sub_100120E44((uint64_t)v275, *(void **)(v239 + 64), v274);

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v277 = (id)qword_1001DCB58;
      unint64_t v278 = (id *)v277;
      if (v277)
      {
        dispatch_assert_queue_V2(*((dispatch_queue_t *)v277 + 1));
        if (([v278[2] apply] & 1) == 0) {
          sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v279,  v280,  v281,  (uint64_t)v394);
        }
      }

      *(_BYTE *)(v239 + 14) = 1;
      uint64_t v282 = (void *)objc_claimAutoreleasedReturnValue([(id)v239 agentUUID]);
      v283 = (void *)objc_claimAutoreleasedReturnValue([v282 UUIDString]);
      sub_10011BB18(0LL, 16002, 0LL, v283);
    }
  }

  else
  {
    sub_1001030D0( @"NRLinkDirector",  @"PhoneCallRelayAgent is Nil",  0LL,  1,  @"[[NRPhoneCallRelayAgent alloc] initWithQueue: delegate:]",  v236,  v237,  v238,  (uint64_t)v394);
  }

LABEL_372:
  v231 = val;
  if ((v222 & 1) == 0)
  {
LABEL_379:
    uint64_t v342 = *((void *)v231 + 12);
    if (v342)
    {
      sub_100060F1C(v342);
      v336 = (id *)*((void *)val + 12);
      *((void *)val + 12) = 0LL;
      goto LABEL_381;
    }

                      id v355 = (char *)v355 + 1;
                    }

                    while (v352 != v355);
                    id v353 = v447 + (_DWORD)v352;
                    uint64_t v352 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v453,  "countByEnumeratingWithState:objects:count:",  &v470,  v492,  16LL);
                    if (!v352) {
                      goto LABEL_382;
                    }
                  }
                }

                __int128 v458 = 0;
LABEL_382:

                id v367 = self->_nrUUID;
                id v369 = (void *)_NRCopyLogObjectForNRUUID(v367, v368);
                int v370 = _NRLogIsLevelEnabled(v369, 0LL);

                if (v370)
                {
                  nw_parameters_t v371 = self->_nrUUID;
                  id v373 = (void *)_NRCopyLogObjectForNRUUID(v371, v372);
                  uint64_t v374 = v459->_primaryLink;
                  id v375 = (void *)createStringFromNRLinkType(-[NRLink type](v374, "type"));
                  id v376 = v459->_primaryLink;
                  char v377 = (void *)createStringFromNRLinkSubtype(-[NRLink subtype](v376, "subtype"));
                  id v378 = (void *)createStringFromNRLinkType(v463);
                  id v379 = (void *)createStringFromNRLinkSubtype(v458);
                  _NRLogWithArgs( v373,  0LL,  "%s%.30s:%-4d Our primary link: %@(%@), peer primary link: %@(%@)",  "",  "-[NRDDeviceConductor linkDidReceiveData:data:]",  6356LL,  v375,  v377,  v378,  v379);

                  self = v459;
                }

                uint64_t v7 = v437;
                if (!self->_followsPeerPrimaryLink) {
                  goto LABEL_416;
                }
                id v380 = v463;
                if (!v463)
                {
                  uint64_t v381 = self->_nrUUID;
                  uint64_t v383 = (void *)_NRCopyLogObjectForNRUUID(v381, v382);
                  uint64_t v384 = _NRLogIsLevelEnabled(v383, 17LL);

                  if (v384)
                  {
                    uint64_t v385 = self->_nrUUID;
                    id v387 = (void *)_NRCopyLogObjectForNRUUID(v385, v386);
                    _NRLogWithArgs(v387, 17LL, "Received recommended Link type is invalid");
                  }

                  id v380 = 1;
                }

                int v388 = self->_nrUUID;
                id v390 = (void *)_NRCopyLogObjectForNRUUID(v388, v389);
                uint64_t v391 = _NRLogIsLevelEnabled(v390, 1LL);

                if (v391)
                {
                  id v392 = self->_nrUUID;
                  uint64_t v394 = (void *)_NRCopyLogObjectForNRUUID(v392, v393);
                  uint64_t v395 = (void *)createStringFromNRLinkType(v380);
                  _NRLogWithArgs( v394,  1LL,  "%s%.30s:%-4d Received a primary link recommendation from the peer: %@",  "",  "-[NRDDeviceConductor linkDidReceiveData:data:]",  6446LL,  v395);
                }

                if (v380 != 2)
                {
                  if (v380 == 1)
                  {
                    dispatch_assert_queue_V2((dispatch_queue_t)self->_queue);
                    dispatch_assert_queue_V2((dispatch_queue_t)self->_queue);
                    v396 = sub_1000D8B90((uint64_t)self, 1, 0);
                    id v398 = v396;
                    if (v396)
                    {
                      if ([v396 state] == 1)
                      {
                        uint64_t v400 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v399);
                        uint64_t v401 = _NRLogIsLevelEnabled(v400, 1LL);

                        if (v401)
                        {
                          uint64_t v403 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v402);
                          _NRLogWithArgs( v403,  1LL,  "%s%.30s:%-4d Starting link: %@",  "",  "-[NRDDeviceConductor resumeLinkOfType:]",  3271LL,  v398);
                        }

                        [v398 start];
                        goto LABEL_415;
                      }

                      if ([v398 state] != 8)
                      {
                        if ([v398 state] == 9)
                        {
                          uint64_t v413 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v412);
                          v414 = _NRLogIsLevelEnabled(v413, 1LL);

                          if (v414)
                          {
                            uint64_t v416 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v415);
                            _NRLogWithArgs( v416,  1LL,  "%s%.30s:%-4d Resuming link: %@",  "",  "-[NRDDeviceConductor resumeLinkOfType:]",  3288LL,  v398);
                          }

                          [v398 resume];
                          goto LABEL_415;
                        }

                        [v398 setSuspendWhenReady:0];
                        __int128 v418 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v417);
                        __int128 v419 = _NRLogIsLevelEnabled(v418, 1LL);

                        if (v419)
                        {
                          id v410 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v420);
                          _NRLogWithArgs( v410,  1LL,  "%s%.30s:%-4d Cannot resume link as it is not suspended: %@",  "",  "-[NRDDeviceConductor resumeLinkOfType:]",  3284LL,  v398);
                          goto LABEL_407;
                        }
                      }
                    }

                    else
                    {
                      id v407 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v397);
                      uint64_t v408 = _NRLogIsLevelEnabled(v407, 1LL);

                      if (v408)
                      {
                        id v410 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v409);
                        int v411 = (void *)createStringFromNRLinkType(1LL);
                        _NRLogWithArgs( v410,  1LL,  "%s%.30s:%-4d Cannot resume link as no link of type '%@' is available",  "",  "-[NRDDeviceConductor resumeLinkOfType:]",  3266LL,  v411);

LABEL_407:
                      }
                    }

LABEL_382:
    int v344 = *((_DWORD *)v231 + 6);
    int v343 = (int *)(v231 + 24);
    if (v344 == -1)
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC898, 0LL))
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        _NRLogWithArgs( qword_1001DC898,  0LL,  "%s%.30s:%-4d registering thermal pressure level watcher",  "",  "-[NRLinkDirector setupThermalStateWatcher]",  2784);
      }

      objc_initWeak(from, val);
      int v345 = (dispatch_queue_s *)*((id *)val + 17);
      location[0] = _NSConcreteStackBlock;
      location[1] = (id)3221225472LL;
      *(void *)&__int128 v452 = sub_1000ABE70;
      *((void *)&v452 + 1) = &unk_1001B0938;
      objc_copyWeak((id *)&v453, from);
      uint32_t v346 = notify_register_dispatch(kOSThermalNotificationPressureLevelName, v343, v345, location);

      if (v346 || *v343 == -1)
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        id v347 = (id)qword_1001DC898;
        char v348 = _NRLogIsLevelEnabled(v347, 17LL);

        if ((v348 & 1) != 0)
        {
          if (qword_1001DC8A0 != -1) {
            dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
          }
          id v349 = (id)qword_1001DC898;
          _NRLogWithArgs(v349, 17LL, "notify_register_dispatch (status: %u, token: %d) failed", v346, *v343);
        }
      }

      else
      {
        int v350 = (dispatch_queue_s *)*((void *)val + 17);
        objc_super block = _NSConcreteStackBlock;
        uint64_t v464 = 3221225472LL;
        id v465 = sub_1000ABEF0;
        int v466 = &unk_1001B0A88;
        id v467 = val;
        dispatch_async(v350, &block);
      }

      objc_destroyWeak((id *)&v453);
      objc_destroyWeak(from);
    }

    sub_1000A96FC();
    if (sub_1000A9F64())
    {
      int v351 = sub_1000A9F64();
      uint64_t v352 = (uint64_t)val;
      if (v351 && *((_DWORD *)val + 7) == -1)
      {
        LODWORD(from[0]) = -1;
        objc_initWeak(location, val);
        id v353 = (dispatch_queue_s *)*((id *)val + 17);
        objc_super block = _NSConcreteStackBlock;
        uint64_t v464 = 3221225472LL;
        id v465 = sub_1000AB838;
        int v466 = &unk_1001B0938;
        objc_copyWeak(&v467, location);
        uint32_t v354 = notify_register_dispatch("com.apple.neconfigurationchanged", (int *)from, v353, &block);

        if (v354)
        {
          if (qword_1001DC8A0 != -1) {
            dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
          }
          id v355 = (id)qword_1001DC898;
          int v356 = _NRLogIsLevelEnabled(v355, 17LL);

          if (v356)
          {
            if (qword_1001DC8A0 != -1) {
              dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
            }
            id v357 = (id)qword_1001DC898;
            _NRLogWithArgs( v357,  17LL,  "notify_register_dispatch(%s, %d) failed: %u",  "com.apple.neconfigurationchanged",  LODWORD(from[0]),  v354);
          }
        }

        else
        {
          int v370 = (int)from[0];
          *((_DWORD *)val + 7) = from[0];
          sub_1000AB88C(val, v370);
        }

        objc_destroyWeak(&v467);
        objc_destroyWeak(location);
        uint64_t v352 = (uint64_t)val;
      }

      if (*(void *)(v352 + 288))
      {
        sub_1000A2170(v352);
      }

      else
      {
        nw_parameters_t v371 = nw_parameters_create();
        nw_parameters_set_account_id(v371, "com.apple.networkextension.app-vpn-agent");
        evaluator_for_endpoint = (void *)nw_path_create_evaluator_for_endpoint(0LL, v371);
        nw_path_evaluator_set_queue(evaluator_for_endpoint, *((void *)val + 17));
        objc_initWeak(from, val);
        location[0] = _NSConcreteStackBlock;
        location[1] = (id)3221225472LL;
        *(void *)&__int128 v452 = sub_1000AB3A0;
        *((void *)&v452 + 1) = &unk_1001AF0C8;
        objc_copyWeak((id *)&v453 + 1, from);
        id v373 = evaluator_for_endpoint;
        *(void *)&__int128 v453 = v373;
        uint64_t v374 = objc_retainBlock(location);
        id v375 = *((id *)val + 17);
        nw_path_evaluator_set_update_handler(v373, v375, v374);

        nw_path_evaluator_start(v373);
        objc_storeStrong((id *)val + 36, evaluator_for_endpoint);
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        id v376 = (id)qword_1001DC898;
        char v377 = _NRLogIsLevelEnabled(v376, 0LL);

        if ((v377 & 1) != 0)
        {
          if (qword_1001DC8A0 != -1) {
            dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
          }
          id v378 = (id)qword_1001DC898;
          id v379 = *((id *)val + 36);
          _NRLogWithArgs( v378,  0LL,  "%s%.30s:%-4d registering path evaluator for appVPN %@",  "",  "-[NRLinkDirector setupAppVPNWatcher]",  2431LL,  v379);
        }

        id v380 = (dispatch_queue_s *)*((void *)val + 17);
        objc_super block = _NSConcreteStackBlock;
        uint64_t v464 = 3221225472LL;
        id v465 = sub_1000AB6D8;
        int v466 = &unk_1001AF0F0;
        id v467 = val;
        id v468 = v373;
        int v469 = v374;
        uint64_t v381 = v374;
        id v382 = v373;
        dispatch_async(v380, &block);

        objc_destroyWeak((id *)&v453 + 1);
        objc_destroyWeak(from);
      }
    }

    if (!*((void *)val + 35))
    {
      uint64_t v383 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  *((dispatch_queue_t *)val + 17));
      dispatch_source_set_timer(v383, 0LL, 0x29E8D60800uLL, 0x2FAF080uLL);
      objc_initWeak(location, val);
      objc_super block = _NSConcreteStackBlock;
      uint64_t v464 = 3221225472LL;
      id v465 = sub_1000AA978;
      int v466 = &unk_1001B0798;
      objc_copyWeak(&v468, location);
      uint64_t v384 = v383;
      id v467 = v384;
      dispatch_source_set_event_handler(v384, &block);
      dispatch_resume(v384);
      uint64_t v385 = (void *)*((void *)val + 35);
      *((void *)val + 35) = v384;
      uint64_t v386 = v384;

      objc_destroyWeak(&v468);
      objc_destroyWeak(location);
    }

    goto LABEL_457;
  }

LABEL_373:
  if (*((void *)v231 + 12)) {
    goto LABEL_382;
  }
  unsigned __int16 v333 = objc_alloc_init(&OBJC_CLASS___NRPreferWiFiAgent);
  unsigned __int16 v334 = (void *)*((void *)val + 12);
  *((void *)val + 12) = v333;

  uint64_t v335 = (void *)*((void *)val + 17);
  v336 = (id *)*((id *)val + 12);
  id v337 = v335;
  unsigned __int16 v338 = v337;
  if (v336)
  {
    if (!*((_BYTE *)v336 + 14))
    {
      objc_storeStrong(v336 + 5, v335);
      objc_initWeak(location, v336);
      dispatch_time_t v339 = dispatch_time(0x8000000000000000LL, 1000000000LL);
      id v340 = v336[5];
      objc_super block = _NSConcreteStackBlock;
      uint64_t v464 = 3221225472LL;
      id v465 = sub_1000607C0;
      int v466 = &unk_1001AFED0;
      v341 = (dispatch_queue_s *)v340;
      objc_copyWeak(&v467, location);
      dispatch_after(v339, v341, &block);

      objc_destroyWeak(&v467);
      objc_destroyWeak(location);
    }

LABEL_381:
    v231 = val;
    goto LABEL_382;
  }

  if (qword_1001DC8A0 != -1) {
    dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC898, 17LL))
  {
    id v393 = sub_1000A2100();
    _NRLogWithArgs(v393, 17LL, "Failed to register prefer Wi-Fi agent");
  }

LABEL_457:
}

void sub_1000A823C(_Unwind_Exception *a1)
{
}

void sub_1000A8298(NSUUID *a1)
{
  id v66 = a1;
  if (a1)
  {
    __int128 v73 = 0u;
    __int128 v74 = 0u;
    __int128 v75 = 0u;
    __int128 v76 = 0u;
    uint64_t v67 = sub_1001314D4((uint64_t)&OBJC_CLASS___NRDLocalDevice);
    id v3 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v67,  "countByEnumeratingWithState:objects:count:",  &v73,  v78,  16LL);
    if (v3)
    {
      char v4 = 0;
      uint64_t v5 = *(void *)v74;
      while (2)
      {
        for (i = 0LL; i != v3; i = (char *)i + 1)
        {
          if (*(void *)v74 != v5) {
            objc_enumerationMutation(v67);
          }
          uint64_t v7 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(*((void *)&v73 + 1) + 8LL * (void)i));
          p_class_meths = (id *)v7;
          if (!v7)
          {
            p_class_meths = (id *)&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
            if (qword_1001DC8A0 != -1) {
              dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
            }
            id v36 = (id)qword_1001DC898;
            int IsLevelEnabled = _NRLogIsLevelEnabled(v36, 16LL);

            if (IsLevelEnabled)
            {
              if (qword_1001DC8A0 != -1) {
                dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
              }
              id v38 = (id)qword_1001DC898;
              _NRLogWithArgs( v38,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRLinkDirector startSocksServerIfNeeded]",  1803);
            }

            uint64_t v39 = _os_log_pack_size(12LL);
            __int128 v28 = (__objc2_class *)((char *)&v64 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL));
            uint64_t v40 = __error();
            uint64_t v41 = _os_log_pack_fill( v28,  v39,  *v40,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
            *(_DWORD *)uint64_t v41 = 136446210;
            *(void *)(v41 + 4) = "-[NRLinkDirector startSocksServerIfNeeded]";
            id v42 = sub_1000A2100();
            _NRLogAbortWithPack(v42, v28);
            goto LABEL_49;
          }

          id v9 = *((id *)v7 + 16);
          unint64_t v1 = v9 == 0LL;

          if ((v1 & 1) == 0)
          {
            unint64_t v1 = (unint64_t)p_class_meths[16];
            if ([(id)v1 proxyCapability] == (id)1)
            {
              id v10 = p_class_meths[16];
              uint64_t v2 = (__objc2_meth_list **)[v10 hasCompanionDatapath];
            }

            else
            {
              uint64_t v2 = 0LL;
            }

            v4 |= v2;
          }
        }

        id v3 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v67,  "countByEnumeratingWithState:objects:count:",  &v73,  v78,  16LL);
        if (v3) {
          continue;
        }
        break;
      }

      if ((v4 & 1) != 0)
      {
        if (v66[18].super.isa) {
          goto LABEL_31;
        }
        nw_endpoint_t host = nw_endpoint_create_host("::", "62742");
        if (host)
        {
          nw_parameters_t v11 = nw_parameters_create();
          p_class_meths = (id *)v11;
          if (v11)
          {
            nw_parameters_set_local_address(v11, host);
            nw_parameters_set_required_interface_subtype(p_class_meths, 5001LL);
            nw_parameters_set_always_open_listener_socket(p_class_meths, 1LL);
            unint64_t v1 = v66[17].super.isa;
            uint64_t v12 = nw_shoes_server_create(p_class_meths, v1);
            Class isa = v66[18].super.isa;
            BOOL v13 = v66 + 18;
            v66[18].super.Class isa = (Class)v12;

            Class v15 = v13->super.isa;
            if (v13->super.isa)
            {
              v72[0] = _NSConcreteStackBlock;
              v72[1] = 3221225472LL;
              v72[2] = sub_1000AD598;
              v72[3] = &unk_1001B04F8;
              void v72[4] = v66;
              nw_socks5_server_set_state_changed_handler(v15, v72);
              nw_socks5_server_start(v66[18].super.isa);
              if (!v66[21].super.isa)
              {
                id v16 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  (dispatch_queue_t)v66[17].super.isa);
                dispatch_time_t v17 = dispatch_time(0x8000000000000000LL, 21600000000000LL);
                dispatch_source_set_timer(v16, v17, 0x13A52453C000uLL, 0xEE6B280uLL);
                objc_initWeak(&v71, v66);
                v68[0] = _NSConcreteStackBlock;
                v68[1] = 3221225472LL;
                v68[2] = sub_1000AD824;
                v68[3] = &unk_1001B0798;
                objc_copyWeak(&v70, &v71);
                uint64_t v18 = v16;
                uint64_t v69 = v18;
                dispatch_source_set_event_handler(v18, v68);
                dispatch_activate(v18);
                Class v19 = v66[21].super.isa;
                v66[21].super.Class isa = (Class)v18;
                SecKeyRef v20 = v18;

                objc_destroyWeak(&v70);
                objc_destroyWeak(&v71);
              }

              id v66 = -[NSUUID initWithUUIDBytes:]( objc_alloc(&OBJC_CLASS___NSUUID),  "initWithUUIDBytes:",  &ne_privacy_proxy_netagent_id);
              id v21 = objc_alloc(&OBJC_CLASS___NEPolicy);
              id v22 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult removeNetworkAgentUUID:]( &OBJC_CLASS___NEPolicyResult,  "removeNetworkAgentUUID:",  v66));
              __int128 v23 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
              v77[0] = v23;
              sec_identity_t v24 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition accountIdentifier:]( &OBJC_CLASS___NEPolicyCondition,  "accountIdentifier:",  @"com.apple.networkrelay.companion_proxy"));
              v77[1] = v24;
              id v25 = +[NEPolicyCondition effectivePID:](&OBJC_CLASS___NEPolicyCondition, "effectivePID:", getpid());
              __int128 v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
              v77[2] = v26;
              SecIdentityRef v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v77,  3LL));
              unint64_t v1 = (unint64_t)[v21 initWithOrder:10 result:v22 conditions:v27];

              __int128 v28 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
              objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
              uint64_t v2 = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
              if (qword_1001DCB60 == -1) {
                goto LABEL_23;
              }
              goto LABEL_50;
            }

            id v57 = sub_1000A2100();
            int v58 = _NRLogIsLevelEnabled(v57, 16LL);

            if (v58)
            {
              id v59 = sub_1000A2100();
              _NRLogWithArgs( v59,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (self.socksServer) != ((void *)0)",  "",  "-[NRLinkDirector startSocksServerIfNeeded]",  1838);
            }

            uint64_t v60 = _os_log_pack_size(12LL);
            __int128 v28 = (__objc2_class *)((char *)&v64 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL));
            id v61 = __error();
            uint64_t v62 = _os_log_pack_fill( v28,  v60,  *v61,  &_mh_execute_header,  "%{public}s Assertion Failed: (self.socksServer) != ((void *)0)");
            *(_DWORD *)uint64_t v62 = 136446210;
            *(void *)(v62 + 4) = "-[NRLinkDirector startSocksServerIfNeeded]";
            id v63 = sub_1000A2100();
            _NRLogAbortWithPack(v63, v28);
          }

          else
          {
            id v50 = sub_1000A2100();
            int v51 = _NRLogIsLevelEnabled(v50, 16LL);

            if (v51)
            {
              id v52 = sub_1000A2100();
              _NRLogWithArgs( v52,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (socksParameters) != ((void *)0)",  "",  "-[NRLinkDirector startSocksServerIfNeeded]",  1827);
            }

            uint64_t v53 = _os_log_pack_size(12LL);
            __int128 v28 = (__objc2_class *)((char *)&v64 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL));
            id v54 = __error();
            uint64_t v55 = _os_log_pack_fill( v28,  v53,  *v54,  &_mh_execute_header,  "%{public}s Assertion Failed: (socksParameters) != ((void *)0)");
            *(_DWORD *)uint64_t v55 = 136446210;
            *(void *)(v55 + 4) = "-[NRLinkDirector startSocksServerIfNeeded]";
            id v56 = sub_1000A2100();
            _NRLogAbortWithPack(v56, v28);
          }
        }

        else
        {
          id v43 = sub_1000A2100();
          int v44 = _NRLogIsLevelEnabled(v43, 16LL);

          if (v44)
          {
            id v45 = sub_1000A2100();
            _NRLogWithArgs( v45,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (socksEndpoint) != ((void *)0)",  "",  "-[NRLinkDirector startSocksServerIfNeeded]",  1825);
          }

          uint64_t v46 = _os_log_pack_size(12LL);
          __int128 v28 = (__objc2_class *)((char *)&v64 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL));
          id v47 = __error();
          uint64_t v48 = _os_log_pack_fill( v28,  v46,  *v47,  &_mh_execute_header,  "%{public}s Assertion Failed: (socksEndpoint) != ((void *)0)");
          *(_DWORD *)uint64_t v48 = 136446210;
          *(void *)(v48 + 4) = "-[NRLinkDirector startSocksServerIfNeeded]";
          id v49 = sub_1000A2100();
          _NRLogAbortWithPack(v49, v28);
        }

void sub_1000A8B9C(char *a1)
{
  if (a1)
  {
    if ((_os_feature_enabled_impl("terminus", "MASQUEProxyServer") & 1) != 0)
    {
      id v63 = a1;
      __int128 v76 = 0u;
      __int128 v77 = 0u;
      __int128 v78 = 0u;
      __int128 v79 = 0u;
      uint64_t v64 = sub_1001314D4((uint64_t)&OBJC_CLASS___NRDLocalDevice);
      char v3 = 0;
      id v4 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v64,  "countByEnumeratingWithState:objects:count:",  &v76,  v80,  16LL);
      if (v4)
      {
        uint64_t v5 = *(void *)v77;
        do
        {
          for (i = 0LL; i != v4; i = (char *)i + 1)
          {
            if (*(void *)v77 != v5) {
              objc_enumerationMutation(v64);
            }
            uint64_t v7 = sub_100129B30( (uint64_t)&OBJC_CLASS___NRDLocalDevice,  *(void **)(*((void *)&v76 + 1) + 8LL * (void)i));
            p_class_meths = (id *)v7;
            if (!v7)
            {
              if (qword_1001DC8A0 != -1) {
                dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
              }
              p_class_meths = (id *)&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
              id v14 = (id)qword_1001DC898;
              int IsLevelEnabled = _NRLogIsLevelEnabled(v14, 16LL);

              if (!IsLevelEnabled) {
                goto LABEL_46;
              }
              if (qword_1001DC8A0 != -1) {
                goto LABEL_71;
              }
              goto LABEL_45;
            }

            id v8 = *((id *)v7 + 16);
            BOOL v9 = v8 == 0LL;

            if (!v9)
            {
              id v10 = p_class_meths[16];
              if ([v10 proxyCapability] == (id)1)
              {
                id v11 = p_class_meths[16];
                unsigned __int8 v12 = [v11 usesTLS];
              }

              else
              {
                unsigned __int8 v12 = 0;
              }

              v3 |= v12;
            }
          }

          id v4 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v64,  "countByEnumeratingWithState:objects:count:",  &v76,  v80,  16LL);
        }

        while (v4);
      }

      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC898, 2LL))
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        BOOL v13 = @"NO";
        if ((v3 & 1) != 0) {
          BOOL v13 = @"YES";
        }
        _NRLogWithArgs( qword_1001DC898,  2LL,  "%s%.30s:%-4d start MASQUE server : %@",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]",  2076LL,  v13);
      }

      if ((v3 & 1) != 0)
      {
        if (*((void *)v63 + 19))
        {
          if (qword_1001DC8A0 != -1) {
            dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC898, 2LL))
          {
            if (qword_1001DC8A0 != -1) {
              dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
            }
            _NRLogWithArgs( qword_1001DC898,  2LL,  "%s%.30s:%-4d MASQUE server is already running",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]",  2084);
          }

          goto LABEL_39;
        }

        if (!*((void *)v63 + 40))
        {
          if (qword_1001DC8A0 != -1) {
            dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC898, 16LL))
          {
            id v33 = sub_1000A2100();
            _NRLogWithArgs( v33,  16LL,  "%s%.30s:%-4d Failed to start MASQUE server without local identity",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]",  2089);
          }

          goto LABEL_39;
        }

        nw_endpoint_t host = nw_endpoint_create_host("::", "0");
        if (host)
        {
          nw_parameters_t v22 = nw_parameters_create();
          p_class_meths = (id *)v22;
          if (v22)
          {
            nw_parameters_set_local_address(v22, host);
            nw_parameters_set_use_awdl(p_class_meths, 1LL);
            nw_parameters_set_no_proxy(p_class_meths, 1LL);
            options = nw_tls_create_options();
            uint64_t v62 = nw_tls_copy_sec_protocol_options(options);
            sec_protocol_options_set_local_identity(v62, *((sec_identity_t *)v63 + 40));
            id v59 = *((id *)v63 + 13);
            sec_protocol_options_add_server_raw_public_key_certificate( v62,  [v59 bytes],  objc_msgSend(*((id *)v63 + 13), "length"));
            id v23 = *((id *)v63 + 17);
            uint64_t v24 = nw_masque_server_create(p_class_meths, v62, v23);
            __int128 v26 = (void *)*((void *)v63 + 19);
            id v25 = (void **)(v63 + 152);
            *((void *)v63 + 19) = v24;

            SecIdentityRef v27 = *v25;
            if (*v25) {
              goto LABEL_56;
            }
            if (qword_1001DC8A0 != -1) {
              dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
            }
            if (_NRLogIsLevelEnabled(qword_1001DC898, 16LL))
            {
              id v28 = sub_1000A2100();
              _NRLogWithArgs( v28,  16LL,  "%s%.30s:%-4d Failed to create MASQUE server",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]",  2116);
            }

            SecIdentityRef v27 = (void *)*((void *)v63 + 19);
            if (v27)
            {
LABEL_56:
              objc_initWeak(&v75, v27);
              objc_initWeak(&v74, v63);
              id v29 = *((id *)v63 + 19);
              v71[0] = _NSConcreteStackBlock;
              v71[1] = 3221225472LL;
              v71[2] = sub_1000AC208;
              v71[3] = &unk_1001AEFB0;
              v58[1] = &v72;
              objc_copyWeak(&v72, &v74);
              objc_copyWeak(&v73, &v75);
              nw_masque_server_set_state_changed_handler(v29, v71);

              id v30 = *((id *)v63 + 19);
              v68[0] = _NSConcreteStackBlock;
              v68[1] = 3221225472LL;
              v68[2] = sub_1000AC4F0;
              v68[3] = &unk_1001AF028;
              objc_copyWeak(&v69, &v74);
              objc_copyWeak(&v70, &v75);
              nw_masque_server_set_outer_connection_handler(v30, v68);

              id v31 = *((id *)v63 + 19);
              v65[0] = _NSConcreteStackBlock;
              v65[1] = 3221225472LL;
              v65[2] = sub_1000AC624;
              v65[3] = &unk_1001AF050;
              objc_copyWeak(&v66, &v74);
              objc_copyWeak(&v67, &v75);
              nw_masque_server_set_proxy_client_connection_event_handler(v31, v65);

              id v32 = *((id *)v63 + 19);
              nw_masque_server_start();

              objc_destroyWeak(&v67);
              objc_destroyWeak(&v66);
              objc_destroyWeak(&v70);
              objc_destroyWeak(&v69);
              objc_destroyWeak(&v73);
              objc_destroyWeak(&v72);
              objc_destroyWeak(&v74);
              objc_destroyWeak(&v75);

              goto LABEL_39;
            }

            id v50 = sub_1000A2100();
            int v51 = _NRLogIsLevelEnabled(v50, 16LL);

            if (v51)
            {
              id v52 = sub_1000A2100();
              _NRLogWithArgs( v52,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (self.masqueServer) != ((void *)0)",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]",  2117);
            }

            uint64_t v53 = _os_log_pack_size(12LL);
            id v54 = (char *)v58 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v55 = __error();
            uint64_t v56 = _os_log_pack_fill( v54,  v53,  *v55,  &_mh_execute_header,  "%{public}s Assertion Failed: (self.masqueServer) != ((void *)0)");
            *(_DWORD *)uint64_t v56 = 136446210;
            *(void *)(v56 + 4) = "-[NRLinkDirector startMASQUEProxyServerIfNeeded]";
            id v57 = sub_1000A2100();
            _NRLogAbortWithPack(v57, v54);
          }

          else
          {
            id v42 = sub_1000A2100();
            int v43 = _NRLogIsLevelEnabled(v42, 16LL);

            if (v43)
            {
              id v44 = sub_1000A2100();
              _NRLogWithArgs( v44,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (masqueParameters) != ((void *)0)",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]",  2096);
            }

            uint64_t v45 = _os_log_pack_size(12LL);
            uint64_t v46 = (char *)v58 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
            id v47 = __error();
            uint64_t v48 = _os_log_pack_fill( v46,  v45,  *v47,  &_mh_execute_header,  "%{public}s Assertion Failed: (masqueParameters) != ((void *)0)");
            *(_DWORD *)uint64_t v48 = 136446210;
            *(void *)(v48 + 4) = "-[NRLinkDirector startMASQUEProxyServerIfNeeded]";
            id v49 = sub_1000A2100();
            _NRLogAbortWithPack(v49, v46);
          }
        }

        else
        {
          id v34 = sub_1000A2100();
          int v35 = _NRLogIsLevelEnabled(v34, 16LL);

          if (v35)
          {
            id v36 = sub_1000A2100();
            _NRLogWithArgs( v36,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (masqueEndpoint) != ((void *)0)",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]",  2094);
          }

          uint64_t v37 = _os_log_pack_size(12LL);
          id v38 = (char *)v58 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v39 = __error();
          uint64_t v40 = _os_log_pack_fill( v38,  v37,  *v39,  &_mh_execute_header,  "%{public}s Assertion Failed: (masqueEndpoint) != ((void *)0)");
          *(_DWORD *)uint64_t v40 = 136446210;
          *(void *)(v40 + 4) = "-[NRLinkDirector startMASQUEProxyServerIfNeeded]";
          id v41 = sub_1000A2100();
          _NRLogAbortWithPack(v41, v38);
        }

        while (1)
        {
          __break(1u);
LABEL_71:
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
LABEL_45:
          id v16 = p_class_meths[275];
          _NRLogWithArgs( v16,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]",  2064);

LABEL_46:
          uint64_t v17 = _os_log_pack_size(12LL);
          uint64_t v18 = (char *)v58 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          Class v19 = __error();
          uint64_t v20 = _os_log_pack_fill( v18,  v17,  *v19,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
          *(_DWORD *)uint64_t v20 = 136446210;
          *(void *)(v20 + 4) = "-[NRLinkDirector startMASQUEProxyServerIfNeeded]";
          id v21 = sub_1000A2100();
          _NRLogAbortWithPack(v21, v18);
        }
      }

      sub_1000A45F8((uint64_t)v63);
LABEL_39:

      return;
    }

    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC898, 1LL))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      _NRLogWithArgs( qword_1001DC898,  1LL,  "%s%.30s:%-4d MASQUEProxyServer feature disabled",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]",  2056);
    }
  }

void sub_1000A9694(_Unwind_Exception *a1)
{
}

void sub_1000A96FC()
{
  id v4 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  if (!v4)
  {
    id v27 = sub_1000A2100();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v27, 16LL);

    if (IsLevelEnabled)
    {
      id v29 = sub_1000A2100();
      _NRLogWithArgs( v29,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (entryDict) != ((void *)0)",  "",  "-[NRLinkDirector addTerminusPrefixDropPolicy]",  1668);
    }

    uint64_t v5 = (NSMutableDictionary *)_os_log_pack_size(12LL);
    BOOL v9 = (char *)&v37 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v30 = *__error();
    uint64_t v31 = _os_log_pack_fill(v9, v5, v30, &_mh_execute_header, "%{public}s Assertion Failed: (entryDict) != ((void *)0)");
    goto LABEL_69;
  }

  uint64_t v5 = v4;
  objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
  id v6 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v6);

  __int128 v39 = xmmword_100156950;
  uint64_t v7 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v39, 16LL);
  id v8 = sub_10012D958((uint64_t)&OBJC_CLASS___NRDLocalDevice, v7, @"0");
  BOOL v9 = (char *)objc_claimAutoreleasedReturnValue(v8);

  -[NSMutableDictionary setObject:forKeyedSubscript:]( v5,  "setObject:forKeyedSubscript:",  @"PrivilegedTunnel",  @"Level");
  id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 hostname]);
  -[NSMutableDictionary setObject:forKeyedSubscript:](v5, "setObject:forKeyedSubscript:", v10, @"Address");

  -[NSMutableDictionary setObject:forKeyedSubscript:]( v5,  "setObject:forKeyedSubscript:",  &off_1001BC688,  @"Prefix");
  uint64_t v1 = @"/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist";
  id v11 = -[NSMutableArray initWithContentsOfFile:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithContentsOfFile:",  @"/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist");
  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  if (v11)
  {
    v0 = v11;
    uint64_t v12 = objc_opt_class(&OBJC_CLASS___NSMutableArray);
    if ((objc_opt_isKindOfClass(v0, v12) & 1) != 0) {
      goto LABEL_12;
    }
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    uint64_t v2 = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    if (_NRLogIsLevelEnabled(qword_1001DC898, 17LL))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      _NRLogWithArgs( qword_1001DC898,  17LL,  "bad file format: %@",  @"/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist");
    }
  }

  v0 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  if (!v0)
  {
    id v32 = sub_1000A2100();
    int v33 = _NRLogIsLevelEnabled(v32, 16LL);

    if (v33)
    {
      id v34 = sub_1000A2100();
      _NRLogWithArgs( v34,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (entryArray) != ((void *)0)",  "",  "-[NRLinkDirector addTerminusPrefixDropPolicy]",  1685);
    }

    uint64_t v5 = (NSMutableDictionary *)_os_log_pack_size(12LL);
    BOOL v9 = (char *)&v37 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v35 = *__error();
    uint64_t v31 = _os_log_pack_fill( v9,  v5,  v35,  &_mh_execute_header,  "%{public}s Assertion Failed: (entryArray) != ((void *)0)");
LABEL_69:
    *(_DWORD *)uint64_t v31 = 136446210;
    *(void *)(v31 + 4) = "-[NRLinkDirector addTerminusPrefixDropPolicy]";
    id v36 = sub_1000A2100();
    _NRLogAbortWithPack(v36, v9);
    goto LABEL_70;
  }

LABEL_62:
}

uint64_t sub_1000A9F64()
{
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  v0 = sub_1001314D4((uint64_t)&OBJC_CLASS___NRDLocalDevice);
  uint64_t v1 = (uint64_t)-[NSMutableArray countByEnumeratingWithState:objects:count:]( v0,  "countByEnumeratingWithState:objects:count:",  &v14,  v18,  16LL);
  if (v1)
  {
    uint64_t v2 = *(void *)v15;
    while (2)
    {
      for (uint64_t i = 0LL; i != v1; ++i)
      {
        if (*(void *)v15 != v2) {
          objc_enumerationMutation(v0);
        }
        id v4 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(*((void *)&v14 + 1) + 8 * i));
        uint64_t v5 = v4;
        if (v4) {
          id v6 = (void *)*((void *)v4 + 16);
        }
        else {
          id v6 = 0LL;
        }
        id v7 = v6;
        id v8 = objc_msgSend(v7, "proxyCapability", (void)v14);

        if (v8 == (id)2)
        {
          if (sub_1001319A0((BOOL)v5)
            || (!v5 ? (BOOL v9 = 0LL) : (BOOL v9 = (void *)*((void *)v5 + 16)),
                id v10 = v9,
                id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 proxyProviderCriteria]),
                unsigned __int8 v12 = [v11 excludeVPNClients],
                v11,
                v10,
                (v12 & 1) != 0))
          {

            uint64_t v1 = 1LL;
            goto LABEL_20;
          }
        }
      }

      uint64_t v1 = (uint64_t)-[NSMutableArray countByEnumeratingWithState:objects:count:]( v0,  "countByEnumeratingWithState:objects:count:",  &v14,  v18,  16LL);
      if (v1) {
        continue;
      }
      break;
    }
  }

void sub_1000AA0FC()
{
  uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  if (!v5)
  {
    id v18 = sub_1000A2100();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 16LL);

    if (IsLevelEnabled)
    {
      id v20 = sub_1000A2100();
      _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (entryDict) != ((void *)0)",  "",  "-[NRLinkDirector removeTerminusPrefixDropPolicy]",  1746);
    }

    id v6 = (NSMutableDictionary *)_os_log_pack_size(12LL);
    id v10 = (char *)&v29 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v21 = __error();
    uint64_t v22 = _os_log_pack_fill( v10,  v6,  *v21,  &_mh_execute_header,  "%{public}s Assertion Failed: (entryDict) != ((void *)0)");
    *(_DWORD *)uint64_t v22 = 136446210;
    *(void *)(v22 + 4) = "-[NRLinkDirector removeTerminusPrefixDropPolicy]";
    goto LABEL_38;
  }

  id v6 = v5;
  objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
  id v7 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v7);

  __int128 v31 = xmmword_100156950;
  id v8 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v31, 16LL);
  id v9 = sub_10012D958((uint64_t)&OBJC_CLASS___NRDLocalDevice, v8, @"0");
  id v10 = (char *)objc_claimAutoreleasedReturnValue(v9);

  -[NSMutableDictionary setObject:forKeyedSubscript:]( v6,  "setObject:forKeyedSubscript:",  @"PrivilegedTunnel",  @"Level");
  id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 hostname]);
  -[NSMutableDictionary setObject:forKeyedSubscript:](v6, "setObject:forKeyedSubscript:", v11, @"Address");

  -[NSMutableDictionary setObject:forKeyedSubscript:]( v6,  "setObject:forKeyedSubscript:",  &off_1001BC688,  @"Prefix");
  uint64_t v2 = &APSConnectionOverrideNamedDelegatePort_ptr;
  uint64_t v1 = @"/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist";
  unsigned __int8 v12 = -[NSMutableArray initWithContentsOfFile:]( objc_alloc(&OBJC_CLASS___NSMutableArray),  "initWithContentsOfFile:",  @"/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist");
  if (v12)
  {
    v0 = v12;
    uint64_t v13 = objc_opt_class(&OBJC_CLASS___NSMutableArray);
    if ((objc_opt_isKindOfClass(v0, v13) & 1) != 0) {
      goto LABEL_12;
    }
    p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    id v4 = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    if (_NRLogIsLevelEnabled(qword_1001DC898, 17LL))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      _NRLogWithArgs( qword_1001DC898,  17LL,  "bad file format: %@",  @"/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist");
    }
  }

  v0 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  if (!v0)
  {
    id v23 = sub_1000A2100();
    int v24 = _NRLogIsLevelEnabled(v23, 16LL);

    v0 = (NSMutableArray *)"-[NRLinkDirector removeTerminusPrefixDropPolicy]";
    if (v24)
    {
      id v25 = sub_1000A2100();
      _NRLogWithArgs( v25,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (entryArray) != ((void *)0)",  "",  "-[NRLinkDirector removeTerminusPrefixDropPolicy]",  1763);
    }

    id v6 = (NSMutableDictionary *)_os_log_pack_size(12LL);
    id v10 = (char *)&v29 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v26 = __error();
    uint64_t v27 = _os_log_pack_fill( v10,  v6,  *v26,  &_mh_execute_header,  "%{public}s Assertion Failed: (entryArray) != ((void *)0)");
    *(_DWORD *)uint64_t v27 = 136446210;
    *(void *)(v27 + 4) = "-[NRLinkDirector removeTerminusPrefixDropPolicy]";
LABEL_38:
    id v28 = sub_1000A2100();
    _NRLogAbortWithPack(v28, v10);
    goto LABEL_39;
  }

NSMutableArray *sub_1000AA684(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(a1);
  id v4 = -[NSMutableArray initWithCapacity:]( [NSMutableArray alloc],  "initWithCapacity:",  [v3 count]);
  __int128 v31 = 0u;
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v34 = 0u;
  id v5 = v3;
  id v6 = [v5 countByEnumeratingWithState:&v31 objects:v35 count:16];
  if (!v6)
  {

    uint64_t v27 = 0LL;
    goto LABEL_24;
  }

  id v7 = v6;
  char v8 = 0;
  id v9 = &APSConnectionOverrideNamedDelegatePort_ptr;
  id v10 = @"Level";
  uint64_t v11 = *(void *)v32;
  while (2)
  {
    unsigned __int8 v12 = 0LL;
    id v30 = v7;
    do
    {
      if (*(void *)v32 != v11) {
        objc_enumerationMutation(v5);
      }
      uint64_t v21 = *(void **)(*((void *)&v31 + 1) + 8LL * (void)v12);
      uint64_t v22 = objc_opt_class(v9[137]);
      if ((objc_opt_isKindOfClass(v21, v22) & 1) != 0)
      {
        id v23 = v21;
        int v24 = (void *)objc_claimAutoreleasedReturnValue([v23 objectForKeyedSubscript:v10]);
        uint64_t v25 = objc_opt_class(&OBJC_CLASS___NSNumber);
        if ((objc_opt_isKindOfClass(v24, v25) & 1) != 0)
        {
          uint64_t StringForLegacyNECPLevel = NEPolicyGetStringForLegacyNECPLevel([v24 unsignedIntValue]);
          uint64_t v14 = v11;
          __int128 v15 = v9;
          id v16 = v5;
          __int128 v17 = v4;
          id v18 = v10;
          id v19 = (void *)objc_claimAutoreleasedReturnValue(StringForLegacyNECPLevel);
          id v20 = [v23 mutableCopy];
          [v20 setObject:v19 forKeyedSubscript:v18];
          -[NSMutableArray addObject:](v17, "addObject:", v20);

          id v10 = v18;
          id v4 = v17;
          id v5 = v16;
          id v9 = v15;
          uint64_t v11 = v14;
          id v7 = v30;
          char v8 = 1;
        }

        else
        {
          -[NSMutableArray addObject:](v4, "addObject:", v23);
        }

LABEL_7:
        goto LABEL_8;
      }

      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC898, 16LL))
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        id v23 = (id)qword_1001DC898;
        uint64_t v26 = objc_opt_class(v21);
        _NRLogWithArgs( v23,  16LL,  "%s%.30s:%-4d Array entry is %@, not NSDictionary",  "",  "+[NRLinkDirector convertDropDestArray:]",  1658LL,  v26);
        goto LABEL_7;
      }

void sub_1000AA978(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained && *((_BYTE *)WeakRetained + 12) && *((void *)WeakRetained + 35) == *(void *)(a1 + 32))
  {
    id v3 = WeakRetained;
    sub_1000AA9D0(0LL);
    id WeakRetained = v3;
  }
}

void sub_1000AA9D0(void *a1)
{
  id v1 = a1;
  if (qword_1001DC888 != -1) {
    dispatch_once(&qword_1001DC888, &stru_1001AF138);
  }
  if (proc_pidinfo(dword_1001DBCC8, 3, 0LL, buffer, 136) != 136)
  {
    int v7 = *__error();
    if (strerror_r(v7, v60, 0x80uLL)) {
      v60[0] = 0;
    }
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC898, 16LL))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      _NRLogWithArgs( qword_1001DC898,  16LL,  "%s%.30s:%-4d failed to fetch bsd info: [%d] %s",  "",  "-[NRLinkDirector checkFDUsageAndFillInStatusDictionary:]",  3020,  v7,  v60);
    }

    goto LABEL_83;
  }

  if (!v62)
  {
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    if (qword_1001DC8A0 == -1)
    {
LABEL_24:
      _NRLogWithArgs( p_class_meths[275],  2LL,  "%s%.30s:%-4d no open files",  "",  "-[NRLinkDirector checkFDUsageAndFillInStatusDictionary:]",  3025);
      goto LABEL_83;
    }

LABEL_87:
    dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    goto LABEL_24;
  }

  if (v62 >= 0x401)
  {
    uint64_t v2 = objc_alloc(&OBJC_CLASS___NSString);
    id v3 = -[NSString initWithFormat:](v2, "initWithFormat:", @"unexpected number of open files %u", v62);
    sub_1001030D0(@"fdUsageMonitor", v3, 0LL, 0, 0LL, v4, v5, v6, v48);
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC898, 17LL))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      _NRLogWithArgs(qword_1001DC898, 17LL, "%@", v3);
    }

LABEL_82:
    goto LABEL_83;
  }

  uint64_t v9 = 8LL * v62;
  id v10 = (unsigned int *)malloc(v9);
  if (!v10)
  {
    id v41 = sub_1000A2100();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v41, 16LL);

    if (IsLevelEnabled)
    {
      id v43 = sub_1000A2100();
      _NRLogWithArgs(v43, 16LL, "%s%.30s:%-4d ABORTING: strict_malloc(%zu) failed", "", "strict_malloc", 79, v9);
    }

    uint64_t v44 = _os_log_pack_size(22LL);
    p_class_meths = (__objc2_meth_list **)((char *)&v48 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL));
    uint64_t v45 = __error();
    uint64_t v46 = _os_log_pack_fill( p_class_meths,  v44,  *v45,  &_mh_execute_header,  "%{public}s strict_malloc(%zu) failed");
    *(_DWORD *)uint64_t v46 = 136446466;
    *(void *)(v46 + 4) = "strict_malloc";
    *(_WORD *)(v46 + 12) = 2048;
    *(void *)(v46 + 14) = v9;
    id v47 = sub_1000A2100();
    _NRLogAbortWithPack(v47, p_class_meths);
    goto LABEL_87;
  }

  uint64_t v11 = v10;
  int v12 = proc_pidinfo(dword_1001DBCC8, 1, 0LL, v10, v9);
  if (v12 >= 1)
  {
    unsigned int v13 = v12;
    if ((v12 & 7) == 0)
    {
      id v49 = v1;
      uint64_t v14 = objc_alloc_init(&OBJC_CLASS___NSCountedSet);
      if (v13 >= 8)
      {
        uint64_t v28 = v13 >> 3;
        uint64_t v29 = v11 + 1;
        do
        {
          switch(*v29)
          {
            case 0u:
              -[NSCountedSet addObject:](v14, "addObject:", @"ATALK");
              break;
            case 1u:
              -[NSCountedSet addObject:](v14, "addObject:", @"VNODE");
              break;
            case 2u:
              -[NSCountedSet addObject:](v14, "addObject:", @"SOCKET");
              break;
            case 3u:
              -[NSCountedSet addObject:](v14, "addObject:", @"PSHM");
              break;
            case 4u:
              -[NSCountedSet addObject:](v14, "addObject:", @"PSEM");
              break;
            case 5u:
              -[NSCountedSet addObject:](v14, "addObject:", @"KQUEUE");
              break;
            case 6u:
              -[NSCountedSet addObject:](v14, "addObject:", @"PIPE");
              break;
            case 7u:
              -[NSCountedSet addObject:](v14, "addObject:", @"FSEVENTS");
              break;
            case 9u:
              -[NSCountedSet addObject:](v14, "addObject:", @"NETPOLICY");
              break;
            case 0xAu:
              -[NSCountedSet addObject:](v14, "addObject:", @"CHANNEL");
              break;
            case 0xBu:
              -[NSCountedSet addObject:](v14, "addObject:", @"NEXUS");
              break;
            default:
              id v30 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%u",  *v29);
              -[NSCountedSet addObject:](v14, "addObject:", v30);

              break;
          }

          v29 += 2;
          --v28;
        }

        while (v28);
      }

      free(v11);
      __int128 v56 = 0u;
      __int128 v57 = 0u;
      __int128 v54 = 0u;
      __int128 v55 = 0u;
      id v3 = v14;
      id v15 = -[NSCountedSet countByEnumeratingWithState:objects:count:]( v3,  "countByEnumeratingWithState:objects:count:",  &v54,  v59,  16LL);
      if (v15)
      {
        id v16 = v15;
        LODWORD(v17) = 0;
        uint64_t v18 = *(void *)v55;
        do
        {
          for (uint64_t i = 0LL; i != v16; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v55 != v18) {
              objc_enumerationMutation(v3);
            }
            uint64_t v20 = *(void *)(*((void *)&v54 + 1) + 8LL * (void)i);
            id v21 = -[NSCountedSet countForObject:](v3, "countForObject:", v20);
            if (qword_1001DC8A0 != -1) {
              dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
            }
            if (_NRLogIsLevelEnabled(qword_1001DC898, 2LL))
            {
              if (qword_1001DC8A0 != -1) {
                dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
              }
              _NRLogWithArgs( qword_1001DC898,  2LL,  "%s%.30s:%-4d fd usage summary - %@ : %u",  "",  "-[NRLinkDirector checkFDUsageAndFillInStatusDictionary:]",  3080LL,  v20,  v21);
            }

            if (v49)
            {
              uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v21));
              [v49 setObject:v22 forKeyedSubscript:v20];
            }

            if (v21 >= 0x101)
            {
              id v23 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"FD usage for type %@ exceeded threshold(%u)",  v20,  256LL);
              sub_1001030D0(@"fdUsageMonitor", v23, 0LL, 0, 0LL, v24, v25, v26, v48);
            }

            uint64_t v17 = (v17 + (_DWORD)v21);
          }

          id v16 = -[NSCountedSet countByEnumeratingWithState:objects:count:]( v3,  "countByEnumeratingWithState:objects:count:",  &v54,  v59,  16LL);
        }

        while (v16);
      }

      else
      {
        uint64_t v17 = 0LL;
      }

      id v1 = v49;
      if (v49)
      {
        __int128 v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:", v17));
        [v49 setObject:v31 forKeyedSubscript:@"Total"];
      }

      if (v17 >= 0x201)
      {
        __int128 v32 = -[NSMutableString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSMutableString),  "initWithFormat:",  @"Total FD usage exceeded threshold(%u)",  512LL);
        __int128 v50 = 0u;
        __int128 v51 = 0u;
        __int128 v52 = 0u;
        __int128 v53 = 0u;
        __int128 v33 = v3;
        id v34 = -[NSCountedSet countByEnumeratingWithState:objects:count:]( v33,  "countByEnumeratingWithState:objects:count:",  &v50,  v58,  16LL);
        if (v34)
        {
          id v35 = v34;
          uint64_t v36 = *(void *)v51;
          do
          {
            for (j = 0LL; j != v35; j = (char *)j + 1)
            {
              if (*(void *)v51 != v36) {
                objc_enumerationMutation(v33);
              }
              -[NSMutableString appendFormat:]( v32,  "appendFormat:",  @" %@:%u",  *(void *)(*((void *)&v50 + 1) + 8LL * (void)j),  -[NSCountedSet countForObject:]( v33,  "countForObject:",  *(void *)(*((void *)&v50 + 1) + 8LL * (void)j)));
            }

            id v35 = -[NSCountedSet countByEnumeratingWithState:objects:count:]( v33,  "countByEnumeratingWithState:objects:count:",  &v50,  v58,  16LL);
          }

          while (v35);
        }

        sub_1001030D0(@"fdUsageMonitor", v32, 0LL, 0, 0LL, v38, v39, v40, v48);
      }

      goto LABEL_82;
    }
  }

  int v27 = *__error();
  if (strerror_r(v27, v60, 0x80uLL)) {
    v60[0] = 0;
  }
  if (qword_1001DC8A0 != -1) {
    dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC898, 16LL))
  {
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    _NRLogWithArgs( qword_1001DC898,  16LL,  "%s%.30s:%-4d failed to fetch fd info: [%d] %s",  "",  "-[NRLinkDirector checkFDUsageAndFillInStatusDictionary:]",  3041,  v27,  v60);
  }

  free(v11);
LABEL_83:
}

void sub_1000AB384(id a1)
{
  dword_1001DBCC8 = getpid();
}

void sub_1000AB3A0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v5 = (uint64_t)WeakRetained;
  if (WeakRetained && WeakRetained[12] && *((void *)WeakRetained + 36) == *(void *)(a1 + 32))
  {
    uint64_t v25 = 0LL;
    uint64_t v26 = &v25;
    uint64_t v27 = 0x3032000000LL;
    uint64_t v28 = sub_1000AB748;
    uint64_t v29 = sub_1000AB758;
    id v30 = 0LL;
    uint64_t v21 = 0LL;
    uint64_t v22 = &v21;
    uint64_t v23 = 0x2020000000LL;
    char v24 = 0;
    uint64_t v6 = (void *)nw_path_copy_netagent_dictionary(v3);
    int v7 = v6;
    if (v6)
    {
      applier[0] = _NSConcreteStackBlock;
      applier[1] = 3221225472LL;
      applier[2] = sub_1000AB760;
      applier[3] = &unk_1001AF0A0;
      applier[4] = &v25;
      applier[5] = &v21;
      xpc_dictionary_apply(v6, applier);
    }

    id v8 = *(id *)(v5 + 296);
    uint64_t v9 = v26;
    if (v8 || v26[5])
    {
      id v10 = *(id *)(v5 + 296);
      unsigned __int8 v11 = [v10 isEqual:v9[5]];

      if ((v11 & 1) == 0)
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        id v12 = (id)qword_1001DC898;
        int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 1LL);

        if (IsLevelEnabled)
        {
          if (qword_1001DC8A0 != -1) {
            dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
          }
          id v14 = (id)qword_1001DC898;
          id v15 = *(id *)(v5 + 296);
          _NRLogWithArgs( v14,  1LL,  "%s%.30s:%-4d AppVPN agent %@",  "",  "-[NRLinkDirector setupAppVPNWatcher]_block_invoke",  2418LL,  v15);
        }

        objc_storeStrong((id *)(v5 + 296), (id)v26[5]);
        sub_1000A2170(v5);
      }
    }

    int v16 = *((unsigned __int8 *)v22 + 24);
    if (v16 != *(unsigned __int8 *)(v5 + 18))
    {
      *(_BYTE *)(v5 + 18) = v16;
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      id v17 = (id)qword_1001DC898;
      int v18 = _NRLogIsLevelEnabled(v17, 1LL);

      if (v18)
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        id v19 = (id)qword_1001DC898;
        _NRLogWithArgs( v19,  1LL,  "%s%.30s:%-4d detected AppVPN active %d",  "",  "-[NRLinkDirector setupAppVPNWatcher]_block_invoke",  2425,  *(unsigned __int8 *)(v5 + 18));
      }
    }

    _Block_object_dispose(&v21, 8);
    _Block_object_dispose(&v25, 8);
  }
}

void sub_1000AB6B4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v12 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000AB6D8(void *a1)
{
  uint64_t v1 = a1[4];
  if (v1 && *(_BYTE *)(v1 + 12) && *(void *)(v1 + 288) == a1[5])
  {
    id v3 = (id)nw_path_evaluator_copy_path();
    (*(void (**)(void))(a1[6] + 16LL))();
  }

uint64_t sub_1000AB748(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1000AB758(uint64_t a1)
{
}

uint64_t sub_1000AB760(uint64_t a1, int a2, xpc_object_t xdict)
{
  size_t length = 0LL;
  data = (const char *)xpc_dictionary_get_data(xdict, "data", &length);
  uint64_t result = 1LL;
  if (data && length >= 0xD8 && length == *((unsigned int *)data + 53) + 216LL)
  {
    if (!strcmp(data + 16, "NetworkExtension") && !strcmp(data + 48, "AppVPN"))
    {
      uint64_t v6 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", data);
      uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8LL);
      id v8 = *(void **)(v7 + 40);
      *(void *)(v7 + 40) = v6;

      uint64_t result = 0LL;
      *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = (data[208] & 2) != 0;
    }

    else
    {
      return 1LL;
    }
  }

  return result;
}

void sub_1000AB838(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && *((_BYTE *)WeakRetained + 12) && *((_DWORD *)WeakRetained + 7) == a2)
  {
    id v4 = WeakRetained;
    sub_1000AB88C(WeakRetained, a2);
    id WeakRetained = v4;
  }
}

void sub_1000AB88C(id val, int a2)
{
  int v4 = *((_DWORD *)val + 8) + 1;
  *((_DWORD *)val + 8) = v4;
  objc_initWeak(&location, val);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue( +[NEConfigurationManager sharedManagerForAllUsers]( &OBJC_CLASS___NEConfigurationManager,  "sharedManagerForAllUsers"));
  id v6 = *((id *)val + 17);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  id v7[2] = sub_1000AB98C;
  v7[3] = &unk_1001AF118;
  objc_copyWeak(&v8, &location);
  int v9 = a2;
  int v10 = v4;
  [v5 loadConfigurationsWithCompletionQueue:v6 handler:v7];

  objc_destroyWeak(&v8);
  objc_destroyWeak(&location);
}

void sub_1000AB968( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_1000AB98C(id *IsLevelEnabled, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = (id *)objc_loadWeakRetained(IsLevelEnabled + 4);
  uint64_t v8 = (uint64_t)WeakRetained;
  if (!WeakRetained
    || !*((_BYTE *)WeakRetained + 12)
    || *((_DWORD *)WeakRetained + 7) != *((_DWORD *)IsLevelEnabled + 10)
    || *((_DWORD *)IsLevelEnabled + 11) != *((_DWORD *)WeakRetained + 8))
  {
    goto LABEL_58;
  }

  if (!v6)
  {
    id location = WeakRetained + 39;
    id v38 = WeakRetained[39];
    int v9 = *(void **)(v8 + 312);
    *(void *)(v8 + 312) = 0LL;

    id v37 = *(id *)(v8 + 304);
    int v10 = *(void **)(v8 + 304);
    uint64_t v39 = v8;
    *(void *)(v8 + 304) = 0LL;

    id v42 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v49 = 0u;
    __int128 v50 = 0u;
    id v40 = v5;
    id v11 = v5;
    id v12 = [v11 countByEnumeratingWithState:&v47 objects:v52 count:16];
    if (v12)
    {
      id v13 = v12;
      uint64_t v14 = 0LL;
      uint64_t v15 = *(void *)v48;
      do
      {
        for (uint64_t i = 0LL; i != v13; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v48 != v15) {
            objc_enumerationMutation(v11);
          }
          id v17 = *(void **)(*((void *)&v47 + 1) + 8LL * (void)i);
          uint64_t v18 = objc_claimAutoreleasedReturnValue([v17 appVPN]);
          if (v18)
          {
            id v19 = (void *)v18;
            uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v17 appVPN]);
            unsigned int v21 = [v20 isEnabled];

            if (v21)
            {
              uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v17 appVPN]);
              id v23 = [v22 copyAppRuleIDs];

              if ([v23 count]) {
                -[NSMutableArray addObjectsFromArray:](v42, "addObjectsFromArray:", v23);
              }
            }
          }

          int IsLevelEnabled = (id *)[v17 copyProviderMachOUUIDs];
          if ([IsLevelEnabled count])
          {
            if (!v14) {
              uint64_t v14 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
            }
            -[NSMutableSet addObjectsFromArray:](v14, "addObjectsFromArray:", IsLevelEnabled);
          }
        }

        id v13 = [v11 countByEnumeratingWithState:&v47 objects:v52 count:16];
      }

      while (v13);
    }

    else
    {
      uint64_t v14 = 0LL;
    }

    uint64_t v8 = v39;
    char v24 = (id *)(v39 + 304);

    uint64_t v25 = location;
    objc_storeStrong(location, v14);
    id v5 = v40;
    if (-[NSMutableArray count](v42, "count"))
    {
      uint64_t v26 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
      __int128 v43 = 0u;
      __int128 v44 = 0u;
      __int128 v45 = 0u;
      __int128 v46 = 0u;
      uint64_t v27 = v42;
      uint64_t v28 = (id *)-[NSMutableArray countByEnumeratingWithState:objects:count:]( v27,  "countByEnumeratingWithState:objects:count:",  &v43,  v51,  16LL);
      if (v28)
      {
        int IsLevelEnabled = v28;
        uint64_t v29 = *(void *)v44;
        do
        {
          id v30 = 0LL;
          do
          {
            if (*(void *)v44 != v29) {
              objc_enumerationMutation(v27);
            }
            id v31 = sub_10010172C(*(void **)(*((void *)&v43 + 1) + 8LL * (void)v30));
            if ([v31 count]) {
              -[NSMutableSet addObjectsFromArray:](v26, "addObjectsFromArray:", v31);
            }

            id v30 = (id *)((char *)v30 + 1);
          }

          while (IsLevelEnabled != v30);
          int IsLevelEnabled = (id *)-[NSMutableArray countByEnumeratingWithState:objects:count:]( v27,  "countByEnumeratingWithState:objects:count:",  &v43,  v51,  16LL);
        }

        while (IsLevelEnabled);
      }

      if (-[NSMutableSet count](v26, "count"))
      {
        objc_storeStrong(v24, v26);
        id v32 = sub_1000A2100();
        int IsLevelEnabled = (id *)_NRLogIsLevelEnabled(v32, 1LL);

        if ((_DWORD)IsLevelEnabled)
        {
          id v33 = sub_1000A2100();
          _NRLogWithArgs( v33,  1LL,  "%s%.30s:%-4d fetched app vpn UUIDs %@",  "",  "-[NRLinkDirector processNEConfigurationChangeForNotifyToken:]_block_invoke",  2589LL,  *v24);
        }
      }

      uint64_t v25 = location;
    }

    id v6 = 0LL;
    if (v37 || (int IsLevelEnabled = (id *)*v24) != 0LL)
    {
      unsigned __int8 v34 = [*v24 isEqualToSet:v37];
      if (!v37) {

      }
      if ((v34 & 1) == 0) {
        sub_1000A2170(v39);
      }
    }

    if (v38 || (int IsLevelEnabled = (id *)*v25) != 0LL)
    {
      unsigned int v35 = [*v25 isEqualToSet:v38];
      char v36 = v35;
      if (v38)
      {
        if (!v35) {
          goto LABEL_56;
        }
      }

      else
      {

        if ((v36 & 1) == 0) {
          goto LABEL_56;
        }
      }
    }

    if (*v25)
    {
LABEL_57:

      goto LABEL_58;
    }

void sub_1000ABE64(id a1)
{
}

void sub_1000ABE70(uint64_t a1, int a2)
{
  id WeakRetained = (dispatch_queue_s **)objc_loadWeakRetained((id *)(a1 + 32));
  int v4 = WeakRetained;
  if (WeakRetained && *((_DWORD *)WeakRetained + 6) == a2)
  {
    id v5 = WeakRetained[17];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_1000ABEF0;
    block[3] = &unk_1001B0A88;
    void block[4] = v4;
    dispatch_async(v5, block);
  }
}

void sub_1000ABEF0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    if (*(_BYTE *)(v1 + 12))
    {
      int v3 = *(_DWORD *)(v1 + 24);
      if (v3 != -1)
      {
        uint64_t state64 = 0LL;
        notify_get_state(v3, &state64);
        uint64_t v4 = *(void *)(a1 + 32);
        if (v4)
        {
          *(_DWORD *)(v4 + 20) = state64;
          uint64_t v5 = *(void *)(a1 + 32);
          uint64_t v6 = v5 ? *(unsigned int *)(v5 + 20) : 0LL;
        }

        else
        {
          uint64_t v5 = 0LL;
          uint64_t v6 = 0LL;
        }

        StringFromThermalPressureLevel = (void *)createStringFromThermalPressureLevel(v6);
        sub_1000A2084(v5, 1049, @"%@", v8, v9, v10, v11, v12, (uint64_t)StringFromThermalPressureLevel);

        uint64_t v13 = *(void *)(a1 + 32);
        if (v13)
        {
          id v14 = *(id *)(v13 + 216);
          if (v14)
          {
            uint64_t v15 = v14;
            uint64_t v16 = *(void *)(a1 + 32);
            id v17 = v16 ? *(void **)(v16 + 216) : 0LL;
            id v18 = [v17 count];

            if (v18)
            {
              uint64_t v19 = *(void *)(a1 + 32);
              if (v19) {
                uint64_t v20 = *(void **)(v19 + 40);
              }
              else {
                uint64_t v20 = 0LL;
              }
              [v20 handleThermalStateUpdate];
              uint64_t v21 = *(void *)(a1 + 32);
              if (v21) {
                uint64_t v22 = *(void **)(v21 + 48);
              }
              else {
                uint64_t v22 = 0LL;
              }
              [v22 handleThermalStateUpdate];
              uint64_t v23 = *(void *)(a1 + 32);
              if (v23) {
                char v24 = *(void **)(v23 + 56);
              }
              else {
                char v24 = 0LL;
              }
              [v24 handleThermalStateUpdate];
              uint64_t v25 = *(void *)(a1 + 32);
              if (v25) {
                uint64_t v26 = *(void **)(v25 + 64);
              }
              else {
                uint64_t v26 = 0LL;
              }
              if (_NRIsAppleInternal([v26 handleThermalStateUpdate]))
              {
                uint64_t v27 = *(void *)(a1 + 32);
                if (v27) {
                  uint64_t v28 = *(void **)(v27 + 184);
                }
                else {
                  uint64_t v28 = 0LL;
                }
                [v28 handleThermalStateUpdate];
              }

              __int128 v45 = 0u;
              __int128 v46 = 0u;
              __int128 v43 = 0u;
              __int128 v44 = 0u;
              uint64_t v29 = *(void **)(a1 + 32);
              if (v29) {
                uint64_t v29 = (void *)v29[27];
              }
              id v30 = v29;
              id v31 = [v30 countByEnumeratingWithState:&v43 objects:v48 count:16];
              if (v31)
              {
                id v32 = v31;
                uint64_t v33 = *(void *)v44;
                do
                {
                  for (uint64_t i = 0LL; i != v32; uint64_t i = (char *)i + 1)
                  {
                    if (*(void *)v44 != v33) {
                      objc_enumerationMutation(v30);
                    }
                    uint64_t v36 = *(void *)(a1 + 32);
                    if (v36) {
                      id v37 = *(void **)(v36 + 216);
                    }
                    else {
                      id v37 = 0LL;
                    }
                    uint64_t v38 = objc_claimAutoreleasedReturnValue( [v37 objectForKeyedSubscript:*(void *)(*((void *)&v43 + 1) + 8 * (void)i)]);
                    uint64_t v39 = v38;
                    if (v38 && *(_BYTE *)(v38 + 13))
                    {
                      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
                      if (qword_1001DC878 != -1) {
                        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
                      }
                      id v40 = (id)qword_1001DC870;
                      if (v40)
                      {
                        unsigned int v35 = v40[5];

                        if (v35 > *(_DWORD *)(v39 + 80))
                        {
                          id v41 = *(id *)(v39 + 624);
                          if (v41) {
                            v41[4] |= 0x400u;
                          }

                          id v42 = *(id *)(v39 + 616);
                          if (v42) {
                            v42[4] |= 0x400u;
                          }
                        }
                      }

                      else
                      {
                        unsigned int v35 = 0;
                      }

                      *(_DWORD *)(v39 + 80) = v35;
                      sub_1000DBA08(v39, *(void **)(v39 + 128));
                    }
                  }

                  id v32 = [v30 countByEnumeratingWithState:&v43 objects:v48 count:16];
                }

                while (v32);
              }
            }
          }
        }
      }
    }
  }

void sub_1000AC208(uint64_t a1, int a2, void *a3)
{
  uint64_t v5 = a3;
  id WeakRetained = (unsigned __int8 *)objc_loadWeakRetained((id *)(a1 + 32));
  id v7 = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v8 = v7;
  if (WeakRetained && WeakRetained[12] && *((id *)WeakRetained + 19) == v7)
  {
    if ((a2 - 1) <= 1)
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC898, 0LL))
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        _NRLogWithArgs(qword_1001DC898, 0LL, "%s%.30s:%-4d MASQUE server started %u");
      }

void sub_1000AC4F0(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6)
{
  id v17 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = a6;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v15 = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v16 = v15;
  if (WeakRetained && *((_BYTE *)WeakRetained + 12) && *((id *)WeakRetained + 19) == v15)
  {
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472LL;
    v18[2] = sub_1000ACBA8;
    v18[3] = &unk_1001AF000;
    id v19 = v12;
    id v20 = v17;
    uint64_t v23 = a2;
    id v21 = WeakRetained;
    id v22 = v11;
    nw_http_fields_access_value_by_name(v13, "Proxy-Usage-Token", v18);
  }
}

void sub_1000AC624(uint64_t a1, uint64_t a2, int a3)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v6 = objc_loadWeakRetained((id *)(a1 + 40));
  id v7 = v6;
  if (!WeakRetained || !*((_BYTE *)WeakRetained + 12) || *((id *)WeakRetained + 19) != v6) {
    goto LABEL_58;
  }
  switch(a3)
  {
    case 1:
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC898, 2LL))
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        _NRLogWithArgs( qword_1001DC898,  2LL,  "%s%.30s:%-4d proxy client connection received (id: %llu)",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke_3",  2258,  a2);
      }

      id v10 = (nw_connection_group *)nw_masque_server_copy_connection_group_with_identifier(v7, a2);
      if (!v10)
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC898, 17LL))
        {
          if (qword_1001DC8A0 != -1) {
            dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
          }
          _NRLogWithArgs(qword_1001DC898, 17LL, "failed to copy connection group (id: %llu)", a2);
          unsigned int v9 = 0LL;
        }

        else
        {
          unsigned int v9 = 0LL;
        }

        goto LABEL_57;
      }

      unsigned int v9 = v10;
      nw_parameters_t v11 = nw_connection_group_copy_parameters(v10);
      id v12 = (void *)nw_protocol_copy_quic_stream_definition();
      id v13 = (void *)nw_parameters_copy_protocol_options_for_definition(v11, v12);

      id v14 = (nw_protocol_options *)nw_quic_stream_copy_shared_connection_options(v13);
      id v15 = v14;
      if (v14)
      {
        uint64_t v16 = nw_quic_copy_sec_protocol_options(v14);
        if (v16)
        {
          id v17 = v16;
          sec_protocol_options_set_peer_authentication_required(v16, 1);
          if ([*((id *)WeakRetained + 41) count])
          {
            id v18 = (void *)objc_claimAutoreleasedReturnValue([*((id *)WeakRetained + 41) allValues]);

            sec_protocol_options_set_client_raw_public_key_certificates(v17, v18);
          }

          nw_quic_connection_set_sec_protocol_options(v15, v17);
        }

        else
        {
          id v23 = sub_1000A2100();
          int IsLevelEnabled = _NRLogIsLevelEnabled(v23, 16LL);

          if (IsLevelEnabled)
          {
            id v25 = sub_1000A2100();
            _NRLogWithArgs( v25,  16LL,  "%s%.30s:%-4d no QUIC sec options",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke_3",  2280);
          }

          id v17 = 0LL;
        }
      }

      else
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        id v17 = sub_1000A2100();
        _NRLogWithArgs( v17,  16LL,  "%s%.30s:%-4d no QUIC options",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke_3",  2283);
      }

LABEL_56:
      goto LABEL_57;
    case 3:
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC898, 2LL))
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        _NRLogWithArgs( qword_1001DC898,  2LL,  "%s%.30s:%-4d proxy client connection cancelled (id: %llu)",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke_3",  2250,  a2);
      }

      id v19 = *((id *)WeakRetained + 20);
      id v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a2));
      id v21 = (void *)objc_claimAutoreleasedReturnValue([v19 objectForKeyedSubscript:v20]);

      if (v21)
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC898, 2LL))
        {
          if (qword_1001DC8A0 != -1) {
            dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
          }
          _NRLogWithArgs( qword_1001DC898,  2LL,  "%s%.30s:%-4d removing cached token (id: %llu)",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke_3",  2252,  a2);
        }
      }

      id v22 = *((id *)WeakRetained + 20);
      unsigned int v9 = (nw_connection_group *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  a2));
      [v22 setObject:0 forKeyedSubscript:v9];

      goto LABEL_57;
    case 2:
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC898, 2LL))
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        _NRLogWithArgs( qword_1001DC898,  2LL,  "%s%.30s:%-4d proxy client connection started (id: %llu)",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke_3",  2245,  a2);
      }

      if (!*((void *)WeakRetained + 20))
      {
        uint64_t v8 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        unsigned int v9 = (nw_connection_group *)*((void *)WeakRetained + 20);
        *((void *)WeakRetained + 20) = v8;
LABEL_57:
      }

      break;
  }

void sub_1000ACBA8(uint64_t a1, char *__s)
{
  if (__s)
  {
    size_t v4 = strlen(__s);
    dispatch_data_t v5 = dispatch_data_create(__s, v4, 0LL, 0LL);
    id v6 = (void *)dispatch_data_create_with_transform( v5,  &_dispatch_data_format_type_base64,  &_dispatch_data_format_type_none);
    uint64_t v56 = 0LL;
    __int128 v57 = &v56;
    uint64_t v58 = 0x3032000000LL;
    id v59 = sub_1000AB748;
    uint64_t v60 = sub_1000AB758;
    id v61 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    v51[0] = _NSConcreteStackBlock;
    v51[1] = 3221225472LL;
    v51[2] = sub_1000AD2C4;
    v51[3] = &unk_1001AEFD8;
    id v52 = *(id *)(a1 + 32);
    id v7 = *(id *)(a1 + 40);
    uint64_t v8 = *(void *)(a1 + 64);
    __int128 v54 = &v56;
    uint64_t v55 = v8;
    id v53 = v7;
    NRTLVParse(v6, v51);
    if ([(id)v57[5] count])
    {
      unsigned int v9 = *(void **)(a1 + 48);
      if (v9) {
        unsigned int v9 = (void *)v9[20];
      }
      uint64_t v10 = v57[5];
      nw_parameters_t v11 = v9;
      id v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *(void *)(a1 + 64)));
      [v11 setObject:v10 forKeyedSubscript:v12];

      id v13 = (id)v57[5];
    }

    else
    {
      id v13 = 0LL;
    }

    _Block_object_dispose(&v56, 8);
  }

  else
  {
    id v14 = *(void **)(a1 + 48);
    if (v14) {
      id v14 = (void *)v14[20];
    }
    uint64_t v15 = *(void *)(a1 + 64);
    uint64_t v16 = v14;
    id v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v15));
    id v18 = (void *)objc_claimAutoreleasedReturnValue([v16 objectForKeyedSubscript:v17]);

    if (!v18)
    {
      id v13 = 0LL;
LABEL_58:
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC898, 1LL))
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        _NRLogWithArgs( qword_1001DC898,  1LL,  "%s%.30s:%-4d no token from %@ for %@ (id: %llu)",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke_2",  2201LL,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  *(void *)(a1 + 64));
      }

      goto LABEL_64;
    }

    id v19 = *(void **)(a1 + 48);
    if (v19) {
      id v19 = (void *)v19[20];
    }
    uint64_t v20 = *(void *)(a1 + 64);
    id v21 = v19;
    id v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v20));
    id v13 = (id)objc_claimAutoreleasedReturnValue([v21 objectForKeyedSubscript:v22]);

    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC898, 1LL))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      _NRLogWithArgs( qword_1001DC898,  1LL,  "%s%.30s:%-4d using cached tokensfrom %@ for %@ (id: %llu)",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke_2",  2197LL,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  *(void *)(a1 + 64));
    }
  }

  if (!v13 || ![v13 count]) {
    goto LABEL_58;
  }
  __int128 v49 = 0u;
  __int128 v50 = 0u;
  __int128 v47 = 0u;
  __int128 v48 = 0u;
  id v13 = v13;
  id v23 = [v13 countByEnumeratingWithState:&v47 objects:v62 count:16];
  if (v23)
  {
    uint64_t v24 = *(void *)v48;
    do
    {
      for (uint64_t i = 0LL; i != v23; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v48 != v24) {
          objc_enumerationMutation(v13);
        }
        uint64_t v26 = *(void *)(*((void *)&v47 + 1) + 8LL * (void)i);
        if (v26 && *(_BYTE *)(v26 + 8) == 1)
        {
          int v27 = *(unsigned __int8 *)(v26 + 9);
          if (v27 == 52)
          {
            id v33 = *(id *)(v26 + 16);
            BOOL v34 = v33 == 0LL;

            if (!v34)
            {
              unsigned int v35 = objc_alloc(&OBJC_CLASS___NSString);
              id v36 = *(id *)(v26 + 16);
              id v32 = -[NSString initWithData:encoding:](v35, "initWithData:encoding:", v36, 4LL);

              if (v32)
              {
                if (qword_1001DC8A0 != -1) {
                  dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
                }
                if (_NRLogIsLevelEnabled(qword_1001DC898, 1LL))
                {
                  if (qword_1001DC8A0 != -1) {
                    dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
                  }
                  _NRLogWithArgs( qword_1001DC898,  1LL,  "%s%.30s:%-4d setting bundle id %@",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke_2",  2219LL,  v32);
                }

                nw_parameters_set_source_application_by_external_bundle_id( *(void *)(a1 + 56),  -[NSString UTF8String](v32, "UTF8String"));
              }

              goto LABEL_24;
            }
          }

          else if (v27 == 51)
          {
            id v28 = *(id *)(v26 + 16);
            BOOL v29 = v28 == 0LL;

            if (!v29)
            {
              id v30 = objc_alloc(&OBJC_CLASS___NSString);
              id v31 = *(id *)(v26 + 16);
              id v32 = -[NSString initWithData:encoding:](v30, "initWithData:encoding:", v31, 4LL);

              if (v32)
              {
                if (qword_1001DC8A0 != -1) {
                  dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
                }
                if (_NRLogIsLevelEnabled(qword_1001DC898, 1LL))
                {
                  if (qword_1001DC8A0 != -1) {
                    dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
                  }
                  _NRLogWithArgs( qword_1001DC898,  1LL,  "%s%.30s:%-4d setting account id %@",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke_2",  2211LL,  v32);
                }

                nw_parameters_set_account_id(*(void *)(a1 + 56), -[NSString UTF8String](v32, "UTF8String"));
              }

void sub_1000AD2A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

uint64_t sub_1000AD2C4(void *a1, uint64_t a2)
{
  size_t v4 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  a2 + 3,  bswap32(*(unsigned __int16 *)(a2 + 1)) >> 16);
  dispatch_data_t v5 = v4;
  if (*(_BYTE *)a2 == 8)
  {
    id v6 = v4;
    objc_opt_self(&OBJC_CLASS___NRToken);
    if (-[NSData length](v6, "length"))
    {
      uint64_t v25 = 0LL;
      uint64_t v26 = &v25;
      uint64_t v27 = 0x2020000000LL;
      char v28 = 0;
      uint64_t v21 = 0LL;
      id v22 = &v21;
      uint64_t v23 = 0x2020000000LL;
      char v24 = 0;
      uint64_t v15 = 0LL;
      uint64_t v16 = &v15;
      uint64_t v17 = 0x3032000000LL;
      id v18 = sub_1000024BC;
      id v19 = sub_1000024CC;
      id v20 = 0LL;
      uint64_t v11 = 0LL;
      id v12 = &v11;
      uint64_t v13 = 0x2020000000LL;
      char v14 = 50;
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 3221225472LL;
      v10[2] = sub_1000024D4;
      v10[3] = &unk_1001ADD08;
      v10[4] = &v25;
      v10[5] = &v21;
      v10[6] = &v15;
      v10[7] = &v11;
      NRTLVParse(v6, v10);
      if (*((_BYTE *)v26 + 24))
      {
        id v7 = 0LL;
      }

      else
      {
        uint64_t v8 = objc_alloc(&OBJC_CLASS___NRToken);
        id v7 = sub_100002254((id *)&v8->super.isa, *((_BYTE *)v22 + 24), *((_BYTE *)v12 + 24), (void *)v16[5]);
      }

      _Block_object_dispose(&v11, 8);
      _Block_object_dispose(&v15, 8);

      _Block_object_dispose(&v21, 8);
      _Block_object_dispose(&v25, 8);

      if (v7 && *((_BYTE *)v7 + 8))
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC898, 1LL))
        {
          if (qword_1001DC8A0 != -1) {
            dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
          }
          _NRLogWithArgs( qword_1001DC898,  1LL,  "%s%.30s:%-4d received token %@ from %@ for %@ (id: %llu)",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke",  2185LL,  v7,  a1[4],  a1[5],  a1[7]);
        }

        [*(id *)(*(void *)(a1[6] + 8) + 40) addObject:v7];
      }
    }

    else
    {

      id v7 = 0LL;
    }
  }

  return 1LL;
}

void sub_1000AD550( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, char a29)
{
}

uint64_t sub_1000AD590(uint64_t a1)
{
  return sub_1000A8B9C(*(void *)(a1 + 32));
}

void sub_1000AD598(uint64_t a1, int a2, void *a3)
{
  dispatch_data_t v5 = a3;
  if ((a2 - 1) <= 1)
  {
LABEL_2:
    uint64_t v6 = *(void *)(a1 + 32);
    if (v6) {
      *(_BYTE *)(v6 + 13) = 0;
    }
    goto LABEL_22;
  }

  if (a2 != 3) {
    goto LABEL_22;
  }
  sub_1000A441C(*(void *)(a1 + 32));
  if (!v5 || nw_error_get_error_domain(v5) != nw_error_domain_posix || nw_error_get_error_code(v5) != 48)
  {
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC898, 17LL))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      _NRLogWithArgs(qword_1001DC898, 17LL, "failed to start proxy server with error %@", v5);
    }

    goto LABEL_2;
  }

  uint64_t v7 = *(void *)(a1 + 32);
  if (v7)
  {
    unsigned int v8 = *(unsigned __int8 *)(v7 + 13);
    if (v8 > 4)
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC898, 17LL))
      {
        id v17 = sub_1000A2100();
        id v18 = v17;
        uint64_t v19 = *(void *)(a1 + 32);
        if (v19) {
          LODWORD(v19) = *(unsigned __int8 *)(v19 + 13);
        }
        _NRLogWithArgs(v17, 17LL, "failed to start proxy server after %u address in use retries", v19);
      }

      goto LABEL_2;
    }

    *(_BYTE *)(v7 + 13) = v8 + 1;
  }

  if (qword_1001DC8A0 != -1) {
    dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC898, 16LL))
  {
    id v9 = sub_1000A2100();
    uint64_t v10 = v9;
    uint64_t v11 = *(void *)(a1 + 32);
    if (v11) {
      LODWORD(v11) = *(unsigned __int8 *)(v11 + 13);
    }
    _NRLogWithArgs( v9,  16LL,  "%s%.30s:%-4d scheduling address in use retry %u",  "",  "-[NRLinkDirector startSocksServerIfNeeded]_block_invoke",  1853,  v11);
  }

  uint64_t v12 = *(void *)(a1 + 32);
  if (v12) {
    int64_t v13 = 200000000LL * *(unsigned __int8 *)(v12 + 13);
  }
  else {
    int64_t v13 = 0LL;
  }
  dispatch_time_t v14 = dispatch_time(0x8000000000000000LL, v13);
  uint64_t v15 = *(void *)(a1 + 32);
  if (v15) {
    uint64_t v16 = *(dispatch_queue_s **)(v15 + 136);
  }
  else {
    uint64_t v16 = 0LL;
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1000AD910;
  block[3] = &unk_1001B0A88;
  void block[4] = v15;
  dispatch_after(v14, v16, block);
LABEL_22:
}

void sub_1000AD824(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  int v3 = WeakRetained;
  if (WeakRetained)
  {
    if (*((void *)WeakRetained + 21) == *(void *)(a1 + 32))
    {
      uint64_t v13 = 0LL;
      id v4 = *((id *)WeakRetained + 18);
      if (v4)
      {
        dispatch_data_t v5 = v4;
        int v6 = nw_shoes_server_fillout_statistics(v3[18], &v13, 8LL, 1LL);

        if (v6)
        {
          uint64_t v7 = objc_alloc_init(&OBJC_CLASS___NRAnalyticsSHOESProxy);
          unsigned int v8 = (void *)v3[22];
          v3[22] = v7;

          uint64_t v9 = v3[22];
          if (v9 && (*(void *)(v9 + 24) = v13, (uint64_t v10 = v3[22]) != 0))
          {
            *(void *)(v10 + 16) = HIDWORD(v13);
            uint64_t v11 = (void *)v3[22];
          }

          else
          {
            uint64_t v11 = 0LL;
          }

          [v11 submit];
          uint64_t v12 = (void *)v3[22];
          v3[22] = 0LL;
        }
      }
    }
  }
}

uint64_t sub_1000AD910(uint64_t a1)
{
  return sub_1000A8298(*(void *)(a1 + 32));
}

void sub_1000AD918(id a1)
{
  if (qword_1001DC8A0 != -1) {
    dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
  }
  uint64_t IsLevelEnabled = _NRLogIsLevelEnabled(qword_1001DC898, 0LL);
  if ((_DWORD)IsLevelEnabled)
  {
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    uint64_t IsLevelEnabled = _NRLogWithArgs( qword_1001DC898,  0LL,  "%s%.30s:%-4d Force clearing nehelper uuid cache",  "",  "-[NRLinkDirector checkEnabledDevices]_block_invoke",  842);
  }

  NEHelperCacheClearUUIDs(IsLevelEnabled);
}

void sub_1000AD9C8(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 320);
  *(void *)(a1 + 320) = 0LL;

  int v3 = *(void **)(a1 + 104);
  *(void *)(a1 + 104) = 0LL;

  id v4 = *(id *)(a1 + 120);
  if (v4 || (id v4 = *(id *)(a1 + 112)) != 0LL)
  {
  }

  else
  {
    int v6 = *(void **)(a1 + 128);
    if (!v6) {
      goto LABEL_7;
    }
  }

  objc_opt_self(&OBJC_CLASS___NRDKeyManager);
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  id v5 = (id)qword_1001DCC10;
  sub_100144A74((uint64_t)v5);

  int v6 = *(void **)(a1 + 128);
LABEL_7:
  *(void *)(a1 + 12_Block_object_dispose((const void *)(v29 - 80), 8) = 0LL;

  uint64_t v7 = *(void **)(a1 + 120);
  *(void *)(a1 + 120) = 0LL;

  unsigned int v8 = *(void **)(a1 + 112);
  *(void *)(a1 + 112) = 0LL;
}

void sub_1000ADA90(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1 && *(_BYTE *)(v1 + 12))
  {
    id v3 = *(id *)(v1 + 72);
    if (v3)
    {
      uint64_t v4 = *(void *)(a1 + 32);
      if (v4)
      {
        uint64_t v5 = *(void *)(v4 + 80);

        if (v5) {
          return;
        }
      }

      else
      {
      }
    }

    sub_1000ADF28(*(void *)(a1 + 32));
  }

void sub_1000ADAF0(uint64_t a1)
{
  if (!*(void *)(a1 + 64))
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472LL;
    v3[2] = sub_1000AE9EC;
    v3[3] = &unk_1001B0A88;
    v3[4] = a1;
    uint64_t v1 = objc_retainBlock(v3);
    if (qword_1001DC9B8 != -1) {
      dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
    }
    if (byte_1001DC9B0)
    {
      ((void (*)(void *))v1[2])(v1);
    }

    else
    {
      objc_opt_self(&OBJC_CLASS___NRDKeyManager);
      if (qword_1001DCC18 != -1) {
        dispatch_once(&qword_1001DCC18, &stru_1001B0910);
      }
      id v2 = (id)qword_1001DCC10;
      sub_100144478((uint64_t)v2, v1);
    }
  }

void sub_1000ADBEC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 && *(_BYTE *)(v2 + 12))
  {
    sub_1000ADF28(v2);
    if (qword_1001DC9B8 != -1) {
      dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
    }
    if (byte_1001DC9B0)
    {
      id v14 = sub_1000A2100();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v14, 0LL);

      if (IsLevelEnabled)
      {
        uint64_t v16 = (dispatch_queue_s *)sub_1000A2100();
        uint64_t v28 = 525LL;
        id v17 = "%s%.30s:%-4d Skipping initialization of NRLinkManagerQuickRelay for unsupported device";
LABEL_23:
        dispatch_queue_t queue = v16;
        _NRLogWithArgs(v16, 0LL, v17, "", "-[NRLinkDirector setupManagers]_block_invoke_2", v28);
LABEL_18:
      }
    }

    else
    {
      objc_opt_self(&OBJC_CLASS___NRLinkManagerQuickRelay);
      if (objc_opt_class(&OBJC_CLASS___IDSService) && objc_opt_class(&OBJC_CLASS___APSConnection))
      {
        id v3 = objc_alloc(&OBJC_CLASS___NRLinkManagerQuickRelay);
        uint64_t v4 = *(void **)(a1 + 32);
        if (v4) {
          uint64_t v4 = (void *)v4[17];
        }
        uint64_t v5 = v4;
        int v6 = *(void **)(a1 + 32);
        dispatch_queue_t queue = v5;
        id v7 = v6;
        if (!v3) {
          goto LABEL_33;
        }
        if (queue)
        {
          dispatch_assert_queue_V2(queue);
          if (v7)
          {
            v30.receiver = v3;
            v30.super_class = (Class)&OBJC_CLASS___NRLinkManagerQuickRelay;
            unsigned int v8 = objc_msgSendSuper2(&v30, "initManagerWithQueue:managerDelegate:", queue, v7);
            if (v8)
            {
              id v9 = v8;
              v8[8] = 4;
              uint64_t v10 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
              uint64_t v11 = (void *)*((void *)v9 + 5);
              *((void *)v9 + 5) = v10;

              objc_storeWeak((id *)v9 + 9, v7);
              [v9 reportEvent:2001];
              sub_1000FA2A8((__objc2_meth_list **)v9);
              *((_DWORD *)v9 + 3) = 1003;
              [v9 reportEvent:2002];
              id v3 = (NRLinkManagerQuickRelay *)v9;
              uint64_t v12 = v3;
LABEL_15:

              uint64_t v13 = *(void *)(a1 + 32);
              if (v13) {
                objc_storeStrong((id *)(v13 + 56), v12);
              }

              goto LABEL_18;
            }

            id v25 = sub_1000F9A88();
            int v26 = _NRLogIsLevelEnabled(v25, 17LL);

            if (v26)
            {
              id v27 = sub_1000F9A88();
              _NRLogWithArgs(v27, 17LL, "[NRLinkManager initManagerWithQueue:] failed");
            }

            id v3 = 0LL;
LABEL_33:
            uint64_t v12 = 0LL;
            goto LABEL_15;
          }

          id v23 = sub_1000F9A88();
          int v24 = _NRLogIsLevelEnabled(v23, 17LL);

          if (!v24) {
            goto LABEL_33;
          }
          id v22 = sub_1000F9A88();
          _NRLogWithArgs(v22, 17LL, "%s called with null managerDelegate");
        }

        else
        {
          id v20 = sub_1000F9A88();
          int v21 = _NRLogIsLevelEnabled(v20, 17LL);

          if (!v21) {
            goto LABEL_33;
          }
          id v22 = sub_1000F9A88();
          _NRLogWithArgs(v22, 17LL, "%s called with null queue");
        }

        uint64_t v12 = 0LL;
        goto LABEL_15;
      }

      id v18 = sub_1000A2100();
      int v19 = _NRLogIsLevelEnabled(v18, 0LL);

      if (v19)
      {
        uint64_t v16 = (dispatch_queue_s *)sub_1000A2100();
        uint64_t v28 = 522LL;
        id v17 = "%s%.30s:%-4d Skipping initialization of NRLinkManagerQuickRelay, IDS and/or APS not available";
        goto LABEL_23;
      }
    }
  }

void sub_1000ADF28(uint64_t a1)
{
  if (a1)
  {
    objc_opt_self(&OBJC_CLASS___NRLinkManagerWiFi);
    if (qword_1001DC9B8 != -1) {
      dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
    }
    if (!byte_1001DC9B0 && qword_1001DCBE8 != -1) {
      dispatch_once(&qword_1001DCBE8, &stru_1001B06F8);
    }
    if (byte_1001DCBE0 == 1)
    {
      if (!*(_BYTE *)(a1 + 17))
      {
        *(_BYTE *)(a1 + 17) = 1;
        sub_1000AE050((id *)a1, 1);
      }
    }

    else
    {
      id v2 = sub_1000A2100();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v2, 0LL);

      if (IsLevelEnabled)
      {
        id v4 = sub_1000A2100();
        _NRLogWithArgs( v4,  0LL,  "%s%.30s:%-4d Skipping initialization of NRLinkManagerWiFi for unsupported device",  "",  "-[NRLinkDirector setupWiFiManager]",  567);
      }
    }
  }

void sub_1000AE050(id *a1, int a2)
{
  id v4 = objc_alloc(&OBJC_CLASS___NRLinkManagerWiFi);
  uint64_t v5 = (dispatch_queue_s *)a1[17];
  int v6 = a1;
  if (!v4)
  {
LABEL_43:
    BOOL v34 = 0LL;
    goto LABEL_30;
  }

  if (!v5)
  {
    id v43 = sub_10013A600();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v43, 17LL);

    if (IsLevelEnabled)
    {
      id v45 = sub_10013A600();
      _NRLogWithArgs( v45,  17LL,  "%s called with null queue",  "-[NRLinkManagerWiFi initManagerWithQueue:managerDelegate:wifiManagerDelegate:]");

      BOOL v34 = 0LL;
      goto LABEL_30;
    }

    goto LABEL_43;
  }

  dispatch_assert_queue_V2(v5);
  v67.receiver = v4;
  v67.super_class = (Class)&OBJC_CLASS___NRLinkManagerWiFi;
  id v7 = (NRLinkManagerWiFi *)objc_msgSendSuper2(&v67, "initManagerWithQueue:managerDelegate:", v5, v6);
  if (!v7)
  {
    id v49 = sub_10013A600();
    int v50 = _NRLogIsLevelEnabled(v49, 17LL);

    if (v50)
    {
      id v51 = sub_10013A600();
      _NRLogWithArgs(v51, 17LL, "[NRLinkManager initManagerWithQueue:] failed");
    }

    id v4 = 0LL;
    goto LABEL_43;
  }

  id v4 = v7;
  objc_storeWeak((id *)&v7->_wifiManagerDelegate, v6);
  v4->super._type = 2;
  unsigned int v8 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
  links = v4->_links;
  v4->_links = v8;

  uint64_t v10 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
  wifiAutojoinClients = v4->_wifiAutojoinClients;
  v4->_wifiAutojoinClients = v10;

  v4->_avoidCompanionNotifyToken = -1;
  uint64_t v12 = v4->super._queue;
  dispatch_assert_queue_V2(v12);

  if (v4->super._state == 1003)
  {
LABEL_29:
    id v4 = v4;
    BOOL v34 = v4;
    goto LABEL_30;
  }

  -[NRLinkManager reportEvent:](v4, "reportEvent:", 2001LL);
  uint64_t v13 = objc_alloc_init(&OBJC_CLASS___CWFInterface);
  coreWiFiHandle = v4->_coreWiFiHandle;
  v4->_coreWiFiHandle = v13;

  uint64_t v15 = v4->_coreWiFiHandle;
  v77[0] = _NSConcreteStackBlock;
  v77[1] = 3221225472LL;
  v77[2] = sub_10013D088;
  void v77[3] = &unk_1001B0A88;
  uint64_t v16 = v15;
  __int128 v78 = v16;
  if (!sub_10013D090((uint64_t)&OBJC_CLASS___NRLinkManagerWiFi, v77))
  {
    uint64_t v71 = 0LL;
    id v72 = &v71;
    uint64_t v73 = 0x3032000000LL;
    id v74 = sub_10013D160;
    id v75 = sub_10013D170;
    id v76 = 0LL;
    v68[0] = _NSConcreteStackBlock;
    v68[1] = 3221225472LL;
    v68[2] = sub_10013D178;
    v68[3] = &unk_1001B07E8;
    id v70 = &v71;
    id v17 = v16;
    id v69 = v17;
    if (sub_10013D090((uint64_t)&OBJC_CLASS___NRLinkManagerWiFi, v68))
    {
      id v55 = sub_10013A600();
      char v56 = _NRLogIsLevelEnabled(v55, 16LL);

      if ((v56 & 1) == 0) {
        goto LABEL_27;
      }
      id v31 = sub_10013A600();
      _NRLogWithArgs( v31,  16LL,  "%s%.30s:%-4d Timed out getting WiFi interface name",  "",  "-[NRLinkManagerWiFi setupWiFiManager]",  2156);
    }

    else if (v72[5])
    {
      id v18 = objc_alloc(&OBJC_CLASS___NRSCDInterfaceConfig);
      int v19 = sub_10001DAD4((id *)&v18->super.isa, (void *)v72[5], 0);
      wifiInterfaceConfig = v4->_wifiInterfaceConfig;
      v4->_wifiInterfaceConfig = (NRSCDInterfaceConfig *)v19;

      int v21 = v4->_wifiInterfaceConfig;
      if (v21 && (unsigned int interfaceIndex = v21->_interfaceIndex, v21, interfaceIndex))
      {
        context.version = 0LL;
        memset(&context.retain, 0, 24);
        context.info = v4;
        SCDynamicStoreRef v23 = SCDynamicStoreCreate( kCFAllocatorDefault,  @"NRLinkManagerWiFi",  (SCDynamicStoreCallBack)sub_10013D1B0,  &context);
        v4->_scdynamicStoreRef = v23;
        if (v23)
        {
          if (SCDynamicStoreSetDisconnectCallBack(v23, sub_10013D1FC))
          {
            scdKeyMIS = v4->_scdKeyMIS;
            v4->_scdKeyMIS = (NSString *)@"com.apple.MobileInternetSharing";

            scdynamicStoreRef = v4->_scdynamicStoreRef;
            int v26 = v4->super._queue;
            LODWORD(scdynamicStoreRef) = SCDynamicStoreSetDispatchQueue(scdynamicStoreRef, v26);

            if ((_DWORD)scdynamicStoreRef)
            {
              id v27 = v4->super._queue;
              block[0] = _NSConcreteStackBlock;
              block[1] = 3221225472LL;
              block[2] = sub_10013D2BC;
              block[3] = &unk_1001B0A88;
              void block[4] = v4;
              dispatch_async(v27, block);

              v4->super._state = 1003;
              -[NRLinkManager reportEvent:](v4, "reportEvent:", 2002LL);
              char v28 = 1;
              goto LABEL_28;
            }

            id v62 = sub_10013A600();
            int v63 = _NRLogIsLevelEnabled(v62, 17LL);

            if (!v63)
            {
LABEL_27:
              char v28 = 0;
LABEL_28:

              _Block_object_dispose(&v71, 8);
              if ((v28 & 1) != 0) {
                goto LABEL_29;
              }
              goto LABEL_47;
            }

            id v31 = sub_10013A600();
            CFErrorRef Error = SCCopyLastError();
            _NRLogWithArgs(v31, 17LL, "SCDynamicStoreSetDispatchQueue failed: %@", Error);
          }

          else
          {
            id v60 = sub_10013A600();
            int v61 = _NRLogIsLevelEnabled(v60, 17LL);

            if (!v61) {
              goto LABEL_27;
            }
            id v31 = sub_10013A600();
            CFErrorRef Error = SCCopyLastError();
            _NRLogWithArgs(v31, 17LL, "SCDynamicStoreSetDisconnectCallBack failed: %@", Error);
          }
        }

        else
        {
          id v57 = sub_10013A600();
          int v58 = _NRLogIsLevelEnabled(v57, 17LL);

          if (!v58) {
            goto LABEL_27;
          }
          id v31 = sub_10013A600();
          CFErrorRef Error = SCCopyLastError();
          _NRLogWithArgs(v31, 17LL, "SCDynamicStoreCreate failed: %@", Error);
        }
      }

      else
      {
        if (qword_1001DCBF8 != -1) {
          dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
        }
        id v32 = (id)qword_1001DCBF0;
        int v33 = _NRLogIsLevelEnabled(v32, 17LL);

        if (!v33) {
          goto LABEL_27;
        }
        if (qword_1001DCBF8 != -1) {
          dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
        }
        id v31 = (id)qword_1001DCBF0;
        _NRLogWithArgs(v31, 17LL, "failed to find interface index for %@", v72[5]);
      }
    }

    else
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      id v29 = (id)qword_1001DCBF0;
      int v30 = _NRLogIsLevelEnabled(v29, 16LL);

      if (!v30) {
        goto LABEL_27;
      }
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      id v31 = (id)qword_1001DCBF0;
      _NRLogWithArgs( v31,  16LL,  "%s%.30s:%-4d [CWFInterface interfaceName] failed",  "",  "-[NRLinkManagerWiFi setupWiFiManager]",  2161);
    }

    goto LABEL_27;
  }

  id v52 = sub_10013A600();
  int v53 = _NRLogIsLevelEnabled(v52, 16LL);

  if (v53)
  {
    id v54 = sub_10013A600();
    _NRLogWithArgs( v54,  16LL,  "%s%.30s:%-4d Timed out activating CoreWiFi handle",  "",  "-[NRLinkManagerWiFi setupWiFiManager]",  2147);
  }

LABEL_47:
  -[NRLinkManagerWiFi invalidateManager](v4, "invalidateManager");
  BOOL v34 = 0LL;
LABEL_30:

  id v35 = v6[6];
  v6[6] = v34;

  id v41 = (id *)v6[6];
  if (v41)
  {
    sub_100143448(v41);
    if (v6[31])
    {
      id v42 = (dispatch_queue_s *)a1[17];
      v66[0] = _NSConcreteStackBlock;
      v66[1] = 3221225472LL;
      v66[2] = sub_1000AE898;
      v66[3] = &unk_1001B0A88;
      v66[4] = v6;
      dispatch_async(v42, v66);
    }
  }

  else
  {
    else {
      uint64_t v46 = (2 * a2);
    }
    sub_1000A2084((uint64_t)v6, 1047, @"WiFi - Retry in %us (attempt: %u)", v36, v37, v38, v39, v40, v46);
    dispatch_time_t v47 = dispatch_time(0LL, 1000000000LL * v46);
    __int128 v48 = (dispatch_queue_s *)a1[17];
    v64[0] = _NSConcreteStackBlock;
    v64[1] = 3221225472LL;
    v64[2] = sub_1000AE9C8;
    v64[3] = &unk_1001AEF20;
    v64[4] = v6;
    int v65 = a2;
    dispatch_after(v47, v48, v64);
  }

void sub_1000AE880( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31)
{
}

void sub_1000AE898(uint64_t a1)
{
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  id v2 = *(void **)(a1 + 32);
  if (v2) {
    id v2 = (void *)v2[31];
  }
  id v3 = v2;
  id v4 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v13;
    do
    {
      id v7 = 0LL;
      do
      {
        if (*(void *)v13 != v6) {
          objc_enumerationMutation(v3);
        }
        (*(void (**)(void))(*(void *)(*((void *)&v12 + 1) + 8LL * (void)v7) + 16LL))(*(void *)(*((void *)&v12 + 1) + 8LL * (void)v7));
        id v7 = (char *)v7 + 1;
      }

      while (v5 != v7);
      id v5 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
    }

    while (v5);
  }

  uint64_t v8 = *(void *)(a1 + 32);
  if (v8) {
    id v9 = *(void **)(v8 + 248);
  }
  else {
    id v9 = 0LL;
  }
  objc_msgSend(v9, "removeAllObjects", (void)v12);
  uint64_t v10 = *(void *)(a1 + 32);
  if (v10)
  {
    uint64_t v11 = *(void **)(v10 + 248);
    *(void *)(v10 + 24_Block_object_dispose((const void *)(v29 - 80), 8) = 0LL;
  }

uint64_t sub_1000AE9C8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    if (*(_BYTE *)(result + 12)) {
      return sub_1000AE050();
    }
  }

  return result;
}

void sub_1000AE9EC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1 && *(_BYTE *)(v1 + 12))
  {
    id v3 = objc_alloc(&OBJC_CLASS___NRLinkManagerWired);
    id v4 = *(void **)(a1 + 32);
    if (v4) {
      id v4 = (void *)v4[17];
    }
    id v7 = v4;
    id v5 = -[NRLinkManagerWired initManagerWithQueue:managerDelegate:](v3, "initManagerWithQueue:managerDelegate:");
    uint64_t v6 = *(void *)(a1 + 32);
    if (v6) {
      objc_storeStrong((id *)(v6 + 64), v5);
    }
  }

void sub_1000AEA84(uint64_t a1, void *a2)
{
  id v22 = a2;
  if (a1)
  {
    id v3 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v3);

    if (v22)
    {
      id v4 = *(id *)(a1 + 48);
      if (v4)
      {

        id v5 = v22;
LABEL_14:
        v5[2]();
        goto LABEL_15;
      }

      objc_opt_self(&OBJC_CLASS___NRLinkManagerWiFi);
      if (qword_1001DC9B8 != -1) {
        dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
      }
      id v5 = v22;
      if (!byte_1001DC9B0 && qword_1001DCBE8 != -1)
      {
        dispatch_once(&qword_1001DCBE8, &stru_1001B06F8);
        id v5 = v22;
      }

      if ((byte_1001DCBE0 & 1) == 0) {
        goto LABEL_14;
      }
      uint64_t v6 = *(void **)(a1 + 248);
      if (!v6)
      {
        id v7 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        uint64_t v8 = *(void **)(a1 + 248);
        *(void *)(a1 + 24_Block_object_dispose((const void *)(v29 - 80), 8) = v7;

        uint64_t v6 = *(void **)(a1 + 248);
        if (!v6)
        {
          id v14 = sub_1000A2100();
          int IsLevelEnabled = _NRLogIsLevelEnabled(v14, 16LL);

          if (IsLevelEnabled)
          {
            id v16 = sub_1000A2100();
            _NRLogWithArgs( v16,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (self.wifiManagerAvailableBlocks) != ((void *)0)",  "",  "-[NRLinkDirector runAfterWiFiManagerAvailable:]",  617);
          }

          uint64_t v17 = _os_log_pack_size(12LL);
          id v18 = (char *)&v22 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          int v19 = __error();
          uint64_t v20 = _os_log_pack_fill( v18,  v17,  *v19,  &_mh_execute_header,  "%{public}s Assertion Failed: (self.wifiManagerAvailableBlocks) != ((void *)0)");
          *(_DWORD *)uint64_t v20 = 136446210;
          *(void *)(v20 + 4) = "-[NRLinkDirector runAfterWiFiManagerAvailable:]";
          id v21 = sub_1000A2100();
          _NRLogAbortWithPack(v21, v18);
        }
      }

      id v9 = v6;
      uint64_t v10 = objc_retainBlock(v22);
      [v9 addObject:v10];
    }

    else
    {
      id v11 = sub_1000A2100();
      int v12 = _NRLogIsLevelEnabled(v11, 17LL);

      if (v12)
      {
        id v13 = sub_1000A2100();
        _NRLogWithArgs( v13,  17LL,  "%s called with null wifiManagerAvailableBlock",  "-[NRLinkDirector runAfterWiFiManagerAvailable:]");
      }
    }
  }

void sub_1000AED0C(uint64_t a1, int a2, void *a3)
{
  id v15 = a3;
  uint64_t v6 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
  id v7 = (void *)v6;
  if (a2)
  {
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 1LL);

    if (IsLevelEnabled)
    {
      uint64_t v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v9);
      _NRLogWithArgs( v10,  1LL,  "%s%.30s:%-4d unpaired BT device %@",  "",  "-[NRLinkDirector unpairBluetoothDeviceWithNRUUID:completionBlock:]_block_invoke",  767LL,  v15);
    }

    sub_100138214((uint64_t)&OBJC_CLASS___NRDLocalDevice, 0LL, *(void **)(a1 + 32));
    id v11 = *(void (**)(void))(*(void *)(a1 + 40) + 16LL);
  }

  else
  {
    int v12 = _NRLogIsLevelEnabled(v6, 16LL);

    if (v12)
    {
      id v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v13);
      _NRLogWithArgs( v14,  16LL,  "%s%.30s:%-4d failed to unpair BT device",  "",  "-[NRLinkDirector unpairBluetoothDeviceWithNRUUID:completionBlock:]_block_invoke",  771);
    }

    id v11 = *(void (**)(void))(*(void *)(a1 + 40) + 16LL);
  }

  v11();
}

void sub_1000AEE40(uint64_t a1, int a2)
{
  if (a1)
  {
    char v2 = a2;
    if (a2) {
      int v4 = 10015;
    }
    else {
      int v4 = 10016;
    }
    sub_10011BB18(0LL, v4, 0LL, 0LL);
    __int128 v19 = 0u;
    __int128 v20 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    id v5 = *(id *)(a1 + 216);
    id v6 = [v5 countByEnumeratingWithState:&v17 objects:v21 count:16];
    if (v6)
    {
      id v7 = v6;
      uint64_t v8 = *(void *)v18;
      if ((v2 & 1) != 0)
      {
        do
        {
          for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v18 != v8) {
              objc_enumerationMutation(v5);
            }
            uint64_t v10 = objc_claimAutoreleasedReturnValue( objc_msgSend( *(id *)(a1 + 216),  "objectForKeyedSubscript:",  *(void *)(*((void *)&v17 + 1) + 8 * (void)i),  (void)v17));
            id v11 = (void *)v10;
            if (v10)
            {
              dispatch_assert_queue_V2(*(dispatch_queue_t *)(v10 + 104));
              id v12 = sub_1000D8B90((uint64_t)v11, 4, 0);
            }

            else
            {
              id v12 = 0LL;
            }
          }

          id v7 = [v5 countByEnumeratingWithState:&v17 objects:v21 count:16];
        }

        while (v7);
      }

      else
      {
        do
        {
          for (j = 0LL; j != v7; j = (char *)j + 1)
          {
            if (*(void *)v18 != v8) {
              objc_enumerationMutation(v5);
            }
            uint64_t v14 = objc_claimAutoreleasedReturnValue( objc_msgSend( *(id *)(a1 + 216),  "objectForKeyedSubscript:",  *(void *)(*((void *)&v17 + 1) + 8 * (void)j),  (void)v17));
            id v15 = (void *)v14;
            if (v14)
            {
              dispatch_assert_queue_V2(*(dispatch_queue_t *)(v14 + 104));
              id v16 = sub_1000D8B90((uint64_t)v15, 4, 0);
            }

            else
            {
              id v16 = 0LL;
            }
          }

          id v7 = [v5 countByEnumeratingWithState:&v17 objects:v21 count:16];
        }

        while (v7);
      }
    }
  }

void sub_1000AF07C(uint64_t a1, int a2, void *a3, void *a4, void *a5)
{
  id v16 = a3;
  id v9 = a4;
  id v10 = a5;
  if (a1)
  {
    if (a2)
    {
      if (v16 || v9 || v10)
      {
        sub_10009FCD0(0LL, @"FixedInterfaceName", v16);
        sub_10009FCD0(0LL, @"FixedInterfacePeerAddress", v9);
        sub_10009FCD0(0LL, @"FixedInterfacePeerIDSDeviceID", v10);
        sub_1000A2084( a1,  1027,  @"interface: %@, peer address: %@, peer IDSDeviceID: %@",  v11,  v12,  v13,  v14,  v15,  (uint64_t)v16);
      }

      else
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC898, 16LL))
        {
          if (qword_1001DC8A0 != -1) {
            dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
          }
          _NRLogWithArgs( qword_1001DC898,  16LL,  "%s%.30s:%-4d Cannot enable fixed-interface mode (interface: %@, peerAddress = %@)",  "",  "-[NRLinkDirector setFixedInterfaceModeWithEnabled:interfaceName:peerAddress:idsDeviceID:]",  1072LL,  0LL,  0LL);
        }
      }
    }

    else
    {
      sub_10009FF2C(0LL, @"FixedInterfaceName");
      sub_10009FF2C(0LL, @"FixedInterfacePeerAddress");
      sub_10009FF2C(0LL, @"FixedInterfacePeerIDSDeviceID");
      sub_10011BB18(0LL, 1028, 0LL, 0LL);
    }
  }
}

void sub_1000AF22C(uint64_t a1, void *a2, void *a3)
{
  id v16 = a2;
  id v6 = a3;
  if (a1)
  {
    id v7 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v7);

    if (v16)
    {
      uint64_t v8 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 216) objectForKeyedSubscript:v6]);
      if (v8)
      {
        uint64_t v9 = v8;
        id v10 = v16;
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v9 + 104));
        [*(id *)(v9 + 168) addObject:v10];
      }

      else
      {
        uint64_t v11 = objc_alloc_init(&OBJC_CLASS___NRDOrphanedConnection);
        p_Class isa = (id *)&v11->super.isa;
        if (v11)
        {
          objc_storeStrong((id *)&v11->_nrUUID, a3);
          objc_storeStrong(p_isa + 2, a2);
        }

        [*(id *)(a1 + 224) addObject:p_isa];
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([p_isa description]);
        sub_10011BB18(0LL, 1015, 0LL, v13);

        uint64_t v9 = 0LL;
      }
    }

    else
    {
      id v14 = sub_1000A2100();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v14, 17LL);

      if (!IsLevelEnabled) {
        goto LABEL_9;
      }
      uint64_t v9 = (uint64_t)sub_1000A2100();
      _NRLogWithArgs(v9, 17LL, "%s called with null connection", "-[NRLinkDirector addDeviceMonitorConnection:nrUUID:]");
    }
  }

void sub_1000AF38C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    int v4 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v4);

    if (v3)
    {
      __int128 v29 = 0u;
      __int128 v30 = 0u;
      __int128 v27 = 0u;
      __int128 v28 = 0u;
      id v5 = *(id *)(a1 + 216);
      id v6 = [v5 countByEnumeratingWithState:&v27 objects:v32 count:16];
      if (v6)
      {
        id v7 = v6;
        uint64_t v8 = *(void *)v28;
        do
        {
          for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v28 != v8) {
              objc_enumerationMutation(v5);
            }
            uint64_t v10 = objc_claimAutoreleasedReturnValue( [*(id *)(a1 + 216) objectForKeyedSubscript:*(void *)(*((void *)&v27 + 1) + 8 * (void)i)]);
            id v11 = v3;
            if (v10)
            {
              dispatch_assert_queue_V2(*(dispatch_queue_t *)(v10 + 104));
              [*(id *)(v10 + 176) removeObject:v11];
              if (![*(id *)(v10 + 176) count]) {
                sub_1000EF77C(v10, 0);
              }
            }
          }

          id v7 = [v5 countByEnumeratingWithState:&v27 objects:v32 count:16];
        }

        while (v7);
      }

      id v12 = [*(id *)(a1 + 232) copy];
      __int128 v23 = 0u;
      __int128 v24 = 0u;
      __int128 v25 = 0u;
      __int128 v26 = 0u;
      id v13 = v12;
      id v14 = [v13 countByEnumeratingWithState:&v23 objects:v31 count:16];
      if (v14)
      {
        id v15 = v14;
        uint64_t v16 = *(void *)v24;
        do
        {
          for (j = 0LL; j != v15; j = (char *)j + 1)
          {
            if (*(void *)v24 != v16) {
              objc_enumerationMutation(v13);
            }
            __int128 v18 = *(void **)(*((void *)&v23 + 1) + 8LL * (void)j);
            if (v18 && (id)v18[2] == v3)
            {
              [*(id *)(a1 + 232) removeObject:*(void *)(*((void *)&v23 + 1) + 8 * (void)j)];
              __int128 v19 = (void *)objc_claimAutoreleasedReturnValue([v18 description]);
              sub_10011BB18(0LL, 1024, 0LL, v19);
            }
          }

          id v15 = [v13 countByEnumeratingWithState:&v23 objects:v31 count:16];
        }

        while (v15);
      }
    }

    else
    {
      id v20 = sub_1000A2100();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v20, 17LL);

      if (IsLevelEnabled)
      {
        id v22 = sub_1000A2100();
        _NRLogWithArgs( v22,  17LL,  "%s called with null connection",  "-[NRLinkDirector removeDeviceSetupInProgressConnection:]");
      }
    }
  }
}

void sub_1000AF63C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v31 = a2;
  id v7 = a3;
  id v8 = a4;
  if (a1)
  {
    uint64_t v9 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v9);

    if (!v7)
    {
      id v27 = sub_1000A2100();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v27, 17LL);

      if (!IsLevelEnabled) {
        goto LABEL_25;
      }
      uint64_t v11 = (uint64_t)sub_1000A2100();
      _NRLogWithArgs(v11, 17LL, "%s called with null connection");
      goto LABEL_24;
    }

    if (!v8)
    {
      id v29 = sub_1000A2100();
      int v30 = _NRLogIsLevelEnabled(v29, 17LL);

      if (!v30) {
        goto LABEL_25;
      }
      uint64_t v11 = (uint64_t)sub_1000A2100();
      _NRLogWithArgs(v11, 17LL, "%s called with null nrUUID");
      goto LABEL_24;
    }

    uint64_t v10 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 216) objectForKeyedSubscript:v8]);
    if (!v10)
    {
      id v22 = objc_alloc_init(&OBJC_CLASS___NRDOrphanedConnection);
      p_Class isa = (id *)&v22->super.isa;
      if (v22)
      {
        objc_storeStrong((id *)&v22->_nrUUID, a4);
        objc_storeStrong(p_isa + 2, a3);
      }

      [*(id *)(a1 + 232) addObject:p_isa];
      __int128 v24 = (void *)objc_claimAutoreleasedReturnValue([p_isa description]);
      sub_10011BB18(0LL, 1022, 0LL, v24);

      uint64_t v11 = 0LL;
      goto LABEL_24;
    }

    uint64_t v11 = v10;
    id v12 = v31;
    id v13 = v7;
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v11 + 104));
    uint64_t v14 = *(void *)(v11 + 184);
    id v15 = v12;
    id v16 = v13;
    if (!v14)
    {
LABEL_19:

      if ([v15 linkType] == 1)
      {
        if ([v15 isNotEmpty])
        {
          uint64_t v26 = (*(void *)(v11 + 592) >> 1) & 1LL;
          v32[0] = _NSConcreteStackBlock;
          v32[1] = 3221225472LL;
          v32[2] = sub_1000DAC0C;
          v32[3] = &unk_1001AF538;
          char v33 = v26;
          void v32[4] = v11;
          sub_1000D8960(v11, 1, v26, v32);
        }

        else
        {
          sub_1000D90D8(v11, *(void **)(v11 + 616));
        }
      }

LABEL_24:
      goto LABEL_25;
    }

    __int128 v17 = *(dispatch_queue_s **)(v14 + 24);
    if (v17) {
      dispatch_assert_queue_V2(v17);
    }
    __int128 v18 = sub_10010EE08(v16);
    __int128 v19 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v14 + 32) objectForKeyedSubscript:v18]);

    sub_10010EC78(v14, v15, v18);
    if ([v15 isNotEmpty])
    {
      uint64_t pid = xpc_connection_get_pid((xpc_connection_t)v16);
      if ((int)pid < 1)
      {
LABEL_18:

        goto LABEL_19;
      }

      id v21 = sub_10010393C(pid, 0);
      sub_10010EA70(v14, v21);
    }

    else
    {
      if (!v19) {
        goto LABEL_18;
      }
      uint64_t v25 = xpc_connection_get_pid((xpc_connection_t)v16);
      id v21 = sub_10010393C(v25, 0);
      sub_10010EB74(v14, v21);
    }

    goto LABEL_18;
  }

void sub_1000AF930(uint64_t a1, void *a2, void *a3)
{
  id v9 = a2;
  id v5 = a3;
  if (a1)
  {
    id v6 = *(void **)(a1 + 328);
    if (!v6)
    {
      id v7 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      id v8 = *(void **)(a1 + 328);
      *(void *)(a1 + 32_Block_object_dispose((const void *)(v29 - 80), 8) = v7;

      id v6 = *(void **)(a1 + 328);
    }

    [v6 setObject:v9 forKeyedSubscript:v5];
  }
}

void sub_1000AF9A4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    if (v5)
    {
      id v7 = objc_alloc_init(&OBJC_CLASS___NRDEphemeralDevice);
      connection = (NSUUID *)v5[4];
      if (v7)
      {
        nrUUID = v7->super._nrUUID;
        v7->super._nrUUID = connection;

        uint64_t v10 = (OS_xpc_object *)v6;
        connection = (NSUUID *)v7->super._connection;
        v7->super._connection = v10;
      }

      [*(id *)(a1 + 240) addObject:v7];
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(-[NRDEphemeralDevice description](v7, "description"));
      sub_10011BB18(0LL, 1041, 0LL, v11);

      goto LABEL_23;
    }

    if ([*(id *)(a1 + 240) count])
    {
      id v12 = [*(id *)(a1 + 240) copy];
      __int128 v21 = 0u;
      __int128 v22 = 0u;
      __int128 v23 = 0u;
      __int128 v24 = 0u;
      id v7 = (NRDEphemeralDevice *)v12;
      id v13 = -[NRDEphemeralDevice countByEnumeratingWithState:objects:count:]( v7,  "countByEnumeratingWithState:objects:count:",  &v21,  v25,  16LL);
      if (!v13)
      {
LABEL_22:

LABEL_23:
        goto LABEL_24;
      }

      id v14 = v13;
      uint64_t v15 = *(void *)v22;
LABEL_10:
      uint64_t v16 = 0LL;
      while (1)
      {
        if (*(void *)v22 != v15) {
          objc_enumerationMutation(v7);
        }
        __int128 v18 = *(void **)(*((void *)&v21 + 1) + 8 * v16);
        if (v18)
        {
          if ((id)v18[2] == v6) {
            goto LABEL_18;
          }
        }

        else if (!v6)
        {
LABEL_18:
          [*(id *)(a1 + 240) removeObject:*(void *)(*((void *)&v21 + 1) + 8 * v16)];
          __int128 v19 = (void *)objc_claimAutoreleasedReturnValue([v18 description]);
          sub_10011BB18(0LL, 1042, 0LL, v19);

          if (v18) {
            __int128 v17 = (void *)v18[1];
          }
          else {
            __int128 v17 = 0LL;
          }
          v20[0] = _NSConcreteStackBlock;
          v20[1] = 3221225472LL;
          v20[2] = sub_1000AFC04;
          v20[3] = &unk_1001AF078;
          v20[4] = v18;
          sub_100130BE8((uint64_t)&OBJC_CLASS___NRDLocalDevice, v17, v20);
        }

        if (v14 == (id)++v16)
        {
          id v14 = -[NRDEphemeralDevice countByEnumeratingWithState:objects:count:]( v7,  "countByEnumeratingWithState:objects:count:",  &v21,  v25,  16LL);
          if (!v14) {
            goto LABEL_22;
          }
          goto LABEL_10;
        }
      }
    }
  }

void sub_1000AFC04(uint64_t a1, uint64_t a2, void *a3)
{
  id v8 = a3;
  if (qword_1001DC8A0 != -1) {
    dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC898, 0LL))
  {
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5) {
      uint64_t v6 = *(void *)(v5 + 8);
    }
    else {
      uint64_t v6 = 0LL;
    }
    id v7 = (id)qword_1001DC898;
    _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d Removed ephemeral device with NRUUID %@ result %lld error %@",  "",  "-[NRLinkDirector updateEphemeralDevice:forConnection:]_block_invoke",  2349LL,  v6,  a2,  v8);
  }
}

void *sub_1000AFCFC(void *a1, void *a2)
{
  id v3 = a2;
  int v4 = v3;
  if (a1)
  {
    uint64_t v5 = (void *)qword_1001DC890;
    if (qword_1001DC890)
    {
      if (v3)
      {
        (*((void (**)(id))v3 + 2))(v3);
        uint64_t v5 = (void *)qword_1001DC890;
      }

      a1 = v5;
    }

    else
    {
      if (v3)
      {
        uint64_t v6 = (void *)a1[42];
        if (!v6)
        {
          id v7 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
          id v8 = (void *)a1[42];
          a1[42] = v7;

          uint64_t v6 = (void *)a1[42];
        }

        id v9 = v6;
        id v10 = objc_retainBlock(v4);
        [v9 addObject:v10];
      }

      if (!*((_BYTE *)a1 + 19))
      {
        *((_BYTE *)a1 + 19) = 1;
        if (qword_1001DCA40 != -1) {
          dispatch_once(&qword_1001DCA40, &stru_1001AFC88);
        }
        uint64_t v11 = (dispatch_queue_s *)(id)qword_1001DCA48;
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472LL;
        block[2] = sub_1000AFE40;
        block[3] = &unk_1001B0A88;
        void block[4] = a1;
        dispatch_async(v11, block);
      }

      a1 = 0LL;
    }
  }

  return a1;
}

void sub_1000AFE40(uint64_t a1)
{
  char v2 = (void *)IDSCopyLocalDeviceUniqueID();
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3) {
    int v4 = *(dispatch_queue_s **)(v3 + 136);
  }
  else {
    int v4 = 0LL;
  }
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472LL;
  v6[2] = sub_1000AFECC;
  v6[3] = &unk_1001B0720;
  v6[4] = v3;
  id v7 = v2;
  id v5 = v2;
  dispatch_async(v4, v6);
}

void sub_1000AFECC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    *(_BYTE *)(v2 + 19) = 0;
  }
  objc_storeStrong((id *)&qword_1001DC890, *(id *)(a1 + 40));
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  uint64_t v3 = *(void **)(a1 + 32);
  if (v3) {
    uint64_t v3 = (void *)v3[42];
  }
  int v4 = v3;
  id v5 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v12;
    do
    {
      id v8 = 0LL;
      do
      {
        if (*(void *)v12 != v7) {
          objc_enumerationMutation(v4);
        }
        (*(void (**)(void))(*(void *)(*((void *)&v11 + 1) + 8LL * (void)v8) + 16LL))(*(void *)(*((void *)&v11 + 1) + 8LL * (void)v8));
        id v8 = (char *)v8 + 1;
      }

      while (v6 != v8);
      id v6 = [v4 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }

    while (v6);
  }

  uint64_t v9 = *(void *)(a1 + 32);
  if (v9)
  {
    id v10 = *(void **)(v9 + 336);
    *(void *)(v9 + 336) = 0LL;
  }

void sub_1000B0798(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC8A8;
  qword_1001DC8A8 = (uint64_t)v1;
}

id sub_1000B07C8()
{
  if (qword_1001DC8B0 != -1) {
    dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
  }
  return (id)qword_1001DC8A8;
}

void sub_1000B0CB8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    int v5 = 1;
    if (sysctlbyname("net.inet6.ip6.forwarding", 0LL, 0LL, &v5, 4uLL))
    {
      int v2 = *__error();
      if (strerror_r(v2, __strerrbuf, 0x80uLL)) {
        __strerrbuf[0] = 0;
      }
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC8A8, 17LL))
      {
        if (qword_1001DC8B0 != -1) {
          dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
        }
        _NRLogWithArgs( qword_1001DC8A8,  17LL,  "failed to set sysctl net.inet6.ip6.forwarding to 1: [%d] %s",  v2,  __strerrbuf);
      }
    }

    ++WeakRetained[5];
    uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained instance]);
    if (qword_1001DC8B0 != -1) {
      dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC8A8, 2LL))
    {
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      _NRLogWithArgs( qword_1001DC8A8,  2LL,  "%s%.30s:%-4d %@Sending public hello on %@ with seqno %u",  "",  "-[NRBabelInterface initWithInstance:]_block_invoke",  716LL,  v3,  WeakRetained,  (unsigned __int16)WeakRetained[5]);
    }

    unsigned int v4 = bswap32((unsigned __int16)WeakRetained[5]);
    v6[0] = 134218282;
    v6[1] = 1540;
    __int16 v7 = HIWORD(v4);
    __int16 v8 = 28695;
    *(void *)__strerrbuf = v6;
    uint64_t v10 = 12LL;
    [WeakRetained sendPacket:__strerrbuf iovLen:1 toAddr:&xmmword_1001568DC];
  }
}

LABEL_107:
}

void sub_1000B2F28( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id *location)
{
}

void sub_1000B375C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained readPackets];
}

void sub_1000B3788(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained readPackets];
}

void sub_1000B37B4(uint64_t a1, void *a2)
{
  int v2 = (id *)(a1 + 32);
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(v2);
  [WeakRetained handlePathUpdate:v3];
}

void sub_1000B653C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v2 = WeakRetained;
    [WeakRetained processPendingOutgoingPackets];
    id WeakRetained = v2;
  }
}

void sub_1000B656C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v2 = WeakRetained;
    [WeakRetained updateRXCostCheckTime:1 personal:0];
    id WeakRetained = v2;
  }
}

void sub_1000B65A4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v2 = WeakRetained;
    [WeakRetained updateRXCostCheckTime:1 personal:1];
    id WeakRetained = v2;
  }
}

void sub_1000B65DC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v2 = WeakRetained;
  if (WeakRetained)
  {
    id v6 = WeakRetained;
    unsigned int v3 = [WeakRetained txcost];
    id v2 = v6;
    if (v3 != 0xFFFF)
    {
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      int IsLevelEnabled = _NRLogIsLevelEnabled(qword_1001DC8A8, 1LL);
      id v2 = v6;
      if (IsLevelEnabled)
      {
        if (qword_1001DC8B0 != -1) {
          dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
        }
        id v5 = (id)qword_1001DC8A8;
        _NRLogWithArgs( v5,  1,  "%s%.30s:%-4d incomingIHUTimer fired for %@, previous txcost was %u",  "",  "-[NRBabelNeighbor initWithAddress:babelInterface:]_block_invoke_4",  1709,  v6,  [v6 txcost]);

        id v2 = v6;
      }
    }
  }
}

LABEL_2:
  metric = self->_metric;
  uint64_t v9 = metric - v4;
  if (metric == v4)
  {
    LOBYTE(v10) = 0;
  }

  else if (metric >= v4)
  {
    uint64_t v15 = (unsigned __int16)(metric - v4);
    if (v9 >= 0) {
      uint64_t v16 = -1;
    }
    else {
      uint64_t v16 = 1;
    }
    if (v15 == 0x8000) {
      LOBYTE(v10) = 0;
    }
    else {
      LOBYTE(v10) = v16;
    }
  }

  else
  {
    __int128 v12 = v4 - metric;
    __int128 v13 = v12;
    uint64_t v10 = ((__int16)v12 >> 15) | 1;
    if (v13 == 0x8000) {
      LOBYTE(v10) = 0;
    }
  }

  return (v10 & 0x80u) == 0;
}

void sub_1000B6E3C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_1000B6F58(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    unsigned int v4 = WeakRetained;
    if (qword_1001DC8B0 != -1) {
      dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC8A8, 1LL))
    {
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      _NRLogWithArgs( qword_1001DC8A8,  1LL,  "%s%.30s:%-4d removing old source %@",  "",  "-[NRBabelSource setupGCTimer]_block_invoke",  1977LL,  v4);
    }

    id v2 = (void *)objc_claimAutoreleasedReturnValue([v4 instance]);
    unsigned int v3 = (void *)objc_claimAutoreleasedReturnValue([v2 sources]);
    [v3 removeObject:v4];

    id WeakRetained = v4;
  }
}

void sub_1000B7448(_Unwind_Exception *a1)
{
}

uint64_t sub_1000B7CCC(uint64_t a1)
{
  if (qword_1001DC8B0 != -1) {
    dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC8A8, 1LL))
  {
    if (qword_1001DC8B0 != -1) {
      dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
    }
    _NRLogWithArgs( qword_1001DC8A8,  1LL,  "%s%.30s:%-4d %@ running <<%@>>",  "",  "-[NRBabelRoute applyUsingSystem]_block_invoke",  2198LL,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
  }

  system((const char *)[*(id *)(a1 + 40) UTF8String]);
  if (qword_1001DC8B0 != -1) {
    dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
  }
  uint64_t result = _NRLogIsLevelEnabled(qword_1001DC8A8, 1LL);
  if ((_DWORD)result)
  {
    if (qword_1001DC8B0 != -1) {
      dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
    }
    return _NRLogWithArgs( qword_1001DC8A8,  1LL,  "%s%.30s:%-4d %@ done running cmd",  "",  "-[NRBabelRoute applyUsingSystem]_block_invoke",  2200LL,  *(void *)(a1 + 32));
  }

  return result;
}

void sub_1000B7E20(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    unsigned int v4 = WeakRetained;
    if ([WeakRetained metric] == 0xFFFF)
    {
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC8A8, 1LL))
      {
        if (qword_1001DC8B0 != -1) {
          dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
        }
        _NRLogWithArgs( qword_1001DC8A8,  1LL,  "%s%.30s:%-4d removing old route %@",  "",  "-[NRBabelRoute initWithPrefix:neighbor:routerID:seqno:interval:receivedMetric:nextHop:instance:]_block_invoke",  2085LL,  v4);
      }

      uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([v4 instance]);
      unsigned int v3 = (void *)objc_claimAutoreleasedReturnValue([v2 routes]);
      [v3 removeObject:v4];
    }

    else
    {
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC8A8, 1LL))
      {
        if (qword_1001DC8B0 != -1) {
          dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
        }
        _NRLogWithArgs( qword_1001DC8A8,  1LL,  "%s%.30s:%-4d making old route unfeasible %@",  "",  "-[NRBabelRoute initWithPrefix:neighbor:routerID:seqno:interval:receivedMetric:nextHop:instance:]_block_invoke",  2081LL,  v4);
      }

      objc_msgSend( v4,  "setNumExpiryTimerFires:",  (unsigned __int16)((unsigned __int16)objc_msgSend(v4, "numExpiryTimerFires") + 1));
      [v4 resetExpiryTimer];
    }

    id WeakRetained = v4;
  }
}

void sub_1000B8D94(uint64_t a1)
{
  id WeakRetained = (__int16 *)objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v5 = WeakRetained;
    unsigned __int8 v3 = [*(id *)(a1 + 32) cancelIfRouteUnselected];
    id WeakRetained = v5;
    if ((v3 & 1) == 0)
    {
      int v4 = v5[6];
      if (v4 < 1)
      {
        [v5 cancelWithDelay:v4 == 0];
        id WeakRetained = v5;
      }

      else
      {
        [v5 sendSeqnoReq];
        id WeakRetained = v5;
        --v5[6];
      }
    }
  }
}

void sub_1000B97D4(_Unwind_Exception *a1)
{
}

LABEL_97:
}

LABEL_138:
          int v30 = v153;
          goto LABEL_50;
        }

        uint64_t v132 = sub_1000B07C8();
        uint64_t v133 = _NRLogIsLevelEnabled(v132, 16LL);

        if (!v133) {
          goto LABEL_202;
        }
        id v124 = sub_1000B07C8();
        uint64_t v125 = @"IHU";
        _NRLogWithArgs( v124,  16LL,  "%s%.30s:%-4d insufficient TLV length %u < %u for type %@",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3720LL,  v34,  6LL,  @"IHU");
        break;
      case 6:
        if (v34 > 9)
        {
          id v27 = *(void *)(v31 + 4);
          int v30 = v153;
          goto LABEL_21;
        }

        uint64_t v134 = sub_1000B07C8();
        id v135 = _NRLogIsLevelEnabled(v134, 16LL);

        if (!v135) {
          goto LABEL_202;
        }
        id v124 = sub_1000B07C8();
        uint64_t v125 = @"RouterID";
        _NRLogWithArgs( v124,  16LL,  "%s%.30s:%-4d insufficient TLV length %u < %u for type %@",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3722LL,  v34,  10LL,  @"RouterID");
        break;
      case 7:
        if (v34 > 1)
        {
          id v62 = *((unsigned __int8 *)v31 + 2);
          if (v31[2])
          {
            if (v62 == 1) {
              p_completion = &completion;
            }
            else {
              p_completion = (void ***)&v160;
            }
            id v91 = sub_1000B07C8();
            uint64_t v92 = _NRLogIsLevelEnabled(v91, 16LL);

            int v30 = v153;
            if (!v92) {
              goto LABEL_50;
            }
            id v45 = sub_1000B07C8();
            _NRLogWithArgs( v45,  16LL,  "%s%.30s:%-4d %@failed to decompress NextHop",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3735LL,  v153,  v145);
            goto LABEL_132;
          }

          __int128 v77 = sub_1000B07C8();
          __int128 v78 = _NRLogIsLevelEnabled(v77, 16LL);

          int v30 = v153;
          if (v78)
          {
            id v45 = sub_1000B07C8();
            _NRLogWithArgs(v45, 16LL, "%s%.30s:%-4d Received invalid NextHop with AE=0");
            goto LABEL_132;
          }

          goto LABEL_50;
        }

        id v136 = sub_1000B07C8();
        uint64_t v137 = _NRLogIsLevelEnabled(v136, 16LL);

        if (!v137) {
          goto LABEL_202;
        }
        id v124 = sub_1000B07C8();
        uint64_t v125 = @"NextHop";
        _NRLogWithArgs( v124,  16LL,  "%s%.30s:%-4d insufficient TLV length %u < %u for type %@",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3739LL,  v34,  2LL,  @"NextHop");
        break;
      case 8:
        if (v34 > 9)
        {
          uint64_t v64 = v34 - 10;
          uint64_t v156 = v31[4];
          int v65 = *((unsigned __int8 *)v31 + 2);
          if (v65 == 1) {
            id v66 = (char *)v159;
          }
          else {
            id v66 = (char *)v158;
          }
          objc_super v67 = sub_1000BF4D0( &v157,  v65,  (void *)(v31 + 12),  v64,  *((unsigned __int8 *)v31 + 5),  v66,  (unsigned __int8 *)&v156);
          if ((v67 & 0x80000000) == 0)
          {
            id v148 = *((unsigned __int8 *)v31 + 2);
            uint64_t v68 = v155;
            if ((v31[3] & 0x40) != 0) {
              uint64_t v68 = *(void *)&v157.__u6_addr32[2];
            }
            if ((sub_1000BF1F0((unsigned __int8 *)&v31[v67 + 12], v64 - v67) & 1) != 0)
            {
              int v30 = v153;
              __int128 v28 = v151;
              id v27 = v68;
              goto LABEL_21;
            }

            if (v148 == 1) {
              id v86 = &completion;
            }
            else {
              id v86 = (void ***)&v160;
            }
            BYTE6(v144) = v31[2];
            WORD2(v144) = bswap32(*((unsigned __int16 *)v31 + 5)) >> 16;
            WORD1(v144) = bswap32(*((unsigned __int16 *)v31 + 3)) >> 16;
            LOWORD(v144) = bswap32(*((unsigned __int16 *)v31 + 4)) >> 16;
            int v30 = v153;
            int v155 = v68;
            uint64_t v87 = -[NRBabelInstance handleUpdateFromAddr:ForPrefix:plen:nextHop:babelInterface:routerID:seqno:interval:metric:ae:]( v153,  "handleUpdateFromAddr:ForPrefix:plen:nextHop:babelInterface:routerID:seqno:interval:metric:ae:",  a5,  &v157,  v156,  v86,  v15,  v68,  v144);
            __int128 v28 = v151;
            if (v31[3] < 0) {
              *(in6_addr *)id v66 = v157;
            }
            v152 |= v87;
            goto LABEL_51;
          }

          __int128 v79 = sub_1000B07C8();
          id v80 = _NRLogIsLevelEnabled(v79, 16LL);

          int v30 = v153;
          if (!v80) {
            goto LABEL_50;
          }
          id v45 = sub_1000B07C8();
          _NRLogWithArgs( v45,  16LL,  "%s%.30s:%-4d %@failed to decompress Update",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3750LL,  v153,  v145);
          goto LABEL_132;
        }

        id v138 = sub_1000B07C8();
        unsigned int v139 = _NRLogIsLevelEnabled(v138, 16LL);

        if (!v139) {
          goto LABEL_202;
        }
        id v124 = sub_1000B07C8();
        uint64_t v125 = @"Update";
        _NRLogWithArgs( v124,  16LL,  "%s%.30s:%-4d insufficient TLV length %u < %u for type %@",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3793LL,  v34,  10LL,  @"Update");
        break;
      case 9:
        if (v34 > 1)
        {
          id v69 = v34 - 2;
          id v70 = *((unsigned __int8 *)v31 + 2);
          if (v31[2])
          {
            uint64_t v156 = v31[3];
            uint64_t v71 = sub_1000BF4D0(&v157, v70, (void *)(v31 + 4), (int)v34 - 2, 0LL, 0LL, (unsigned __int8 *)&v156);
            int v30 = v153;
            if (v71 < 0)
            {
              id v72 = sub_1000B07C8();
              uint64_t v73 = _NRLogIsLevelEnabled(v72, 16LL);

              if (v73)
              {
                id v45 = sub_1000B07C8();
                _NRLogWithArgs( v45,  16LL,  "%s%.30s:%-4d %@failed to decompress RouteReq",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3804LL,  v153,  v145);
LABEL_132:
              }

LABEL_202:
  int v30 = v153;
LABEL_203:
  if (qword_1001DC8B0 != -1) {
    dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC8A8, 2LL))
  {
    if (qword_1001DC8B0 != -1) {
      dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
    }
    _NRLogWithArgs( qword_1001DC8A8,  2LL,  "%s%.30s:%-4d %@%@",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3840LL,  v30,  v154);
  }

  if ((v152 & 1) != 0) {
    -[NRBabelInstance updateRoutes](v30, "updateRoutes");
  }

LABEL_212:
}

uint64_t sub_1000BF1F0(unsigned __int8 *a1, int a2)
{
  if (!a1)
  {
    id v6 = sub_1000B07C8();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 17LL);

    if (IsLevelEnabled)
    {
      id v8 = sub_1000B07C8();
      _NRLogWithArgs(v8, 17LL, "%s called with null tlvTrailer", "nrBabelTLVHasUnknownMandatoryTLV");
    }

    return 0LL;
  }

  if (!a2) {
    return 0LL;
  }
  uint64_t v2 = a1;
  unint64_t v3 = (unint64_t)&a1[a2];
  while (1)
  {
    int v4 = *v2;
    if (!*v2)
    {
      ++v2;
      goto LABEL_5;
    }

    if ((v4 & 0x80) != 0) {
      break;
    }
    if ((unint64_t)(v2 + 1) >= v3)
    {
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC8A8, 16LL))
      {
        if (qword_1001DC8B0 != -1) {
          dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
        }
        _NRLogWithArgs(qword_1001DC8A8, 16LL, "%s%.30s:%-4d Sub-TLV length hanging off edge of TLV trailer");
      }

      return 1LL;
    }

    v2 += v2[1] + 2;
    if ((unint64_t)v2 > v3)
    {
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC8A8, 16LL))
      {
        if (qword_1001DC8B0 != -1) {
          dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
        }
        _NRLogWithArgs(qword_1001DC8A8, 16LL, "%s%.30s:%-4d Sub-TLV body hanging off edge of TLV trailer");
      }

      return 1LL;
    }

    if (qword_1001DC8B0 != -1) {
      dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC8A8, 1LL))
    {
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      _NRLogWithArgs( qword_1001DC8A8,  1LL,  "%s%.30s:%-4d Found unknown non-mandatory Sub-TLV %u",  "",  "nrBabelTLVHasUnknownMandatoryTLV",  2380,  v4);
    }

uint64_t sub_1000BF4D0( void *a1, int a2, void *__src, unsigned int a4, size_t __n, char *a6, unsigned __int8 *a7)
{
  if (!a2)
  {
    uint64_t result = 0LL;
    *a1 = 0LL;
    a1[1] = 0LL;
    return result;
  }

  unsigned int v9 = __n;
  if (a7 && *a7 >= 0x81u)
  {
    if (qword_1001DC8B0 != -1) {
      dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC8A8, 16LL))
    {
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      _NRLogWithArgs(qword_1001DC8A8, 16LL, "%s%.30s:%-4d got plen too high %u");
    }

    return 0xFFFFFFFFLL;
  }

  if ((_DWORD)__n && !a6)
  {
    if (qword_1001DC8B0 != -1) {
      dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC8A8, 16LL))
    {
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      _NRLogWithArgs(qword_1001DC8A8, 16LL, "%s%.30s:%-4d prevAddr is NULL");
    }

    return 0xFFFFFFFFLL;
  }

  __int128 v27 = 0uLL;
  switch(a2)
  {
    case 1:
      if (a7 && *a7 >= 0x21u)
      {
        if (qword_1001DC8B0 != -1) {
          dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC8A8, 16LL))
        {
          id v14 = sub_1000B07C8();
          _NRLogWithArgs(v14, 16LL, "%s%.30s:%-4d got IPv4 plen too high %u", "", "nrBabelDecompressAddress", 2275, *a7);
        }

        return 0xFFFFFFFFLL;
      }

      WORD5(v27) = -1;
      uint64_t v15 = (char *)&v27 + 12;
      a6 += 12;
      unsigned int v16 = 32;
      if (a7) {
        goto LABEL_31;
      }
      break;
    case 2:
      unsigned int v16 = 128;
      uint64_t v15 = (char *)&v27;
      if (a7) {
LABEL_31:
      }
        unsigned int v16 = *a7;
      break;
    case 3:
      LOWORD(v27) = -32514;
      uint64_t v15 = (char *)&v27 + 8;
      a6 += 8;
      unsigned int v16 = 64;
      if (a7) {
        goto LABEL_31;
      }
      break;
    default:
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      id v22 = sub_1000B07C8();
      _NRLogWithArgs(v22, 16LL, "%s%.30s:%-4d invalid AE %u");
      goto LABEL_69;
  }

  unsigned int v17 = v16 >> 3;
  if (v16 >> 3 < __n)
  {
    if (qword_1001DC8B0 != -1) {
      dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC8A8, 16LL))
    {
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      _NRLogWithArgs(qword_1001DC8A8, 16LL, "%s%.30s:%-4d AE %u omitted %u > plenBytes %u", "");
    }

    return 0xFFFFFFFFLL;
  }

  int v18 = v16 & 7;
  if (v17 > __n)
  {
    if (!__src)
    {
      id v25 = sub_1000B07C8();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v25, 16LL);

      if (IsLevelEnabled)
      {
        id v22 = sub_1000B07C8();
        _NRLogWithArgs(v22, 16LL, "%s%.30s:%-4d currentAddr is NULL");
        goto LABEL_69;
      }

      return 0xFFFFFFFFLL;
    }

    if ((v16 & 7) != 0) {
      unsigned __int8 v19 = (v16 >> 3) - __n + 1;
    }
    else {
      unsigned __int8 v19 = (v16 >> 3) - __n;
    }
    if (a4 < v19)
    {
      id v20 = sub_1000B07C8();
      int v21 = _NRLogIsLevelEnabled(v20, 16LL);

      if (v21)
      {
        id v22 = sub_1000B07C8();
        _NRLogWithArgs(v22, 16LL, "%s%.30s:%-4d currentAddr is not long enough");
LABEL_69:

        return 0xFFFFFFFFLL;
      }

      return 0xFFFFFFFFLL;
    }
  }

  if ((_DWORD)__n) {
    memcpy(v15, a6, __n);
  }
  __int128 v23 = &v15[v9];
  if (v17 <= v9)
  {
    unsigned int v24 = 0;
  }

  else
  {
    unsigned int v24 = v17 - v9;
    memcpy(v23, __src, (int)(v17 - v9));
  }

  if (v18)
  {
    v23[v17] = *((_BYTE *)__src + (int)(v17 - v9)) & (-1 << (8 - v18));
    ++v24;
  }

  if (a2 == 1 && a7) {
    *a7 += 96;
  }
  *(_OWORD *)a1 = v27;
  if (v24 > a4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v24;
  }
}

void sub_1000BF9C4(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 24LL);
  uint64_t v5 = 65021LL;
  uint64_t v6 = v2;
  unint64_t v3 = -[NRBabelPrefix initWithPrefix:plen:]( objc_alloc(&OBJC_CLASS___NRBabelPrefix),  "initWithPrefix:plen:",  &v5,  128LL);
  int v4 = objc_alloc(&OBJC_CLASS___NRBabelSourceLocal);

  [*(id *)(a1 + 32) setupAddress:&v5];
  [*(id *)(a1 + 32) setupInterfaces];
}

void sub_1000BFA64(uint64_t a1, void *a2)
{
  uint64_t v2 = (id *)(a1 + 32);
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(v2);
  [WeakRetained handleIfBringupPathUpdate:v3];
}

void sub_1000C0510(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = *(void **)(a1 + 48);
  id v4 = *(id *)(a1 + 40);
  id v6 = v2;
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 instance]);
  objc_msgSend( v5,  "handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:",  objc_msgSend(v6, "bytes"),  *(unsigned int *)(a1 + 64),  objc_msgSend(v4, "localAddress"),  *(void *)(a1 + 56),  *(void *)(a1 + 48),  0);
}

void sub_1000C05AC(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) interfaces]);
  [v2 addObject:*(void *)(a1 + 40)];

  id v3 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) fakeInterfaces]);
  [v3 addObject:*(void *)(a1 + 40)];
}

void sub_1000C159C(_Unwind_Exception *a1)
{
}

LABEL_4:
  if (self->_upgradeSessionAfterFirstUnlock || !-[NRLinkWired onlyAllowClassC](self, "onlyAllowClassC"))
  {
    -[NRLinkWired setupIPsecIfNecessary:](self, "setupIPsecIfNecessary:", 4LL);
  }

  else
  {
    objc_opt_self(&OBJC_CLASS___NRDKeyManager);
    if (qword_1001DCC18 != -1) {
      dispatch_once(&qword_1001DCC18, &stru_1001B0910);
    }
    id v8 = (id)qword_1001DCC10;
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472LL;
    v12[2] = sub_1000C5530;
    v12[3] = &unk_1001B0A88;
    v12[4] = self;
    sub_100144478((uint64_t)v8, v12);
  }

  return 1;
}

void sub_1000C195C(_Unwind_Exception *a1)
{
}

void sub_1000C2230( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id *location, id *a17)
{
}

void sub_1000C29B4(_Unwind_Exception *a1)
{
}

void sub_1000C3690( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_1000C37CC(_Unwind_Exception *a1)
{
}

void sub_1000C3BCC(_Unwind_Exception *a1)
{
}

void sub_1000C419C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v2 = WeakRetained;
    if (WeakRetained[208]) {
      [WeakRetained upgradeSessionsIfNeeded];
    }
    else {
      [WeakRetained setupIPsecIfNecessary:3];
    }
    id WeakRetained = v2;
  }
}

void sub_1000C41F0(uint64_t a1)
{
  id WeakRetained = (unsigned __int8 *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = (char *)WeakRetained;
  if (WeakRetained && WeakRetained[16] != 255 && *(void *)(WeakRetained + 239))
  {
    objc_initWeak(&location, WeakRetained);
    id v3 = *(void **)(v2 + 239);
    id v4 = sub_10010CD5C();
    id v10 = v4;
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v10, 1LL));
    id v6 = (void *)objc_claimAutoreleasedReturnValue([v2 queue]);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    id v7[2] = sub_1000C4368;
    v7[3] = &unk_1001AF950;
    objc_copyWeak(&v8, &location);
    [v3 sendPrivateNotifies:v5 maxRetries:10 retryIntervalInMilliseconds:1000 callbackQueue:v6 callback:v7];

    objc_destroyWeak(&v8);
    objc_destroyWeak(&location);
  }
}

void sub_1000C433C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_1000C4368(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v15 = WeakRetained;
    uint64_t v5 = _NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    id v6 = (void *)v5;
    if (a2)
    {
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

      if (IsLevelEnabled)
      {
        unsigned int v9 = (void *)_NRCopyLogObjectForNRUUID(v15[4], v8);
        id v10 = [v15 copyDescription];
        _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: Received response to classC unlock",  "",  "-[NRLinkWired sendClassCUnlockedNotify]_block_invoke_2",  913LL,  v10);
      }

      [v15 setSentLocalClassCUnlockNotify:1];
      [v15 upgradeSessionsIfNeeded];
      goto LABEL_8;
    }

    int v11 = _NRLogIsLevelEnabled(v5, 16LL);

    id WeakRetained = v15;
    if (v11)
    {
      __int128 v13 = (void *)_NRCopyLogObjectForNRUUID(v15[4], v12);
      id v14 = [v15 copyDescription];
      _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d %@: Did not receive response to classC unlock",  "",  "-[NRLinkWired sendClassCUnlockedNotify]_block_invoke_2",  917LL,  v14);

LABEL_8:
      id WeakRetained = v15;
    }
  }
}

id sub_1000C449C()
{
  if (qword_1001DC8C0 != -1) {
    dispatch_once(&qword_1001DC8C0, &stru_1001AF3E8);
  }
  return (id)qword_1001DC8B8;
}

void sub_1000C44DC(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v14 = WeakRetained;
    BOOL v4 = [WeakRetained state] == 255;
    id WeakRetained = v14;
    if (!v4)
    {
      uint64_t v6 = _NRCopyLogObjectForNRUUID(v14[4], v5);
      __int16 v7 = (void *)v6;
      if (a2)
      {
        int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

        id WeakRetained = v14;
        if (IsLevelEnabled)
        {
          id v10 = (void *)_NRCopyLogObjectForNRUUID(v14[4], v9);
          id v11 = [v14 copyDescription];
          _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d %@: Received response to control notify",  "",  "-[NRLinkWired sendControlData:]_block_invoke",  864LL,  v11);
LABEL_8:

          id WeakRetained = v14;
        }
      }

      else
      {
        int v12 = _NRLogIsLevelEnabled(v6, 16LL);

        id WeakRetained = v14;
        if (v12)
        {
          id v10 = (void *)_NRCopyLogObjectForNRUUID(v14[4], v13);
          id v11 = [v14 copyDescription];
          _NRLogWithArgs( v10,  16LL,  "%s%.30s:%-4d %@: Did not receive response to control notify",  "",  "-[NRLinkWired sendControlData:]_block_invoke",  866LL,  v11);
          goto LABEL_8;
        }
      }
    }
  }
}

void sub_1000C45FC(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC8B8;
  qword_1001DC8B8 = (uint64_t)v1;
}

void sub_1000C462C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v4 = WeakRetained;
    BOOL v3 = [WeakRetained state] == 255;
    id WeakRetained = v4;
    if (!v3)
    {
      [v4 setupIPsecIfNecessary:*(unsigned __int8 *)(a1 + 40)];
      id WeakRetained = v4;
    }
  }
}

void sub_1000C4680(uint64_t a1, uint64_t a2, void *a3)
{
  id v76 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v6 = WeakRetained;
  if (WeakRetained)
  {
    __int16 v7 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained linkDelegate]);
    id v8 = v76;
    if (v76)
    {
      int v9 = *(unsigned __int8 *)(a1 + 56);
      if (v9 == 4
        || v9 == 3
        && ([v6 setIkeClassCEstablished:0],
            unsigned int v10 = [v6 onlyAllowClassC],
            id v8 = v76,
            v10))
      {
        objc_msgSend(v6, "setIkeClassDEstablished:", 0, v8);
        id v8 = v76;
      }

      [v6 processIKEDisconnection:*(unsigned __int8 *)(a1 + 56) error:v8];
      if ([v6 state] != 255)
      {
        uint64_t v11 = *(void *)(a1 + 32);
        uint64_t v12 = *(void *)(a1 + 40);
        SessionStateString = (void *)NEIKEv2CreateSessionStateString(a2);
        [v6 reportEvent:3018, @"%@ session %@ got IKE error %@ with state %@", v11, v12, v76, SessionStateString detailsFormat];

LABEL_9:
        [v6 restartIKESessionForDataProtectionClass:*(unsigned __int8 *)(a1 + 56)];
      }
    }

    else
    {
      uint64_t v14 = *(void *)(a1 + 32);
      uint64_t v15 = *(void *)(a1 + 40);
      unsigned int v16 = (void *)NEIKEv2CreateSessionStateString(a2);
      [v6 reportEvent:3009, @"%@ session %@ changed state to %@", v14, v15, v16 detailsFormat];

      switch(a2)
      {
        case 1LL:
          if ([v6 state] == 1)
          {
            unsigned __int8 v19 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v18);
            int IsLevelEnabled = _NRLogIsLevelEnabled(v19, 0LL);

            if (IsLevelEnabled)
            {
              uint64_t v22 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v21);
              id v23 = [v6 copyDescription];
              _NRLogWithArgs( v22,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ now connecting",  "",  "-[NRLinkWired setupIKECallbacks:]_block_invoke",  413LL,  v23,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
            }

            [v6 changeStateTo:5];
          }

          else
          {
            unsigned int v39 = [v6 state];
            uint64_t v41 = _NRCopyLogObjectForNRUUID(v6[4], v40);
            id v42 = (void *)v41;
            if (v39 == 5)
            {
              int v43 = _NRLogIsLevelEnabled(v41, 0LL);

              if (!v43) {
                break;
              }
              id v45 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v44);
              id v46 = [v6 copyDescription];
              _NRLogWithArgs( v45,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ already connecting",  "",  "-[NRLinkWired setupIKECallbacks:]_block_invoke",  416LL,  v46,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
            }

            else
            {
              int v69 = _NRLogIsLevelEnabled(v41, 16LL);

              if (!v69) {
                break;
              }
              id v45 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v70);
              id v46 = [v6 copyDescription];
              _NRLogWithArgs( v45,  16LL,  "%s%.30s:%-4d %@: %@ IKE %@ connecting but weird state",  "",  "-[NRLinkWired setupIKECallbacks:]_block_invoke",  418LL,  v46,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
            }
          }

          break;
        case 2LL:
          unsigned int v24 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v17);
          int v25 = _NRLogIsLevelEnabled(v24, 0LL);

          if (v25)
          {
            __int128 v27 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v26);
            id v28 = [v6 copyDescription];
            _NRLogWithArgs( v27,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ now connected from started",  "",  "-[NRLinkWired setupIKECallbacks:]_block_invoke",  421LL,  v28,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
          }

          int v29 = *(unsigned __int8 *)(a1 + 56);
          if (v29 == 4
            || v29 == 3
            && ([v6 setIkeClassCEstablished:1], objc_msgSend(v6, "onlyAllowClassC")))
          {
            [v6 setIkeClassDEstablished:1];
          }

          if ([v6 state] == 8)
          {
            id v31 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v30);
            int v32 = _NRLogIsLevelEnabled(v31, 0LL);

            if (v32)
            {
              BOOL v34 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v33);
              id v35 = [v6 copyDescription];
              _NRLogWithArgs( v34,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ already ready",  "",  "-[NRLinkWired setupIKECallbacks:]_block_invoke",  432LL,  v35,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
            }

            [v7 linkIsReady:v6];
          }

          else
          {
            if ([v6 state] != 5)
            {
              __int128 v48 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v47);
              int v49 = _NRLogIsLevelEnabled(v48, 0LL);

              if (v49)
              {
                id v51 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v50);
                id v52 = [v6 copyDescription];
                _NRLogWithArgs( v51,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ ready but weird state",  "",  "-[NRLinkWired setupIKECallbacks:]_block_invoke",  436LL,  v52,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
              }
            }

            [v6 changeStateTo:8];
            [v7 linkIsReady:v6];
            if ([v6 shouldCreateCompanionProxyAgent])
            {
              int v53 = (void *)objc_claimAutoreleasedReturnValue([v6 companionProxyAgent]);

              if (!v53)
              {
                id v54 = (void *)NEVirtualInterfaceCopyName([v6 virtualInterface]);
                id v55 = (void *)objc_claimAutoreleasedReturnValue([v6 nrUUID]);
                char v56 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v55);
                id v57 = v56;
                if (v56) {
                  int v58 = (void *)*((void *)v56 + 14);
                }
                else {
                  int v58 = 0LL;
                }
                id v59 = v58;

                if (v54 && v59)
                {
                  id v60 = objc_alloc(&OBJC_CLASS___NRCompanionProxyAgent);
                  int v61 = (void *)objc_claimAutoreleasedReturnValue([v6 queue]);
                  id v62 = (void *)objc_claimAutoreleasedReturnValue([v6 nrUUID]);
                  int v63 = sub_10005E638((id *)&v60->super.isa, v61, v54, v59, v62);
                  uint64_t v64 = (void *)v6[11];
                  v6[11] = v63;

                  [v6 reportEvent:12001];
                }
              }

              int v65 = (void *)objc_claimAutoreleasedReturnValue([v6 companionProxyAgent]);
              char v67 = sub_10005E944((uint64_t)v65, v66);

              if ((v67 & 1) != 0)
              {
                [v6 reportEvent:12002];
              }

              else
              {
                uint64_t v71 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v68);
                int v72 = _NRLogIsLevelEnabled(v71, 16LL);

                if (v72)
                {
                  id v74 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v73);
                  id v75 = [v6 copyDescription];
                  _NRLogWithArgs( v74,  16LL,  "%s%.30s:%-4d %@: failed to register companion agent",  "",  "-[NRLinkWired setupIKECallbacks:]_block_invoke",  453LL,  v75);
                }
              }
            }
          }

          [v6 sendClassCUnlockedNotify];
          break;
        case 3LL:
          int v36 = *(unsigned __int8 *)(a1 + 56);
          if (v36 == 4
            || v36 == 3
            && ([v6 setIkeClassCEstablished:0], objc_msgSend(v6, "onlyAllowClassC")))
          {
            [v6 setIkeClassDEstablished:0];
          }

          [v6 reportEvent:3018, @"%@ session %@ cancelled by peer", *(void *)(a1 + 32), *(void *)(a1 + 40) detailsFormat];
          goto LABEL_9;
        case 4LL:
          [v6 cancelWithReason:@"%@ session %@ got unexpected MOBIKE state", *(void *)(a1 + 32), *(void *)(a1 + 40)];
          break;
        default:
          uint64_t v37 = *(void *)(a1 + 32);
          uint64_t v38 = (void *)NEIKEv2CreateSessionStateString(a2);
          [v6 cancelWithReason:@"%@ session %@ got bad IKE state %@", v37, v38];

          break;
      }
    }
  }
}

void sub_1000C4DA4(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v14 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    if (v14)
    {
      uint64_t v8 = *(void *)(a1 + 32);
      uint64_t v9 = *(void *)(a1 + 40);
      SessionStateString = (void *)NEIKEv2CreateSessionStateString(a3);
      [WeakRetained reportEvent:3018, @"%@ session %@ got child %u state update %@ error %@", v8, v9, a2, SessionStateString, v14 detailsFormat];

      [WeakRetained processIKEDisconnection:*(unsigned __int8 *)(a1 + 56) error:v14];
    }

    else
    {
      uint64_t v11 = *(void *)(a1 + 32);
      uint64_t v12 = *(void *)(a1 + 40);
      if (a3 != 3)
      {
        uint64_t v13 = (void *)NEIKEv2CreateSessionStateString(a3);
        [WeakRetained reportEvent:3009, @"%@ session %@ child %u state update %@", v11, v12, a2, v13 detailsFormat];

        goto LABEL_9;
      }

      [WeakRetained reportEvent:3018, @"%@ session %@ got child %u Disconnected state with no error", v11, *(void *)(a1 + 40), a2 detailsFormat];
    }

    [WeakRetained restartIKESessionForDataProtectionClass:*(unsigned __int8 *)(a1 + 56)];
  }

void sub_1000C4EC8(uint64_t a1, void *a2)
{
  id v11 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v5 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      id v10 = [v5 copyDescription];
      _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got config update %@",  "",  "-[NRLinkWired setupIKECallbacks:]_block_invoke_3",  518LL,  v10,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  v11);
    }
  }
}

void sub_1000C4F94(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v16 = a3;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v10 = WeakRetained;
  if (WeakRetained)
  {
    id v11 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v9);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0LL);

    if (IsLevelEnabled)
    {
      id v14 = (void *)_NRCopyLogObjectForNRUUID(v10[4], v13);
      id v15 = [v10 copyDescription];
      _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got child %u traffic selector update local %@ remote %@",  "",  "-[NRLinkWired setupIKECallbacks:]_block_invoke_4",  529LL,  v15,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  a2,  v16,  v7);
    }
  }
}

void sub_1000C5080(uint64_t a1, void *a2)
{
  id v11 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v5 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      id v10 = [v5 copyDescription];
      _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got additional addresses %@",  "",  "-[NRLinkWired setupIKECallbacks:]_block_invoke_5",  538LL,  v10,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  v11);
    }
  }
}

void sub_1000C514C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    uint64_t v9 = WeakRetained;
    uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v3);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

    id WeakRetained = v9;
    if (IsLevelEnabled)
    {
      id v7 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v6);
      id v8 = [v9 copyDescription];
      _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got short DPD",  "",  "-[NRLinkWired setupIKECallbacks:]_block_invoke_6",  546LL,  v8,  *(void *)(a1 + 32),  *(void *)(a1 + 40));

      id WeakRetained = v9;
    }
  }
}

void sub_1000C520C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 sortedArrayUsingComparator:&stru_1001AFCC8]);
    id v7 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v6);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0LL);

    if (IsLevelEnabled)
    {
      id v10 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v9);
      id v11 = [WeakRetained copyDescription];
      _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got private notifies %@",  "",  "-[NRLinkWired setupIKECallbacks:]_block_invoke_7",  556LL,  v11,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  v5);
    }

    __int128 v22 = 0u;
    __int128 v23 = 0u;
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    id v12 = v5;
    id v13 = [v12 countByEnumeratingWithState:&v20 objects:v24 count:16];
    if (v13)
    {
      id v14 = v13;
      uint64_t v15 = *(void *)v21;
      do
      {
        for (uint64_t i = 0LL; i != v14; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v21 != v15) {
            objc_enumerationMutation(v12);
          }
          uint64_t v17 = *(void **)(*((void *)&v20 + 1) + 8LL * (void)i);
          id v18 = [v17 notifyStatus];
          unsigned __int8 v19 = (void *)objc_claimAutoreleasedReturnValue([v17 notifyData]);
          [WeakRetained handleNotifyCode:v18 payload:v19];
        }

        id v14 = [v12 countByEnumeratingWithState:&v20 objects:v24 count:16];
      }

      while (v14);
    }
  }
}

void sub_1000C53F4(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v13 = WeakRetained;
    BOOL v4 = [WeakRetained state] == 255;
    id WeakRetained = v13;
    if (!v4)
    {
      *((_BYTE *)v13 + 83) = 0;
      uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v13 + 4), v5);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

      if (!a2)
      {
        if (IsLevelEnabled)
        {
          id v11 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v13 + 4), v8);
          id v12 = [v13 copyDescription];
          _NRLogWithArgs( v11,  0LL,  "%s%.30s:%-4d %@: peer is NOT available",  "",  "-[NRLinkWired checkPeerAvailabilityWithForceAggressive:]_block_invoke",  304LL,  v12);
        }

        [v13 cancelWithReason:@"Dead Peer Detection"];
        goto LABEL_9;
      }

      id WeakRetained = v13;
      if (IsLevelEnabled)
      {
        uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v13 + 4), v8);
        id v10 = [v13 copyDescription];
        _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: peer is available",  "",  "-[NRLinkWired checkPeerAvailabilityWithForceAggressive:]_block_invoke",  302LL,  v10);

LABEL_9:
        id WeakRetained = v13;
      }
    }
  }
}

id sub_1000C5530(uint64_t a1)
{
  return [*(id *)(a1 + 32) setupIPsecIfNecessary:3];
}

void sub_1000C553C(uint64_t a1, int a2, unsigned int a3)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v7 = WeakRetained;
  if (WeakRetained)
  {
    __int128 v23 = WeakRetained;
    unsigned int v8 = [WeakRetained state];
    id v7 = v23;
    if (v8 != 255)
    {
      id v9 = objc_loadWeakRetained((id *)(a1 + 40));
      if (!v9) {
        goto LABEL_30;
      }
      id v10 = (id)objc_claimAutoreleasedReturnValue([v23 pairingClient]);

      if (v10 != v9) {
        goto LABEL_30;
      }
      uint64_t v11 = objc_claimAutoreleasedReturnValue([v23 pairingClient]);
      id v12 = (void *)v11;
      if (v11) {
        uint64_t v13 = *(void *)(v11 + 48);
      }
      else {
        LOBYTE(v13) = 0;
      }
      id v14 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
      uint64_t v15 = v14;
      if ((v13 & 1) != 0)
      {
        -[NSMutableString appendFormat:](v14, "appendFormat:", @"PairingSessionConnected | ");
        if ((v13 & 2) == 0)
        {
LABEL_9:
          if ((v13 & 4) == 0) {
            goto LABEL_10;
          }
          goto LABEL_17;
        }
      }

      else if ((v13 & 2) == 0)
      {
        goto LABEL_9;
      }

      -[NSMutableString appendFormat:](v15, "appendFormat:", @"ClassDVerified | ");
      if ((v13 & 4) == 0)
      {
LABEL_10:
        if ((v13 & 8) == 0) {
          goto LABEL_11;
        }
        goto LABEL_18;
      }

id sub_1000C58FC()
{
  if (qword_1001DC8D0 != -1) {
    dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
  }
  return (id)qword_1001DC8C8;
}

void sub_1000C593C(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC8C8;
  qword_1001DC8C8 = (uint64_t)v1;
}

void sub_1000C6A18(uint64_t a1)
{
  if ([*(id *)(a1 + 32) state] == 255)
  {
    if (qword_1001DC8D0 != -1) {
      dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC8C8, 1LL))
    {
      if (qword_1001DC8D0 != -1) {
        dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
      }
      _NRLogWithArgs( qword_1001DC8C8,  1LL,  "%s%.30s:%-4d Ignoring as link is cancelled: %@",  "",  "-[NRLinkManagerWired linkDidReceiveData:data:]_block_invoke",  702LL,  *(void *)(a1 + 32));
    }
  }

  else
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2) {
      id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    }
    else {
      id WeakRetained = 0LL;
    }
    id v4 = WeakRetained;
    [WeakRetained linkDidReceiveData:*(void *)(a1 + 32) data:*(void *)(a1 + 48)];
  }

void sub_1000C6B28(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
  }
  else {
    id WeakRetained = 0LL;
  }
  [WeakRetained linkIsUnavailable:*(void *)(a1 + 40)];

  id v4 = *(void **)(a1 + 32);
  if (v4)
  {
    uint64_t v6 = sub_100131A50((uint64_t)&OBJC_CLASS___NRDLocalDevice);
    if (-[NSMutableArray count](v6, "count")) {
      sub_1000C6BDC(v4, v6);
    }
    uint64_t v5 = sub_1001317AC((uint64_t)&OBJC_CLASS___NRDLocalDevice);
    if (-[NSMutableArray count](v5, "count")) {
      sub_1000C6BDC(v4, v5);
    }
  }

void sub_1000C6BDC(void *a1, void *a2)
{
  id v135 = a2;
  __int128 v172 = 0u;
  __int128 v173 = 0u;
  __int128 v174 = 0u;
  __int128 v175 = 0u;
  id obj = [(id)a1[5] copy];
  uint64_t v133 = a1;
  id v142 = [obj countByEnumeratingWithState:&v172 objects:v184 count:16];
  if (v142)
  {
    uint64_t v140 = *(void *)v173;
    do
    {
      for (uint64_t i = 0LL; i != v142; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v173 != v140) {
          objc_enumerationMutation(obj);
        }
        uint64_t v5 = *(void **)(*((void *)&v172 + 1) + 8LL * (void)i);
        id v6 = (id)a1[10];
        id v7 = (void *)objc_claimAutoreleasedReturnValue([v5 localInterfaceName]);
        unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:v7]);

        if (!v8 || ![v8 count]) {
          [v5 cancelWithReason:@"interface went away"];
        }

        id v9 = (id)a1[11];
        id v10 = (void *)objc_claimAutoreleasedReturnValue([v5 nrUUID]);
        uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:v10]);

        if (!v11) {
          goto LABEL_6;
        }
        __int128 v170 = 0u;
        __int128 v171 = 0u;
        __int128 v168 = 0u;
        __int128 v169 = 0u;
        id v12 = (void *)objc_claimAutoreleasedReturnValue([v11 interfaceToPeerAddressDictionary]);
        uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v12 allValues]);

        id v14 = [v13 countByEnumeratingWithState:&v168 objects:v183 count:16];
        if (!v14)
        {
LABEL_5:

LABEL_6:
          id v4 = 0LL;
          goto LABEL_7;
        }

        id v15 = v14;
        uint64_t v16 = *(void *)v169;
LABEL_17:
        uint64_t v17 = 0LL;
        while (1)
        {
          if (*(void *)v169 != v16) {
            objc_enumerationMutation(v13);
          }
          id v18 = *(void **)(*((void *)&v168 + 1) + 8 * v17);
          unsigned __int8 v19 = (void *)objc_claimAutoreleasedReturnValue([v5 remoteOuterEndpoint]);
          unsigned __int8 v20 = [v18 containsObject:v19];

          if ((v20 & 1) != 0) {
            break;
          }
          if (v15 == (id)++v17)
          {
            id v15 = [v13 countByEnumeratingWithState:&v168 objects:v183 count:16];
            a1 = v133;
            if (v15) {
              goto LABEL_17;
            }
            goto LABEL_5;
          }
        }

        id v4 = v18;

        if (v4)
        {
          a1 = v133;
          if ([v4 count]) {
            goto LABEL_8;
          }
        }

        else
        {
          a1 = v133;
        }

LABEL_103:
            uint64_t v49 = v121 + 1;
            if ((id)(v121 + 1) == v119)
            {
              id v119 = [v115 countByEnumeratingWithState:&v156 objects:v180 count:16];
              if (!v119) {
                goto LABEL_33;
              }
              goto LABEL_102;
            }
          }

          uint64_t v126 = v54;
          unsigned int v141 = *(void **)(*((void *)&v152 + 1) + 8 * v54);
          __int128 v150 = 0u;
          __int128 v151 = 0u;
          __int128 v148 = 0u;
          __int128 v149 = 0u;
          id v130 = v125;
          id v56 = [v130 countByEnumeratingWithState:&v148 objects:v178 count:16];
          if (!v56) {
            goto LABEL_110;
          }
          id v57 = v56;
          uint64_t v58 = *(void *)v149;
          uint64_t v128 = *(void *)v149;
          while (2)
          {
            uint64_t v59 = 0LL;
            id v129 = v57;
LABEL_121:
            if (*(void *)v149 != v58) {
              objc_enumerationMutation(v130);
            }
            if (!(v33 & 1 | ((v34 & 1) == 0))) {
              goto LABEL_110;
            }
            id obja = *(id *)(*((void *)&v148 + 1) + 8 * v59);
            uint64_t v134 = v59;
            int v132 = v34;
            __int128 v146 = 0u;
            __int128 v147 = 0u;
            __int128 v144 = 0u;
            __int128 v145 = 0u;
            id v60 = [(id)a1[5] copy];
            id v61 = [v60 countByEnumeratingWithState:&v144 objects:v177 count:16];
            if (!v61)
            {
LABEL_141:

              goto LABEL_142;
            }

            id v62 = v61;
            uint64_t v63 = *(void *)v145;
LABEL_128:
            uint64_t v64 = 0LL;
LABEL_133:
            if (*(void *)v145 != v63) {
              objc_enumerationMutation(v60);
            }
            int v65 = *(void **)(*((void *)&v144 + 1) + 8 * v64);
            uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue([v65 nrUUID]);
            if ([v66 isEqual:v24])
            {
              char v67 = (void *)objc_claimAutoreleasedReturnValue([v65 localInterfaceName]);
              unsigned int v68 = [v67 isEqualToString:v143];

              if (v68)
              {
                int v69 = (void *)objc_claimAutoreleasedReturnValue([v65 localOuterEndpoint]);
                uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue([v69 hostname]);

                uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue([v65 remoteOuterEndpoint]);
                uint64_t v71 = (void *)objc_claimAutoreleasedReturnValue([v70 hostname]);

                int v72 = (void *)objc_claimAutoreleasedReturnValue([v141 hostname]);
                if ([v66 isEqualToString:v72])
                {
                  uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue([obja hostname]);
                  unsigned __int8 v74 = [v71 isEqualToString:v73];

                  unsigned int v24 = v136;
                  if ((v74 & 1) != 0)
                  {
                    unsigned int v75 = [v65 state];

                    if (v75 != 255)
                    {
                      a1 = v133;
                      char v33 = v127;
                      int v34 = v132;
                      uint64_t v58 = v128;
                      id v57 = v129;
                      goto LABEL_119;
                    }

LABEL_187:
                      id v95 = v84;
                      __int128 v99 = 0LL;
                      unsigned int v24 = v136;
                      uint64_t v98 = objb;
                      goto LABEL_159;
                    }

                    if (!v24)
                    {
                      if (qword_1001DC8C0 != -1) {
                        dispatch_once(&qword_1001DC8C0, &stru_1001AF3E8);
                      }
                      id v103 = (id)qword_1001DC8B8;
                      int v104 = _NRLogIsLevelEnabled(v103, 17LL);

                      if (!v104) {
                        goto LABEL_187;
                      }
                      id v95 = v84;
                      if (qword_1001DC8C0 != -1) {
                        dispatch_once(&qword_1001DC8C0, &stru_1001AF3E8);
                      }
                      unsigned int v24 = v136;
                      id v102 = (id)qword_1001DC8B8;
                      _NRLogWithArgs(v102, 17LL, "%s called with null nrUUID");
                      goto LABEL_185;
                    }

                    if ((_NRIsUUIDNonZero(v89) & 1) == 0)
                    {
                      if (qword_1001DC8C0 != -1) {
                        dispatch_once(&qword_1001DC8C0, &stru_1001AF3E8);
                      }
                      id v105 = (id)qword_1001DC8B8;
                      int v106 = _NRLogIsLevelEnabled(v105, 17LL);

                      if (!v106) {
                        goto LABEL_187;
                      }
                      id v95 = v84;
                      if (qword_1001DC8C0 != -1) {
                        dispatch_once(&qword_1001DC8C0, &stru_1001AF3E8);
                      }
                      unsigned int v24 = v136;
                      id v102 = (id)qword_1001DC8B8;
                      _NRLogWithArgs(v102, 17LL, "called with all-zero nrUUID");
                      goto LABEL_185;
                    }

                    if (!v143)
                    {
                      if (qword_1001DC8C0 != -1) {
                        dispatch_once(&qword_1001DC8C0, &stru_1001AF3E8);
                      }
                      id v107 = (id)qword_1001DC8B8;
                      int v108 = _NRLogIsLevelEnabled(v107, 17LL);

                      if (!v108) {
                        goto LABEL_187;
                      }
                      id v95 = v84;
                      if (qword_1001DC8C0 != -1) {
                        dispatch_once(&qword_1001DC8C0, &stru_1001AF3E8);
                      }
                      unsigned int v24 = v136;
                      id v102 = (id)qword_1001DC8B8;
                      _NRLogWithArgs(v102, 17LL, "%s called with null localInterfaceName");
LABEL_185:

LABEL_186:
                      __int128 v99 = 0LL;
                      uint64_t v98 = objb;
                      goto LABEL_159;
                    }

                    v176.receiver = v81;
                    v176.super_class = (Class)&OBJC_CLASS___NRLinkWired;
                    id v93 = objc_msgSendSuper2(&v176, "initLinkWithQueue:linkDelegate:nrUUID:", v87, v88, v89);
                    if (!v93)
                    {
                      if (qword_1001DC8C0 != -1) {
                        dispatch_once(&qword_1001DC8C0, &stru_1001AF3E8);
                      }
                      id v109 = (id)qword_1001DC8B8;
                      int v110 = _NRLogIsLevelEnabled(v109, 17LL);

                      if (v110)
                      {
                        id v95 = v84;
                        if (qword_1001DC8C0 != -1) {
                          dispatch_once(&qword_1001DC8C0, &stru_1001AF3E8);
                        }
                        uint64_t v98 = objb;
                        id v111 = (id)qword_1001DC8B8;
                        _NRLogWithArgs(v111, 17LL, "[NRLink initLinkWithQueue:] failed");

                        uint64_t v81 = 0LL;
                        __int128 v99 = 0LL;
                        goto LABEL_159;
                      }

                      id v95 = v84;
                      uint64_t v81 = 0LL;
                      goto LABEL_186;
                    }

                    __int128 v94 = v93;
                    id v95 = v84;
                    [v93 setType:5];
                    [v94 setLocalInterfaceName:v90];
                    [v94 setLocalOuterEndpoint:objb];
                    [v94 setRemoteOuterEndpoint:v91];
                    [v94 setListenerPortString:v92];
                    [v94 setOnlyAllowClassC:1];
                    id v96 = (void *)objc_claimAutoreleasedReturnValue([v89 UUIDString]);
                    [v94 reportEvent:3000 details:v96];

                    id v97 = (void *)objc_claimAutoreleasedReturnValue([v94 linkDelegate]);
                    [v97 linkIsAvailable:v94];

                    uint64_t v98 = objb;
                    uint64_t v81 = v94;
                    __int128 v99 = v81;
LABEL_159:

                    if (v99)
                    {
                      int v34 = 1;
                      a1 = v133;
                      char v33 = v127;
                    }

                    else
                    {
                      [v131 reportEvent:3210];
                      a1 = v133;
                      char v33 = v127;
                      int v34 = v132;
                    }

                    uint64_t v58 = v128;
                    id v57 = v129;

LABEL_119:
                    uint64_t v59 = v134;
LABEL_120:
                    if ((id)++v59 == v57)
                    {
                      id v57 = [v130 countByEnumeratingWithState:&v148 objects:v178 count:16];
                      if (!v57)
                      {
LABEL_110:

                        uint64_t v54 = v126 + 1;
                        if ((id)(v126 + 1) != v124) {
                          goto LABEL_111;
                        }
                        id v124 = [v122 countByEnumeratingWithState:&v152 objects:v179 count:16];
                        if (v124) {
                          goto LABEL_109;
                        }
                        goto LABEL_103;
                      }

                      continue;
                    }

                    goto LABEL_121;
                  }
                }

                else
                {
                }

                goto LABEL_131;
              }
            }

            else
            {
LABEL_131:
            }

            break;
          }

          if (v62 == (id)++v64)
          {
            id v62 = [v60 countByEnumeratingWithState:&v144 objects:v177 count:16];
            if (!v62) {
              goto LABEL_141;
            }
            goto LABEL_128;
          }

          goto LABEL_133;
        }

        if (qword_1001DC8D0 != -1) {
          dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC8C8, 1LL))
        {
          if (qword_1001DC8D0 != -1) {
            dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
          }
          id v22 = (id)qword_1001DC8C8;
          uint64_t v115 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v24);
          _NRLogWithArgs( v22,  1LL,  "%s%.30s:%-4d deferring creating link until a peer is discovered for %@",  "",  "-[NRLinkManagerWired createLinkForNRUUIDs:]",  238LL,  v115);

LABEL_33:
        }

LABEL_35:
        uint64_t v21 = v116 + 1;
      }

      while ((id)(v116 + 1) != v114);
      id v114 = [v112 countByEnumeratingWithState:&v164 objects:v182 count:16];
    }

    while (v114);
  }
}

void sub_1000C7EE4(uint64_t a1)
{
  if ([*(id *)(a1 + 32) state] == 9)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2) {
      id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    }
    else {
      id WeakRetained = 0LL;
    }
    id v4 = WeakRetained;
    [WeakRetained linkIsSuspended:*(void *)(a1 + 32)];
  }

  else
  {
    if (qword_1001DC8D0 != -1) {
      dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC8C8, 16LL))
    {
      if (qword_1001DC8D0 != -1) {
        dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
      }
      _NRLogWithArgs( qword_1001DC8C8,  16LL,  "%s%.30s:%-4d %@: link %@ is not in suspended state anymore",  "",  "-[NRLinkManagerWired linkIsSuspended:]_block_invoke",  661LL,  *(void *)(a1 + 40),  *(void *)(a1 + 32));
    }
  }

void sub_1000C7FF4(uint64_t a1)
{
  if ([*(id *)(a1 + 32) state] == 8)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2) {
      id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    }
    else {
      id WeakRetained = 0LL;
    }
    id v4 = WeakRetained;
    [WeakRetained linkIsReady:*(void *)(a1 + 32)];
  }

  else
  {
    if (qword_1001DC8D0 != -1) {
      dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC8C8, 16LL))
    {
      if (qword_1001DC8D0 != -1) {
        dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
      }
      _NRLogWithArgs( qword_1001DC8C8,  16LL,  "%s%.30s:%-4d %@: link %@ is not in ready state anymore",  "",  "-[NRLinkManagerWired linkIsReady:]_block_invoke",  638LL,  *(void *)(a1 + 40),  *(void *)(a1 + 32));
    }
  }

void sub_1000C8104(uint64_t a1)
{
  if ([*(id *)(a1 + 32) state] == 1)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2) {
      id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    }
    else {
      id WeakRetained = 0LL;
    }
    id v4 = WeakRetained;
    [WeakRetained linkIsAvailable:*(void *)(a1 + 32)];
  }

  else
  {
    if (qword_1001DC8D0 != -1) {
      dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC8C8, 16LL))
    {
      if (qword_1001DC8D0 != -1) {
        dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
      }
      _NRLogWithArgs( qword_1001DC8C8,  16LL,  "%s%.30s:%-4d %@: link %@ is not in initial state anymore",  "",  "-[NRLinkManagerWired linkIsAvailable:]_block_invoke",  615LL,  *(void *)(a1 + 40),  *(void *)(a1 + 32));
    }
  }

void sub_1000C8214(uint64_t a1)
{
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  uint64_t v2 = (id)qword_1001DC870;
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    if (v2) {
      BOOL v4 = v2[8] != 0;
    }
    else {
      BOOL v4 = 0;
    }
    *(_BYTE *)(v3 + 32) = v4;
  }
}

void sub_1000C829C(uint64_t a1)
{
  if (a1)
  {
    id v2 = [*(id *)(a1 + 48) count];
    uint64_t v3 = *(void *)(a1 + 56);
    if (v2)
    {
      if (!v3)
      {
        v47.version = 0LL;
        memset(&v47.retain, 0, 24);
        v47.info = (void *)a1;
        SCDynamicStoreRef v4 = SCDynamicStoreCreate( kCFAllocatorDefault,  @"NRLinkManagerWired",  (SCDynamicStoreCallBack)sub_1000C879C,  &v47);
        *(void *)(a1 + 56) = v4;
        if (!v4)
        {
          id v25 = sub_1000C58FC();
          int IsLevelEnabled = _NRLogIsLevelEnabled(v25, 16LL);

          if (IsLevelEnabled)
          {
            id v27 = sub_1000C58FC();
            _NRLogWithArgs( v27,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (self.scdynamicStoreRef) != ((void *)0)",  "",  "-[NRLinkManagerWired setupSCDWatcher]",  564);
          }

          uint64_t v28 = _os_log_pack_size(12LL);
          id v22 = (char *)&v37 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v29 = *__error();
          uint64_t v24 = _os_log_pack_fill( v22,  v28,  v29,  &_mh_execute_header,  "%{public}s Assertion Failed: (self.scdynamicStoreRef) != ((void *)0)");
          goto LABEL_27;
        }

        SCDynamicStoreSetDisconnectCallBack(v4, sub_1000C8800);
      }

      uint64_t v38 = v3;
      uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      __int128 v43 = 0u;
      __int128 v44 = 0u;
      __int128 v45 = 0u;
      __int128 v46 = 0u;
      uint64_t v39 = a1;
      id v40 = *(id *)(a1 + 48);
      id v6 = [v40 countByEnumeratingWithState:&v43 objects:v48 count:16];
      if (v6)
      {
        id v7 = v6;
        uint64_t v8 = *(void *)v44;
        do
        {
          for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v44 != v8) {
              objc_enumerationMutation(v40);
            }
            id v10 = *(const __CFString **)(*((void *)&v43 + 1) + 8LL * (void)i);
            NetworkInterfaceEntity = (__CFString *)SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainState,  v10,  kSCEntNetIPv4);
            id v12 = (__CFString *)SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainState,  v10,  kSCEntNetIPv6);
            -[NSMutableArray addObject:](v5, "addObject:", NetworkInterfaceEntity);
            -[NSMutableArray addObject:](v5, "addObject:", v12);
          }

          id v7 = [v40 countByEnumeratingWithState:&v43 objects:v48 count:16];
        }

        while (v7);
      }

      if (SCDynamicStoreSetNotificationKeys(*(SCDynamicStoreRef *)(v39 + 56), (CFArrayRef)v5, 0LL))
      {
        if (v38
          || (uint64_t v13 = *(const __SCDynamicStore **)(v39 + 56),
              id v14 = (dispatch_queue_s *)*(id *)(v39 + 24),
              LODWORD(v13) = SCDynamicStoreSetDispatchQueue(v13, v14),
              v14,
              (_DWORD)v13))
        {
          id v15 = (dispatch_queue_s *)*(id *)(v39 + 24);
          v41[0] = _NSConcreteStackBlock;
          v41[1] = 3221225472LL;
          v41[2] = sub_1000C8944;
          v41[3] = &unk_1001B0720;
          v41[4] = v39;
          id v42 = v5;
          uint64_t v16 = v5;
          dispatch_async(v15, v41);

          return;
        }

        id v30 = sub_1000C58FC();
        int v31 = _NRLogIsLevelEnabled(v30, 16LL);

        if (v31)
        {
          id v32 = sub_1000C58FC();
          _NRLogWithArgs( v32,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: retval",  "",  "-[NRLinkManagerWired setupSCDWatcher]",  586);
        }

        uint64_t v33 = _os_log_pack_size(12LL);
        id v22 = (char *)&v37 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        int v34 = __error();
        uint64_t v35 = _os_log_pack_fill( v22,  v33,  *v34,  &_mh_execute_header,  "%{public}s Assertion Failed: retval");
        *(_DWORD *)uint64_t v35 = 136446210;
        *(void *)(v35 + 4) = "-[NRLinkManagerWired setupSCDWatcher]";
LABEL_31:
        id v36 = sub_1000C58FC();
        _NRLogAbortWithPack(v36, v22);
      }

      id v18 = sub_1000C58FC();
      int v19 = _NRLogIsLevelEnabled(v18, 16LL);

      if (v19)
      {
        id v20 = sub_1000C58FC();
        _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: retval",  "",  "-[NRLinkManagerWired setupSCDWatcher]",  582);
      }

      uint64_t v21 = _os_log_pack_size(12LL);
      id v22 = (char *)&v37 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v23 = *__error();
      uint64_t v24 = _os_log_pack_fill(v22, v21, v23, &_mh_execute_header, "%{public}s Assertion Failed: retval");
LABEL_27:
      *(_DWORD *)uint64_t v24 = 136446210;
      *(void *)(v24 + 4) = "-[NRLinkManagerWired setupSCDWatcher]";
      goto LABEL_31;
    }

    if (v3)
    {
      SCDynamicStoreSetDispatchQueue(*(SCDynamicStoreRef *)(a1 + 56), 0LL);
      uint64_t v17 = *(const void **)(a1 + 56);
      if (v17)
      {
        CFRelease(v17);
        *(void *)(a1 + 56) = 0LL;
      }
    }
  }

void sub_1000C879C(uint64_t a1, void *a2, void *a3)
{
  if (a3)
  {
    id v5 = a3;
    if (*((_DWORD *)v5 + 3) != 1004 && *((void *)v5 + 7) == a1)
    {
      id v6 = v5;
      sub_1000C89C8((uint64_t)v5, a2);
      id v5 = v6;
    }
  }

void sub_1000C8800(id a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = a2;
    SCDynamicStoreRef v4 = v3;
    if (*((_DWORD *)v3 + 3) != 1004 && v3[7] == a1)
    {
      if (qword_1001DC8D0 != -1) {
        dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC8C8, 16LL))
      {
        if (qword_1001DC8D0 != -1) {
          dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
        }
        _NRLogWithArgs(qword_1001DC8C8, 16LL, "%s%.30s:%-4d SCD server restarted", "", "scdDisconnectCallback", 537);
      }

      id v5 = (dispatch_queue_s *)v4[3];
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_1000C97A4;
      block[3] = &unk_1001B0A88;
      id v7 = v4;
      dispatch_async(v5, block);
    }
  }

void sub_1000C8944(uint64_t a1)
{
  os_log_t v1 = *(void **)(a1 + 32);
  if (v1)
  {
    uint64_t v2 = v1[7];
    uint64_t v3 = *(void **)(a1 + 40);
    SCDynamicStoreRef v4 = v1;
    if (*((_DWORD *)v4 + 3) != 1004 && v4[7] == v2)
    {
      id v5 = v4;
      sub_1000C89C8((uint64_t)v4, v3);
      SCDynamicStoreRef v4 = v5;
    }
  }

void sub_1000C89C8(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  if (a1) {
    SCDynamicStoreRef v4 = *(void **)(a1 + 24);
  }
  else {
    SCDynamicStoreRef v4 = 0LL;
  }
  id v5 = v4;
  dispatch_assert_queue_V2(v5);

  CFDictionaryRef v97 = SCDynamicStoreCopyMultiple(*(SCDynamicStoreRef *)(a1 + 56), v3, 0LL);
  if (qword_1001DC8D0 != -1) {
    dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC8C8, 1LL))
  {
    if (qword_1001DC8D0 != -1) {
      dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
    }
    _NRLogWithArgs( qword_1001DC8C8,  1LL,  "%s%.30s:%-4d SCD update for NRLinkManagerWired: %@",  "",  "-[NRLinkManagerWired processSCDUpdate:]",  401LL,  v97);
  }

  __int128 v101 = (id *)a1;
  __int128 v130 = 0u;
  __int128 v131 = 0u;
  __int128 v128 = 0u;
  __int128 v129 = 0u;
  id v6 = v3;
  id v7 = -[__CFArray countByEnumeratingWithState:objects:count:]( v6,  "countByEnumeratingWithState:objects:count:",  &v128,  v141,  16LL);
  if (v7)
  {
    id v8 = v7;
    int v9 = 0;
    char v10 = 0;
    uint64_t v11 = *(void *)v129;
    do
    {
      for (uint64_t i = 0LL; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v129 != v11) {
          objc_enumerationMutation(v6);
        }
        uint64_t v13 = *(void **)(*((void *)&v128 + 1) + 8LL * (void)i);
        else {
          v9 |= [v13 containsString:kSCEntNetIPv6];
        }
      }

      id v8 = -[__CFArray countByEnumeratingWithState:objects:count:]( v6,  "countByEnumeratingWithState:objects:count:",  &v128,  v141,  16LL);
    }

    while (v8);
  }

  else
  {
    LOBYTE(v9) = 0;
    char v10 = 0;
  }

  id v96 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
  id v14 = v101;
  id v89 = v6;
  if ((v10 & 1) != 0)
  {
    __int128 v126 = 0u;
    __int128 v127 = 0u;
    __int128 v124 = 0u;
    __int128 v125 = 0u;
    id v15 = v6;
    id v16 = -[__CFArray countByEnumeratingWithState:objects:count:]( v15,  "countByEnumeratingWithState:objects:count:",  &v124,  v140,  16LL);
    if (v16)
    {
      id v17 = v16;
      uint64_t v18 = 0LL;
      uint64_t v19 = *(void *)v125;
      CFStringRef v20 = kSCEntNetIPv4;
      uint64_t v21 = *(void *)v125;
      uint64_t v93 = *(void *)v125;
      __int128 v94 = v15;
      while (1)
      {
        if (v21 != v19) {
          objc_enumerationMutation(v15);
        }
        id v22 = *(void **)(*((void *)&v124 + 1) + 8 * v18);
        if ([v22 containsString:v20])
        {
          id obj = v17;
          __int128 v122 = 0u;
          __int128 v123 = 0u;
          __int128 v120 = 0u;
          __int128 v121 = 0u;
          id v23 = v14[6];
          id v24 = [v23 countByEnumeratingWithState:&v120 objects:v139 count:16];
          if (v24)
          {
            id v25 = v24;
            uint64_t v26 = *(void *)v121;
            while (2)
            {
              for (j = 0LL; j != v25; j = (char *)j + 1)
              {
                if (*(void *)v121 != v26) {
                  objc_enumerationMutation(v23);
                }
                uint64_t v28 = *(void *)(*((void *)&v120 + 1) + 8LL * (void)j);
                if ([v22 containsString:v28])
                {
                  -[NSMutableSet addObject:](v96, "addObject:", v28);
                  [v101[8] setObject:0 forKeyedSubscript:v28];
                  uint64_t v98 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKeyedSubscript:](v97, "objectForKeyedSubscript:", v22));
                  uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v98 objectForKeyedSubscript:kSCPropNetIPv4Addresses]);
                  id v100 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                  __int128 v116 = 0u;
                  __int128 v117 = 0u;
                  __int128 v118 = 0u;
                  __int128 v119 = 0u;
                  id v30 = v29;
                  id v31 = [v30 countByEnumeratingWithState:&v116 objects:v138 count:16];
                  if (v31)
                  {
                    unint64_t v32 = (unint64_t)v31;
                    uint64_t v33 = 0LL;
                    uint64_t v34 = *(void *)v117;
                    for (uint64_t k = *(void *)v117; ; uint64_t k = *(void *)v117)
                    {
                      if (k != v34) {
                        objc_enumerationMutation(v30);
                      }
                      id v36 = *(void **)(*((void *)&v116 + 1) + 8 * v33);
                      if (inet_pton(2, (const char *)[v36 UTF8String], &v133) == 1)
                      {
                        unsigned int v37 = bswap32(v133);
                        unsigned int v38 = v37 & 0xFF000000;
                        BOOL v41 = HIWORD(v37) == 43518 || v38 == 0 || v38 == 2130706432 || v37 >> 28 == 14;
                        unsigned int v42 = v37 & 0xFFFFFFF8;
                        if (v41 || v133 == -1 || v42 == -1073741824)
                        {
                          if (qword_1001DC8D0 != -1) {
                            dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
                          }
                          if (_NRLogIsLevelEnabled(qword_1001DC8C8, 1LL))
                          {
                            if (qword_1001DC8D0 != -1) {
                              dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
                            }
                            _NRLogWithArgs( qword_1001DC8C8,  1LL,  "%s%.30s:%-4d Ignoring ipv4 address: %@",  "",  "-[NRLinkManagerWired processSCDUpdate:]",  437LL,  v36);
                          }
                        }

                        else
                        {
                          __int128 v46 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v36,  @"0"));
                          -[NSMutableArray addObject:](v100, "addObject:", v46);
                        }
                      }

                      if (++v33 >= v32)
                      {
                        id v45 = [v30 countByEnumeratingWithState:&v116 objects:v138 count:16];
                        if (!v45) {
                          break;
                        }
                        unint64_t v32 = (unint64_t)v45;
                        uint64_t v33 = 0LL;
                      }
                    }
                  }

                  if (-[NSMutableArray count](v100, "count")) {
                    [v101[8] setObject:v100 forKeyedSubscript:v28];
                  }

                  goto LABEL_71;
                }
              }

              id v25 = [v23 countByEnumeratingWithState:&v120 objects:v139 count:16];
              if (v25) {
                continue;
              }
              break;
            }
          }

uint64_t sub_1000C97A4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2) {
    goto LABEL_13;
  }
  uint64_t v3 = *(const __SCDynamicStore **)(v2 + 56);
  if (!v3
    || (SCDynamicStoreSetDispatchQueue(v3, 0LL), (uint64_t v2 = *(void *)(a1 + 32)) != 0)
    && ((SCDynamicStoreRef v4 = *(const void **)(v2 + 56)) == 0LL
     || (CFRelease(v4), (uint64_t v5 = *(void *)(a1 + 32)) != 0)
     && (*(void *)(v5 + 56) = 0LL, (uint64_t v2 = *(void *)(a1 + 32)) != 0)))
  {
    id v6 = *(void **)(v2 + 64);
  }

  else
  {
LABEL_13:
    id v6 = 0LL;
  }

  [v6 removeAllObjects];
  uint64_t v7 = *(void *)(a1 + 32);
  if (v7) {
    id v8 = *(void **)(v7 + 72);
  }
  else {
    id v8 = 0LL;
  }
  [v8 removeAllObjects];
  uint64_t v9 = *(void *)(a1 + 32);
  if (v9) {
    char v10 = *(void **)(v9 + 80);
  }
  else {
    char v10 = 0LL;
  }
  [v10 removeAllObjects];
  return sub_1000C829C(*(void *)(a1 + 32));
}

void sub_1000C986C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  char v10 = v9;
  if (a1)
  {
    if (v9)
    {
      uint64_t v11 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      id v12 = (NRDWiredPeer *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 88) objectForKeyedSubscript:v9]);
      if (v7 && [v7 count])
      {
        if (v8)
        {
          uint64_t v35 = a1;
          id v36 = v10;
          if (!v12) {
            id v12 = objc_alloc_init(&OBJC_CLASS___NRDWiredPeer);
          }
          __int128 v41 = 0u;
          __int128 v42 = 0u;
          __int128 v39 = 0u;
          __int128 v40 = 0u;
          id v37 = v7;
          id obj = v7;
          id v13 = [obj countByEnumeratingWithState:&v39 objects:v43 count:16];
          if (v13)
          {
            id v14 = v13;
            uint64_t v15 = *(void *)v40;
            do
            {
              for (uint64_t i = 0LL; i != v14; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v40 != v15) {
                  objc_enumerationMutation(obj);
                }
                objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
                if (qword_1001DC640 != -1) {
                  dispatch_once(&qword_1001DC640, &stru_1001ADE98);
                }
                id v19 = (id)qword_1001DC638;
                CFStringRef v20 = @"62743";
                if (!v19) {
                  CFStringRef v20 = 0LL;
                }
                uint64_t v21 = v20;
                id v22 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v18,  v21));

                id v23 = (void *)objc_claimAutoreleasedReturnValue( -[NRDWiredPeer interfaceToPeerAddressDictionary]( v12,  "interfaceToPeerAddressDictionary"));
                id v24 = (void *)objc_claimAutoreleasedReturnValue([v23 objectForKeyedSubscript:v8]);

                if (!v24 || ([v24 containsObject:v22] & 1) == 0)
                {
                  id v25 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                  if ([v24 count]) {
                    -[NSMutableArray addObjectsFromArray:](v25, "addObjectsFromArray:", v24);
                  }
                  -[NSMutableArray addObject:](v25, "addObject:", v22);
                  id v17 = (void *)objc_claimAutoreleasedReturnValue( -[NRDWiredPeer interfaceToPeerAddressDictionary]( v12,  "interfaceToPeerAddressDictionary"));
                  [v17 setObject:v25 forKeyedSubscript:v8];
                }
              }

              id v14 = [obj countByEnumeratingWithState:&v39 objects:v43 count:16];
            }

            while (v14);
          }

          char v10 = v36;
          id v7 = v37;
          a1 = v35;
          uint64_t v11 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
        }
      }

      else if (v8)
      {
        uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(-[NRDWiredPeer interfaceToPeerAddressDictionary](v12, "interfaceToPeerAddressDictionary"));
        [v26 setObject:0 forKeyedSubscript:v8];
      }

      else
      {
        -[NRDWiredPeer setInterfaceToPeerAddressDictionary:](v12, "setInterfaceToPeerAddressDictionary:", 0LL);
      }

      id v27 = (void *)objc_claimAutoreleasedReturnValue(-[NRDWiredPeer interfaceToPeerAddressDictionary](v12, "interfaceToPeerAddressDictionary"));
      id v28 = [v27 count];

      if (v28) {
        uint64_t v29 = v12;
      }
      else {
        uint64_t v29 = 0LL;
      }
      [*(id *)(a1 + v11[559]) setObject:v29 forKeyedSubscript:v10];
      if (qword_1001DC8D0 != -1) {
        dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC8C8, 1LL))
      {
        if (qword_1001DC8D0 != -1) {
          dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
        }
        uint64_t v30 = *(void *)(a1 + v11[559]);
        id v31 = (id)qword_1001DC8C8;
        _NRLogWithArgs( v31,  1LL,  "%s%.30s:%-4d updated peer endpoint state %@",  "",  "-[NRLinkManagerWired setPeerEndpoints:interfaceName:nrUUID:]",  357LL,  v30);
      }

      sub_1000C9C88(a1);
    }

    else
    {
      id v32 = sub_1000C58FC();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v32, 17LL);

      if (IsLevelEnabled)
      {
        id v34 = sub_1000C58FC();
        _NRLogWithArgs( v34,  17LL,  "%s called with null nrUUID",  "-[NRLinkManagerWired setPeerEndpoints:interfaceName:nrUUID:]");
      }
    }
  }
}

void sub_1000C9C88(uint64_t a1)
{
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 88), "allValues", 0));
  id v4 = [v3 countByEnumeratingWithState:&v15 objects:v19 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v16;
    do
    {
      for (uint64_t i = 0LL; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v16 != v6) {
          objc_enumerationMutation(v3);
        }
        id v8 = *(void **)(*((void *)&v15 + 1) + 8LL * (void)i);
        id v9 = (void *)objc_claimAutoreleasedReturnValue([v8 interfaceToPeerAddressDictionary]);
        id v10 = [v9 count];

        if (v10)
        {
          uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v8 interfaceToPeerAddressDictionary]);
          id v12 = (void *)objc_claimAutoreleasedReturnValue([v11 allKeys]);
          -[NSMutableSet addObjectsFromArray:](v2, "addObjectsFromArray:", v12);
        }
      }

      id v5 = [v3 countByEnumeratingWithState:&v15 objects:v19 count:16];
    }

    while (v5);
  }

  if ([*(id *)(a1 + 48) isEqualToSet:v2])
  {
    id v13 = sub_100131A50((uint64_t)&OBJC_CLASS___NRDLocalDevice);
    if (-[NSMutableArray count](v13, "count")) {
      sub_1000C6BDC((void *)a1, v13);
    }
    id v14 = sub_1001317AC((uint64_t)&OBJC_CLASS___NRDLocalDevice);
    if (-[NSMutableArray count](v14, "count")) {
      sub_1000C6BDC((void *)a1, v14);
    }
  }

  else
  {
    objc_storeStrong((id *)(a1 + 48), v2);
    sub_1000C829C(a1);
  }
}

id sub_1000CA434()
{
  if (qword_1001DC8E0 != -1) {
    dispatch_once(&qword_1001DC8E0, &stru_1001AF428);
  }
  return (id)qword_1001DC8D8;
}

void sub_1000CA474(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC8D8;
  qword_1001DC8D8 = (uint64_t)v1;
}

LABEL_81:
}

LABEL_318:
        goto LABEL_319;
      }

      id v22 = sub_1000229A0(v20, 1LL);
      id v23 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v22, "firstObject"));

      p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
      id v25 = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
      if (v23)
      {
        uint64_t v26 = self->_nrUUID;
        id v28 = (void *)_NRCopyLogObjectForNRUUID(v26, v27);
        uint64_t v29 = _NRLogIsLevelEnabled(v28, 1LL);

        if (v29)
        {
          uint64_t v30 = self->_nrUUID;
          id v32 = (void *)_NRCopyLogObjectForNRUUID(v30, v31);
          _NRLogWithArgs( v32,  1LL,  "%s%.30s:%-4d Received hello message",  "",  "-[NRDDeviceConductor linkDidReceiveData:data:]",  6002);
        }

        if (self->_helloMessageReceivedOnce)
        {
          uint64_t v33 = self->_nrUUID;
          uint64_t v35 = (void *)_NRCopyLogObjectForNRUUID(v33, v34);
          id v36 = _NRLogIsLevelEnabled(v35, 1LL);

          if (v36)
          {
            id v37 = self->_nrUUID;
            __int128 v39 = (void *)_NRCopyLogObjectForNRUUID(v37, v38);
            _NRLogWithArgs( v39,  1LL,  "%s%.30s:%-4d The other side restarted",  "",  "-[NRDDeviceConductor linkDidReceiveData:data:]",  6008);
          }

          __int128 v40 = v437;
          dispatch_assert_queue_V2((dispatch_queue_t)self->_queue);
          __int128 v41 = (id *)sub_100021C64(objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage), self->_nrUUID);
          __int128 v42 = v41;
          if (v41)
          {
            objc_storeStrong(v41 + 3, a3);
            sub_1000222F4((uint64_t)v42, 1, 0LL);
          }

          sub_100023824((uint64_t)v42);
          self->_helloMessageSent = 1;

          objc_opt_self(&OBJC_CLASS___NRDKeyManager);
          if (qword_1001DCC18 != -1) {
            dispatch_once(&qword_1001DCC18, &stru_1001B0910);
          }
          __int128 v43 = (id)qword_1001DCC10;
          if (v43)
          {
            __int128 v44 = v43;
            dispatch_assert_queue_V2(*((dispatch_queue_t *)v43 + 2));
            if (!v44[10])
            {
              v44[10] = 1;
              if (v44[8] == 4)
              {
                sub_100143DD4((uint64_t)v44);
                if (v44[9])
                {
                  v44[8] = 3;
                  sub_100144044((uint64_t)v44);
                }
              }
            }

            id v45 = v44[8] & 0xFD;

            if (v45 == 1)
            {
              sub_1000DA884((uint64_t)self, @"Other side restarted", v46, v47, v48, v49, v50, v51, (uint64_t)v431);
              if (self->_isPreferWiFiProvider)
              {
                dispatch_assert_queue_V2((dispatch_queue_t)self->_queue);
                objc_opt_self(&OBJC_CLASS___NRLinkDirector);
                if (qword_1001DC878 != -1) {
                  dispatch_once(&qword_1001DC878, &stru_1001AEED0);
                }
                CFStringRef v52 = (id)qword_1001DC870;
                int v53 = v52;
                if (v52) {
                  uint64_t v54 = (void *)*((void *)v52 + 6);
                }
                else {
                  uint64_t v54 = 0LL;
                }
                uint64_t v55 = v54;

                if (v55)
                {
                  id v56 = (dispatch_queue_s *)v55[3];
                  dispatch_assert_queue_V2(v56);

                  id v57 = *((_DWORD *)v55 + 10) > 0;
                }

                else
                {
                  id v57 = 0;
                }

                self->_pendingPreferWiFiRequest = v57;
              }
            }
          }
        }

        else
        {
          self->_helloMessageReceivedOnce = 1;
        }
      }

      int v69 = v436;
      id v70 = sub_1000229A0(v436, 3LL);
      id v71 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v70, "firstObject"));

      if (v71
        || (int v72 = sub_1000229A0(v436, 2LL),
            BOOL v73 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v72, "firstObject")),
            v72,
            int v69 = v436,
            v73,
            v73))
      {
        self->_latestWiFiAddressUpdateMsgIdentifier = sub_100020CF0((uint64_t)v69);
      }

      id v7 = v437;
      if (self->_supportsAWDL)
      {
        id v74 = sub_1000229A0(v69, 10LL);
        id v75 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v74, "firstObject"));

        int v69 = v436;
        if (v75) {
          self->_latestAWDLAddressUpdateMsgIdentifier = sub_100020CF0((uint64_t)v436);
        }
      }

      uint64_t v76 = sub_1000229A0(v69, 7LL);
      id v77 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v76, "firstObject"));

      uint64_t v78 = v436;
      if (v77
        || (__int128 v79 = sub_1000229A0(v436, 13LL),
            id v80 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v79, "firstObject")),
            v79,
            uint64_t v78 = v436,
            v80,
            v80))
      {
        self->_latestPreferWiFiAckMsgIdentifier = sub_100020CF0((uint64_t)v78);
      }

      uint64_t v81 = sub_1000229A0(v78, 5LL);
      uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v81, "firstObject"));

      id v83 = v436;
      if (v82
        || (id v84 = sub_1000229A0(v436, 13LL),
            id v85 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v84, "firstObject")),
            v84,
            id v83 = v436,
            v85,
            v85))
      {
        self->_latestPreferWiFiRequestMsgIdentifier = sub_100020CF0((uint64_t)v83);
      }

      id v86 = sub_1000229A0(v83, 6LL);
      id v87 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v86, "firstObject"));

      if (v87) {
        self->_latestDeviceLinkStateMsgIdentifier = sub_100020CF0((uint64_t)v436);
      }
      id v88 = sub_1000229A0(v436, 15LL);
      id v89 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v88, "firstObject"));

      if (v89) {
        self->_latestCountryCodeMsgIdentifier = sub_100020CF0((uint64_t)v436);
      }
      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      id v90 = (id)qword_1001DC870;
      v486[0] = _NSConcreteStackBlock;
      v486[1] = 3221225472LL;
      v486[2] = sub_1000DBF8C;
      v486[3] = &unk_1001B0720;
      v486[4] = self;
      id v91 = v436;
      v487 = v91;
      sub_1000AEA84((uint64_t)v90, v486);

      __int128 v434 = v91;
      uint64_t v92 = sub_1000229A0(v91, 8LL);
      uint64_t v93 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v92, "firstObject"));

      if (v93 && !self->_handlesLinkRecommendations && !self->_didForceWoWMode)
      {
        if (!self->_forcedWoWUUID)
        {
          __int128 v94 = (NSUUID *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
          forcedWoWUUID = self->_forcedWoWUUID;
          self->_forcedWoWUUID = v94;
        }

        dispatch_assert_queue_V2((dispatch_queue_t)self->_queue);
        objc_opt_self(&OBJC_CLASS___NRLinkDirector);
        if (qword_1001DC878 != -1) {
          dispatch_once(&qword_1001DC878, &stru_1001AEED0);
        }
        id v96 = (id)qword_1001DC870;
        CFDictionaryRef v97 = v96;
        if (v96) {
          uint64_t v98 = (void *)*((void *)v96 + 6);
        }
        else {
          uint64_t v98 = 0LL;
        }
        __int128 v99 = v98;

        sub_100140F48((uint64_t)v99, 1, self->_forcedWoWUUID);
        dispatch_assert_queue_V2((dispatch_queue_t)self->_queue);
        objc_opt_self(&OBJC_CLASS___NRLinkDirector);
        if (qword_1001DC878 != -1) {
          dispatch_once(&qword_1001DC878, &stru_1001AEED0);
        }
        id v100 = (id)qword_1001DC870;
        __int128 v101 = v100;
        if (v100) {
          id v102 = (void *)*((void *)v100 + 6);
        }
        else {
          id v102 = 0LL;
        }
        id v103 = v102;

        sub_1001424C8(v103, 16LL, self->_forcedWoWUUID, &off_1001BCA40);
        __int128 v104 = dispatch_time(0x8000000000000000LL, 60000000000LL);
        dispatch_queue_t queue = self->_queue;
        objc_super block = _NSConcreteStackBlock;
        uint64_t v507 = 3221225472LL;
        uint64_t v508 = sub_1000E08E8;
        uint64_t v509 = &unk_1001B0A88;
        uint64_t v510 = self;
        dispatch_after(v104, (dispatch_queue_t)queue, &block);
        self->_didForceWoWMode = 1;
        sub_10011BB18(self->_nrUUID, 1029, 0LL, 0LL);
      }

      __int128 v106 = v434;
      __int128 v107 = sub_1000229A0(v434, 11LL);
      __int128 v108 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v107, "firstObject"));

      __int128 v433 = v108;
      if ((unint64_t)[v108 length] < 8)
      {
LABEL_109:
        uint64_t v459 = self;
        if (self->_supportsPathOverrides)
        {
          __int128 v118 = sub_1000229A0(v106, 12LL);
          __int128 v119 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v118, "firstObject"));

          if (v119)
          {
            __int128 v120 = sub_100015030((char *)objc_alloc(&OBJC_CLASS___NRNetInfo), v119);
            __int128 v122 = v120;
            else {
              sub_1000DD608((uint64_t)self);
            }
            __int128 v124 = v119;
            CC_SHA256([v124 bytes], (CC_LONG)objc_msgSend(v124, "length"), (unsigned __int8 *)&block);
            __int128 v123 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  &block,  32LL);
          }

          else
          {
            __int128 v122 = 0LL;
            __int128 v123 = 0LL;
          }

          __int128 v125 = self->_lastReceivedNetInfoDataHash;
          __int128 v126 = -[NSData isEqualToData:](v123, "isEqualToData:", v125);

          if (v126)
          {
            __int128 v127 = self->_nrUUID;
            __int128 v129 = (void *)_NRCopyLogObjectForNRUUID(v127, v128);
            __int128 v130 = _NRLogIsLevelEnabled(v129, 1LL);

            if (v130)
            {
              __int128 v131 = self->_nrUUID;
              unsigned int v133 = (void *)_NRCopyLogObjectForNRUUID(v131, v132);
              _NRLogWithArgs( v133,  1LL,  "%s%.30s:%-4d ignoring unchanged net-info update",  "",  "-[NRDDeviceConductor linkDidReceiveData:data:]",  6246);
            }
          }

          else if (v119)
          {
            uint64_t v134 = self->_nrUUID;
            id v136 = (void *)_NRCopyLogObjectForNRUUID(v134, v135);
            uint64_t v137 = _NRLogIsLevelEnabled(v136, 0LL);

            if (v137)
            {
              id v138 = self->_nrUUID;
              uint64_t v140 = (void *)_NRCopyLogObjectForNRUUID(v138, v139);
              [v119 length];
              __int128 v431 = "";
              _NRLogWithArgs(v140, 0LL, "%s%.30s:%-4d Received net-info: %@ (%lu bytes)");
            }

            sub_1000DD678((uint64_t)self, v122 == 0LL);
            if (v122)
            {
              __int128 v454 = v123;
              objc_storeStrong((id *)&self->_lastReceivedNetInfoDataHash, v123);
              unsigned int v141 = (void *)nw_path_override_info_create();
              nw_path_override_info_set_expensive(v141, (*((_DWORD *)v122 + 7) >> 3) & 1);
              nw_path_override_info_set_constrained(v141, (*((_DWORD *)v122 + 7) >> 4) & 1);
              nw_path_override_info_set_roaming(v141, (*((_DWORD *)v122 + 7) >> 5) & 1);
              nw_path_override_info_set_uses_wifi(v141, v122[16] == 1);
              nw_path_override_info_set_uses_cellular(v141, v122[16] == 2);
              id v142 = *((id *)v122 + 16);
              id v482 = 0u;
              int v483 = 0u;
              id v484 = 0u;
              v485 = 0u;
              id v143 = v142;
              __int128 v144 = [v143 countByEnumeratingWithState:&v482 objects:v497 count:16];
              if (v144)
              {
                __int128 v145 = v144;
                __int128 v146 = *(void *)v483;
                do
                {
                  for (uint64_t i = 0LL; i != v145; uint64_t i = (char *)i + 1)
                  {
                    if (*(void *)v483 != v146) {
                      objc_enumerationMutation(v143);
                    }
                    nw_path_override_info_add_resolver_config( v141,  *(void *)(*((void *)&v482 + 1) + 8LL * (void)i));
                  }

                  __int128 v145 = [v143 countByEnumeratingWithState:&v482 objects:v497 count:16];
                }

                while (v145);
              }

              __int128 v460 = v122;

              __int128 v148 = v459->_queue;
              __int128 v149 = nw_agent_create_with_path_override_info(v141, "NetworkRelay path overrides", v148);
              __int128 v150 = (void *)objc_claimAutoreleasedReturnValue(v149);
              objc_storeStrong((id *)&v459->_pathOverrideAgent, v150);

              __int128 v151 = v459->_pathOverrideAgent;
              __int128 v152 = (void *)nw_path_override_info_copy_data(v141);
              nw_agent_change_state(v151, 1LL, 1LL, v152);

              uint64_t v511 = 0uLL;
              __int128 v153 = v459->_pathOverrideAgent;
              nw_agent_get_uuid(v153, &v511);

              __int128 v154 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", &v511);
              __int128 v155 = v459->_nrUUID;
              __int128 v157 = (void *)_NRCopyLogObjectForNRUUID(v155, v156);
              __int128 v158 = _NRLogIsLevelEnabled(v157, 0LL);

              if (v158)
              {
                __int128 v159 = v459->_nrUUID;
                __int128 v161 = (void *)_NRCopyLogObjectForNRUUID(v159, v160);
                __int128 v431 = "";
                _NRLogWithArgs(v161, 0LL, "%s%.30s:%-4d Published net-info agent: %@");
              }

              __int128 v162 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  5LL,  6LL));
              id v451 = v154;
              [v162 setNetworkAgentUUID:v154];
              __int128 v163 = objc_alloc(&OBJC_CLASS___NEPolicy);
              v448 = v162;
              uint64_t v496 = v162;
              __int128 v164 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v496,  1LL));
              __int128 v165 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v164));
              __int128 v166 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
              char v495 = v166;
              __int128 v167 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v495,  1LL));
              __int128 v168 = [v163 initWithOrder:10 result:v165 conditions:v167];

              objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
              if (qword_1001DCB60 != -1) {
                dispatch_once(&qword_1001DCB60, &stru_1001B0538);
              }
              __int128 v122 = v460;
              __int128 v169 = (id)qword_1001DCB58;
              __int128 v170 = v459->_netInfoPolicyIdentifier;
              __int128 v171 = sub_100120E44((uint64_t)v169, v170, v168);

              __int128 v172 = v460;
              __int128 v173 = v172[5];
              __int128 v174 = v173;
              id v7 = v437;
              if (v173)
              {
                CC_SHA256([v173 bytes], (CC_LONG)objc_msgSend(v173, "length"), (unsigned __int8 *)&block);
                __int128 v175 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  &block,  32LL);
              }

              else
              {
                __int128 v175 = 0LL;
              }

              id v445 = v168;
              if (!-[NSData isEqualToData:](v459->_companionNWDescAgentDataHash, "isEqualToData:", v175))
              {
                id obj = v175;
                unsigned __int16 v443 = v172;
                if (!v459->_companionNWDescAgent)
                {
                  objc_super v176 = v459->_queue;
                  unsigned int v177 = nw_agent_create("com.apple.networkrelay", "CompanionNetworkDescription", "", v176);
                  companionNWDescAgent = v459->_companionNWDescAgent;
                  v459->_companionNWDescAgent = (OS_nw_agent *)v177;
                }

                uint64_t v179 = v172[5];

                if (v179)
                {
                  uint64_t v180 = v172[5];
                  __int128 v439 = dispatch_data_create( [v180 bytes],  (size_t)objc_msgSend(v180, "length"),  (dispatch_queue_t)v459->_queue,  0);
                }

                else
                {
                  __int128 v439 = 0LL;
                }

                objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                if (qword_1001DCB60 != -1) {
                  dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                }
                int v181 = (id)qword_1001DCB58;
                sub_10012114C((uint64_t)v181, v459->_companionNWDescPolicyIdentifier);

                nw_agent_change_state(v459->_companionNWDescAgent, 1LL, 1LL, v439);
                objc_storeStrong((id *)&v459->_companionNWDescAgentDataHash, v175);
                unsigned __int16 v498 = 0uLL;
                nw_agent_get_uuid(v459->_companionNWDescAgent, &v498);
                uint64_t v182 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", &v498);
                v183 = objc_alloc(&OBJC_CLASS___NEPolicy);
                int v184 = v182;
                id v185 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult netAgentUUID:](&OBJC_CLASS___NEPolicyResult, "netAgentUUID:", v182));
                id v186 = (void **)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
                objc_super block = v186;
                uint64_t v187 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition platformBinary](&OBJC_CLASS___NEPolicyCondition, "platformBinary"));
                uint64_t v507 = (uint64_t)v187;
                unsigned int v188 = (void (*)(uint64_t))objc_claimAutoreleasedReturnValue( +[NEPolicyCondition customEntitlement:]( &OBJC_CLASS___NEPolicyCondition,  "customEntitlement:",  @"com.apple.networkrelay.companionNetworkDescription"));
                uint64_t v508 = v188;
                uint64_t v189 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &block,  3LL));
                unsigned int v190 = [v183 initWithOrder:10 result:v185 conditions:v189];

                objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                if (qword_1001DCB60 != -1) {
                  dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                }
                __int128 v122 = v460;
                uint64_t v191 = (id)qword_1001DCB58;
                uint64_t v192 = sub_100120E44((uint64_t)v191, v459->_companionNWDescPolicyIdentifier, v190);

                id v7 = v437;
                __int128 v175 = obj;
                __int128 v172 = v443;
              }

              objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
              if (qword_1001DCB60 != -1) {
                dispatch_once(&qword_1001DCB60, &stru_1001B0538);
              }
              id v25 = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
              p_class_meths = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
              uint64_t v193 = (id)qword_1001DCB58;
              uint64_t v194 = (id *)v193;
              if (v193)
              {
                dispatch_assert_queue_V2(*((dispatch_queue_t *)v193 + 1));
                if (([v194[2] apply] & 1) == 0) {
                  sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v195,  v196,  v197,  (uint64_t)v431);
                }
              }

              if (*((_BYTE *)v172 + 9) && !v459->_hasNonCompanionClients) {
                sub_1000DD7C4((uint64_t)v459);
              }
              uint64_t v198 = v122[16] - 1;
              if (v198 <= 2)
              {
                int v199 = (const char *)dword_100156938[(char)v198];
                uint64_t v480 = 0u;
                v481 = 0u;
                id v478 = 0u;
                v479 = 0u;
                uint64_t v200 = v459->_availableLinks;
                uint64_t v201 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v200,  "countByEnumeratingWithState:objects:count:",  &v478,  v494,  16LL);
                if (v201)
                {
                  id v202 = v201;
                  int v203 = *(void *)v479;
                  do
                  {
                    for (j = 0LL; j != v202; j = (char *)j + 1)
                    {
                      if (*(void *)v479 != v203) {
                        objc_enumerationMutation(v200);
                      }
                      unsigned __int16 v205 = *(void **)(*((void *)&v478 + 1) + 8LL * (void)j);
                      if ([v205 virtualInterface])
                      {
                        uint64_t v206 = (void *)objc_claimAutoreleasedReturnValue([v205 proxyAgentUUID]);

                        if (v206) {
                          [v205 setInterfacePeerEgressFunctionalType:v199];
                        }
                      }
                    }

                    id v202 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v200,  "countByEnumeratingWithState:objects:count:",  &v478,  v494,  16LL);
                  }

                  while (v202);
                }

                __int128 v122 = v460;
                id v7 = v437;
                id v25 = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
                p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
                if (v459->_catchAllInterface)
                {
                  id v207 = v459->_proxyAgentUUID;

                  if (v207)
                  {
                    catchAllInterface = v459->_catchAllInterface;
                    if (catchAllInterface) {
                      id v209 = (void *)NEVirtualInterfaceCopyName(catchAllInterface);
                    }
                    else {
                      id v209 = 0LL;
                    }
                    sub_1001022B8(v209, v199);
                  }
                }
              }

              __int128 v123 = v454;
              self = v459;
            }

            else
            {
              sub_1000DD8EC((uint64_t)self);
            }

            sub_1000DDA30((uint64_t)self, 1);
          }

          __int128 v106 = v434;
        }

        id v210 = sub_1000229A0(v106, 6LL);
        unsigned int v211 = v210;
        if (v210 && -[NSMutableArray count](v210, "count"))
        {
          v501 = 0u;
          v500 = 0u;
          uint64_t v499 = 0u;
          unsigned __int16 v498 = 0u;
          uint64_t v212 = v211;
          uint64_t v213 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v212,  "countByEnumeratingWithState:objects:count:",  &v498,  &block,  16LL);
          if (v213)
          {
            uint64_t v214 = v213;
            id v215 = 0LL;
            id v216 = *(void *)v499;
            do
            {
              for (uint64_t k = 0LL; k != v214; uint64_t k = (char *)k + 1)
              {
                if (*(void *)v499 != v216) {
                  objc_enumerationMutation(v212);
                }
                id v220 = *(void **)(*((void *)&v498 + 1) + 8LL * (void)k);
                LOBYTE(v511) = 0;
                else {
                  char v221 = 1LL;
                }
                [v220 getBytes:&v511 length:v221];
                if (!v215) {
                  id v215 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                }
                else {
                  int v218 = 0x202020504020100uLL >> (8 * v511);
                }
                id v219 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  v218 & 7));
                -[NSMutableArray addObject:](v215, "addObject:", v219);
              }

              uint64_t v214 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v212,  "countByEnumeratingWithState:objects:count:",  &v498,  &block,  16LL);
            }

            while (v214);

            if (v215)
            {
              id v7 = v437;
              __int128 v106 = v434;
              if (-[NSMutableArray count](v215, "count"))
              {
                id v476 = 0u;
                int v477 = 0u;
                uint64_t v474 = 0u;
                v475 = 0u;
                id v322 = v215;
                id v323 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v322,  "countByEnumeratingWithState:objects:count:",  &v474,  v493,  16LL);
                id v450 = v322;
                if (v323)
                {
                  uint64_t v324 = v323;
                  int v325 = 0;
                  int v463 = 0;
                  uint64_t v326 = *(void *)v475;
                  while (1)
                  {
                    id v327 = 0LL;
                    __int128 v457 = v325;
                    uint64_t v328 = -v325;
                    do
                    {
                      if (*(void *)v475 != v326) {
                        objc_enumerationMutation(v322);
                      }
                      int v329 = [*(id *)(*((void *)&v474 + 1) + 8 * (void)v327) unsignedShortValue];
                      StringFromNRLinkType = (void *)createStringFromNRLinkType(v329);
                      uint64_t v331 = v459->_nrUUID;
                      unsigned __int16 v333 = (void *)_NRCopyLogObjectForNRUUID(v331, v332);
                      unsigned __int16 v334 = _NRLogIsLevelEnabled(v333, 0LL);

                      if (v328 == (_DWORD)v327)
                      {
                        int v463 = v329;
                        if (v334)
                        {
                          uint64_t v335 = v459->_nrUUID;
                          id v337 = (void *)_NRCopyLogObjectForNRUUID(v335, v336);
                          _NRLogWithArgs( v337,  0LL,  "%s%.30s:%-4d Peer has link: %@ (PRIMARY)",  "",  "-[NRDDeviceConductor linkDidReceiveData:data:]",  6330LL,  StringFromNRLinkType);
                          int v463 = v329;
LABEL_326:
                        }
                      }

                      else if (v334)
                      {
                        uint64_t v335 = v459->_nrUUID;
                        id v337 = (void *)_NRCopyLogObjectForNRUUID(v335, v338);
                        _NRLogWithArgs( v337,  0LL,  "%s%.30s:%-4d Peer has link: %@",  "",  "-[NRDDeviceConductor linkDidReceiveData:data:]",  6332LL,  StringFromNRLinkType);
                        goto LABEL_326;
                      }

                      id v327 = (char *)v327 + 1;
                      id v322 = v450;
                    }

                    while (v324 != v327);
                    int v325 = v457 + (_DWORD)v324;
                    uint64_t v324 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v450,  "countByEnumeratingWithState:objects:count:",  &v474,  v493,  16LL);
                    if (!v324) {
                      goto LABEL_343;
                    }
                  }
                }

                int v463 = 0;
LABEL_343:

                dispatch_time_t v339 = sub_1000229A0(v434, 6LL);
                id v340 = v339;
                if (v339 && -[NSMutableArray count](v339, "count"))
                {
                  v501 = 0u;
                  v500 = 0u;
                  uint64_t v499 = 0u;
                  unsigned __int16 v498 = 0u;
                  v341 = v340;
                  uint64_t v342 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v341,  "countByEnumeratingWithState:objects:count:",  &v498,  &block,  16LL);
                  if (v342)
                  {
                    int v343 = v342;
                    int v344 = 0LL;
                    int v345 = *(void *)v499;
                    do
                    {
                      for (m = 0LL; m != v343; m = (char *)m + 1)
                      {
                        if (*(void *)v499 != v345) {
                          objc_enumerationMutation(v341);
                        }
                        id v349 = *(void **)(*((void *)&v498 + 1) + 8LL * (void)m);
                        LOBYTE(v511) = 0;
                        else {
                          int v350 = 1LL;
                        }
                        [v349 getBytes:&v511 length:v350];
                        if (!v344) {
                          int v344 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                        }
                        else {
                          id v347 = 0x6867660000650000uLL >> (8 * v511);
                        }
                        char v348 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  v347));
                        -[NSMutableArray addObject:](v344, "addObject:", v348);
                      }

                      int v343 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v341,  "countByEnumeratingWithState:objects:count:",  &v498,  &block,  16LL);
                    }

                    while (v343);
                  }

                  else
                  {
                    int v344 = 0LL;
                  }
                }

                else
                {
                  int v344 = 0LL;
                }

                id v470 = 0u;
                v471 = 0u;
                uint64_t v472 = 0u;
                v473 = 0u;
                __int128 v453 = v344;
                int v351 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v453,  "countByEnumeratingWithState:objects:count:",  &v470,  v492,  16LL);
                self = v459;
                if (v351)
                {
                  uint64_t v352 = v351;
                  id v353 = 0;
                  __int128 v458 = 0;
                  uint32_t v354 = *(void *)v471;
                  while (1)
                  {
                    id v355 = 0LL;
                    uint64_t v447 = v353;
                    int v356 = -v353;
                    do
                    {
                      if (*(void *)v471 != v354) {
                        objc_enumerationMutation(v453);
                      }
                      id v360 = [*(id *)(*((void *)&v470 + 1) + 8 * (void)v355) unsignedShortValue];
                      StringFromNRLinkSubtype = (void *)createStringFromNRLinkSubtype(v360);
                      v362 = self->_nrUUID;
                      id v364 = (void *)_NRCopyLogObjectForNRUUID(v362, v363);
                      id v365 = _NRLogIsLevelEnabled(v364, 0LL);

                      if (v356 == (_DWORD)v355 && v360)
                      {
                        __int128 v458 = v360;
                        self = v459;
                        if (v365)
                        {
                          id v357 = v459->_nrUUID;
                          v359 = (void *)_NRCopyLogObjectForNRUUID(v357, v366);
                          _NRLogWithArgs( v359,  0LL,  "%s%.30s:%-4d Peer has link subtype: %@ (PRIMARY)",  "",  "-[NRDDeviceConductor linkDidReceiveData:data:]",  6347LL,  StringFromNRLinkSubtype);
                          __int128 v458 = v360;
                          goto LABEL_371;
                        }
                      }

                      else
                      {
                        if (v365)
                        {
                          self = v459;
                          id v357 = v459->_nrUUID;
                          v359 = (void *)_NRCopyLogObjectForNRUUID(v357, v358);
                          _NRLogWithArgs( v359,  0LL,  "%s%.30s:%-4d Peer has link subtype: %@",  "",  "-[NRDDeviceConductor linkDidReceiveData:data:]",  6349LL,  StringFromNRLinkSubtype);
LABEL_371:

                          goto LABEL_372;
                        }

                        self = v459;
                      }

LABEL_415:
                    sub_1000D8FF0((uint64_t)self);
                  }

LABEL_416:
                  id v468 = 0u;
                  int v469 = 0u;
                  int v466 = 0u;
                  id v467 = 0u;
                  __int128 v421 = self->_availableLinks;
                  __int128 v422 = -[NSMutableSet copy](v421, "copy");

                  __int128 v423 = [v422 countByEnumeratingWithState:&v466 objects:v491 count:16];
                  if (v423)
                  {
                    __int128 v424 = v423;
                    __int128 v425 = *(void *)v467;
                    do
                    {
                      for (n = 0LL; n != v424; n = (char *)n + 1)
                      {
                        if (*(void *)v467 != v425) {
                          objc_enumerationMutation(v422);
                        }
                        __int128 v427 = *(void **)(*((void *)&v466 + 1) + 8LL * (void)n);
                        if ([v427 state] == 8)
                        {
                          __int128 v428 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( NSNumber,  "numberWithUnsignedChar:",  [v427 type]));
                          if (!-[NSMutableArray containsObject:](v450, "containsObject:", v428)
                            || [v427 subtype]
                            && (v429 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( NSNumber,  "numberWithUnsignedChar:",  [v427 subtype])),  __int128 v430 = -[NSMutableArray containsObject:](v453, "containsObject:", v429),  v429,  (v430 & 1) == 0))
                          {
                            [v427 checkPeerAvailabilityWithForceAggressive:1];
                          }

                          id v7 = v437;
                        }
                      }

                      __int128 v424 = [v422 countByEnumeratingWithState:&v466 objects:v491 count:16];
                    }

                    while (v424);
                  }

                  __int128 v106 = v434;
                  id v25 = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
                  p_class_meths = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
                  id v215 = v450;
                  goto LABEL_196;
                }

                dispatch_assert_queue_V2((dispatch_queue_t)self->_queue);
                unint64_t v404 = sub_1000D8B90((uint64_t)self, 2, 101);
                id v405 = v404;
                if (v404 && [v404 state] == 8)
                {
                  id v406 = v405;
                }

                else
                {
                  id v406 = sub_1000D8B90((uint64_t)self, 2, 102);
                }

                sub_1000D8254((uint64_t)self);
LABEL_404:

                goto LABEL_416;
              }

              self = v459;
            }

            else
            {
              id v7 = v437;
              self = v459;
              __int128 v106 = v434;
            }
          }

          else
          {

            id v215 = 0LL;
            __int128 v106 = v434;
          }
        }

        else
        {

          id v215 = 0LL;
        }

LABEL_196:
        char v222 = sub_1000229A0(v106, 14LL);
        uint64_t v223 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v222, "firstObject"));

        if (v223)
        {
          uint64_t v224 = sub_1000229A0(v106, 14LL);
          uint64_t v225 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v224, "firstObject"));

          LOBYTE(block) = 0;
          if ([v225 length] && (objc_msgSend(v225, "getBytes:length:", &block, 1), (_BYTE)block))
          {
            if (block >= 0xBu)
            {
              if (block >= 0x15u)
              {
                else {
                  int v226 = 30;
                }
              }

              else
              {
                int v226 = 20;
              }
            }

            else
            {
              int v226 = 10;
            }
          }

          else
          {
            int v226 = 0;
          }

          self->_lastSeenPeerThermalPressure = v226;
          __int128 v106 = v434;
          if (self->_lastReportedPeerThermalPressure != v226) {
            sub_1000DAF94((uint64_t)self);
          }
        }

        BOOL v227 = sub_1000229A0(v106, 22LL);
        id v228 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v227, "firstObject"));

        if (v228)
        {
          BOOL v229 = sub_1000229A0(v106, 22LL);
          id v230 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v229, "firstObject"));

          if (v230 && [v230 length])
          {
            LOBYTE(block) = 0;
            [v230 getBytes:&block length:1];
            v231 = (block & 1) != 0 ? &__kCFBooleanTrue : &__kCFBooleanFalse;
          }

          else
          {
            v231 = 0LL;
          }

          id v232 = [v231 BOOLValue];
          self->_lastSeenPeerPluggedInState = v232;
          __int128 v106 = v434;
          if (v232 != self->_lastReportedPluggedInState) {
            sub_1000DAF94((uint64_t)self);
          }
        }

        id v233 = sub_1000229A0(v106, 16LL);
        int v234 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v233, "firstObject"));

        if (v234) {
          goto LABEL_217;
        }
        id v235 = sub_1000229A0(v106, 18LL);
        uint64_t v236 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v235, "firstObject"));

        if (v236) {
          goto LABEL_217;
        }
        uint64_t v237 = sub_1000229A0(v106, 17LL);
        uint64_t v238 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v237, "firstObject"));

        if (v238
          || (uint64_t v239 = sub_1000229A0(v106, 19LL),
              uint64_t v240 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v239, "firstObject")),
              v239,
              v240,
              v240))
        {
LABEL_217:
          objc_opt_self(&OBJC_CLASS___NRDKeyManager);
          if (p_class_meths[387] != (__objc2_meth_list *)-1LL) {
            dispatch_once(&qword_1001DCC18, &stru_1001B0910);
          }
          __int128 v106 = v434;
          unsigned int v241 = v25[386];
          v464[0] = _NSConcreteStackBlock;
          v464[1] = 3221225472LL;
          v464[2] = sub_1000DE104;
          v464[3] = &unk_1001B0720;
          v464[4] = self;
          id v465 = v434;
          sub_100144478((uint64_t)v241, v464);
        }

        uint64_t v242 = sub_1000229A0(v106, 20LL);
        uint64_t v243 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v242, "firstObject"));

        uint64_t v449 = v215;
        if (v243)
        {
          uint64_t v244 = sub_1000229A0(v106, 20LL);
          id v245 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v244, "firstObject"));

          if (self)
          {
            __int128 v455 = v245;
            uint64_t v246 = sub_1000DEBD4(v245);
            uint64_t v248 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v247);
            int v249 = _NRLogIsLevelEnabled(v248, 1LL);

            if (v249)
            {
              id v251 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v250);
              _NRLogWithArgs( v251,  1LL,  "%s%.30s:%-4d received resolve request %@",  "",  "-[NRDDeviceConductor handleIncomingResolveRequest:]",  8625LL,  v246);
            }

            v501 = 0u;
            v500 = 0u;
            uint64_t v499 = 0u;
            unsigned __int16 v498 = 0u;
            id v252 = v246;
            int v253 = [v252 countByEnumeratingWithState:&v498 objects:&block count:16];
            if (v253)
            {
              int v254 = v253;
              __int128 v461 = *(void *)v499;
              do
              {
                for (iuint64_t i = 0LL; ii != v254; iuint64_t i = (char *)ii + 1)
                {
                  if (*(void *)v499 != v461) {
                    objc_enumerationMutation(v252);
                  }
                  id v258 = *(void **)(*((void *)&v498 + 1) + 8LL * (void)ii);
                  int v259 = (void *)objc_claimAutoreleasedReturnValue([v252 objectForKeyedSubscript:v258]);
                  uint64_t v260 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                  *(void *)&uint64_t v511 = _NSConcreteStackBlock;
                  *((void *)&v511 + 1) = 3221225472LL;
                  *(void *)&uint64_t v512 = sub_1000DFA50;
                  *((void *)&v512 + 1) = &unk_1001AF650;
                  *(void *)&id v513 = v260;
                  id v261 = v260;
                  nw_array_apply(v259, &v511);
                  id v262 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
                  [v262 getUUIDBytes:&v502];

                  id v263 = (void *)nw_endpoint_create_application_service([v258 UTF8String], &v502);
                  nw_endpoint_set_public_keys(v263, v261);
                  sub_1000D2CC0((uint64_t)self, v263);
                  asClient = self->_asClient;
                  v265 = v258;
                  id v266 = v263;
                  if (asClient && !asClient->_cancelled)
                  {
                    if ((-[NSMutableArray containsObject:]( asClient->_asNamesForIncomingResolveRequests,  "containsObject:",  v265) & 1) == 0) {
                      -[NSMutableArray addObject:](asClient->_asNamesForIncomingResolveRequests, "addObject:", v265);
                    }
                    objc_opt_self(&OBJC_CLASS___NRApplicationServiceManager);
                    if (qword_1001DC930 != -1) {
                      dispatch_once(&qword_1001DC930, &stru_1001AF7E0);
                    }
                    int v267 = (id *)qword_1001DC928;
                    uint64_t v268 = (nw_endpoint *)v266;
                    uint64_t v269 = v268;
                    if (!v267) {
                      goto LABEL_230;
                    }
                    if (v268)
                    {
                      if (nw_endpoint_get_type(v268) != 6)
                      {
                        if (qword_1001DC940 != -1) {
                          dispatch_once(&qword_1001DC940, &stru_1001AF878);
                        }
                        if (_NRLogIsLevelEnabled(qword_1001DC938, 16LL))
                        {
                          if (qword_1001DC940 != -1) {
                            dispatch_once(&qword_1001DC940, &stru_1001AF878);
                          }
                          _NRLogWithArgs( qword_1001DC938,  16LL,  "%s%.30s:%-4d invalid endpoint type %@",  "",  "-[NRApplicationServiceManager addIncomingResolveRequestForEndpoint:]",  625LL,  v269);
                        }

                        goto LABEL_230;
                      }

                      id v256 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  nw_endpoint_get_application_service_name(v269));
                      id v257 = (id)objc_claimAutoreleasedReturnValue(v256);
                      [v267[7] setObject:v269 forKeyedSubscript:v257];
                      sub_1000F4F4C(v267);
                    }

                    else
                    {
                      if (qword_1001DC940 != -1) {
                        dispatch_once(&qword_1001DC940, &stru_1001AF878);
                      }
                      id v270 = (id)qword_1001DC938;
                      id v271 = _NRLogIsLevelEnabled(v270, 17LL);

                      if (!v271) {
                        goto LABEL_230;
                      }
                      if (qword_1001DC940 != -1) {
                        dispatch_once(&qword_1001DC940, &stru_1001AF878);
                      }
                      id v257 = (id)qword_1001DC938;
                      _NRLogWithArgs( v257,  17LL,  "%s called with null asEndpoint",  "-[NRApplicationServiceManager addIncomingResolveRequestForEndpoint:]");
                    }

LABEL_230:
                  }

                  self = v459;
                }

                int v254 = [v252 countByEnumeratingWithState:&v498 objects:&block count:16];
              }

              while (v254);
            }

            sub_1000DED4C((uint64_t)self, 1);
            id v215 = v449;
            id v245 = v455;
          }

          id v7 = v437;
          __int128 v106 = v434;
        }

        int v272 = sub_1000229A0(v106, 21LL);
        id v273 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v272, "firstObject"));

        if (v273)
        {
          id v274 = sub_1000229A0(v106, 21LL);
          id v275 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v274, "firstObject"));

          id v276 = v275;
          if (self)
          {
            id v277 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, self->_nrUUID);
            __int128 v432 = v276;
            unint64_t v278 = sub_1000DEBD4(v276);
            uint64_t v280 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v279);
            uint64_t v281 = _NRLogIsLevelEnabled(v280, 1LL);

            if (v281)
            {
              v283 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v282);
              _NRLogWithArgs( v283,  1LL,  "%s%.30s:%-4d received resolve response %@",  "",  "-[NRDDeviceConductor handleIncomingResolveResponse:]",  8539LL,  v278);
            }

            v505 = 0u;
            uint64_t v504 = 0u;
            v503 = 0u;
            v502 = 0u;
            uint64_t v284 = v278;
            unsigned __int128 v456 = [v284 countByEnumeratingWithState:&v502 objects:&v498 count:16];
            if (v456)
            {
              __int128 v452 = *(id *)v503;
              uint64_t v285 = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
              __int128 v438 = v284;
              __int128 v440 = v277;
              do
              {
                unsigned int v286 = 0LL;
                do
                {
                  if (*(id *)v503 != v452) {
                    objc_enumerationMutation(v284);
                  }
                  uint64_t v290 = *(void **)(*((void *)&v502 + 1) + 8 * v286);
                  id v291 = self->_asClient;
                  unsigned __int8 v292 = v291;
                  __int128 v462 = v286;
                  if (v291) {
                    asNamesForResolving = v291->_asNamesForResolving;
                  }
                  else {
                    asNamesForResolving = 0LL;
                  }
                  uint64_t v294 = asNamesForResolving;
                  unint64_t v295 = -[NSMutableArray containsObject:](v294, "containsObject:", v290);

                  if (v295)
                  {
                    -[NSMutableDictionary setObject:forKeyedSubscript:]( self->_asNamesToResolvedEndpoints,  "setObject:forKeyedSubscript:",  0LL,  v290);
                    id v296 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                    int v297 = (void *)objc_claimAutoreleasedReturnValue([v284 objectForKeyedSubscript:v290]);
                    v488[0] = _NSConcreteStackBlock;
                    v488[1] = 3221225472LL;
                    v488[2] = sub_1000DECB4;
                    v488[3] = &unk_1001AF628;
                    v488[4] = self;
                    id v489 = v277;
                    int v490 = v296;
                    int v288 = v296;
                    nw_array_apply(v297, v488);
                    -[NSMutableDictionary setObject:forKeyedSubscript:]( self->_asNamesToResolvedEndpoints,  "setObject:forKeyedSubscript:",  v288,  v290);
                    uint64_t v298 = self->_asClient;
                    unsigned __int8 v289 = v290;
                    uint64_t v287 = v297;
                    if (v298 && !v298->_cancelled)
                    {
                      objc_opt_self(&OBJC_CLASS___NRApplicationServiceManager);
                      if (qword_1001DC930 != -1) {
                        dispatch_once(&qword_1001DC930, &stru_1001AF7E0);
                      }
                      id v299 = qword_1001DC928;
                      v446 = v289;
                      uint64_t v300 = v289;
                      id v301 = v287;
                      id v302 = v301;
                      if (v299)
                      {
                        if (v301)
                        {
                          dispatch_assert_queue_V2(*(dispatch_queue_t *)(v299 + 8));
                          int v303 = (id)objc_claimAutoreleasedReturnValue([*(id *)(v299 + 40) objectForKeyedSubscript:v300]);
                          if ([v303 count])
                          {
                            id obja = v287;
                            v444 = v288;
                            id v513 = 0u;
                            int v514 = 0u;
                            uint64_t v511 = 0u;
                            uint64_t v512 = 0u;
                            int v303 = v303;
                            uint64_t v304 = [v303 countByEnumeratingWithState:&v511 objects:&block count:16];
                            if (v304)
                            {
                              uint64_t v305 = v304;
                              uint64_t v306 = *(void *)v512;
                              do
                              {
                                for (jj = 0LL; jj != v305; jj = (char *)jj + 1)
                                {
                                  if (*(void *)v512 != v306) {
                                    objc_enumerationMutation(v303);
                                  }
                                  v312 = *(void *)(*((void *)&v511 + 1) + 8LL * (void)jj);
                                  if (!v312 || !*(_BYTE *)(v312 + 48))
                                  {
                                    if (v285[296] != (__objc2_meth_list *)-1LL) {
                                      dispatch_once(&qword_1001DC940, &stru_1001AF878);
                                    }
                                    if (v285[296] == (__objc2_meth_list *)-1LL)
                                    {
                                      int v308 = (void *)qword_1001DC938;
                                      if (!v312)
                                      {
LABEL_302:
                                        v309 = 0LL;
LABEL_288:
                                        id v310 = v308;
                                        _NRLogWithArgs( v310,  2LL,  "%s%.30s:%-4d triggering resolve response block for %@ (%p) with endpoints %@",  "",  "-[NRApplicationServiceManager reportResolveResultForASName:endpoint:]",  357LL,  v300,  v309,  v302);

                                        uint64_t v285 = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
LABEL_289:
                                        if (v312)
                                        {
                                          *(_BYTE *)(v312 + 4_Block_object_dispose((const void *)(v29 - 80), 8) = 1;
                                          uint64_t v311 = *(void *)(v312 + 56);
                                        }

                                        else
                                        {
                                          uint64_t v311 = 0LL;
                                        }

                                        (*(void (**)(uint64_t, void *))(v311 + 16))(v311, v302);
                                        continue;
                                      }
                                    }

                                    else
                                    {
                                      dispatch_once(&qword_1001DC940, &stru_1001AF878);
                                      int v308 = (void *)qword_1001DC938;
                                      if (!v312) {
                                        goto LABEL_302;
                                      }
                                    }

                                    v309 = *(void *)(v312 + 40);
                                    goto LABEL_288;
                                  }
                                }

                                uint64_t v305 = [v303 countByEnumeratingWithState:&v511 objects:&block count:16];
                              }

                              while (v305);
                            }

                            self = v459;
                            uint64_t v287 = obja;
                            int v288 = v444;
                          }

  uint64_t v180 = [v124 BOOLValue];
  int v181 = "dis";
  if (v180) {
    int v181 = "en";
  }
  sub_1000D4F78( *(void *)(a1 + 32),  1008,  @"received prefer Wi-Fi request: %sable",  v175,  v176,  v177,  v178,  v179,  (uint64_t)v181);
  v183 = *(void *)(a1 + 32);
  if (!v180)
  {
    if (v183) {
      v183 = *(void *)(v183 + 96);
    }
    int v199 = (void *)_NRCopyLogObjectForNRUUID(v183, v182);
    uint64_t v200 = _NRLogIsLevelEnabled(v199, 0LL);

    if (v200)
    {
      id v202 = *(void *)(a1 + 32);
      if (v202) {
        int v203 = *(void *)(v202 + 96);
      }
      else {
        int v203 = 0LL;
      }
      id v204 = (void *)_NRCopyLogObjectForNRUUID(v203, v201);
      _NRLogWithArgs( v204,  0LL,  "%s%.30s:%-4d Disable prefer Wi-Fi request",  "",  "-[NRDDeviceConductor linkDidReceiveData:data:]_block_invoke",  6187);
    }

    unsigned __int16 v205 = *(void *)(a1 + 32);
    if (v205)
    {
      *(_BYTE *)(v205 + 25) = 0;
      v183 = *(void *)(a1 + 32);
      if (v127) {
        goto LABEL_225;
      }
    }

    else
    {
      v183 = 0LL;
      if (v127) {
        goto LABEL_225;
      }
    }

LABEL_108:
      __int128 v106 = v434;
      goto LABEL_109;
    }

    id v62 = (void *)_NRCopyLogObjectForNRUUID(nrUUID, v9);
    uint64_t v63 = _NRLogIsLevelEnabled(v62, 16LL);

    if (v63)
    {
      uint64_t v61 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v64);
      _NRLogWithArgs( v61,  16LL,  "%s%.30s:%-4d Ignoring link receive data event as link was cancelled %@",  "",  "-[NRDDeviceConductor linkDidReceiveData:data:]",  5988LL,  v7);
      goto LABEL_34;
    }
  }

  else
  {
    id v58 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v8);
    uint64_t v59 = _NRLogIsLevelEnabled(v58, 1LL);

    if (v59)
    {
      uint64_t v61 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v60);
      _NRLogWithArgs(v61, 1LL, "%s%.30s:%-4d Ignoring link receive data event as conductor is disabled");
LABEL_34:
    }
  }

LABEL_319:
}

void sub_1000D1D1C(uint64_t a1, void *a2)
{
  id v34 = a2;
  unsigned int v3 = [*(id *)(a1 + 128) ikeClassDEstablished];
  id v4 = v34;
  if (v3)
  {
    id v5 = *(void **)(a1 + 632);
    if (v5) {
      id v5 = (void *)v5[4];
    }
    uint64_t v6 = v5;
    unsigned int v7 = [v6 containsObject:v34];

    id v4 = v34;
    if (v7)
    {
      nw_endpoint_t v8 = *(nw_endpoint_t *)(a1 + 632);
      id v9 = v34;
      if (v8)
      {
        if (*((_BYTE *)v8 + 9))
        {
          nw_endpoint_t v8 = 0LL;
        }

        else
        {
          objc_opt_self(&OBJC_CLASS___NRApplicationServiceManager);
          if (qword_1001DC930 != -1) {
            dispatch_once(&qword_1001DC930, &stru_1001AF7E0);
          }
          nw_endpoint_t v8 = sub_1000F6DD0(qword_1001DC928, v9);
        }
      }

      uint64_t v10 = *(void *)(a1 + 632);
      id v11 = v9;
      if (!v10 || *(_BYTE *)(v10 + 9))
      {
        id v12 = 0LL;
        goto LABEL_30;
      }

      objc_opt_self(&OBJC_CLASS___NRApplicationServiceManager);
      if (qword_1001DC930 != -1) {
        dispatch_once(&qword_1001DC930, &stru_1001AF7E0);
      }
      id v12 = (id *)qword_1001DC928;
      id v13 = v11;
      id v14 = v13;
      if (v12)
      {
        if (v13)
        {
          uint64_t v15 = objc_claimAutoreleasedReturnValue([v12[3] objectForKeyedSubscript:v13]);
          id v16 = (id)v15;
          if (v15)
          {
            id v12 = (id *)sub_1000F44A4(*(void **)(v15 + 40));
LABEL_23:

            goto LABEL_24;
          }

void sub_1000D2088(uint64_t a1, int a2, int a3)
{
  if (*(void *)(a1 + 632))
  {
    uint64_t v5 = a1;
    uint64_t v6 = *(void **)(a1 + 640);
    if (!v6)
    {
      uint64_t v7 = objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
      nw_endpoint_t v8 = *(void **)(v5 + 640);
      *(void *)(v5 + 640) = v7;

      uint64_t v6 = *(void **)(v5 + 640);
    }

    v157[0] = 0LL;
    v157[1] = 0LL;
    [v6 getUUIDBytes:v157];
    id v9 = *(void **)(v5 + 632);
    if (v9) {
      id v9 = (void *)v9[2];
    }
    uint64_t v10 = v9;
    id v11 = [v10 count];

    uint64_t v135 = v5;
    if (v11 && a2)
    {
      __int128 v148 = 0u;
      __int128 v149 = 0u;
      __int128 v146 = 0u;
      __int128 v147 = 0u;
      id v12 = *(void **)(v5 + 632);
      int v126 = a3;
      if (v12) {
        id v12 = (void *)v12[2];
      }
      id v13 = v12;
      id v14 = [v13 countByEnumeratingWithState:&v146 objects:v156 count:16];
      if (v14)
      {
        id v15 = v14;
        id obj = *(id *)v147;
        __int128 v129 = v13;
        do
        {
          id v16 = 0LL;
          id v134 = v15;
          do
          {
            if (*(id *)v147 != obj) {
              objc_enumerationMutation(v13);
            }
            if (*(_BYTE *)(v5 + 47))
            {
              CFStringRef v20 = *(void **)(*((void *)&v146 + 1) + 8LL * (void)v16);
              if (!sub_1000F72A0(*(void *)(v5 + 632), v20)
                || (id v21 = *(id *)(v5 + 128)) != 0LL
                && (id v23 = v21, v24 = [*(id *)(v5 + 128) type], v23, v24 != 4))
              {
                application_service = (void *)nw_endpoint_create_application_service( [v20 UTF8String],  v157);
                sub_1000D2CC0(v5, application_service);
                unsigned int v30 = [*(id *)(v5 + 128) ikeClassDEstablished];
                uint64_t v31 = *(void *)(v5 + 632);
                id v19 = v20;
                id v17 = application_service;
                if (v30)
                {
                  if (v31 && !*(_BYTE *)(v31 + 9))
                  {
                    objc_opt_self(&OBJC_CLASS___NRApplicationServiceManager);
                    if (qword_1001DC930 != -1) {
                      dispatch_once(&qword_1001DC930, &stru_1001AF7E0);
                    }
                    uint64_t v32 = qword_1001DC928;
                    id v18 = v19;
                    id v33 = v17;
                    id v34 = v33;
                    if (v32)
                    {
                      id v132 = v19;
                      if (v33)
                      {
                        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v32 + 8));
                        id v35 = (id)objc_claimAutoreleasedReturnValue([*(id *)(v32 + 32) objectForKeyedSubscript:v18]);
                        if ([v35 count])
                        {
                          id v127 = v18;
                          id v130 = v17;
                          __int128 v152 = 0u;
                          __int128 v153 = 0u;
                          __int128 v150 = 0u;
                          __int128 v151 = 0u;
                          id v35 = v35;
                          id v36 = [v35 countByEnumeratingWithState:&v150 objects:v158 count:16];
                          if (v36)
                          {
                            id v37 = v36;
                            uint64_t v38 = *(void *)v151;
                            do
                            {
                              for (uint64_t i = 0LL; i != v37; uint64_t i = (char *)i + 1)
                              {
                                if (*(void *)v151 != v38) {
                                  objc_enumerationMutation(v35);
                                }
                                uint64_t v40 = *(void *)(*((void *)&v150 + 1) + 8LL * (void)i);
                                if (v40)
                                {
                                  uint64_t v41 = *(void *)(v40 + 56);
                                  if (!v41)
                                  {
                                    __int128 v42 = (void *)nw_array_create();
                                    objc_storeStrong((id *)(v40 + 56), v42);

                                    uint64_t v41 = *(void *)(v40 + 56);
                                  }

                                  nw_array_append(v41, v34);
                                  id v43 = *(id *)(v40 + 48);
                                  uint64_t v44 = (uint64_t)v43 + 16;
                                  uint64_t v45 = *(void *)(v40 + 56);
                                }

                                else
                                {

                                  nw_array_append(0LL, v34);
                                  id v43 = 0LL;
                                  uint64_t v45 = 0LL;
                                  uint64_t v44 = 16LL;
                                }

                                (*(void (**)(id, uint64_t))v44)(v43, v45);
                              }

                              id v37 = [v35 countByEnumeratingWithState:&v150 objects:v158 count:16];
                            }

                            while (v37);
                          }

                          uint64_t v5 = v135;
                          id v17 = v130;
                          id v18 = v127;
                        }

void sub_1000D2CC0(uint64_t a1, void *a2)
{
  unsigned int v3 = a2;
  if (!a1) {
    goto LABEL_19;
  }
  endpoint = v3;
  id v4 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 96));
  if (nw_endpoint_get_type(endpoint) == 6)
  {
    if (v4) {
      uint64_t v5 = (void *)*((void *)v4 + 14);
    }
    else {
      uint64_t v5 = 0LL;
    }
    id v6 = v5;

    if (v6)
    {
      if (v4) {
        uint64_t v7 = (void *)*((void *)v4 + 14);
      }
      else {
        uint64_t v7 = 0LL;
      }
      id v8 = v7;
      nw_endpoint_set_device_name(endpoint, [v8 UTF8String]);
    }

    if (v4)
    {
      if (v4[18])
      {
        StringFromNRDeviceEndpointType = (void *)createStringFromNRDeviceEndpointType(v4[18]);
        nw_endpoint_set_device_model(endpoint, [StringFromNRDeviceEndpointType UTF8String]);
      }

      goto LABEL_13;
    }

void sub_1000D2DE0(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 10))
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v2 = (id)qword_1001DC870;
    unsigned int v3 = v2;
    if (v2) {
      id v4 = (void *)*((void *)v2 + 6);
    }
    else {
      id v4 = 0LL;
    }
    uint64_t v5 = v4;

    if (v5) {
      id v6 = (void *)v5[8];
    }
    else {
      id v6 = 0LL;
    }
    id v7 = v6;

    if (v7)
    {
      id v8 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 96));
      id v9 = v8;
      if (v8)
      {
        id v10 = *((id *)v8 + 16);

        if (v10)
        {
          if (!v9[13])
          {
            id v11 = *(id *)(a1 + 96);
            objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
            id v12 = sub_100136BF4((uint64_t)&OBJC_CLASS___NRDLocalDevice, v11, &off_1001BC8E0);

            if (v12)
            {
              if (sub_1000D5E34(a1) == 2 && [v12 addressFamily] == (id)30)
              {
                __int128 v21 = 0uLL;
                int v23 = 0;
                uint64_t v22 = 0LL;
                sub_10012DBE0((uint64_t)&OBJC_CLASS___NRDLocalDevice, &v21, v12);
                if (BYTE8(v21) == 254 && (BYTE9(v21) & 0xC0) == 0x80)
                {
                  id v13 = sub_1000D4CD4(a1);
                  id v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
                  if (v14)
                  {
                    uint64_t v15 = v14[14];
                    if (v15) {
                      LODWORD(v15) = *(_DWORD *)(v15 + 12);
                    }
                  }

                  else
                  {
                    LODWORD(v15) = 0;
                  }

                  int v23 = v15;
                }

                if (!WORD1(v21))
                {
                  id v16 = sub_10000E178();
                  if (v16) {
                    unsigned int v17 = -2793;
                  }
                  else {
                    unsigned int v17 = 0;
                  }
                  WORD1(v21) = bswap32(v17) >> 16;
                }

                id v18 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithAddress:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithAddress:",  &v21));
                id v19 = sub_1000D4CD4(a1);
                CFStringRef v20 = (id *)objc_claimAutoreleasedReturnValue(v19);
                sub_100140BC8(v20, v18, *(void **)(a1 + 96));
              }
            }

            else
            {
              sub_1000D55D0(a1, 2u, 102);
            }
          }
        }
      }
    }
  }

void sub_1000D3034(uint64_t a1, uint64_t a2)
{
  if (a1 && *(_BYTE *)(a1 + 13) && *(_BYTE *)(a1 + 10))
  {
    if (!*(_BYTE *)(a1 + 47) || *(_BYTE *)(a1 + 51))
    {
      unsigned int v3 = objc_alloc_init(&OBJC_CLASS___NRLinkDirectorRequest);
      if (v3)
      {
        v3->_type = 11;
        v3->_requiredLinkType = 1;
        *(_WORD *)&v3->_attemptImmediately = 257;
      }

      id v7 = v3;
      sub_1000D312C(a1, v3);
      goto LABEL_9;
    }

    id v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

    if (IsLevelEnabled)
    {
      id v7 = (NRLinkDirectorRequest *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v6);
      _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d Deferring sending AWDL address update to when we need it",  "",  "-[NRDDeviceConductor sendAWDLEndpoint]",  7198);
LABEL_9:
    }
  }

void sub_1000D312C(uint64_t a1, void *a2)
{
  unsigned int v3 = a2;
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    id v4 = *(void **)(a1 + 120);
    if (!v4)
    {
      uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      uint64_t v6 = *(void **)(a1 + 120);
      *(void *)(a1 + 120) = v5;

      id v4 = *(void **)(a1 + 120);
    }

    __int128 v31 = 0u;
    __int128 v32 = 0u;
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    id v7 = v4;
    id v8 = [v7 countByEnumeratingWithState:&v29 objects:v33 count:16];
    if (v8)
    {
      id v9 = v8;
      id v10 = 0LL;
      uint64_t v11 = *(void *)v30;
LABEL_6:
      uint64_t v12 = 0LL;
      while (1)
      {
        id v13 = v10;
        if (*(void *)v30 != v11) {
          objc_enumerationMutation(v7);
        }
        id v10 = (unsigned __int8 *)*(id *)(*((void *)&v29 + 1) + 8 * v12);

        if (!v10) {
          break;
        }
        int v14 = v10[10];
        if (v3) {
          goto LABEL_13;
        }
        if (!v10[10]) {
          goto LABEL_22;
        }
LABEL_8:
        if (v9 == (id)++v12)
        {
          id v9 = [v7 countByEnumeratingWithState:&v29 objects:v33 count:16];
          if (v9) {
            goto LABEL_6;
          }

          goto LABEL_20;
        }
      }

      if (!v3)
      {
        id v10 = 0LL;
LABEL_22:

        unsigned int v17 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v16);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v17, 1LL);

        if (IsLevelEnabled)
        {
          id v19 = *(id *)(a1 + 96);
          __int128 v21 = (void *)_NRCopyLogObjectForNRUUID(v19, v20);
          _NRLogWithArgs( v21,  1LL,  "%s%.30s:%-4d Removing existing request: %@",  "",  "-[NRDDeviceConductor addRequest:]",  2693LL,  v10,  (void)v29);
        }

        [*(id *)(a1 + 120) removeObject:v10];
        goto LABEL_25;
      }

      int v14 = 0;
LABEL_13:
      if (v14 == v3[10] && v14 != 6) {
        goto LABEL_22;
      }
      goto LABEL_8;
    }

void sub_1000D3428(uint64_t a1, void *a2)
{
  unsigned int v3 = a2;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
  if (!v3
    || (uint64_t v4 = *((unsigned __int8 *)v3 + 11), !*((_BYTE *)v3 + 11))
    || (*((_BYTE *)v3 + 10) & 0xFE) == 6 && v3[4]
    || !sub_1000D4B98(a1, v4))
  {
    uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v4);
    int IsLevelEnabled = (id *)_NRLogIsLevelEnabled(v11, 1LL);

    if ((_DWORD)IsLevelEnabled)
    {
      int v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v13);
      _NRLogWithArgs( v14,  1LL,  "%s%.30s:%-4d Processing request %@",  "",  "-[NRDDeviceConductor processRequest:]",  2776LL,  v3);
    }

    if (v3) {
      id v15 = v3[2];
    }
    else {
      id v15 = 0LL;
    }
    id v16 = v15;

    uint64_t v216 = a1;
    uint64_t v217 = v3;
    if (v16)
    {
      __int128 v244 = 0u;
      __int128 v245 = 0u;
      __int128 v242 = 0u;
      __int128 v243 = 0u;
      id v17 = *(id *)(a1 + 112);
      int IsLevelEnabled = (id *)[v17 countByEnumeratingWithState:&v242 objects:v251 count:16];
      if (IsLevelEnabled)
      {
        uint64_t v18 = *(void *)v243;
        do
        {
          for (uint64_t i = 0LL; i != IsLevelEnabled; uint64_t i = (id *)((char *)i + 1))
          {
            if (*(void *)v243 != v18) {
              objc_enumerationMutation(v17);
            }
            uint64_t v20 = v217;
            if (v217) {
              uint64_t v20 = (id *)v217[2];
            }
            __int128 v21 = *(void **)(*((void *)&v242 + 1) + 8LL * (void)i);
            uint64_t v22 = v20;
            int v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( NSNumber,  "numberWithUnsignedChar:",  [v21 type]));
            if ([v22 containsObject:v23])
            {
              BOOL v24 = [v21 state] == 8;

              if (v24)
              {
                uint64_t v214 = v21;
                goto LABEL_32;
              }
            }

            else
            {
            }
          }

          int IsLevelEnabled = (id *)[v17 countByEnumeratingWithState:&v242 objects:v251 count:16];
        }

        while (IsLevelEnabled);
      }

      uint64_t v214 = 0LL;
LABEL_32:

      a1 = v216;
      unsigned int v3 = v217;
      goto LABEL_33;
    }

    if (v3)
    {
      if (*((_BYTE *)v3 + 9))
      {
        else {
          uint64_t v214 = 0LL;
        }
        goto LABEL_33;
      }

      if (*((_BYTE *)v3 + 8))
      {
        __int128 v240 = 0u;
        __int128 v241 = 0u;
        __int128 v238 = 0u;
        __int128 v239 = 0u;
        id v38 = *(id *)(a1 + 112);
        int IsLevelEnabled = (id *)[v38 countByEnumeratingWithState:&v238 objects:v250 count:16];
        if (!IsLevelEnabled) {
          goto LABEL_68;
        }
        uint64_t v39 = *(void *)v239;
LABEL_58:
        uint64_t v40 = 0LL;
        while (1)
        {
          if (*(void *)v239 != v39) {
            objc_enumerationMutation(v38);
          }
          uint64_t v41 = *(void **)(*((void *)&v238 + 1) + 8 * v40);
          if ([v41 type] == *((unsigned __int8 *)v217 + 8)
            && ([v41 state] == 8
             || *((_BYTE *)v217 + 14) && [v41 state] == 9))
          {
            break;
          }

          if (IsLevelEnabled == (id *)++v40)
          {
            int IsLevelEnabled = (id *)[v38 countByEnumeratingWithState:&v238 objects:v250 count:16];
            if (!IsLevelEnabled)
            {
LABEL_68:

              a1 = v216;
              goto LABEL_139;
            }

            goto LABEL_58;
          }
        }

        uint64_t v214 = v41;

        a1 = v216;
        unsigned int v3 = v217;
        if (v214)
        {
LABEL_33:
          uint64_t v213 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 96));
          int v26 = v217;
          if (v3)
          {
            int v27 = *((unsigned __int8 *)v217 + 10);
            switch(*((_BYTE *)v217 + 10))
            {
              case 0:
                goto LABEL_265;
              case 1:
                uint64_t v29 = v216;
                if (!*(_BYTE *)(v216 + 43)) {
                  goto LABEL_137;
                }
                id v43 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
                objc_opt_self(&OBJC_CLASS___NRLinkDirector);
                p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
                if (qword_1001DC878 != -1) {
                  dispatch_once(&qword_1001DC878, &stru_1001AEED0);
                }
                int IsLevelEnabled = (id *)&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
                uint64_t v45 = (id *)(id)qword_1001DC870;
                int v26 = v45;
                if (!v45) {
                  goto LABEL_268;
                }
                uint64_t v46 = v45[6];
                if (v46) {
                  uint64_t v46 = (void *)v46[7];
                }
                id v47 = v46;
                goto LABEL_78;
              case 2:
              case 3:
                uint64_t v212 = *((unsigned __int8 *)v217 + 10);
                __int128 v30 = (id *)sub_100021C64(objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage), *(void **)(v216 + 96));
                id v215 = v30;
                __int128 v31 = v30;
                if (v30)
                {
                  objc_storeStrong(v30 + 3, v214);
                  __int128 v31 = v215;
                }

                if (!v213 || *((unsigned __int16 *)v213 + 14) <= 0x11u)
                {
                  if (v31)
                  {
                    LOBYTE(v233[0]) = (_DWORD)v212 == 2;
                    __int128 v32 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  v233,  1LL);
                    sub_1000222F4((uint64_t)v215, 5, v32);
                  }

LABEL_240:
                  int v188 = sub_100023824((uint64_t)v215);
                  if (v188)
                  {
                    *((_BYTE *)v217 + 12) = 1;
                    uint64_t v189 = "Successfully sent";
                  }

                  else
                  {
                    uint64_t v189 = "Failed to send";
                  }

                  BOOL v190 = (_DWORD)v212 == 2;
                  if ((_DWORD)v212 == 2) {
                    char v191 = v188;
                  }
                  else {
                    char v191 = 0;
                  }
                  *(_BYTE *)(v216 + 15) = v191;
                  __int128 v129 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v190, v212));
                  sub_1000D4F78( v216,  1008,  @"%s prefer Wi-Fi request %@",  v192,  v193,  v194,  v195,  v196,  (uint64_t)v189);
LABEL_247:

LABEL_248:
                  int v28 = 1;
LABEL_249:
                  uint64_t v29 = v216;
                  int v26 = v217;
LABEL_250:
                  BOOL v197 = *((_BYTE *)v26 + 12) == 0;
                  uint64_t v198 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v29 + 96), v25);
                  int v199 = _NRLogIsLevelEnabled(v198, 1LL);

                  if (v197)
                  {
                    if (!v199)
                    {
LABEL_261:

                      goto LABEL_262;
                    }

                    id v204 = (void (**)(void))_NRCopyLogObjectForNRUUID(*(void *)(v216 + 96), v200);
                    _NRLogWithArgs( v204,  1LL,  "%s%.30s:%-4d Could not complete request %@",  "",  "-[NRDDeviceConductor processRequest:]",  3097LL,  v217);
                  }

                  else
                  {
                    if (v199)
                    {
                      uint64_t v201 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v216 + 96), v200);
                      _NRLogWithArgs( v201,  1LL,  "%s%.30s:%-4d Completed request %@",  "",  "-[NRDDeviceConductor processRequest:]",  3092LL,  v217);
                    }

                    id v202 = v217[6];
                    if (v202) {
                      int v203 = v28;
                    }
                    else {
                      int v203 = 0;
                    }

                    if (!v203) {
                      goto LABEL_261;
                    }
                    id v204 = (void (**)(void))v217[6];
                    v204[2]();
                  }

                  goto LABEL_261;
                }

                memset(v233, 0, 9);
                *(_DWORD *)((char *)v233 + 1) = bswap32(arc4random_uniform(0xFFFFFFFF));
                if ((_DWORD)v212 != 2)
                {
                  id v86 = 0LL;
                  goto LABEL_213;
                }

                LOBYTE(v233[0]) = 1;
                id v86 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                BOOL v232 = 0;
                int v87 = (unsigned __int8 *)v216;
                if (*(_BYTE *)(v216 + 10))
                {
                  id v88 = sub_1000A2C08((uint64_t)&OBJC_CLASS___NRLinkDirector);
                  uint64_t v89 = v88;
                  if (v88) {
                    id v90 = (void *)*((void *)v88 + 12);
                  }
                  else {
                    id v90 = 0LL;
                  }
                  id v91 = v90;
                  *(_BYTE *)(v216 + 52) = sub_100061098((uint64_t)v91, &v232);

                  int v87 = (unsigned __int8 *)v216;
                }

                if (!v87[52]) {
                  goto LABEL_206;
                }
                int v92 = v87[10];
                if (!v87[10] && !v87[49]) {
                  goto LABEL_120;
                }
                if (!v87[49]) {
                  goto LABEL_201;
                }
                -[NSMutableArray addObject:](v86, "addObject:", &off_1001BC748);
                int v87 = (unsigned __int8 *)v216;
                if (!*(_BYTE *)(v216 + 52)) {
                  goto LABEL_206;
                }
                int v92 = *(unsigned __int8 *)(v216 + 10);
LABEL_201:
                if (v92)
                {
                  sub_1000D4FF8((uint64_t)v87, v215);
                  -[NSMutableArray addObject:](v86, "addObject:", &off_1001BC6D0);
                  int v87 = (unsigned __int8 *)v216;
                  if (!*(_BYTE *)(v216 + 52)) {
                    goto LABEL_206;
                  }
                }

                id v156 = sub_1000D4CD4((uint64_t)v87);
                uint64_t v157 = objc_claimAutoreleasedReturnValue(v156);
                __int128 v158 = (void *)v157;
                __int128 v159 = v157 ? *(void **)(v157 + 56) : 0LL;
                id v160 = v159;
                BOOL v161 = v160 == 0LL;

                if (!v161)
                {
LABEL_206:
                  if (v232)
                  {
LABEL_120:
                    -[NSMutableArray addObject:](v86, "addObject:", &off_1001BC730);
                    goto LABEL_213;
                  }

                  -[NSMutableArray insertObject:atIndex:](v86, "insertObject:atIndex:", &off_1001BC730, 0LL);
                }

LABEL_125:
                  id v95 = v26[7];
                  __int128 v94 = v26 + 7;
                  id v96 = v95;
                  BOOL v97 = v96 == 0LL;

                  if (v97)
                  {
                    uint64_t v98 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  *(dispatch_queue_t *)(v216 + 104));
                    dispatch_time_t v99 = dispatch_time(0x8000000000000000LL, 1000000000LL * (void)v217[4]);
                    dispatch_source_set_timer(v98, v99, 0xFFFFFFFFFFFFFFFFLL, 0LL);
                    objc_initWeak(v233, v217);
                    v218[0] = _NSConcreteStackBlock;
                    v218[1] = 3221225472LL;
                    v218[2] = sub_1000D5444;
                    v218[3] = &unk_1001B0798;
                    objc_copyWeak(&v219, v233);
                    v218[4] = v216;
                    dispatch_source_set_event_handler(v98, v218);
                    dispatch_resume(v98);
                    objc_storeStrong(v94, v98);
                    objc_destroyWeak(&v219);
                    objc_destroyWeak(v233);
                  }

                  uint64_t v214 = 0LL;
                  int v28 = 0;
                }

                else
                {
                  int v100 = v26 + 7;
                  id v101 = v26[7];
                  BOOL v102 = v101 == 0LL;

                  if (!v102)
                  {
                    __int128 v104 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v216 + 96), v103);
                    int v105 = _NRLogIsLevelEnabled(v104, 1LL);

                    if (v105)
                    {
                      __int128 v107 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v216 + 96), v106);
                      _NRLogWithArgs( v107,  1LL,  "%s%.30s:%-4d Cancelling the timer request %@",  "",  "-[NRDDeviceConductor processRequest:]",  3075LL,  v217);
                    }

                    int v108 = (dispatch_source_s *)*v100;
                    dispatch_source_cancel(v108);

                    objc_storeStrong(v100, 0LL);
                  }

                  uint64_t v109 = v217;
                  *((_BYTE *)v217 + 12) = 1;
                  id v110 = v109[3];

                  if (v110)
                  {
                    __int128 v111 = (void (**)(void))v217[3];
                    v111[2]();
                  }

                  int v28 = 0;
                }

                goto LABEL_249;
              case 9:
              case 0xA:
                id v33 = (id *)sub_100021C64(objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage), *(void **)(v216 + 96));
                id v215 = v33;
                id v34 = v33;
                if (v33)
                {
                  objc_storeStrong(v33 + 3, v214);
                  id v34 = v215;
                }

                if (!v213 || *((unsigned __int16 *)v213 + 14) <= 0x11u)
                {
                  if (v34)
                  {
                    LOBYTE(v233[0]) = v27 == 9;
                    id v35 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  v233,  1LL);
                    sub_1000222F4((uint64_t)v215, 7, v35);
                  }

LABEL_265:
          id v205 = sub_1000D54AC();
          int v206 = _NRLogIsLevelEnabled(v205, 16LL);

          if (v206)
          {
            id v207 = sub_1000D54AC();
            _NRLogWithArgs( v207,  16LL,  "%s%.30s:%-4d ABORTING: Received invalid request type",  "",  "-[NRDDeviceConductor processRequest:]",  3087);
          }

          p_class_meths = (__objc2_meth_list **)_os_log_pack_size(12LL);
          id v43 = (__objc2_class *)((char *)&v212 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL));
          id v208 = __error();
          uint64_t v209 = _os_log_pack_fill( v43,  p_class_meths,  *v208,  &_mh_execute_header,  "%{public}s Received invalid request type");
          *(_DWORD *)uint64_t v209 = 136446210;
          *(void *)(v209 + 4) = "-[NRDDeviceConductor processRequest:]";
          id v210 = sub_1000D54AC();
          _NRLogAbortWithPack(v210, v43);
          __break(1u);
LABEL_268:
          id v47 = 0LL;
LABEL_78:

          dispatch_assert_queue_V2(*(dispatch_queue_t *)(v216 + 104));
          objc_opt_self(&v43[54]);
          if (p_class_meths[271] != (__objc2_meth_list *)-1LL) {
            dispatch_once(&qword_1001DC878, &stru_1001AEED0);
          }
          id v48 = IsLevelEnabled[270];
          id v49 = v48;
          if (v48)
          {
            id v50 = (void *)*((void *)v48 + 6);
            if (v50) {
              id v50 = (void *)v50[7];
            }
            id v51 = v50;
          }

          else
          {
            id v51 = 0LL;
          }

          unsigned int v52 = [*(id *)(v216 + 136) isEqual:v51];
          if (v52 && !*(_BYTE *)(v216 + 24))
          {
            __int128 v162 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v216 + 96), v53);
            int v163 = _NRLogIsLevelEnabled(v162, 1LL);

            if (v163)
            {
              __int128 v165 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v216 + 96), v164);
              _NRLogWithArgs( v165,  1LL,  "%s%.30s:%-4d We already sent this information to the gizmo",  "",  "-[NRDDeviceConductor processRequest:]",  2835);
            }
          }

          else
          {
            if (v47)
            {
              uint64_t v54 = objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage);
              uint64_t v55 = (id *)sub_100021C64(v54, *(void **)(v216 + 96));
              uint64_t v56 = v55;
              if (v55) {
                objc_storeStrong(v55 + 3, v214);
              }
              objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
              if (qword_1001DC640 != -1) {
                dispatch_once(&qword_1001DC640, &stru_1001ADE98);
              }
              id v57 = (id)qword_1001DC638;
              uint64_t v58 = v57;
              if (v56)
              {
                if (v57) {
                  unsigned int v59 = 62743;
                }
                else {
                  unsigned int v59 = 0;
                }
                sub_1000227DC((uint64_t)v56, v47, v59, 0);
              }

              id v60 = sub_1000D4CD4(v216);
              uint64_t v61 = objc_claimAutoreleasedReturnValue(v60);
              id v62 = (void *)v61;
              if (v61) {
                uint64_t v63 = *(void **)(v61 + 80);
              }
              else {
                uint64_t v63 = 0LL;
              }
              id v64 = v63;
              BOOL v65 = v64 == 0LL;

              if (!v65)
              {
                id v66 = sub_1000D4CD4(v216);
                uint64_t v67 = objc_claimAutoreleasedReturnValue(v66);
                unsigned int v68 = (void *)v67;
                if (v67) {
                  id v69 = *(void **)(v67 + 80);
                }
                else {
                  id v69 = 0LL;
                }
                id v70 = v69;
                sub_1000222F4((uint64_t)v56, 4, v70);
              }

              if (sub_100023824((uint64_t)v56))
              {
                uint64_t v76 = v216;
                *((_BYTE *)v217 + 12) = 1;
                sub_1000D4D64(v76, v47);
                id v77 = sub_1000D4CD4(v216);
                uint64_t v78 = objc_claimAutoreleasedReturnValue(v77);
                __int128 v79 = (void *)v78;
                if (v78) {
                  id v80 = *(void **)(v78 + 80);
                }
                else {
                  id v80 = 0LL;
                }
                id v81 = v80;
                sub_1000D4E80(v216, v81);

                id v82 = "Successfully sent";
              }

              else
              {
                id v82 = "Failed to send";
              }

              sub_1000D4F78(v216, 1010, @"%s Wi-Fi address update %@", v71, v72, v73, v74, v75, (uint64_t)v82);

              goto LABEL_211;
            }

            __int128 v149 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v216 + 96), v53);
            int v150 = _NRLogIsLevelEnabled(v149, 1LL);

            if (v150)
            {
              __int128 v152 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v216 + 96), v151);
              _NRLogWithArgs( v152,  1LL,  "%s%.30s:%-4d No Wi-Fi address present",  "",  "-[NRDDeviceConductor processRequest:]",  2841);
            }
          }

          *((_BYTE *)v217 + 12) = 1;
LABEL_211:

          goto LABEL_248;
        }

LABEL_192:
      a1 = v216;
      unsigned int v3 = v217;
    }

    uint64_t v214 = IsLevelEnabled;
    if (IsLevelEnabled) {
      goto LABEL_33;
    }
    goto LABEL_194;
  }

  uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v4);
  int v6 = _NRLogIsLevelEnabled(v5, 1LL);

  if (v6)
  {
    id v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v7);
    unint64_t v9 = *((unsigned __int8 *)v3 + 11);
    if (v9 > 0xB) {
      id v10 = @"Unknown";
    }
    else {
      id v10 = -[NSString initWithUTF8String:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithUTF8String:",  (&off_1001AFA78)[v9]);
    }
    _NRLogWithArgs( v8,  1LL,  "%s%.30s:%-4d Deferring request %@ as request %@ exists",  "",  "-[NRDDeviceConductor processRequest:]",  2770LL,  v3,  v10);
  }

uint64_t sub_1000D4B98(uint64_t a1, int a2)
{
  uint64_t v2 = a1;
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    id v4 = *(id *)(v2 + 120);
    id v5 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v14;
      do
      {
        id v8 = 0LL;
        do
        {
          if (*(void *)v14 != v7) {
            objc_enumerationMutation(v4);
          }
          unint64_t v9 = *(unsigned __int8 **)(*((void *)&v13 + 1) + 8LL * (void)v8);
          if (v9)
          {
            if (v9[10] == a2) {
              goto LABEL_15;
            }
          }

          else if (!a2)
          {
LABEL_15:
            uint64_t v11 = v9;
            goto LABEL_16;
          }

          id v8 = (char *)v8 + 1;
        }

        while (v6 != v8);
        id v10 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
        id v6 = v10;
      }

      while (v10);
    }

    uint64_t v11 = 0LL;
LABEL_16:

    uint64_t v2 = v11 != 0LL;
  }

  return v2;
}

id sub_1000D4CD4(uint64_t a1)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v1 = (id)qword_1001DC870;
    uint64_t v2 = v1;
    if (v1) {
      unsigned int v3 = (void *)*((void *)v1 + 6);
    }
    else {
      unsigned int v3 = 0LL;
    }
    id v4 = v3;
  }

  else
  {
    id v4 = 0LL;
  }

  return v4;
}

void sub_1000D4D64(uint64_t a1, void *a2)
{
  id v12 = a2;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
  if (([*(id *)(a1 + 136) isEqual:v12] & 1) == 0)
  {
    id v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 1LL);

    if (IsLevelEnabled)
    {
      id v7 = *(id *)(a1 + 96);
      unint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(v7, v8);
      _NRLogWithArgs( v9,  1LL,  "%s%.30s:%-4d Setting last sent WiFi endpoint: %@ --> %@",  "",  "-[NRDDeviceConductor setLastSentWiFiEndpoint:]",  2097LL,  *(void *)(a1 + 136),  v12);
    }

    objc_storeStrong((id *)(a1 + 136), a2);
    id v10 = *(id *)(a1 + 96);
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v12 addressData]);
    sub_10009FCD0(v10, @"WiFiEndpointAddressData", v11);
  }
}

void sub_1000D4E80(uint64_t a1, void *a2)
{
  id v10 = a2;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
  if (([*(id *)(a1 + 144) isEqualToData:v10] & 1) == 0)
  {
    id v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 1LL);

    if (IsLevelEnabled)
    {
      id v7 = *(id *)(a1 + 96);
      unint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(v7, v8);
      _NRLogWithArgs( v9,  1LL,  "%s%.30s:%-4d Setting last sent WiFi signature: %@ --> %@",  "",  "-[NRDDeviceConductor setLastSentWiFiSignature:]",  2133LL,  *(void *)(a1 + 144),  v10);
    }

    objc_storeStrong((id *)(a1 + 144), a2);
    sub_10009FCD0(*(void **)(a1 + 96), @"WiFiSignature", *(void **)(a1 + 144));
  }
}

void sub_1000D4F78( uint64_t a1, int a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1)
  {
    id v11 = a3;
    id v12 = -[NSString initWithFormat:arguments:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:arguments:",  v11,  &a9);

    sub_10011BB18(*(void **)(a1 + 96), a2, 0LL, v12);
  }

void sub_1000D4FF8(uint64_t a1, void *a2)
{
  id v27 = a2;
  if (v27)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v3 = (id)qword_1001DC870;
    uint64_t v4 = v3;
    if (v3) {
      id v5 = (void *)*((void *)v3 + 6);
    }
    else {
      id v5 = 0LL;
    }
    id v6 = v5;

    if (v6) {
      id v7 = (void *)v6[8];
    }
    else {
      id v7 = 0LL;
    }
    id v8 = v7;

    LOBYTE(v31) = v8 != 0LL;
    unint64_t v9 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v31, 1LL);
    sub_1000222F4((uint64_t)v27, 10, v9);

    if (!v8) {
      goto LABEL_30;
    }
    id v10 = (void *)objc_claimAutoreleasedReturnValue([v8 port]);
    sub_1000227DC((uint64_t)v27, v8, (unsigned __int16)[v10 intValue], 1);

    id v11 = v27;
    if (!*(_BYTE *)(a1 + 47) || !*(_BYTE *)(a1 + 43)) {
      goto LABEL_29;
    }
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v12 = (id)qword_1001DC870;
    __int128 v13 = v12;
    if (v12) {
      __int128 v14 = (void *)*((void *)v12 + 6);
    }
    else {
      __int128 v14 = 0LL;
    }
    __int128 v15 = v14;

    if (!v15)
    {
      id v22 = 0LL;
      goto LABEL_27;
    }

    __int128 v16 = (dispatch_queue_s *)v15[3];
    dispatch_assert_queue_V2(v16);

    uint64_t v31 = 0LL;
    __int128 v32 = &v31;
    uint64_t v33 = 0x3032000000LL;
    id v34 = sub_10013D160;
    id v35 = sub_10013D170;
    id v36 = 0LL;
    id v17 = v15[22];
    v28[0] = _NSConcreteStackBlock;
    v28[1] = 3221225472LL;
    v28[2] = sub_100142C54;
    v28[3] = &unk_1001B07E8;
    __int128 v30 = &v31;
    id v18 = v17;
    id v29 = v18;
    if (sub_10013D090((uint64_t)&OBJC_CLASS___NRLinkManagerWiFi, v28))
    {
      id v25 = sub_10013A600();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v25, 16LL);

      if (!IsLevelEnabled)
      {
LABEL_24:
        id v22 = (id)v32[5];

        _Block_object_dispose(&v31, 8);
        if (!v22 || ![v22 compare:@"XZ" options:1]) {
          goto LABEL_28;
        }
        __int128 v15 = (id *)objc_claimAutoreleasedReturnValue([v22 dataUsingEncoding:4]);
        sub_1000222F4((uint64_t)v11, 15, v15);
LABEL_27:

LABEL_28:
LABEL_29:

        goto LABEL_30;
      }

      id v21 = sub_10013A600();
      _NRLogWithArgs( v21,  16LL,  "%s%.30s:%-4d timed out getting country code",  "",  "-[NRLinkManagerWiFi getDeviceCountryCode]",  1977);
    }

    else
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      id v19 = (id)qword_1001DCBF0;
      char v20 = _NRLogIsLevelEnabled(v19, 1LL);

      if ((v20 & 1) == 0) {
        goto LABEL_24;
      }
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      id v21 = (id)qword_1001DCBF0;
      _NRLogWithArgs( v21,  1LL,  "%s%.30s:%-4d retrieved country code",  "",  "-[NRLinkManagerWiFi getDeviceCountryCode]",  1975);
    }

    goto LABEL_24;
  }

  id v23 = sub_1000D54AC();
  int v24 = _NRLogIsLevelEnabled(v23, 17LL);

  if (!v24) {
    goto LABEL_31;
  }
  id v8 = sub_1000D54AC();
  _NRLogWithArgs(v8, 17LL, "%s called with null message", "-[NRDDeviceConductor addAWDLEndpointToMessage:]");
LABEL_30:

LABEL_31:
}

void sub_1000D542C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_1000D5444(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    uint64_t v4 = WeakRetained;
    id v3 = (void (**)(void))WeakRetained[6];
    v3[2]();

    *((_BYTE *)v4 + 12) = 1;
    sub_1000D551C(*(void *)(a1 + 32), v4);
    id WeakRetained = v4;
  }
}

id sub_1000D54AC()
{
  if (qword_1001DC8F0 != -1) {
    dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
  }
  return (id)qword_1001DC8E8;
}

void sub_1000D54EC(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC8E8;
  qword_1001DC8E8 = (uint64_t)v1;
}

void sub_1000D551C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v9 = v3;
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    id v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 1LL);

    if (IsLevelEnabled)
    {
      id v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v7);
      _NRLogWithArgs( v8,  1LL,  "%s%.30s:%-4d Removing request: %@",  "",  "-[NRDDeviceConductor removeRequest:]",  2714LL,  v9);
    }

    [*(id *)(a1 + 120) removeObject:v9];
    id v3 = v9;
  }
}

void sub_1000D55D0(uint64_t a1, unsigned int a2, char a3)
{
  if (!a1) {
    return;
  }
  if ((sub_1000D5FC0(a1) & 1) != 0)
  {
    unsigned int v7 = (a3 - 101);
    if (v7 >= 4)
    {
      if (a2 >= 6 || (unint64_t v8 = 0x40300020100uLL >> (8 * a2), !(_BYTE)v8))
      {
LABEL_15:
        __int128 v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v6);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v15, 16LL);

        if (IsLevelEnabled)
        {
          id v84 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v17);
          _NRLogWithArgs(v84, 16LL, "%s%.30s:%-4d invalid link type/subtype %u/%u");
          goto LABEL_17;
        }

        return;
      }
    }

    else
    {
      LODWORD(v_Block_object_dispose(va, 8) = 0x7060502u >> (8 * v7);
      if (!(_BYTE)v8) {
        goto LABEL_15;
      }
    }

    id v12 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 96));
    __int128 v13 = v12;
    if (*(_BYTE *)(a1 + 68) && v12)
    {
      if (v12[15])
      {
        int v14 = 1;
        if (!v12[12]) {
          goto LABEL_30;
        }
      }

      else
      {
        if (v12[14]) {
          BOOL v18 = 1;
        }
        else {
          BOOL v18 = *((unsigned __int16 *)v12 + 14) > 0x12u;
        }
        int v14 = v18;
        if (!v12[12]) {
          goto LABEL_30;
        }
      }

      if (!v12[13]) {
        int v14 = 0;
      }
      if (v14 == 1)
      {
        *(_BYTE *)(a1 + 6_Block_object_dispose(va, 8) = 0;
        id v19 = *(void **)(a1 + 424);
        *(void *)(a1 + 424) = 0LL;

        uint64_t v21 = *(void *)(a1 + 416);
        if (v21)
        {
          sub_100113E44(v21, v20);
          id v22 = *(void **)(a1 + 416);
          *(void *)(a1 + 416) = 0LL;
        }
      }
    }

void sub_1000D5DD0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id *location, id *a15, id *a16, id *a17)
{
}

uint64_t sub_1000D5E34(uint64_t a1)
{
  os_log_t v1 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 96));
  if (!v1)
  {
    id v9 = sub_1000D54AC();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 16LL);

    if (IsLevelEnabled)
    {
      id v11 = sub_1000D54AC();
      _NRLogWithArgs( v11,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRDDeviceConductor getPreferredLinkTypeFromConfiguration]",  521);
    }

    uint64_t v12 = _os_log_pack_size(12LL);
    __int128 v13 = (char *)&v17 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v14 = __error();
    uint64_t v15 = _os_log_pack_fill( v13,  v12,  *v14,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    *(_DWORD *)uint64_t v15 = 136446210;
    *(void *)(v15 + 4) = "-[NRDDeviceConductor getPreferredLinkTypeFromConfiguration]";
    id v16 = sub_1000D54AC();
    _NRLogAbortWithPack(v16, v13);
  }

  uint64_t v2 = (id *)v1;
  id v3 = *((id *)v1 + 16);

  if (v3)
  {
    id v4 = v2[16];
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 allowedLinkTypes]);
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 firstObject]);

    unsigned __int8 v7 = [v6 unsignedShortValue];
  }

  else
  {
    unsigned __int8 v7 = 1;
  }

  return v7;
}

id sub_1000D5FC0(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 13)) {
    return 0LL;
  }
  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  uint64_t v2 = (unsigned __int8 *)(id)qword_1001DC870;
  if (v2)
  {
    int v3 = v2[8];

    if (v3) {
      return 0LL;
    }
  }

  id v5 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 96));
  uint64_t v6 = v5;
  if (v5) {
    unsigned __int8 v7 = (void *)*((void *)v5 + 16);
  }
  else {
    unsigned __int8 v7 = 0LL;
  }
  id v8 = v7;
  id v9 = [v8 allowsDeviceDiscovery];

  return v9;
}

void sub_1000D6084(uint64_t a1, void *a2)
{
  id v6 = a2;
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  id v4 = objc_loadWeakRetained((id *)(a1 + 40));
  id v5 = v4;
  if (WeakRetained && v4 && *((_BYTE *)WeakRetained + 13) && WeakRetained[52] == v4) {
    sub_1000D6600((uint64_t)WeakRetained, v6);
  }
}

void sub_1000D60FC(uint64_t a1, void *a2)
{
  id v44 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v4 = objc_loadWeakRetained((id *)(a1 + 40));
  id v5 = v4;
  if (WeakRetained && v4 && *((_BYTE *)WeakRetained + 13) && *((id *)WeakRetained + 52) == v4)
  {
    id v6 = v44;
    unsigned __int8 v7 = v6;
    if (*((void *)WeakRetained + 53))
    {
      if (v6) {
        id v8 = (void *)*((void *)v6 + 2);
      }
      else {
        id v8 = 0LL;
      }
      id v9 = v8;
      int v10 = (void *)*((void *)WeakRetained + 53);
      if (v10) {
        int v10 = (void *)v10[2];
      }
      id v11 = v10;
      unsigned __int8 v12 = [v9 isEqualToString:v11];

      int v14 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 12), v13);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v14, 1LL);

      if ((v12 & 1) != 0)
      {
        if (IsLevelEnabled)
        {
          uint64_t v17 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 12), v16);
          _NRLogWithArgs(v17, 1LL, "%s%.30s:%-4d lost %@", "", "-[NRDDeviceConductor lostDevice:]", 7712LL, v7);
        }

        id v18 = *((id *)WeakRetained + 12);
        objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
        id v19 = sub_100136BF4((uint64_t)&OBJC_CLASS___NRDLocalDevice, v18, &off_1001BC8F8);

        if (!v19)
        {
          objc_opt_self(&OBJC_CLASS___NRLinkDirector);
          if (qword_1001DC878 != -1) {
            dispatch_once(&qword_1001DC878, &stru_1001AEED0);
          }
          id v20 = (id)qword_1001DC870;
          uint64_t v21 = v20;
          if (v20) {
            id v22 = (void *)*((void *)v20 + 8);
          }
          else {
            id v22 = 0LL;
          }
          id v23 = v22;
          sub_1000C986C((uint64_t)v23, 0LL, 0LL, *((void **)WeakRetained + 12));
        }

        id v24 = *((id *)WeakRetained + 12);
        objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
        id v25 = sub_100136BF4((uint64_t)&OBJC_CLASS___NRDLocalDevice, v24, &off_1001BC8B0);

        if (!v25)
        {
          objc_opt_self(&OBJC_CLASS___NRLinkDirector);
          if (qword_1001DC878 != -1) {
            dispatch_once(&qword_1001DC878, &stru_1001AEED0);
          }
          id v26 = (id)qword_1001DC870;
          id v27 = v26;
          if (v26) {
            int v28 = (void *)*((void *)v26 + 6);
          }
          else {
            int v28 = 0LL;
          }
          id v29 = v28;
          sub_100140720(v29, 0LL, *((void **)WeakRetained + 12));
        }

        id v30 = *((id *)WeakRetained + 12);
        objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
        uint64_t v31 = sub_100136BF4((uint64_t)&OBJC_CLASS___NRDLocalDevice, v30, &off_1001BC8E0);

        if (!v31)
        {
          objc_opt_self(&OBJC_CLASS___NRLinkDirector);
          if (qword_1001DC878 != -1) {
            dispatch_once(&qword_1001DC878, &stru_1001AEED0);
          }
          id v32 = (id)qword_1001DC870;
          id v33 = v32;
          if (v32) {
            unsigned int v34 = (void *)*((void *)v32 + 6);
          }
          else {
            unsigned int v34 = 0LL;
          }
          id v35 = v34;
          sub_100140BC8(v35, 0LL, *((void **)WeakRetained + 12));
        }

        id v36 = (void *)*((void *)WeakRetained + 53);
        if (v36)
        {
          __int128 v47 = 0u;
          __int128 v48 = 0u;
          __int128 v45 = 0u;
          __int128 v46 = 0u;
          id v37 = [*((id *)WeakRetained + 14) copy];
          id v38 = [v37 countByEnumeratingWithState:&v45 objects:v49 count:16];
          if (v38)
          {
            id v39 = v38;
            uint64_t v40 = *(void *)v46;
            do
            {
              for (uint64_t i = 0LL; i != v39; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v46 != v40) {
                  objc_enumerationMutation(v37);
                }
                uint64_t v42 = *(void **)(*((void *)&v45 + 1) + 8LL * (void)i);
              }

              id v39 = [v37 countByEnumeratingWithState:&v45 objects:v49 count:16];
            }

            while (v39);
          }

          id v36 = (void *)*((void *)WeakRetained + 53);
        }

        *((void *)WeakRetained + 53) = 0LL;
      }

      else if (IsLevelEnabled)
      {
        id v43 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 12), v16);
        _NRLogWithArgs( v43,  1LL,  "%s%.30s:%-4d ignoring lost stale device %@",  "",  "-[NRDDeviceConductor lostDevice:]",  7708LL,  v7);
      }
    }
  }
}

void sub_1000D6588(uint64_t a1, void *a2)
{
  id v6 = a2;
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  id v4 = objc_loadWeakRetained((id *)(a1 + 40));
  id v5 = v4;
  if (WeakRetained && v4 && *((_BYTE *)WeakRetained + 13) && WeakRetained[52] == v4) {
    sub_1000D6600((uint64_t)WeakRetained, v6);
  }
}

void sub_1000D6600(uint64_t a1, void *a2)
{
  id v4 = a2;
  id v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v5);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 1LL);

  if (IsLevelEnabled)
  {
    id v8 = *(id *)(a1 + 96);
    int v10 = (void *)_NRCopyLogObjectForNRUUID(v8, v9);
    _NRLogWithArgs(v10, 1LL, "%s%.30s:%-4d discovered %@", "", "-[NRDDeviceConductor discoveredDevice:]", 7637LL, v4);
  }

  objc_storeStrong((id *)(a1 + 424), a2);
  __int128 v187 = 0u;
  __int128 v188 = 0u;
  __int128 v185 = 0u;
  __int128 v186 = 0u;
  id v11 = *(id *)(a1 + 112);
  id v12 = [v11 countByEnumeratingWithState:&v185 objects:v193 count:16];
  if (v12)
  {
    id v13 = v12;
    uint64_t v14 = *(void *)v186;
    do
    {
      for (uint64_t i = 0LL; i != v13; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v186 != v14) {
          objc_enumerationMutation(v11);
        }
        sub_1000D77EC(a1, *(void **)(*((void *)&v185 + 1) + 8LL * (void)i));
      }

      id v13 = [v11 countByEnumeratingWithState:&v185 objects:v193 count:16];
    }

    while (v13);
  }

  if (v4)
  {
    uint64_t v16 = (void *)*((void *)v4 + 12);
    p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    if (v16)
    {
      id v18 = v16;
      id v19 = *(void **)(a1 + 96);
      id v20 = v18;
      id v21 = v19;
      objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
      id v22 = (void *)qword_1001DCBA8;
      if (!qword_1001DCBA8)
      {
        id v23 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        id v24 = (void *)qword_1001DCBA8;
        qword_1001DCBA8 = (uint64_t)v23;

        id v22 = (void *)qword_1001DCBA8;
      }

      [v22 setObject:v20 forKeyedSubscript:v21];

      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      id v25 = (id)qword_1001DC870;
      id v26 = v25;
      if (v25) {
        id v27 = (void *)*((void *)v25 + 5);
      }
      else {
        id v27 = 0LL;
      }
      id v28 = v27;
      sub_10002E6C8((uint64_t)v28);
    }

    id v29 = sub_1001138F4((uint64_t)v4, 5u, 0, 0);

    if (v29)
    {
      id v30 = *((id *)v4 + 16);
      uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", 4LL));
      id v32 = (void *)objc_claimAutoreleasedReturnValue([v30 objectForKeyedSubscript:v31]);

      if (v32)
      {
        id v33 = (void *)*((void *)v4 + 15);
        if (v33)
        {
          unsigned int v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", 4LL));
          id v33 = (void *)objc_claimAutoreleasedReturnValue([v33 objectForKeyedSubscript:v34]);
        }

        objc_opt_self(&OBJC_CLASS___NRLinkDirector);
        if (qword_1001DC878 != -1) {
          dispatch_once(&qword_1001DC878, &stru_1001AEED0);
        }
        id v35 = (id)qword_1001DC870;
        id v36 = v35;
        if (v35) {
          id v37 = (void *)*((void *)v35 + 8);
        }
        else {
          id v37 = 0LL;
        }
        id v38 = v37;
        sub_1000C986C((uint64_t)v38, v33, v32, *(void **)(a1 + 96));
      }
    }

    id v39 = sub_1001138F4((uint64_t)v4, 2u, 101, 0);

    if (v39)
    {
      uint64_t v40 = (void *)*((void *)v4 + 15);
      if (v40)
      {
        int v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", 2LL));
        uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v40 objectForKeyedSubscript:v41]);
      }

      dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      id v42 = (id)qword_1001DC870;
      id v43 = v42;
      if (v42) {
        id v44 = (void *)*((void *)v42 + 6);
      }
      else {
        id v44 = 0LL;
      }
      __int128 v45 = v44;

      sub_100140720(v45, v40, *(void **)(a1 + 96));
    }

    id v46 = sub_1001138F4((uint64_t)v4, 2u, 102, 0);

    id v182 = v4;
    if (!v46) {
      goto LABEL_73;
    }
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v47 = (id)qword_1001DC870;
    __int128 v48 = v47;
    if (v47) {
      id v49 = (void *)*((void *)v47 + 6);
    }
    else {
      id v49 = 0LL;
    }
    id v50 = v49;

    if (v50)
    {
      id v51 = v50[8];
      if (v51)
      {
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
        objc_opt_self(&OBJC_CLASS___NRLinkDirector);
        if (qword_1001DC878 != -1) {
          dispatch_once(&qword_1001DC878, &stru_1001AEED0);
        }
        id v52 = (id)qword_1001DC870;
        uint64_t v53 = v52;
        if (v52) {
          uint64_t v54 = (void *)*((void *)v52 + 6);
        }
        else {
          uint64_t v54 = 0LL;
        }
        uint64_t v55 = v54;

        if (v55) {
          uint64_t v56 = (void *)v55[8];
        }
        else {
          uint64_t v56 = 0LL;
        }
        id v57 = v56;
        int v58 = [v57 addressFamily];

        goto LABEL_56;
      }
    }

    else
    {
      id v51 = 0LL;
    }

    int v58 = 0;
LABEL_56:

    id v59 = sub_1001138F4((uint64_t)v4, 2u, 102, v58);
    id v60 = (void *)objc_claimAutoreleasedReturnValue([v59 hostname]);
    objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
    if (qword_1001DC640 != -1) {
      dispatch_once(&qword_1001DC640, &stru_1001ADE98);
    }
    id v61 = (id)qword_1001DC638;
    uint64_t v62 = @"62743";
    if (!v61) {
      uint64_t v62 = 0LL;
    }
    uint64_t v63 = v62;
    char v64 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v60,  v63));

    id v65 = (void *)objc_claimAutoreleasedReturnValue([v64 hostname]);
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v66 = (id)qword_1001DC870;
    uint64_t v67 = v66;
    if (v66) {
      unsigned int v68 = (void *)*((void *)v66 + 6);
    }
    else {
      unsigned int v68 = 0LL;
    }
    id v69 = v68;

    if (v69) {
      int v70 = (void *)v69[8];
    }
    else {
      int v70 = 0LL;
    }
    id v71 = v70;
    uint64_t v72 = (void *)objc_claimAutoreleasedReturnValue([v71 hostname]);
    unsigned __int8 v73 = [v65 isEqualToString:v72];

    p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    if ((v73 & 1) == 0)
    {
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      id v74 = (id)qword_1001DC870;
      uint64_t v75 = v74;
      if (v74) {
        uint64_t v76 = (void *)*((void *)v74 + 6);
      }
      else {
        uint64_t v76 = 0LL;
      }
      id v77 = v76;

      sub_100140BC8(v77, v64, *(void **)(a1 + 96));
    }

    id v4 = v182;
LABEL_73:
    id v78 = sub_1001138F4((uint64_t)v4, 2u, 103, 0);

    if (v78)
    {
      id v178 = sub_1001138F4((uint64_t)v4, 2u, 103, 0);
      uint64_t v79 = (void *)objc_claimAutoreleasedReturnValue([v178 hostname]);
      objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
      if (qword_1001DC640 != -1) {
        dispatch_once(&qword_1001DC640, &stru_1001ADE98);
      }
      id v80 = (id)qword_1001DC638;
      id v81 = @"62743";
      if (!v80) {
        id v81 = 0LL;
      }
      id v82 = v81;
      uint64_t v83 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v79,  v82));

      dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      id v84 = (id)qword_1001DC870;
      unsigned int v85 = v84;
      if (v84) {
        id v86 = (void *)*((void *)v84 + 6);
      }
      else {
        id v86 = 0LL;
      }
      id v87 = v86;

      id v88 = *(void **)(a1 + 96);
      id v89 = v83;
      id v90 = v88;
      id v91 = v89;
      if (v87)
      {
        id v92 = (dispatch_queue_s *)v87[3];
        dispatch_assert_queue_V2(v92);

        uint64_t v183 = (void *)sub_10014065C(v89);
        id v93 = v87[15];
        if (v93) {
          id v93 = (void *)v93[9];
        }
        __int128 v94 = v93;
        id v95 = (void *)objc_claimAutoreleasedReturnValue([v94 objectForKeyedSubscript:v90]);
        uint64_t v96 = objc_claimAutoreleasedReturnValue([v95 firstObject]);

        id v97 = (void *)v96;
        id v91 = v183;
        if (!v97 || ([v97 isEqual:v183] & 1) == 0)
        {
          __int128 v175 = v97;
          uint64_t v98 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v90);
          id v176 = v89;
          if (qword_1001DCBF8 != -1) {
            dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCBF0, 1LL))
          {
            if (qword_1001DCBF8 != -1) {
              dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
            }
            dispatch_time_t v99 = (void *)qword_1001DCBF0;
            int v100 = v87[15];
            id v101 = v99;
            BOOL v102 = v87;
            if (v100) {
              uint64_t v103 = (void *)v100[9];
            }
            else {
              uint64_t v103 = 0LL;
            }
            id v104 = v103;
            int v105 = (void *)objc_claimAutoreleasedReturnValue([v104 objectForKeyedSubscript:v90]);
            id v91 = v183;
            _NRLogWithArgs( v101,  1LL,  "%s%.30s:%-4d Setting the peer NAN endpoint as %@ ----> %@ for %@",  "",  "-[NRLinkManagerWiFi setPeerNANEndpoint:nrUUID:]",  1006LL,  v105,  v183,  v98);

            id v87 = v102;
          }

          if (v91)
          {
            *(void *)&__int128 v199 = v91;
            uint64_t v106 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v199,  1LL));
          }

          else
          {
            uint64_t v106 = 0LL;
          }

          __int128 v107 = v87[15];
          if (v107) {
            __int128 v107 = (void *)v107[9];
          }
          __int128 v174 = v98;
          int v108 = v107;
          [v108 setObject:v106 forKeyedSubscript:v90];

          if (v183) {
          uint64_t v180 = v87;
          }
          id v109 = [v87[19] copy];
          __int128 v194 = 0u;
          __int128 v195 = 0u;
          __int128 v196 = 0u;
          __int128 v197 = 0u;
          id v110 = v109;
          id v111 = [v110 countByEnumeratingWithState:&v194 objects:v198 count:16];
          if (v111)
          {
            id v112 = v111;
            uint64_t v113 = *(void *)v195;
            do
            {
              for (j = 0LL; j != v112; j = (char *)j + 1)
              {
                if (*(void *)v195 != v113) {
                  objc_enumerationMutation(v110);
                }
                id v115 = *(void **)(*((void *)&v194 + 1) + 8LL * (void)j);
                if ([v115 subtype] == 103)
                {
                  uint64_t v116 = (void *)objc_claimAutoreleasedReturnValue([v115 nrUUID]);
                  unsigned int v117 = [v116 isEqual:v90];

                  if (v117) {
                    [v115 cancelWithReason:@"Peer NAN endpoint changed"];
                  }
                }
              }

              id v112 = [v110 countByEnumeratingWithState:&v194 objects:v198 count:16];
            }

            while (v112);
          }

          id v4 = v182;
          id v91 = v183;
          p_class_meths = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
          id v89 = v176;
          if (v183)
          {
            unsigned int v118 = (void *)nw_interface_create_with_name("nan0");
            id v119 = [v183 copyCEndpoint];
            id v120 = (void *)nw_interface_copy_local_address_for_remote_address(v118, v119);

            if (v120)
            {
              BOOL v173 = v118;
              id v121 = objc_alloc(&OBJC_CLASS___NRLinkNAN);
              id v122 = v180[3];
              uint64_t v123 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithCEndpoint:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithCEndpoint:",  v120));
              objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
              if (qword_1001DC640 != -1) {
                dispatch_once(&qword_1001DC640, &stru_1001ADE98);
              }
              id v124 = (id)qword_1001DC638;
              unsigned int v125 = @"62743";
              if (!v124) {
                unsigned int v125 = 0LL;
              }
              unsigned int v126 = v125;
              id v127 = -[NRLinkNAN initLinkWithQueue:linkDelegate:nrUUID:wifiInterfaceName:localOuterEndpoint:remoteOuterEndpoint:listenerPortString:]( v121,  "initLinkWithQueue:linkDelegate:nrUUID:wifiInterfaceName:localOuterEndpoint:remoteOuterEndpoint:li stenerPortString:",  v122,  v180,  v90,  @"nan0",  v123,  v183,  v126);
              id v128 = v122;
              __int128 v129 = v127;

              if (!v129) {
                [v180 reportEvent:3201];
              }

              id v4 = v182;
              id v91 = v183;
              unsigned int v118 = v173;
              p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
            }
          }

          id v87 = v180;
          id v97 = v175;
        }
      }
    }

    id v130 = sub_1001138F4((uint64_t)v4, 2u, 104, 0);

    if (v130)
    {
      uint64_t v131 = (void *)*((void *)v4 + 15);
      if (v131)
      {
        uint64_t v132 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", 7LL));
        uint64_t v133 = (void *)objc_claimAutoreleasedReturnValue([v131 objectForKeyedSubscript:v132]);
      }

      else
      {
        uint64_t v133 = 0LL;
      }

      dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      uint64_t v134 = p_class_meths[270];
      id v135 = v134;
      if (v134) {
        uint64_t v136 = (void *)v134[6];
      }
      else {
        uint64_t v136 = 0LL;
      }
      uint64_t v137 = v136;

      __int128 v138 = *(void **)(a1 + 96);
      id v139 = v133;
      id v184 = v138;
      if (v137)
      {
        __int128 v201 = 0u;
        __int128 v202 = 0u;
        __int128 v199 = 0u;
        __int128 v200 = 0u;
        id v140 = [v139 countByEnumeratingWithState:&v199 objects:v198 count:16];
        if (v140)
        {
          id v141 = v140;
          __int128 v142 = 0LL;
          uint64_t v143 = *(void *)v200;
          do
          {
            for (uint64_t k = 0LL; k != v141; uint64_t k = (char *)k + 1)
            {
              if (*(void *)v200 != v143) {
                objc_enumerationMutation(v139);
              }
              uint64_t v145 = (void *)sub_10014065C(*(void **)(*((void *)&v199 + 1) + 8LL * (void)k));
              if (v145)
              {
                if (!v142) {
                  __int128 v142 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                }
                -[NSMutableArray addObject:](v142, "addObject:", v145);
              }
            }

            id v141 = [v139 countByEnumeratingWithState:&v199 objects:v198 count:16];
          }

          while (v141);
        }

        else
        {
          __int128 v142 = 0LL;
        }

        uint64_t v146 = v137[16];
        if (v146) {
          uint64_t v146 = (void *)v146[9];
        }
        uint64_t v147 = v146;
        uint64_t v148 = (void *)objc_claimAutoreleasedReturnValue([v147 objectForKeyedSubscript:v184]);

        if (!v148
          || (__int128 v149 = -[NSSet initWithArray:](objc_alloc(&OBJC_CLASS___NSSet), "initWithArray:", v142),
              int v150 = -[NSSet initWithArray:](objc_alloc(&OBJC_CLASS___NSSet), "initWithArray:", v148),
              unsigned __int8 v151 = -[NSSet isEqualToSet:](v149, "isEqualToSet:", v150),
              v150,
              v149,
              (v151 & 1) == 0))
        {
          int v181 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v184);
          if (qword_1001DCBF8 != -1) {
            dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCBF0, 1LL))
          {
            if (qword_1001DCBF8 != -1) {
              dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
            }
            __int128 v152 = (void *)qword_1001DCBF0;
            __int128 v153 = v137[16];
            id v154 = v152;
            if (v153) {
              uint64_t v155 = (void *)v153[9];
            }
            else {
              uint64_t v155 = 0LL;
            }
            id v156 = v155;
            uint64_t v157 = (void *)objc_claimAutoreleasedReturnValue([v156 objectForKeyedSubscript:v184]);
            _NRLogWithArgs( v154,  1LL,  "%s%.30s:%-4d Setting the peer IR endpoints as %@ ----> %@ for %@",  "",  "-[NRLinkManagerWiFi setPeerIREndpoints:forNRUUID:]",  1102LL,  v157,  v142,  v181);
          }

          id v158 = v137[16];
          __int128 v159 = v158;
          uint64_t v177 = v148;
          if (v158) {
            id v160 = (void *)*((void *)v158 + 9);
          }
          else {
            id v160 = 0LL;
          }
          id v161 = v160;
          [v161 setObject:v142 forKeyedSubscript:v184];

          uint64_t v179 = (uint64_t)v137;
          id v162 = [v137[19] copy];
          __int128 v189 = 0u;
          __int128 v190 = 0u;
          __int128 v191 = 0u;
          __int128 v192 = 0u;
          id v163 = v162;
          id v164 = [v163 countByEnumeratingWithState:&v189 objects:&v194 count:16];
          if (v164)
          {
            id v165 = v164;
            uint64_t v166 = *(void *)v190;
            do
            {
              for (m = 0LL; m != v165; m = (char *)m + 1)
              {
                if (*(void *)v190 != v166) {
                  objc_enumerationMutation(v163);
                }
                __int128 v168 = *(void **)(*((void *)&v189 + 1) + 8LL * (void)m);
                if ([v168 subtype] == 104)
                {
                  id v169 = (void *)objc_claimAutoreleasedReturnValue([v168 remoteOuterEndpoint]);
                  unsigned __int8 v170 = -[NSMutableArray containsObject:](v142, "containsObject:", v169);

                  if ((v170 & 1) == 0)
                  {
                    __int128 v171 = (void *)objc_claimAutoreleasedReturnValue([v168 nrUUID]);
                    unsigned int v172 = [v171 isEqual:v184];

                    if (v172) {
                      [v168 cancelWithReason:@"Peer Wi-Fi endpoint changed"];
                    }
                  }
                }
              }

              id v165 = [v163 countByEnumeratingWithState:&v189 objects:&v194 count:16];
            }

            while (v165);
          }

          uint64_t v137 = (id *)v179;
          if (-[NSMutableArray count](v142, "count")) {
            sub_10013F988(v179);
          }
          else {
            sub_10013FF8C(v179);
          }
          id v4 = v182;
          uint64_t v148 = v177;
        }
      }
    }
  }
}

void sub_1000D77EC(uint64_t a1, void *a2)
{
  id v21 = a2;
  int v3 = *(void **)(a1 + 424);
  if (v3) {
    int v3 = (void *)v3[10];
  }
  id v4 = v3;
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v4 UUIDString]);
  [v21 setPeerToken:v5];

  id v6 = *(void **)(a1 + 424);
  if (v6) {
    id v6 = (void *)v6[11];
  }
  unsigned __int8 v7 = v6;
  id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 UUIDString]);
  [v21 setLocalToken:v8];

  if ([v21 type] == 5)
  {
    int v10 = v21;
    id v11 = v10;
    uint64_t v12 = *(void *)(a1 + 424);
    BOOL v14 = 0;
    if (v12)
    {
      uint64_t v13 = *(void *)(v12 + 48);
      if ((v13 & 1) != 0 && ((v13 & 2) != 0 || (*(_BYTE *)(v12 + 56) & 2) != 0)) {
        BOOL v14 = 1;
      }
    }

    if ([v10 startRequested])
    {
      if (!v11)
      {
        if (!v14) {
          goto LABEL_21;
        }
        goto LABEL_18;
      }

      if (v14 != (v11[208] != 0))
      {
LABEL_18:
        [v11 cancelWithReason:@"classD support changed"];
LABEL_21:

        goto LABEL_22;
      }
    }

    else if (!v11)
    {
      goto LABEL_21;
    }

    v11[208] = v14;
    goto LABEL_21;
  }

BOOL sub_1000D79D4(uint64_t a1, int a2, BOOL a3, char a4, int a5, void *a6)
{
  id v11 = a6;
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    if (a2) {
      unsigned int v12 = 3;
    }
    else {
      unsigned int v12 = 2;
    }
    sub_1000D8CCC(a1, v12);
    uint64_t v13 = objc_alloc_init(&OBJC_CLASS___NRLinkDirectorRequest);
    uint64_t v15 = v13;
    if (v13)
    {
      if (a2) {
        char v16 = 2;
      }
      else {
        char v16 = 3;
      }
      v13->_type = v16;
      if (a2) {
        uint64_t v17 = 2LL;
      }
      else {
        uint64_t v17 = 3LL;
      }
      v13->_allowsSuspendedLinuint64_t k = byte_1001568EC[v17];
      *(_BYTE *)(a1 + 36) = v16;
      if (a5) {
        v13->_requiredLinkType = 1;
      }
      objc_setProperty_nonatomic_copy(v13, v14, v11, 48LL);
      v15->_attemptImmediately = a3;
      sub_1000D312C(a1, v15);
      if ((a4 & 1) != 0 && !v15->_complete) {
        sub_1000D551C(a1, v15);
      }
      BOOL complete = v15->_complete;
    }

    else
    {
      *(_BYTE *)(a1 + 36) = 0;
      sub_1000D312C(a1, 0LL);
      BOOL complete = 0LL;
      if ((a4 & 1) != 0)
      {
        sub_1000D551C(a1, 0LL);
        BOOL complete = 0LL;
      }
    }
  }

  else
  {
    BOOL complete = 0LL;
  }

  return complete;
}

void sub_1000D7B08(uint64_t a1, int a2)
{
  if (!a1) {
    return;
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
  if ((a2 & 1) == 0) {
    *(_BYTE *)(a1 + 15) = 0;
  }
  sub_1000D4F78(a1, 1008, @"%d -> %d", v4, v5, v6, v7, v8, *(unsigned __int8 *)(a1 + 14));
  int v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v9);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 1LL);

  if (IsLevelEnabled)
  {
    id v13 = *(id *)(a1 + 96);
    uint64_t v15 = (void *)_NRCopyLogObjectForNRUUID(v13, v14);
    int v16 = *(unsigned __int8 *)(a1 + 14);

    _NRLogWithArgs( v15,  1LL,  "%s%.30s:%-4d Setting prefer Wi-Fi request: %d -> %d",  "",  "-[NRDDeviceConductor setPreferWiFiRequest:]",  1885,  v16,  a2);
  }

  *(_BYTE *)(a1 + 14) = a2;
  if (*(void *)(a1 + 368))
  {
    if (a2) {
      goto LABEL_9;
    }
LABEL_18:
    if (*(_BYTE *)(a1 + 17))
    {
      id v28 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v12);
      int v29 = _NRLogIsLevelEnabled(v28, 1LL);

      if (v29)
      {
        uint64_t v31 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v30);
        _NRLogWithArgs( v31,  1LL,  "%s%.30s:%-4d Not cancelling Wi-Fi as we do not have good BT connectivity",  "",  "-[NRDDeviceConductor setPreferWiFiRequest:]",  1948);
      }

      id v32 = sub_1000D8B90(a1, 2, 102);
    }

    *(_BYTE *)(a1 + 19) = 0;
    *(_BYTE *)(a1 + 25) = 0;
    sub_1000D8CCC(a1, 2u);
    sub_1000D8CCC(a1, 7u);
    uint64_t v33 = mach_absolute_time();
    uint64_t v34 = *(void *)(a1 + 368);
    if (v34)
    {
      *(void *)(v34 + 24) = v33;
      id v35 = *(void **)(a1 + 368);
    }

    else
    {
      id v35 = 0LL;
    }

    [v35 submit];
    id v36 = *(void **)(a1 + 368);
    *(void *)(a1 + 36_Block_object_dispose(va, 8) = 0LL;

    sub_1000D8F48(a1, 0LL);
    *(_BYTE *)(a1 + 52) = 0;
    id v37 = *(void **)(a1 + 432);
    *(void *)(a1 + 432) = 0LL;

    sub_1000D8FF0(a1);
    id v38 = *(_BYTE **)(a1 + 624);
    if (v38 && (v38[16] & 1) != 0) {
      sub_1000D90D8(a1, v38);
    }
    return;
  }

  id v26 = objc_alloc_init(&OBJC_CLASS___NRAnalyticsPreferWiFi);
  id v27 = *(void **)(a1 + 368);
  *(void *)(a1 + 36_Block_object_dispose(va, 8) = v26;

  if (!*(_BYTE *)(a1 + 14)) {
    goto LABEL_18;
  }
LABEL_9:
  uint64_t v17 = *(void *)(a1 + 584);
  if (v17)
  {
    if ([*(id *)(a1 + 584) cancelled])
    {
      id v19 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v17 + 16), v18);
      int v20 = _NRLogIsLevelEnabled(v19, 2LL);

      if (v20)
      {
        id v22 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v17 + 16), v21);
        _NRLogWithArgs( v22,  2LL,  "%s%.30s:%-4d %@: cancelled, ignoring request",  "",  "-[NRAutoLinkUpgradeMonitor reportPreferWiFiRequest]",  440LL,  v17);
      }
    }
  }

  uint64_t v23 = mach_absolute_time();
  uint64_t v24 = *(void *)(a1 + 368);
  if (v24) {
    *(void *)(v24 + 16) = v23;
  }
  sub_1000D7F94(a1);
  if (sub_1000D8034(a1))
  {
    sub_1000D8174(a1);
  }

  else
  {
    id v39 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v25);
    int v40 = _NRLogIsLevelEnabled(v39, 1LL);

    if (v40)
    {
      id v42 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v41);
      _NRLogWithArgs( v42,  1LL,  "%s%.30s:%-4d Suspending BT link as we have prefer Wi-Fi request",  "",  "-[NRDDeviceConductor setPreferWiFiRequest:]",  1908);
    }

    sub_1000D8254(a1);
  }

  sub_1000D8434(a1);
  sub_1000D8670(a1);
  __int128 v51 = 0u;
  __int128 v52 = 0u;
  __int128 v49 = 0u;
  __int128 v50 = 0u;
  id v43 = *(id *)(a1 + 432);
  id v44 = [v43 countByEnumeratingWithState:&v49 objects:v55 count:16];
  if (v44)
  {
    id v45 = v44;
    uint64_t v46 = *(void *)v50;
    while (2)
    {
      for (uint64_t i = 0LL; i != v45; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v50 != v46) {
          objc_enumerationMutation(v43);
        }
        if ([*(id *)(*((void *)&v49 + 1) + 8 * (void)i) unsignedCharValue] == 101)
        {
          uint64_t v48 = (*(void *)(a1 + 592) >> 2) & 1LL;
          v53[0] = _NSConcreteStackBlock;
          v53[1] = 3221225472LL;
          v53[2] = sub_1000D8858;
          v53[3] = &unk_1001AF538;
          char v54 = v48;
          v53[4] = a1;
          sub_1000D8960(a1, 2, v48, v53);
          goto LABEL_42;
        }
      }

      id v45 = [v43 countByEnumeratingWithState:&v49 objects:v55 count:16];
      if (v45) {
        continue;
      }
      break;
    }
  }

void sub_1000D7F94(uint64_t a1)
{
  if (a1 && !*(_BYTE *)(a1 + 8))
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    sub_1000D8CCC(a1, 3u);
    self = objc_alloc_init(&OBJC_CLASS___NRLinkDirectorRequest);
    if (self)
    {
      self->_type = 9;
      self->_allowsSuspendedLinuint64_t k = 1;
      objc_setProperty_nonatomic_copy(self, v2, 0LL, 48LL);
      self->_attemptImmediately = 1;
    }

    sub_1000D312C(a1, self);
  }

uint64_t sub_1000D8034(uint64_t a1)
{
  uint64_t v2 = (unsigned __int8 *)sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 96));
  if (!v2)
  {
    id v5 = sub_1000D54AC();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16LL);

    if (IsLevelEnabled)
    {
      id v7 = sub_1000D54AC();
      _NRLogWithArgs( v7,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRDDeviceConductor isAlwaysOnWiFiSupported]",  2358);
    }

    uint64_t v8 = _os_log_pack_size(12LL);
    uint64_t v9 = (char *)&v13 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v10 = __error();
    uint64_t v11 = _os_log_pack_fill( v9,  v8,  *v10,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    *(_DWORD *)uint64_t v11 = 136446210;
    *(void *)(v11 + 4) = "-[NRDDeviceConductor isAlwaysOnWiFiSupported]";
    id v12 = sub_1000D54AC();
    _NRLogAbortWithPack(v12, v9);
  }

  uint64_t v3 = v2[17];

  return v3;
}

void sub_1000D8174(uint64_t a1)
{
  if (a1 && (sub_1000D4B98(a1, 5) & 1) == 0)
  {
    uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NRLinkDirectorRequest);
    uint64_t v4 = v2;
    if (v2)
    {
      v2->_type = 5;
      v2->_allowsSuspendedLinuint64_t k = 0;
      v2->_requiredLinkType = 2;
      newValue = _NSConcreteStackBlock;
      uint64_t v6 = 3221225472LL;
      id v7 = sub_1000DAA0C;
      uint64_t v8 = &unk_1001B0A88;
      uint64_t v9 = a1;
      objc_setProperty_nonatomic_copy(v2, v3, &newValue, 48LL);
    }

    else
    {
      newValue = _NSConcreteStackBlock;
      uint64_t v6 = 3221225472LL;
      id v7 = sub_1000DAA0C;
      uint64_t v8 = &unk_1001B0A88;
      uint64_t v9 = a1;
    }

    sub_1000D312C(a1, v4);
  }

void sub_1000D8254(uint64_t a1)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    id v2 = sub_1000D8B90(a1, 1, 0);
    id v18 = v2;
    if (v2)
    {
      if ([v2 state] == 1
        || [v18 state] == 9
        || [v18 state] == 8)
      {
        id v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v4);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 1LL);

        if (IsLevelEnabled)
        {
          uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v7);
          _NRLogWithArgs( v8,  1LL,  "%s%.30s:%-4d Suspending link: %@",  "",  "-[NRDDeviceConductor suspendLinkOfType:]",  3256LL,  v18);
        }

        [v18 suspend];
      }

      else
      {
        uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v4);
        int v15 = _NRLogIsLevelEnabled(v14, 1LL);

        if (v15)
        {
          uint64_t v17 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v16);
          _NRLogWithArgs( v17,  1LL,  "%s%.30s:%-4d Link will be suspended once it becomes ready: %@",  "",  "-[NRDDeviceConductor suspendLinkOfType:]",  3251LL,  v18);
        }

        [v18 setSuspendWhenReady:1];
      }
    }

    else
    {
      uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v3);
      int v10 = _NRLogIsLevelEnabled(v9, 1LL);

      if (v10)
      {
        id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v11);
        StringFromNRLinkType = (void *)createStringFromNRLinkType(1LL);
        _NRLogWithArgs( v12,  1LL,  "%s%.30s:%-4d Cannot suspend link as no link of type '%@' is available",  "",  "-[NRDDeviceConductor suspendLinkOfType:]",  3246LL,  StringFromNRLinkType);
      }
    }
  }

void sub_1000D8434(uint64_t a1)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    if (*(_BYTE *)(a1 + 19))
    {
      uint64_t v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v2);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1LL);

      if (IsLevelEnabled)
      {
        id v15 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v5);
        _NRLogWithArgs( v15,  1LL,  "%s%.30s:%-4d prefer Wi-Fi timeout already set",  "",  "-[NRDDeviceConductor setPreferWiFiTimeout]",  2219);
      }
    }

    else
    {
      *(_BYTE *)(a1 + 19) = 1;
      uint64_t v6 = objc_alloc_init(&OBJC_CLASS___NRLinkDirectorRequest);
      uint64_t v7 = v6;
      if (v6)
      {
        v6->_type = 7;
        v6->_allowsSuspendedLinuint64_t k = 0;
        objc_storeStrong((id *)&v6->_cancelIfLinkTypeReady, &off_1001BCA10);
        newValue = _NSConcreteStackBlock;
        uint64_t v20 = 3221225472LL;
        uint64_t v21 = sub_1000DA53C;
        id v22 = &unk_1001B0A88;
        uint64_t v23 = a1;
        objc_setProperty_nonatomic_copy(v7, v8, &newValue, 24LL);
        v7->_attemptImmediately = 1;
        v7->_timeout = 60LL;
      }

      else
      {
        newValue = _NSConcreteStackBlock;
        uint64_t v20 = 3221225472LL;
        uint64_t v21 = sub_1000DA53C;
        id v22 = &unk_1001B0A88;
        uint64_t v23 = a1;
      }

      sub_1000D8F48(a1, 0LL);
      id v9 = *(id *)(a1 + 432);
      int v10 = (void *)objc_claimAutoreleasedReturnValue([v9 firstObject]);

      if (v10)
      {
        unsigned int v11 = [v10 unsignedCharValue];
        if (v11 - 105 >= 0xFFFFFFFD && v7)
        {
          v7->_attemptImmediately = 1;
          v7->_timeout = 15LL;
        }

        sub_1000D8F48(a1, v11 == 102);
        BOOL v12 = *(_BYTE *)(a1 + 51) != 0;
      }

      else
      {
        BOOL v12 = 0;
      }

      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472LL;
      v16[2] = sub_1000DA56C;
      v16[3] = &unk_1001B00A0;
      v16[4] = a1;
      id v17 = v10;
      BOOL v18 = v12;
      id v14 = v10;
      if (v7) {
        objc_setProperty_nonatomic_copy(v7, v13, v16, 48LL);
      }
      sub_1000D312C(a1, v7);
    }
  }

void sub_1000D8670(uint64_t a1)
{
  if (!a1) {
    return;
  }
  sub_1000D99BC(a1);
  if (*(_BYTE *)(a1 + 17))
  {
    sub_1000D9E00(a1);
    uint64_t v3 = (_BYTE *)(a1 + 14);
    if (!*(_BYTE *)(a1 + 14)) {
      goto LABEL_8;
    }
  }

  else
  {
    if (!*(_BYTE *)(a1 + 14)) {
      return;
    }
    uint64_t v3 = (_BYTE *)(a1 + 14);
  }

  sub_1000D8434(a1);
LABEL_8:
  uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 1LL);

  if (IsLevelEnabled)
  {
    uint64_t v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v6);
    _NRLogWithArgs( v7,  1LL,  "%s%.30s:%-4d supportsAWDL %d needsAWDL %d preferWiFiRequest %d",  "",  "-[NRDDeviceConductor enableWiFiAutojoin]",  2517,  *(unsigned __int8 *)(a1 + 10),  *(unsigned __int8 *)(a1 + 51),  *(unsigned __int8 *)(a1 + 14));
  }

  if (*(_BYTE *)(a1 + 10) && *(_BYTE *)(a1 + 51) && *v3)
  {
    sub_1000D9FE0(a1);
  }

  else
  {
    sub_1000D9D2C(a1, 1);
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    id v13 = sub_1000D8B90(a1, 2, 101);
    if (*(_BYTE *)(a1 + 47) && *(_BYTE *)(a1 + 17) && !*v3 && !*(_BYTE *)(a1 + 27))
    {
      id v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v8);
      int v10 = _NRLogIsLevelEnabled(v9, 1LL);

      if (v10)
      {
        BOOL v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v11);
        _NRLogWithArgs( v12,  1LL,  "%s%.30s:%-4d not adding suspend BT request",  "",  "-[NRDDeviceConductor enableWiFiAutojoin]",  2546);
      }
    }

    else
    {
      sub_1000D8174(a1);
    }
  }

void sub_1000D8858(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 40))
  {
    uint64_t v2 = *(dispatch_queue_t **)(a1 + 32);
    if (v2)
    {
      dispatch_assert_queue_V2(v2[13]);
      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      id v3 = (id)qword_1001DC870;
      uint64_t v4 = v3;
      if (v3) {
        uint64_t v5 = (void *)*((void *)v3 + 6);
      }
      else {
        uint64_t v5 = 0LL;
      }
      uint64_t v6 = v5;

      if (v6) {
        uint64_t v2 = (dispatch_queue_t *)v6[7];
      }
      else {
        uint64_t v2 = 0LL;
      }
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    uint64_t v7 = v2;

    if (!v7)
    {
      uint64_t v8 = *(void *)(a1 + 32);
      if (v8)
      {
        id v9 = *(id *)(v8 + 624);
        if (v9) {
          v9[4] |= 8u;
        }
      }

      else
      {
        id v9 = 0LL;
      }
    }
  }

void sub_1000D8960(uint64_t a1, int a2, char a3, void *a4)
{
  uint64_t v7 = a4;
  if (!*(_BYTE *)(a1 + 11)) {
    goto LABEL_36;
  }
  uint64_t v20 = v7;
  if (a2 == 1)
  {
    uint64_t v9 = 616LL;
  }

  else
  {
    if (a2 != 2)
    {
      id v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v8);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v14, 16LL);

      if (!IsLevelEnabled)
      {
        int v10 = 0LL;
        goto LABEL_19;
      }

      uint64_t v11 = (_BYTE *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v16);
      _NRLogWithArgs( v11,  16LL,  "%s%.30s:%-4d unsupported report type %u",  "",  "-[NRDDeviceConductor copyLinkUpgradeReportForType:]",  5084,  a2);
      int v10 = 0LL;
      goto LABEL_17;
    }

    uint64_t v9 = 624LL;
  }

  int v10 = (int *)*(id *)(a1 + v9);
  if (v10) {
    goto LABEL_18;
  }
  uint64_t v11 = (id)sub_1000669BC(objc_alloc(&OBJC_CLASS___NRLinkUpgradeReport), a2);
  unsigned __int8 v12 = [*(id *)(a1 + 128) type];
  if (v11) {
    v11[11] = v12;
  }
  unsigned __int8 v13 = [*(id *)(a1 + 128) subtype];
  if (v11)
  {
    v11[12] = v13;
    if (*(_BYTE *)(a1 + 29)) {
      *((_DWORD *)v11 + 4) |= 0x100u;
    }
    if (*(void *)(a1 + 256)) {
      *((_DWORD *)v11 + 4) |= 0x200u;
    }
  }

  int v10 = (int *)v11;
LABEL_17:

LABEL_18:
  if (a2 == 2)
  {
    uint64_t v17 = 624LL;
LABEL_25:
    objc_storeStrong((id *)(a1 + v17), v10);
    goto LABEL_26;
  }

id sub_1000D8B90(uint64_t a1, int a2, int a3)
{
  if (!a1) {
    return 0LL;
  }
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  id v5 = *(id *)(a1 + 112);
  id v6 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v14;
LABEL_5:
    uint64_t v9 = 0LL;
    while (1)
    {
      if (*(void *)v14 != v8) {
        objc_enumerationMutation(v5);
      }
      int v10 = *(void **)(*((void *)&v13 + 1) + 8 * v9);
      if (objc_msgSend(v10, "type", (void)v13) == a2
        && [v10 subtype] == a3)
      {
        break;
      }

      if (v7 == (id)++v9)
      {
        id v7 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
        if (!v7) {
          goto LABEL_12;
        }
        goto LABEL_5;
      }
    }

    id v11 = v10;
  }

  else
  {
LABEL_12:
    id v11 = 0LL;
  }

  return v11;
}

void sub_1000D8CCC(uint64_t a1, unsigned int a2)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    __int128 v22 = 0u;
    __int128 v23 = 0u;
    id v4 = *(id *)(a1 + 120);
    id v5 = [v4 countByEnumeratingWithState:&v22 objects:v26 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v23;
      while (2)
      {
        uint64_t v8 = 0LL;
        do
        {
          if (*(void *)v23 != v7) {
            objc_enumerationMutation(v4);
          }
          uint64_t v9 = *(unsigned __int8 **)(*((void *)&v22 + 1) + 8LL * (void)v8);
          if (v9)
          {
            if (v9[10] == a2)
            {
              uint64_t v17 = v9;

              sub_1000D551C(a1, v17);
              uint64_t v19 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v18);
              int IsLevelEnabled = _NRLogIsLevelEnabled(v19, 1LL);

              if (!IsLevelEnabled) {
                goto LABEL_26;
              }
              __int128 v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v21);
              if (a2 > 0xB) {
                __int128 v16 = @"Unknown";
              }
              else {
                __int128 v16 = -[NSString initWithUTF8String:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithUTF8String:",  (&off_1001AFA78)[a2]);
              }
              _NRLogWithArgs( v15,  1LL,  "%s%.30s:%-4d Removed request of type %@",  "",  "-[NRDDeviceConductor removeRequestOfType:]",  2732LL,  v16,  (void)v22);
              goto LABEL_25;
            }
          }

          else if (!a2)
          {
            goto LABEL_14;
          }

          uint64_t v8 = (char *)v8 + 1;
        }

        while (v6 != v8);
        id v10 = [v4 countByEnumeratingWithState:&v22 objects:v26 count:16];
        id v6 = v10;
        if (v10) {
          continue;
        }
        break;
      }
    }

void sub_1000D8F48(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    int v2 = a2;
    if (*(unsigned __int8 *)(a1 + 51) != (_DWORD)a2)
    {
      id v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), a2);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

      if (IsLevelEnabled)
      {
        uint64_t v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v6);
        _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d needsAWDL %d -> %d",  "",  "-[NRDDeviceConductor setNeedsAWDL:]",  1513,  *(unsigned __int8 *)(a1 + 51),  v2);
      }

      *(_BYTE *)(a1 + 51) = v2;
    }
  }

void sub_1000D8FF0(uint64_t a1)
{
  if (a1)
  {
    sub_1000D99BC(a1);
    id v2 = sub_1000D8B90(a1, 2, 102);
    id v5 = v2;
    if (*(_BYTE *)(a1 + 17) || *(_BYTE *)(a1 + 14))
    {
    }

    else
    {
      if (!*(_BYTE *)(a1 + 43))
      {
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
        id v3 = sub_1000D8B90(a1, 2, 101);
        id v4 = v3;
      }

      sub_1000D8CCC(a1, 5u);
      sub_1000D9D2C(a1, 0);
    }
  }

void sub_1000D90D8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (!a1 || !v3) {
    goto LABEL_71;
  }
  int v5 = *((unsigned __int8 *)v3 + 8);
  uint64_t v83 = v3;
  if (v5 != 2)
  {
    if (v5 != 1)
    {
      id v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v4);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 16LL);

      id v3 = v83;
      if (!IsLevelEnabled) {
        goto LABEL_71;
      }
      int v13 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v12);
      _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d unsupported type",  "",  "-[NRDDeviceConductor submitLinkUpgradeReport:]",  5183);
      goto LABEL_70;
    }

    id v6 = *(id *)(a1 + 184);
    uint64_t v7 = v6;
    if (v6 && *((_BYTE *)v6 + 8)) {
      goto LABEL_7;
    }
    uint64_t v14 = *(id *)(a1 + 616);
    if (!v14 || !v14[8])
    {

LABEL_7:
      goto LABEL_8;
    }

    uint64_t v15 = *(void *)(a1 + 616);
    if (v15)
    {
      uint64_t v16 = *(void *)(v15 + 72);

      if (v16) {
        goto LABEL_8;
      }
    }

    else
    {
    }

    uint64_t v17 = mach_absolute_time();
    uint64_t v18 = *(void *)(a1 + 616);
    if (v18) {
      *(void *)(v18 + 72) = v17;
    }
LABEL_8:
    if ((*(_BYTE *)(a1 + 592) & 2) == 0)
    {
      uint64_t v8 = *(id *)(a1 + 616);
      if (v8 && v8[7] || (uint64_t v24 = *(void *)(a1 + 616)) == 0)
      {
      }

      else
      {
        uint64_t v25 = *(void *)(v24 + 48);

        if (v25)
        {
          uint64_t v26 = mach_absolute_time();
          uint64_t v27 = *(void *)(a1 + 616);
          if (v27) {
            *(void *)(v27 + 56) = v26;
          }
        }
      }
    }

    uint64_t v28 = *(void *)(a1 + 184);
    id v3 = v83;
    if (v28 && *(_BYTE *)(v28 + 8)) {
      goto LABEL_71;
    }
    uint64_t v29 = *(void *)(a1 + 592);
    if ((v29 & 2) != 0) {
      goto LABEL_71;
    }
    goto LABEL_45;
  }

  if (!*(_BYTE *)(a1 + 14))
  {
    uint64_t v19 = *(id *)(a1 + 624);
    if (v19 && v19[8])
    {
      uint64_t v20 = *(void *)(a1 + 624);
      if (v20)
      {
        uint64_t v21 = *(void *)(v20 + 72);

        if (v21) {
          goto LABEL_13;
        }
      }

      else
      {
      }

      uint64_t v22 = mach_absolute_time();
      uint64_t v23 = *(void *)(a1 + 624);
      if (v23) {
        *(void *)(v23 + 72) = v22;
      }
    }

    else
    {
    }
  }

void sub_1000D99BC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 17))
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    id v2 = sub_1000D8B90(a1, 1, 0);
    id v3 = v2;
    else {
      uint64_t v4 = 2LL;
    }
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  if (*(_BYTE *)(a1 + 14)) {
    uint64_t v5 = v4 | 4;
  }
  else {
    uint64_t v5 = v4;
  }
  if (!v5)
  {
    uint64_t v28 = 0LL;
    goto LABEL_44;
  }

  id v6 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v28 = v6;
  if (!*(_BYTE *)(a1 + 17))
  {
    if (!*(_BYTE *)(a1 + 14)) {
      goto LABEL_44;
    }
    if (*(_BYTE *)(a1 + 8)) {
      goto LABEL_19;
    }
  }

  -[NSMutableArray addObject:](v6, "addObject:", @"terminusd");
  if (*(_BYTE *)(a1 + 14))
  {
    if (*(_BYTE *)(a1 + 8))
    {
LABEL_19:
      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      uint64_t v7 = (id *)(id)qword_1001DC870;
      uint64_t v8 = v7;
      if (v7)
      {
        uint64_t v9 = (id *)v7[12];
        id v10 = v9;
        if (v9 && !*((_BYTE *)v9 + 15) && v9[8])
        {
          uint64_t v27 = v8;
          uint64_t v11 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
          __int128 v29 = 0u;
          __int128 v30 = 0u;
          __int128 v31 = 0u;
          __int128 v32 = 0u;
          uint64_t v26 = v10;
          uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v10[8] allValues]);
          id v13 = [v12 countByEnumeratingWithState:&v29 objects:v33 count:16];
          if (v13)
          {
            id v14 = v13;
            uint64_t v15 = *(void *)v30;
            do
            {
              for (uint64_t i = 0LL; i != v14; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v30 != v15) {
                  objc_enumerationMutation(v12);
                }
                id v18 = [v17 copyCParameters];

                uint64_t account_id = nw_parameters_get_account_id(v18);
                if (account_id)
                {
                  uint64_t v20 = (NSString *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  account_id));
LABEL_32:
                  -[NSMutableArray addObject:](v11, "addObject:", v20);
LABEL_33:

                  goto LABEL_34;
                }

                uint64_t pid = nw_parameters_get_pid(v18);
                if ((int)pid >= 1)
                {
                  uint64_t v20 = sub_10010393C(pid, 0);
                  if (!v20) {
                    goto LABEL_33;
                  }
                  goto LABEL_32;
                }

void sub_1000D9D2C(uint64_t a1, int a2)
{
  if ((a2 & 1) != 0 || !*(_BYTE *)(a1 + 17) && !*(_BYTE *)(a1 + 14))
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v4 = (id)qword_1001DC870;
    uint64_t v5 = v4;
    if (v4) {
      id v6 = (void *)*((void *)v4 + 6);
    }
    else {
      id v6 = 0LL;
    }
    id v7 = v6;

    sub_100140F48((uint64_t)v7, a2, *(void **)(a1 + 96));
  }

void sub_1000D9E00(uint64_t a1)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    if (*(_BYTE *)(a1 + 18))
    {
      id v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v2);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1LL);

      if (IsLevelEnabled)
      {
        id v10 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v5);
        _NRLogWithArgs( v10,  1LL,  "%s%.30s:%-4d Wi-Fi bring up timeout already set",  "",  "-[NRDDeviceConductor setWiFiLinkBringUpTimeout]",  2308);
      }
    }

    else
    {
      *(_BYTE *)(a1 + 1_Block_object_dispose(va, 8) = 1;
      id v6 = objc_alloc_init(&OBJC_CLASS___NRLinkDirectorRequest);
      id v7 = v6;
      if (v6)
      {
        v6->_type = 6;
        v6->_allowsSuspendedLinuint64_t k = 0;
        objc_storeStrong((id *)&v6->_timerDescription, @"WiFi-bringup-timeout");
        objc_storeStrong((id *)&v7->_cancelIfLinkTypeReady, &off_1001BCA28);
        newValue = _NSConcreteStackBlock;
        uint64_t v17 = 3221225472LL;
        id v18 = sub_1000DA0EC;
        uint64_t v19 = &unk_1001B0A88;
        uint64_t v20 = a1;
        objc_setProperty_nonatomic_copy(v7, v8, &newValue, 24LL);
        v7->_attemptImmediately = 1;
        v7->_timeout = 60LL;
        v7->_deferIfRequestExists = 5;
        uint64_t v11 = _NSConcreteStackBlock;
        uint64_t v12 = 3221225472LL;
        id v13 = sub_1000DA0FC;
        id v14 = &unk_1001B0A88;
        uint64_t v15 = a1;
        objc_setProperty_nonatomic_copy(v7, v9, &v11, 48LL);
      }

      else
      {
        uint64_t v15 = a1;
        newValue = _NSConcreteStackBlock;
        uint64_t v17 = 3221225472LL;
        id v18 = sub_1000DA0EC;
        uint64_t v19 = &unk_1001B0A88;
        uint64_t v20 = a1;
        uint64_t v11 = _NSConcreteStackBlock;
        uint64_t v12 = 3221225472LL;
        id v13 = sub_1000DA0FC;
        id v14 = &unk_1001B0A88;
      }

      sub_1000D312C(a1, v7);
    }
  }

void sub_1000D9FE0(uint64_t a1)
{
  if (a1 && *(_BYTE *)(a1 + 10))
  {
    id v2 = sub_1000D8B90(a1, 2, 102);
    id v8 = v2;
    if (v2)
    {
      if (([v2 startRequested] & 1) == 0)
      {
        if (*(_BYTE *)(a1 + 51) || *(_BYTE *)(a1 + 38) == 2)
        {
          [v8 start];
          if (!*(_BYTE *)(a1 + 56)) {
            sub_1000D8174(a1);
          }
        }

        else
        {
          sub_1000D8CCC(a1, 5u);
        }
      }
    }

    else
    {
      id v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v3);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 1LL);

      if (IsLevelEnabled)
      {
        id v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v6);
        _NRLogWithArgs( v7,  1LL,  "%s%.30s:%-4d no awdl link available",  "",  "-[NRDDeviceConductor startAWDLIfNeeded]",  3999);
      }
    }
  }

uint64_t sub_1000DA0EC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (v1) {
    *(_BYTE *)(v1 + 1_Block_object_dispose(va, 8) = 0;
  }
  return result;
}

void sub_1000DA0FC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3) {
    uint64_t v4 = *(void *)(v3 + 96);
  }
  else {
    uint64_t v4 = 0LL;
  }
  uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(v4, a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 1LL);

  if (IsLevelEnabled)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      uint64_t v9 = *(void *)(v8 + 96);
    }
    else {
      uint64_t v9 = 0LL;
    }
    id v10 = (void *)_NRCopyLogObjectForNRUUID(v9, v7);
    _NRLogWithArgs( v10,  1LL,  "%s%.30s:%-4d WiFi link failed to become ready in 60s. Giving up Wi-Fi assertion",  "",  "-[NRDDeviceConductor setWiFiLinkBringUpTimeout]_block_invoke_2",  2327);
  }

  uint64_t v11 = *(void *)(a1 + 32);
  if (v11)
  {
    *(_BYTE *)(v11 + 1_Block_object_dispose(va, 8) = 0;
    uint64_t v12 = *(void *)(a1 + 32);
    if (v12)
    {
      if ((*(_BYTE *)(v12 + 592) & 4) == 0
        || (id v13 = *(void **)(v12 + 584),
            id v14 = *(void **)(v12 + 608),
            uint64_t v15 = v13,
            sub_1000670E8(v15, v14),
            v15,
            (uint64_t v12 = *(void *)(a1 + 32)) != 0))
      {
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v12 + 104));
        sub_1000DA20C(v12, 0LL, 10LL);
      }
    }
  }

void sub_1000DA20C(uint64_t a1, int a2, unsigned int a3)
{
  if (*(unsigned __int8 *)(a1 + 17) != a2)
  {
    int v7 = *(unsigned __int8 *)(a1 + 22);
    uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v6);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 1LL);

    if (v7)
    {
      if (IsLevelEnabled)
      {
        id v24 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v10);
        _NRLogWithArgs( v24,  1LL,  "%s%.30s:%-4d Range extension disabled. Not bringing up Wi-Fi immediately",  "",  "-[NRDDeviceConductor setBringUpWiFiImmediatelyInner:timeout:addSuspendBTRequest:]",  2018);
      }
    }

    else
    {
      if (IsLevelEnabled)
      {
        id v11 = *(id *)(a1 + 96);
        id v13 = (void *)_NRCopyLogObjectForNRUUID(v11, v12);
        int v14 = *(unsigned __int8 *)(a1 + 17);

        _NRLogWithArgs( v13,  1LL,  "%s%.30s:%-4d Setting bringUpWiFiImmediately: %d -> %d",  "",  "-[NRDDeviceConductor setBringUpWiFiImmediatelyInner:timeout:addSuspendBTRequest:]",  2022,  v14,  a2);
      }

      *(_BYTE *)(a1 + 17) = a2;
      if (a2)
      {
        v32[0] = _NSConcreteStackBlock;
        v32[1] = 3221225472LL;
        v32[2] = sub_1000DA4E8;
        v32[3] = &unk_1001B0A88;
        void v32[4] = a1;
        uint64_t v15 = objc_retainBlock(v32);
        uint64_t v16 = v15;
        if (a3)
        {
          uint64_t v17 = objc_alloc_init(&OBJC_CLASS___NRLinkDirectorRequest);
          id v18 = v17;
          if (v17)
          {
            v17->_type = 6;
            v17->_allowsSuspendedLinuint64_t k = 0;
            objc_storeStrong((id *)&v17->_timerDescription, @"WiFi-bringup-hysteresis");
            objc_storeStrong((id *)&v18->_cancelIfLinkTypeReady, &off_1001BC9F8);
            v18->_attemptImmediately = 1;
            v18->_timeout = a3;
            objc_setProperty_nonatomic_copy(v18, v19, v16, 48LL);
          }

          sub_1000D312C(a1, v18);
        }

        else
        {
          uint64_t v20 = *(dispatch_queue_s **)(a1 + 104);
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472LL;
          block[2] = sub_1000DA4F0;
          block[3] = &unk_1001B0960;
          __int128 v31 = v15;
          dispatch_async(v20, block);
          id v18 = v31;
        }

        uint64_t v21 = objc_alloc_init(&OBJC_CLASS___NRLinkDirectorRequest);
        uint64_t v23 = v21;
        if (v21)
        {
          *(_WORD *)&v21->_type = 1284;
          v21->_allowsSuspendedLinuint64_t k = 0;
          v21->_requiredLinkType = 1;
          newValue = _NSConcreteStackBlock;
          uint64_t v26 = 3221225472LL;
          uint64_t v27 = sub_1000DA4FC;
          uint64_t v28 = &unk_1001B0A88;
          uint64_t v29 = a1;
          objc_setProperty_nonatomic_copy(v21, v22, &newValue, 48LL);
        }

        else
        {
          newValue = _NSConcreteStackBlock;
          uint64_t v26 = 3221225472LL;
          uint64_t v27 = sub_1000DA4FC;
          uint64_t v28 = &unk_1001B0A88;
          uint64_t v29 = a1;
        }

        sub_1000D312C(a1, v23);
      }

      else
      {
        sub_1000D8CCC(a1, 4u);
        sub_1000D8FF0(a1);
      }
    }
  }

void sub_1000DA4E8(uint64_t a1)
{
}

uint64_t sub_1000DA4F0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t sub_1000DA4FC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (v1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 104));
    return sub_1000DA20C(v1, 0LL, 10LL);
  }

  return result;
}

uint64_t sub_1000DA53C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 368);
    if (!v2 || (*(void *)(v2 + 40) = 1LL, (uint64_t v1 = *(void *)(result + 32)) != 0)) {
      *(_BYTE *)(v1 + 19) = 0;
    }
  }

  return result;
}

void sub_1000DA56C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 && *(_BYTE *)(v2 + 19))
  {
    if (*(void *)(a1 + 40))
    {
      objc_msgSend(*(id *)(v2 + 432), "removeObject:");
      uint64_t v2 = *(void *)(a1 + 32);
    }

    sub_1000D8F48(v2, 0LL);
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3 && (*(_BYTE *)(v3 + 19) = 0, (uint64_t v4 = *(void *)(a1 + 32)) != 0)) {
      uint64_t v5 = *(void **)(v4 + 432);
    }
    else {
      uint64_t v5 = 0LL;
    }
    id v6 = [v5 count];
    uint64_t v8 = *(void *)(a1 + 32);
    if (!v6)
    {
      if (v8 && ((v21 = *(void *)(v8 + 368)) == 0 || (*(void *)(v21 + 32) = 1LL, (uint64_t v8 = *(void *)(a1 + 32)) != 0))) {
        uint64_t v22 = *(void *)(v8 + 96);
      }
      else {
        uint64_t v22 = 0LL;
      }
      uint64_t v23 = (void *)_NRCopyLogObjectForNRUUID(v22, v7);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v23, 1LL);

      if (IsLevelEnabled)
      {
        uint64_t v32 = *(void *)(a1 + 32);
        if (v32) {
          uint64_t v33 = *(void *)(v32 + 96);
        }
        else {
          uint64_t v33 = 0LL;
        }
        uint64_t v34 = (void *)_NRCopyLogObjectForNRUUID(v33, v25);
        _NRLogWithArgs( v34,  1LL,  "%s%.30s:%-4d WiFi link failed to become ready in 60s. Could not honor prefer Wi-Fi ",  "",  "-[NRDDeviceConductor setPreferWiFiTimeout]_block_invoke_2",  2292);
      }

      sub_1000DA884(*(void *)(a1 + 32), @"WiFi link did not come up", v26, v27, v28, v29, v30, v31, v42);
      uint64_t v35 = *(void *)(a1 + 32);
      if (v35
        && ((*(_BYTE *)(v35 + 592) & 4) == 0
         || (double v36 = *(void **)(v35 + 608),
             double v37 = *(id *)(v35 + 584),
             sub_1000670E8(v37, v36),
             v37,
             (uint64_t v35 = *(void *)(a1 + 32)) != 0)))
      {
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v35 + 104));
        objc_opt_self(&OBJC_CLASS___NRLinkDirector);
        if (qword_1001DC878 != -1) {
          dispatch_once(&qword_1001DC878, &stru_1001AEED0);
        }
        id v38 = (id)qword_1001DC870;
        unint64_t v39 = v38;
        if (v38) {
          double v40 = (void *)*((void *)v38 + 6);
        }
        else {
          double v40 = 0LL;
        }
        id v43 = v40;

        sub_1001426F8((uint64_t)v43);
      }

      else
      {
        id v43 = 0LL;
        sub_1001426F8(0LL);
      }

      goto LABEL_35;
    }

    if (v8) {
      uint64_t v9 = *(void *)(v8 + 96);
    }
    else {
      uint64_t v9 = 0LL;
    }
    uint64_t v10 = (void *)_NRCopyLogObjectForNRUUID(v9, v7);
    int v11 = _NRLogIsLevelEnabled(v10, 0LL);

    if (v11)
    {
      uint64_t v12 = *(void **)(a1 + 32);
      if (v12) {
        uint64_t v12 = (void *)v12[12];
      }
      id v13 = v12;
      uint64_t v15 = (void *)_NRCopyLogObjectForNRUUID(v13, v14);
      id v16 = [*(id *)(a1 + 40) unsignedCharValue];

      StringFromNRLinkSubtype = (void *)createStringFromNRLinkSubtype(v16);
      _NRLogWithArgs( v15,  0LL,  "%s%.30s:%-4d Failed to upgrade to %@, trying next link",  "",  "-[NRDDeviceConductor setPreferWiFiTimeout]_block_invoke_2",  2273LL,  StringFromNRLinkSubtype);
    }

    sub_1000D8434(*(void *)(a1 + 32));
    int v18 = *(unsigned __int8 *)(a1 + 48);
    uint64_t v19 = *(void *)(a1 + 32);
    if (v18)
    {
      id v43 = sub_1000D8B90(v19, 2, 102);
      if ([v43 startRequested])
      {
        uint64_t v20 = @"AWDL link is not needed anymore";
LABEL_18:
        [v43 cancelWithReason:v20];
        goto LABEL_35;
      }

      goto LABEL_35;
    }

    if (!v19)
    {
      id v41 = 0LL;
      goto LABEL_36;
    }

    if (!*(_BYTE *)(v19 + 43))
    {
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(v19 + 104));
      id v41 = sub_1000D8B90(v19, 2, 101);
      if (!v41) {
        goto LABEL_36;
      }
      id v43 = v41;
      if ([v41 startRequested])
      {
        uint64_t v20 = @"Wi-Fi link is not needed anymore";
        goto LABEL_18;
      }

void sub_1000DA884( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1)
  {
    uint64_t v10 = *(dispatch_queue_s **)(a1 + 104);
    id v11 = a2;
    dispatch_assert_queue_V2(v10);
    uint64_t v12 = -[NSString initWithFormat:arguments:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:arguments:",  v11,  &a9);

    uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v13);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v14, 1LL);

    if (IsLevelEnabled)
    {
      uint64_t v17 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v16);
      _NRLogWithArgs( v17,  1LL,  "%s%.30s:%-4d Rejecting prefer Wi-Fi request: %@",  "",  "-[NRDDeviceConductor rejectPreferWiFiRequest:]",  3197LL,  v12);
    }

    sub_10011BB18(*(void **)(a1 + 96), 1009, 0LL, v12);
    *(_BYTE *)(a1 + 15) = 0;
    if (*(_BYTE *)(a1 + 14))
    {
      if (*(_BYTE *)(a1 + 19)) {
        *(_BYTE *)(a1 + 19) = 0;
      }
      sub_1000D79D4(a1, 0, 1, 0, 0, 0LL);
      sub_1000D7B08(a1, 0);
      *(void *)(a1 + 400) = mach_absolute_time();
    }

    else
    {
      uint64_t v19 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v18);
      int v20 = _NRLogIsLevelEnabled(v19, 1LL);

      if (v20)
      {
        uint64_t v22 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v21);
        _NRLogWithArgs( v22,  1LL,  "%s%.30s:%-4d ... we never had a prefer Wi-Fi request",  "",  "-[NRDDeviceConductor rejectPreferWiFiRequest:]",  3202);
      }
    }
  }

void sub_1000DAA0C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 104));
    id v2 = sub_1000D8B90(v1, 1, 0);
    if (v2)
    {
      id v3 = v2;
      if ([v2 state] != 255)
      {
        if ([v3 state] == 8)
        {
          [v3 suspend];
        }

        else if ([v3 state] != 9)
        {
          [v3 setSuspendWhenReady:1];
        }
      }

      id v2 = v3;
    }
  }

  else
  {
    id v2 = 0LL;
  }
}

void sub_1000DAAA4(uint64_t a1, char a2)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    if (*(_BYTE *)(a1 + 43))
    {
      uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NRLinkDirectorRequest);
      id v6 = v4;
      if (v4)
      {
        v4->_type = 1;
        v4->_requiredLinkType = 1;
        *(_WORD *)&v4->_attemptImmediately = 257;
        sub_1000D312C(a1, v4);
        uint64_t v5 = v6;
        if ((a2 & 1) == 0 || v6->_complete) {
          goto LABEL_7;
        }
      }

      else
      {
        sub_1000D312C(a1, 0LL);
        uint64_t v5 = 0LL;
        if ((a2 & 1) == 0) {
          goto LABEL_7;
        }
      }

      sub_1000D551C(a1, v6);
      uint64_t v5 = v6;
LABEL_7:
    }
  }

void sub_1000DAB5C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    if (*(_BYTE *)(v3 + 25))
    {
      *(_BYTE *)(v3 + 25) = 0;
      return;
    }

    uint64_t v4 = *(void *)(v3 + 96);
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(v4, a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 17LL);

  if (IsLevelEnabled)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      uint64_t v9 = *(void *)(v8 + 96);
    }
    else {
      uint64_t v9 = 0LL;
    }
    id v10 = (id)_NRCopyLogObjectForNRUUID(v9, v7);
    _NRLogWithArgs(v10, 17LL, "Sent prefer Wi-Fi request when we didn't have a pending request");
  }

void sub_1000DAC0C(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 40))
  {
    uint64_t v1 = *(void *)(a1 + 32);
    if (v1)
    {
      if (!*(_BYTE *)(v1 + 27))
      {
        id v2 = *(id *)(v1 + 616);
        if (v2) {
          v2[4] |= 8u;
        }
      }
    }

    else
    {
    }
  }

void sub_1000DAC60(uint64_t a1)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v2 = (unsigned __int8 *)(id)qword_1001DC870;
    if (v2 && (int v4 = v2[8], v2, v4))
    {
      uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v3);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

      if (IsLevelEnabled)
      {
        id v21 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v7);
        _NRLogWithArgs(v21, 0LL, "%s%.30s:%-4d Not starting QR link as conductor is operating in fixed interface mode");
LABEL_8:
      }
    }

    else if (*(_BYTE *)(a1 + 30))
    {
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
      id v9 = sub_1000D8B90(a1, 4, 0);
      if (v9)
      {
        *(void *)(a1 + 224) = mach_continuous_time();
        [v9 start];
        id v10 = objc_alloc_init(&OBJC_CLASS___NRLinkDirectorRequest);
        uint64_t v12 = v10;
        if (v10)
        {
          v10->_type = 8;
          v10->_allowsSuspendedLinuint64_t k = 0;
          v10->_requiredLinkType = 1;
          newValue = _NSConcreteStackBlock;
          uint64_t v23 = 3221225472LL;
          id v24 = sub_1000DAF10;
          uint64_t v25 = &unk_1001B0A88;
          uint64_t v26 = a1;
          objc_setProperty_nonatomic_copy(v10, v11, &newValue, 48LL);
        }

        else
        {
          newValue = _NSConcreteStackBlock;
          uint64_t v23 = 3221225472LL;
          id v24 = sub_1000DAF10;
          uint64_t v25 = &unk_1001B0A88;
          uint64_t v26 = a1;
        }

        sub_1000D312C(a1, v12);
      }

      else
      {
        uint64_t v17 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v8);
        int v18 = _NRLogIsLevelEnabled(v17, 0LL);

        if (v18)
        {
          int v20 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v19);
          _NRLogWithArgs( v20,  0LL,  "%s%.30s:%-4d No quick relay link",  "",  "-[NRDDeviceConductor startQuickRelayLinkIfApplicable:]",  1373);
        }
      }
    }

    else
    {
      uint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v3);
      int v14 = _NRLogIsLevelEnabled(v13, 0LL);

      if (v14)
      {
        id v15 = *(id *)(a1 + 96);
        id v21 = (id)_NRCopyLogObjectForNRUUID(v15, v16);

        _NRLogWithArgs( v21,  0LL,  "%s%.30s:%-4d Not starting quick relay link (hasQuickRelayRequest=%d, apsIsConnected=%d)");
        goto LABEL_8;
      }
    }
  }

void sub_1000DAF10(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 104));
    id v3 = sub_1000D8B90(v1, 4, 0);
    unsigned __int8 v2 = [v3 ikeClassDEstablished];
  }

  else
  {
    id v3 = 0LL;
    unsigned __int8 v2 = [0 ikeClassDEstablished];
  }

  else {
    [v3 cancelWithReason:@"BT reconnected"];
  }
}

void sub_1000DAF94(uint64_t a1)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    if ([*(id *)(a1 + 168) count])
    {
      xpc_object_t v2 = xpc_dictionary_create(0LL, 0LL, 0LL);
      if (!v2)
      {
        id v9 = sub_1000D54AC();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 16LL);

        if (IsLevelEnabled)
        {
          id v11 = sub_1000D54AC();
          _NRLogWithArgs( v11,  16LL,  "%s%.30s:%-4d ABORTING: xpc_dictionary_create(%p, %p, %u) failed",  "",  "nr_xpc_dictionary_create",  74,  0LL,  0LL,  0);
        }

        uint64_t v12 = _os_log_pack_size(38LL);
        uint64_t v13 = (char *)&v17 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        int v14 = __error();
        uint64_t v15 = _os_log_pack_fill( v13,  v12,  *v14,  &_mh_execute_header,  "%{public}s xpc_dictionary_create(%p, %p, %u) failed");
        sub_1000DB1A0(v15);
        id v16 = sub_1000D54AC();
        _NRLogAbortWithPack(v16, v13);
      }

      id v3 = v2;
      sub_1000DB1DC(a1, v2);

      __int128 v19 = 0u;
      __int128 v20 = 0u;
      __int128 v17 = 0u;
      __int128 v18 = 0u;
      id v4 = *(id *)(a1 + 168);
      id v5 = [v4 countByEnumeratingWithState:&v17 objects:v21 count:16];
      if (v5)
      {
        id v6 = v5;
        uint64_t v7 = *(void *)v18;
        do
        {
          uint64_t v8 = 0LL;
          do
          {
            if (*(void *)v18 != v7) {
              objc_enumerationMutation(v4);
            }
            xpc_connection_send_message(*(xpc_connection_t *)(*((void *)&v17 + 1) + 8LL * (void)v8), v3);
            uint64_t v8 = (char *)v8 + 1;
          }

          while (v6 != v8);
          id v6 = [v4 countByEnumeratingWithState:&v17 objects:v21 count:16];
        }

        while (v6);
      }
    }
  }

double sub_1000DB1A0(uint64_t a1)
{
  *(void *)&double result = 136446978LL;
  *(_DWORD *)a1 = 136446978;
  *(void *)(a1 + 4) = "nr_xpc_dictionary_create";
  *(_WORD *)(a1 + 12) = 2048;
  *(void *)(a1 + 14) = 0LL;
  *(_WORD *)(a1 + 22) = 2048;
  *(void *)(a1 + 24) = 0LL;
  *(_WORD *)(a1 + 32) = 1024;
  *(_DWORD *)(a1 + 34) = 0;
  return result;
}

id sub_1000DB1DC(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
  int v4 = *(unsigned __int8 *)(a1 + 26);
  int v5 = *(unsigned __int8 *)(a1 + 27);
  BOOL v6 = *(_BYTE *)(a1 + 27) != 0;
  int v7 = *(unsigned __int8 *)(a1 + 28);
  unsigned int v33 = *(_DWORD *)(a1 + 84);
  int v8 = *(unsigned __int8 *)(a1 + 62);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
  id v9 = *(id *)(a1 + 128);
  int v37 = v7;
  int v38 = v8;
  BOOL v36 = v6;
  if ([v9 state] != 8)
  {
    BOOL v13 = 0;
    BOOL v14 = 0;
    unsigned __int8 v34 = 0;
    unsigned __int8 v35 = 0;
    uint64_t v12 = 0LL;
    LOBYTE(v10) = 0;
    goto LABEL_14;
  }

  unsigned int v10 = [v9 type];
  unsigned __int8 v35 = [v9 subtype];
  unsigned __int8 v34 = [v9 ikeClassCEstablished];
  if (v10 - 1 < 2) {
    goto LABEL_47;
  }
  if (v10 == 4)
  {
    BOOL v14 = 0;
    uint64_t v12 = 0LL;
    BOOL v13 = 1;
    goto LABEL_14;
  }

  if (v10 == 5)
  {
LABEL_47:
    if (*(void *)(a1 + 448) && *(void *)(a1 + 464))
    {
      uint64_t v12 = (void *)NEVirtualInterfaceCopyName();
      BOOL v13 = 0;
      BOOL v14 = 1;
    }

    else
    {
      BOOL v13 = 0;
      uint64_t v12 = 0LL;
      BOOL v14 = 1;
    }
  }

  else
  {
    uint64_t v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v11);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v15, 17LL);

    if (IsLevelEnabled)
    {
      id v17 = *(id *)(a1 + 96);
      __int128 v19 = (void *)_NRCopyLogObjectForNRUUID(v17, v18);
      _NRLogWithArgs(v19, 17LL, "Link is ready when the link type is unknown/unsupported: %@", v9);
    }

    BOOL v13 = 0;
    BOOL v14 = 0;
    uint64_t v12 = 0LL;
  }

void *sub_1000DB570( uint64_t a1, void *a2, BOOL a3, BOOL a4, BOOL a5, BOOL a6, BOOL a7, BOOL a8, unsigned __int8 a9, unsigned __int8 a10, void *a11, unsigned int a12, BOOL a13, void *a14)
{
  id v18 = a2;
  id v19 = a11;
  id v20 = a14;
  objc_opt_self(a1);
  unint64_t v46 = v18;
  BOOL v21 = sub_100129C28((uint64_t)&OBJC_CLASS___NRDLocalDevice, v18, 0);
  id v22 = v20;
  uint64_t v23 = v22;
  if (v21)
  {
    xpc_dictionary_set_BOOL(v22, nrXPCKeyDeviceMonitorStatusIsRegistered, v21[8]);
    xpc_dictionary_set_BOOL(v23, nrXPCKeyDeviceMonitorStatusIsEnabled, v21[9]);
    __int128 v47 = 0uLL;
    sub_10012D7C8(v21, &v47);
    objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
    if (WORD5(v47)) {
      BOOL v24 = WORD6(v47) == 0;
    }
    else {
      BOOL v24 = 1;
    }
    int v25 = !v24;
    __int128 v47 = 0uLL;
    sub_100136A64(v21, &v47);
    objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
    if (WORD5(v47)) {
      BOOL v27 = WORD6(v47) == 0;
    }
    else {
      BOOL v27 = 1;
    }
    int v28 = !v27;
    if (v21[8])
    {
      int v29 = v21[9] ? v25 : 0;
      if ((v29 & v28 & 1) != 0)
      {
        unsigned int v30 = a10;
        unsigned int v31 = a9;
        uint64_t v32 = v19;
        BOOL v33 = a3;
        BOOL v34 = a7;
        goto LABEL_26;
      }
    }
  }

  else
  {
    xpc_dictionary_set_BOOL(v22, nrXPCKeyDeviceMonitorStatusIsRegistered, 0);
    xpc_dictionary_set_BOOL(v23, nrXPCKeyDeviceMonitorStatusIsEnabled, 0);
    int v25 = 0;
    int v28 = 0;
  }

  unsigned __int8 v35 = (void *)_NRCopyLogObjectForNRUUID(v46, v26);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v35, 0LL);

  if (IsLevelEnabled)
  {
    uint64_t v38 = _NRCopyLogObjectForNRUUID(v46, v37);
    unint64_t v39 = (void *)v38;
    if (v21)
    {
      int v40 = v21[8];
      int v41 = v21[9];
    }

    else
    {
      int v40 = 0;
      int v41 = 0;
    }

    _NRLogWithArgs( v38,  0LL,  "%s%.30s:%-4d Deferring the device monitor update (registered=%d, enabled=%d, hasClassDAddr=%d, hasClassCAddr=%d)",  "",  "+[NRDDeviceConductor createDeviceMonitorDictWithNRUUID:isNearby:isConnected:isCloudConnected:isAsleep:isClassCConn ected:hasUnpairedBluetooth:linkType:linkSubtype:proxySvcIntfName:thermalPressure:pluggedIn:replyDict:]",  1624,  v40,  v41,  v25,  v28);
  }

  unsigned int v30 = 0;
  uint64_t v32 = 0LL;
  unsigned int v31 = 0;
  BOOL v34 = 0;
  a6 = 0;
  a5 = 0;
  a4 = 0;
  BOOL v33 = 0;
LABEL_26:
  xpc_dictionary_set_BOOL(v23, nrXPCKeyDeviceMonitorStatusIsNearby, v33);
  xpc_dictionary_set_BOOL(v23, nrXPCKeyDeviceMonitorStatusIsConnected, a4);
  xpc_dictionary_set_BOOL(v23, nrXPCKeyDeviceMonitorStatusIsCloudConnected, a5);
  xpc_dictionary_set_BOOL(v23, nrXPCKeyDeviceMonitorStatusIsAsleep, a6);
  xpc_dictionary_set_BOOL(v23, nrXPCKeyDeviceMonitorStatusIsClassCConnected, v34);
  xpc_dictionary_set_BOOL(v23, nrXPCKeyDeviceMonitorStatusHasUnpairedBluetooth, a8);
  xpc_dictionary_set_uint64(v23, nrXPCKeyDeviceMonitorStatusLinkType, v31);
  xpc_dictionary_set_uint64(v23, nrXPCKeyDeviceMonitorStatusLinkSubtype, v30);
  if (v32) {
    xpc_dictionary_set_string( v23,  nrXPCKeyDeviceMonitorStatusProxySvcIntfName,  (const char *)[v32 UTF8String]);
  }
  xpc_dictionary_set_uint64(v23, nrXPCKeyDeviceMonitorStatusThermalPressureLevel, a12);
  xpc_dictionary_set_BOOL(v23, nrXPCKeyDeviceMonitorStatusPluggedIn, a13);

  return v23;
}

void sub_1000DB8E4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1 && *(_BYTE *)(v1 + 13) && *(void *)(a1 + 40) == *(void *)(v1 + 216))
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 104));
    id v3 = sub_1000D8B90(v1, 1, 0);
    id v15 = v3;
    if (v3 && ([v3 ikeClassDEstablished] & 1) != 0)
    {
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5) {
        uint64_t v6 = *(void *)(v5 + 96);
      }
      else {
        uint64_t v6 = 0LL;
      }
      int v7 = (void *)_NRCopyLogObjectForNRUUID(v6, v4);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0LL);

      if (IsLevelEnabled)
      {
        uint64_t v10 = *(void *)(a1 + 32);
        if (v10) {
          uint64_t v11 = *(void *)(v10 + 96);
        }
        else {
          uint64_t v11 = 0LL;
        }
        uint64_t v12 = (void *)_NRCopyLogObjectForNRUUID(v11, v9);
        _NRLogWithArgs( v12,  0LL,  "%s%.30s:%-4d Not activating QR agent",  "",  "-[NRDDeviceConductor pipeDidConnectForNRUUID:nrUUID:]_block_invoke",  6721);
      }
    }

    else
    {
      uint64_t v13 = *(void *)(a1 + 32);
      if (v13) {
        uint64_t v14 = *(void *)(v13 + 192);
      }
      else {
        uint64_t v14 = 0LL;
      }
      sub_1000300A8(v14);
    }
  }

void sub_1000DBA08(uint64_t a1, void *a2)
{
  id v4 = a2;
  uint64_t v5 = v4;
  if (a1)
  {
    id v18 = v4;
    unsigned int v6 = [v4 ikeClassDEstablished];
    uint64_t v5 = v18;
    if (v6)
    {
      unsigned int v7 = [v18 type];
      uint64_t v5 = v18;
      if (v7 != 4)
      {
        if (*(_BYTE *)(a1 + 27) && *(_BYTE *)(a1 + 26))
        {
          int v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v18);
          int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 1LL);

          if (IsLevelEnabled)
          {
            uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v10);
            _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d deferring sending thermal pressure level update",  "",  "-[NRDDeviceConductor sendDeviceThermalPressureLevelOnLink:]",  3929);
          }

          *(_BYTE *)(a1 + 64) = 1;
          goto LABEL_27;
        }

        *(_BYTE *)(a1 + 64) = 0;
        uint64_t v12 = (id *)sub_100021C64(objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage), *(void **)(a1 + 96));
        uint64_t v13 = v12;
        if (v12) {
          objc_storeStrong(v12 + 3, a2);
        }
        objc_opt_self(&OBJC_CLASS___NRLinkDirector);
        if (qword_1001DC878 != -1) {
          dispatch_once(&qword_1001DC878, &stru_1001AEED0);
        }
        uint64_t v14 = (unsigned int *)(id)qword_1001DC870;
        id v15 = v14;
        if (v14)
        {
          if (!v13)
          {
LABEL_26:

            sub_100023824((uint64_t)v13);
LABEL_27:
            uint64_t v5 = v18;
            goto LABEL_28;
          }

          unsigned int v16 = v14[5];
          if (v16)
          {
            if (v16 >= 0xB)
            {
              if (v16 >= 0x15)
              {
                if (v16 >= 0x1F)
                {
                  if (v16 >= 0x29) {
                    LOBYTE(v16) = 50;
                  }
                  else {
                    LOBYTE(v16) = 40;
                  }
                }

                else
                {
                  LOBYTE(v16) = 30;
                }
              }

              else
              {
                LOBYTE(v16) = 20;
              }
            }

            else
            {
              LOBYTE(v16) = 10;
            }
          }
        }

        else
        {
          if (!v13) {
            goto LABEL_26;
          }
          LOBYTE(v16) = 0;
        }

        char v19 = v16;
        id v17 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v19, 1LL);
        sub_1000222F4((uint64_t)v13, 14, v17);

        goto LABEL_26;
      }
    }
  }

void sub_1000DBBF8(uint64_t a1, void *a2)
{
  id v4 = a2;
  uint64_t v5 = v4;
  if (a1)
  {
    id v18 = v4;
    unsigned int v6 = [v4 ikeClassDEstablished];
    uint64_t v5 = v18;
    if (v6)
    {
      unsigned int v7 = [v18 type];
      uint64_t v5 = v18;
      if (v7 != 4)
      {
        if (*(_BYTE *)(a1 + 27) && *(_BYTE *)(a1 + 26))
        {
          int v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v18);
          int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 1LL);

          if (IsLevelEnabled)
          {
            uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v10);
            _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d deferring sending device state update",  "",  "-[NRDDeviceConductor sendDeviceStateUpdateOnLink:]",  3909);
          }

          *(_BYTE *)(a1 + 65) = 1;
          goto LABEL_17;
        }

        *(_BYTE *)(a1 + 65) = 0;
        uint64_t v12 = (id *)sub_100021C64(objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage), *(void **)(a1 + 96));
        uint64_t v13 = v12;
        if (v12) {
          objc_storeStrong(v12 + 3, a2);
        }
        objc_opt_self(&OBJC_CLASS___NRLinkDirector);
        if (qword_1001DC878 != -1) {
          dispatch_once(&qword_1001DC878, &stru_1001AEED0);
        }
        id v14 = (id)qword_1001DC870;
        id v15 = v14;
        if (v14)
        {
          BOOL v16 = *((_BYTE *)v14 + 11) != 0;
          if (!v13)
          {
LABEL_16:

            sub_100023824((uint64_t)v13);
LABEL_17:
            uint64_t v5 = v18;
            goto LABEL_18;
          }
        }

        else
        {
          BOOL v16 = 0;
          if (!v13) {
            goto LABEL_16;
          }
        }

        BOOL v19 = v16;
        id v17 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v19, 1LL);
        sub_1000222F4((uint64_t)v13, 22, v17);

        goto LABEL_16;
      }
    }
  }

void sub_1000DBDAC(uint64_t a1, void *a2)
{
  id v4 = a2;
  uint64_t v5 = v4;
  if (a1)
  {
    if (v4)
    {
      if (*(void *)(a1 + 488))
      {
        BOOL v21 = v4;
        unsigned int v6 = [v4 ikeClassDEstablished];
        uint64_t v5 = v21;
        if (v6)
        {
          unsigned int v7 = [v21 state];
          uint64_t v5 = v21;
          if (v7 != 255)
          {
            unsigned int v8 = [v21 type];
            uint64_t v5 = v21;
            if (v8 != 4)
            {
              if (!*(_BYTE *)(a1 + 26) || !*(_BYTE *)(a1 + 27))
              {
                uint64_t v11 = sub_100017030(*(void *)(a1 + 488));
                if (v11)
                {
                  uint64_t v12 = *(void *)(a1 + 488);
                  if (v12) {
                    uint64_t v12 = *(void *)(v12 + 32);
                  }
                  *(void *)(a1 + 496) = v12;
                  uint64_t v13 = (id *)sub_100021C64(objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage), *(void **)(a1 + 96));
                  id v14 = v13;
                  if (v13) {
                    objc_storeStrong(v13 + 3, a2);
                  }
                  sub_1000222F4((uint64_t)v14, 12, v11);
                  sub_100023824((uint64_t)v14);
                  BOOL v16 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v15);
                  int IsLevelEnabled = _NRLogIsLevelEnabled(v16, 1LL);

                  if (IsLevelEnabled)
                  {
                    id v18 = *(id *)(a1 + 96);
                    id v20 = (void *)_NRCopyLogObjectForNRUUID(v18, v19);
                    _NRLogWithArgs( v20,  1LL,  "%s%.30s:%-4d sending net-info update %@ generation %llu on %@",  "",  "-[NRDDeviceConductor sendNetInfoOnLink:]",  934LL,  *(void *)(a1 + 488),  *(void *)(a1 + 496),  v21);
                  }
                }

                goto LABEL_19;
              }

              uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v21);
              int v10 = _NRLogIsLevelEnabled(v9, 2LL);

              uint64_t v5 = v21;
              if (v10)
              {
                uint64_t v11 = (NSMutableData *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v21);
                _NRLogWithArgs( v11,  2LL,  "%s%.30s:%-4d deferring net-info update as peer is asleep",  "",  "-[NRDDeviceConductor sendNetInfoOnLink:]",  920);
LABEL_19:

                uint64_t v5 = v21;
              }
            }
          }
        }
      }
    }
  }
}

void sub_1000DBF8C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 104));
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v3 = (id)qword_1001DC870;
    id v4 = v3;
    if (v3) {
      uint64_t v5 = (void *)*((void *)v3 + 6);
    }
    else {
      uint64_t v5 = 0LL;
    }
    unsigned int v6 = v5;

    if (v6 && (uint64_t v7 = v6[13]) != 0) {
      int v8 = *(_DWORD *)(v7 + 12);
    }
    else {
      int v8 = 0;
    }
  }

  else
  {
    unsigned int v6 = 0LL;
    int v8 = 0;
  }

  uint64_t v9 = *(void **)(a1 + 40);
  if (!v9)
  {
    uint64_t v11 = 0LL;
    uint64_t v57 = *(void *)(a1 + 32);
    if (!v57) {
      goto LABEL_97;
    }
    goto LABEL_59;
  }

  int v10 = sub_1000234F4(v9, v8, 0);
  uint64_t v11 = v10;
  if (v10 && -[NSMutableArray count](v10, "count"))
  {
    unint64_t v12 = sub_100020CF0(*(void *)(a1 + 40));
    uint64_t v14 = *(void *)(a1 + 32);
    if (v14)
    {
      if (v12 == *(void *)(v14 + 320))
      {
LABEL_14:
        uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v11, "firstObject"));
        uint64_t v16 = *(void *)(a1 + 32);
        if (v16)
        {
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(v16 + 104));
          objc_opt_self(&OBJC_CLASS___NRLinkDirector);
          if (qword_1001DC878 != -1) {
            dispatch_once(&qword_1001DC878, &stru_1001AEED0);
          }
          id v17 = (id)qword_1001DC870;
          id v18 = v17;
          if (v17) {
            uint64_t v19 = (void *)*((void *)v17 + 6);
          }
          else {
            uint64_t v19 = 0LL;
          }
          id v20 = v19;
        }

        else
        {
          id v20 = 0LL;
        }

        id v258 = v15;
        BOOL v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v258, 1LL));
        uint64_t v22 = *(void *)(a1 + 32);
        if (v22) {
          uint64_t v23 = *(void **)(v22 + 96);
        }
        else {
          uint64_t v23 = 0LL;
        }
        sub_100140720(v20, v21, v23);

        BOOL v24 = (void *)objc_claimAutoreleasedReturnValue([v15 addressData]);
        uint64_t v25 = *(void *)(a1 + 32);
        if (v25) {
          uint64_t v26 = *(void **)(v25 + 96);
        }
        else {
          uint64_t v26 = 0LL;
        }
        sub_10009FCD0(v26, @"WiFiEndpointAddressData", v24);
        uint64_t v27 = *(void *)(a1 + 32);
        if (v27)
        {
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(v27 + 104));
          objc_opt_self(&OBJC_CLASS___NRLinkDirector);
          if (qword_1001DC878 != -1) {
            dispatch_once(&qword_1001DC878, &stru_1001AEED0);
          }
          id v28 = (id)qword_1001DC870;
          int v29 = v28;
          if (v28) {
            unsigned int v30 = (void *)*((void *)v28 + 6);
          }
          else {
            unsigned int v30 = 0LL;
          }
          id v31 = v30;

          uint64_t v32 = *(void **)(a1 + 32);
          if (v32) {
            uint64_t v32 = (void *)v32[12];
          }
        }

        else
        {
          id v31 = 0LL;
          uint64_t v32 = 0LL;
        }

        BOOL v33 = v32;
        id v34 = sub_100140B30((uint64_t)v31, v33);
        unsigned __int8 v35 = (void *)objc_claimAutoreleasedReturnValue(v34);
        sub_1000D4F78(v27, 1010, @"received Wi-Fi address update: %@", v36, v37, v38, v39, v40, (uint64_t)v35);

        int v41 = *(void **)(a1 + 40);
        if (v41)
        {
          uint64_t v42 = sub_1000229A0(v41, 4LL);
          id v43 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v42, "firstObject"));

          if (v43)
          {
            id v44 = [v43 length];
            uint64_t v45 = *(void *)(a1 + 32);
            if (v44)
            {
              if (v45)
              {
                dispatch_assert_queue_V2(*(dispatch_queue_t *)(v45 + 104));
                objc_opt_self(&OBJC_CLASS___NRLinkDirector);
                if (qword_1001DC878 != -1) {
                  dispatch_once(&qword_1001DC878, &stru_1001AEED0);
                }
                id v46 = (id)qword_1001DC870;
                __int128 v47 = v46;
                if (v46) {
                  unint64_t v48 = (void *)*((void *)v46 + 6);
                }
                else {
                  unint64_t v48 = 0LL;
                }
                id v49 = v48;
              }

              else
              {
                id v49 = 0LL;
              }

              sub_100140538((uint64_t)v49, v43);
            }

            else
            {
              if (v45)
              {
                dispatch_assert_queue_V2(*(dispatch_queue_t *)(v45 + 104));
                objc_opt_self(&OBJC_CLASS___NRLinkDirector);
                if (qword_1001DC878 != -1) {
                  dispatch_once(&qword_1001DC878, &stru_1001AEED0);
                }
                id v58 = (id)qword_1001DC870;
                id v59 = v58;
                if (v58) {
                  id v60 = (void *)*((void *)v58 + 6);
                }
                else {
                  id v60 = 0LL;
                }
                id v49 = v60;
              }

              else
              {
                id v49 = 0LL;
              }

              sub_100140538((uint64_t)v49, 0LL);
            }

            uint64_t v61 = *(void *)(a1 + 32);
            if (v61) {
              uint64_t v62 = *(void **)(v61 + 96);
            }
            else {
              uint64_t v62 = 0LL;
            }
            sub_10009FCD0(v62, @"WiFiSignature", v43);
          }
        }

        else
        {
          id v43 = 0LL;
        }

        goto LABEL_58;
      }

      uint64_t v50 = *(void *)(v14 + 96);
    }

    else
    {
      if (!v12) {
        goto LABEL_14;
      }
      uint64_t v50 = 0LL;
    }

    __int128 v51 = (void *)_NRCopyLogObjectForNRUUID(v50, v13);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v51, 1LL);

    if (IsLevelEnabled)
    {
      uint64_t v53 = *(void **)(a1 + 32);
      if (v53) {
        uint64_t v53 = (void *)v53[12];
      }
      char v54 = v53;
      uint64_t v56 = (void *)_NRCopyLogObjectForNRUUID(v54, v55);
      _NRLogWithArgs( v56,  1LL,  "%s%.30s:%-4d Skipping WiFi address update message %@",  "",  "-[NRDDeviceConductor linkDidReceiveData:data:]_block_invoke",  6078LL,  *(void *)(a1 + 40));

      uint64_t v57 = *(void *)(a1 + 32);
      if (!v57) {
        goto LABEL_97;
      }
      goto LABEL_59;
    }
  }

LABEL_157:
        unint64_t v132 = sub_100020CF0(*(void *)(a1 + 40));
        uint64_t v134 = *(void *)(a1 + 32);
        if (v134)
        {
          if (v132 == *(void *)(v134 + 336)) {
            goto LABEL_159;
          }
          uint64_t v165 = *(void *)(v134 + 96);
        }

        else
        {
          if (!v132)
          {
LABEL_159:
            int v140 = [v124 BOOLValue];
            uint64_t v141 = a1 + 32;
            __int128 v142 = "disable";
            if (v140) {
              __int128 v142 = "enable";
            }
            sub_1000D4F78(*(void *)(a1 + 32), 1021, @"%s", v135, v136, v137, v138, v139, (uint64_t)v142);
            if (*(void *)v141)
            {
              *(_BYTE *)(*(void *)v141 + 15LL) = 0;
              uint64_t v143 = *(void *)(a1 + 32);
              if ((v140 & 1) == 0)
              {
                if (v143)
                {
                  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v143 + 104));
                  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
                  if (qword_1001DC878 != -1) {
                    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
                  }
                  id v144 = (id)qword_1001DC870;
                  uint64_t v145 = v144;
                  if (v144) {
                    uint64_t v146 = (void *)*((void *)v144 + 6);
                  }
                  else {
                    uint64_t v146 = 0LL;
                  }
                  uint64_t v147 = v146;

                  if (v147)
                  {
                    uint64_t v148 = (dispatch_queue_s *)v147[3];
                    dispatch_assert_queue_V2(v148);

                    BOOL v149 = *((_DWORD *)v147 + 10) > 0;
                    uint64_t v150 = *(void *)(a1 + 32);
                    if (!v150) {
                      goto LABEL_171;
                    }
                    goto LABEL_170;
                  }

                  BOOL v149 = 0;
                  uint64_t v150 = *(void *)(a1 + 32);
                  if (v150) {
LABEL_170:
                  }
                    *(_BYTE *)(v150 + 25) = v149;
                }

                else
                {
                  uint64_t v147 = 0LL;
                }

LABEL_171:
                uint64_t v152 = *(void *)(a1 + 32);
                if (v152) {
                  uint64_t v153 = *(void *)(v152 + 96);
                }
                else {
                  uint64_t v153 = 0LL;
                }
                id v154 = (void *)_NRCopyLogObjectForNRUUID(v153, v151);
                int v155 = _NRLogIsLevelEnabled(v154, 0LL);

                uint64_t v143 = *(void *)(a1 + 32);
                if (v155)
                {
                  if (v143) {
                    id v156 = *(void **)(v143 + 96);
                  }
                  else {
                    id v156 = 0LL;
                  }
                  id v157 = v156;
                  uint64_t v159 = _NRCopyLogObjectForNRUUID(v157, v158);
                  id v160 = (void *)v159;
                  uint64_t v161 = *(void *)(a1 + 32);
                  if (v161) {
                    LODWORD(v161) = *(unsigned __int8 *)(v161 + 25);
                  }
                  _NRLogWithArgs( v159,  0LL,  "%s%.30s:%-4d Pending prefer Wi-Fi set to: %d",  "",  "-[NRDDeviceConductor linkDidReceiveData:data:]_block_invoke",  6139,  v161);

                  uint64_t v143 = *(void *)(a1 + 32);
                }
              }
            }

            else
            {
              uint64_t v147 = 0LL;
              uint64_t v143 = 0LL;
              if ((v140 & 1) == 0) {
                goto LABEL_171;
              }
            }

            if (v123) {
              sub_1000E0A7C(v143, v131);
            }
            else {
              sub_1000D7B08(v143, v140);
            }
            goto LABEL_223;
          }

          uint64_t v165 = 0LL;
        }

        uint64_t v166 = (void *)_NRCopyLogObjectForNRUUID(v165, v133);
        int v167 = _NRLogIsLevelEnabled(v166, 1LL);

        if (v167)
        {
          __int128 v168 = *(void **)(a1 + 32);
          if (v168) {
            __int128 v168 = (void *)v168[12];
          }
          id v169 = v168;
          __int128 v171 = (void *)_NRCopyLogObjectForNRUUID(v169, v170);
          _NRLogWithArgs( v171,  1LL,  "%s%.30s:%-4d Skipping Prefer Wi-Fi ACK message %@",  "",  "-[NRDDeviceConductor linkDidReceiveData:data:]_block_invoke",  6148LL,  *(void *)(a1 + 40));
        }

        goto LABEL_223;
      }

      id v128 = *(void **)(a1 + 40);
      if (v128)
      {
        __int128 v129 = sub_1000229A0(v128, 7LL);
        id v130 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v129, "firstObject"));

        if (v130 && [v130 length])
        {
          LOBYTE(v244) = 0;
          [v130 getBytes:&v244 length:1];
          if ((v244 & 1) != 0) {
            id v124 = &__kCFBooleanTrue;
          }
          else {
            id v124 = &__kCFBooleanFalse;
          }
        }

        else
        {
          id v124 = 0LL;
        }

        uint64_t v131 = 0LL;
        if (!v124) {
          goto LABEL_223;
        }
        goto LABEL_157;
      }
    }

    uint64_t v123 = 0LL;
    id v124 = 0LL;
    goto LABEL_226;
  }

  LOBYTE(v236) = 0;
  __int128 v235 = 0LL;
  unsigned int v125 = *(void **)(a1 + 40);
  if (!v125) {
    goto LABEL_262;
  }
  unsigned int v126 = sub_1000229A0(v125, 13LL);
  id v127 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v126, "firstObject"));

  if (v127)
  {
    [v127 getBytes:&v235 length:9];
    id v124 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  v235));
    uint64_t v123 = v127;
    if (!v124) {
      goto LABEL_226;
    }
    goto LABEL_194;
  }

  id v162 = *(void **)(a1 + 40);
  if (!v162)
  {
LABEL_262:
    id v124 = 0LL;
    uint64_t v123 = 0LL;
    goto LABEL_226;
  }

  id v163 = sub_1000229A0(v162, 5LL);
  id v164 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v163, "firstObject"));

  if (v164 && [v164 length])
  {
    LOBYTE(v244) = 0;
    [v164 getBytes:&v244 length:1];
    if ((v244 & 1) != 0) {
      id v124 = &__kCFBooleanTrue;
    }
    else {
      id v124 = &__kCFBooleanFalse;
    }
  }

  else
  {
    id v124 = 0LL;
  }

  uint64_t v123 = 0LL;
  if (!v124) {
    goto LABEL_226;
  }
LABEL_194:
  unint64_t v172 = sub_100020CF0(*(void *)(a1 + 40));
  uint64_t v174 = *(void *)(a1 + 32);
  if (!v174)
  {
    if (!v172) {
      goto LABEL_196;
    }
    uint64_t v192 = 0LL;
LABEL_209:
    uint64_t v193 = (void *)_NRCopyLogObjectForNRUUID(v192, v173);
    int v194 = _NRLogIsLevelEnabled(v193, 1LL);

    if (v194)
    {
      __int128 v195 = *(void **)(a1 + 32);
      if (v195) {
        __int128 v195 = (void *)v195[12];
      }
      __int128 v196 = v195;
      uint64_t v198 = (void *)_NRCopyLogObjectForNRUUID(v196, v197);
      _NRLogWithArgs( v198,  1LL,  "%s%.30s:%-4d Skipping Prefer Wi-Fi message %@",  "",  "-[NRDDeviceConductor linkDidReceiveData:data:]_block_invoke",  6215LL,  *(void *)(a1 + 40));
    }

    goto LABEL_226;
  }

  if (v172 != *(void *)(v174 + 328))
  {
    uint64_t v192 = *(void *)(v174 + 96);
    goto LABEL_209;
  }

LABEL_221:
    sub_1000D7B08(v183, v180);
    goto LABEL_226;
  }

  if (v183)
  {
    if (*(_BYTE *)(v183 + 14))
    {
      id v184 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v183 + 96), v182);
      int v185 = _NRLogIsLevelEnabled(v184, 1LL);

      if (v185)
      {
        __int128 v186 = *(void **)(a1 + 32);
        if (v186) {
          __int128 v186 = (void *)v186[12];
        }
        __int128 v187 = v186;
        uint64_t v189 = _NRCopyLogObjectForNRUUID(v187, v188);
        __int128 v190 = (void *)v189;
        uint64_t v191 = *(void *)(a1 + 32);
        if (v191) {
          LODWORD(v191) = *(unsigned __int8 *)(v191 + 14);
        }
        _NRLogWithArgs( v189,  1LL,  "%s%.30s:%-4d We already know about this prefer Wi-Fi request (%d). Ignoring this request",  "",  "-[NRDDeviceConductor linkDidReceiveData:data:]_block_invoke",  6170,  v191);
      }

      sub_1000D7F94(*(void *)(a1 + 32));
      goto LABEL_226;
    }

    if (v127)
    {
LABEL_225:
      sub_1000E0A7C(v183, v123);
      goto LABEL_226;
    }

    BOOL v206 = sub_1000E0EC4(v183);
    uint64_t v207 = *(void *)(a1 + 32);
    if (!v206)
    {
      if (v207) {
        *(_BYTE *)(v207 + 25) = 1;
      }
      goto LABEL_226;
    }
  }

  else
  {
    uint64_t v207 = 0LL;
    if (v127) {
      goto LABEL_225;
    }
  }

  id v208 = sub_1000D4CD4(v207);
  uint64_t v209 = objc_claimAutoreleasedReturnValue(v208);
  id v210 = (void *)v209;
  uint64_t v211 = *(void *)(a1 + 32);
  if (v211) {
    uint64_t v212 = *(void **)(v211 + 96);
  }
  else {
    uint64_t v212 = 0LL;
  }
  id v213 = sub_100140B30(v209, v212);
  uint64_t v214 = (void *)objc_claimAutoreleasedReturnValue(v213);

  uint64_t v216 = *(void *)(a1 + 32);
  if (v214)
  {
    if (v216) {
      uint64_t v217 = *(void *)(v216 + 96);
    }
    else {
      uint64_t v217 = 0LL;
    }
    int v218 = (void *)_NRCopyLogObjectForNRUUID(v217, v215);
    int v219 = _NRLogIsLevelEnabled(v218, 1LL);

    if (v219)
    {
      uint64_t v221 = *(void *)(a1 + 32);
      if (v221) {
        uint64_t v222 = *(void *)(v221 + 96);
      }
      else {
        uint64_t v222 = 0LL;
      }
      __int128 v223 = (void *)_NRCopyLogObjectForNRUUID(v222, v220);
      _NRLogWithArgs( v223,  1LL,  "%s%.30s:%-4d Honoring prefer Wi-Fi request",  "",  "-[NRDDeviceConductor linkDidReceiveData:data:]_block_invoke",  6203);
    }

    uint64_t v183 = *(void *)(a1 + 32);
    goto LABEL_221;
  }

  if (v216) {
    uint64_t v224 = *(void *)(v216 + 96);
  }
  else {
    uint64_t v224 = 0LL;
  }
  __int128 v225 = (void *)_NRCopyLogObjectForNRUUID(v224, v215);
  int v226 = _NRLogIsLevelEnabled(v225, 17LL);

  if (v226)
  {
    uint64_t v228 = *(void *)(a1 + 32);
    if (v228) {
      uint64_t v229 = *(void *)(v228 + 96);
    }
    else {
      uint64_t v229 = 0LL;
    }
    __int128 v230 = (void *)_NRCopyLogObjectForNRUUID(v229, v227);
    _NRLogWithArgs(v230, 17LL, "Could not enable prefer Wi-Fi request as no peer address found");
  }

LABEL_226:
}

void sub_1000DD460( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, char a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, char a30)
{
}

void sub_1000DD494(uint64_t a1, uint64_t a2)
{
  if (a1 && sub_1000E0798(a1, a2))
  {
    uint64_t v4 = *(void *)(a1 + 576);
    if (v4 && *(_BYTE *)(v4 + 9))
    {
      uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v3);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 2LL);

      if (IsLevelEnabled)
      {
        id v13 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v7);
        _NRLogWithArgs( v13,  2LL,  "%s%.30s:%-4d discovery proxy already running",  "",  "-[NRDDeviceConductor startDiscoveryProxyClientIfNeeded]",  4739);
      }

      return;
    }

    *(_BYTE *)(a1 + 71) = 1;
    objc_initWeak(&location, (id)a1);
    unsigned int v8 = *(_DWORD *)(a1 + 76);
    if (v8 >= 0xC)
    {
      LOBYTE(v_Block_object_dispose((const void *)(v30 - 136), 8) = 12;
      *(_DWORD *)(a1 + 76) = 12;
    }

    else if (!v8)
    {
      int64_t v9 = 0LL;
LABEL_12:
      dispatch_time_t v10 = dispatch_time(0LL, v9);
      uint64_t v11 = *(void **)(a1 + 104);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_1000E08A4;
      block[3] = &unk_1001AFED0;
      unint64_t v12 = v11;
      objc_copyWeak(&v15, &location);
      dispatch_after(v10, v12, block);

      objc_destroyWeak(&v15);
      objc_destroyWeak(&location);
      return;
    }

    int64_t v9 = 1000000000LL << (v8 + 1);
    goto LABEL_12;
  }

void sub_1000DD608(uint64_t a1)
{
  if (a1 && *(_BYTE *)(a1 + 61))
  {
    if (*(void *)(a1 + 576))
    {
      sub_1000E0670(a1, 0LL);
      [*(id *)(a1 + 576) cancel];
      uint64_t v2 = *(void **)(a1 + 576);
      *(void *)(a1 + 576) = 0LL;
    }

    uint64_t v3 = *(void **)(a1 + 568);
    if (v3)
    {
      [v3 cancel];
      uint64_t v4 = *(void **)(a1 + 568);
      *(void *)(a1 + 56_Block_object_dispose((const void *)(v30 - 136), 8) = 0LL;
    }

    *(_DWORD *)(a1 + 76) = 0;
    *(_BYTE *)(a1 + 71) = 0;
  }

void sub_1000DD678(uint64_t a1, int a2)
{
  if (a1 && *(_BYTE *)(a1 + 55))
  {
    uint64_t v4 = *(void **)(a1 + 504);
    *(void *)(a1 + 504) = 0LL;

    uint64_t v5 = *(void **)(a1 + 528);
    *(void *)(a1 + 52_Block_object_dispose((const void *)(v30 - 136), 8) = 0LL;

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v6 = (id)qword_1001DCB58;
    sub_10012114C((uint64_t)v6, *(void **)(a1 + 280));

    if (a2)
    {
      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      uint64_t v7 = (dispatch_queue_t *)(id)qword_1001DCB58;
      unsigned int v8 = v7;
      if (v7)
      {
        uint64_t v14 = (id *)v7;
        dispatch_assert_queue_V2(v7[1]);
        unsigned __int8 v9 = [v14[2] apply];
        unsigned int v8 = v14;
        if ((v9 & 1) == 0)
        {
          sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v10,  v11,  v12,  v13);
          unsigned int v8 = v14;
        }
      }
    }
  }

void sub_1000DD7C4(uint64_t a1)
{
  if (a1)
  {
    if ([*(id *)(a1 + 128) state] == 8)
    {
      *(_BYTE *)(a1 + 67) = 0;
      uint64_t v2 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 96));
      unsigned int v8 = v2;
      if (v2)
      {
        uint64_t v3 = 2LL;
        uint64_t v4 = 4LL;
        if (!*(_BYTE *)(a1 + 66))
        {
          uint64_t v3 = 4LL;
          uint64_t v4 = 8LL;
        }

        else {
          uint64_t v5 = v4;
        }
      }

      else
      {
        uint64_t v5 = 2LL;
        if (!*(_BYTE *)(a1 + 66)) {
          uint64_t v5 = 4LL;
        }
      }

      uint64_t v9 = v5;
      id v6 = (id *)sub_100021C64(objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage), *(void **)(a1 + 96));
      uint64_t v7 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v9, 8LL);
      sub_1000222F4((uint64_t)v6, 11, v7);
      if (v6) {
        objc_storeStrong(v6 + 3, *(id *)(a1 + 128));
      }
      sub_100023824((uint64_t)v6);
    }

    else
    {
      *(_BYTE *)(a1 + 67) = 1;
    }
  }

void sub_1000DD8EC(uint64_t a1)
{
  if (a1 && *(_BYTE *)(a1 + 55))
  {
    uint64_t v2 = *(void **)(a1 + 512);
    *(void *)(a1 + 512) = 0LL;

    uint64_t v3 = *(void **)(a1 + 520);
    *(void *)(a1 + 520) = 0LL;

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v4 = (id)qword_1001DCB58;
    sub_10012114C((uint64_t)v4, *(void **)(a1 + 288));

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    uint64_t v5 = (dispatch_queue_t *)(id)qword_1001DCB58;
    id v6 = v5;
    if (v5)
    {
      uint64_t v12 = (id *)v5;
      dispatch_assert_queue_V2(v5[1]);
      unsigned __int8 v7 = [v12[2] apply];
      id v6 = v12;
      if ((v7 & 1) == 0)
      {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v8,  v9,  v10,  v11);
        id v6 = v12;
      }
    }
  }

void sub_1000DDA30(uint64_t a1, char a2)
{
  if (a1)
  {
    uint64_t v2 = a1;
    if (*(void *)(a1 + 632))
    {
      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v4 = (id)qword_1001DCB58;
      sub_10012114C((uint64_t)v4, *(void **)(v2 + 312));

      char v54 = sub_1000E0378(v2);
      if (-[NSMutableArray count](v54, "count"))
      {
        char v51 = a2;
        uint64_t v5 = objc_claimAutoreleasedReturnValue( +[NEPolicyCondition requiredAgentDomain:agentType:]( &OBJC_CLASS___NEPolicyCondition,  "requiredAgentDomain:agentType:",  @"com.apple.networkrelay",  @"ASResolver"));
        id v49 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition requiredAgentDomain:agentType:]( &OBJC_CLASS___NEPolicyCondition,  "requiredAgentDomain:agentType:",  @"com.apple.networkrelay",  @"ASListener"));
        uint64_t v50 = (void *)v5;
        v77[0] = v5;
        v77[1] = v49;
        __int128 v67 = 0u;
        __int128 v68 = 0u;
        __int128 v69 = 0u;
        __int128 v70 = 0u;
        id obj = (id)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v77,  2LL));
        id v55 = [obj countByEnumeratingWithState:&v67 objects:v76 count:16];
        if (v55)
        {
          uint64_t v53 = *(void *)v68;
          uint64_t v6 = v2;
          do
          {
            uint64_t v7 = 0LL;
            do
            {
              if (*(void *)v68 != v53) {
                objc_enumerationMutation(obj);
              }
              uint64_t v56 = v7;
              uint64_t v10 = *(void *)(*((void *)&v67 + 1) + 8 * v7);
              __int128 v63 = 0u;
              __int128 v64 = 0u;
              __int128 v65 = 0u;
              __int128 v66 = 0u;
              uint64_t v11 = v54;
              id v12 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v11,  "countByEnumeratingWithState:objects:count:",  &v63,  v75,  16LL);
              if (v12)
              {
                id v13 = v12;
                uint64_t v14 = *(void *)v64;
                do
                {
                  for (uint64_t i = 0LL; i != v13; uint64_t i = (char *)i + 1)
                  {
                    if (*(void *)v64 != v14) {
                      objc_enumerationMutation(v11);
                    }
                    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult removeNetworkAgentUUID:]( &OBJC_CLASS___NEPolicyResult,  "removeNetworkAgentUUID:",  *(void *)(*((void *)&v63 + 1) + 8LL * (void)i)));
                    id v17 = objc_alloc(&OBJC_CLASS___NEPolicy);
                    id v18 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
                    v74[0] = v18;
                    v74[1] = v10;
                    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v74,  2LL));
                    id v20 = [v17 initWithOrder:10 result:v16 conditions:v19];

                    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                    if (qword_1001DCB60 != -1) {
                      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                    }
                    uint64_t v2 = v6;
                    id v21 = (id)qword_1001DCB58;
                    id v22 = sub_100120E44((uint64_t)v21, *(void **)(v6 + 312), v20);
                  }

                  id v13 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v11,  "countByEnumeratingWithState:objects:count:",  &v63,  v75,  16LL);
                }

                while (v13);
              }

              uint64_t v23 = *(void *)(v2 + 504);
              if (v23)
              {
                v73[0] = 0LL;
                v73[1] = 0LL;
                nw_agent_get_uuid(v23, v73);
                BOOL v24 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v73);
                uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult removeNetworkAgentUUID:]( &OBJC_CLASS___NEPolicyResult,  "removeNetworkAgentUUID:",  v24));
                id v26 = objc_alloc(&OBJC_CLASS___NEPolicy);
                uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
                v72[0] = v27;
                v72[1] = v10;
                id v28 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v72,  2LL));
                id v29 = [v26 initWithOrder:10 result:v25 conditions:v28];

                objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                if (qword_1001DCB60 != -1) {
                  dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                }
                uint64_t v2 = v6;
                id v8 = (id)qword_1001DCB58;
                id v9 = sub_100120E44((uint64_t)v8, *(void **)(v6 + 312), v29);
              }

              uint64_t v7 = v56 + 1;
            }

            while ((id)(v56 + 1) != v55);
            id v55 = [obj countByEnumeratingWithState:&v67 objects:v76 count:16];
          }

          while (v55);
        }

        a2 = v51;
      }

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v30 = (id)qword_1001DCB58;
      id v31 = (id *)v30;
      if (v30)
      {
        dispatch_assert_queue_V2(*((dispatch_queue_t *)v30 + 1));
        if (([v31[2] apply] & 1) == 0) {
          sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v32,  v33,  v34,  (uint64_t)v49);
        }
      }

      if ((a2 & 1) == 0)
      {
        uint64_t v35 = *(void *)(v2 + 448);
        if (v35)
        {
          uint64_t v36 = (void *)NEVirtualInterfaceCopyName(v35);
          if (v36) {
            sub_1000F71BC(*(void *)(v2 + 632), v36);
          }
        }

        else
        {
          uint64_t v36 = 0LL;
        }

        __int128 v61 = 0u;
        __int128 v62 = 0u;
        __int128 v59 = 0u;
        __int128 v60 = 0u;
        id v37 = *(id *)(v2 + 112);
        id v38 = [v37 countByEnumeratingWithState:&v59 objects:v71 count:16];
        if (v38)
        {
          id v39 = v38;
          uint64_t v40 = *(void *)v60;
          do
          {
            for (j = 0LL; j != v39; j = (char *)j + 1)
            {
              if (*(void *)v60 != v40) {
                objc_enumerationMutation(v37);
              }
              uint64_t v42 = *(void **)(*((void *)&v59 + 1) + 8LL * (void)j);
              if ([v42 virtualInterface])
              {
                id v43 = (void *)NEVirtualInterfaceCopyName([v42 virtualInterface]);
                unsigned int v44 = [v42 isPrimary];
                uint64_t v45 = *(void *)(v2 + 632);
                if (v44) {
                  sub_1000F708C(v45, v43);
                }
                else {
                  sub_1000F71BC(v45, v43);
                }
              }
            }

            id v39 = [v37 countByEnumeratingWithState:&v59 objects:v71 count:16];
          }

          while (v39);
        }

        if (!*(void *)(v2 + 128))
        {
          id v46 = objc_alloc_init(&OBJC_CLASS___NRLinkDirectorRequest);
          p_Class isa = (id *)&v46->super.isa;
          if (v46)
          {
            v46->_type = 6;
            *(_WORD *)&v46->_attemptImmediately = 1;
            v46->_timeout = 10LL;
            objc_storeStrong((id *)&v46->_timerDescription, @"Hysteresis for AS registrations");
            objc_storeStrong(p_isa + 2, &off_1001BCA70);
          }

          newValue[0] = _NSConcreteStackBlock;
          newValue[1] = 3221225472LL;
          newValue[2] = sub_1000E064C;
          newValue[3] = &unk_1001B0720;
          newValue[4] = v2;
          id v58 = v36;
          if (p_isa) {
            objc_setProperty_nonatomic_copy(p_isa, v48, newValue, 48LL);
          }
          sub_1000D312C(v2, p_isa);
        }
      }
    }
  }

void sub_1000DE104(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(id *)(a1 + 40);
  uint64_t v3 = v2;
  if (!v1) {
    goto LABEL_111;
  }
  if (!*(_BYTE *)(v1 + 13) || v2 == 0LL) {
    goto LABEL_111;
  }
  uint64_t v5 = sub_1000229A0(v2, 16LL);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v5, "firstObject"));

  if (v6)
  {
    uint64_t v7 = sub_1000229A0(v3, 16LL);
    id v8 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v7, "firstObject"));

    if (v8 && [v8 length])
    {
      v134[0] = 0;
      [v8 getBytes:v134 length:1];
      if ((v134[0] & 1) != 0) {
        id v9 = &__kCFBooleanTrue;
      }
      else {
        id v9 = &__kCFBooleanFalse;
      }
    }

    else
    {
      id v9 = 0LL;
    }

    if ([v9 BOOLValue])
    {
      int v11 = *(unsigned __int8 *)(v1 + 44);
      *(_BYTE *)(v1 + 60) = v11;
      if (v11)
      {
        id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 96), v10);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 1LL);

        if (IsLevelEnabled)
        {
          id v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 96), v14);
          _NRLogWithArgs( v15,  1LL,  "%s%.30s:%-4d received dns proxy enable request",  "",  "-[NRDDeviceConductor handleDNSProxyMessage:]",  4895);
        }

        uint64_t v16 = *(void *)(v1 + 560);
        if (v16)
        {
          int v17 = *(unsigned __int8 *)(v16 + 8);
          if (v17 == 1)
          {
LABEL_27:

            goto LABEL_28;
          }

          if (v17 == 2)
          {
            objc_msgSend((id)v1, "didUpdateDNSProxyState:state:");
            goto LABEL_27;
          }
        }

        sub_1000DFA94(v1);
        goto LABEL_27;
      }
    }

    else
    {
      *(_BYTE *)(v1 + 60) = 0;
    }

    id v18 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 96), v10);
    int v19 = _NRLogIsLevelEnabled(v18, 1LL);

    if (v19)
    {
      id v21 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 96), v20);
      _NRLogWithArgs( v21,  1LL,  "%s%.30s:%-4d received dns proxy disable request",  "",  "-[NRDDeviceConductor handleDNSProxyMessage:]",  4908);
    }

    [*(id *)(v1 + 560) cancel];
    id v22 = *(void **)(v1 + 560);
    *(void *)(v1 + 560) = 0LL;

    goto LABEL_27;
  }

LABEL_109:
LABEL_110:
  }

LABEL_111:
}

id sub_1000DEBD4(void *a1)
{
  id v1 = a1;
  uint64_t v5 = 0LL;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x3032000000LL;
  id v8 = sub_1000DF67C;
  id v9 = sub_1000DF68C;
  uint64_t v10 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_1000DF694;
  v4[3] = &unk_1001AFDF8;
  v4[4] = &v5;
  NRTLVParse(v1, v4);
  id v2 = (id)v6[5];
  _Block_object_dispose(&v5, 8);

  return v2;
}

void sub_1000DEC9C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1000DECB4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = a3;
  sub_1000D2CC0(v4, v5);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithCEndpoint:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithCEndpoint:",  v5));

  uint64_t v7 = *(void **)(a1 + 40);
  id v8 = (void *)objc_claimAutoreleasedReturnValue([v6 port]);
  id v9 = sub_10012D254(v7, v8);

  [*(id *)(a1 + 48) addObject:v9];
  return 1LL;
}

void sub_1000DED4C(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 632))
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    id v4 = sub_1000D8B90(a1, 4, 0);
    id v5 = v4;
    if (v4 && [v4 state] == 8)
    {
      uint64_t v73 = a1;
      HIDWORD(v71) = a2;
      __int128 v100 = 0u;
      __int128 v101 = 0u;
      __int128 v98 = 0u;
      __int128 v99 = 0u;
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 appSvcPolicyIDs]);
      id v7 = [v6 countByEnumeratingWithState:&v98 objects:v111 count:16];
      if (v7)
      {
        id v8 = v7;
        uint64_t v9 = *(void *)v99;
        do
        {
          for (uint64_t i = 0LL; i != v8; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v99 != v9) {
              objc_enumerationMutation(v6);
            }
            uint64_t v14 = *(void **)(*((void *)&v98 + 1) + 8LL * (void)i);
            id v15 = (void *)objc_claimAutoreleasedReturnValue([v5 policyIDs]);
            unsigned int v16 = [v15 containsObject:v14];

            if (v16)
            {
              objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
              if (qword_1001DCB60 != -1) {
                dispatch_once(&qword_1001DCB60, &stru_1001B0538);
              }
              id v11 = (id)qword_1001DCB58;
              id v12 = (void *)objc_claimAutoreleasedReturnValue([v5 policyIdentifierString]);
              sub_100120F60((uint64_t)v11, v12, v14);

              id v13 = (void *)objc_claimAutoreleasedReturnValue([v5 policyIDs]);
              [v13 removeObject:v14];
            }
          }

          id v8 = [v6 countByEnumeratingWithState:&v98 objects:v111 count:16];
        }

        while (v8);
      }

      int v17 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      [v5 setAppSvcPolicyIDs:v17];

      id v84 = (void *)NEVirtualInterfaceCopyName([v5 virtualInterface]);
      uint64_t v79 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(v73 + 96));
      uint64_t v18 = *(void *)(v73 + 632);
      id v85 = v5;
      if (!v18 || *(_BYTE *)(v18 + 9)) {
        goto LABEL_17;
      }
      objc_opt_self(&OBJC_CLASS___NRApplicationServiceManager);
      if (qword_1001DC930 != -1) {
        dispatch_once(&qword_1001DC930, &stru_1001AF7E0);
      }
      uint64_t v20 = qword_1001DC928;
      if (qword_1001DC928)
      {
        __int128 v104 = 0u;
        __int128 v105 = 0u;
        __int128 v102 = 0u;
        __int128 v103 = 0u;
        id v21 = *(id *)(qword_1001DC928 + 24);
        id v22 = [v21 countByEnumeratingWithState:&v102 objects:v112 count:16];
        if (v22)
        {
          id v23 = v22;
          int v19 = 0LL;
          uint64_t v24 = *(void *)v103;
          do
          {
            for (j = 0LL; j != v23; j = (char *)j + 1)
            {
              if (*(void *)v103 != v24) {
                objc_enumerationMutation(v21);
              }
              id v26 = *(void **)(*((void *)&v102 + 1) + 8LL * (void)j);
              if (!v19) {
                int v19 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
              }
              nw_endpoint_t v27 = sub_1000F6DD0(v20, v26);
              if (v27) {
                -[NSMutableArray addObject:](v19, "addObject:", v27);
              }
            }

            id v23 = [v21 countByEnumeratingWithState:&v102 objects:v112 count:16];
          }

          while (v23);
        }

        else
        {
          int v19 = 0LL;
        }
      }

      else
      {
LABEL_17:
        int v19 = 0LL;
      }

      __int128 v96 = 0u;
      __int128 v97 = 0u;
      __int128 v94 = 0u;
      __int128 v95 = 0u;
      id obj = v19;
      id v80 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v94,  v110,  16LL);
      if (v80)
      {
        uint64_t v77 = *(void *)v95;
        do
        {
          for (uint64_t k = 0LL; k != v80; uint64_t k = (char *)k + 1)
          {
            if (*(void *)v95 != v77) {
              objc_enumerationMutation(obj);
            }
            uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithCEndpoint:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithCEndpoint:",  *(void *)(*((void *)&v94 + 1) + 8LL * (void)k)));
            id v30 = (void *)objc_claimAutoreleasedReturnValue([v29 port]);
            int v31 = sub_10012CD2C(v79, v30);

            uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition localAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "localAddress:prefix:",  v31,  128LL));
            v109[0] = v32;
            uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
            v109[1] = v33;
            uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v109,  2LL));

            int v35 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v84,  0LL));
            id v36 = [[NEPolicy alloc] initWithOrder:1200 result:v35 conditions:v34];
            objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
            uint64_t v82 = v29;
            if (qword_1001DCB60 != -1) {
              dispatch_once(&qword_1001DCB60, &stru_1001B0538);
            }
            id v37 = (id)qword_1001DCB58;
            id v38 = (void *)objc_claimAutoreleasedReturnValue([v85 policyIdentifierString]);
            id v39 = sub_100120E44((uint64_t)v37, v38, v36);
            id v40 = (void *)objc_claimAutoreleasedReturnValue(v39);

            id v41 = (void *)objc_claimAutoreleasedReturnValue([v85 appSvcPolicyIDs]);
            [v41 addObject:v40];
          }

          id v80 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v94,  v110,  16LL);
        }

        while (v80);
      }

      __int128 v92 = 0u;
      __int128 v93 = 0u;
      __int128 v90 = 0u;
      __int128 v91 = 0u;
      uint64_t v42 = v73;
      id v75 = *(id *)(v73 + 648);
      id v43 = [v75 countByEnumeratingWithState:&v90 objects:v108 count:16];
      id v5 = v85;
      if (v43)
      {
        id v44 = v43;
        uint64_t v45 = *(void *)v91;
        uint64_t v72 = *(void *)v91;
        do
        {
          id v46 = 0LL;
          id v74 = v44;
          do
          {
            if (*(void *)v91 != v45) {
              objc_enumerationMutation(v75);
            }
            __int128 v47 = *(void **)(*((void *)&v90 + 1) + 8LL * (void)v46);
            if ((sub_1000F72A0(*(void *)(v42 + 632), v47) & 1) == 0)
            {
              id v78 = v46;
              unint64_t v48 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v42 + 648) objectForKeyedSubscript:v47]);
              __int128 v86 = 0u;
              __int128 v87 = 0u;
              __int128 v88 = 0u;
              __int128 v89 = 0u;
              id v81 = v48;
              id v49 = [v81 countByEnumeratingWithState:&v86 objects:v107 count:16];
              if (v49)
              {
                id v50 = v49;
                uint64_t v83 = *(void *)v87;
                do
                {
                  for (m = 0LL; m != v50; m = (char *)m + 1)
                  {
                    if (*(void *)v87 != v83) {
                      objc_enumerationMutation(v81);
                    }
                    __int128 v52 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:",  *(void *)(*((void *)&v86 + 1) + 8LL * (void)m),  128LL));
                    v106[0] = v52;
                    uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
                    v106[1] = v53;
                    char v54 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v106,  2LL));

                    id v55 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v84,  0LL));
                    id v56 = [[NEPolicy alloc] initWithOrder:1200 result:v55 conditions:v54];
                    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                    if (qword_1001DCB60 != -1) {
                      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                    }
                    id v57 = (id)qword_1001DCB58;
                    id v58 = (void *)objc_claimAutoreleasedReturnValue([v85 policyIdentifierString]);
                    id v59 = sub_100120E44((uint64_t)v57, v58, v56);
                    __int128 v60 = (void *)objc_claimAutoreleasedReturnValue(v59);

                    __int128 v61 = (void *)objc_claimAutoreleasedReturnValue([v85 appSvcPolicyIDs]);
                    [v61 addObject:v60];
                  }

                  id v50 = [v81 countByEnumeratingWithState:&v86 objects:v107 count:16];
                }

                while (v50);
              }

              id v5 = v85;
              uint64_t v45 = v72;
              uint64_t v42 = v73;
              id v44 = v74;
              id v46 = v78;
            }

            id v46 = (char *)v46 + 1;
          }

          while (v46 != v44);
          id v44 = [v75 countByEnumeratingWithState:&v90 objects:v108 count:16];
        }

        while (v44);
      }

      __int128 v62 = (void *)objc_claimAutoreleasedReturnValue([v5 appSvcPolicyIDs]);
      id v63 = [v62 count];

      if (v63)
      {
        __int128 v64 = (void *)objc_claimAutoreleasedReturnValue([v5 policyIDs]);
        id v65 = (void *)objc_claimAutoreleasedReturnValue([v5 appSvcPolicyIDs]);
        [v64 addObjectsFromArray:v65];

        if (HIDWORD(v71))
        {
          objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
          if (qword_1001DCB60 != -1) {
            dispatch_once(&qword_1001DCB60, &stru_1001B0538);
          }
          id v66 = (id)qword_1001DCB58;
          __int128 v67 = (id *)v66;
          if (v66)
          {
            dispatch_assert_queue_V2(*((dispatch_queue_t *)v66 + 1));
            if (([v67[2] apply] & 1) == 0) {
              sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v68,  v69,  v70,  v71);
            }
          }
        }
      }
    }
  }

uint64_t sub_1000DF67C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1000DF68C(uint64_t a1)
{
}

uint64_t sub_1000DF694(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)a2 == 6)
  {
    uint64_t v3 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  a2 + 3,  bswap32(*(unsigned __int16 *)(a2 + 1)) >> 16);
    uint64_t v23 = 0LL;
    uint64_t v24 = &v23;
    uint64_t v25 = 0x3032000000LL;
    id v26 = sub_1000DF67C;
    nw_endpoint_t v27 = sub_1000DF68C;
    id v28 = 0LL;
    uint64_t v17 = 0LL;
    uint64_t v18 = &v17;
    uint64_t v19 = 0x3032000000LL;
    uint64_t v20 = sub_1000DF67C;
    id v21 = sub_1000DF68C;
    id v22 = 0LL;
    uint64_t v11 = 0LL;
    id v12 = &v11;
    uint64_t v13 = 0x3032000000LL;
    uint64_t v14 = sub_1000DF67C;
    id v15 = sub_1000DF68C;
    id v16 = 0LL;
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472LL;
    v10[2] = sub_1000DF914;
    v10[3] = &unk_1001AF600;
    v10[4] = &v23;
    v10[5] = &v17;
    v10[6] = &v11;
    NRTLVParse(v3, v10);
    if (v24[5] && [(id)v12[5] count])
    {
      id v4 = (void *)v18[5];
      if (v4)
      {
        id application_service = [v4 copyCEndpoint];
      }

      else
      {
        v29[0] = 0LL;
        v29[1] = 0LL;
        uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
        [v6 getUUIDBytes:v29];

        id application_service = (id)nw_endpoint_create_application_service([(id)v24[5] UTF8String], v29);
      }

      id v7 = application_service;
      nw_endpoint_set_public_keys(application_service, v12[5]);
      id v8 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) objectForKeyedSubscript:v24[5]]);
      if (!v8) {
        id v8 = (void *)nw_array_create();
      }
      nw_array_append(v8, v7);
      [*(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) setObject:v8 forKeyedSubscript:v24[5]];
    }

    _Block_object_dispose(&v11, 8);

    _Block_object_dispose(&v17, 8);
    _Block_object_dispose(&v23, 8);
  }

  return 1LL;
}

void sub_1000DF8D4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v8 - 120), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000DF914(void *a1, unsigned __int8 *a2)
{
  uint64_t v3 = bswap32(*(unsigned __int16 *)(a2 + 1)) >> 16;
  int v4 = *a2;
  switch(v4)
  {
    case 2:
      id v5 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a2 + 3, v3);
      id v8 = sub_100104514(v5, 1, 0, 0);
      uint64_t v6 = (NSString *)objc_claimAutoreleasedReturnValue(v8);
      uint64_t v7 = a1[5];
      goto LABEL_6;
    case 7:
      id v5 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a2 + 3, v3);
      uint64_t v11 = *(void **)(*(void *)(a1[6] + 8LL) + 40LL);
      if (!v11)
      {
        uint64_t v12 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        uint64_t v13 = *(void *)(a1[6] + 8LL);
        uint64_t v14 = *(void **)(v13 + 40);
        *(void *)(v13 + 40) = v12;

        uint64_t v11 = *(void **)(*(void *)(a1[6] + 8LL) + 40LL);
      }

      [v11 addObject:v5];
      goto LABEL_10;
    case 5:
      id v5 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a2 + 3, v3);
      uint64_t v6 = -[NSString initWithData:encoding:](objc_alloc(&OBJC_CLASS___NSString), "initWithData:encoding:", v5, 4LL);
      uint64_t v7 = a1[4];
LABEL_6:
      uint64_t v9 = *(void *)(v7 + 8);
      uint64_t v10 = *(void **)(v9 + 40);
      *(void *)(v9 + 40) = v6;

LABEL_10:
      break;
  }

  return 1LL;
}

uint64_t sub_1000DFA50(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = (void *)nw_endpoint_copy_public_keys(a3);
  if ([v4 count]) {
    [*(id *)(a1 + 32) addObjectsFromArray:v4];
  }

  return 1LL;
}

void sub_1000DFA94(uint64_t a1)
{
  if (a1 && *(_BYTE *)(a1 + 60))
  {
    id v2 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
    __int128 v23 = 0u;
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    id v3 = *(id *)(a1 + 112);
    id v4 = [v3 countByEnumeratingWithState:&v23 objects:v28 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v24;
      do
      {
        for (uint64_t i = 0LL; i != v5; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v24 != v6) {
            objc_enumerationMutation(v3);
          }
          id v8 = *(void **)(*((void *)&v23 + 1) + 8LL * (void)i);
          if (objc_msgSend(v8, "ikeClassDEstablished", (void)v23))
          {
            uint64_t v9 = +[NSNumber numberWithUnsignedInt:]( NSNumber,  "numberWithUnsignedInt:",  NEVirtualInterfaceGetIndex([v8 virtualInterface]));
            uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
            -[NSMutableSet addObject:](v2, "addObject:", v10);
          }
        }

        id v5 = [v3 countByEnumeratingWithState:&v23 objects:v28 count:16];
      }

      while (v5);
    }

    uint64_t v11 = *(void **)(a1 + 560);
    if (v11) {
      uint64_t v11 = (void *)v11[9];
    }
    uint64_t v12 = v11;
    unsigned __int8 v13 = [v12 isEqualToSet:v2];

    if ((v13 & 1) == 0)
    {
      id v14 = *(id *)(a1 + 560);
      uint64_t v15 = *(void **)(a1 + 560);
      *(void *)(a1 + 560) = 0LL;

      [v14 cancel];
      if (-[NSMutableSet count](v2, "count"))
      {
        uint64_t v16 = objc_alloc(&OBJC_CLASS___NRDNSProxyServer);
        uint64_t v17 = *(void **)(a1 + 104);
        id v18 = *(id *)(a1 + 96);
        id v19 = v17;
        uint64_t v20 = v2;
        if (v16)
        {
          v27.receiver = v16;
          v27.super_class = (Class)&OBJC_CLASS___NRDNSProxyServer;
          id v21 = (NRDNSProxyServer *)objc_msgSendSuper2(&v27, "initWithQueue:nrUUID:delegate:", v19, v18, a1);
          uint64_t v16 = v21;
          if (v21) {
            objc_storeStrong((id *)&v21->_localIfIndices, v2);
          }
        }

        id v22 = *(void **)(a1 + 560);
        *(void *)(a1 + 560) = v16;

        [*(id *)(a1 + 560) start];
      }
    }
  }

void sub_1000DFCE8(uint64_t a1, void *a2, _BYTE *a3, _BYTE *a4, _DWORD *a5, void **a6, void **a7)
{
  id v13 = a2;
  if (v13)
  {
    if (a3)
    {
      if (a4)
      {
        if (a5)
        {
          if (a6)
          {
            if (a7)
            {
              *a3 = 1;
              *a4 = 0;
              *a5 = 0;
              id v14 = *a6;
              *a6 = 0LL;

              uint64_t v15 = *a7;
              *a7 = 0LL;

              v29[0] = _NSConcreteStackBlock;
              v29[1] = 3221225472LL;
              void v29[2] = sub_1000E01B4;
              v29[3] = &unk_1001AF510;
              v29[4] = a1;
              void v29[5] = a3;
              v29[6] = a6;
              v29[7] = a4;
              v29[8] = a5;
              v29[9] = a7;
              uint64_t v16 = objc_retainBlock(v29);
              NRTLVParse(v13, v16);
            }

            else
            {
              id v27 = sub_1000D54AC();
              int IsLevelEnabled = _NRLogIsLevelEnabled(v27, 17LL);

              if (!IsLevelEnabled) {
                goto LABEL_9;
              }
              uint64_t v16 = sub_1000D54AC();
              _NRLogWithArgs(v16, 17LL, "%s called with null serverCertificateDataPtr");
            }
          }

          else
          {
            id v25 = sub_1000D54AC();
            int v26 = _NRLogIsLevelEnabled(v25, 17LL);

            if (!v26) {
              goto LABEL_9;
            }
            uint64_t v16 = sub_1000D54AC();
            _NRLogWithArgs(v16, 17LL, "%s called with null serverEndpointPtr");
          }
        }

        else
        {
          id v23 = sub_1000D54AC();
          int v24 = _NRLogIsLevelEnabled(v23, 17LL);

          if (!v24) {
            goto LABEL_9;
          }
          uint64_t v16 = sub_1000D54AC();
          _NRLogWithArgs(v16, 17LL, "%s called with null resolverProtocolPtr");
        }
      }

      else
      {
        id v21 = sub_1000D54AC();
        int v22 = _NRLogIsLevelEnabled(v21, 17LL);

        if (!v22) {
          goto LABEL_9;
        }
        uint64_t v16 = sub_1000D54AC();
        _NRLogWithArgs(v16, 17LL, "%s called with null shouldStartPtr");
      }
    }

    else
    {
      id v19 = sub_1000D54AC();
      int v20 = _NRLogIsLevelEnabled(v19, 17LL);

      if (!v20) {
        goto LABEL_9;
      }
      uint64_t v16 = sub_1000D54AC();
      _NRLogWithArgs(v16, 17LL, "%s called with null resultPtr");
    }
  }

  else
  {
    id v17 = sub_1000D54AC();
    int v18 = _NRLogIsLevelEnabled(v17, 17LL);

    if (!v18) {
      goto LABEL_9;
    }
    uint64_t v16 = sub_1000D54AC();
    _NRLogWithArgs(v16, 17LL, "%s called with null tlvData");
  }

LABEL_9:
}

void sub_1000DFF48(unsigned int *val)
{
  if (val && *((_BYTE *)val + 59))
  {
    id v2 = (void *)*((void *)val + 69);
    if (v2)
    {
      uint64_t v7 = v2;
      [val didUpdateDNSProxyState:v7 state:v7[8]];
    }

    else
    {
      objc_initWeak(&location, val);
      unsigned int v3 = val[18];
      if (v3 >= 0xC) {
        unsigned int v3 = 12;
      }
      val[18] = v3;
      dispatch_time_t v4 = dispatch_time(0LL, 1000000000LL << (v3 + 1));
      id v5 = (void *)*((void *)val + 13);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_1000E0074;
      block[3] = &unk_1001B0798;
      uint64_t v6 = v5;
      objc_copyWeak(&v9, &location);
      void block[4] = val;
      dispatch_after(v4, v6, block);

      objc_destroyWeak(&v9);
      objc_destroyWeak(&location);
    }
  }

void sub_1000E0074(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained && WeakRetained[13] && WeakRetained[59])
  {
    uint64_t v4 = *(void *)(a1 + 32);
    int v18 = WeakRetained;
    if (v4) {
      uint64_t v5 = *(void *)(v4 + 96);
    }
    else {
      uint64_t v5 = 0LL;
    }
    uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(v5, v3);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 1LL);

    if (IsLevelEnabled)
    {
      uint64_t v9 = *(void *)(a1 + 32);
      if (v9) {
        uint64_t v10 = *(void *)(v9 + 96);
      }
      else {
        uint64_t v10 = 0LL;
      }
      uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(v10, v8);
      _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d requesting to start DNS proxy service",  "",  "-[NRDDeviceConductor startDNSProxyClientIfNeeded]_block_invoke",  4775);
    }

    uint64_t v12 = objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage);
    uint64_t v13 = *(void *)(a1 + 32);
    if (v13) {
      id v14 = *(void **)(v13 + 96);
    }
    else {
      id v14 = 0LL;
    }
    uint64_t v15 = sub_100021D14(v12, v14);
    uint64_t v16 = v15;
    if (v15)
    {
      *((_BYTE *)v15 + 9) = 1;
      char v19 = 1;
      id v17 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v19, 1LL);
      sub_1000222F4((uint64_t)v16, 16, v17);
    }

    sub_100023824((uint64_t)v16);

    id WeakRetained = v18;
  }
}

uint64_t sub_1000E01B4(uint64_t a1, unsigned __int8 *a2)
{
  unsigned int v4 = bswap32(*(unsigned __int16 *)(a2 + 1));
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5) {
    uint64_t v6 = *(void *)(v5 + 96);
  }
  else {
    uint64_t v6 = 0LL;
  }
  uint64_t v7 = HIWORD(v4);
  uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(v6, a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 2LL);

  if (IsLevelEnabled)
  {
    uint64_t v11 = *(void *)(a1 + 32);
    if (v11) {
      uint64_t v12 = *(void *)(v11 + 96);
    }
    else {
      uint64_t v12 = 0LL;
    }
    uint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(v12, v10);
    _NRLogWithArgs( v13,  2LL,  "%s%.30s:%-4d processing tlv %u (len %u)",  "",  "-[NRDDeviceConductor fillInDNSUpdateStateFromTLVData:resultPtr:shouldStartPtr:resolverProtocolPtr:serverEndpointPt r:serverCertificateDataPtr:]_block_invoke",  4840,  *a2,  v7);
  }

  switch(*a2)
  {
    case 1u:
      if (a2[3]) {
        goto LABEL_18;
      }
      uint64_t v14 = 0LL;
      **(_BYTE **)(a1 + 40) = 0;
      break;
    case 2u:
      uint64_t v15 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a2 + 3, v7);
      uint64_t v14 = 1LL;
      id v16 = sub_100104514(v15, 1, 0, 0);
      uint64_t v17 = objc_claimAutoreleasedReturnValue(v16);
      int v18 = *(void ***)(a1 + 48);
      char v19 = *v18;
      *int v18 = (void *)v17;

      if (**(void **)(a1 + 48)) {
        **(_BYTE **)(a1 + 56) = 1;
      }

      break;
    case 3u:
      char v20 = bswap64(*(void *)(a2 + 3));
      if ((v20 & 1) != 0)
      {
        **(_DWORD **)(a1 + 64) = 0;
        goto LABEL_18;
      }

      uint64_t v14 = 1LL;
      if ((v20 & 2) != 0) {
        **(_DWORD **)(a1 + 64) = 1;
      }
      break;
    case 4u:
      id v21 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a2 + 3, v7);
      int v22 = *(void ***)(a1 + 72);
      id v23 = *v22;
      *int v22 = v21;

      goto LABEL_18;
    default:
LABEL_18:
      uint64_t v14 = 1LL;
      break;
  }

  return v14;
}

NSMutableArray *sub_1000E0378(uint64_t a1)
{
  if (!a1 || !*(_BYTE *)(a1 + 45)) {
    return 0LL;
  }
  id v2 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v3 = v2;
  if (*(void *)(a1 + 472)) {
    -[NSMutableArray addObject:](v2, "addObject:");
  }
  if ([*(id *)(a1 + 656) count])
  {
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    unsigned int v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 656) allValues]);
    id v5 = [v4 countByEnumeratingWithState:&v30 objects:v36 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v31;
      do
      {
        for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v31 != v7) {
            objc_enumerationMutation(v4);
          }
          uint64_t v9 = *(void *)(*((void *)&v30 + 1) + 8LL * (void)i);
          v35[0] = 0LL;
          v35[1] = 0LL;
          nw_agent_get_uuid(v9, v35);
          uint64_t v10 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v35);
          -[NSMutableArray addObject:](v3, "addObject:", v10);
        }

        id v6 = [v4 countByEnumeratingWithState:&v30 objects:v36 count:16];
      }

      while (v6);
    }
  }

  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  id v11 = *(id *)(a1 + 112);
  id v12 = [v11 countByEnumeratingWithState:&v26 objects:v34 count:16];
  if (v12)
  {
    id v13 = v12;
    uint64_t v14 = *(void *)v27;
    do
    {
      for (j = 0LL; j != v13; j = (char *)j + 1)
      {
        if (*(void *)v27 != v14) {
          objc_enumerationMutation(v11);
        }
        uint64_t v17 = *(void **)(*((void *)&v26 + 1) + 8LL * (void)j);
        int v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "proxyAgentUUID", (void)v26));

        if (v18)
        {
          char v19 = (void *)objc_claimAutoreleasedReturnValue([v17 proxyAgentUUID]);
          -[NSMutableArray addObject:](v3, "addObject:", v19);
        }

        char v20 = (void *)objc_claimAutoreleasedReturnValue([v17 companionProxyAgent]);

        if (v20)
        {
          id v21 = (void *)objc_claimAutoreleasedReturnValue([v17 companionProxyAgent]);
          int v22 = (void *)objc_claimAutoreleasedReturnValue([v21 agentUUID]);
          -[NSMutableArray addObject:](v3, "addObject:", v22);

          uint64_t v23 = objc_claimAutoreleasedReturnValue([v17 companionProxyAgent]);
          if (v23)
          {
            int v24 = (void *)v23;
            id v16 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v23 + 64) agentUUID]);

            if (v16) {
              -[NSMutableArray addObject:](v3, "addObject:", v16);
            }
          }

          else
          {
            id v16 = 0LL;
          }
        }
      }

      id v13 = [v11 countByEnumeratingWithState:&v26 objects:v34 count:16];
    }

    while (v13);
  }

  return v3;
}

void sub_1000E064C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    if (*(void *)(v1 + 128)) {
      return;
    }
    uint64_t v1 = *(void *)(v1 + 632);
  }

  sub_1000F708C(v1, *(void **)(a1 + 40));
}

void sub_1000E0670(uint64_t a1, uint64_t a2)
{
  int v2 = a2;
  if (sub_1000E0798(a1, a2))
  {
    id v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 1LL);

    if (IsLevelEnabled)
    {
      uint64_t v8 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v7);
      uint64_t v9 = (void *)v8;
      uint64_t v10 = "stop";
      if (v2) {
        uint64_t v10 = "start";
      }
      _NRLogWithArgs( v8,  1LL,  "%s%.30s:%-4d requesting to %s discovery proxy service",  "",  "-[NRDDeviceConductor sendDiscoveryProxyClientMessageWithEnabled:]",  4725,  v10);
    }

    id v12 = sub_100021D14(objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage), *(void **)(a1 + 96));
    if (v12)
    {
      v12[9] = 1;
      char v13 = v2;
      id v11 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v13, 1LL);
      sub_1000222F4((uint64_t)v12, 18, v11);
    }

    sub_100023824((uint64_t)v12);
  }

id sub_1000E0798(uint64_t a1, uint64_t a2)
{
  if (!*(_BYTE *)(a1 + 61))
  {
    uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 2LL);

    if (IsLevelEnabled)
    {
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v11);
      _NRLogWithArgs(v8, 2LL, "%s%.30s:%-4d not eligible to use discovery proxy service");
      goto LABEL_9;
    }

    return 0LL;
  }

  if (!*(_BYTE *)(a1 + 45)) {
    return 0LL;
  }
  id result = [*(id *)(a1 + 128) ikeClassDEstablished];
  if ((_DWORD)result)
  {
    id result = [*(id *)(a1 + 128) type];
    if ((_DWORD)result != 1)
    {
      id v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v4);
      int v6 = _NRLogIsLevelEnabled(v5, 2LL);

      if (v6)
      {
        uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v7);
        _NRLogWithArgs(v8, 2LL, "%s%.30s:%-4d not requesting discovery proxy service for non-BT primary link");
LABEL_9:

        return 0LL;
      }

      return 0LL;
    }
  }

  return result;
}

void sub_1000E08A4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && WeakRetained[13] && WeakRetained[71])
  {
    int v2 = WeakRetained;
    sub_1000E0670((uint64_t)WeakRetained, 1LL);
    id WeakRetained = v2;
  }
}

void sub_1000E08E8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 104));
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v3 = (id)qword_1001DC870;
    uint64_t v4 = v3;
    if (v3) {
      id v5 = (void *)*((void *)v3 + 6);
    }
    else {
      id v5 = 0LL;
    }
    id v6 = v5;

    uint64_t v7 = *(void *)(a1 + 32);
    if (v7) {
      uint64_t v8 = *(void **)(v7 + 232);
    }
    else {
      uint64_t v8 = 0LL;
    }
  }

  else
  {
    id v6 = 0LL;
    uint64_t v8 = 0LL;
  }

  sub_100140F48((uint64_t)v6, 0, v8);

  uint64_t v9 = *(void *)(a1 + 32);
  if (v9)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v9 + 104));
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v10 = (id)qword_1001DC870;
    uint64_t v11 = v10;
    if (v10) {
      id v12 = (void *)*((void *)v10 + 6);
    }
    else {
      id v12 = 0LL;
    }
    char v13 = v12;

    uint64_t v14 = *(void *)(a1 + 32);
    if (v14) {
      uint64_t v15 = *(void **)(v14 + 232);
    }
    else {
      uint64_t v15 = 0LL;
    }
  }

  else
  {
    char v13 = 0LL;
    uint64_t v15 = 0LL;
  }

  sub_100142404(v13, v15);

  uint64_t v16 = *(void *)(a1 + 32);
  if (v16)
  {
    *(_BYTE *)(v16 + 33) = 0;
    uint64_t v17 = *(void *)(a1 + 32);
    if (v17) {
      sub_10011BB18(*(void **)(v17 + 96), 1030, 0LL, 0LL);
    }
  }

void sub_1000E0A7C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    memset(v53, 0, 9);
    if ((unint64_t)[v3 length] > 8)
    {
      [v4 getBytes:v53 length:9];
      int v15 = *(_DWORD *)((char *)v53 + 5);
      if (LOBYTE(v53[0]))
      {
        if (*(_BYTE *)(a1 + 10) || *(_BYTE *)(a1 + 49))
        {
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
          objc_opt_self(&OBJC_CLASS___NRLinkDirector);
          if (qword_1001DC878 != -1) {
            dispatch_once(&qword_1001DC878, &stru_1001AEED0);
          }
          id v16 = (id)qword_1001DC870;
          uint64_t v17 = v16;
          if (v16) {
            int v18 = (void *)*((void *)v16 + 6);
          }
          else {
            int v18 = 0LL;
          }
          char v19 = v18;

          BOOL v20 = v19 != 0LL;
          if (v19)
          {
            id v21 = (dispatch_queue_s *)v19[3];
            dispatch_assert_queue_V2(v21);
          }
        }

        else
        {
          BOOL v20 = 0;
        }

        dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
        id v22 = sub_1000D8B90(a1, 2, 101);
        uint64_t v23 = v22;
        if (!*(_BYTE *)(a1 + 43)) {
          [v22 startRequested];
        }
        int v24 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        if ((unint64_t)[v4 length] >= 0xA)
        {
          id v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "subdataWithRange:", 9, objc_msgSend(v4, "length") - 9));
          v50[0] = _NSConcreteStackBlock;
          v50[1] = 3221225472LL;
          v50[2] = sub_1000E0FCC;
          v50[3] = &unk_1001AF560;
          v50[4] = a1;
          BOOL v52 = v20;
          char v51 = v24;
          NRTLVParse(v25, v50);
        }

        if (-[NSMutableArray count](v24, "count"))
        {
          id v43 = v24;
          id v44 = v23;
          int v45 = v15;
          objc_storeStrong((id *)(a1 + 432), v24);
          __int128 v26 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
          __int128 v46 = 0u;
          __int128 v47 = 0u;
          __int128 v48 = 0u;
          __int128 v49 = 0u;
          id v27 = *(id *)(a1 + 432);
          id v28 = [v27 countByEnumeratingWithState:&v46 objects:v54 count:16];
          if (v28)
          {
            id v29 = v28;
            uint64_t v30 = *(void *)v47;
            do
            {
              for (uint64_t i = 0LL; i != v29; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v47 != v30) {
                  objc_enumerationMutation(v27);
                }
                __int128 v32 = *(void **)(*((void *)&v46 + 1) + 8LL * (void)i);
                id v33 = -[NSMutableString length](v26, "length");
                uint64_t ShortStringFromNRLinkSubtype = createShortStringFromNRLinkSubtype([v32 unsignedCharValue]);
                int v35 = (void *)ShortStringFromNRLinkSubtype;
                if (v33) {
                  -[NSMutableString appendFormat:](v26, "appendFormat:", @"/%@", ShortStringFromNRLinkSubtype);
                }
                else {
                  -[NSMutableString appendString:](v26, "appendString:", ShortStringFromNRLinkSubtype);
                }
              }

              id v29 = [v27 countByEnumeratingWithState:&v46 objects:v54 count:16];
            }

            while (v29);
          }

          id v41 = "ack";
          if ((v45 & 0x1000000) == 0) {
            id v41 = "req";
          }
          sub_1000D4F78(a1, 1050, @"recv %s %d %@", v36, v37, v38, v39, v40, (uint64_t)v41);
          if (sub_1000E0EC4(a1)) {
            sub_1000D7B08(a1, 1);
          }
          else {
            *(_BYTE *)(a1 + 25) = 1;
          }
          int v24 = v43;
          uint64_t v23 = v44;
        }
      }

      else
      {
        uint64_t v42 = "ack ";
        if ((*(_DWORD *)((_BYTE *)v53 + 5) & 0x1000000) == 0) {
          uint64_t v42 = "req";
        }
        sub_1000D4F78(a1, 1050, @"recv %s %d", v10, v11, v12, v13, v14, (uint64_t)v42);
        *(_BYTE *)(a1 + 52) = 0;
        sub_1000D7B08(a1, 0);
      }
    }

    else
    {
      id v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v5);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 16LL);

      if (IsLevelEnabled)
      {
        uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v8);
        _NRLogWithArgs( v9,  16,  "%s%.30s:%-4d invalid request size %lu",  "",  "-[NRDDeviceConductor processLinkUpgradeRequest:]",  6540,  [v4 length]);
      }
    }
  }
}

BOOL sub_1000E0EC4(uint64_t a1)
{
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v2 = (id)qword_1001DC870;
  id v3 = v2;
  if (v2) {
    uint64_t v4 = (void *)*((void *)v2 + 6);
  }
  else {
    uint64_t v4 = 0LL;
  }
  id v5 = v4;

  BOOL v6 = sub_10014281C((uint64_t)v5);
  if (!v6)
  {
    uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v7);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v10);
      _NRLogWithArgs( v11,  0LL,  "%s%.30s:%-4d Deferring prefer Wi-Fi request as Wi-Fi is powered off",  "",  "-[NRDDeviceConductor canProcessPreferWiFiRequest]",  6661);
    }
  }

  return v6;
}

uint64_t sub_1000E0FCC(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)a2 != 1) {
    return 1LL;
  }
  if (*(_WORD *)(a2 + 1) != 256)
  {
    uint64_t v18 = *(void *)(a1 + 32);
    if (v18) {
      uint64_t v19 = *(void *)(v18 + 96);
    }
    else {
      uint64_t v19 = 0LL;
    }
    BOOL v20 = (void *)_NRCopyLogObjectForNRUUID(v19, a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v20, 16LL);

    if (IsLevelEnabled)
    {
      uint64_t v23 = *(void *)(a1 + 32);
      if (v23) {
        uint64_t v24 = *(void *)(v23 + 96);
      }
      else {
        uint64_t v24 = 0LL;
      }
      uint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(v24, v22);
      _NRLogWithArgs(v13, 16LL, "%s%.30s:%-4d invalid size %u");
      goto LABEL_39;
    }

    return 1LL;
  }

  unsigned int v3 = *(unsigned __int8 *)(a2 + 3);
  unint64_t v4 = 0x6867660000650000uLL >> (8 * v3);
  if (v3 >= 8) {
    LOBYTE(v4) = 0;
  }
  if (v4 > 0x65u)
  {
    if (v4 == 102)
    {
      uint64_t v29 = *(void *)(a1 + 32);
      if (!v29 || !*(_BYTE *)(v29 + 10) || !*(_BYTE *)(a1 + 48)) {
        return 1LL;
      }
      __int128 v26 = *(void **)(a1 + 40);
      uint64_t v27 = 102LL;
    }

    else
    {
      uint64_t v25 = *(void *)(a1 + 32);
      if (!v25 || !*(_BYTE *)(v25 + 49) || !*(_BYTE *)(a1 + 48)) {
        return 1LL;
      }
      __int128 v26 = *(void **)(a1 + 40);
      uint64_t v27 = 103LL;
    }

void sub_1000E12E4(uint64_t a1)
{
  if (a1)
  {
    __int128 v10 = 0u;
    __int128 v11 = 0u;
    __int128 v8 = 0u;
    __int128 v9 = 0u;
    id v2 = *(id *)(a1 + 152);
    id v3 = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
    if (v3)
    {
      id v4 = v3;
      uint64_t v5 = *(void *)v9;
      do
      {
        id v6 = 0LL;
        do
        {
          if (*(void *)v9 != v5) {
            objc_enumerationMutation(v2);
          }
          xpc_connection_cancel(*(xpc_connection_t *)(*((void *)&v8 + 1) + 8LL * (void)v6));
          id v6 = (char *)v6 + 1;
        }

        while (v4 != v6);
        id v4 = [v2 countByEnumeratingWithState:&v8 objects:v12 count:16];
      }

      while (v4);
    }

    objc_msgSend(*(id *)(a1 + 152), "removeAllObjects", (void)v8);
    uint64_t v7 = *(void **)(a1 + 160);
    *(void *)(a1 + 160) = 0LL;
  }

void sub_1000E13F4(uint64_t a1, uint64_t a2)
{
  id v3 = *(dispatch_queue_t **)(a1 + 32);
  if (!v3) {
    goto LABEL_16;
  }
  dispatch_assert_queue_V2(v3[13]);
  id v4 = (dispatch_queue_t *)sub_1000D8B90((uint64_t)v3, 1, 0);
  id v3 = v4;
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5) {
    uint64_t v6 = *(void *)(v5 + 96);
  }
  else {
LABEL_16:
  }
    uint64_t v6 = 0LL;
  uint64_t v7 = (void *)_NRCopyLogObjectForNRUUID(v6, a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0LL);

  if (IsLevelEnabled)
  {
    uint64_t v10 = *(void *)(a1 + 32);
    if (v10) {
      uint64_t v11 = *(void *)(v10 + 96);
    }
    else {
      uint64_t v11 = 0LL;
    }
    id v12 = (void *)_NRCopyLogObjectForNRUUID(v11, v9);
    _NRLogWithArgs( v12,  0LL,  "%s%.30s:%-4d BT unavailable and ClassC is unlocked, starting Wi-Fi immediately",  "",  "-[NRDDeviceConductor linkIsUnavailable:]_block_invoke",  5836);
  }

  uint64_t v13 = *(void *)(a1 + 32);
  if (v13)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v13 + 104));
    sub_1000DA20C(v13, 1, 0xAu);
  }

  uint64_t v14 = objc_alloc_init(&OBJC_CLASS___NRLinkDirectorRequest);
  uint64_t v15 = v14;
  if (v14)
  {
    v14->_type = 6;
    v14->_allowsSuspendedLinuint64_t k = 0;
    objc_storeStrong((id *)&v14->_timerDescription, @"QR-activation-hysteresis");
    objc_storeStrong((id *)&v15->_cancelIfLinkTypeReady, &off_1001BCA58);
    v15->_attemptImmediately = 1;
    v15->_timeout = 10LL;
    newValue = _NSConcreteStackBlock;
    uint64_t v19 = 3221225472LL;
    BOOL v20 = sub_1000E3858;
    id v21 = &unk_1001B0A88;
    uint64_t v22 = *(void *)(a1 + 32);
    objc_setProperty_nonatomic_copy(v15, v16, &newValue, 48LL);
    uint64_t v17 = *(void *)(a1 + 32);
  }

  else
  {
    newValue = _NSConcreteStackBlock;
    uint64_t v19 = 3221225472LL;
    BOOL v20 = sub_1000E3858;
    id v21 = &unk_1001B0A88;
    uint64_t v17 = *(void *)(a1 + 32);
    uint64_t v22 = v17;
  }

  sub_1000D312C(v17, v15);

LABEL_15:
}

void sub_1000E15D4(uint64_t a1)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    sub_1000DA20C(a1, 1, 0xAu);
  }

void sub_1000E160C(uint64_t a1)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    if (![*(id *)(a1 + 112) count])
    {
      sub_1000E1E9C(a1, 0LL);
      return;
    }

    if (!*(_BYTE *)(a1 + 56))
    {
      int v2 = *(unsigned __int8 *)(a1 + 38);
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
      if (v2 == 2) {
        int v3 = 101;
      }
      else {
        int v3 = 0;
      }
      id v4 = sub_1000D8B90(a1, v2, v3);
      uint64_t v5 = v4;
    }

    __int128 v22 = 0u;
    __int128 v23 = 0u;
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    id v6 = *(id *)(a1 + 112);
    id v7 = [v6 countByEnumeratingWithState:&v20 objects:v24 count:16];
    if (v7)
    {
      id v8 = v7;
      uint64_t v5 = 0LL;
      uint64_t v9 = *(void *)v21;
      unsigned __int16 v10 = -1;
      do
      {
        for (uint64_t i = 0LL; i != v8; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v21 != v9) {
            objc_enumerationMutation(v6);
          }
          id v12 = *(void **)(*((void *)&v20 + 1) + 8LL * (void)i);
          if ([v12 state] == 8 && objc_msgSend(v12, "metric") < v10)
          {
            id v13 = v12;

            unsigned __int16 v10 = (unsigned __int16)[v13 metric];
            uint64_t v5 = v13;
          }
        }

        id v8 = [v6 countByEnumeratingWithState:&v20 objects:v24 count:16];
      }

      while (v8);

      uint64_t v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v14);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v15, 17LL);

      if (IsLevelEnabled)
      {
        id v17 = *(id *)(a1 + 96);
        uint64_t v19 = (void *)_NRCopyLogObjectForNRUUID(v17, v18);
        _NRLogWithArgs(v19, 17LL, "Attempting to set a non-ready link %@ as primary link", v5);
      }
    }

    else
    {
      uint64_t v5 = v6;
    }

    uint64_t v5 = 0LL;
LABEL_27:
    sub_1000E1E9C(a1, v5);
  }

void sub_1000E1878(uint64_t a1, void *a2)
{
  id v31 = a2;
  if (a1 && [*(id *)(a1 + 128) state] == 8)
  {
    id v4 = sub_100021C64(objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage), *(void **)(a1 + 96));
    uint64_t v5 = v4;
    if (v4)
    {
      objc_storeStrong((id *)v4 + 3, a2);
      if (!*(_BYTE *)(a1 + 56)) {
        v5[8] = 1;
      }
      id v6 = *(id *)(a1 + 112);
      __int128 v37 = 0u;
      __int128 v38 = 0u;
      __int128 v39 = 0u;
      __int128 v40 = 0u;
      id v7 = v6;
      id v8 = [v7 countByEnumeratingWithState:&v37 objects:v42 count:16];
      if (v8)
      {
        id v9 = v8;
        uint64_t v10 = *(void *)v38;
LABEL_9:
        uint64_t v11 = 0LL;
        while (1)
        {
          if (*(void *)v38 != v10) {
            objc_enumerationMutation(v7);
          }
          id v12 = *(void **)(*((void *)&v37 + 1) + 8 * v11);
          if ([v12 state] != 255)
          {
          }

          if (v9 == (id)++v11)
          {
            id v9 = [v7 countByEnumeratingWithState:&v37 objects:v42 count:16];
            if (!v9) {
              goto LABEL_21;
            }
            goto LABEL_9;
          }
        }

        unsigned int v13 = [v12 type];
        unsigned int v14 = ([v12 subtype] - 101);
        unint64_t v15 = 0x40300020100uLL >> (8 * v13);
        if (v13 >= 6) {
          LOBYTE(v15) = 0;
        }
        if (v14 >= 4) {
          char v16 = v15;
        }
        else {
          char v16 = 0x7060502u >> (8 * v14);
        }
        char v36 = v16;
        id v17 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v36, 1LL);
        sub_1000222F4((uint64_t)v5, 6, v17);
      }

void sub_1000E1BF4(uint64_t a1)
{
  if (a1 && sub_1000D5FC0(a1))
  {
    if (qword_1001DC9B8 != -1) {
      dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
    }
    if (byte_1001DC9B0)
    {
      sub_1000D55D0(a1, 5u, 0);
    }

    else
    {
      int v2 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 96));
      int v3 = v2;
      __int128 v23 = 0u;
      __int128 v24 = 0u;
      __int128 v25 = 0u;
      __int128 v26 = 0u;
      if (v2) {
        id v4 = (void *)*((void *)v2 + 16);
      }
      else {
        id v4 = 0LL;
      }
      id v5 = v4;
      id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 allowedLinkSubtypes]);

      id v7 = [v6 countByEnumeratingWithState:&v23 objects:v28 count:16];
      if (v7)
      {
        id v8 = v7;
        uint64_t v9 = *(void *)v24;
        do
        {
          for (uint64_t i = 0LL; i != v8; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v24 != v9) {
              objc_enumerationMutation(v6);
            }
            sub_1000D55D0( a1,  0,  (char)[*(id *)(*((void *)&v23 + 1) + 8 * (void)i) unsignedShortValue]);
          }

          id v8 = [v6 countByEnumeratingWithState:&v23 objects:v28 count:16];
        }

        while (v8);
      }

      __int128 v21 = 0u;
      __int128 v22 = 0u;
      __int128 v19 = 0u;
      __int128 v20 = 0u;
      if (v3) {
        uint64_t v11 = (void *)*((void *)v3 + 16);
      }
      else {
        uint64_t v11 = 0LL;
      }
      id v12 = v11;
      unsigned int v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "allowedLinkTypes", (void)v19));

      id v14 = [v13 countByEnumeratingWithState:&v19 objects:v27 count:16];
      if (v14)
      {
        id v15 = v14;
        uint64_t v16 = *(void *)v20;
        do
        {
          for (j = 0LL; j != v15; j = (char *)j + 1)
          {
            if (*(void *)v20 != v16) {
              objc_enumerationMutation(v13);
            }
            uint64_t v18 = *(void **)(*((void *)&v19 + 1) + 8LL * (void)j);
          }

          id v15 = [v13 countByEnumeratingWithState:&v19 objects:v27 count:16];
        }

        while (v15);
      }
    }
  }

void sub_1000E1E9C(uint64_t a1, void *a2)
{
  id v170 = a2;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
  uint64_t v9 = (id *)(a1 + 128);
  if (*(id *)(a1 + 128) != v170)
  {
    sub_1000D4F78(a1, 1012, @"%@ -> (%@)", v4, v5, v6, v7, v8, *(void *)(a1 + 128));
    id v10 = *(id *)(a1 + 128);
    *(_BYTE *)(a1 + 40) = [v10 type];
    id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v11);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 1LL);

    if (IsLevelEnabled)
    {
      id v14 = *(id *)(a1 + 96);
      uint64_t v16 = (void *)_NRCopyLogObjectForNRUUID(v14, v15);
      int v155 = "";
      _NRLogWithArgs(v16, 1LL, "%s%.30s:%-4d Changing primary link %@ ----> %@");
    }

    objc_storeStrong((id *)(a1 + 128), a2);
    sub_1000E2FD0(a1);
    id v17 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 96));
    uint64_t v18 = v17;
    if (*(_BYTE *)(a1 + 47)) {
      goto LABEL_47;
    }
    __int128 v19 = v17 ? (void *)*((void *)v17 + 16) : 0LL;
    id v20 = v19;
    unsigned int v21 = [v20 hasPoliciesForProxyCriteria];

    if (!v21) {
      goto LABEL_47;
    }
    __int128 v22 = v18 ? (void *)*((void *)v18 + 16) : 0LL;
    id v23 = v22;
    id v24 = [v23 proxyCapability];

    if (v24 != (id)2) {
      goto LABEL_47;
    }
    if (v18) {
      __int128 v25 = (void *)*((void *)v18 + 16);
    }
    else {
      __int128 v25 = 0LL;
    }
    id v26 = v25;
    char v27 = (void *)objc_claimAutoreleasedReturnValue([v26 proxyProviderCriteria]);
    if ([v27 excludeLegacyClients])
    {

      goto LABEL_47;
    }

    unint64_t v28 = v18 ? (void *)*((void *)v18 + 16) : 0LL;
    id v29 = v28;
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v29 proxyProviderCriteria]);
    unsigned __int8 v31 = [v30 excludeNonMatchingLegacyClients];

    if ((v31 & 1) != 0)
    {
LABEL_47:

      __int128 v105 = *(id *)(a1 + 368);
      if (v105) {
        ++v105[6];
      }

      if (*v9)
      {
        if (!*(void *)(a1 + 408))
        {
          sub_1000E3500(a1);
          if (!*(_BYTE *)(a1 + 44)) {
            goto LABEL_63;
          }
          goto LABEL_54;
        }
      }

      if (!*(_BYTE *)(a1 + 44)) {
        goto LABEL_63;
      }
LABEL_54:
      if (*v9)
      {
        if (*(_BYTE *)(a1 + 41) && sub_100103800())
        {
          *(_BYTE *)(a1 + 41) = 0;
          uint64_t v106 = *(void **)(a1 + 96);
          int v107 = 1036;
LABEL_62:
          sub_10011BB18(v106, v107, 0LL, 0LL);
        }
      }

      else
      {
        LODWORD(v178[0]) = 0x10000;
        if ((sysctlbyname("net.link.generic.system.companion_sndbuf_limit", 0LL, 0LL, v178, 4uLL) & 0x80000000) == 0)
        {
          *(_BYTE *)(a1 + 41) = 1;
          uint64_t v106 = *(void **)(a1 + 96);
          int v107 = 1035;
          goto LABEL_62;
        }

        int v154 = *__error();
        if (strerror_r(v154, __strerrbuf, 0x80uLL)) {
          __strerrbuf[0] = 0;
        }
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCA50, 16LL))
        {
          if (qword_1001DCA58 != -1) {
            dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
          }
          _NRLogWithArgs( qword_1001DCA50,  16LL,  "%s%.30s:%-4d sysctl net.link.generic.system.companion_sndbuf_limit -> %d failed: [%d] %s",  "",  "NRLimitCompanionLinkFlows",  901,  LODWORD(v178[0]),  v154,  __strerrbuf);
        }
      }

LABEL_96:
}

void sub_1000E2FD0(uint64_t a1)
{
  int v2 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 96));
  uint64_t v4 = *(void **)(a1 + 128);
  if (!v4) {
    goto LABEL_32;
  }
  if ([v4 type] == 1)
  {
    uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v3);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

    if (!IsLevelEnabled) {
      goto LABEL_16;
    }
    id v7 = *(id *)(a1 + 96);
    uint64_t v9 = _NRCopyLogObjectForNRUUID(v7, v8);
    id v10 = (void *)v9;
    uint64_t v11 = *(void *)(a1 + 128);
    uint64_t v12 = 1449LL;
    goto LABEL_15;
  }

  unsigned int v13 = *(void **)(a1 + 128);
  if (!v13) {
    goto LABEL_32;
  }
  if ([v13 type] == 2)
  {
    id v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v3);
    int v15 = _NRLogIsLevelEnabled(v14, 0LL);

    if (!v15) {
      goto LABEL_16;
    }
    id v7 = *(id *)(a1 + 96);
    uint64_t v9 = _NRCopyLogObjectForNRUUID(v7, v16);
    id v10 = (void *)v9;
    uint64_t v11 = *(void *)(a1 + 128);
    uint64_t v12 = 1455LL;
    goto LABEL_15;
  }

  id v17 = *(void **)(a1 + 128);
  if (!v17) {
    goto LABEL_32;
  }
  if ([v17 type] != 5)
  {
    if (*(void *)(a1 + 128))
    {
      int64_t v42 = 15000000000LL;
LABEL_38:
      objc_initWeak(location, (id)a1);
      id v48 = *(void **)(a1 + 392);
      dispatch_time_t v49 = dispatch_time(0x8000000000000000LL, v42);
      uint64_t v50 = *(void **)(a1 + 104);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_1000E35C4;
      block[3] = &unk_1001B0770;
      id v51 = v50;
      objc_copyWeak(v54, location);
      v54[1] = v48;
      dispatch_after(v49, v51, block);

      objc_destroyWeak(v54);
      objc_destroyWeak(location);
      goto LABEL_39;
    }

void sub_1000E3500(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 448);
    if (v2)
    {
      id v8 = (id)NEVirtualInterfaceCopyName(v2);
      uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v3);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 1LL);

      if (IsLevelEnabled)
      {
        id v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v6);
        _NRLogWithArgs( v7,  1LL,  "%s%.30s:%-4d Setting interface availability for catch-all interface %@",  "",  "-[NRDDeviceConductor setInterfaceAvailabilityForCatchAllInterface]",  7777LL,  v8);
      }

      sub_100103A54(v8);
    }
  }

void sub_1000E35C4(uint64_t a1)
{
  id WeakRetained = (uint64_t *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && *((_BYTE *)WeakRetained + 13))
  {
    id v14 = WeakRetained;
    if (*(void *)(a1 + 40) == WeakRetained[49])
    {
      if (*((_BYTE *)WeakRetained + 55))
      {
        sub_1000DD678((uint64_t)WeakRetained, 1);
        sub_1000DD8EC((uint64_t)v14);
        id WeakRetained = v14;
      }

      uint64_t v4 = WeakRetained[48];
      if (v4)
      {
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v4 + 40));
        if ([(id)v4 isActive])
        {
          [(id)v4 setActive:0];
          [*(id *)(v4 + 48) updateNetworkAgent:v4];
          uint64_t v5 = *(void **)(v4 + 32);
          id v6 = *(id *)(v4 + 64);
          id v7 = v5;
          id v8 = (void *)objc_claimAutoreleasedReturnValue([(id)v4 agentUUID]);
          uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 UUIDString]);
          sub_10011BB18(v7, 19004, v6, v9);
        }
      }

      sub_1000E3750((uint64_t)v14);
      goto LABEL_12;
    }

    id v10 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[12], v3);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 2LL);

    id WeakRetained = v14;
    if (IsLevelEnabled)
    {
      unsigned int v13 = (void *)_NRCopyLogObjectForNRUUID(v14[12], v12);
      _NRLogWithArgs( v13,  2LL,  "%s%.30s:%-4d Skipping viability update (%llu != %llu)",  "",  "-[NRDDeviceConductor updateCompanionLinkViability]_block_invoke",  1494,  *(void *)(a1 + 40),  v14[49]);

LABEL_12:
      id WeakRetained = v14;
    }
  }
}

void sub_1000E3750(uint64_t a1)
{
  if (*(void *)(a1 + 448) && *(_BYTE *)(a1 + 58))
  {
    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v2 = (id)qword_1001DCB58;
    sub_10012114C((uint64_t)v2, *(void **)(a1 + 536));

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v3 = (id)qword_1001DCB58;
    uint64_t v4 = (id *)v3;
    if (v3)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v3 + 1));
      if (([v4[2] apply] & 1) == 0) {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v5,  v6,  v7,  v8);
      }
    }

    *(_BYTE *)(a1 + 5_Block_object_dispose(va, 8) = 0;
  }

void sub_1000E3858(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    if (!*(_BYTE *)(v1 + 27)) {
      sub_1000300A8(*(void *)(v1 + 192));
    }
  }

  else
  {
    sub_1000300A8(0LL);
  }

void sub_1000E387C(void **a1)
{
  if (a1)
  {
    uint64_t v5 = a1;
    uint64_t v6 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, a1[12]);
    if (!v6)
    {
      id v78 = sub_1000D54AC();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v78, 16LL);

      if (IsLevelEnabled)
      {
        id v80 = sub_1000D54AC();
        _NRLogWithArgs( v80,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: localDevice",  "",  "-[NRDDeviceConductor setupCatchAllInterfaceIfApplicable]",  7845);
      }

      uint64_t v7 = _os_log_pack_size(12LL);
      uint64_t v5 = (void **)((char *)&v98 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL));
      uint64_t v81 = *__error();
      uint64_t v82 = _os_log_pack_fill(v5, v7, v81, &_mh_execute_header, "%{public}s Assertion Failed: localDevice");
      goto LABEL_62;
    }

    uint64_t v7 = (uint64_t)v6;
    id v8 = *((id *)v6 + 16);
    unsigned int v9 = [v8 hasCompanionDatapath];

    if (!v9)
    {
LABEL_57:

      return;
    }

    if (!v5[56])
    {
      uint64_t v10 = sub_10010B160(v5[13]);
      v5[56] = (void *)v10;
      if (v10)
      {
        objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
        uint64_t v11 = sub_100146AFC();
        dispatch_assert_queue_V2((dispatch_queue_t)v11);

        __int128 v100 = xmmword_100156950;
        uint64_t v12 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v100, 16LL);
        id v13 = sub_10012D958((uint64_t)&OBJC_CLASS___NRDLocalDevice, v12, @"0");
        id v14 = (void *)objc_claimAutoreleasedReturnValue(v13);

        int v15 = v5[56];
        uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v14 hostname]);
        NEVirtualInterfaceAddIPv6Route(v15, v16, &off_1001BC7A8, 0LL, 0LL);

        NEVirtualInterfaceSetIPv6Router(v5[56], @"fe80::");
        NEVirtualInterfaceSetRankNever(v5[56], 1LL);
        id v17 = (void *)NEVirtualInterfaceCopyName(v5[56]);
        if ((sub_100101EE8(v17, 8) & 1) != 0)
        {
          char v19 = sub_100102728(v17);
          uint64_t v21 = _NRCopyLogObjectForNRUUID(v5[12], v20);
          __int128 v22 = (void *)v21;
          if ((v19 & 1) != 0)
          {
            int v23 = _NRLogIsLevelEnabled(v21, 0LL);

            if (v23)
            {
              __int128 v25 = (void *)_NRCopyLogObjectForNRUUID(v5[12], v24);
              _NRLogWithArgs( v25,  0LL,  "%s%.30s:%-4d Created catch-all interface (%@)",  "",  "-[NRDDeviceConductor createCatchAllInterface]",  7839LL,  v17);
            }

            goto LABEL_22;
          }

          int v30 = _NRLogIsLevelEnabled(v21, 17LL);

          if (v30)
          {
            id v29 = (void *)_NRCopyLogObjectForNRUUID(v5[12], v31);
            _NRLogWithArgs(v29, 17LL, "Failed to set no ack prioritization for catch-all %@", v17);
            goto LABEL_20;
          }
        }

        else
        {
          id v26 = (void *)_NRCopyLogObjectForNRUUID(v5[12], v18);
          int v27 = _NRLogIsLevelEnabled(v26, 17LL);

          if (v27)
          {
            id v29 = (void *)_NRCopyLogObjectForNRUUID(v5[12], v28);
            _NRLogWithArgs(v29, 17LL, "Failed to set interface subfamily for catch-all %@", v17);
LABEL_20:
          }
        }

        sub_1000EC130((uint64_t)v5);
LABEL_22:

        goto LABEL_23;
      }

      if (qword_1001DC8F0 != -1) {
        dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC8E8, 17LL))
      {
        if (qword_1001DC8F0 != -1) {
          dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
        }
        _NRLogWithArgs(qword_1001DC8E8, 17LL, "NRLinkVirtualInterfaceCreate failed");
      }
    }

LABEL_69:
          uint64_t v7 = _os_log_pack_size(12LL);
          uint64_t v5 = (void **)((char *)&v98 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL));
          uint64_t v91 = *__error();
          uint64_t v82 = _os_log_pack_fill( v5,  v7,  v91,  &_mh_execute_header,  "%{public}s Assertion Failed: (policyPrefix) != ((void *)0)");
          goto LABEL_62;
        }

        objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
        uint64_t v4 = v99;
        if (qword_1001DCB60 != -1) {
          dispatch_once(&qword_1001DCB60, &stru_1001B0538);
        }
        id v3 = v44;
        id v47 = (id)qword_1001DCB58;
        id v48 = sub_100120E44((uint64_t)v47, v5[34], v46);

        char v35 = 1;
      }
    }

    if (!*(_BYTE *)(v7 + 13)) {
      goto LABEL_42;
    }
    if (!v4) {
      goto LABEL_42;
    }
    if (v1)
    {
      dispatch_time_t v49 = (void *)objc_claimAutoreleasedReturnValue([v4 hostname]);
      unsigned __int8 v50 = [v1 containsObject:v49];

      if ((v50 & 1) != 0) {
        goto LABEL_42;
      }
    }

    uint64_t v98 = v1;
    __int128 v99 = v4;
    id v51 = v5[56];
    uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "hostname", v1));
    NEVirtualInterfaceAddAddress(v51, v52, @"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff");

    id v53 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v53);

    id v54 = sub_10012D610((void *)v7, @"0");
    id v55 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:",  v54,  128LL));

    if (v55)
    {
      id v56 = objc_alloc(&OBJC_CLASS___NEPolicy);
      uint64_t v1 = v3;
      id v3 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v3,  0LL));
      v101[0] = v55;
      uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      v101[1] = v4;
      id v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v101, 2LL));
      id v58 = [v56 initWithOrder:4000 result:v3 conditions:v57];

      if (v58)
      {
        objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
        if (qword_1001DCB60 != -1) {
          dispatch_once(&qword_1001DCB60, &stru_1001B0538);
        }
        id v3 = v1;
        uint64_t v4 = v99;
        id v59 = (id)qword_1001DCB58;
        id v60 = sub_100120E44((uint64_t)v59, v5[34], v58);

        char v35 = 1;
        uint64_t v1 = v98;
LABEL_42:
        if (*(unsigned __int16 *)(v7 + 28) >= 0xCu && !*((_BYTE *)v5 + 57))
        {
          NEVirtualInterfaceSetMTU(v5[56], 1400LL);
          *((_BYTE *)v5 + 57) = 1;
          __int128 v62 = (void *)_NRCopyLogObjectForNRUUID(v5[12], v61);
          int v63 = _NRLogIsLevelEnabled(v62, 0LL);

          if (v63)
          {
            uint64_t v64 = (void *)_NRCopyLogObjectForNRUUID(v5[12], v34);
            _NRLogWithArgs( v64,  0LL,  "%s%.30s:%-4d Updated interface mtu for catch-all interface (%@)",  "",  "-[NRDDeviceConductor setupCatchAllInterfaceIfApplicable]",  7904LL,  v3);
          }
        }

        if ((v35 & 1) == 0)
        {
          id v75 = (void *)_NRCopyLogObjectForNRUUID(v5[12], v34);
          int v76 = _NRLogIsLevelEnabled(v75, 0LL);

          if (!v76)
          {
LABEL_56:

            goto LABEL_57;
          }

          id v74 = (void *)_NRCopyLogObjectForNRUUID(v5[12], v77);
          _NRLogWithArgs(v74, 0LL, "%s%.30s:%-4d Not updating catch-all interface as there are no new addresses");
LABEL_55:

          goto LABEL_56;
        }

        NEVirtualInterfaceUpdateAdHocService(v5[56]);
        objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
        if (qword_1001DCB60 == -1)
        {
LABEL_48:
          id v65 = (id)qword_1001DCB58;
          id v66 = (id *)v65;
          if (v65)
          {
            dispatch_assert_queue_V2(*((dispatch_queue_t *)v65 + 1));
            if (([v66[2] apply] & 1) == 0) {
              sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v67,  v68,  v69,  (uint64_t)v98);
            }
          }

          uint64_t v71 = (void *)_NRCopyLogObjectForNRUUID(v5[12], v70);
          int v72 = _NRLogIsLevelEnabled(v71, 0LL);

          if (!v72) {
            goto LABEL_56;
          }
          id v74 = (void *)_NRCopyLogObjectForNRUUID(v5[12], v73);
          _NRLogWithArgs( v74,  0LL,  "%s%.30s:%-4d Successfully created a catch-all interface (%@) and installed policies",  "",  "-[NRDDeviceConductor setupCatchAllInterfaceIfApplicable]",  7915LL,  v3);
          goto LABEL_55;
        }

void sub_1000E44D4(uint64_t a1)
{
  if (a1)
  {
    id v2 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 96));
    if (v2)
    {
      id v3 = (void *)*((void *)v2 + 16);
      id v29 = (id *)v2;
      nw_parameters_t v4 = v3;
      if (v4 && *((_BYTE *)v29 + 12) && *(_BYTE *)(a1 + 44))
      {
        uint64_t v5 = *(void *)(a1 + 440);

        if (v5)
        {
LABEL_13:

          return;
        }

        nw_parameters_t v4 = nw_parameters_create();
        id v6 = v29[16];
        unsigned int v7 = [v6 proxyProviderRequiresWiFi];

        if (v7) {
          nw_parameters_set_required_interface_type(v4, nw_interface_type_wifi);
        }
        nw_parameters_set_account_id(v4, "com.apple.networkrelay.companion_proxy");
        id v8 = objc_alloc(&OBJC_CLASS___NRCompanionProxyConfigAgent);
        unsigned int v9 = *(void **)(a1 + 104);
        id v10 = *(id *)(a1 + 96);
        id v11 = v9;
        uint64_t v12 = sub_10005F548((id *)&v8->super.isa, v11, v4, v10);
        id v13 = *(void **)(a1 + 440);
        *(void *)(a1 + 440) = v12;

        if ((sub_10005F7E0(*(void *)(a1 + 440), v14) & 1) == 0)
        {
          int v15 = *(void **)(a1 + 440);
          *(void *)(a1 + 440) = 0LL;

          id v17 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v16);
          int IsLevelEnabled = _NRLogIsLevelEnabled(v17, 17LL);

          if (IsLevelEnabled)
          {
            uint64_t v20 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v19);
            _NRLogWithArgs(v20, 17LL, "failed to register companion proxy config agent");
          }
        }
      }

      goto LABEL_13;
    }

    id v21 = sub_1000D54AC();
    int v22 = _NRLogIsLevelEnabled(v21, 16LL);

    if (v22)
    {
      id v23 = sub_1000D54AC();
      _NRLogWithArgs( v23,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRDDeviceConductor setupCompanionProxyConfigAgentIfApplicable]",  495);
    }

    uint64_t v24 = _os_log_pack_size(12LL);
    __int128 v25 = (char *)&v29 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v26 = __error();
    uint64_t v27 = _os_log_pack_fill( v25,  v24,  *v26,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    *(_DWORD *)uint64_t v27 = 136446210;
    *(void *)(v27 + 4) = "-[NRDDeviceConductor setupCompanionProxyConfigAgentIfApplicable]";
    id v28 = sub_1000D54AC();
    _NRLogAbortWithPack(v28, v25);
  }

void sub_1000E475C(void **a1)
{
  if (a1)
  {
    uint64_t v67 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, a1[12]);
    if (sub_100107FE8(v67))
    {
      id v2 = a1[48];
      if (!v2) {
        goto LABEL_6;
      }
      nw_parameters_t v4 = (unsigned __int8 *)a1[48];
      if (!v4)
      {

        uint64_t v6 = (uint64_t)a1[48];
        if (!v6)
        {
LABEL_8:
          if (v67)
          {
            __int128 v69 = 0uLL;
            sub_10012D7C8(v67, &v69);
            objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
            if (WORD5(v69)) {
              BOOL v8 = WORD6(v69) == 0;
            }
            else {
              BOOL v8 = 1;
            }
            unsigned int v9 = !v8;
            __int128 v69 = 0uLL;
            sub_100136A64(v67, &v69);
            objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
            if (WORD5(v69)) {
              BOOL v10 = WORD6(v69) == 0;
            }
            else {
              BOOL v10 = 1;
            }
            unsigned int v11 = !v10;
            if (v67[8])
            {
              unsigned int v12 = v67[9] ? v9 : 0;
              if ((v12 & v11 & 1) != 0)
              {
                id v13 = objc_alloc(&OBJC_CLASS___NRCompanionLinkViabilityAgent);
                uint64_t v14 = a1[12];
                id v15 = a1[13];
                id v16 = v14;
                id v17 = sub_10006776C((id *)&v13->super.isa, v16, v15);
                uint64_t v18 = a1[48];
                a1[48] = v17;

                uint64_t v19 = a1[48];
                if (v19)
                {
                  dispatch_assert_queue_V2(*((dispatch_queue_t *)v19 + 5));
                  if (!*((_BYTE *)v19 + 14))
                  {
                    uint64_t v20 = -[NWNetworkAgentRegistration initWithNetworkAgentClass:]( objc_alloc(&OBJC_CLASS___NWNetworkAgentRegistration),  "initWithNetworkAgentClass:",  objc_opt_class(v19));
                    id v21 = (void *)*((void *)v19 + 6);
                    *((void *)v19 + 6) = v20;

                    int v22 = (void *)*((void *)v19 + 6);
                    if (v22)
                    {
                      if ([v22 registerNetworkAgent:v19])
                      {
                        uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v19 agentUUID]);
                        uint64_t v25 = objc_claimAutoreleasedReturnValue(+[NEPolicyResult netAgentUUID:](&OBJC_CLASS___NEPolicyResult, "netAgentUUID:", v24));

                        id v26 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *((void **)v19 + 4));
                        uint64_t v27 = sub_10012D254(v26, @"62742");
                        uint64_t v28 = objc_claimAutoreleasedReturnValue( +[NEPolicyCondition flowRemoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "flowRemoteAddress:prefix:",  v27,  128LL));

                        uint64_t v64 = v26;
                        id v29 = sub_10012D610(v26, @"62742");
                        id v66 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition flowRemoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "flowRemoteAddress:prefix:",  v29,  128LL));

                        id v30 = objc_alloc(&OBJC_CLASS___NEPolicy);
                        int v63 = (void *)v28;
                        *(void *)&__int128 v69 = v28;
                        uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition allInterfaces]( &OBJC_CLASS___NEPolicyCondition,  "allInterfaces"));
                        *((void *)&v69 + 1) = v31;
                        id v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v69,  2LL));
                        unsigned int v33 = (void *)v25;
                        id v65 = [v30 initWithOrder:10 result:v25 conditions:v32];

                        objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                        if (qword_1001DCB60 != -1) {
                          dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                        }
                        id v34 = (id)qword_1001DCB58;
                        id v35 = sub_100120E44((uint64_t)v34, *((void **)v19 + 7), v65);

                        id v36 = objc_alloc(&OBJC_CLASS___NEPolicy);
                        v68[0] = v66;
                        unsigned __int8 v37 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition allInterfaces]( &OBJC_CLASS___NEPolicyCondition,  "allInterfaces"));
                        v68[1] = v37;
                        uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v68,  2LL));
                        id v39 = [v36 initWithOrder:10 result:v25 conditions:v38];

                        objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                        if (qword_1001DCB60 != -1) {
                          dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                        }
                        id v40 = (id)qword_1001DCB58;
                        id v41 = sub_100120E44((uint64_t)v40, *((void **)v19 + 7), v39);

                        objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                        if (qword_1001DCB60 != -1) {
                          dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                        }
                        id v42 = (id)qword_1001DCB58;
                        id v43 = (id *)v42;
                        if (v42)
                        {
                          dispatch_assert_queue_V2(*((dispatch_queue_t *)v42 + 1));
                          if (([v43[2] apply] & 1) == 0) {
                            sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v44,  v45,  v46,  v62);
                          }
                        }

                        *((_BYTE *)v19 + 14) = 1;
                        id v47 = (void *)*((void *)v19 + 4);
                        id v48 = *((id *)v19 + 8);
                        id v49 = v47;
                        unsigned __int8 v50 = (void *)objc_claimAutoreleasedReturnValue([v19 agentUUID]);
                        id v51 = (void *)objc_claimAutoreleasedReturnValue([v50 UUIDString]);
                        sub_10011BB18(v49, 19002, v48, v51);
                      }

                      else
                      {
                        uint64_t v52 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v19 + 4), v23);
                        int IsLevelEnabled = _NRLogIsLevelEnabled(v52, 17LL);

                        if (IsLevelEnabled)
                        {
                          id v55 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v19 + 4), v54);
                          _NRLogWithArgs(v55, 17LL, "Failed to register CompanionLinkViability agent");
                        }
                      }
                    }
                  }
                }

                sub_1000E2FD0((uint64_t)a1);
                goto LABEL_51;
              }
            }
          }

          else
          {
            unsigned int v9 = 0;
            unsigned int v11 = 0;
          }

          id v56 = (void *)_NRCopyLogObjectForNRUUID(a1[12], v3);
          int v57 = _NRLogIsLevelEnabled(v56, 0LL);

          if (v57)
          {
            id v59 = (void *)_NRCopyLogObjectForNRUUID(a1[12], v58);
            if (v67)
            {
              uint64_t v60 = v67[8];
              uint64_t v61 = v67[9];
            }

            else
            {
              uint64_t v60 = 0LL;
              uint64_t v61 = 0LL;
            }

            _NRLogWithArgs( v59,  0LL,  "%s%.30s:%-4d %@ Deferring the registration of viability agent (registered=%d, enabled=%d, hasClassDAddr=%d , hasClassCAddr=%d)",  "",  "-[NRDDeviceConductor createCmpLnkViabilityAgentIfApplicable]",  1816LL,  v67,  v60,  v61,  v9,  v11);
          }

          goto LABEL_51;
        }

void sub_1000E4DAC(char *a1, void *a2)
{
  id v4 = a2;
  if (!a1) {
    goto LABEL_92;
  }
  dispatch_assert_queue_V2(*((dispatch_queue_t *)a1 + 13));
  if ([v4 state] != 8)
  {
    unsigned int v7 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v5);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0LL);

    if (IsLevelEnabled)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v9);
      _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d Not setting IP tunnel policies because link is not ready %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3490LL,  v4);
    }

    goto LABEL_92;
  }

  if (([v4 hasCompanionDatapath] & 1) == 0)
  {
    id v11 = v4;
    if ([v11 hasCompanionDatapath])
    {
LABEL_44:

      goto LABEL_92;
    }

    unsigned int v12 = &APSConnectionOverrideNamedDelegatePort_ptr;
    id v13 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    uint64_t v14 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *((void **)a1 + 12));
    uint64_t v15 = objc_claimAutoreleasedReturnValue([v11 localInterfaceName]);
    if (v15)
    {
      id v16 = (void *)v15;
      uint64_t v17 = objc_claimAutoreleasedReturnValue([v11 proxyAgentUUID]);
      if (v17)
      {
        uint64_t v18 = (void *)v17;
        uint64_t v549 = v13;
        if (v14) {
          uint64_t v19 = (void *)*((void *)v14 + 16);
        }
        else {
          uint64_t v19 = 0LL;
        }
        id v20 = v19;
        unsigned __int8 v21 = [v20 hasPoliciesForProxyCriteria];

        id v13 = v549;
        if ((v21 & 1) == 0)
        {
          id v547 = v14;
          int v22 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
          uint64_t v570 = v22;
          uint64_t v23 = (char *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v570,  1LL));

          uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v11 localInterfaceName]);
          uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forInterfaceName:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forInterfaceName:",  5LL,  v24));

          id v26 = (void *)objc_claimAutoreleasedReturnValue([v11 proxyAgentUUID]);
          [v25 setNetworkAgentUUID:v26];

          id v546 = v25;
          v569 = v25;
          uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v569,  1LL));
          uint64_t v28 = (NSString *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v27));

          id v545 = v28;
          v548 = v23;
          id v29 = [[NEPolicy alloc] initWithOrder:10 result:v28 conditions:v23];
          objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
          if (qword_1001DCB60 != -1) {
            dispatch_once(&qword_1001DCB60, &stru_1001B0538);
          }
          id v30 = (id)qword_1001DCB58;
          id v31 = sub_100120E44((uint64_t)v30, *((void **)a1 + 34), v29);
          id v32 = (void *)objc_claimAutoreleasedReturnValue(v31);

          id v544 = v29;
          if ([v32 unsignedIntegerValue])
          {
            -[NSMutableArray addObject:](v549, "addObject:", v32);

            id v34 = objc_alloc(&OBJC_CLASS___NEPolicy);
            id v35 = (void *)objc_claimAutoreleasedReturnValue([v11 proxyAgentUUID]);
            id v36 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult netAgentUUID:](&OBJC_CLASS___NEPolicyResult, "netAgentUUID:", v35));
            unsigned __int8 v37 = (void *)objc_claimAutoreleasedReturnValue([v11 localInterfaceName]);
            uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition scopedInterface:]( &OBJC_CLASS___NEPolicyCondition,  "scopedInterface:",  v37));
            v568 = v38;
            id v39 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v568,  1LL));
            id v40 = [v34 initWithOrder:10 result:v36 conditions:v39];

            objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
            if (qword_1001DCB60 != -1) {
              dispatch_once(&qword_1001DCB60, &stru_1001B0538);
            }
            id v41 = (id)qword_1001DCB58;
            id v42 = sub_100120E44((uint64_t)v41, *((void **)a1 + 34), v40);
            id v32 = (void *)objc_claimAutoreleasedReturnValue(v42);

            if ([v32 unsignedIntegerValue])
            {
              -[NSMutableArray addObject:](v549, "addObject:", v32);

              id v13 = v549;
              uint64_t v14 = v547;
              unsigned int v12 = &APSConnectionOverrideNamedDelegatePort_ptr;
              goto LABEL_31;
            }

            id v327 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v43);
            int v328 = _NRLogIsLevelEnabled(v327, 16LL);

            if (v328)
            {
              id v330 = *((id *)a1 + 12);
              id v332 = (void *)_NRCopyLogObjectForNRUUID(v330, v331);
              _NRLogWithArgs( v332,  16LL,  "%s%.30s:%-4d %@ failed to add generalPolicy %@ to session %@",  "",  "-[NRDDeviceConductor setPoliciesForNonCompanionDatapath:]",  3467LL,  v11,  v40,  *((void *)a1 + 34));
            }

            unsigned __int16 v333 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v329);
            char v334 = _NRLogIsLevelEnabled(v333, 17LL);

            id v316 = v40;
            if ((v334 & 1) == 0)
            {
LABEL_180:
              [v11 cancelWithReason:@"Failed to add generalPolicy %@ to session %@", v316, *((void *)a1 + 34)];

              uint64_t v52 = v548;
              id v13 = v549;
              uint64_t v46 = v547;
              goto LABEL_42;
            }
          }

          else
          {
            id v316 = v544;
            uint64_t v317 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v33);
            int v318 = _NRLogIsLevelEnabled(v317, 16LL);

            if (v318)
            {
              id v320 = *((id *)a1 + 12);
              id v322 = (void *)_NRCopyLogObjectForNRUUID(v320, v321);
              _NRLogWithArgs( v322,  16LL,  "%s%.30s:%-4d %@ failed to add generalPolicy %@ to session %@",  "",  "-[NRDDeviceConductor setPoliciesForNonCompanionDatapath:]",  3462LL,  v11,  v544,  *((void *)a1 + 34));
            }

            id v323 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v319);
            char v324 = _NRLogIsLevelEnabled(v323, 17LL);

            if ((v324 & 1) == 0) {
              goto LABEL_180;
            }
          }

          uint64_t v326 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v325);
          _NRLogWithArgs(v326, 17LL, "Failed to add generalPolicy");

          goto LABEL_180;
        }
      }

      else
      {
      }
    }

LABEL_141:
        uint64_t v102 = v545;
        id v64 = v546;
        goto LABEL_89;
      }

      id v281 = sub_1000D54AC();
      int v282 = _NRLogIsLevelEnabled(v281, 16LL);

      if (v282)
      {
        id v283 = sub_1000D54AC();
        _NRLogWithArgs( v283,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3541);
      }

      id v4 = (id)_os_log_pack_size(12LL);
      a1 = (char *)&v541 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v284 = *__error();
      uint64_t v280 = _os_log_pack_fill( a1,  v4,  v284,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    }

    else
    {
      id v276 = sub_1000D54AC();
      int v277 = _NRLogIsLevelEnabled(v276, 16LL);

      if (v277)
      {
        id v278 = sub_1000D54AC();
        _NRLogWithArgs( v278,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (addedPolicyIDs) != ((void *)0)",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3538);
      }

      id v4 = (id)_os_log_pack_size(12LL);
      a1 = (char *)&v541 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v279 = *__error();
      uint64_t v280 = _os_log_pack_fill( a1,  v4,  v279,  &_mh_execute_header,  "%{public}s Assertion Failed: (addedPolicyIDs) != ((void *)0)");
    }

    *(_DWORD *)uint64_t v280 = 136446210;
    *(void *)(v280 + 4) = "-[NRDDeviceConductor setIPTunnelPolicyForLink:]";
    id v285 = sub_1000D54AC();
    _NRLogAbortWithPack(v285, a1);
LABEL_159:
    dispatch_once(&qword_1001DCB60, &stru_1001B0538);
LABEL_81:
    id v97 = (id)qword_1001DCB58;
    uint64_t v98 = (id *)v97;
    if (v97)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v97 + 1));
      if (([v98[2] apply] & 1) == 0) {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v99,  v100,  v101,  v541);
      }
    }

    uint64_t v102 = (NSString *)objc_claimAutoreleasedReturnValue([v4 policyIDs]);
    id v71 = [objc_alloc((Class)v65[143]) initWithArray:v102];
    [v71 addObjectsFromArray:v2];
    [v4 setPolicyIDs:v71];
    id v103 = *((id *)a1 + 12);
    __int128 v105 = (void *)_NRCopyLogObjectForNRUUID(v103, v104);
    int v106 = _NRLogIsLevelEnabled(v105, 0LL);

    if (v106)
    {
      id v107 = *((id *)a1 + 12);
      uint64_t v109 = (void *)_NRCopyLogObjectForNRUUID(v107, v108);
      _NRLogWithArgs( v109,  0LL,  "%s%.30s:%-4d Successfully set policies for link: %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3859LL,  v4);
    }

    goto LABEL_88;
  }

  uint64_t v260 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v62);
  int v261 = _NRLogIsLevelEnabled(v260, 16LL);

  if (v261)
  {
    id v263 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v262);
    _NRLogWithArgs( v263,  16LL,  "%s%.30s:%-4d %@ failed to get virtual interface to set IP tunnel policies",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3523LL,  v4);
  }

  uint64_t v264 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v262);
  int v265 = _NRLogIsLevelEnabled(v264, 17LL);

  if (v265)
  {
    int v267 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v266);
    _NRLogWithArgs(v267, 17LL, "Failed to get virtual interface to set IP tunnel policies");
  }

  [v4 cancelWithReason:@"Failed to get virtual interface to set IP tunnel policies"];
LABEL_92:
}

void sub_1000E8470(uint64_t a1)
{
  if (a1)
  {
    id v2 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 96));
    uint64_t v3 = v2;
    if (*(_BYTE *)(a1 + 47)) {
      goto LABEL_15;
    }
    if (v2) {
      id v4 = (void *)*((void *)v2 + 16);
    }
    else {
      id v4 = 0LL;
    }
    id v5 = v4;
    unsigned __int8 v6 = [v5 hasPoliciesForProxyCriteria];

    if ((v6 & 1) == 0)
    {
      sub_1000EAAB8(a1);
      goto LABEL_15;
    }

    if ([*(id *)(a1 + 128) state] != 8)
    {
LABEL_15:

      return;
    }

    id v216 = v3;
    id val = (id)a1;
    if (!*(void *)(a1 + 304))
    {
      unsigned int v7 = @"proxyCriteria";
      BOOL v8 = objc_alloc(&OBJC_CLASS___NSString);
      id v208 = (char *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 96) UUIDString]);
      uint64_t v9 = -[NSString initWithFormat:](v8, "initWithFormat:", @"NRDDC-%@-%@");

      BOOL v10 = *(void **)(a1 + 304);
      *(void *)(a1 + 304) = v9;
    }

    if (v3) {
      id v11 = (void *)*((void *)v3 + 16);
    }
    else {
      id v11 = 0LL;
    }
    id v12 = v11;
    id v13 = (void *)objc_claimAutoreleasedReturnValue([v12 proxyProviderCriteria]);
    unsigned int v14 = [v13 hasProxyCriteriaAssigningTokens];

    uint64_t v15 = (id *)val;
    id v16 = (void *)*((void *)val + 82);
    if (v14)
    {
      if (v16) {
        goto LABEL_19;
      }
      uint64_t v17 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      id v16 = (void *)*((void *)val + 82);
    }

    else
    {
      uint64_t v17 = 0LL;
    }

    *((void *)val + 82) = v17;

LABEL_19:
    if (v3) {
      uint64_t v18 = (void *)*((void *)v3 + 16);
    }
    else {
      uint64_t v18 = 0LL;
    }
    id v19 = v18;
    if ([v19 proxyCapability] == (id)1)
    {
      if (v3) {
        id v20 = (void *)*((void *)v3 + 16);
      }
      else {
        id v20 = 0LL;
      }
      id v21 = v20;
      int v22 = (void *)objc_claimAutoreleasedReturnValue([v21 proxyProviderCriteria]);
      unsigned __int8 v23 = [v22 forwardNonMatchingTraffic];

      uint64_t v15 = (id *)val;
      if ((v23 & 1) != 0) {
        goto LABEL_15;
      }
    }

    else
    {
    }

    if (v3) {
      uint64_t v24 = (void *)*((void *)v3 + 16);
    }
    else {
      uint64_t v24 = 0LL;
    }
    id v25 = v24;
    id v26 = [v25 proxyCapability];

    if (v26 == (id)2)
    {
      id v211 = (void *)objc_claimAutoreleasedReturnValue([v15[16] proxyAgentUUID]);
      if (!v211)
      {
        id v33 = sub_1000D54AC();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v33, 17LL);

        if (IsLevelEnabled)
        {
          id v35 = sub_1000D54AC();
          _NRLogWithArgs(v35, 17LL, "invalid proxy agent uuid");
        }

        uint64_t v3 = v216;
        goto LABEL_15;
      }

      if (v3) {
        uint64_t v27 = (void *)*((void *)v3 + 16);
      }
      else {
        uint64_t v27 = 0LL;
      }
      id v28 = val;
      id v29 = v27;
      unsigned int v30 = [v29 hasCompanionDatapath];

      id v31 = (void *)*((void *)val + 16);
      if (v30)
      {
        uint64_t v32 = NEVirtualInterfaceCopyName([v31 virtualInterface]);
      }

      else
      {
        uint64_t v32 = objc_claimAutoreleasedReturnValue([v31 localInterfaceName]);
        id v28 = val;
      }

      id v36 = (void *)v32;
      if (!v32)
      {
        id v47 = sub_1000D54AC();
        int v48 = _NRLogIsLevelEnabled(v47, 17LL);

        if (v48)
        {
          id v49 = sub_1000D54AC();
          _NRLogWithArgs(v49, 17LL, "invalid interface name for %@", *((void *)v28 + 16));
        }

        char v228 = 0;
LABEL_168:

        BOOL v207 = (v228 & 1) == 0 || v36 == 0LL;
        uint64_t v3 = v216;
        if (!v207) {
          dispatch_async(*((dispatch_queue_t *)val + 13), &stru_1001AF4E8);
        }
        goto LABEL_15;
      }

      id v210 = (void *)v32;
      id v37 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
      sub_10012114C((uint64_t)v37, *((void **)v28 + 38));

      uint64_t v215 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult netAgentUUID:](&OBJC_CLASS___NEPolicyResult, "netAgentUUID:", v211));
      if (v3)
      {
        uint64_t v38 = v3;
        id v39 = (void *)*((void *)v3 + 16);
      }

      else
      {
        id v39 = 0LL;
        uint64_t v38 = 0LL;
      }

      BOOL v40 = v38 == 0LL;
      id v41 = v39;
      id v42 = (void *)objc_claimAutoreleasedReturnValue([v41 proxyProviderCriteria]);
      uint64_t v43 = (void *)objc_claimAutoreleasedReturnValue([v42 proxyUsageRules]);

      if (v40) {
        uint64_t v44 = 0LL;
      }
      else {
        uint64_t v44 = (void *)*((void *)v216 + 16);
      }
      id v45 = v44;
      uint64_t v46 = (void *)objc_claimAutoreleasedReturnValue([v45 proxyProviderCriteria]);
      if ([v46 excludeLegacyClients])
      {
      }

      else
      {
        uint64_t v50 = v216;
        if (v216) {
          uint64_t v50 = (char *)*((void *)v216 + 16);
        }
        uint64_t v51 = v50;
        uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue([v51 proxyProviderCriteria]);
        unsigned int v53 = [v52 excludeNonMatchingLegacyClients];

        if (!v53)
        {
          int v75 = 301;
LABEL_59:
          int v223 = v75;
          if (_NRIsAppleInternal(v54))
          {
            id v76 = sub_1000A019C(0LL, @"TetheringBundleIDs");
            id v77 = (void *)objc_claimAutoreleasedReturnValue(v76);
            uint64_t v78 = objc_opt_class(&OBJC_CLASS___NSArray);
            if ((objc_opt_isKindOfClass(v77, v78) & 1) != 0)
            {
              __int128 v268 = 0u;
              __int128 v269 = 0u;
              __int128 v266 = 0u;
              __int128 v267 = 0u;
              id v79 = v77;
              id v80 = [v79 countByEnumeratingWithState:&v266 objects:v285 count:16];
              if (v80)
              {
                uint64_t v227 = 0LL;
                uint64_t v81 = *(void *)v267;
                do
                {
                  for (uint64_t i = 0LL; i != v80; uint64_t i = (char *)i + 1)
                  {
                    if (*(void *)v267 != v81) {
                      objc_enumerationMutation(v79);
                    }
                    id v83 = sub_10010172C(*(void **)(*((void *)&v266 + 1) + 8LL * (void)i));
                    if (!v227) {
                      uint64_t v227 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                    }
                    if ([v83 count]) {
                      -[NSMutableArray addObjectsFromArray:](v227, "addObjectsFromArray:", v83);
                    }
                  }

                  id v80 = [v79 countByEnumeratingWithState:&v266 objects:v285 count:16];
                }

                while (v80);
              }

              else
              {
                uint64_t v227 = 0LL;
              }
            }

            else
            {
              uint64_t v227 = 0LL;
            }
          }

          else
          {
            uint64_t v227 = 0LL;
          }

          id v212 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
          __int128 v264 = 0u;
          __int128 v265 = 0u;
          __int128 v262 = 0u;
          __int128 v263 = 0u;
          id obj = v43;
          id v84 = [obj countByEnumeratingWithState:&v262 objects:v284 count:16];
          id v218 = v84;
          if (v84)
          {
            char v214 = 0;
            char v228 = 0;
            uint64_t v217 = *(void *)v263;
            do
            {
              id v222 = 0LL;
              do
              {
                if (*(void *)v263 != v217) {
                  objc_enumerationMutation(obj);
                }
                id v226 = *(void **)(*((void *)&v262 + 1) + 8LL * (void)v222);
                if ((_NRIsAppleInternal(v84) & (v227 != 0LL)) == 1)
                {
                  id v234 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                  -[NSMutableArray addObjectsFromArray:](v234, "addObjectsFromArray:", v227);
                }

                else
                {
                  id v234 = 0LL;
                }

                uint64_t v85 = (void *)objc_claimAutoreleasedReturnValue([v226 entitlements]);
                BOOL v86 = [v85 count] == 0;

                if (v86) {
                  goto LABEL_108;
                }
                uint64_t v87 = (void *)objc_claimAutoreleasedReturnValue([v226 entitlements]);
                id v229 = (id)objc_claimAutoreleasedReturnValue( +[LSApplicationRecord enumeratorWithOptions:]( &OBJC_CLASS___LSApplicationRecord,  "enumeratorWithOptions:",  0LL));
                v260[0] = _NSConcreteStackBlock;
                v260[1] = 3221225472LL;
                v260[2] = sub_1000EABBC;
                v260[3] = &unk_1001AF478;
                id v224 = v87;
                id v261 = v224;
                [v229 setFilter:v260];
                id v88 = [v226 copyExcludedBundleIdentifiers];
                uint64_t v89 = (void *)objc_claimAutoreleasedReturnValue([v229 nextObject]);
                if (v89)
                {
                  do
                  {
                    __int128 v258 = 0u;
                    __int128 v259 = 0u;
                    __int128 v256 = 0u;
                    __int128 v257 = 0u;
                    id v90 = (void *)objc_claimAutoreleasedReturnValue([v89 machOUUIDs]);
                    id v91 = [v90 countByEnumeratingWithState:&v256 objects:v283 count:16];
                    if (v91)
                    {
                      uint64_t v92 = *(void *)v257;
                      while (2)
                      {
                        for (j = 0LL; j != v91; j = (char *)j + 1)
                        {
                          if (*(void *)v257 != v92) {
                            objc_enumerationMutation(v90);
                          }
                          uint64_t v94 = *(void *)(*((void *)&v256 + 1) + 8LL * (void)j);
                          if (!v234) {
                            id v234 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                          }
                          id v95 = (void *)objc_claimAutoreleasedReturnValue([v89 bundleIdentifier]);
                          if (v95)
                          {
                            uint64_t v96 = (void *)objc_claimAutoreleasedReturnValue([v89 bundleIdentifier]);
                            unsigned int v97 = [v88 containsObject:v96];

                            if (v97)
                            {
                              uint64_t v99 = (void *)_NRCopyLogObjectForNRUUID(*((void *)val + 12), v98);
                              int v100 = _NRLogIsLevelEnabled(v99, 0LL);

                              if (v100)
                              {
                                uint64_t v102 = (void *)_NRCopyLogObjectForNRUUID(*((void *)val + 12), v101);
                                uint64_t v209 = (void *)objc_claimAutoreleasedReturnValue([v89 bundleIdentifier]);
                                id v208 = "";
                                _NRLogWithArgs( v102,  0LL,  "%s%.30s:%-4d found exclude bundle identifier %@. Skipping rule");
                              }

                              goto LABEL_102;
                            }
                          }

                          -[NSMutableArray addObject:](v234, "addObject:", v94);
                        }

                        id v91 = [v90 countByEnumeratingWithState:&v256 objects:v283 count:16];
                        if (v91) {
                          continue;
                        }
                        break;
                      }
                    }

LABEL_102:
                    uint64_t v103 = objc_claimAutoreleasedReturnValue([v229 nextObject]);
                    uint64_t v89 = (void *)v103;
                  }

                  while (v103);
                }

                id v105 = -[NSMutableArray count](v234, "count");
                if (v105)
                {
                  -[NSMutableSet addObjectsFromArray:](v212, "addObjectsFromArray:", v234);
                }

                else
                {
                  int v106 = (void *)_NRCopyLogObjectForNRUUID(*((void *)val + 12), v104);
                  int v107 = _NRLogIsLevelEnabled(v106, 0LL);

                  if (v107)
                  {
                    id v108 = *((id *)val + 12);
                    id v110 = (void *)_NRCopyLogObjectForNRUUID(v108, v109);
                    id v208 = "";
                    _NRLogWithArgs(v110, 0LL, "%s%.30s:%-4d no app has entitlements %@. Skipping rule");
                  }
                }

                char v214 = 1;
                if (v105)
                {
LABEL_108:
                  __int128 v225 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                  uint64_t v111 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition trafficClassStart:end:]( NEPolicyCondition,  "trafficClassStart:end:",  [v226 trafficClass],  objc_msgSend(v226, "trafficClass")));
                  -[NSMutableArray addObject:](v225, "addObject:", v111);

                  if ([v226 transportProtocol])
                  {
                    int v112 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition flowIPProtocol:]( NEPolicyCondition,  "flowIPProtocol:",  [v226 transportProtocol]));
                    -[NSMutableArray addObject:](v225, "addObject:", v112);
                  }

                  int v113 = (void *)objc_claimAutoreleasedReturnValue([v226 domain]);
                  BOOL v114 = v113 == 0LL;

                  if (!v114)
                  {
                    uint64_t v115 = (void *)objc_claimAutoreleasedReturnValue([v226 domain]);
                    int v116 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition domain:](&OBJC_CLASS___NEPolicyCondition, "domain:", v115));

                    -[NSMutableArray addObject:](v225, "addObject:", v116);
                  }

                  uint64_t v117 = (v223 + 3);
                  uint64_t v118 = (v223 + 5);
                  unsigned int v221 = v223 + 7;
                  if (-[NSMutableArray count](v225, "count"))
                  {
                    id v119 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition allInterfaces]( &OBJC_CLASS___NEPolicyCondition,  "allInterfaces"));
                    -[NSMutableArray addObject:](v225, "addObject:", v119);

                    uint64_t v120 = (void *)objc_claimAutoreleasedReturnValue([v226 entitlements]);
                    BOOL v121 = [v120 count] == 0;

                    if (v121) {
                      uint64_t v122 = v118;
                    }
                    else {
                      uint64_t v122 = v117;
                    }
                    id v123 = objc_alloc(&OBJC_CLASS___NEPolicy);
                    id v124 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult skipWithOrder:]( &OBJC_CLASS___NEPolicyResult,  "skipWithOrder:",  v122));
                    id v125 = [v123 initWithOrder:(v223 + 1) result:v124 conditions:v225];

                    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                    if (qword_1001DCB60 != -1) {
                      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                    }
                    id v126 = (id)qword_1001DCB58;
                    id v127 = sub_100120E44((uint64_t)v126, *((void **)val + 38), v125);

                    id v128 = objc_alloc(&OBJC_CLASS___NEPolicy);
                    __int128 v129 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult skipWithOrder:]( &OBJC_CLASS___NEPolicyResult,  "skipWithOrder:",  v221));
                    id v130 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition allInterfaces]( &OBJC_CLASS___NEPolicyCondition,  "allInterfaces"));
                    int v282 = v130;
                    __int128 v131 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v282,  1LL));
                    id v132 = [v128 initWithOrder:(v223 + 2) result:v129 conditions:v131];

                    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                    if (qword_1001DCB60 != -1) {
                      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                    }
                    id v133 = (id)qword_1001DCB58;
                    id v134 = sub_100120E44((uint64_t)v133, *((void **)val + 38), v132);
                  }

                  __int128 v254 = 0u;
                  __int128 v255 = 0u;
                  __int128 v252 = 0u;
                  __int128 v253 = 0u;
                  id v234 = v234;
                  id v135 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v234,  "countByEnumeratingWithState:objects:count:",  &v252,  v281,  16LL);
                  if (v135)
                  {
                    uint64_t v136 = *(void *)v253;
                    do
                    {
                      for (uint64_t k = 0LL; k != v135; uint64_t k = (char *)k + 1)
                      {
                        if (*(void *)v253 != v136) {
                          objc_enumerationMutation(v234);
                        }
                        uint64_t v138 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition effectiveApplication:]( &OBJC_CLASS___NEPolicyCondition,  "effectiveApplication:",  *(void *)(*((void *)&v252 + 1) + 8LL * (void)k)));
                        id v139 = objc_alloc(&OBJC_CLASS___NEPolicy);
                        int v140 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult skipWithOrder:]( &OBJC_CLASS___NEPolicyResult,  "skipWithOrder:",  v118));
                        uint64_t v141 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition allInterfaces]( &OBJC_CLASS___NEPolicyCondition,  "allInterfaces"));
                        v280[0] = v141;
                        v280[1] = v138;
                        id v142 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v280,  2LL));
                        id v143 = [v139 initWithOrder:v117 result:v140 conditions:v142];

                        objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                        if (qword_1001DCB60 != -1) {
                          dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                        }
                        id v144 = (id)qword_1001DCB58;
                        id v145 = sub_100120E44((uint64_t)v144, *((void **)val + 38), v143);
                      }

                      id v135 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v234,  "countByEnumeratingWithState:objects:count:",  &v252,  v281,  16LL);
                    }

                    while (v135);
                  }

                  id v146 = objc_alloc(&OBJC_CLASS___NEPolicy);
                  id v147 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult skipWithOrder:]( &OBJC_CLASS___NEPolicyResult,  "skipWithOrder:",  v221));
                  uint64_t v148 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
                  uint64_t v279 = v148;
                  id v149 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v279,  1LL));
                  id v220 = [v146 initWithOrder:(v223 + 4) result:v147 conditions:v149];

                  objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                  if (qword_1001DCB60 != -1) {
                    dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                  }
                  id v150 = (id)qword_1001DCB58;
                  id v151 = sub_100120E44((uint64_t)v150, *((void **)val + 38), v220);

                  id v152 = objc_alloc(&OBJC_CLASS___NEPolicy);
                  id v153 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
                  id v278 = v153;
                  id v154 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v278,  1LL));
                  id v219 = [v152 initWithOrder:v118 result:v215 conditions:v154];

                  objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                  if (qword_1001DCB60 != -1) {
                    dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                  }
                  id v155 = (id)qword_1001DCB58;
                  id v156 = sub_100120E44((uint64_t)v155, *((void **)val + 38), v219);

                  id v157 = [v226 copyMatchTokens];
                  __int128 v250 = 0u;
                  __int128 v251 = 0u;
                  __int128 v248 = 0u;
                  __int128 v249 = 0u;
                  id v230 = v157;
                  id v158 = [v230 countByEnumeratingWithState:&v248 objects:v277 count:16];
                  if (v158)
                  {
                    uint64_t v159 = *(void *)v249;
                    do
                    {
                      for (m = 0LL; m != v158; m = (char *)m + 1)
                      {
                        if (*(void *)v249 != v159) {
                          objc_enumerationMutation(v230);
                        }
                        id v161 = *(void **)(*((void *)&v248 + 1) + 8LL * (void)m);
                        id v162 = (void *)objc_claimAutoreleasedReturnValue([*((id *)val + 82) objectForKeyedSubscript:v161]);
                        if (v162) {
                          goto LABEL_142;
                        }
                        id v162 = (void *)nw_agent_create( "com.apple.networkrelay",  "ProxyUsageTokenAgent",  "",  *((void *)val + 13));
                        dispatch_data_t v163 = dispatch_data_create( [v161 bytes],  (size_t)objc_msgSend(v161, "length"),  *((dispatch_queue_t *)val + 13),  0);
                        nw_agent_change_state(v162, 1LL, 0LL, 0LL);
                        objc_initWeak(location, val);
                        objc_initWeak(&from, v162);
                        v243[0] = _NSConcreteStackBlock;
                        v243[1] = 3221225472LL;
                        v243[2] = sub_1000EAD7C;
                        v243[3] = &unk_1001AF4A0;
                        objc_copyWeak(&v245, location);
                        objc_copyWeak(&v246, &from);
                        id v164 = v163;
                        id v244 = v164;
                        nw_agent_set_token_low_water_mark(v162, 1LL, v243);
                        v241[0] = _NSConcreteStackBlock;
                        v241[1] = 3221225472LL;
                        v241[2] = sub_1000EAE48;
                        v241[3] = &unk_1001AF4C8;
                        objc_copyWeak(&v242, location);
                        nw_agent_set_error_handler(v162, v241);
                        sub_1000EAEF8(v162, v164);
                        id v165 = *((id *)val + 82);
                        [v165 setObject:v162 forKeyedSubscript:v161];

                        objc_destroyWeak(&v242);
                        objc_destroyWeak(&v246);
                        objc_destroyWeak(&v245);
                        objc_destroyWeak(&from);
                        objc_destroyWeak(location);

                        char v228 = 1;
                        if (v162)
                        {
LABEL_142:
                          location[1] = 0LL;
                          location[0] = 0LL;
                          nw_agent_get_uuid(v162, location);
                          id v166 = -[NSUUID initWithUUIDBytes:]( objc_alloc(&OBJC_CLASS___NSUUID),  "initWithUUIDBytes:",  location);
                          int v167 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult netAgentUUID:]( &OBJC_CLASS___NEPolicyResult,  "netAgentUUID:",  v166));
                          id v168 = objc_alloc(&OBJC_CLASS___NEPolicy);
                          id v169 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition allInterfaces]( &OBJC_CLASS___NEPolicyCondition,  "allInterfaces"));
                          id v275 = v169;
                          id v170 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v275,  1LL));
                          id v171 = [v168 initWithOrder:v118 result:v167 conditions:v170];

                          objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                          if (qword_1001DCB60 != -1) {
                            dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                          }
                          id v172 = (id)qword_1001DCB58;
                          id v173 = sub_100120E44((uint64_t)v172, *((void **)val + 38), v171);
                        }
                      }

                      id v158 = [v230 countByEnumeratingWithState:&v248 objects:v277 count:16];
                    }

                    while (v158);
                  }

                  id v174 = objc_alloc(&OBJC_CLASS___NEPolicy);
                  id v175 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult skipWithOrder:]( &OBJC_CLASS___NEPolicyResult,  "skipWithOrder:",  599LL));
                  uint64_t v176 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
                  uint64_t v274 = v176;
                  id v177 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v274,  1LL));
                  id v178 = [v174 initWithOrder:(v223 + 6) result:v175 conditions:v177];

                  objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                  if (qword_1001DCB60 != -1) {
                    dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                  }
                  id v179 = (id)qword_1001DCB58;
                  id v180 = sub_100120E44((uint64_t)v179, *((void **)val + 38), v178);

                  v223 += 7;
                }

                id v222 = (char *)v222 + 1;
              }

              while (v222 != v218);
              id v84 = [obj countByEnumeratingWithState:&v262 objects:v284 count:16];
              id v218 = v84;
            }

            while (v84);
          }

          else
          {
            char v214 = 0;
            char v228 = 0;
          }

          if (-[NSMutableSet count](v212, "count"))
          {
            id v232 = (id *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 591LL));
            id v181 = objc_alloc(&OBJC_CLASS___NEPolicy);
            uint64_t v182 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
            int v273 = v182;
            id v183 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v273,  1LL));
            to = (id *)[v181 initWithOrder:589 result:v232 conditions:v183];

            id v184 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
            id v185 = sub_100120E44((uint64_t)v184, *((void **)val + 38), to);

            __int128 v239 = 0u;
            __int128 v240 = 0u;
            __int128 v237 = 0u;
            __int128 v238 = 0u;
            id v233 = v212;
            id v186 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v233,  "countByEnumeratingWithState:objects:count:",  &v237,  v272,  16LL);
            if (v186)
            {
              id v235 = *(id *)v238;
              do
              {
                for (n = 0LL; n != v186; n = (char *)n + 1)
                {
                  if (*(id *)v238 != v235) {
                    objc_enumerationMutation(v233);
                  }
                  uint64_t v188 = *(void *)(*((void *)&v237 + 1) + 8LL * (void)n);
                  uint64_t v189 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  7LL,  0LL));
                  [v189 setControlUnit:0xFFFFFFFLL];
                  id v190 = objc_alloc(&OBJC_CLASS___NEPolicy);
                  id v271 = v189;
                  uint64_t v191 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v271,  1LL));
                  id v192 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v191));
                  id v193 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
                  v270[0] = v193;
                  id v194 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition effectiveApplication:]( &OBJC_CLASS___NEPolicyCondition,  "effectiveApplication:",  v188));
                  v270[1] = v194;
                  id v195 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v270,  2LL));
                  id v196 = [v190 initWithOrder:590 result:v192 conditions:v195];

                  objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                  if (qword_1001DCB60 != -1) {
                    dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                  }
                  id v197 = (id)qword_1001DCB58;
                  id v198 = sub_100120E44((uint64_t)v197, *((void **)val + 38), v196);
                }

                id v186 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v233,  "countByEnumeratingWithState:objects:count:",  &v237,  v272,  16LL);
              }

              while (v186);
            }
          }

          id v199 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
          sub_1001212F4((uint64_t)v199, v200, v201, v202, v203, v204, v205, v206, (uint64_t)v208);

          if ((v214 & 1) != 0) {
            sub_1000EAFE4((uint64_t)val);
          }
          else {
            sub_1000EAAB8((uint64_t)val);
          }

          id v36 = v210;
          goto LABEL_168;
        }
      }

      id v55 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      int v56 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition usesModernNetworkAPI](&OBJC_CLASS___NEPolicyCondition, "usesModernNetworkAPI"));
      uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition allowsUnsafeSocketAccess]( &OBJC_CLASS___NEPolicyCondition,  "allowsUnsafeSocketAccess"));
      [v57 setNegative:1];
      uint64_t v58 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 304LL));
      id v59 = objc_alloc(&OBJC_CLASS___NEPolicy);
      v287[0] = v55;
      v287[1] = v56;
      v287[2] = v57;
      int v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v287, 3LL));
      id v61 = [v59 initWithOrder:302 result:v58 conditions:v60];

      id v62 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
      id v63 = sub_100120E44((uint64_t)v62, *((void **)val + 38), v61);

      if (v216) {
        id v64 = (void *)*((void *)v216 + 16);
      }
      else {
        id v64 = 0LL;
      }
      id v65 = v64;
      id v66 = (void *)objc_claimAutoreleasedReturnValue([v65 proxyProviderCriteria]);
      unsigned int v67 = [v66 excludeNonMatchingLegacyClients];

      if (v67) {
        uint64_t v68 = 590LL;
      }
      else {
        uint64_t v68 = 599LL;
      }
      __int128 v69 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", v68));
      id v70 = objc_alloc(&OBJC_CLASS___NEPolicy);
      unsigned int v286 = v55;
      id v71 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v286, 1LL));
      id v72 = [v70 initWithOrder:303 result:v69 conditions:v71];

      id v73 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
      id v74 = sub_100120E44((uint64_t)v73, *((void **)val + 38), v72);

      int v75 = 304;
      goto LABEL_59;
    }

    goto LABEL_15;
  }

void sub_1000E9DC8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, id *a32, id *a33, id *location, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,id a58)
{
}

void sub_1000E9E10(uint64_t a1)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    id v2 = *(id *)(a1 + 120);
    if (v2)
    {
      uint64_t v3 = v2;
      id v4 = [*(id *)(a1 + 120) count];

      if (v4)
      {
        __int128 v61 = 0u;
        __int128 v62 = 0u;
        __int128 v59 = 0u;
        __int128 v60 = 0u;
        id v5 = [*(id *)(a1 + 120) copy];
        id v6 = [v5 countByEnumeratingWithState:&v59 objects:v68 count:16];
        if (v6)
        {
          id v7 = v6;
          uint64_t v8 = *(void *)v60;
          do
          {
            for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v60 != v8) {
                objc_enumerationMutation(v5);
              }
              sub_1000D3428(a1, *(void **)(*((void *)&v59 + 1) + 8LL * (void)i));
            }

            id v7 = [v5 countByEnumeratingWithState:&v59 objects:v68 count:16];
          }

          while (v7);
        }

        __int128 v57 = 0u;
        __int128 v58 = 0u;
        __int128 v55 = 0u;
        __int128 v56 = 0u;
        id v10 = *(id *)(a1 + 120);
        id v11 = [v10 countByEnumeratingWithState:&v55 objects:v67 count:16];
        if (v11)
        {
          id v12 = v11;
          id v13 = 0LL;
          uint64_t v14 = *(void *)v56;
          do
          {
            for (j = 0LL; j != v12; j = (char *)j + 1)
            {
              if (*(void *)v56 != v14) {
                objc_enumerationMutation(v10);
              }
              uint64_t v16 = *(void *)(*((void *)&v55 + 1) + 8LL * (void)j);
              if (v16 && *(_BYTE *)(v16 + 12))
              {
                if (!v13) {
                  id v13 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                }
                -[NSMutableArray addObject:](v13, "addObject:", v16);
              }
            }

            id v12 = [v10 countByEnumeratingWithState:&v55 objects:v67 count:16];
          }

          while (v12);
        }

        else
        {
          id v13 = 0LL;
        }

        __int128 v53 = 0u;
        __int128 v54 = 0u;
        __int128 v51 = 0u;
        __int128 v52 = 0u;
        uint64_t v17 = v13;
        id v18 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v17,  "countByEnumeratingWithState:objects:count:",  &v51,  v66,  16LL);
        if (v18)
        {
          id v19 = v18;
          uint64_t v20 = *(void *)v52;
          do
          {
            for (uint64_t k = 0LL; k != v19; uint64_t k = (char *)k + 1)
            {
              if (*(void *)v52 != v20) {
                objc_enumerationMutation(v17);
              }
              sub_1000D551C(a1, *(void **)(*((void *)&v51 + 1) + 8LL * (void)k));
            }

            id v19 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v17,  "countByEnumeratingWithState:objects:count:",  &v51,  v66,  16LL);
          }

          while (v19);
        }

        __int128 v49 = 0u;
        __int128 v50 = 0u;
        __int128 v47 = 0u;
        __int128 v48 = 0u;
        id v22 = *(id *)(a1 + 120);
        id v23 = [v22 countByEnumeratingWithState:&v47 objects:v65 count:16];
        if (v23)
        {
          id v24 = v23;
          uint64_t v25 = *(void *)v48;
          do
          {
            for (m = 0LL; m != v24; m = (char *)m + 1)
            {
              if (*(void *)v48 != v25) {
                objc_enumerationMutation(v22);
              }
              sub_1000D3428(a1, *(void **)(*((void *)&v47 + 1) + 8LL * (void)m));
            }

            id v24 = [v22 countByEnumeratingWithState:&v47 objects:v65 count:16];
          }

          while (v24);
        }

        __int128 v45 = 0u;
        __int128 v46 = 0u;
        __int128 v43 = 0u;
        __int128 v44 = 0u;
        id v27 = *(id *)(a1 + 120);
        id v28 = [v27 countByEnumeratingWithState:&v43 objects:v64 count:16];
        if (v28)
        {
          id v29 = v28;
          unsigned int v30 = 0LL;
          uint64_t v31 = *(void *)v44;
          do
          {
            for (n = 0LL; n != v29; n = (char *)n + 1)
            {
              if (*(void *)v44 != v31) {
                objc_enumerationMutation(v27);
              }
              uint64_t v33 = *(void *)(*((void *)&v43 + 1) + 8LL * (void)n);
              if (v33 && *(_BYTE *)(v33 + 12))
              {
                if (!v30) {
                  unsigned int v30 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                }
                -[NSMutableArray addObject:](v30, "addObject:", v33);
              }
            }

            id v29 = [v27 countByEnumeratingWithState:&v43 objects:v64 count:16];
          }

          while (v29);
        }

        else
        {
          unsigned int v30 = 0LL;
        }

        __int128 v41 = 0u;
        __int128 v42 = 0u;
        __int128 v39 = 0u;
        __int128 v40 = 0u;
        id v34 = v30;
        id v35 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v34,  "countByEnumeratingWithState:objects:count:",  &v39,  v63,  16LL);
        if (v35)
        {
          id v36 = v35;
          uint64_t v37 = *(void *)v40;
          do
          {
            for (iuint64_t i = 0LL; ii != v36; iuint64_t i = (char *)ii + 1)
            {
              if (*(void *)v40 != v37) {
                objc_enumerationMutation(v34);
              }
              sub_1000D551C(a1, *(void **)(*((void *)&v39 + 1) + 8LL * (void)ii));
            }

            id v36 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v34,  "countByEnumeratingWithState:objects:count:",  &v39,  v63,  16LL);
          }

          while (v36);
        }
      }
    }
  }

void sub_1000EA2AC(uint64_t a1)
{
  if (a1 && *(_BYTE *)(a1 + 47) && !*(void *)(a1 + 632))
  {
    id v2 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 96));
    id v4 = v2;
    if (!v2) {
      goto LABEL_21;
    }
    if (v2[15])
    {
      char v5 = 1;
      if (!v2[12]) {
        goto LABEL_21;
      }
    }

    else
    {
      if (v2[14]) {
        BOOL v6 = 1;
      }
      else {
        BOOL v6 = *((unsigned __int16 *)v2 + 14) > 0x12u;
      }
      char v5 = v6;
      if (!v2[12]) {
        goto LABEL_21;
      }
    }

    if (!v2[13]) {
      char v5 = 0;
    }
    if ((v5 & 1) != 0)
    {
      if (*((unsigned __int16 *)v2 + 14) > 0x15u)
      {
        uint64_t v63 = a1;
        id v14 = *((id *)v2 + 6);

        if (v14)
        {
          uint64_t v16 = objc_alloc(&OBJC_CLASS___NRApplicationServiceClient);
          uint64_t v17 = *(void **)(a1 + 104);
          id v18 = *(id *)(v63 + 96);
          id v19 = v17;
          uint64_t v20 = sub_1000F6E98((id *)&v16->super.isa, (void *)v63, v19, v18);
          id v21 = *(void **)(v63 + 632);
          *(void *)(v63 + 632) = v20;

          id v23 = *(_BYTE **)(v63 + 632);
          if (v23 && !v23[9])
          {
            if (!v23[8])
            {
              v23[8] = 1;
              objc_opt_self(&OBJC_CLASS___NRApplicationServiceManager);
              if (qword_1001DC930 != -1) {
                dispatch_once(&qword_1001DC930, &stru_1001AF7E0);
              }
              uint64_t v33 = qword_1001DC928;
              id v34 = v23;
              if (v33)
              {
                dispatch_assert_queue_V2(*(dispatch_queue_t *)(v33 + 8));
                [*(id *)(v33 + 48) addObject:v34];
                __int128 v78 = 0u;
                __int128 v79 = 0u;
                __int128 v76 = 0u;
                __int128 v77 = 0u;
                uint64_t v62 = v33;
                id v35 = *(id *)(v33 + 32);
                id v36 = [v35 countByEnumeratingWithState:&v76 objects:location count:16];
                uint64_t v37 = v4;
                if (v36)
                {
                  uint64_t v38 = *(void *)v77;
                  do
                  {
                    for (uint64_t i = 0LL; i != v36; uint64_t i = (char *)i + 1)
                    {
                      if (*(void *)v77 != v38) {
                        objc_enumerationMutation(v35);
                      }
                      uint64_t v40 = *(void *)(*((void *)&v76 + 1) + 8LL * (void)i);
                      __int128 v41 = (dispatch_queue_s *)v34[8];
                      block[0] = _NSConcreteStackBlock;
                      block[1] = 3221225472LL;
                      block[2] = sub_1000F6DB8;
                      block[3] = &unk_1001B0720;
                      id v74 = v34;
                      uint64_t v75 = v40;
                      __int128 v42 = v41;
                      id v4 = v37;
                      dispatch_async(v42, block);
                    }

                    id v36 = [v35 countByEnumeratingWithState:&v76 objects:location count:16];
                  }

                  while (v36);
                }

                __int128 v72 = 0u;
                __int128 v70 = 0u;
                __int128 v71 = 0u;
                __int128 v69 = 0u;
                id v43 = *(id *)(v62 + 40);
                id v44 = [v43 countByEnumeratingWithState:&v69 objects:v80 count:16];
                if (v44)
                {
                  uint64_t v45 = *(void *)v70;
                  do
                  {
                    for (j = 0LL; j != v44; j = (char *)j + 1)
                    {
                      if (*(void *)v70 != v45) {
                        objc_enumerationMutation(v43);
                      }
                      uint64_t v47 = *(void *)(*((void *)&v69 + 1) + 8LL * (void)j);
                      __int128 v48 = (dispatch_queue_s *)v34[8];
                      v66[0] = _NSConcreteStackBlock;
                      v66[1] = 3221225472LL;
                      v66[2] = sub_1000F6DC4;
                      v66[3] = &unk_1001B0720;
                      unsigned int v67 = v34;
                      uint64_t v68 = v47;
                      __int128 v49 = v48;
                      id v4 = v37;
                      dispatch_async(v49, v66);
                    }

                    id v44 = [v43 countByEnumeratingWithState:&v69 objects:v80 count:16];
                  }

                  while (v44);
                }
              }

              __int128 v51 = (void *)_NRCopyLogObjectForNRUUID(v34[7], v50);
              int IsLevelEnabled = _NRLogIsLevelEnabled(v51, 1LL);

              if (IsLevelEnabled)
              {
                __int128 v54 = (void *)_NRCopyLogObjectForNRUUID(v34[7], v53);
                _NRLogWithArgs(v54, 1LL, "%s%.30s:%-4d %@ start", "", "-[NRApplicationServiceClient start]", 820LL, v34);
              }
            }

            __int128 v55 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
            objc_storeStrong((id *)(v63 + 648), v55);

            __int128 v57 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v63 + 96), v56);
            int v58 = _NRLogIsLevelEnabled(v57, 0LL);

            if (v58)
            {
              id v59 = *(id *)(v63 + 96);
              __int128 v61 = (void *)_NRCopyLogObjectForNRUUID(v59, v60);
              _NRLogWithArgs( v61,  0LL,  "%s%.30s:%-4d registered application service client %@",  "",  "-[NRDDeviceConductor registerASClientIfNeeded]",  8697LL,  *(void *)(v63 + 632));
            }

            sub_1000DDA30(v63, 0);
          }

          else
          {
            id v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v63 + 96), v22);
            int v25 = _NRLogIsLevelEnabled(v24, 17LL);

            if (v25)
            {
              id v27 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v63 + 96), v26);
              _NRLogWithArgs(v27, 17LL, "failed to start AS client");
            }

            sub_1000EAAAC(v63);
          }
        }

        else
        {
          id v28 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v15);
          int v29 = _NRLogIsLevelEnabled(v28, 2LL);

          if (v29)
          {
            uint64_t v31 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v30);
            _NRLogWithArgs( v31,  2LL,  "%s%.30s:%-4d waiting on peer IDS device ID to complete ASClient registration",  "",  "-[NRDDeviceConductor registerASClientIfNeeded]",  8670);
          }

          objc_initWeak(location, (id)a1);
          id v32 = *(id *)(a1 + 96);
          v64[0] = _NSConcreteStackBlock;
          v64[1] = 3221225472LL;
          v64[2] = sub_1000EA954;
          v64[3] = &unk_1001AF678;
          objc_copyWeak(&v65, location);
          sub_100135424((uint64_t)&OBJC_CLASS___NRDLocalDevice, v32, v64);

          objc_destroyWeak(&v65);
          objc_destroyWeak(location);
        }

        goto LABEL_24;
      }

      id v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v3);
      int v8 = _NRLogIsLevelEnabled(v7, 2LL);

      if (v8)
      {
        id v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v9);
        _NRLogWithArgs(v10, 2LL, "%s%.30s:%-4d ignoring ASClient registration for unsupported peer");
LABEL_23:
      }

void sub_1000EA930(_Unwind_Exception *a1)
{
}

void sub_1000EA954(uint64_t a1, void *a2)
{
  uint64_t v20 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v4 = WeakRetained;
  if (WeakRetained && *((_BYTE *)WeakRetained + 13))
  {
    id v5 = *((id *)WeakRetained + 12);
    BOOL v6 = v20 ? (void *)v20[4] : 0LL;
    id v7 = v6;
    unsigned int v8 = [v5 isEqual:v7];

    if (v8)
    {
      if (v20) {
        uint64_t v9 = (void *)v20[6];
      }
      else {
        uint64_t v9 = 0LL;
      }
      id v10 = v9;

      uint64_t v12 = _NRCopyLogObjectForNRUUID(v4[12], v11);
      uint64_t v13 = (void *)v12;
      if (v10)
      {
        int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 0LL);

        if (IsLevelEnabled)
        {
          uint64_t v16 = (void *)_NRCopyLogObjectForNRUUID(v4[12], v15);
          _NRLogWithArgs( v16,  0LL,  "%s%.30s:%-4d received peer IDS device ID. Registering ASClient",  "",  "-[NRDDeviceConductor registerASClientIfNeeded]_block_invoke",  8682);
        }

        sub_1000EA2AC(v4);
      }

      else
      {
        int v17 = _NRLogIsLevelEnabled(v12, 17LL);

        if (v17)
        {
          id v19 = (void *)_NRCopyLogObjectForNRUUID(v4[12], v18);
          _NRLogWithArgs(v19, 17LL, "no IDS device ID");
        }
      }
    }
  }
}

void sub_1000EAAAC(uint64_t a1)
{
}

void sub_1000EAAB8(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 48))
  {
    id v7 = (id)objc_claimAutoreleasedReturnValue( +[NSDistributedNotificationCenter defaultCenter]( &OBJC_CLASS___NSDistributedNotificationCenter,  "defaultCenter"));
    [v7 removeObserver:a1 name:@"com.apple.LaunchServices.applicationRegistered" object:0];
    [v7 removeObserver:a1 name:@"com.apple.LaunchServices.applicationStateChanged" object:0];
    [v7 removeObserver:a1 name:@"com.apple.LaunchServices.applicationUnregistered" object:0];
    *(_BYTE *)(a1 + 4_Block_object_dispose(va, 8) = 0;
    uint64_t v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0LL);

    if (IsLevelEnabled)
    {
      BOOL v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v5);
      _NRLogWithArgs( v6,  0LL,  "%s%.30s:%-4d stopped monitoring LS events",  "",  "-[NRDDeviceConductor stopMonitoringLSAppEvents]",  4038);
    }
  }

uint64_t sub_1000EABBC(uint64_t a1, void *a2)
{
  id v3 = a2;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  id v4 = *(id *)(a1 + 32);
  id v5 = [v4 countByEnumeratingWithState:&v16 objects:v20 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v17;
LABEL_3:
    uint64_t v8 = 0LL;
    while (1)
    {
      if (*(void *)v17 != v7) {
        objc_enumerationMutation(v4);
      }
      uint64_t v9 = *(void *)(*((void *)&v16 + 1) + 8 * v8);
      id v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "entitlements", (void)v16));
      id v11 = [v10 objectForKey:v9 ofClass:objc_opt_class(NSObject)];
      uint64_t v12 = objc_claimAutoreleasedReturnValue(v11);

      if (!v12) {
        break;
      }
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectForKeyedSubscript:v9]);
      if (([(id)v12 isEqual:v13] & 1) == 0)
      {
        uint64_t v14 = objc_opt_class(&OBJC_CLASS___NSArray);
        if ((objc_opt_isKindOfClass(v12, v14) & 1) == 0
          || ([(id)v12 containsObject:v13] & 1) == 0)
        {

          uint64_t v12 = 0LL;
          break;
        }
      }

      if (v6 == (id)++v8)
      {
        id v6 = [v4 countByEnumeratingWithState:&v16 objects:v20 count:16];
        uint64_t v12 = 1LL;
        if (v6) {
          goto LABEL_3;
        }
        break;
      }
    }
  }

  else
  {
    uint64_t v12 = 1LL;
  }

  return v12;
}

void sub_1000EAD7C(void **a1)
{
  id WeakRetained = objc_loadWeakRetained(a1 + 5);
  if (WeakRetained && WeakRetained[13])
  {
    uint64_t v9 = WeakRetained;
    id v4 = objc_loadWeakRetained(a1 + 6);
    if (v4)
    {
      id v5 = (void *)_NRCopyLogObjectForNRUUID(v9[12], v3);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 1LL);

      if (IsLevelEnabled)
      {
        uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(v9[12], v7);
        _NRLogWithArgs( v8,  1LL,  "%s%.30s:%-4d tokens needed",  "",  "-[NRDDeviceConductor updateProxyCriteriaPoliciesIfNeeded]_block_invoke_2",  4369);
      }

      sub_1000EAEF8(v4, a1[4]);
    }

    id WeakRetained = v9;
  }
}

void sub_1000EAE48(uint64_t a1, uint64_t a2, int a3)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    if (a3)
    {
      if (*((_BYTE *)WeakRetained + 13))
      {
        id v10 = WeakRetained;
        id v6 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 12), v5);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 16LL);

        id WeakRetained = v10;
        if (IsLevelEnabled)
        {
          uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v10 + 12), v8);
          _NRLogWithArgs( v9,  16LL,  "%s%.30s:%-4d token agent received error %d",  "",  "-[NRDDeviceConductor updateProxyCriteriaPoliciesIfNeeded]_block_invoke_3",  4378,  a3);

          id WeakRetained = v10;
        }
      }
    }
  }
}

void sub_1000EAEF8(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  ((void (*)(void))nw_agent_add_token)();
  nw_agent_add_token(v4, v3);
  nw_agent_add_token(v4, v3);
  nw_agent_add_token(v4, v3);
  nw_agent_add_token(v4, v3);
  nw_agent_add_token(v4, v3);
  nw_agent_add_token(v4, v3);
  nw_agent_add_token(v4, v3);
  nw_agent_add_token(v4, v3);
  nw_agent_add_token(v4, v3);
  nw_agent_add_token(v4, v3);
  nw_agent_add_token(v4, v3);
  nw_agent_add_token(v4, v3);
  nw_agent_add_token(v4, v3);
  nw_agent_add_token(v4, v3);
}

void sub_1000EAFE4(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 48))
  {
    id v7 = (id)objc_claimAutoreleasedReturnValue( +[NSDistributedNotificationCenter defaultCenter]( &OBJC_CLASS___NSDistributedNotificationCenter,  "defaultCenter"));
    [v7 addObserver:a1 selector:"processAppStateChanged:" name:@"com.apple.LaunchServices.applicationRegistered" object:0];
    [v7 addObserver:a1 selector:"processAppStateChanged:" name:@"com.apple.LaunchServices.applicationStateChanged" object:0];
    [v7 addObserver:a1 selector:"processAppStateChanged:" name:@"com.apple.LaunchServices.applicationUnregistered" object:0];
    *(_BYTE *)(a1 + 4_Block_object_dispose(va, 8) = 1;
    id v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0LL);

    if (IsLevelEnabled)
    {
      id v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v5);
      _NRLogWithArgs( v6,  0LL,  "%s%.30s:%-4d started monitoring for LS events",  "",  "-[NRDDeviceConductor startMonitoringLSAppEvents]",  4062);
    }
  }

void sub_1000EB100(id a1)
{
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v1 = (id)qword_1001DC870;
  sub_1000A2170((uint64_t)v1);
}

void sub_1000EB164(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 37) && !*(_BYTE *)(a1 + 45))
  {
    uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
    id v3 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v3);

    __int128 v74 = xmmword_100156950;
    id v4 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v74, 16LL);
    id v5 = sub_10012D958((uint64_t)&OBJC_CLASS___NRDLocalDevice, v4, @"0");
    id v6 = (void *)objc_claimAutoreleasedReturnValue(v5);

    id v7 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:",  v6,  64LL));
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition ipProtocol:](&OBJC_CLASS___NEPolicyCondition, "ipProtocol:", 58LL));
    v79[0] = v7;
    v79[1] = v8;
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
    v79[2] = v9;
    id v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v79, 3LL));

    id v11 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 220LL));
    id v12 = [[NEPolicy alloc] initWithOrder:200 result:v11 conditions:v10];
    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    id v73 = v2;
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v13 = (id)qword_1001DCB58;
    id v14 = sub_100120E44((uint64_t)v13, *(void **)(a1 + 272), v12);
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(v14);

    -[NSMutableArray addObject:](v73, "addObject:", v15);
    objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
    __int128 v16 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v16);

    __int128 v74 = xmmword_100156950;
    __int128 v17 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v74, 16LL);
    id v18 = sub_10012D958((uint64_t)&OBJC_CLASS___NRDLocalDevice, v17, @"0");
    __int128 v19 = (void *)objc_claimAutoreleasedReturnValue(v18);

    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:",  v19,  64LL));
    id v21 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition platformBinary](&OBJC_CLASS___NEPolicyCondition, "platformBinary"));
    v78[0] = v20;
    v78[1] = v21;
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
    v78[2] = v22;
    id v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v78, 3LL));

    id v24 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 220LL));
    id v25 = [[NEPolicy alloc] initWithOrder:200 result:v24 conditions:v23];
    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v26 = (id)qword_1001DCB58;
    id v27 = sub_100120E44((uint64_t)v26, *(void **)(a1 + 272), v25);
    id v28 = (void *)objc_claimAutoreleasedReturnValue(v27);

    -[NSMutableArray addObject:](v73, "addObject:", v28);
    int v29 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition requiredAgentDomain:agentType:]( &OBJC_CLASS___NEPolicyCondition,  "requiredAgentDomain:agentType:",  @"com.apple.networkrelay",  @"ASListener"));
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition platformBinary](&OBJC_CLASS___NEPolicyCondition, "platformBinary"));
    v77[0] = v29;
    v77[1] = v30;
    uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
    void v77[2] = v31;
    id v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v77, 3LL));

    uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 220LL));
    id v34 = [[NEPolicy alloc] initWithOrder:200 result:v33 conditions:v32];
    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v35 = (id)qword_1001DCB58;
    id v36 = sub_100120E44((uint64_t)v35, *(void **)(a1 + 272), v34);
    uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue(v36);

    -[NSMutableArray addObject:](v73, "addObject:", v37);
    uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition requiredAgentDomain:agentType:]( &OBJC_CLASS___NEPolicyCondition,  "requiredAgentDomain:agentType:",  @"com.apple.networkrelay",  @"ASResolver"));
    __int128 v39 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition platformBinary](&OBJC_CLASS___NEPolicyCondition, "platformBinary"));
    v76[0] = v38;
    v76[1] = v39;
    uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
    v76[2] = v40;
    __int128 v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v76, 3LL));

    __int128 v42 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 220LL));
    id v43 = [[NEPolicy alloc] initWithOrder:200 result:v42 conditions:v41];
    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v44 = (id)qword_1001DCB58;
    id v45 = sub_100120E44((uint64_t)v44, *(void **)(a1 + 272), v43);
    __int128 v46 = (void *)objc_claimAutoreleasedReturnValue(v45);

    -[NSMutableArray addObject:](v73, "addObject:", v46);
    uint64_t v47 = -[NSUUID initWithUUIDString:]( objc_alloc(&OBJC_CLASS___NSUUID),  "initWithUUIDString:",  @"4946eeba-8277-69b4-e898-d635c8fde872");
    uint64_t v75 = v47;
    __int128 v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v75, 1LL));
    sub_1000EB9C0(a1, v48, v73, @"4946eeba-8277-69b4-e898-d635c8fde872");

    if (_NRIsAppleInternal(v49))
    {
      id v50 = sub_10010172C(@"com.apple.Home");
      id v51 = [v50 count];
      uint64_t v53 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v52);
      __int128 v54 = (void *)v53;
      if (v51)
      {
        int IsLevelEnabled = _NRLogIsLevelEnabled(v53, 0LL);

        if (IsLevelEnabled)
        {
          __int128 v57 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v56);
          __int128 v72 = "";
          _NRLogWithArgs(v57, 0LL, "%s%.30s:%-4d UUIDs for '%s': %@");
        }

        sub_1000EB9C0(a1, v50, v73, @"com.apple.Home");
      }

      else
      {
        int v58 = _NRLogIsLevelEnabled(v53, 16LL);

        if (v58)
        {
          uint64_t v60 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v59);
          _NRLogWithArgs( v60,  16LL,  "%s%.30s:%-4d Failed to retrieve UUIDs for '%s' (may not be installed)",  "",  "-[NRDDeviceConductor setPermittedClientPolicies]",  3412,  "com.apple.Home");
        }
      }
    }

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v61 = (id)qword_1001DCB58;
    uint64_t v62 = (id *)v61;
    if (v61)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v61 + 1));
      if (([v62[2] apply] & 1) == 0) {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v63,  v64,  v65,  (uint64_t)v72);
      }
    }

    uint64_t v66 = *(void *)(a1 + 240);
    *(_BYTE *)(a1 + 37) = 1;
    -[NSMutableArray addObjectsFromArray:](v73, "addObjectsFromArray:", v66);
    objc_storeStrong((id *)(a1 + 240), v73);
    uint64_t v68 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v67);
    int v69 = _NRLogIsLevelEnabled(v68, 0LL);

    if (v69)
    {
      __int128 v71 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v70);
      _NRLogWithArgs( v71,  0LL,  "%s%.30s:%-4d Added permitted client policies",  "",  "-[NRDDeviceConductor setPermittedClientPolicies]",  3427);
    }
  }

void sub_1000EB9C0(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v6 = a2;
  id v27 = a3;
  id v24 = a4;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  id obj = v6;
  id v7 = [obj countByEnumeratingWithState:&v28 objects:v33 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v29;
    do
    {
      id v10 = 0LL;
      do
      {
        if (*(void *)v29 != v9) {
          objc_enumerationMutation(obj);
        }
        id v11 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition effectiveApplication:]( &OBJC_CLASS___NEPolicyCondition,  "effectiveApplication:",  *(void *)(*((void *)&v28 + 1) + 8LL * (void)v10)));
        id v12 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
        v32[0] = v12;
        v32[1] = v11;
        id v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v32, 2LL));

        id v14 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 220LL));
        id v16 = [[NEPolicy alloc] initWithOrder:200 result:v14 conditions:v13];
        if (v16)
        {
          objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
          if (qword_1001DCB60 != -1) {
            dispatch_once(&qword_1001DCB60, &stru_1001B0538);
          }
          id v17 = (id)qword_1001DCB58;
          id v18 = sub_100120E44((uint64_t)v17, *(void **)(a1 + 272), v16);
          __int128 v19 = (void *)objc_claimAutoreleasedReturnValue(v18);

          [v27 addObject:v19];
          goto LABEL_10;
        }

        uint64_t v20 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v15);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v20, 17LL);

        if (IsLevelEnabled)
        {
          __int128 v19 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v22);
          _NRLogWithArgs(v19, 17LL, "Failed to create effective application policy for %@", v24);
LABEL_10:
        }

        if (!v16) {
          goto LABEL_17;
        }
        id v10 = (char *)v10 + 1;
      }

      while (v8 != v10);
      id v23 = [obj countByEnumeratingWithState:&v28 objects:v33 count:16];
      id v8 = v23;
    }

    while (v23);
  }

void sub_1000EBC48(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v3);
  if (!v4)
  {
    id v25 = sub_1000D54AC();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v25, 16LL);

    if (IsLevelEnabled)
    {
      id v27 = sub_1000D54AC();
      _NRLogWithArgs( v27,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: localDevice",  "",  "-[NRDDeviceConductor updateProxyAgentForNRUUID:]",  7980);
    }

    uint64_t v28 = _os_log_pack_size(12LL);
    __int128 v29 = (char *)&v33 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    __int128 v30 = __error();
    uint64_t v31 = _os_log_pack_fill( v29,  v28,  *v30,  &_mh_execute_header,  "%{public}s Assertion Failed: localDevice");
    *(_DWORD *)uint64_t v31 = 136446210;
    *(void *)(v31 + 4) = "-[NRDDeviceConductor updateProxyAgentForNRUUID:]";
    id v32 = sub_1000D54AC();
    _NRLogAbortWithPack(v32, v29);
  }

  id v5 = (id *)v4;
  if (sub_100107FE8(v4))
  {
    id v6 = v5[16];
    unsigned __int8 v7 = [v6 hasPoliciesForProxyCriteria];

    if ((v7 & 1) == 0)
    {
      id v8 = (id *)(a1 + 456);
      id v9 = *(id *)(a1 + 456);
      if (!v9) {
        goto LABEL_7;
      }
      id v10 = v9;
      id v11 = *v8;
      id v12 = v5[12];
      if (v11 == v12)
      {

        goto LABEL_14;
      }

      id v13 = v12;
      id v14 = *v8;
      id v15 = v5[12];
      unsigned __int8 v16 = [v14 isEqual:v15];

      if ((v16 & 1) == 0)
      {
LABEL_7:
        sub_1000EBF5C(a1);
        objc_storeStrong((id *)(a1 + 456), v5[12]);
        if (*(void *)(a1 + 456))
        {
          id v34 = 0LL;
          id v35 = 0LL;
          id v33 = 0LL;
          id v17 = (void *)NEVirtualInterfaceCopyName(*(void *)(a1 + 448));
          id v18 = *(id *)(a1 + 456);
          __int128 v19 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 description]);
          char v20 = sub_10010961C(v5, v18, v17, &v34, &v35, &v33, v19);

          if ((v20 & 1) != 0)
          {
            id v21 = v34;
            objc_storeStrong((id *)(a1 + 464), v34);
            id v22 = v35;
            objc_storeStrong((id *)(a1 + 472), v35);
            objc_storeStrong((id *)(a1 + 480), v33);
            if (*(void *)(a1 + 480)) {
              id v23 = sub_10010AA54(v22, v17, *(void **)(a1 + 544));
            }
          }

          else
          {
            id v24 = *(void **)(a1 + 456);
            *(void *)(a1 + 456) = 0LL;

            id v21 = v34;
            objc_storeStrong((id *)(a1 + 464), v34);
            id v22 = v35;
            objc_storeStrong((id *)(a1 + 472), v35);
            objc_storeStrong((id *)(a1 + 480), v33);
          }
        }
      }
    }
  }

void sub_1000EBF5C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 464);
  if (v2)
  {
    [v2 unregisterNetworkAgent];
    id v3 = *(void **)(a1 + 464);
    *(void *)(a1 + 464) = 0LL;
  }

  if (*(void *)(a1 + 480))
  {
    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v4 = (id)qword_1001DCB58;
    sub_10012114C((uint64_t)v4, *(void **)(a1 + 544));

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v5 = (id)qword_1001DCB58;
    id v6 = (id *)v5;
    if (v5)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v5 + 1));
      if (([v6[2] apply] & 1) == 0) {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v7,  v8,  v9,  v13);
      }
    }

    nw_proxy_config_unpublish(*(void *)(a1 + 480));
    id v10 = *(void **)(a1 + 480);
    *(void *)(a1 + 480) = 0LL;

    if (qword_1001DC8F0 != -1) {
      dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC8E8, 2LL))
    {
      if (qword_1001DC8F0 != -1) {
        dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
      }
      _NRLogWithArgs( qword_1001DC8E8,  2LL,  "%s%.30s:%-4d unregistered MASQUE proxy agent",  "",  "-[NRDDeviceConductor unregisterProxyAgent]",  7959);
    }
  }

  id v11 = *(void **)(a1 + 456);
  *(void *)(a1 + 456) = 0LL;

  id v12 = *(void **)(a1 + 472);
  *(void *)(a1 + 472) = 0LL;
}

void sub_1000EC130(uint64_t a1)
{
  if (*(void *)(a1 + 448))
  {
    sub_1000EBF5C(a1);
    sub_1000E3750(a1);
    id v9 = (id)NEVirtualInterfaceCopyName(*(void *)(a1 + 448));
    NEVirtualInterfaceInvalidate(*(void *)(a1 + 448), v2);
    id v4 = *(const void **)(a1 + 448);
    if (v4) {
      CFRelease(v4);
    }
    *(void *)(a1 + 44_Block_object_dispose(va, 8) = 0LL;
    *(_BYTE *)(a1 + 57) = 0;
    id v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v3);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v7);
      _NRLogWithArgs( v8,  0LL,  "%s%.30s:%-4d Removed catch-all interface (%@)",  "",  "-[NRDDeviceConductor removeCatchAllInterface]",  7808LL,  v9);
    }
  }

void sub_1000EC214(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3) {
    uint64_t v4 = *(void *)(v3 + 96);
  }
  else {
    uint64_t v4 = 0LL;
  }
  id v5 = (void *)_NRCopyLogObjectForNRUUID(v4, a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

  if (IsLevelEnabled)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      uint64_t v9 = *(void *)(v8 + 96);
    }
    else {
      uint64_t v9 = 0LL;
    }
    uint64_t v10 = _NRCopyLogObjectForNRUUID(v9, v7);
    id v12 = (id)v10;
    if (*(_BYTE *)(a1 + 40)) {
      id v11 = "enable";
    }
    else {
      id v11 = "disable";
    }
    _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d Re-sent prefer wi-fi: %s",  "",  "-[NRDDeviceConductor linkIsAvailable:]_block_invoke",  5478,  v11);
  }

void sub_1000EC2EC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 && *(_BYTE *)(v2 + 13))
  {
    *(_BYTE *)(v2 + 50) = 0;
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4) {
      uint64_t v5 = *(void *)(v4 + 96);
    }
    else {
      uint64_t v5 = 0LL;
    }
    id v6 = (void *)_NRCopyLogObjectForNRUUID(v5, a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v8 = *(void **)(a1 + 32);
      if (v8) {
        uint64_t v8 = (void *)v8[12];
      }
      uint64_t v9 = v8;
      uint64_t v11 = _NRCopyLogObjectForNRUUID(v9, v10);
      id v12 = (void *)v11;
      uint64_t v13 = *(void *)(a1 + 32);
      if (v13)
      {
        int v14 = *(unsigned __int8 *)(v13 + 14);
        LODWORD(v13) = *(unsigned __int8 *)(v13 + 25);
      }

      else
      {
        int v14 = 0;
      }

      _NRLogWithArgs( v11,  0LL,  "%s%.30s:%-4d attempting to send request %d %d ",  "",  "-[NRDDeviceConductor linkIsAvailable:]_block_invoke_2",  5549,  v14,  v13);
    }

    uint64_t v15 = *(void *)(a1 + 32);
    if (v15 && (*(_BYTE *)(v15 + 14) || *(_BYTE *)(v15 + 25)))
    {
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(v15 + 104));
      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      id v16 = (id)qword_1001DC870;
      id v17 = v16;
      if (v16) {
        id v18 = (void *)*((void *)v16 + 6);
      }
      else {
        id v18 = 0LL;
      }
      __int128 v19 = v18;

      if (v19) {
        char v20 = (void *)v19[7];
      }
      else {
        char v20 = 0LL;
      }
      id v21 = v20;

      if (v21) {
        goto LABEL_21;
      }
      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      id v23 = (id)qword_1001DC870;
      id v24 = v23;
      id v25 = v23 ? (void *)*((void *)v23 + 12) : 0LL;
      id v26 = v25;
      int v27 = sub_100061098((uint64_t)v26, 0LL);

      if (v27)
      {
        id v28 = sub_1000D8B90(*(void *)(a1 + 32), 2, 102);
        if (v28)
        {
          __int128 v29 = v28;
          unsigned int v30 = [v28 state];

          if (v30 != 255)
          {
LABEL_21:
            uint64_t v22 = *(void *)(a1 + 32);
            v31[0] = _NSConcreteStackBlock;
            v31[1] = 3221225472LL;
            v31[2] = sub_1000EC564;
            v31[3] = &unk_1001B0A88;
            v31[4] = v22;
            sub_1000D79D4(v22, 1, 1, 0, 0, v31);
          }
        }
      }
    }
  }

uint64_t sub_1000EC564(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (v1) {
    *(_BYTE *)(v1 + 25) = 0;
  }
  return result;
}

void *sub_1000EC574(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*((_BYTE *)result + 11))
    {
      uint64_t v2 = (void *)result[26];
      if (v2) {
        return [v2 trackNOIAnyForInterfaceType:1 options:0];
      }
      uint64_t v3 = objc_alloc_init(&OBJC_CLASS___NWNetworkOfInterestManager);
      uint64_t v4 = (void *)v1[26];
      v1[26] = v3;

      uint64_t v5 = (void *)v1[26];
      if (v5)
      {
        uint64_t v6 = v1[13];
        id v7 = v5;
        [v7 setQueue:v6];

        [(id)v1[26] setDelegate:v1];
        uint64_t v2 = (void *)v1[26];
        return [v2 trackNOIAnyForInterfaceType:1 options:0];
      }

      if (qword_1001DC8F0 != -1) {
        dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
      }
      id result = (void *)_NRLogIsLevelEnabled(qword_1001DC8E8, 17LL);
      if ((_DWORD)result)
      {
        if (qword_1001DC8F0 != -1) {
          dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
        }
        return (void *)_NRLogWithArgs(qword_1001DC8E8, 17LL, "[[NWNetworkOfInterestManager alloc] init] failed");
      }
    }
  }

  return result;
}

void sub_1000EC68C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    uint64_t v7 = objc_opt_class(&OBJC_CLASS___NRDNSProxyServer);
    if ((objc_opt_isKindOfClass(v5, v7) & 1) != 0
      || (uint64_t v8 = objc_opt_class(&OBJC_CLASS___NRDiscoveryProxyServer), (objc_opt_isKindOfClass(v5, v8) & 1) != 0))
    {
      char v21 = 0;
      if (!v5 || *((_BYTE *)v5 + 8) != 2)
      {
        id v16 = &v21;
        id v17 = v6;
        uint64_t v18 = 1LL;
        uint64_t v19 = 1LL;
        goto LABEL_11;
      }

      char v21 = 1;
      id v9 = *((id *)v5 + 3);
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 port]);
      uint64_t v11 = sub_1001040C8(v9, (unsigned __int16)[v10 intValue], 0);
      id v12 = (void *)objc_claimAutoreleasedReturnValue(v11);

      NRTLVAddData(v6, 2LL);
      int v13 = *((_DWORD *)v5 + 4);
      id v14 = *((id *)v5 + 4);

      if (v14)
      {
        id v15 = *((id *)v5 + 4);
        NRTLVAddData(v6, 4LL);
      }

      NRTLVAdd(v6, 1LL, 1LL, &v21);
      if (v13 == 1)
      {
        uint64_t v20 = 0x200000000000000LL;
        id v16 = (char *)&v20;
        id v17 = v6;
        uint64_t v18 = 3LL;
        uint64_t v19 = 8LL;
LABEL_11:
        NRTLVAdd(v17, v18, v19, v16);
      }
    }
  }
}

void sub_1000EC808(uint64_t a1)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 552), 0LL);
  }
}

void sub_1000EC81C(uint64_t a1)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 576), 0LL);
  }
}

void sub_1000EC830(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 && *(_BYTE *)(v2 + 13) && *(_BYTE *)(v2 + 48))
  {
    uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v2 + 96), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

    if (IsLevelEnabled)
    {
      id v6 = *(void **)(a1 + 32);
      if (v6) {
        id v6 = (void *)v6[12];
      }
      uint64_t v7 = v6;
      id v9 = (void *)_NRCopyLogObjectForNRUUID(v7, v8);
      _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d received notification: %@",  "",  "-[NRDDeviceConductor processAppStateChanged:]_block_invoke",  4071LL,  *(void *)(a1 + 40));
    }

    sub_1000E8470(*(void *)(a1 + 32));
  }

char *sub_1000EC900(char *a1, void *a2, void *a3)
{
  id v7 = a2;
  uint64_t v8 = a3;
  id v9 = v8;
  if (!a1) {
    goto LABEL_19;
  }
  if (!v7)
  {
    id v70 = sub_1000D54AC();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v70, 17LL);

    if (IsLevelEnabled)
    {
      id v72 = sub_1000D54AC();
      _NRLogWithArgs(v72, 17LL, "%s called with null nrUUID");
LABEL_18:

      uint64_t v68 = 0LL;
      goto LABEL_13;
    }

void sub_1000ECF60(id val)
{
  if (!*((_BYTE *)val + 10)
    && (!*((_BYTE *)val + 47) || _os_feature_enabled_impl("terminus", "CompanionLinkAWDL")))
  {
    objc_initWeak(&location, val);
    uint64_t v2 = (void *)*((void *)val + 13);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_1000ED028;
    block[3] = &unk_1001B0798;
    void block[4] = val;
    uint64_t v3 = v2;
    objc_copyWeak(&v5, &location);
    dispatch_async(v3, block);

    objc_destroyWeak(&v5);
    objc_destroyWeak(&location);
  }

void sub_1000ED028(uint64_t a1)
{
  *(_BYTE *)(*(void *)(a1 + 32) + 10LL) = 1;
  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v2 = (id)qword_1001DC870;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_1000ED11C;
  v3[3] = &unk_1001AFED0;
  objc_copyWeak(&v4, (id *)(a1 + 40));
  sub_1000AEA84((uint64_t)v2, v3);

  objc_destroyWeak(&v4);
}

void sub_1000ED108(_Unwind_Exception *a1)
{
}

void sub_1000ED11C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && *((_BYTE *)WeakRetained + 13))
  {
    id v12 = WeakRetained;
    uint64_t v3 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 12), v2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0LL);

    if (IsLevelEnabled)
    {
      id v6 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v12 + 12), v5);
      _NRLogWithArgs( v6,  0LL,  "%s%.30s:%-4d starting AWDL manager",  "",  "-[NRDDeviceConductor setSupportsAWDL:]_block_invoke_2",  376);
    }

    dispatch_assert_queue_V2(*((dispatch_queue_t *)v12 + 13));
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v7 = (id)qword_1001DC870;
    uint64_t v8 = v7;
    if (v7) {
      id v9 = (void *)*((void *)v7 + 6);
    }
    else {
      id v9 = 0LL;
    }
    uint64_t v10 = v9;

    if (v10)
    {
      uint64_t v11 = (dispatch_queue_s *)v10[3];
      dispatch_assert_queue_V2(v11);

      if (!*((_BYTE *)v10 + 36) && *((_DWORD *)v10 + 3) != 1004)
      {
        *((_BYTE *)v10 + 36) = 1;
        sub_100142D28((uint64_t)v10, 1LL);
      }
    }

    id WeakRetained = v12;
  }
}

void sub_1000ED270(uint64_t a1)
{
  uint64_t v2 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 96));
  if (!v2)
  {
    id v72 = sub_1000D54AC();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v72, 16LL);

    if (IsLevelEnabled)
    {
      id v74 = sub_1000D54AC();
      _NRLogWithArgs( v74,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRDDeviceConductor updateOperatingMode]",  386);
    }

    uint64_t v75 = _os_log_pack_size(12LL);
    int v76 = (char *)&v80 - ((v75 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v77 = __error();
    uint64_t v78 = _os_log_pack_fill( v76,  v75,  *v77,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    *(_DWORD *)uint64_t v78 = 136446210;
    *(void *)(v78 + 4) = "-[NRDDeviceConductor updateOperatingMode]";
    id v79 = sub_1000D54AC();
    _NRLogAbortWithPack(v79, v76);
  }

  id v80 = v2;
  id v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v3);
  int v5 = _NRLogIsLevelEnabled(v4, 0LL);

  if (v5)
  {
    id v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v6);
    id v8 = *((id *)v80 + 16);
    _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d starting with operational properties: %@",  "",  "-[NRDDeviceConductor updateOperatingMode]",  388LL,  v8);
  }

  id v9 = *((id *)v80 + 16);

  if (!v9)
  {
    *(_WORD *)(a1 + 53) = 257;
    *(_BYTE *)(a1 + 9) = 1;
    *(_BYTE *)(a1 + 47) = 1;
    *(_BYTE *)(a1 + 55) = *(_BYTE *)(a1 + 45);
    sub_1000ECF60((id)a1);

    return;
  }

  uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v10);
  int v12 = _NRLogIsLevelEnabled(v11, 0LL);

  if (v12)
  {
    id v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v13);
    id v15 = *((id *)v80 + 16);
    _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d retrieved operational properties: %@",  "",  "-[NRDDeviceConductor updateOperatingMode]",  416LL,  v15);
  }

  id v16 = *((id *)v80 + 16);
  if ([v16 proxyCapability] == (id)1)
  {

LABEL_11:
    id v19 = *((id *)v80 + 16);
    id v20 = [v19 proxyCapability];
LABEL_12:
    BOOL v21 = v20 == (id)1;
LABEL_13:
    char v22 = v21;
    *(_BYTE *)(a1 + 56) = v22;
    goto LABEL_17;
  }

  id v17 = *((id *)v80 + 16);
  id v18 = [v17 proxyCapability];

  if (v18 == (id)2) {
    goto LABEL_11;
  }
  id v59 = *((id *)v80 + 16);
  if ([v59 bluetoothRole] == (id)1)
  {

LABEL_72:
    id v19 = *((id *)v80 + 16);
    id v20 = [v19 bluetoothRole];
    goto LABEL_12;
  }

  id v60 = *((id *)v80 + 16);
  id v61 = [v60 bluetoothRole];

  if (v61 == (id)2) {
    goto LABEL_72;
  }
  id v62 = *((id *)v80 + 16);
  if ([v62 bluetoothEndpointType] == (id)2)
  {

LABEL_76:
    id v19 = *((id *)v80 + 16);
    BOOL v21 = [v19 bluetoothEndpointType] == (id)2;
    goto LABEL_13;
  }

  id v63 = *((id *)v80 + 16);
  id v64 = [v63 bluetoothEndpointType];

  if (v64 == (id)1) {
    goto LABEL_76;
  }
  uint64_t v65 = (void *)sub_100136CA4(v80);
  uint64_t v66 = (void *)sub_100136D6C(v80);
  id v67 = [v65 compare:v66];

  if (v67 == (id)-1LL)
  {
    *(_BYTE *)(a1 + 56) = 1;
    goto LABEL_18;
  }

  int v69 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v68);
  int v70 = _NRLogIsLevelEnabled(v69, 17LL);

  id v23 = v80;
  if (v70)
  {
    id v19 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v71);
    _NRLogWithArgs(v19, 17LL, "unable to determine link follower");
LABEL_17:

LABEL_18:
    id v23 = v80;
  }

  *(_BYTE *)(a1 + 47) = sub_1001319A0((BOOL)v23);
  *(_BYTE *)(a1 + 3_Block_object_dispose(va, 8) = sub_1000D5E34(a1);
  id v24 = *((id *)v80 + 16);
  *(_BYTE *)(a1 + 42) = [v24 handlesLinkRecommendations];

  id v25 = *((id *)v80 + 16);
  else {
    BOOL v26 = 0;
  }
  *(_BYTE *)(a1 + 43) = v26;

  id v27 = *((id *)v80 + 16);
  *(_BYTE *)(a1 + 46) = [v27 allowsDirectToCloud];

  id v28 = *((id *)v80 + 16);
  *(_BYTE *)(a1 + 44) = [v28 proxyCapability] == (id)1;

  id v29 = *((id *)v80 + 16);
  *(_BYTE *)(a1 + 45) = [v29 proxyCapability] == (id)2;

  id v30 = *((id *)v80 + 16);
  else {
    BOOL v31 = 0;
  }
  *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = v31;

  *(_BYTE *)(a1 + 55) = *(_BYTE *)(a1 + 45);
  id v32 = *((id *)v80 + 16);
  id v33 = (void *)objc_claimAutoreleasedReturnValue([v32 allowedLinkSubtypes]);
  unsigned int v34 = [v33 containsObject:&off_1001BC6D0];

  if (v34) {
    sub_1000ECF60((id)a1);
  }
  id v35 = *((id *)v80 + 16);
  uint64_t v36 = objc_claimAutoreleasedReturnValue([v35 allowedLinkTypes]);
  if (!v36)
  {

    goto LABEL_31;
  }

  uint64_t v37 = (void *)v36;
  id v38 = *((id *)v80 + 16);
  __int128 v39 = (void *)objc_claimAutoreleasedReturnValue([v38 allowedLinkTypes]);
  unsigned int v40 = [v39 containsObject:&off_1001BC6E8];

  if (v40)
  {
LABEL_31:
    *(_BYTE *)(a1 + 9) = 1;
    *(_BYTE *)(a1 + 53) = 1;
  }

  id v41 = *((id *)v80 + 16);
  unsigned int v42 = [v41 version];

  if (v42)
  {
    id v43 = *((id *)v80 + 16);
    *(_BYTE *)(a1 + 9) = [v43 providesPhoneCallRelaySupport];
  }

  id v44 = *((id *)v80 + 16);
  uint64_t v45 = objc_claimAutoreleasedReturnValue([v44 allowedLinkTypes]);
  if (v45)
  {
    __int128 v46 = (void *)v45;
    id v47 = *((id *)v80 + 16);
    __int128 v48 = (void *)objc_claimAutoreleasedReturnValue([v47 allowedLinkTypes]);
    unsigned int v49 = [v48 containsObject:&off_1001BC700];

    if (!v49) {
      goto LABEL_39;
    }
  }

  else
  {
  }

  *(_BYTE *)(a1 + 54) = 1;
LABEL_39:
  objc_opt_self(&OBJC_CLASS___NRLinkManagerQuickRelay);
  if (!objc_opt_class(&OBJC_CLASS___IDSService) || !objc_opt_class(&OBJC_CLASS___APSConnection)) {
    *(_BYTE *)(a1 + 54) = 0;
  }
  if (*(_BYTE *)(a1 + 45))
  {
    id v50 = *((id *)v80 + 16);
    if ([v50 requiresReachability])
    {
      int v51 = *(unsigned __int8 *)(a1 + 47);

      if (!v51) {
        *(_BYTE *)(a1 + 59) = 1;
      }
    }

    else
    {
    }
  }

  sub_1000E44D4(a1);
  if (objc_opt_class(&OBJC_CLASS___NWNetworkOfInterestManager) && *(_BYTE *)(a1 + 47))
  {
    int v52 = *(unsigned __int8 *)(a1 + 45);
    *(_BYTE *)(a1 + 11) = v52;
    if (v52) {
      char v53 = _os_feature_enabled_impl("terminus", "CompanionLinkAutoUpgrade");
    }
    else {
      char v53 = 0;
    }
  }

  else
  {
    char v53 = 0;
    *(_BYTE *)(a1 + 11) = 0;
  }

  *(_BYTE *)(a1 + 12) = v53;
  if (*(_BYTE *)(a1 + 47)) {
    char v54 = _os_feature_enabled_impl("terminus", "DiscoveryProxy");
  }
  else {
    char v54 = 0;
  }
  *(_BYTE *)(a1 + 61) = v54;
  __int128 v55 = v80;
  if (v80[15])
  {
    char v56 = 1;
    if (v80[12])
    {
LABEL_57:
      char v57 = v56 ^ 1;
      if (!v80[13]) {
        char v57 = 1;
      }
      goto LABEL_67;
    }
  }

  else
  {
    if (v80[14]) {
      BOOL v58 = 1;
    }
    else {
      BOOL v58 = *((unsigned __int16 *)v80 + 14) > 0x12u;
    }
    char v56 = v58;
    if (v80[12]) {
      goto LABEL_57;
    }
  }

  char v57 = 1;
LABEL_67:
  *(_BYTE *)(a1 + 6_Block_object_dispose(va, 8) = v57;
}

void sub_1000EDA50(uint64_t a1)
{
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v2 = (id)qword_1001DC870;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_1000EEB5C;
  v4[3] = &unk_1001B0720;
  uint64_t v3 = *(void **)(a1 + 40);
  v4[4] = *(void *)(a1 + 32);
  id v5 = v3;
  sub_1000AEA84((uint64_t)v2, v4);
}

void sub_1000EDB0C(uint64_t a1)
{
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v2 = (id)qword_1001DC870;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  v4[2] = sub_1000EE9F0;
  v4[3] = &unk_1001B0720;
  uint64_t v3 = *(void **)(a1 + 40);
  v4[4] = *(void *)(a1 + 32);
  id v5 = v3;
  sub_1000AEA84((uint64_t)v2, v4);
}

void sub_1000EDBC8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1 && *(_BYTE *)(v1 + 13))
  {
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    uint64_t v3 = (unsigned __int8 *)(id)qword_1001DC870;
    if (v3)
    {
      int v4 = v3[8];

      if (v4)
      {
        objc_opt_self(&OBJC_CLASS___NRLinkDirector);
        if (qword_1001DC878 != -1) {
          dispatch_once(&qword_1001DC878, &stru_1001AEED0);
        }
        id v5 = (id)qword_1001DC870;
        uint64_t v6 = v5;
        if (v5) {
          id v7 = (void *)*((void *)v5 + 9);
        }
        else {
          id v7 = 0LL;
        }
        id v8 = v7;

        objc_opt_self(&OBJC_CLASS___NRLinkDirector);
        if (qword_1001DC878 != -1) {
          dispatch_once(&qword_1001DC878, &stru_1001AEED0);
        }
        id v9 = (id)qword_1001DC870;
        uint64_t v10 = v9;
        if (v9) {
          uint64_t v11 = (void *)*((void *)v9 + 10);
        }
        else {
          uint64_t v11 = 0LL;
        }
        id v12 = v11;

        if (v8 && v12)
        {
          objc_opt_self(&OBJC_CLASS___NRLinkDirector);
          if (qword_1001DC878 != -1) {
            dispatch_once(&qword_1001DC878, &stru_1001AEED0);
          }
          id v13 = (id)qword_1001DC870;
          id v14 = v13;
          if (v13) {
            id v15 = (void *)*((void *)v13 + 8);
          }
          else {
            id v15 = 0LL;
          }
          id v16 = v15;
          id v17 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v12,  @"0"));
          id v62 = v17;
          id v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v62,  1LL));
          uint64_t v19 = *(void *)(a1 + 32);
          if (v19) {
            id v20 = *(void **)(v19 + 96);
          }
          else {
            id v20 = 0LL;
          }
          sub_1000C986C((uint64_t)v16, v18, v8, v20);
        }
      }
    }

    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v21 = (id)qword_1001DC870;
    v48[0] = _NSConcreteStackBlock;
    v48[1] = 3221225472LL;
    v48[2] = sub_1000EE29C;
    v48[3] = &unk_1001B0A88;
    v48[4] = *(void *)(a1 + 32);
    sub_1000AEA84((uint64_t)v21, v48);

    uint64_t v22 = *(void *)(a1 + 32);
    if (v22 && *(_BYTE *)(v22 + 44) && *(_BYTE *)(v22 + 47) && !*(void *)(v22 + 488))
    {
      id v23 = sub_100014E8C(objc_alloc(&OBJC_CLASS___NRNetInfo), *(void **)(v22 + 104));
      objc_initWeak(&location, (id)v22);
      objc_initWeak(&from, v23);
      v49[0] = _NSConcreteStackBlock;
      v49[1] = 3221225472LL;
      v49[2] = sub_1000EE960;
      v49[3] = &unk_1001AF450;
      objc_copyWeak(&v50, &location);
      objc_copyWeak(&v51, &from);
      id v24 = v49;
      id v25 = v24;
      if (v23)
      {
        dispatch_assert_queue_V2(*((dispatch_queue_t *)v23 + 6));
        if (!v23[10])
        {
          id v26 = objc_retainBlock(v25);
          id v27 = (void *)*((void *)v23 + 7);
          *((void *)v23 + 7) = v26;
        }

        dispatch_assert_queue_V2(*((dispatch_queue_t *)v23 + 6));
        if (!v23[10])
        {
          objc_initWeak(&v61, v23);
          id obj = (id)nw_path_create_evaluator_for_endpoint(0LL, 0LL);
          id v28 = *((id *)v23 + 6);
          newValue = _NSConcreteStackBlock;
          uint64_t v55 = 3221225472LL;
          char v56 = sub_100015EF0;
          char v57 = &unk_1001AE1D8;
          objc_copyWeak(&v60, &v61);
          id v29 = (void **)obj;
          BOOL v58 = v29;
          id v59 = v23;
          nw_path_evaluator_set_update_handler();

          nw_path_evaluator_start(v29);
          if (qword_1001DC690 != -1) {
            dispatch_once(&qword_1001DC690, &stru_1001AE298);
          }
          id v30 = (id)qword_1001DC688;
          char IsLevelEnabled = _NRLogIsLevelEnabled(v30, 0LL);

          if ((IsLevelEnabled & 1) != 0)
          {
            if (qword_1001DC690 != -1) {
              dispatch_once(&qword_1001DC690, &stru_1001AE298);
            }
            id v32 = (id)qword_1001DC688;
            _NRLogWithArgs(v32, 0LL, "%s%.30s:%-4d started evaluator: %@", "", "-[NRNetInfo start]", 170LL, v29);
          }

          objc_storeStrong((id *)v23 + 9, obj);
          sub_100016400((uint64_t)v23);

          objc_destroyWeak(&v60);
          objc_destroyWeak(&v61);
        }
      }

      else
      {
      }

      id v33 = *(void **)(v22 + 488);
      *(void *)(v22 + 48_Block_object_dispose(va, 8) = v23;

      objc_destroyWeak(&v51);
      objc_destroyWeak(&v50);
      objc_destroyWeak(&from);
      objc_destroyWeak(&location);
      uint64_t v22 = *(void *)(a1 + 32);
    }

    sub_1000EA2AC(v22);
    unsigned int v34 = *(void ***)(a1 + 32);
    if (v34 && sub_1000D5FC0((uint64_t)v34))
    {
      id v35 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v34[12]);
      uint64_t v36 = v35;
      if (v35) {
        uint64_t v37 = (void *)*((void *)v35 + 16);
      }
      else {
        uint64_t v37 = 0LL;
      }
      id v38 = v37;
      id v39 = [v38 activeOperationalScope];

      unsigned int v40 = objc_alloc_init(&OBJC_CLASS___NRLinkDirectorRequest);
      p_Class isa = (id *)&v40->super.isa;
      if (v40)
      {
        uint64_t v42 = 2LL;
        if (!v39) {
          uint64_t v42 = 10LL;
        }
        v40->_type = 6;
        *(_WORD *)&v40->_attemptImmediately = 1;
        v40->_timeout = v42;
        objc_storeStrong((id *)&v40->_timerDescription, @"start-device-discovery");
      }

      if (v36) {
        id v43 = (void *)*((void *)v36 + 16);
      }
      else {
        id v43 = 0LL;
      }
      id v44 = v43;
      uint64_t v45 = (void *)objc_claimAutoreleasedReturnValue([v44 allowedLinkTypes]);
      if (p_isa) {
        objc_storeStrong(p_isa + 2, v45);
      }

      newValue = _NSConcreteStackBlock;
      uint64_t v55 = 3221225472LL;
      char v56 = sub_1000EE948;
      char v57 = &unk_1001B0A88;
      BOOL v58 = v34;
      if (p_isa) {
        objc_setProperty_nonatomic_copy(p_isa, v46, &newValue, 48LL);
      }
      sub_1000D312C((uint64_t)v34, p_isa);
    }
  }

void sub_1000EE234( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id *location, uint64_t a15, id *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, id a28, id a29)
{
}

void sub_1000EE29C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1 && *(_BYTE *)(v1 + 13))
  {
    id v2 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(v1 + 96));
    uint64_t v3 = v2;
    if (!v2) {
      goto LABEL_67;
    }
    id v4 = *((id *)v2 + 16);

    if (!v4 || !v3[9]) {
      goto LABEL_67;
    }
    if (v3[15])
    {
      char v5 = 1;
      if (!v3[12]) {
        goto LABEL_19;
      }
    }

    else
    {
      if (v3[14]) {
        BOOL v6 = 1;
      }
      else {
        BOOL v6 = *((unsigned __int16 *)v3 + 14) > 0x12u;
      }
      char v5 = v6;
      if (!v3[12]) {
        goto LABEL_19;
      }
    }

    if (!v3[13]) {
      char v5 = 0;
    }
    if ((v5 & 1) != 0) {
      goto LABEL_67;
    }
LABEL_19:
    if (sub_1001319A0((BOOL)v3))
    {
      if (qword_1001DC9B8 == -1)
      {
        if (!byte_1001DC9B0)
        {
LABEL_67:

          return;
        }
      }

      else
      {
        dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
        if (!byte_1001DC9B0) {
          goto LABEL_67;
        }
      }
    }

    id v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 96), v7);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 96), v10);
      _NRLogWithArgs( v11,  0LL,  "%s%.30s:%-4d creating pairing links",  "",  "-[NRDDeviceConductor createPairingLinksIfNeeded]",  732);
    }

    if (qword_1001DC9B8 == -1)
    {
      if (byte_1001DC9B0)
      {
LABEL_26:
        uint64_t v12 = v1;
        unsigned int v13 = 5;
        char v14 = 0;
LABEL_66:
        sub_1000D55D0(v12, v13, v14);
        goto LABEL_67;
      }
    }

    else
    {
      dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
      if (byte_1001DC9B0) {
        goto LABEL_26;
      }
    }

    id v15 = *((id *)v3 + 16);
    id v16 = (void *)objc_claimAutoreleasedReturnValue([v15 allowedLinkTypes]);
    if ([v16 containsObject:&off_1001BC6E8] && v3[9] && v3[20])
    {
      int v17 = v3[10];

      if (!v17) {
        sub_1000D55D0(v1, 1u, 0);
      }
    }

    else
    {
    }

    sub_1000D2DE0(v1);
    id v18 = *((id *)v3 + 16);
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v18 allowedLinkTypes]);
    unsigned int v20 = [v19 containsObject:&off_1001BC718];

    id v21 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
    if (v20)
    {
      id v22 = *(id *)(v1 + 96);
      objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
      id v23 = sub_100136BF4((uint64_t)&OBJC_CLASS___NRDLocalDevice, v22, &off_1001BC8F8);

      if (v23)
      {
        id v24 = [v23 copyCEndpoint];
        evaluator_for_endpoint = (void *)nw_path_create_evaluator_for_endpoint(v24, 0LL);

        id v26 = (void *)nw_path_evaluator_copy_path(evaluator_for_endpoint);
        id v28 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 96), v27);
        int v29 = _NRLogIsLevelEnabled(v28, 0LL);

        if (v29)
        {
          id v30 = *(id *)(v1 + 96);
          id v32 = (void *)_NRCopyLogObjectForNRUUID(v30, v31);
          _NRLogWithArgs( v32,  0LL,  "%s%.30s:%-4d path for wired endpoint %@ is %@",  "",  "-[NRDDeviceConductor createPairingLinksIfNeeded]",  753LL,  v23,  v26);
        }

        id v33 = (nw_interface *)nw_path_copy_interface(v26);
        name = nw_interface_get_name(v33);
        if (name)
        {
          id v35 = name;
          objc_opt_self(&OBJC_CLASS___NRLinkDirector);
          id v63 = evaluator_for_endpoint;
          if (qword_1001DC878 != -1) {
            dispatch_once(&qword_1001DC878, &stru_1001AEED0);
          }
          id v36 = (id)qword_1001DC870;
          uint64_t v37 = v36;
          if (v36) {
            id v38 = (void *)*((void *)v36 + 8);
          }
          else {
            id v38 = 0LL;
          }
          id v39 = v38;
          uint64_t v65 = v23;
          unsigned int v40 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v65,  1LL));
          id v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v35));
          sub_1000C986C((uint64_t)v39, v40, v41, *(void **)(v1 + 96));

          id v21 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
          evaluator_for_endpoint = v63;
        }
      }

      else
      {
        sub_1000D55D0(v1, 5u, 0);
      }
    }

    id v42 = *((id *)v3 + 16);
    id v43 = (void *)objc_claimAutoreleasedReturnValue([v42 allowedLinkSubtypes]);
    unsigned int v44 = [v43 containsObject:&off_1001BC730];

    if (v44)
    {
      id v45 = *(id *)(v1 + 96);
      objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
      __int128 v46 = sub_100136BF4((uint64_t)&v21[64], v45, &off_1001BC8B0);

      if (v46)
      {
        id v47 = (void *)objc_claimAutoreleasedReturnValue([v46 hostname]);
        objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
        if (qword_1001DC640 != -1) {
          dispatch_once(&qword_1001DC640, &stru_1001ADE98);
        }
        id v48 = (id)qword_1001DC638;
        unsigned int v49 = @"62743";
        if (!v48) {
          unsigned int v49 = 0LL;
        }
        id v50 = v49;
        id v51 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v47,  v50));

        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 104));
        objc_opt_self(&OBJC_CLASS___NRLinkDirector);
        if (qword_1001DC878 != -1) {
          dispatch_once(&qword_1001DC878, &stru_1001AEED0);
        }
        id v52 = (id)qword_1001DC870;
        char v53 = v52;
        if (v52) {
          char v54 = (void *)*((void *)v52 + 6);
        }
        else {
          char v54 = 0LL;
        }
        uint64_t v55 = v54;

        id v64 = v51;
        char v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v64, 1LL));
        sub_100140720(v55, v56, *(void **)(v1 + 96));

        if (*(_BYTE *)(v1 + 47)) {
          sub_1000DA20C(v1, 1, 0);
        }
      }

      else
      {
        sub_1000D55D0(v1, 2u, 101);
      }
    }

    id v57 = *((id *)v3 + 16);
    BOOL v58 = (void *)objc_claimAutoreleasedReturnValue([v57 allowedLinkSubtypes]);
    unsigned int v59 = [v58 containsObject:&off_1001BC748];

    if (v59) {
      sub_1000D55D0(v1, 2u, 103);
    }
    id v60 = *((id *)v3 + 16);
    id v61 = (void *)objc_claimAutoreleasedReturnValue([v60 allowedLinkSubtypes]);
    unsigned int v62 = [v61 containsObject:&off_1001BC760];

    if (!v62) {
      goto LABEL_67;
    }
    uint64_t v12 = v1;
    unsigned int v13 = 2;
    char v14 = 104;
    goto LABEL_66;
  }

void sub_1000EE948(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1 || !*(void *)(v1 + 128)) {
    sub_1000E1BF4(v1);
  }
}

void sub_1000EE960(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v2 = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    if (*((_BYTE *)WeakRetained + 13)) {
      BOOL v3 = v2 == 0LL;
    }
    else {
      BOOL v3 = 1;
    }
    if (!v3 && *((void **)WeakRetained + 61) == v2 && *((void *)WeakRetained + 62) != v2[4]) {
      sub_1000DBDAC((uint64_t)WeakRetained, *((void **)WeakRetained + 16));
    }
  }
}

void sub_1000EE9F0(uint64_t a1)
{
  id v2 = *(dispatch_queue_t **)(a1 + 32);
  if (v2)
  {
    dispatch_assert_queue_V2(v2[13]);
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v3 = (id)qword_1001DC870;
    id v4 = v3;
    if (v3) {
      char v5 = (void *)*((void *)v3 + 6);
    }
    else {
      char v5 = 0LL;
    }
    BOOL v6 = v5;

    if (v6) {
      id v2 = (dispatch_queue_t *)v6[11];
    }
    else {
      id v2 = 0LL;
    }
  }

  else
  {
    BOOL v6 = 0LL;
  }

  uint64_t v7 = v2;

  if (!v7)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(v8 + 104));
      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      id v9 = (id)qword_1001DC870;
      uint64_t v10 = v9;
      if (v9) {
        uint64_t v11 = (void *)*((void *)v9 + 6);
      }
      else {
        uint64_t v11 = 0LL;
      }
      id v12 = v11;

      sub_100140538((uint64_t)v12, *(void **)(a1 + 40));
    }

    else
    {
      id v12 = 0LL;
      sub_100140538(0LL, *(void **)(a1 + 40));
    }
  }

void sub_1000EEB5C(uint64_t a1)
{
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v2 = (id)qword_1001DC870;
  id v3 = v2;
  if (v2) {
    id v4 = (void *)*((void *)v2 + 6);
  }
  else {
    id v4 = 0LL;
  }
  id v5 = v4;

  id v6 = sub_100140B30((uint64_t)v5, *(void **)(*(void *)(a1 + 32) + 96LL));
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue(v6);

  if (!v7)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    if (v8)
    {
      uint64_t v9 = *(void *)(a1 + 32);
      if (v9)
      {
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v9 + 104));
        objc_opt_self(&OBJC_CLASS___NRLinkDirector);
        if (qword_1001DC878 != -1) {
          dispatch_once(&qword_1001DC878, &stru_1001AEED0);
        }
        id v10 = (id)qword_1001DC870;
        uint64_t v11 = v10;
        if (v10) {
          id v12 = (void *)*((void *)v10 + 6);
        }
        else {
          id v12 = 0LL;
        }
        unsigned int v13 = v12;

        uint64_t v8 = *(void *)(a1 + 40);
      }

      else
      {
        unsigned int v13 = 0LL;
      }

      uint64_t v15 = v8;
      char v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v15, 1LL));
      sub_100140720(v13, v14, *(void **)(*(void *)(a1 + 32) + 96LL));
    }
  }
}

void sub_1000EED00(uint64_t a1)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    if (*(_BYTE *)(a1 + 13))
    {
      *(_BYTE *)(a1 + 13) = 0;
      id v3 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 description]);
      sub_10011BB18(*(void **)(a1 + 96), 1502, 0LL, v3);

      objc_opt_self(&OBJC_CLASS___NRLinkDirectorMessageManager);
      if (qword_1001DC708 != -1) {
        dispatch_once(&qword_1001DC708, &stru_1001AE488);
      }
      id v4 = (id)qword_1001DC700;
      id v5 = (id *)v4;
      if (v4)
      {
        id v6 = (dispatch_queue_s *)*((void *)v4 + 1);
        id v7 = *(id *)(a1 + 96);
        dispatch_assert_queue_V2(v6);
        [v5[2] setObject:0 forKeyedSubscript:v7];
      }

      uint64_t v8 = *(void **)(a1 + 584);
      if (v8 && ([*(id *)(a1 + 584) cancelled] & 1) == 0)
      {
        [v8 setCancelled:1];
        [v8 setUpdateBlock:0];
        [v8 invalidateAggregateStatsTimerSource];
        [v8 reportEvent:30003];
      }

      uint64_t v9 = *(void **)(a1 + 624);
      *(void *)(a1 + 624) = 0LL;

      id v10 = *(void **)(a1 + 616);
      *(void *)(a1 + 616) = 0LL;

      *(_OWORD *)(a1 + 592) = 0u;
      uint64_t v11 = *(void **)(a1 + 208);
      if (v11)
      {
        [v11 setDelegate:0];
        [*(id *)(a1 + 208) destroy];
        id v12 = *(void **)(a1 + 208);
        *(void *)(a1 + 20_Block_object_dispose(va, 8) = 0LL;
      }

      *(_BYTE *)(a1 + 22) = 0;
      *(_DWORD *)(a1 + 1_Block_object_dispose(va, 8) = 0;
      *(_DWORD *)(a1 + 24) = 0;
      *(_BYTE *)(a1 + 2_Block_object_dispose(va, 8) = 0;
      sub_1000D7B08(a1, 0);
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
      sub_1000DA20C(a1, 0, 0xAu);
      [*(id *)(a1 + 560) cancel];
      unsigned int v13 = *(void **)(a1 + 560);
      *(void *)(a1 + 560) = 0LL;

      [*(id *)(a1 + 552) cancel];
      char v14 = *(void **)(a1 + 552);
      *(void *)(a1 + 552) = 0LL;

      sub_1000DD608(a1);
      uint64_t v16 = *(void *)(a1 + 488);
      if (v16)
      {
        *(_BYTE *)(v16 + 10) = 1;
        uint64_t v17 = *(void *)(v16 + 72);
        if (v17)
        {
          nw_path_evaluator_cancel(v17, v15);
          id v18 = *(void **)(v16 + 72);
          *(void *)(v16 + 72) = 0LL;
        }

        uint64_t v19 = *(void **)(a1 + 488);
        *(void *)(a1 + 48_Block_object_dispose(va, 8) = 0LL;
      }

      uint64_t v20 = *(void *)(a1 + 192);
      if (v20)
      {
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v20 + 48));
        objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
        if (qword_1001DCB60 != -1) {
          dispatch_once(&qword_1001DCB60, &stru_1001B0538);
        }
        id v21 = (id)qword_1001DCB58;
        sub_10012114C((uint64_t)v21, *(void **)(v20 + 72));

        objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
        if (qword_1001DCB60 != -1) {
          dispatch_once(&qword_1001DCB60, &stru_1001B0538);
        }
        id v22 = (id)qword_1001DCB58;
        id v23 = (id *)v22;
        if (v22)
        {
          dispatch_assert_queue_V2(*((dispatch_queue_t *)v22 + 1));
          if (([v23[2] apply] & 1) == 0) {
            sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v24,  v25,  v26,  v96);
          }
        }

        uint64_t v27 = *(void **)(v20 + 56);
        if (v27)
        {
          if (([v27 unregisterNetworkAgent] & 1) == 0)
          {
            int v29 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v20 + 40), v28);
            int IsLevelEnabled = _NRLogIsLevelEnabled(v29, 17LL);

            if (IsLevelEnabled)
            {
              id v32 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v20 + 40), v31);
              _NRLogWithArgs(v32, 17LL, "Failed to unregister PhoneCallRelay agent");
            }
          }

          id v33 = *(void **)(v20 + 56);
          *(void *)(v20 + 56) = 0LL;

          unsigned int v34 = *(void **)(v20 + 40);
          id v35 = *(id *)(v20 + 80);
          id v36 = v34;
          uint64_t v37 = (void *)objc_claimAutoreleasedReturnValue([(id)v20 agentUUID]);
          id v38 = (void *)objc_claimAutoreleasedReturnValue([v37 UUIDString]);
          sub_10011BB18(v36, 17003, v35, v38);
        }

        *(_BYTE *)(v20 + 14) = 0;
        id v39 = *(void **)(a1 + 192);
        *(void *)(a1 + 192) = 0LL;
      }

      uint64_t v40 = *(void *)(a1 + 200);
      if (v40)
      {
        sub_1000651A0(v40);
        id v41 = *(void **)(a1 + 200);
        *(void *)(a1 + 200) = 0LL;
      }

      uint64_t v42 = *(void *)(a1 + 384);
      if (v42)
      {
        sub_100067C8C(v42);
        id v43 = *(void **)(a1 + 384);
        *(void *)(a1 + 384) = 0LL;
      }

      uint64_t v44 = *(void *)(a1 + 440);
      if (v44)
      {
        sub_10005E374(v44, v15);
        id v45 = *(void **)(a1 + 440);
        *(void *)(a1 + 440) = 0LL;
      }

      uint64_t v46 = *(void *)(a1 + 632);
      if (v46)
      {
        sub_1000F6C6C(v46, v15);
        id v47 = *(void **)(a1 + 632);
        *(void *)(a1 + 632) = 0LL;
      }

      sub_1000EC130(a1);
      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      id v48 = (id)qword_1001DC870;
      sub_1000AF930((uint64_t)v48, 0LL, *(void **)(a1 + 96));

      sub_1000EAAB8(a1);
      unsigned int v49 = *(void **)(a1 + 656);
      *(void *)(a1 + 656) = 0LL;

      if (*(_BYTE *)(a1 + 55))
      {
        id v50 = *(void **)(a1 + 512);
        *(void *)(a1 + 512) = 0LL;

        id v51 = *(void **)(a1 + 520);
        *(void *)(a1 + 520) = 0LL;

        objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
        if (qword_1001DCB60 != -1) {
          dispatch_once(&qword_1001DCB60, &stru_1001B0538);
        }
        id v52 = (id)qword_1001DCB58;
        sub_10012114C((uint64_t)v52, *(void **)(a1 + 288));

        if (*(_BYTE *)(a1 + 55))
        {
          char v53 = *(void **)(a1 + 504);
          *(void *)(a1 + 504) = 0LL;

          char v54 = *(void **)(a1 + 528);
          *(void *)(a1 + 52_Block_object_dispose(va, 8) = 0LL;

          objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
          if (qword_1001DCB60 != -1) {
            dispatch_once(&qword_1001DCB60, &stru_1001B0538);
          }
          id v55 = (id)qword_1001DCB58;
          sub_10012114C((uint64_t)v55, *(void **)(a1 + 280));
        }
      }

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v56 = (id)qword_1001DCB58;
      sub_10012114C((uint64_t)v56, *(void **)(a1 + 272));

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v57 = (id)qword_1001DCB58;
      sub_10012114C((uint64_t)v57, *(void **)(a1 + 312));

      if (*(void *)(a1 + 296))
      {
        objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
        if (qword_1001DCB60 != -1) {
          dispatch_once(&qword_1001DCB60, &stru_1001B0538);
        }
        id v58 = (id)qword_1001DCB58;
        sub_10012114C((uint64_t)v58, *(void **)(a1 + 296));
      }

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v59 = (id)qword_1001DCB58;
      sub_10012114C((uint64_t)v59, *(void **)(a1 + 544));

      if (*(void *)(a1 + 304))
      {
        objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
        if (qword_1001DCB60 != -1) {
          dispatch_once(&qword_1001DCB60, &stru_1001B0538);
        }
        id v60 = (id)qword_1001DCB58;
        sub_10012114C((uint64_t)v60, *(void **)(a1 + 304));
      }

      id v61 = *(void **)(a1 + 664);
      *(void *)(a1 + 664) = 0LL;

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v62 = (id)qword_1001DCB58;
      sub_10012114C((uint64_t)v62, *(void **)(a1 + 680));

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v63 = (id)qword_1001DCB58;
      id v64 = (id *)v63;
      if (v63)
      {
        dispatch_assert_queue_V2(*((dispatch_queue_t *)v63 + 1));
        if (([v64[2] apply] & 1) == 0) {
          sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v65,  v66,  v67,  v96);
        }
      }

      uint64_t v68 = *(void **)(a1 + 424);
      *(void *)(a1 + 424) = 0LL;

      uint64_t v70 = *(void *)(a1 + 416);
      if (v70)
      {
        sub_100113E44(v70, v69);
        uint64_t v71 = *(void **)(a1 + 416);
        *(void *)(a1 + 416) = 0LL;
      }

      id v72 = *(void **)(a1 + 240);
      *(void *)(a1 + 240) = 0LL;

      id v73 = *(dispatch_source_s **)(a1 + 360);
      if (v73)
      {
        dispatch_source_cancel(v73);
        id v74 = *(void **)(a1 + 360);
        *(void *)(a1 + 360) = 0LL;
      }

      [*(id *)(a1 + 120) removeAllObjects];
      uint64_t v76 = *(void *)(a1 + 184);
      if (v76)
      {
        id v77 = *(dispatch_queue_s **)(v76 + 24);
        if (v77) {
          dispatch_assert_queue_V2(v77);
        }
        uint64_t v78 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v76 + 16), v75);
        int v79 = _NRLogIsLevelEnabled(v78, 0LL);

        if (v79)
        {
          uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v76 + 16), v80);
          _NRLogWithArgs(v81, 0LL, "%s%.30s:%-4d Cancel %@", "", "-[NRDevicePreferencesManager cancel]", 77LL, v76);
        }

        [*(id *)(v76 + 32) removeAllObjects];
        sub_10010E0D0(v76);
        [*(id *)(v76 + 40) removeAllObjects];
        sub_10010E880(v76);
        objc_super v82 = *(void **)(a1 + 184);
      }

      else
      {
        objc_super v82 = 0LL;
      }

      *(void *)(a1 + 184) = 0LL;

      __int128 v104 = 0u;
      __int128 v105 = 0u;
      __int128 v102 = 0u;
      __int128 v103 = 0u;
      id v83 = *(id *)(a1 + 168);
      id v84 = [v83 countByEnumeratingWithState:&v102 objects:v107 count:16];
      if (v84)
      {
        id v85 = v84;
        uint64_t v86 = *(void *)v103;
        do
        {
          for (uint64_t i = 0LL; i != v85; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v103 != v86) {
              objc_enumerationMutation(v83);
            }
            xpc_connection_cancel(*(xpc_connection_t *)(*((void *)&v102 + 1) + 8LL * (void)i));
          }

          id v85 = [v83 countByEnumeratingWithState:&v102 objects:v107 count:16];
        }

        while (v85);
      }

      [*(id *)(a1 + 168) removeAllObjects];
      __int128 v100 = 0u;
      __int128 v101 = 0u;
      __int128 v98 = 0u;
      __int128 v99 = 0u;
      id v88 = *(id *)(a1 + 176);
      id v89 = [v88 countByEnumeratingWithState:&v98 objects:v106 count:16];
      if (v89)
      {
        id v90 = v89;
        uint64_t v91 = *(void *)v99;
        do
        {
          for (j = 0LL; j != v90; j = (char *)j + 1)
          {
            if (*(void *)v99 != v91) {
              objc_enumerationMutation(v88);
            }
            xpc_connection_cancel(*(xpc_connection_t *)(*((void *)&v98 + 1) + 8LL * (void)j));
          }

          id v90 = [v88 countByEnumeratingWithState:&v98 objects:v106 count:16];
        }

        while (v90);
      }

      [*(id *)(a1 + 176) removeAllObjects];
      sub_1000E12E4(a1);
    }

    else
    {
      id v93 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v2);
      int v94 = _NRLogIsLevelEnabled(v93, 1LL);

      if (v94)
      {
        id v97 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v95);
        _NRLogWithArgs( v97,  1LL,  "%s%.30s:%-4d Skipping cancel as conductor is already disabled",  "",  "-[NRDDeviceConductor cancelConductor]",  1244);
      }
    }
  }

void sub_1000EF77C(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 16) != a2)
  {
    sub_1000D4F78(a1, 1033, @"%d -> %d", v4, v5, v6, v7, v8, *(unsigned __int8 *)(a1 + 16));
    *(_BYTE *)(a1 + 16) = a2;
    if (a2) {
      sub_1000DA884(a1, @"Device setup in progress", v9, v10, v11, v12, v13, v14, v26);
    }
    if (*(_BYTE *)(a1 + 8) && !*(_BYTE *)(a1 + 16))
    {
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      id v15 = (id)qword_1001DC870;
      uint64_t v16 = v15;
      if (v15) {
        uint64_t v17 = (void *)*((void *)v15 + 6);
      }
      else {
        uint64_t v17 = 0LL;
      }
      uint64_t v27 = v17;

      id v18 = v27;
      if (v27
        && (uint64_t v19 = (dispatch_queue_s *)v27[3],
            dispatch_assert_queue_V2(v19),
            v19,
            id v18 = v27,
            *((int *)v27 + 10) >= 1))
      {
        int v20 = *(unsigned __int8 *)(a1 + 14);

        if (!v20)
        {
          id v22 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v21);
          int IsLevelEnabled = _NRLogIsLevelEnabled(v22, 0LL);

          if (IsLevelEnabled)
          {
            uint64_t v25 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v24);
            _NRLogWithArgs( v25,  0LL,  "%s%.30s:%-4d processing outstanding prefer Wi-Fi requests",  "",  "-[NRDDeviceConductor setDeviceSetupInProgress:]",  1848);
          }

          [(id)a1 preferWiFiRequestAvailable];
        }
      }

      else
      {
      }
    }
  }

void sub_1000EF930(uint64_t a1, void *a2)
{
  id v6 = a2;
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
    if (v6)
    {
      [*(id *)(a1 + 168) addObject:v6];
    }

    else
    {
      id v3 = sub_1000D54AC();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 17LL);

      if (IsLevelEnabled)
      {
        id v5 = sub_1000D54AC();
        _NRLogWithArgs(v5, 17LL, "%s called with null connection", "-[NRDDeviceConductor addDeviceMonitorConnection:]");
      }
    }
  }
}

uint64_t sub_1000EF9C8(uint64_t a1, const char *a2, void *a3)
{
  id v6 = a3;
  uint64_t v7 = *(void *)(a1 + 32);
  if (v7) {
    uint64_t v8 = *(void *)(v7 + 96);
  }
  else {
    uint64_t v8 = 0LL;
  }
  uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(v8, v5);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 0LL);

  if (IsLevelEnabled)
  {
    uint64_t v12 = *(void *)(a1 + 32);
    if (v12) {
      uint64_t v13 = *(void *)(v12 + 96);
    }
    else {
      uint64_t v13 = 0LL;
    }
    uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(v13, v11);
    _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d Received data key: %s",  "",  "-[NRDDeviceConductor processXPCCommNotificationForConnection:notificationDictionary:]_block_invoke",  7348,  a2);
  }

  if (!strcmp(a2, kNRXPCCommNotificationTypeXPCommDictionary))
  {
    if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
    {
      uint64_t v24 = _CFXPCCreateCFObjectFromXPCObject(v6);
      uint64_t v25 = *(void *)(*(void *)(a1 + 40) + 8LL);
      uint64_t v26 = *(void **)(v25 + 40);
      *(void *)(v25 + 40) = v24;

      uint64_t v28 = *(void *)(a1 + 32);
      if (v28) {
        uint64_t v29 = *(void *)(v28 + 96);
      }
      else {
        uint64_t v29 = 0LL;
      }
      id v30 = (void *)_NRCopyLogObjectForNRUUID(v29, v27);
      int v31 = _NRLogIsLevelEnabled(v30, 0LL);

      if (v31)
      {
        id v32 = *(void **)(a1 + 32);
        if (v32) {
          id v32 = (void *)v32[12];
        }
        id v33 = v32;
        id v23 = (void *)_NRCopyLogObjectForNRUUID(v33, v34);
        _NRLogWithArgs( v23,  0LL,  "%s%.30s:%-4d Received data: %@",  "",  "-[NRDDeviceConductor processXPCCommNotificationForConnection:notificationDictionary:]_block_invoke",  7352LL,  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL));

        goto LABEL_21;
      }
    }

    else
    {
      uint64_t v16 = *(void *)(a1 + 32);
      if (v16) {
        uint64_t v17 = *(void *)(v16 + 96);
      }
      else {
        uint64_t v17 = 0LL;
      }
      id v18 = (void *)_NRCopyLogObjectForNRUUID(v17, v15);
      int v19 = _NRLogIsLevelEnabled(v18, 17LL);

      if (v19)
      {
        uint64_t v21 = *(void *)(a1 + 32);
        if (v21) {
          uint64_t v22 = *(void *)(v21 + 96);
        }
        else {
          uint64_t v22 = 0LL;
        }
        id v23 = (void *)_NRCopyLogObjectForNRUUID(v22, v20);
        _NRLogWithArgs(v23, 17LL, "Invalid type for key %s", a2);
LABEL_21:
      }
    }
  }

  return 1LL;
}

void sub_1000EFBC8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1 && *(_BYTE *)(a1 + 13))
  {
    id v4 = [*(id *)(a1 + 152) count];
    if (!v3 || v4)
    {
      id v51 = v3;
      __int128 v70 = 0u;
      __int128 v71 = 0u;
      __int128 v68 = 0u;
      __int128 v69 = 0u;
      id v52 = *(id *)(a1 + 160);
      id v56 = (char *)[v52 countByEnumeratingWithState:&v68 objects:v74 count:16];
      if (v56)
      {
        uint64_t v55 = *(void *)v69;
        char v54 = (const char *)kNRXPCCommNotificationTypeXPCommDictionary;
        char v53 = (const char *)nrXPCKeyXPCCommNotification;
        do
        {
          uint64_t v8 = 0LL;
          do
          {
            if (*(void *)v69 != v55) {
              objc_enumerationMutation(v52);
            }
            uint64_t v9 = *(void *)(*((void *)&v68 + 1) + 8LL * (void)v8);
            xpc_object_t v10 = xpc_dictionary_create(0LL, 0LL, 0LL);
            if (!v10)
            {
              if (qword_1001DC8F0 != -1) {
                dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
              }
              id v38 = (id)qword_1001DC8E8;
              int IsLevelEnabled = _NRLogIsLevelEnabled(v38, 16LL);

              if (!IsLevelEnabled) {
                goto LABEL_51;
              }
              if (qword_1001DC8F0 == -1) {
                goto LABEL_49;
              }
LABEL_54:
              dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
LABEL_49:
              id v42 = (id)qword_1001DC8E8;
              _NRLogWithArgs( v42,  16LL,  "%s%.30s:%-4d ABORTING: xpc_dictionary_create(%p, %p, %u) failed",  "",  "nr_xpc_dictionary_create",  74,  0LL,  0LL,  0);
              goto LABEL_50;
            }

            uint64_t v11 = v10;
            xpc_object_t v12 = xpc_dictionary_create(0LL, 0LL, 0LL);
            if (!v12)
            {
              if (qword_1001DC8F0 != -1) {
                dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
              }
              id v40 = (id)qword_1001DC8E8;
              int v41 = _NRLogIsLevelEnabled(v40, 16LL);

              if (!v41) {
                goto LABEL_51;
              }
              if (qword_1001DC8F0 != -1) {
                goto LABEL_54;
              }
              goto LABEL_49;
            }

            uint64_t v13 = v12;
            id v59 = v8;
            id v57 = (id)_CFXPCCreateXPCObjectFromCFObject(v9);
            xpc_dictionary_set_value(v13, v54, v57);
            id v58 = v13;
            xpc_dictionary_set_value(v11, v53, v13);
            __int128 v66 = 0u;
            __int128 v67 = 0u;
            __int128 v64 = 0u;
            __int128 v65 = 0u;
            id v14 = *(id *)(a1 + 152);
            id v15 = [v14 countByEnumeratingWithState:&v64 objects:v73 count:16];
            if (v15)
            {
              id v16 = v15;
              uint64_t v17 = *(void *)v65;
              do
              {
                for (uint64_t i = 0LL; i != v16; uint64_t i = (char *)i + 1)
                {
                  if (*(void *)v65 != v17) {
                    objc_enumerationMutation(v14);
                  }
                  xpc_connection_send_message(*(xpc_connection_t *)(*((void *)&v64 + 1) + 8LL * (void)i), v11);
                  uint64_t v20 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v19);
                  int v21 = _NRLogIsLevelEnabled(v20, 0LL);

                  if (v21)
                  {
                    id v23 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v22);
                    _NRLogWithArgs( v23,  0LL,  "%s%.30s:%-4d sending xpcComm pending message",  "",  "-[NRDDeviceConductor sendXPCCommDictionary:]",  7417);
                  }
                }

                id v16 = [v14 countByEnumeratingWithState:&v64 objects:v73 count:16];
              }

              while (v16);
            }

            uint64_t v8 = v59 + 1;
          }

          while (v59 + 1 != v56);
          id v56 = (char *)[v52 countByEnumeratingWithState:&v68 objects:v74 count:16];
        }

        while (v56);
      }

      [*(id *)(a1 + 160) removeAllObjects];
      id v3 = v51;
      if (v51)
      {
        xpc_object_t v24 = xpc_dictionary_create(0LL, 0LL, 0LL);
        if (!v24 || (uint64_t v25 = v24, (v26 = (char *)xpc_dictionary_create(0LL, 0LL, 0LL)) == 0LL))
        {
          while (1)
          {
            id v48 = sub_1000D54AC();
            int v49 = _NRLogIsLevelEnabled(v48, 16LL);

            if (v49)
            {
              id v42 = sub_1000D54AC();
              _NRLogWithArgs( v42,  16LL,  "%s%.30s:%-4d ABORTING: xpc_dictionary_create(%p, %p, %u) failed",  "",  "nr_xpc_dictionary_create",  74,  0LL,  0LL,  0);
LABEL_50:
            }

void sub_1000F0258(_BYTE *a1, int a2)
{
  if (a1 && (a1[66] != 0) != a2 && a1[13] && a1[45] && a1[47])
  {
    if (qword_1001DC8F0 != -1) {
      dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC8E8, 0LL))
    {
      if (qword_1001DC8F0 != -1) {
        dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
      }
      _NRLogWithArgs( qword_1001DC8E8,  0LL,  "%s%.30s:%-4d has non companion clients %d",  "",  "-[NRDDeviceConductor updateHasNonCompanionClients:]",  8071,  a2);
    }

    a1[66] = a2;
    sub_1000DD7C4((uint64_t)a1);
  }

void *sub_1000F0418(void *a1)
{
  if (!a1) {
    return 0LL;
  }
  v23.receiver = a1;
  v23.super_class = (Class)&OBJC_CLASS___NRDIDSKeyManager;
  uint64_t v1 = objc_msgSendSuper2(&v23, "init");
  if (!v1)
  {
    id v8 = sub_1000F0648();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 16LL);

    if (IsLevelEnabled)
    {
      id v10 = sub_1000F0648();
      _NRLogWithArgs( v10,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDIDSKeyManager initInternal]",  98);
    }

    uint64_t v11 = _os_log_pack_size(12LL);
    xpc_object_t v12 = (char *)&v22 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v13 = __error();
    uint64_t v14 = _os_log_pack_fill(v12, v11, *v13, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)uint64_t v14 = 136446210;
    *(void *)(v14 + 4) = "-[NRDIDSKeyManager initInternal]";
    goto LABEL_11;
  }

  uint64_t v2 = v1;
  id v3 = sub_100146AFC();
  id v4 = (void *)v2[2];
  v2[2] = v3;

  uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v6 = (void *)v2[6];
  v2[6] = v5;

  if (!v2[6])
  {
    id v15 = sub_1000F0648();
    int v16 = _NRLogIsLevelEnabled(v15, 16LL);

    if (v16)
    {
      id v17 = sub_1000F0648();
      _NRLogWithArgs( v17,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (self.deviceRecords) != ((void *)0)",  "",  "-[NRDIDSKeyManager initInternal]",  101);
    }

    uint64_t v18 = _os_log_pack_size(12LL);
    xpc_object_t v12 = (char *)&v22 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v19 = __error();
    uint64_t v20 = _os_log_pack_fill( v12,  v18,  *v19,  &_mh_execute_header,  "%{public}s Assertion Failed: (self.deviceRecords) != ((void *)0)");
    *(_DWORD *)uint64_t v20 = 136446210;
    *(void *)(v20 + 4) = "-[NRDIDSKeyManager initInternal]";
LABEL_11:
    id v21 = sub_1000F0648();
    _NRLogAbortWithPack(v21, v12);
    return 0LL;
  }

  return v2;
}

id sub_1000F0648()
{
  if (qword_1001DC910 != -1) {
    dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
  }
  return (id)qword_1001DC908;
}

void sub_1000F0688(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC908;
  qword_1001DC908 = (uint64_t)v1;
}

void sub_1000F06B8(id a1)
{
  os_log_t v1 = sub_1000F0418(objc_alloc(&OBJC_CLASS___NRDIDSKeyManager));
  uint64_t v2 = (void *)qword_1001DC8F8;
  qword_1001DC8F8 = (uint64_t)v1;
}

uint64_t sub_1000F06E4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
    id v4 = [v3 fullIdentity];
    if (v4)
    {
      a1 = *((void *)v4 + 3);
      if (a1)
      {
        CFRetain(*((CFTypeRef *)v4 + 3));
        goto LABEL_5;
      }

      id v9 = sub_1000F0648();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 17LL);

      if (IsLevelEnabled)
      {
        id v8 = sub_1000F0648();
        _NRLogWithArgs(v8, 17LL, "privateSigningKey missing from mpsFullID");
        goto LABEL_10;
      }
    }

    else
    {
      id v6 = sub_1000F0648();
      int v7 = _NRLogIsLevelEnabled(v6, 17LL);

      if (v7)
      {
        id v8 = sub_1000F0648();
        _NRLogWithArgs(v8, 17LL, "Failed to extract fullIdentity from localPrivateIDSIdentity");
LABEL_10:
      }
    }

    a1 = 0LL;
  }

uint64_t sub_1000F07B0(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
    id v4 = [v3 publicIdentity];
    if (v4)
    {
      a1 = *((void *)v4 + 2);
      if (a1)
      {
        CFRetain(*((CFTypeRef *)v4 + 2));
        goto LABEL_5;
      }

      id v9 = sub_1000F0648();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 17LL);

      if (IsLevelEnabled)
      {
        id v8 = sub_1000F0648();
        _NRLogWithArgs(v8, 17LL, "publicSigningKey missing from mpsPublicID");
        goto LABEL_10;
      }
    }

    else
    {
      id v6 = sub_1000F0648();
      int v7 = _NRLogIsLevelEnabled(v6, 17LL);

      if (v7)
      {
        id v8 = sub_1000F0648();
        _NRLogWithArgs(v8, 17LL, "Failed to extract publicIdentity from remotePublicIDSIdentity");
LABEL_10:
      }
    }

    a1 = 0LL;
  }

void sub_1000F087C(uint64_t a1, int a2)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
    if (*(_BYTE *)(a1 + 8))
    {
      if (a2) {
        *(_BYTE *)(a1 + 9) = 1;
      }
    }

    else
    {
      *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = 1;
      if (!*(void *)(a1 + 56))
      {
        id v4 = objc_alloc_init(&OBJC_CLASS___NRAnalyticsKeyManager);
        uint64_t v5 = *(void **)(a1 + 56);
        *(void *)(a1 + 56) = v4;
      }

      sub_10011BB18(0LL, 5500, &stru_1001B1528, 0LL);
      uint64_t v6 = mach_absolute_time();
      uint64_t v7 = *(void *)(a1 + 56);
      if (v7) {
        *(void *)(v7 + 24) = v6;
      }
      if (qword_1001DC918 != -1) {
        dispatch_once(&qword_1001DC918, &stru_1001AF7C0);
      }
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_1000F0988;
      block[3] = &unk_1001B0A88;
      void block[4] = a1;
      dispatch_async((dispatch_queue_t)qword_1001DC920, block);
    }
  }

uint64_t sub_1000F0988(uint64_t a1)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472LL;
  v2[2] = sub_1000F0A0C;
  v2[3] = &unk_1001AF6E0;
  v2[4] = *(void *)(a1 + 32);
  if (qword_1001DC918 != -1) {
    dispatch_once(&qword_1001DC918, &stru_1001AF7C0);
  }
  return IDSLocalPairingGetPairingRecordsWithCompletionBlock(v2, qword_1001DC920);
}

void sub_1000F0A0C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = v9;
  uint64_t v11 = *(void *)(a1 + 32);
  if (v11) {
    xpc_object_t v12 = *(dispatch_queue_s **)(v11 + 16);
  }
  else {
    xpc_object_t v12 = 0LL;
  }
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472LL;
  v16[2] = sub_1000F0AF0;
  v16[3] = &unk_1001AF908;
  v16[4] = v11;
  id v17 = v9;
  id v18 = v7;
  id v19 = v8;
  id v13 = v8;
  id v14 = v7;
  id v15 = v10;
  dispatch_async(v12, v16);
}

id sub_1000F0AF0(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id v3 = *(dispatch_queue_s **)(v2 + 16);
  }
  else {
    id v3 = 0LL;
  }
  dispatch_assert_queue_V2(v3);
  uint64_t v4 = *(void *)(v1 + 32);
  if (v4) {
    *(_BYTE *)(v4 + _Block_object_dispose(va, 8) = 0;
  }
  uint64_t v5 = mach_absolute_time();
  uint64_t v11 = *(void *)(v1 + 32);
  if (v11)
  {
    uint64_t v12 = *(void *)(v11 + 56);
    if (v12) {
      *(void *)(v12 + 32) = v5;
    }
  }

  uint64_t v13 = *(void *)(v1 + 48);
  if (!*(void *)(v1 + 40) && v13 && *(void *)(v1 + 56))
  {
    sub_1000F1ABC(*(void *)(v1 + 32), 5501, @"%@ %@", v6, v7, v8, v9, v10, *(void *)(v1 + 48));
    uint64_t v18 = *(void *)(v1 + 32);
    if (v18 && ((uint64_t v19 = *(void *)(v18 + 56)) == 0 || (*(_BYTE *)(v19 + 16) = 1, (v18 = *(void *)(v1 + 32)) != 0))) {
      uint64_t v20 = *(void **)(v18 + 56);
    }
    else {
      uint64_t v20 = 0LL;
    }
    [v20 submit];
    uint64_t v21 = *(void *)(v1 + 32);
    id v22 = *(id *)(v1 + 48);
    p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    xpc_object_t v24 = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
    if (v21)
    {
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(v21 + 16));
      if (v22)
      {
        *(void *)&__int128 v101 = 0LL;
        uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v22 fullIdentityClassD:&v101]);
        id v26 = (id)v101;
        uint64_t v27 = v26;
        if (!v25 || v26)
        {
          if (qword_1001DC910 != -1) {
            dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC908, 16LL))
          {
            if (qword_1001DC910 != -1) {
              dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
            }
            _NRLogWithArgs( qword_1001DC908,  16LL,  "%s%.30s:%-4d Failed to ingest IDS local classD identity: %@",  "",  "-[NRDIDSKeyManager ingestIDSLocalDeviceRecord:]",  132LL,  v27);
          }
        }

        else
        {
          id v28 = (const void *)sub_1000F06E4(v21, v25);
          if (qword_1001DC910 != -1) {
            dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC908, 0LL))
          {
            if (qword_1001DC910 != -1) {
              dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
            }
            id v29 = (id)qword_1001DC908;
            if (v28)
            {
              v106[0] = 0LL;
              SecKeyCopyPublicBytes(v28, v106);
              id v30 = (void *)v106[0];
              v106[0] = 0LL;
              LogString = (__CFString *)_NRKeyCreateLogString(v30);
            }

            else
            {
              LogString = @"[nil]";
            }

            _NRLogWithArgs( v29,  0LL,  "%s%.30s:%-4d Ingested IDS local classD identity %@",  "",  "-[NRDIDSKeyManager ingestIDSLocalDeviceRecord:]",  128LL,  LogString);
          }

          objc_storeStrong((id *)(v21 + 24), v25);
          if (v28) {
            CFRelease(v28);
          }
        }

        id v105 = 0LL;
        id v32 = (void *)objc_claimAutoreleasedReturnValue([v22 fullIdentityClassC:&v105]);
        id v33 = v105;
        uint64_t v34 = v33;
        if (!v32 || v33)
        {
          if (qword_1001DC910 != -1) {
            dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC908, 16LL))
          {
            if (qword_1001DC910 != -1) {
              dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
            }
            _NRLogWithArgs( qword_1001DC908,  16LL,  "%s%.30s:%-4d Failed to ingest IDS local classC identity: %@",  "",  "-[NRDIDSKeyManager ingestIDSLocalDeviceRecord:]",  147LL,  v34);
          }
        }

        else
        {
          int v35 = (const void *)sub_1000F06E4(v21, v32);
          if (qword_1001DC910 != -1) {
            dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC908, 0LL))
          {
            if (qword_1001DC910 != -1) {
              dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
            }
            id v36 = (id)qword_1001DC908;
            if (v35)
            {
              v106[0] = 0LL;
              SecKeyCopyPublicBytes(v35, v106);
              uint64_t v37 = (void *)v106[0];
              v106[0] = 0LL;
              id v38 = (__CFString *)_NRKeyCreateLogString(v37);
            }

            else
            {
              id v38 = @"[nil]";
            }

            _NRLogWithArgs( v36,  0LL,  "%s%.30s:%-4d Ingested IDS local classC identity %@",  "",  "-[NRDIDSKeyManager ingestIDSLocalDeviceRecord:]",  143LL,  v38);
          }

          objc_storeStrong((id *)(v21 + 32), v32);
          if (v35) {
            CFRelease(v35);
          }
        }

        id v100 = 0LL;
        id v39 = (void *)objc_claimAutoreleasedReturnValue([v22 fullIdentityClassA:&v100]);
        id v40 = v100;
        int v41 = v40;
        if (!v39 || v40)
        {
          if (qword_1001DC910 != -1) {
            dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC908, 16LL))
          {
            if (qword_1001DC910 != -1) {
              dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
            }
            _NRLogWithArgs( qword_1001DC908,  16LL,  "%s%.30s:%-4d Failed to ingest IDS local classA identity: %@",  "",  "-[NRDIDSKeyManager ingestIDSLocalDeviceRecord:]",  162LL,  v41);
          }
        }

        else
        {
          id v42 = (const void *)sub_1000F06E4(v21, v39);
          if (qword_1001DC910 != -1) {
            dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC908, 0LL))
          {
            if (qword_1001DC910 != -1) {
              dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
            }
            id v43 = (id)qword_1001DC908;
            if (v42)
            {
              v106[0] = 0LL;
              SecKeyCopyPublicBytes(v42, v106);
              uint64_t v44 = (void *)v106[0];
              v106[0] = 0LL;
              id v45 = (__CFString *)_NRKeyCreateLogString(v44);
            }

            else
            {
              id v45 = @"[nil]";
            }

            _NRLogWithArgs( v43,  0LL,  "%s%.30s:%-4d Ingested IDS local classA identity %@",  "",  "-[NRDIDSKeyManager ingestIDSLocalDeviceRecord:]",  158LL,  v45);
          }

          objc_storeStrong((id *)(v21 + 40), v39);
          if (v42) {
            CFRelease(v42);
          }
        }

        p_class_meths = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
        xpc_object_t v24 = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
      }

      else
      {
        id v85 = sub_1000F0648();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v85, 17LL);

        if (IsLevelEnabled)
        {
          id v87 = sub_1000F0648();
          _NRLogWithArgs( v87,  17LL,  "%s called with null localDeviceRecord",  "-[NRDIDSKeyManager ingestIDSLocalDeviceRecord:]");
        }
      }
    }

    uint64_t v46 = *(void *)(v1 + 32);
    id v47 = *(id *)(v1 + 56);
    if (v46)
    {
      uint64_t v95 = v46;
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(v46 + 16));
      if (v47)
      {
        id v91 = v47;
        uint64_t v92 = v1;
        __int128 v103 = 0u;
        __int128 v104 = 0u;
        __int128 v101 = 0u;
        __int128 v102 = 0u;
        id obj = v47;
        uint64_t v48 = v46;
        id v94 = [obj countByEnumeratingWithState:&v101 objects:v106 count:16];
        if (v94)
        {
          uint64_t v93 = *(void *)v102;
          do
          {
            for (uint64_t i = 0LL; i != v94; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v102 != v93) {
                objc_enumerationMutation(obj);
              }
              char v53 = *(void **)(*((void *)&v101 + 1) + 8LL * (void)i);
              id v52 = (void *)objc_claimAutoreleasedReturnValue([obj objectForKeyedSubscript:v53]);
              char v54 = (NRDIDSKMDeviceRecord *)objc_claimAutoreleasedReturnValue([*(id *)(v48 + 48) objectForKeyedSubscript:v53]);
              if (!v54) {
                char v54 = objc_alloc_init(&OBJC_CLASS___NRDIDSKMDeviceRecord);
              }
              id v100 = 0LL;
              uint64_t v55 = (void *)objc_claimAutoreleasedReturnValue([v52 publicIdentityClassD:&v100]);
              id v56 = v100;
              id v57 = v56;
              if (v55) {
                BOOL v58 = v56 == 0LL;
              }
              else {
                BOOL v58 = 0;
              }
              id v97 = v52;
              if (v58)
              {
                __int128 v61 = (const void *)sub_1000F07B0(v48, v55);
                if (p_class_meths[290] != (__objc2_meth_list *)-1LL) {
                  dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
                }
                if (_NRLogIsLevelEnabled(v24[289], 0LL))
                {
                  if (p_class_meths[290] != (__objc2_meth_list *)-1LL) {
                    dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
                  }
                  __int128 v62 = v24[289];
                  __int128 v63 = (void *)objc_claimAutoreleasedReturnValue([v53 UUIDString]);
                  if (v61)
                  {
                    id v105 = 0LL;
                    SecKeyCopyPublicBytes(v61, &v105);
                    id v64 = v105;
                    id v105 = 0LL;
                    __int128 v65 = (__CFString *)_NRKeyCreateLogString(v64);

                    uint64_t v48 = v95;
                  }

                  else
                  {
                    __int128 v65 = @"[nil]";
                  }

                  _NRLogWithArgs( v62,  0LL,  "%s%.30s:%-4d Ingested IDS remote classD identity for BT<%@> %@",  "",  "-[NRDIDSKeyManager ingestIDSPairedDevicesRecords:]",  187LL,  v63,  v65);

                  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
                  xpc_object_t v24 = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
                  id v52 = v97;
                }

                if (v54) {
                  objc_storeStrong((id *)&v54->_remoteIDSClassDIdentity, v55);
                }
                if (v61) {
                  CFRelease(v61);
                }
              }

              else
              {
                if (p_class_meths[290] != (__objc2_meth_list *)-1LL) {
                  dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
                }
                if (_NRLogIsLevelEnabled(v24[289], 16LL))
                {
                  if (p_class_meths[290] != (__objc2_meth_list *)-1LL) {
                    dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
                  }
                  id v59 = v24[289];
                  __int128 v60 = (void *)objc_claimAutoreleasedReturnValue([v53 UUIDString]);
                  _NRLogWithArgs( v59,  16LL,  "%s%.30s:%-4d Failed to ingest IDS remote classD identity for bluetoothUUID %@: %@",  "",  "-[NRDIDSKeyManager ingestIDSPairedDevicesRecords:]",  192LL,  v60,  v57);

                  uint64_t v48 = v95;
                  id v52 = v97;
                }
              }

              id v99 = 0LL;
              __int128 v66 = (void *)objc_claimAutoreleasedReturnValue([v52 publicIdentityClassC:&v99]);
              id v67 = v99;
              __int128 v68 = v67;
              if (!v66 || v67)
              {
                if (p_class_meths[290] != (__objc2_meth_list *)-1LL) {
                  dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
                }
                if (_NRLogIsLevelEnabled(v24[289], 16LL))
                {
                  if (p_class_meths[290] != (__objc2_meth_list *)-1LL) {
                    dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
                  }
                  id v74 = v24[289];
                  uint64_t v75 = (void *)objc_claimAutoreleasedReturnValue([v53 UUIDString]);
                  _NRLogWithArgs( v74,  16LL,  "%s%.30s:%-4d Failed to ingest IDS remote classC identity for bluetoothUUID %@: %@",  "",  "-[NRDIDSKeyManager ingestIDSPairedDevicesRecords:]",  208LL,  v75,  v68);

                  uint64_t v48 = v95;
                  id v52 = v97;
                }
              }

              else
              {
                __int128 v69 = (const void *)sub_1000F07B0(v48, v66);
                if (p_class_meths[290] != (__objc2_meth_list *)-1LL) {
                  dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
                }
                if (_NRLogIsLevelEnabled(v24[289], 0LL))
                {
                  if (p_class_meths[290] != (__objc2_meth_list *)-1LL) {
                    dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
                  }
                  __int128 v70 = v24[289];
                  __int128 v71 = (void *)objc_claimAutoreleasedReturnValue([v53 UUIDString]);
                  if (v69)
                  {
                    id v105 = 0LL;
                    SecKeyCopyPublicBytes(v69, &v105);
                    id v72 = v105;
                    id v105 = 0LL;
                    id v73 = (__CFString *)_NRKeyCreateLogString(v72);

                    uint64_t v48 = v95;
                  }

                  else
                  {
                    id v73 = @"[nil]";
                  }

                  _NRLogWithArgs( v70,  0LL,  "%s%.30s:%-4d Ingested IDS remote classC identity for BT<%@> %@",  "",  "-[NRDIDSKeyManager ingestIDSPairedDevicesRecords:]",  203LL,  v71,  v73);

                  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
                  xpc_object_t v24 = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
                  id v52 = v97;
                }

                if (v54) {
                  objc_storeStrong((id *)&v54->_remoteIDSClassCIdentity, v66);
                }
                if (v69) {
                  CFRelease(v69);
                }
              }

              id v98 = 0LL;
              uint64_t v76 = (void *)objc_claimAutoreleasedReturnValue([v52 publicIdentityClassA:&v98]);
              id v77 = v98;
              uint64_t v78 = v77;
              if (!v76 || v77)
              {
                if (p_class_meths[290] != (__objc2_meth_list *)-1LL) {
                  dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
                }
                if (_NRLogIsLevelEnabled(v24[289], 16LL))
                {
                  if (p_class_meths[290] != (__objc2_meth_list *)-1LL) {
                    dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
                  }
                  uint64_t v50 = v24[289];
                  id v51 = (void *)objc_claimAutoreleasedReturnValue([v53 UUIDString]);
                  _NRLogWithArgs( v50,  16LL,  "%s%.30s:%-4d Failed to ingest IDS remote classA identity for bluetoothUUID %@: %@",  "",  "-[NRDIDSKeyManager ingestIDSPairedDevicesRecords:]",  224LL,  v51,  v78);

                  uint64_t v48 = v95;
                  id v52 = v97;
                }
              }

              else
              {
                int v79 = (const void *)sub_1000F07B0(v48, v76);
                if (p_class_meths[290] != (__objc2_meth_list *)-1LL) {
                  dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
                }
                if (_NRLogIsLevelEnabled(v24[289], 0LL))
                {
                  if (p_class_meths[290] != (__objc2_meth_list *)-1LL) {
                    dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
                  }
                  uint64_t v80 = v24[289];
                  uint64_t v81 = (void *)objc_claimAutoreleasedReturnValue([v53 UUIDString]);
                  if (v79)
                  {
                    id v105 = 0LL;
                    SecKeyCopyPublicBytes(v79, &v105);
                    id v82 = v105;
                    id v105 = 0LL;
                    id v83 = (__CFString *)_NRKeyCreateLogString(v82);

                    uint64_t v48 = v95;
                  }

                  else
                  {
                    id v83 = @"[nil]";
                  }

                  _NRLogWithArgs( v80,  0LL,  "%s%.30s:%-4d Ingested IDS remote classA identity for BT<%@> %@",  "",  "-[NRDIDSKeyManager ingestIDSPairedDevicesRecords:]",  219LL,  v81,  v83);

                  p_class_meths = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
                  xpc_object_t v24 = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
                  id v52 = v97;
                }

                if (v54) {
                  objc_storeStrong((id *)&v54->_remoteIDSClassAIdentity, v76);
                }
                if (v79) {
                  CFRelease(v79);
                }
              }

              [*(id *)(v48 + 48) setObject:v54 forKeyedSubscript:v53];
            }

            id v94 = [obj countByEnumeratingWithState:&v101 objects:v106 count:16];
          }

          while (v94);
        }

        id v47 = v91;
        uint64_t v1 = v92;
      }

      else
      {
        id v88 = sub_1000F0648();
        int v89 = _NRLogIsLevelEnabled(v88, 17LL);

        if (v89)
        {
          id v90 = sub_1000F0648();
          _NRLogWithArgs( v90,  17LL,  "%s called with null pairedDevicesRecords",  "-[NRDIDSKeyManager ingestIDSPairedDevicesRecords:]");
        }
      }
    }

    id result = *(id *)(v1 + 32);
    if (result)
    {
      id result = (id)sub_1000F1B3C(result, 0LL);
      uint64_t v84 = *(void *)(v1 + 32);
      if (v84)
      {
        if (*(_BYTE *)(v84 + 9))
        {
          *(_BYTE *)(v84 + 9) = 0;
          return (id)sub_1000F087C(*(void *)(v1 + 32), 0LL);
        }
      }
    }
  }

  else
  {
    sub_1000F1ABC(*(void *)(v1 + 32), 5502, @"%@ %@ %@", v6, v7, v8, v9, v10, v13);
    uint64_t v14 = *(void *)(v1 + 32);
    if (v14 && ((v15 = *(void *)(v14 + 56)) == 0 || (*(_BYTE *)(v15 + 16) = 0, (uint64_t v14 = *(void *)(v1 + 32)) != 0))) {
      int v16 = *(void **)(v14 + 56);
    }
    else {
      int v16 = 0LL;
    }
    return [v16 submit];
  }

  return result;
}

void sub_1000F1ABC( uint64_t a1, int a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1)
  {
    id v10 = a3;
    uint64_t v11 = -[NSString initWithFormat:arguments:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:arguments:",  v10,  &a9);

    sub_10011BB18(0LL, a2, &stru_1001B1528, v11);
  }

void sub_1000F1B3C(uint64_t a1, int a2)
{
  if (a1)
  {
    uint64_t v3 = a1;
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
    __int128 v90 = 0u;
    __int128 v91 = 0u;
    __int128 v88 = 0u;
    __int128 v89 = 0u;
    id v4 = *(id *)(v3 + 48);
    id v57 = [v4 countByEnumeratingWithState:&v88 objects:v95 count:16];
    if (v57)
    {
      int v5 = 0;
      int v6 = 0;
      uint64_t v55 = *(void *)v89;
      int v61 = a2;
      id v56 = v4;
      uint64_t v60 = v3;
      do
      {
        uint64_t v7 = 0LL;
        do
        {
          if (*(void *)v89 != v55) {
            objc_enumerationMutation(v4);
          }
          uint64_t v8 = *(void *)(*((void *)&v88 + 1) + 8 * v7);
          id v9 = *(id *)(v3 + 48);
          uint64_t v59 = v8;
          id v10 = (id *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:v8]);

          if (v10) {
            id v11 = v10[4];
          }
          else {
            id v11 = 0LL;
          }
          uint64_t v58 = v7;
          id v12 = [v11 copy];
          __int128 v84 = 0u;
          __int128 v85 = 0u;
          __int128 v86 = 0u;
          __int128 v87 = 0u;
          id obj = v12;
          id v71 = [obj countByEnumeratingWithState:&v84 objects:v94 count:16];
          if (v71)
          {
            uint64_t v70 = *(void *)v85;
            do
            {
              for (uint64_t i = 0LL; i != v71; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v85 != v70) {
                  objc_enumerationMutation(obj);
                }
                uint64_t v14 = *(void *)(*((void *)&v84 + 1) + 8LL * (void)i);
                if (v14)
                {
                  BOOL v15 = *(unsigned __int8 *)(v14 + 9) != 4;
                  BOOL v16 = (*(_BYTE *)(v14 + 9) - 5) < 0xFEu;
                }

                else
                {
                  BOOL v16 = 1;
                  BOOL v15 = 1;
                }

                id v17 = *(id *)(v3 + 24);
                if (!v17) {
                  goto LABEL_46;
                }
                if (!v10)
                {

LABEL_46:
                  if (v14)
                  {
                    if (*(_BYTE *)(v14 + 8))
                    {
                      v5 |= a2;
                    }

                    else
                    {
                      int v5 = 1;
                      *(_BYTE *)(v14 + _Block_object_dispose(va, 8) = 1;
                    }
                  }

                  else
                  {
                    int v5 = 1;
                  }

                  int v6 = 1;
                  continue;
                }

                id v18 = v10[1];

                if (!v18) {
                  goto LABEL_46;
                }
                if (v15)
                {
                  id v19 = *(id *)(v3 + 32);
                  if (!v19) {
                    goto LABEL_46;
                  }
                  id v20 = v10[2];

                  if (!v20) {
                    goto LABEL_46;
                  }
                }

                if (v16)
                {
                  id v21 = *(id *)(v3 + 40);
                  if (!v21) {
                    goto LABEL_46;
                  }
                  id v22 = v10[3];

                  if (!v22) {
                    goto LABEL_46;
                  }
                }

                if (qword_1001DC910 != -1) {
                  dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
                }
                if (_NRLogIsLevelEnabled(qword_1001DC908, 0LL))
                {
                  if (qword_1001DC910 != -1) {
                    dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
                  }
                  if (v14) {
                    uint64_t v23 = *(unsigned __int8 *)(v14 + 9);
                  }
                  else {
                    uint64_t v23 = 0LL;
                  }
                  id v24 = (id)qword_1001DC908;
                  String = (void *)NRDataProtectionClassCreateString(v23);
                  _NRLogWithArgs( v24,  0LL,  "%s%.30s:%-4d Completing query for %@ BT<%@>",  "",  "-[NRDIDSKeyManager checkOutstandingQueriesForceQueryIDS:]",  347LL,  String,  v59);
                }

                int v67 = v6;
                int v68 = v5;
                id v66 = *(id *)(v3 + 24);
                id v65 = *(id *)(v3 + 32);
                uint64_t v26 = v3;
                id v64 = *(id *)(v3 + 40);
                id v27 = v10[1];
                id v28 = v10[2];
                id v29 = v10[3];
                if (v14)
                {
                  id v30 = *(id *)(v14 + 16);
                  objc_setProperty_nonatomic_copy((id)v14, v31, 0LL, 16LL);
                }

                else
                {
                  id v30 = 0LL;
                }

                [v10[4] removeObject:v14];
                if (![v10[4] count])
                {
                  id v32 = v10[4];
                  v10[4] = 0LL;
                }

                id v33 = *(dispatch_queue_s **)(v26 + 16);
                block[0] = _NSConcreteStackBlock;
                block[1] = 3221225472LL;
                block[2] = sub_1000F23BC;
                block[3] = &unk_1001AF730;
                id v82 = v29;
                id v83 = v30;
                id v77 = v66;
                id v78 = v65;
                id v79 = v64;
                id v80 = v27;
                id v81 = v28;
                id v63 = v29;
                id v62 = v28;
                id v34 = v27;
                id v35 = v64;
                id v36 = v65;
                id v37 = v66;
                id v38 = v30;
                dispatch_async(v33, block);

                uint64_t v3 = v60;
                a2 = v61;
                int v6 = v67;
                int v5 = v68;
              }

              id v71 = [obj countByEnumeratingWithState:&v84 objects:v94 count:16];
            }

            while (v71);
          }

          uint64_t v7 = v58 + 1;
          id v4 = v56;
        }

        while ((id)(v58 + 1) != v57);
        id v57 = [v56 countByEnumeratingWithState:&v88 objects:v95 count:16];
      }

      while (v57);

      if ((v5 & 1) != 0) {
        sub_1000F087C(v3, a2);
      }
      if ((v6 & 1) != 0)
      {
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 16));
        if (*(_BYTE *)(v3 + 10)) {
          return;
        }
        *(_BYTE *)(v3 + 10) = 1;
        objc_opt_self(&OBJC_CLASS___NRDKeyManager);
        if (qword_1001DCC18 != -1) {
          dispatch_once(&qword_1001DCC18, &stru_1001B0910);
        }
        id v39 = (dispatch_queue_t *)(id)qword_1001DCC10;
        v92[0] = _NSConcreteStackBlock;
        v92[1] = 3221225472LL;
        v92[2] = sub_1000F23D8;
        v92[3] = &unk_1001AF708;
        v92[4] = v3;
        id v40 = v92;
        if (v39)
        {
          dispatch_assert_queue_V2(v39[2]);
          if (qword_1001DCC28 != -1) {
            dispatch_once(&qword_1001DCC28, &stru_1001B0980);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
          {
            if (qword_1001DCC28 != -1) {
              dispatch_once(&qword_1001DCC28, &stru_1001B0980);
            }
            _NRLogWithArgs( qword_1001DCC20,  0LL,  "%s%.30s:%-4d Registering for IDS key manager data protection class updates",  "",  "-[NRDKeyManager registerForIDSKeyManagerUpdates:]",  99);
          }

          int v41 = objc_retainBlock(v40);
          dispatch_queue_t v42 = v39[3];
          v39[3] = v41;

          sub_10014395C((uint64_t)v39);
        }

        goto LABEL_68;
      }
    }

    else
    {
    }

    __int128 v74 = 0u;
    __int128 v75 = 0u;
    __int128 v72 = 0u;
    __int128 v73 = 0u;
    id v39 = (dispatch_queue_t *)*(id *)(v3 + 48);
    id v43 = -[dispatch_queue_t countByEnumeratingWithState:objects:count:]( v39,  "countByEnumeratingWithState:objects:count:",  &v72,  v93,  16LL);
    if (v43)
    {
      id v44 = v43;
      uint64_t v45 = *(void *)v73;
LABEL_72:
      uint64_t v46 = 0LL;
      while (1)
      {
        if (*(void *)v73 != v45) {
          objc_enumerationMutation(v39);
        }
        uint64_t v47 = *(void *)(*((void *)&v72 + 1) + 8 * v46);
        id v48 = *(id *)(v3 + 48);
        int v49 = (void *)objc_claimAutoreleasedReturnValue([v48 objectForKeyedSubscript:v47]);
        uint64_t v50 = v49;
        if (v49) {
          int v49 = (void *)v49[4];
        }
        id v51 = [v49 count];

        if (v51) {
          break;
        }
        if (v44 == (id)++v46)
        {
          id v44 = -[dispatch_queue_t countByEnumeratingWithState:objects:count:]( v39,  "countByEnumeratingWithState:objects:count:",  &v72,  v93,  16LL);
          if (v44) {
            goto LABEL_72;
          }
          goto LABEL_80;
        }
      }

uint64_t sub_1000F23BC(void *a1)
{
  return (*(uint64_t (**)(void, void, void, void, void, void, void))(a1[10] + 16LL))( a1[10],  a1[4],  a1[5],  a1[6],  a1[7],  a1[8],  a1[9]);
}

uint64_t sub_1000F23D8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    uint64_t v3 = *(dispatch_queue_s **)(v2 + 16);
  }
  else {
    uint64_t v3 = 0LL;
  }
  dispatch_assert_queue_V2(v3);
  return sub_1000F1B3C(*(void *)(a1 + 32), 1LL);
}

void sub_1000F2414(id a1)
{
  uint64_t v1 = (dispatch_queue_attr_s *)_NRCopySerialQueueAttr(a1);
  dispatch_queue_t v2 = dispatch_queue_create("terminusd.IdentityServices.pairingRecords", v1);

  if (!v2)
  {
    id v4 = sub_1000F0648();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16LL);

    if (IsLevelEnabled)
    {
      id v6 = sub_1000F0648();
      _NRLogWithArgs( v6,  16LL,  "%s%.30s:%-4d ABORTING: dispatch_queue_create(%s) failed",  "",  "nr_dispatch_queue_create",  118,  "terminusd.IdentityServices.pairingRecords");
    }

    uint64_t v7 = _os_log_pack_size(22LL);
    uint64_t v8 = (char *)&v12 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v9 = __error();
    uint64_t v10 = _os_log_pack_fill( v8,  v7,  *v9,  &_mh_execute_header,  "%{public}s dispatch_queue_create(%s) failed");
    *(_DWORD *)uint64_t v10 = 136446466;
    *(void *)(v10 + 4) = "nr_dispatch_queue_create";
    *(_WORD *)(v10 + 12) = 2080;
    *(void *)(v10 + 14) = "terminusd.IdentityServices.pairingRecords";
    id v11 = sub_1000F0648();
    _NRLogAbortWithPack(v11, v8);
  }

  uint64_t v3 = (void *)qword_1001DC920;
  qword_1001DC920 = (uint64_t)v2;
}

void sub_1000F257C(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v38 = a2;
  id v7 = a4;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
  if (v7)
  {
    uint64_t v8 = objc_alloc_init(&OBJC_CLASS___NRIDSKMOutstandingQuery);
    if (v8)
    {
      id v10 = v8;
      v8->_minDataProtectionClass = a3;
      objc_setProperty_nonatomic_copy(v8, v9, v7, 16LL);
      if (qword_1001DC910 != -1) {
        dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC908, 0LL))
      {
        if (qword_1001DC910 != -1) {
          dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
        }
        id v11 = (id)qword_1001DC908;
        String = (void *)NRDataProtectionClassCreateString(a3);
        _NRLogWithArgs( v11,  0LL,  "%s%.30s:%-4d Adding query %p for %@ BT<%@>",  "",  "-[NRDIDSKeyManager internalQueryIDSKeysForBluetoothUUID:minDataProtectionClass:completionBlock:]",  412LL,  v10,  String,  v38);
      }

      uint64_t v13 = (NRDIDSKMDeviceRecord *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 48), "objectForKeyedSubscript:", v38, v38));
      if (v13 || (uint64_t v13 = objc_alloc_init(&OBJC_CLASS___NRDIDSKMDeviceRecord)) != 0LL)
      {
        outstandingQueries = v13->_outstandingQueries;
        if (outstandingQueries
          || (BOOL v15 = objc_alloc_init(&OBJC_CLASS___NSMutableArray),
              BOOL v16 = v13->_outstandingQueries,
              v13->_outstandingQueries = v15,
              v16,
              (outstandingQueries = v13->_outstandingQueries) != 0LL))
        {
          -[NSMutableArray addObject:](outstandingQueries, "addObject:", v10);
          [*(id *)(a1 + 48) setObject:v13 forKeyedSubscript:v38];
          sub_1000F1B3C(a1, 0);

          goto LABEL_14;
        }

        id v31 = sub_1000F0648();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v31, 16LL);

        if (IsLevelEnabled)
        {
          id v33 = sub_1000F0648();
          _NRLogWithArgs( v33,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (deviceRecord.outstandingQueries) != ((void *)0)",  "",  "-[NRDIDSKeyManager internalQueryIDSKeysForBluetoothUUID:minDataProtectionClass:completionBlock:]",  421);
        }

        uint64_t v34 = _os_log_pack_size(12LL);
        uint64_t v23 = (char *)&v38 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        id v35 = __error();
        uint64_t v36 = _os_log_pack_fill( v23,  v34,  *v35,  &_mh_execute_header,  "%{public}s Assertion Failed: (deviceRecord.outstandingQueries) != ((void *)0)");
        *(_DWORD *)uint64_t v36 = 136446210;
        *(void *)(v36 + 4) = "-[NRDIDSKeyManager internalQueryIDSKeysForBluetoothUUID:minDataProtectionClass:completionBlock:]";
LABEL_28:
        id v37 = sub_1000F0648();
        _NRLogAbortWithPack(v37, v23);
      }

      id v26 = sub_1000F0648();
      int v27 = _NRLogIsLevelEnabled(v26, 16LL);

      if (v27)
      {
        id v28 = sub_1000F0648();
        _NRLogWithArgs( v28,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (deviceRecord) != ((void *)0)",  "",  "-[NRDIDSKeyManager internalQueryIDSKeysForBluetoothUUID:minDataProtectionClass:completionBlock:]",  417);
      }

      uint64_t v29 = _os_log_pack_size(12LL);
      uint64_t v23 = (char *)&v38 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v30 = *__error();
      uint64_t v25 = _os_log_pack_fill( v23,  v29,  v30,  &_mh_execute_header,  "%{public}s Assertion Failed: (deviceRecord) != ((void *)0)",  v38);
    }

    else
    {
      id v19 = sub_1000F0648();
      int v20 = _NRLogIsLevelEnabled(v19, 16LL);

      if (v20)
      {
        id v21 = sub_1000F0648();
        _NRLogWithArgs( v21,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (outstandingQuery) != ((void *)0)",  "",  "-[NRDIDSKeyManager internalQueryIDSKeysForBluetoothUUID:minDataProtectionClass:completionBlock:]",  407);
      }

      uint64_t v22 = _os_log_pack_size(12LL);
      uint64_t v23 = (char *)&v38 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v24 = *__error();
      uint64_t v25 = _os_log_pack_fill( v23,  v22,  v24,  &_mh_execute_header,  "%{public}s Assertion Failed: (outstandingQuery) != ((void *)0)",  v38);
    }

    *(_DWORD *)uint64_t v25 = 136446210;
    *(void *)(v25 + 4) = "-[NRDIDSKeyManager internalQueryIDSKeysForBluetoothUUID:minDataProtectionClass:completionBlock:]";
    goto LABEL_28;
  }

  id v17 = sub_1000F0648();
  int v18 = _NRLogIsLevelEnabled(v17, 17LL);

  if (!v18) {
    goto LABEL_15;
  }
  id v10 = sub_1000F0648();
  _NRLogWithArgs( v10,  17LL,  "%s called with null completionBlock",  "-[NRDIDSKeyManager internalQueryIDSKeysForBluetoothUUID:minDataProtectionClass:completionBlock:]");
LABEL_14:

LABEL_15:
}

void sub_1000F29F4(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7)
{
  id v13 = a2;
  id v14 = a3;
  id v15 = a4;
  id v16 = a5;
  id v87 = a6;
  id v86 = a7;
  uint64_t v17 = *(void *)(a1 + 32);
  if (v17)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v17 + 16));
    if (v13) {
      goto LABEL_3;
    }
LABEL_67:
    id v80 = sub_1000F0648();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v80, 17LL);

    if (!IsLevelEnabled) {
      goto LABEL_55;
    }
    id v71 = sub_1000F0648();
    _NRLogWithArgs(v71, 17LL, "%s called with null localIDSClassDIdentity");
    goto LABEL_69;
  }

  dispatch_assert_queue_V2(0LL);
  if (!v13) {
    goto LABEL_67;
  }
LABEL_3:
  if (!v16)
  {
    id v69 = sub_1000F0648();
    int v70 = _NRLogIsLevelEnabled(v69, 17LL);

    if (!v70) {
      goto LABEL_55;
    }
    id v71 = sub_1000F0648();
    _NRLogWithArgs(v71, 17LL, "%s called with null remoteIDSClassDIdentity");
LABEL_69:

    goto LABEL_55;
  }

  int v18 = *(unsigned __int8 *)(a1 + 80);
  if ((v18 | 2) != 3) {
    goto LABEL_10;
  }
  if (!v14)
  {
    id v72 = sub_1000F0648();
    int v73 = _NRLogIsLevelEnabled(v72, 17LL);

    if (!v73) {
      goto LABEL_55;
    }
    id v71 = sub_1000F0648();
    _NRLogWithArgs(v71, 17LL, "%s called with null localIDSClassCIdentity");
    goto LABEL_69;
  }

  if (!v87)
  {
    id v74 = sub_1000F0648();
    int v75 = _NRLogIsLevelEnabled(v74, 17LL);

    if (!v75) {
      goto LABEL_55;
    }
    id v71 = sub_1000F0648();
    _NRLogWithArgs(v71, 17LL, "%s called with null remoteIDSClassCIdentity");
    goto LABEL_69;
  }

  if (v18 != 1) {
    goto LABEL_10;
  }
  if (!v15)
  {
    id v76 = sub_1000F0648();
    int v77 = _NRLogIsLevelEnabled(v76, 17LL);

    if (!v77) {
      goto LABEL_55;
    }
    id v71 = sub_1000F0648();
    _NRLogWithArgs(v71, 17LL, "%s called with null localIDSClassAIdentity");
    goto LABEL_69;
  }

  if (!v86)
  {
    id v78 = sub_1000F0648();
    int v79 = _NRLogIsLevelEnabled(v78, 17LL);

    if (!v79) {
      goto LABEL_55;
    }
    id v71 = sub_1000F0648();
    _NRLogWithArgs(v71, 17LL, "%s called with null remoteIDSClassAIdentity");
    goto LABEL_69;
  }

void sub_1000F304C(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  id v7 = a2;
  id v8 = a5;
  uint64_t v9 = a1[4];
  if (v9)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v9 + 16));
    if (v7) {
      goto LABEL_3;
    }
LABEL_19:
    id v26 = sub_1000F0648();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v26, 17LL);

    if (!IsLevelEnabled) {
      goto LABEL_15;
    }
    id v25 = sub_1000F0648();
    _NRLogWithArgs(v25, 17LL, "%s called with null localIDSClassDIdentity");
    goto LABEL_21;
  }

  dispatch_assert_queue_V2(0LL);
  if (!v7) {
    goto LABEL_19;
  }
LABEL_3:
  if (!v8)
  {
    id v23 = sub_1000F0648();
    int v24 = _NRLogIsLevelEnabled(v23, 17LL);

    if (!v24) {
      goto LABEL_15;
    }
    id v25 = sub_1000F0648();
    _NRLogWithArgs(v25, 17LL, "%s called with null remoteIDSClassDIdentity");
LABEL_21:

    goto LABEL_15;
  }

  uint64_t v10 = a1[5];
  id v28 = 0LL;
  id v11 = (void *)objc_claimAutoreleasedReturnValue([v7 verifyAndExposeData:v10 withSigner:v8 error:&v28]);
  id v17 = v28;
  if (v17 || !v11)
  {
    if (qword_1001DC910 != -1) {
      dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC908, 17LL))
    {
      if (qword_1001DC910 != -1) {
        dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
      }
      _NRLogWithArgs(qword_1001DC908, 17LL, "Failed to decrypt and check classD TLV for %@: %@", a1[6], v17);
    }

    sub_1000F1ABC(a1[4], 5506, @"ClassD BT<%@>: %@", v18, v19, v20, v21, v22, a1[6]);
  }

  else
  {
    sub_1000F1ABC(a1[4], 5505, @"ClassD BT<%@>", v12, v13, v14, v15, v16, a1[6]);
  }

  (*(void (**)(void))(a1[7] + 16))();

LABEL_15:
}

void sub_1000F324C(uint64_t *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, void *a6)
{
  id v8 = a3;
  id v9 = a6;
  uint64_t v10 = a1[4];
  if (v10)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v10 + 16));
    if (v8) {
      goto LABEL_3;
    }
LABEL_19:
    id v27 = sub_1000F0648();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v27, 17LL);

    if (!IsLevelEnabled) {
      goto LABEL_15;
    }
    id v26 = sub_1000F0648();
    _NRLogWithArgs(v26, 17LL, "%s called with null localIDSClassCIdentity");
    goto LABEL_21;
  }

  dispatch_assert_queue_V2(0LL);
  if (!v8) {
    goto LABEL_19;
  }
LABEL_3:
  if (!v9)
  {
    id v24 = sub_1000F0648();
    int v25 = _NRLogIsLevelEnabled(v24, 17LL);

    if (!v25) {
      goto LABEL_15;
    }
    id v26 = sub_1000F0648();
    _NRLogWithArgs(v26, 17LL, "%s called with null remoteIDSClassCIdentity");
LABEL_21:

    goto LABEL_15;
  }

  uint64_t v11 = a1[5];
  id v29 = 0LL;
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v8 verifyAndExposeData:v11 withSigner:v9 error:&v29]);
  id v18 = v29;
  if (v18 || !v12)
  {
    if (qword_1001DC910 != -1) {
      dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC908, 17LL))
    {
      if (qword_1001DC910 != -1) {
        dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
      }
      _NRLogWithArgs(qword_1001DC908, 17LL, "Failed to decrypt and check classC TLV for %@: %@", a1[6], v18);
    }

    sub_1000F1ABC(a1[4], 5506, @"ClassC BT<%@>: %@", v19, v20, v21, v22, v23, a1[6]);
  }

  else
  {
    sub_1000F1ABC(a1[4], 5505, @"ClassC BT<%@>", v13, v14, v15, v16, v17, a1[6]);
  }

  (*(void (**)(void))(a1[7] + 16))();

LABEL_15:
}

void sub_1000F344C(uint64_t *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, void *a7)
{
  id v9 = a4;
  id v10 = a7;
  uint64_t v11 = a1[4];
  if (v11)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v11 + 16));
    if (v9) {
      goto LABEL_3;
    }
LABEL_25:
    id v28 = sub_1000F0648();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v28, 17LL);

    if (!IsLevelEnabled) {
      goto LABEL_21;
    }
    id v27 = sub_1000F0648();
    _NRLogWithArgs(v27, 17LL, "%s called with null localIDSClassAIdentity");
    goto LABEL_27;
  }

  dispatch_assert_queue_V2(0LL);
  if (!v9) {
    goto LABEL_25;
  }
LABEL_3:
  if (!v10)
  {
    id v25 = sub_1000F0648();
    int v26 = _NRLogIsLevelEnabled(v25, 17LL);

    if (!v26) {
      goto LABEL_21;
    }
    id v27 = sub_1000F0648();
    _NRLogWithArgs(v27, 17LL, "%s called with null remoteIDSClassAIdentity");
LABEL_27:

    goto LABEL_21;
  }

  uint64_t v12 = a1[5];
  id v30 = 0LL;
  uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v9 verifyAndExposeData:v12 withSigner:v10 error:&v30]);
  id v19 = v30;
  if (v19 || !v13)
  {
    if (qword_1001DC910 != -1) {
      dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC908, 16LL))
    {
      if (qword_1001DC910 != -1) {
        dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
      }
      _NRLogWithArgs( qword_1001DC908,  16LL,  "%s%.30s:%-4d Failed to decrypt and check classA TLV for BT<%@>: %@, remotePublicClassAKeys=%@",  "",  "-[NRDIDSKeyManager decryptRemoteClassAKeysEncryptedWithIDS:bluetoothUUID:decryptCompletionBlock:]_block_invoke",  697LL,  a1[6],  v19,  v13);
    }

    if (qword_1001DC910 != -1) {
      dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC908, 17LL))
    {
      if (qword_1001DC910 != -1) {
        dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
      }
      _NRLogWithArgs(qword_1001DC908, 17LL, "Failed to decrypt and check classA TLV for %@: %@", a1[6], v19);
    }

    sub_1000F1ABC(a1[4], 5506, @"ClassA BT<%@>: %@", v20, v21, v22, v23, v24, a1[6]);
  }

  else
  {
    sub_1000F1ABC(a1[4], 5505, @"ClassA BT<%@>", v14, v15, v16, v17, v18, a1[6]);
  }

  (*(void (**)(void))(a1[7] + 16))();

LABEL_21:
}

NSMutableArray *sub_1000F4294(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (!a1)
  {
LABEL_23:
    id v9 = 0LL;
    goto LABEL_20;
  }

  if (!v3)
  {
    id v16 = sub_1000F4464();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v16, 17LL);

    if (IsLevelEnabled)
    {
      id v18 = sub_1000F4464();
      _NRLogWithArgs( v18,  17LL,  "%s called with null asName",  "-[NRApplicationServiceManager copyResolverPublicKeysForASName:]");
    }

    goto LABEL_23;
  }

  int v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) objectForKeyedSubscript:v3]);
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  id v6 = v5;
  id v7 = [v6 countByEnumeratingWithState:&v19 objects:v23 count:16];
  if (v7)
  {
    id v8 = v7;
    id v9 = 0LL;
    uint64_t v10 = *(void *)v20;
    do
    {
      for (uint64_t i = 0LL; i != v8; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v20 != v10) {
          objc_enumerationMutation(v6);
        }
        uint64_t v12 = *(void *)(*((void *)&v19 + 1) + 8LL * (void)i);
        if (v12) {
          uint64_t v13 = *(void **)(v12 + 40);
        }
        else {
          uint64_t v13 = 0LL;
        }
        uint64_t v14 = (void *)sub_1000F44A4(v13);
        if (v14)
        {
          if (!v9) {
            id v9 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
          }
        }
      }

      id v8 = [v6 countByEnumeratingWithState:&v19 objects:v23 count:16];
    }

    while (v8);
  }

  else
  {
    id v9 = 0LL;
  }

LABEL_20:
  return v9;
}

id sub_1000F4464()
{
  if (qword_1001DC940 != -1) {
    dispatch_once(&qword_1001DC940, &stru_1001AF878);
  }
  return (id)qword_1001DC938;
}

uint64_t sub_1000F44A4(void *a1)
{
  id v1 = a1;
  dispatch_queue_t v2 = (nw_parameters *)nw_agent_client_copy_parameters();
  id v3 = nw_parameters_copy_default_protocol_stack(v2);
  uint64_t v7 = 0LL;
  id v8 = &v7;
  uint64_t v9 = 0x3032000000LL;
  uint64_t v10 = sub_1000F45A0;
  uint64_t v11 = sub_1000F45B0;
  id v12 = 0LL;
  iterate_block[0] = _NSConcreteStackBlock;
  iterate_block[1] = 3221225472LL;
  iterate_block[2] = sub_1000F45B8;
  iterate_block[3] = &unk_1001AF858;
  iterate_void block[4] = &v7;
  nw_protocol_stack_iterate_application_protocols(v3, iterate_block);
  if (v8[5]) {
    uint64_t v4 = nw_quic_options_copy_local_public_key();
  }
  else {
    uint64_t v4 = 0LL;
  }
  _Block_object_dispose(&v7, 8);

  return v4;
}

void sub_1000F4588( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_1000F45A0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1000F45B0(uint64_t a1)
{
}

void sub_1000F45B8(uint64_t a1, void *a2)
{
  uint64_t v4 = a2;
  int v5 = v4;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL))
  {
    uint64_t v7 = v4;
    BOOL is_quic = nw_protocol_options_is_quic(v4);
    int v5 = v7;
    if (is_quic)
    {
      objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL), a2);
      int v5 = v7;
    }
  }
}

void sub_1000F4624(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  dispatch_queue_t v2 = (void *)qword_1001DC938;
  qword_1001DC938 = (uint64_t)v1;
}

void sub_1000F4654(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = sub_1000F4D2C((id *)objc_alloc(&OBJC_CLASS___NRASMListenRequest), v5);
  uint64_t v9 = v7;
  if (v7)
  {
    objc_setProperty_nonatomic_copy(v7, v8, v6, 48LL);
    id v10 = sub_1000F4BC0((uint64_t)v9);
    uint64_t v11 = qword_1001DC940;
    if (v10)
    {
      id v12 = v10;
      if (qword_1001DC940 != -1) {
        dispatch_once(&qword_1001DC940, &stru_1001AF878);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC938, 0LL))
      {
        if (qword_1001DC940 != -1) {
          dispatch_once(&qword_1001DC940, &stru_1001AF878);
        }
        id v13 = v9[2];
        id v14 = (id)qword_1001DC938;
        _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d received start advertise request for %@ (%p) from %@",  "",  "-[NRApplicationServiceManager setupListenerAgent]_block_invoke",  684LL,  v12,  v5,  v13);
      }

      uint64_t v15 = *(void *)(a1 + 32);
      if (v15) {
        id v16 = *(void **)(v15 + 24);
      }
      else {
        id v16 = 0LL;
      }
      [v16 setObject:v9 forKeyedSubscript:v12];
      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
      v24[0] = 0LL;
      v24[1] = 0LL;
      [v17 getUUIDBytes:v24];
      id application_service = (void *)nw_endpoint_create_application_service([v12 UTF8String], v24);
      v23[0] = 0LL;
      v23[1] = 0LL;
      uint64_t v19 = *(void *)(a1 + 32);
      if (v19) {
        __int128 v20 = *(void **)(v19 + 88);
      }
      else {
        __int128 v20 = 0LL;
      }
      [v20 getUUIDBytes:v23];
      uint64_t v21 = nw_endpoint_set_agent_identifier(application_service, v23);
      __int128 v22 = (void *)nw_array_create(v21);
      nw_array_append(v22, application_service);
      (*((void (**)(id, void *))v6 + 2))(v6, v22);
      sub_1000F4F4C(*(id **)(a1 + 32));

      goto LABEL_22;
    }
  }

  else
  {
    uint64_t v11 = qword_1001DC940;
  }

  if (v11 != -1) {
    dispatch_once(&qword_1001DC940, &stru_1001AF878);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC938, 16LL))
  {
    if (qword_1001DC940 != -1) {
      dispatch_once(&qword_1001DC940, &stru_1001AF878);
    }
    _NRLogWithArgs( qword_1001DC938,  16LL,  "%s%.30s:%-4d received start advertise request without an appsvc name",  "",  "-[NRApplicationServiceManager setupListenerAgent]_block_invoke",  681);
  }

  id v12 = 0LL;
LABEL_22:
}

void sub_1000F490C(uint64_t a1, void *a2)
{
  id v3 = a2;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4) {
    id v5 = *(void **)(v4 + 24);
  }
  else {
    id v5 = 0LL;
  }
  id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 allValues]);
  id v7 = [v6 countByEnumeratingWithState:&v19 objects:v23 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v20;
    while (2)
    {
      id v10 = 0LL;
      do
      {
        if (*(void *)v20 != v9) {
          objc_enumerationMutation(v6);
        }
        uint64_t v11 = *(void **)(*((void *)&v19 + 1) + 8LL * (void)v10);
        if (v11)
        {
          if ((id)v11[5] == v3) {
            goto LABEL_16;
          }
        }

        else if (!v3)
        {
LABEL_16:
          id v13 = v11;

          if (!v11) {
            goto LABEL_26;
          }
          id v14 = sub_1000F4BC0((uint64_t)v13);
          if (qword_1001DC940 != -1) {
            dispatch_once(&qword_1001DC940, &stru_1001AF878);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC938, 0LL))
          {
            if (qword_1001DC940 != -1) {
              dispatch_once(&qword_1001DC940, &stru_1001AF878);
            }
            uint64_t v15 = v13[2];
            id v16 = (id)qword_1001DC938;
            _NRLogWithArgs( v16,  0LL,  "%s%.30s:%-4d received stop advertise request for %@ (%p) from %@",  "",  "-[NRApplicationServiceManager setupListenerAgent]_block_invoke_2",  712LL,  v14,  v3,  v15,  (void)v19);
          }

          uint64_t v17 = *(void *)(a1 + 32);
          if (v17) {
            id v18 = *(void **)(v17 + 24);
          }
          else {
            id v18 = 0LL;
          }
          [v18 setObject:0 forKeyedSubscript:v14];

          goto LABEL_32;
        }

        id v10 = (char *)v10 + 1;
      }

      while (v8 != v10);
      id v12 = [v6 countByEnumeratingWithState:&v19 objects:v23 count:16];
      id v8 = v12;
      if (v12) {
        continue;
      }
      break;
    }
  }

LABEL_26:
  if (qword_1001DC940 != -1) {
    dispatch_once(&qword_1001DC940, &stru_1001AF878);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC938, 16LL))
  {
    if (qword_1001DC940 != -1) {
      dispatch_once(&qword_1001DC940, &stru_1001AF878);
    }
    _NRLogWithArgs( qword_1001DC938,  16LL,  "%s%.30s:%-4d no listen request for client",  "",  "-[NRApplicationServiceManager setupListenerAgent]_block_invoke_2",  707);
  }

id sub_1000F4BC0(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 40))
    {
      dispatch_queue_t v2 = *(void **)(a1 + 24);
      if (v2) {
        return v2;
      }
      uint64_t v3 = objc_opt_class(&OBJC_CLASS___NRASMBrowseRequest);
      if ((objc_opt_isKindOfClass(a1, v3) & 1) != 0)
      {
        uint64_t v4 = (nw_browse_descriptor *)nw_agent_client_copy_browse_descriptor(*(void *)(a1 + 40));
        if (v4)
        {
          id v5 = v4;
          application_service_name = nw_browse_descriptor_get_application_service_name(v4);
          goto LABEL_13;
        }

id *sub_1000F4D2C(id *a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    v26.receiver = a1;
    v26.super_class = (Class)&OBJC_CLASS___NRASMRequest;
    id v5 = (id *)objc_msgSendSuper2(&v26, "init");
    if (!v5)
    {
      id v17 = sub_1000F4464();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v17, 16LL);

      if (IsLevelEnabled)
      {
        id v19 = sub_1000F4464();
        _NRLogWithArgs( v19,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRASMRequest initWithClient:]",  70);
      }

      uint64_t v20 = _os_log_pack_size(12LL);
      __int128 v21 = (char *)&v25 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      __int128 v22 = __error();
      uint64_t v23 = _os_log_pack_fill(v21, v20, *v22, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v23 = 136446210;
      *(void *)(v23 + 4) = "-[NRASMRequest initWithClient:]";
      id v24 = sub_1000F4464();
      _NRLogAbortWithPack(v24, v21);
    }

    id v6 = v5;
    objc_storeStrong(v5 + 5, a2);
    uint64_t v7 = (void *)nw_agent_client_copy_path(v4);
    v27[0] = 0LL;
    v27[1] = 0LL;
    nw_path_get_client_id(v7, v27);
    uint64_t v8 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v27);
    id v9 = v6[4];
    v6[4] = v8;

    id v10 = (void *)nw_agent_client_copy_parameters(v4);
    uint64_t pid = nw_parameters_get_pid(v10);
    uint64_t v12 = sub_10010393C(pid, 0);
    uint64_t account_id = (const char *)nw_parameters_get_account_id(v10);
    if (account_id && !strcmp(account_id, "com.apple.network.local-asquic")) {
      *((_BYTE *)v6 + _Block_object_dispose(va, 8) = 1;
    }
    id v14 = -[NSString initWithFormat:](objc_alloc(&OBJC_CLASS___NSString), "initWithFormat:", @"%@", v12);
    id v15 = v6[2];
    _DWORD v6[2] = v14;

    a1 = v6;
  }

  return a1;
}

void sub_1000F4F4C(id *a1)
{
  if (a1)
  {
    os_log_t v1 = a1;
    id v24 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    __int128 v38 = 0u;
    __int128 v39 = 0u;
    __int128 v40 = 0u;
    __int128 v41 = 0u;
    id obj = v1[7];
    id v2 = [obj countByEnumeratingWithState:&v38 objects:v44 count:16];
    if (v2)
    {
      id v3 = v2;
      uint64_t v4 = *(void *)v39;
      uint64_t v22 = *(void *)v39;
      uint64_t v23 = v1;
      do
      {
        id v5 = 0LL;
        id v25 = v3;
        do
        {
          if (*(void *)v39 != v4) {
            objc_enumerationMutation(obj);
          }
          id v6 = *(void **)(*((void *)&v38 + 1) + 8LL * (void)v5);
          uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v1[3] objectForKeyedSubscript:v6]);
          if (v7)
          {
            uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v1[7] objectForKeyedSubscript:v6]);
            if (v8)
            {
              uint64_t v9 = nw_array_create();
              id v28 = v8;
              nw_array_append(v9, v8);
              id v27 = (void *)v9;
              (*(void (**)(void))(v7[6] + 16LL))();
              __int128 v36 = 0u;
              __int128 v37 = 0u;
              __int128 v34 = 0u;
              __int128 v35 = 0u;
              id v10 = v1[6];
              id v11 = [v10 countByEnumeratingWithState:&v34 objects:v43 count:16];
              if (v11)
              {
                id v12 = v11;
                uint64_t v13 = *(void *)v35;
                do
                {
                  for (uint64_t i = 0LL; i != v12; uint64_t i = (char *)i + 1)
                  {
                    if (*(void *)v35 != v13) {
                      objc_enumerationMutation(v10);
                    }
                    uint64_t v15 = *(void *)(*((void *)&v34 + 1) + 8LL * (void)i);
                    if (v15) {
                      id v16 = *(dispatch_queue_s **)(v15 + 64);
                    }
                    else {
                      id v16 = 0LL;
                    }
                    block[0] = _NSConcreteStackBlock;
                    block[1] = 3221225472LL;
                    block[2] = sub_1000F5288;
                    block[3] = &unk_1001B0720;
                    void block[4] = v15;
                    void block[5] = v6;
                    dispatch_async(v16, block);
                  }

                  id v12 = [v10 countByEnumeratingWithState:&v34 objects:v43 count:16];
                }

                while (v12);
              }

              -[NSMutableArray addObject:](v24, "addObject:", v6);
              uint64_t v4 = v22;
              os_log_t v1 = v23;
              id v3 = v25;
              uint64_t v8 = v28;
            }
          }

          else
          {
            notify_post((const char *)[v6 UTF8String]);
          }

          id v5 = (char *)v5 + 1;
        }

        while (v5 != v3);
        id v3 = [obj countByEnumeratingWithState:&v38 objects:v44 count:16];
      }

      while (v3);
    }

    __int128 v31 = 0u;
    __int128 v32 = 0u;
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    id v17 = v24;
    id v18 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v17,  "countByEnumeratingWithState:objects:count:",  &v29,  v42,  16LL);
    if (v18)
    {
      id v19 = v18;
      uint64_t v20 = *(void *)v30;
      do
      {
        for (j = 0LL; j != v19; j = (char *)j + 1)
        {
          if (*(void *)v30 != v20) {
            objc_enumerationMutation(v17);
          }
          [v1[7] setObject:0 forKeyedSubscript:*(void *)(*((void *)&v29 + 1) + 8 * (void)j)];
        }

        id v19 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v17,  "countByEnumeratingWithState:objects:count:",  &v29,  v42,  16LL);
      }

      while (v19);
    }
  }

id sub_1000F5288(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "didCompleteIncomingResolveRequestForASName:asClient:", *(void *)(a1 + 40));
}

void sub_1000F5294(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = sub_1000F4D2C((id *)objc_alloc(&OBJC_CLASS___NRASMBrowseRequest), v5);
  uint64_t v9 = v7;
  if (v7)
  {
    objc_setProperty_nonatomic_copy(v7, v8, v6, 48LL);
    id v10 = sub_1000F4BC0((uint64_t)v9);
    uint64_t v11 = qword_1001DC940;
    if (v10)
    {
      id v12 = v10;
      if (qword_1001DC940 != -1) {
        dispatch_once(&qword_1001DC940, &stru_1001AF878);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC938, 0LL))
      {
        if (qword_1001DC940 != -1) {
          dispatch_once(&qword_1001DC940, &stru_1001AF878);
        }
        id v13 = v9[2];
        id v14 = (id)qword_1001DC938;
        _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d received start browse request for %@ (%p) from %@",  "",  "-[NRApplicationServiceManager setupResolverAgent]_block_invoke",  382LL,  v12,  v5,  v13);
      }

      uint64_t v15 = *(void *)(a1 + 32);
      if (v15) {
        id v16 = *(void **)(v15 + 32);
      }
      else {
        id v16 = 0LL;
      }
      id v17 = (NSMutableArray *)objc_claimAutoreleasedReturnValue([v16 objectForKeyedSubscript:v12]);
      if (!v17) {
        id v17 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      }
      -[NSMutableArray addObject:](v17, "addObject:", v9);
      uint64_t v18 = *(void *)(a1 + 32);
      if (v18) {
        id v19 = *(void **)(v18 + 32);
      }
      else {
        id v19 = 0LL;
      }
      [v19 setObject:v17 forKeyedSubscript:v12];
      __int128 v34 = 0u;
      __int128 v35 = 0u;
      __int128 v32 = 0u;
      __int128 v33 = 0u;
      uint64_t v20 = *(void **)(a1 + 32);
      id v29 = v5;
      id v28 = v9;
      if (v20) {
        uint64_t v20 = (void *)v20[6];
      }
      __int128 v21 = v20;
      id v22 = [v21 countByEnumeratingWithState:&v32 objects:v36 count:16];
      if (v22)
      {
        id v23 = v22;
        uint64_t v24 = *(void *)v33;
        do
        {
          for (uint64_t i = 0LL; i != v23; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v33 != v24) {
              objc_enumerationMutation(v21);
            }
            uint64_t v26 = *(void *)(*((void *)&v32 + 1) + 8LL * (void)i);
            if (v26) {
              id v27 = *(dispatch_queue_s **)(v26 + 64);
            }
            else {
              id v27 = 0LL;
            }
            block[0] = _NSConcreteStackBlock;
            block[1] = 3221225472LL;
            block[2] = sub_1000F6624;
            block[3] = &unk_1001B0720;
            void block[4] = v26;
            id v31 = v12;
            dispatch_async(v27, block);
          }

          id v23 = [v21 countByEnumeratingWithState:&v32 objects:v36 count:16];
        }

        while (v23);
      }

      id v5 = v29;
      uint64_t v9 = v28;
      goto LABEL_37;
    }
  }

  else
  {
    uint64_t v11 = qword_1001DC940;
  }

  if (v11 != -1) {
    dispatch_once(&qword_1001DC940, &stru_1001AF878);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC938, 16LL))
  {
    if (qword_1001DC940 != -1) {
      dispatch_once(&qword_1001DC940, &stru_1001AF878);
    }
    _NRLogWithArgs( qword_1001DC938,  16LL,  "%s%.30s:%-4d received start browse request without an appsvc name",  "",  "-[NRApplicationServiceManager setupResolverAgent]_block_invoke",  379);
  }

  id v12 = 0LL;
LABEL_37:
}

void sub_1000F5614(uint64_t a1, void *a2)
{
  id v3 = a2;
  __int128 v50 = 0u;
  __int128 v51 = 0u;
  __int128 v52 = 0u;
  __int128 v53 = 0u;
  uint64_t v39 = a1;
  uint64_t v4 = *(void **)(a1 + 32);
  if (v4) {
    uint64_t v4 = (void *)v4[4];
  }
  id v5 = v4;
  id v6 = [v5 countByEnumeratingWithState:&v50 objects:v56 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v51;
    do
    {
      for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v51 != v8) {
          objc_enumerationMutation(v5);
        }
        uint64_t v11 = *(void *)(v39 + 32);
        if (v11) {
          id v12 = *(void **)(v11 + 32);
        }
        else {
          id v12 = 0LL;
        }
        id v13 = (void *)objc_claimAutoreleasedReturnValue( [v12 objectForKeyedSubscript:*(void *)(*((void *)&v50 + 1) + 8 * (void)i)]);
        __int128 v46 = 0u;
        __int128 v47 = 0u;
        __int128 v48 = 0u;
        __int128 v49 = 0u;
        id v14 = v13;
        id v15 = [v14 countByEnumeratingWithState:&v46 objects:v55 count:16];
        if (v15)
        {
          id v16 = v15;
          uint64_t v17 = *(void *)v47;
          while (2)
          {
            uint64_t v18 = 0LL;
            do
            {
              if (*(void *)v47 != v17) {
                objc_enumerationMutation(v14);
              }
              id v19 = *(void **)(*((void *)&v46 + 1) + 8LL * (void)v18);
              if (v19)
              {
                if ((id)v19[5] == v3) {
                  goto LABEL_7;
                }
              }

              else if (!v3)
              {
LABEL_7:
                id v10 = v19;

                if (!v19) {
                  goto LABEL_8;
                }

                id v21 = sub_1000F4BC0((uint64_t)v10);
                if (v21)
                {
                  if (qword_1001DC940 != -1) {
                    dispatch_once(&qword_1001DC940, &stru_1001AF878);
                  }
                  if (_NRLogIsLevelEnabled(qword_1001DC938, 0LL))
                  {
                    if (qword_1001DC940 != -1) {
                      dispatch_once(&qword_1001DC940, &stru_1001AF878);
                    }
                    uint64_t v22 = v10[2];
                    id v23 = (id)qword_1001DC938;
                    _NRLogWithArgs( v23,  0LL,  "%s%.30s:%-4d received stop browse request for %@ (%p) from %@",  "",  "-[NRApplicationServiceManager setupResolverAgent]_block_invoke_3",  421LL,  v21,  v3,  v22);
                  }

                  uint64_t v24 = *(void *)(v39 + 32);
                  if (v24) {
                    id v25 = *(void **)(v24 + 32);
                  }
                  else {
                    id v25 = 0LL;
                  }
                  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v25 objectForKeyedSubscript:v21]);
                  [v26 removeObject:v10];
                  if (![v26 count])
                  {
                    uint64_t v27 = *(void *)(v39 + 32);
                    if (v27) {
                      id v28 = *(void **)(v27 + 32);
                    }
                    else {
                      id v28 = 0LL;
                    }
                    [v28 setObject:0 forKeyedSubscript:v21];
                    __int128 v44 = 0u;
                    __int128 v45 = 0u;
                    __int128 v42 = 0u;
                    __int128 v43 = 0u;
                    id v29 = *(void **)(v39 + 32);
                    __int128 v37 = v26;
                    __int128 v38 = v10;
                    if (v29) {
                      id v29 = (void *)v29[6];
                    }
                    __int128 v30 = v29;
                    id v31 = [v30 countByEnumeratingWithState:&v42 objects:v54 count:16];
                    if (v31)
                    {
                      id v32 = v31;
                      uint64_t v33 = *(void *)v43;
                      do
                      {
                        for (j = 0LL; j != v32; j = (char *)j + 1)
                        {
                          if (*(void *)v43 != v33) {
                            objc_enumerationMutation(v30);
                          }
                          uint64_t v35 = *(void *)(*((void *)&v42 + 1) + 8LL * (void)j);
                          if (v35) {
                            __int128 v36 = *(dispatch_queue_s **)(v35 + 64);
                          }
                          else {
                            __int128 v36 = 0LL;
                          }
                          block[0] = _NSConcreteStackBlock;
                          block[1] = 3221225472LL;
                          block[2] = sub_1000F6618;
                          block[3] = &unk_1001B0720;
                          void block[4] = v35;
                          id v41 = v21;
                          dispatch_async(v36, block);
                        }

                        id v32 = [v30 countByEnumeratingWithState:&v42 objects:v54 count:16];
                      }

                      while (v32);
                    }

                    uint64_t v26 = v37;
                    id v10 = v38;
                  }
                }

                else
                {
                  if (qword_1001DC940 != -1) {
                    dispatch_once(&qword_1001DC940, &stru_1001AF878);
                  }
                  if (_NRLogIsLevelEnabled(qword_1001DC938, 16LL))
                  {
                    if (qword_1001DC940 != -1) {
                      dispatch_once(&qword_1001DC940, &stru_1001AF878);
                    }
                    _NRLogWithArgs( qword_1001DC938,  16LL,  "%s%.30s:%-4d received stop browse request without an appsvc name",  "",  "-[NRApplicationServiceManager setupResolverAgent]_block_invoke_3",  418);
                  }
                }

                goto LABEL_67;
              }

              uint64_t v18 = (char *)v18 + 1;
            }

            while (v16 != v18);
            id v20 = [v14 countByEnumeratingWithState:&v46 objects:v55 count:16];
            id v16 = v20;
            if (v20) {
              continue;
            }
            break;
          }
        }

LABEL_8:
        ;
      }

      id v7 = [v5 countByEnumeratingWithState:&v50 objects:v56 count:16];
    }

    while (v7);
  }

  if (qword_1001DC940 != -1) {
    dispatch_once(&qword_1001DC940, &stru_1001AF878);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC938, 16LL))
  {
    if (qword_1001DC940 != -1) {
      dispatch_once(&qword_1001DC940, &stru_1001AF878);
    }
    _NRLogWithArgs( qword_1001DC938,  16LL,  "%s%.30s:%-4d no browse request for client",  "",  "-[NRApplicationServiceManager setupResolverAgent]_block_invoke_3",  412);
  }

void sub_1000F5B58(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = sub_1000F4D2C((id *)objc_alloc(&OBJC_CLASS___NRASMResolveRequest), v5);
  uint64_t v9 = v7;
  if (v7)
  {
    objc_setProperty_nonatomic_copy(v7, v8, v6, 56LL);
    id v10 = sub_1000F4BC0((uint64_t)v9);
    uint64_t v11 = qword_1001DC940;
    if (v10)
    {
      id v12 = v10;
      if (qword_1001DC940 != -1) {
        dispatch_once(&qword_1001DC940, &stru_1001AF878);
      }
      id v41 = v6;
      if (_NRLogIsLevelEnabled(qword_1001DC938, 0LL))
      {
        if (qword_1001DC940 != -1) {
          dispatch_once(&qword_1001DC940, &stru_1001AF878);
        }
        id v13 = v9[2];
        id v14 = (id)qword_1001DC938;
        _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d received start resolve request for %@ (%p) from %@",  "",  "-[NRApplicationServiceManager setupResolverAgent]_block_invoke_5",  447LL,  v12,  v5,  v13);

        id v6 = v41;
      }

      uint64_t v15 = *(void *)(a1 + 32);
      if (v15) {
        id v16 = *(void **)(v15 + 40);
      }
      else {
        id v16 = 0LL;
      }
      uint64_t v17 = (NSMutableArray *)objc_claimAutoreleasedReturnValue([v16 objectForKeyedSubscript:v12]);
      if (!v17) {
        uint64_t v17 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      }
      id v40 = v5;
      if (-[NSMutableArray count](v17, "count"))
      {
        __int128 v50 = 0u;
        __int128 v51 = 0u;
        __int128 v48 = 0u;
        __int128 v49 = 0u;
        uint64_t v18 = v17;
        id v19 = v17;
        id v20 = (char *)-[NSMutableArray countByEnumeratingWithState:objects:count:]( v19,  "countByEnumeratingWithState:objects:count:",  &v48,  v53,  16LL);
        if (v20)
        {
          id v21 = v20;
          uint64_t v22 = *(void *)v49;
LABEL_16:
          if (*(void *)v49 == v22)
          {
            uint64_t v23 = *((void *)&v48 + 1);
            while (*(void *)v23 && *(_BYTE *)(*(void *)v23 + 48LL))
            {
              v23 += 8LL;
              if (!--v21) {
                goto LABEL_28;
              }
            }
          }

          else
          {
            uint64_t v24 = 0LL;
            while (1)
            {
              if (*(void *)v49 != v22) {
                objc_enumerationMutation(v19);
              }
              uint64_t v25 = *(void *)(*((void *)&v48 + 1) + 8 * v24);
              if (!v25 || !*(_BYTE *)(v25 + 48)) {
                break;
              }
              if (v21 == (char *)++v24)
              {
LABEL_28:
                id v21 = (char *)-[NSMutableArray countByEnumeratingWithState:objects:count:]( v19,  "countByEnumeratingWithState:objects:count:",  &v48,  v53,  16LL);
                if (v21) {
                  goto LABEL_16;
                }
                goto LABEL_29;
              }
            }
          }

          -[NSMutableArray addObject:](v19, "addObject:", v9);
          uint64_t v28 = *(void *)(a1 + 32);
          if (v28) {
            id v29 = *(void **)(v28 + 40);
          }
          else {
            id v29 = 0LL;
          }
          [v29 setObject:v19 forKeyedSubscript:v12];
          if (qword_1001DC940 != -1) {
            dispatch_once(&qword_1001DC940, &stru_1001AF878);
          }
          id v5 = v40;
          if (_NRLogIsLevelEnabled(qword_1001DC938, 0LL))
          {
            if (qword_1001DC940 != -1) {
              dispatch_once(&qword_1001DC940, &stru_1001AF878);
            }
            _NRLogWithArgs( qword_1001DC938,  0LL,  "%s%.30s:%-4d already has resolve request for %@ (%p)",  "",  "-[NRApplicationServiceManager setupResolverAgent]_block_invoke_5",  473LL,  v12,  v40);
          }

          goto LABEL_57;
        }

void sub_1000F60BC(uint64_t a1, void *a2)
{
  id v3 = a2;
  __int128 v50 = 0u;
  __int128 v51 = 0u;
  __int128 v52 = 0u;
  __int128 v53 = 0u;
  uint64_t v39 = a1;
  uint64_t v4 = *(void **)(a1 + 32);
  if (v4) {
    uint64_t v4 = (void *)v4[5];
  }
  id v5 = v4;
  id v6 = [v5 countByEnumeratingWithState:&v50 objects:v56 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v51;
    do
    {
      for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v51 != v8) {
          objc_enumerationMutation(v5);
        }
        uint64_t v11 = *(void *)(v39 + 32);
        if (v11) {
          id v12 = *(void **)(v11 + 40);
        }
        else {
          id v12 = 0LL;
        }
        id v13 = (void *)objc_claimAutoreleasedReturnValue( [v12 objectForKeyedSubscript:*(void *)(*((void *)&v50 + 1) + 8 * (void)i)]);
        __int128 v46 = 0u;
        __int128 v47 = 0u;
        __int128 v48 = 0u;
        __int128 v49 = 0u;
        id v14 = v13;
        id v15 = [v14 countByEnumeratingWithState:&v46 objects:v55 count:16];
        if (v15)
        {
          id v16 = v15;
          uint64_t v17 = *(void *)v47;
          while (2)
          {
            uint64_t v18 = 0LL;
            do
            {
              if (*(void *)v47 != v17) {
                objc_enumerationMutation(v14);
              }
              id v19 = *(void **)(*((void *)&v46 + 1) + 8LL * (void)v18);
              if (v19)
              {
                if ((id)v19[5] == v3) {
                  goto LABEL_7;
                }
              }

              else if (!v3)
              {
LABEL_7:
                id v10 = v19;

                if (!v19) {
                  goto LABEL_8;
                }

                id v21 = sub_1000F4BC0((uint64_t)v10);
                if (v21)
                {
                  if (qword_1001DC940 != -1) {
                    dispatch_once(&qword_1001DC940, &stru_1001AF878);
                  }
                  if (_NRLogIsLevelEnabled(qword_1001DC938, 0LL))
                  {
                    if (qword_1001DC940 != -1) {
                      dispatch_once(&qword_1001DC940, &stru_1001AF878);
                    }
                    uint64_t v22 = v10[2];
                    id v23 = (id)qword_1001DC938;
                    _NRLogWithArgs( v23,  0LL,  "%s%.30s:%-4d received stop resolve request for %@ (%p) from %@",  "",  "-[NRApplicationServiceManager setupResolverAgent]_block_invoke_7",  500LL,  v21,  v3,  v22);
                  }

                  uint64_t v24 = *(void *)(v39 + 32);
                  if (v24) {
                    uint64_t v25 = *(void **)(v24 + 40);
                  }
                  else {
                    uint64_t v25 = 0LL;
                  }
                  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v25 objectForKeyedSubscript:v21]);
                  [v26 removeObject:v10];
                  if (![v26 count])
                  {
                    uint64_t v27 = *(void *)(v39 + 32);
                    if (v27) {
                      uint64_t v28 = *(void **)(v27 + 40);
                    }
                    else {
                      uint64_t v28 = 0LL;
                    }
                    [v28 setObject:0 forKeyedSubscript:v21];
                    __int128 v44 = 0u;
                    __int128 v45 = 0u;
                    __int128 v42 = 0u;
                    __int128 v43 = 0u;
                    id v29 = *(void **)(v39 + 32);
                    __int128 v37 = v26;
                    uint64_t v38 = v10;
                    if (v29) {
                      id v29 = (void *)v29[6];
                    }
                    uint64_t v30 = v29;
                    id v31 = [v30 countByEnumeratingWithState:&v42 objects:v54 count:16];
                    if (v31)
                    {
                      id v32 = v31;
                      uint64_t v33 = *(void *)v43;
                      do
                      {
                        for (j = 0LL; j != v32; j = (char *)j + 1)
                        {
                          if (*(void *)v43 != v33) {
                            objc_enumerationMutation(v30);
                          }
                          uint64_t v35 = *(void *)(*((void *)&v42 + 1) + 8LL * (void)j);
                          if (v35) {
                            uint64_t v36 = *(dispatch_queue_s **)(v35 + 64);
                          }
                          else {
                            uint64_t v36 = 0LL;
                          }
                          block[0] = _NSConcreteStackBlock;
                          block[1] = 3221225472LL;
                          block[2] = sub_1000F6600;
                          block[3] = &unk_1001B0720;
                          void block[4] = v35;
                          id v41 = v21;
                          dispatch_async(v36, block);
                        }

                        id v32 = [v30 countByEnumeratingWithState:&v42 objects:v54 count:16];
                      }

                      while (v32);
                    }

                    uint64_t v26 = v37;
                    id v10 = v38;
                  }
                }

                else
                {
                  if (qword_1001DC940 != -1) {
                    dispatch_once(&qword_1001DC940, &stru_1001AF878);
                  }
                  if (_NRLogIsLevelEnabled(qword_1001DC938, 16LL))
                  {
                    if (qword_1001DC940 != -1) {
                      dispatch_once(&qword_1001DC940, &stru_1001AF878);
                    }
                    _NRLogWithArgs( qword_1001DC938,  16LL,  "%s%.30s:%-4d received stop resolve request without an appsvc name",  "",  "-[NRApplicationServiceManager setupResolverAgent]_block_invoke_7",  497);
                  }
                }

                goto LABEL_67;
              }

              uint64_t v18 = (char *)v18 + 1;
            }

            while (v16 != v18);
            id v20 = [v14 countByEnumeratingWithState:&v46 objects:v55 count:16];
            id v16 = v20;
            if (v20) {
              continue;
            }
            break;
          }
        }

LABEL_8:
        ;
      }

      id v7 = [v5 countByEnumeratingWithState:&v50 objects:v56 count:16];
    }

    while (v7);
  }

  if (qword_1001DC940 != -1) {
    dispatch_once(&qword_1001DC940, &stru_1001AF878);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC938, 16LL))
  {
    if (qword_1001DC940 != -1) {
      dispatch_once(&qword_1001DC940, &stru_1001AF878);
    }
    _NRLogWithArgs( qword_1001DC938,  16LL,  "%s%.30s:%-4d no resolve request for client",  "",  "-[NRApplicationServiceManager setupResolverAgent]_block_invoke_7",  491);
  }

id sub_1000F6600(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "didStopResolveRequestForASName:asClient:", *(void *)(a1 + 40));
}

id sub_1000F660C(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "didStartResolveRequestForASName:asClient:", *(void *)(a1 + 40));
}

id sub_1000F6618(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "didStopBrowseRequestForASName:asClient:", *(void *)(a1 + 40));
}

id sub_1000F6624(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "didStartBrowseRequestForASName:asClient:", *(void *)(a1 + 40));
}

LABEL_6:
  id v10 = (void *)_NRCopyLogObjectForNRUUID(nrUUID, v8);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 0LL);

  if (IsLevelEnabled)
  {
    if (v7) {
      id v13 = v7->_nrUUID;
    }
    else {
      id v13 = 0LL;
    }
    id WeakRetained = (id)_NRCopyLogObjectForNRUUID(v13, v12);
    _NRLogWithArgs( WeakRetained,  0LL,  "%s%.30s:%-4d already browsing for %@",  "",  "-[NRApplicationServiceClient didStartBrowseRequestForASName:asClient:]",  916LL,  v16);
    goto LABEL_12;
  }

  id v13 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", context);

  return v13;
}

    uint64_t v8 = (void *)v8[4];
    goto LABEL_7;
  }

  __int128 v46 = a1[5];
  if (v46)
  {
    __int128 v47 = *(void **)(v46 + 24);
    if (v47)
    {
      __int128 v48 = v47;
      __int128 v49 = [v48 length];

      if (v49)
      {
        __int128 v50 = a1[4];
        if (v50)
        {
          __int128 v51 = *(unsigned __int8 *)(v50 + 18);
          __int128 v52 = (void *)a1[5];
          if (!v52) {
            goto LABEL_48;
          }
        }

        else
        {
          __int128 v51 = 0;
          __int128 v52 = (void *)a1[5];
          if (!v52)
          {
LABEL_48:
            __int128 v53 = v52;
            uint64_t v54 = (void *)a1[5];
            if (v54) {
              uint64_t v54 = (void *)v54[1];
            }
            id v55 = v54;
            uint64_t v56 = sub_1001129CC(v50, v51, v53, v55);

            uint64_t v58 = a1[4];
            id v57 = (void *)a1[5];
            if (v57) {
              id v57 = (void *)v57[3];
            }
            uint64_t v59 = v57;
            uint64_t v60 = sub_100112A90(v58, v59, v56, v5);

            if (v60)
            {
              id v6 = (NSMutableData *)a1[4];
              uint64_t v8 = (void *)a1[5];
              if (!v8) {
                goto LABEL_7;
              }
              goto LABEL_6;
            }

            goto LABEL_41;
          }
        }

        __int128 v52 = (void *)v52[4];
        goto LABEL_48;
      }
    }
  }
      }

      id v6 = [v4 countByEnumeratingWithState:&v15 objects:v19 count:16];
    }

    while (v6);
  }

  return v3;
}

void sub_1000F6C6C(uint64_t a1, uint64_t a2)
{
  if (a1 && !*(_BYTE *)(a1 + 9))
  {
    *(_BYTE *)(a1 + 9) = 1;
    id v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 56), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1LL);

    if (IsLevelEnabled)
    {
      id v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 56), v5);
      _NRLogWithArgs(v6, 1LL, "%s%.30s:%-4d %@ cancel", "", "-[NRApplicationServiceClient cancel]", 828LL, a1);
    }

    objc_opt_self(&OBJC_CLASS___NRApplicationServiceManager);
    if (qword_1001DC930 != -1) {
      dispatch_once(&qword_1001DC930, &stru_1001AF7E0);
    }
    id v7 = (void *)qword_1001DC928;
    if (qword_1001DC928)
    {
      uint64_t v8 = *(dispatch_queue_s **)(qword_1001DC928 + 8);
      id v9 = (id)a1;
      id v10 = v7;
      dispatch_assert_queue_V2(v8);
      [v10[6] removeObject:v9];
    }
  }

void sub_1000F6D90(id a1)
{
  os_log_t v1 = objc_alloc_init(&OBJC_CLASS___NRApplicationServiceManager);
  id v2 = (void *)qword_1001DC928;
  qword_1001DC928 = (uint64_t)v1;
}

id sub_1000F6DB8(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "didStartBrowseRequestForASName:asClient:", *(void *)(a1 + 40));
}

id sub_1000F6DC4(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "didStartResolveRequestForASName:asClient:", *(void *)(a1 + 40));
}

nw_endpoint_t sub_1000F6DD0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (!a1) {
    goto LABEL_10;
  }
  if (!v3)
  {
    id v9 = sub_1000F4464();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 17LL);

    if (IsLevelEnabled)
    {
      id v6 = sub_1000F4464();
      _NRLogWithArgs( v6,  17LL,  "%s called with null asName",  "-[NRApplicationServiceManager copyListenerEndpointForASName:]");
      goto LABEL_7;
    }

id *sub_1000F6E98(id *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (a1)
  {
    v28.receiver = a1;
    v28.super_class = (Class)&OBJC_CLASS___NRApplicationServiceClient;
    id v10 = (id *)objc_msgSendSuper2(&v28, "init");
    if (!v10)
    {
      id v19 = sub_1000F4464();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v19, 16LL);

      if (IsLevelEnabled)
      {
        id v21 = sub_1000F4464();
        _NRLogWithArgs( v21,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRApplicationServiceClient initWithDelegate:delegateQueue:nrUUID:]",  782);
      }

      uint64_t v22 = _os_log_pack_size(12LL);
      id v23 = (char *)&v27 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v24 = __error();
      uint64_t v25 = _os_log_pack_fill(v23, v22, *v24, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v25 = 136446210;
      *(void *)(v25 + 4) = "-[NRApplicationServiceClient initWithDelegate:delegateQueue:nrUUID:]";
      id v26 = sub_1000F4464();
      _NRLogAbortWithPack(v26, v23);
    }

    a1 = v10;
    do
      unint64_t v11 = __ldxr(&qword_1001DC040);
    while (__stxr(v11 + 1, &qword_1001DC040));
    v10[5] = (id)v11;
    objc_storeWeak(v10 + 6, v7);
    objc_storeStrong(a1 + 8, a3);
    objc_storeStrong(a1 + 7, a4);
    id v12 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    id v13 = a1[2];
    a1[2] = v12;

    id v14 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    id v15 = a1[3];
    a1[3] = v14;

    id v16 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    id v17 = a1[4];
    a1[4] = v16;
  }

  return a1;
}

void sub_1000F708C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1 && !*(_BYTE *)(a1 + 9))
  {
    id v12 = v3;
    if (!v3)
    {
      id v10 = sub_1000F4464();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 17LL);

      id v3 = 0LL;
      if (!IsLevelEnabled) {
        goto LABEL_16;
      }
      id v5 = sub_1000F4464();
      _NRLogWithArgs( v5,  17LL,  "%s called with null interfaceName",  "-[NRApplicationServiceClient addInterfaceForApplicationService:]");
      goto LABEL_15;
    }

    objc_opt_self(&OBJC_CLASS___NRApplicationServiceManager);
    if (qword_1001DC930 != -1) {
      dispatch_once(&qword_1001DC930, &stru_1001AF7E0);
    }
    uint64_t v4 = qword_1001DC928;
    id v5 = v12;
    if (v4)
    {
      id v6 = *(id *)(v4 + 64);
      if (v6)
      {

LABEL_10:
        id v7 = (void *)nw_interface_create_with_name([v5 UTF8String]);
        uint64_t v8 = *(void *)(v4 + 64);
        if (v8) {
          nw_agent_add_to_interface(v8, v7);
        }
        uint64_t v9 = *(void *)(v4 + 80);
        if (v9) {
          nw_agent_add_to_interface(v9, v7);
        }

        goto LABEL_15;
      }

      if (*(void *)(v4 + 80)) {
        goto LABEL_10;
      }
    }

void sub_1000F71BC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1 && !*(_BYTE *)(a1 + 9))
  {
    id v10 = v3;
    objc_opt_self(&OBJC_CLASS___NRApplicationServiceManager);
    if (qword_1001DC930 != -1) {
      dispatch_once(&qword_1001DC930, &stru_1001AF7E0);
    }
    uint64_t v4 = qword_1001DC928;
    id v5 = v10;
    if (!v4) {
      goto LABEL_14;
    }
    id v6 = *(id *)(v4 + 64);
    if (v6)
    {
    }

    else if (!*(void *)(v4 + 80))
    {
LABEL_14:

      id v3 = v10;
      goto LABEL_15;
    }

    id v7 = (void *)nw_interface_create_with_name([v5 UTF8String]);
    uint64_t v8 = *(void *)(v4 + 64);
    if (v8) {
      nw_agent_remove_from_interface(v8, v7);
    }
    uint64_t v9 = *(void *)(v4 + 80);
    if (v9) {
      nw_agent_remove_from_interface(v9, v7);
    }

    goto LABEL_14;
  }

uint64_t sub_1000F72A0(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1 && !*(_BYTE *)(a1 + 9))
  {
    objc_opt_self(&OBJC_CLASS___NRApplicationServiceManager);
    if (qword_1001DC930 != -1) {
      dispatch_once(&qword_1001DC930, &stru_1001AF7E0);
    }
    uint64_t v4 = qword_1001DC928;
    id v5 = v3;
    id v6 = v5;
    if (v4)
    {
      if (v5)
      {
        id v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v4 + 32) objectForKeyedSubscript:v5]);
        __int128 v29 = 0u;
        __int128 v30 = 0u;
        __int128 v31 = 0u;
        __int128 v32 = 0u;
        id v8 = v7;
        uint64_t v9 = (char *)[v8 countByEnumeratingWithState:&v29 objects:v34 count:16];
        if (v9)
        {
          id v10 = v9;
          uint64_t v11 = *(void *)v30;
LABEL_10:
          if (*(void *)v30 == v11)
          {
            uint64_t v12 = *((void *)&v29 + 1);
            while (!*(void *)v12 || !*(_BYTE *)(*(void *)v12 + 8LL))
            {
              v12 += 8LL;
              if (!--v10) {
                goto LABEL_22;
              }
            }
          }

          else
          {
            uint64_t v13 = 0LL;
            while (1)
            {
              if (*(void *)v30 != v11) {
                objc_enumerationMutation(v8);
              }
              uint64_t v14 = *(void *)(*((void *)&v29 + 1) + 8 * v13);
              if (v14)
              {
                if (*(_BYTE *)(v14 + 8)) {
                  break;
                }
              }

              if (v10 == (char *)++v13)
              {
LABEL_22:
                id v10 = (char *)[v8 countByEnumeratingWithState:&v29 objects:v34 count:16];
                if (v10) {
                  goto LABEL_10;
                }
                goto LABEL_23;
              }
            }
          }

          uint64_t v4 = 1LL;
          id v16 = v8;
        }

        else
        {
LABEL_23:

          id v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v4 + 40) objectForKeyedSubscript:v6]);
          __int128 v25 = 0u;
          __int128 v26 = 0u;
          __int128 v27 = 0u;
          __int128 v28 = 0u;
          id v16 = v15;
          uint64_t v4 = (uint64_t)[v16 countByEnumeratingWithState:&v25 objects:v33 count:16];
          if (v4)
          {
            uint64_t v17 = *(void *)v26;
LABEL_25:
            if (*(void *)v26 == v17)
            {
              uint64_t v18 = *((void *)&v25 + 1);
              while (!*(void *)v18 || !*(_BYTE *)(*(void *)v18 + 8LL))
              {
                v18 += 8LL;
                if (!--v4) {
                  goto LABEL_37;
                }
              }
            }

            else
            {
              uint64_t v19 = 0LL;
              while (1)
              {
                if (*(void *)v26 != v17) {
                  objc_enumerationMutation(v16);
                }
                uint64_t v20 = *(void *)(*((void *)&v25 + 1) + 8 * v19);
                if (v20)
                {
                  if (*(_BYTE *)(v20 + 8)) {
                    break;
                  }
                }

                if (v4 == ++v19)
                {
LABEL_37:
                  uint64_t v4 = (uint64_t)[v16 countByEnumeratingWithState:&v25 objects:v33 count:16];
                  if (v4) {
                    goto LABEL_25;
                  }
                  goto LABEL_41;
                }
              }
            }

            uint64_t v4 = 1LL;
          }

void sub_1000F842C(void *a1)
{
  uint64_t v2 = a1[4];
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
  }
  else {
    id WeakRetained = 0LL;
  }
  id v4 = WeakRetained;
  [WeakRetained linkDidReceiveData:a1[5] data:a1[6]];
}

void sub_1000F8478(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC948;
  qword_1001DC948 = (uint64_t)v1;
}

id sub_1000F84A8()
{
  if (qword_1001DC950 != -1) {
    dispatch_once(&qword_1001DC950, &stru_1001AF898);
  }
  return (id)qword_1001DC948;
}

void sub_1000F84E8(uint64_t a1)
{
  id v43 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) nrUUID]);
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
  }
  else {
    id WeakRetained = 0LL;
  }
  [WeakRetained linkIsUnavailable:*(void *)(a1 + 32)];

  uint64_t v4 = *(void *)(a1 + 40);
  if (v4 && *(_BYTE *)(v4 + 32))
  {
    if (qword_1001DC950 != -1) {
      dispatch_once(&qword_1001DC950, &stru_1001AF898);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC948, 1LL))
    {
      if (qword_1001DC950 != -1) {
        dispatch_once(&qword_1001DC950, &stru_1001AF898);
      }
      _NRLogWithArgs( qword_1001DC948,  1LL,  "%s%.30s:%-4d Forcing interface availability event, as the underlying transport is still available",  "",  "-[NRLinkManagerFixedInterface linkIsUnavailable:]_block_invoke",  333);
    }

    uint64_t v5 = *(void *)(a1 + 40);
    id v6 = v43;
    if (!v5)
    {
      __int128 v29 = 0LL;
      goto LABEL_34;
    }

    id v7 = (dispatch_queue_s *)*(id *)(v5 + 24);
    dispatch_assert_queue_V2(v7);

    if (([(id)v5 shouldCreateLinkForNRUUID:v6] & 1) == 0)
    {
      id StringFromNRLinkType = (id)createStringFromNRLinkType(*(unsigned __int8 *)(v5 + 8));
      [(id)v5 reportEvent:3017, @"unsupported link type: %@", StringFromNRLinkType detailsFormat];
      __int128 v29 = 0LL;
      goto LABEL_33;
    }

    id v42 = v6;
    id v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v5 + 56) hostname]);
    objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
    if (qword_1001DC640 != -1) {
      dispatch_once(&qword_1001DC640, &stru_1001ADE98);
    }
    id v9 = (id)qword_1001DC638;
    if (v9) {
      id v10 = @"62743";
    }
    else {
      id v10 = 0LL;
    }
    uint64_t v11 = v10;
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v8,  v11));

    uint64_t v13 = objc_alloc(&OBJC_CLASS___NRLinkFixedInterface);
    id v14 = *(id *)(v5 + 24);
    id v15 = *(id *)(v5 + 64);
    objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
    if (qword_1001DC640 != -1) {
      dispatch_once(&qword_1001DC640, &stru_1001ADE98);
    }
    id v16 = (id)qword_1001DC638;
    if (v16) {
      uint64_t v17 = @"62743";
    }
    else {
      uint64_t v17 = 0LL;
    }
    uint64_t v18 = v17;
    id v19 = v14;
    id v20 = (id)v5;
    id v21 = v6;
    id v22 = v15;
    id StringFromNRLinkType = v12;
    id v24 = v18;
    if (!v13)
    {
      __int128 v29 = 0LL;
      goto LABEL_31;
    }

    if (v19)
    {
      if (v21)
      {
        if ((_NRIsUUIDNonZero(v21) & 1) != 0)
        {
          if (v22)
          {
            v44.receiver = v13;
            v44.super_class = (Class)&OBJC_CLASS___NRLinkFixedInterface;
            __int128 v25 = (char *)objc_msgSendSuper2(&v44, "initLinkWithQueue:linkDelegate:nrUUID:", v19, v20, v21);
            if (v25)
            {
              __int128 v26 = v25;
              [v25 setType:2];
              [v26 setSubtype:101];
              [v26 setLocalInterfaceName:v22];
              [v26 setLocalOuterEndpoint:0];
              [v26 setRemoteOuterEndpoint:StringFromNRLinkType];
              objc_storeStrong((id *)(v26 + 239), v17);
              __int128 v27 = (void *)objc_claimAutoreleasedReturnValue([v21 UUIDString]);
              [v26 reportEvent:3000 details:v27];

              __int128 v28 = (void *)objc_claimAutoreleasedReturnValue([v26 linkDelegate]);
              [v28 linkIsAvailable:v26];

              uint64_t v13 = v26;
              __int128 v29 = v13;
            }

            else
            {
              if (qword_1001DC7B8 != -1) {
                dispatch_once(&qword_1001DC7B8, &stru_1001AEA00);
              }
              id v35 = (id)qword_1001DC7B0;
              int IsLevelEnabled = _NRLogIsLevelEnabled(v35, 17LL);

              if (IsLevelEnabled)
              {
                if (qword_1001DC7B8 != -1) {
                  dispatch_once(&qword_1001DC7B8, &stru_1001AEA00);
                }
                id v37 = (id)qword_1001DC7B0;
                _NRLogWithArgs(v37, 17LL, "[NRLink initLinkWithQueue:] failed");
              }

              uint64_t v13 = 0LL;
              __int128 v29 = 0LL;
            }

            goto LABEL_30;
          }

          if (qword_1001DC7B8 != -1) {
            dispatch_once(&qword_1001DC7B8, &stru_1001AEA00);
          }
          id v34 = (id)qword_1001DC7B0;
          int v41 = _NRLogIsLevelEnabled(v34, 17LL);

          if (!v41)
          {
LABEL_61:
            __int128 v29 = 0LL;
LABEL_30:
            id v6 = v42;
LABEL_31:

LABEL_33:
LABEL_34:

            goto LABEL_35;
          }

          if (qword_1001DC7B8 != -1) {
            dispatch_once(&qword_1001DC7B8, &stru_1001AEA00);
          }
          id v31 = (id)qword_1001DC7B0;
          _NRLogWithArgs(v31, 17LL, "%s called with null fixedInterfaceName");
        }

        else
        {
          if (qword_1001DC7B8 != -1) {
            dispatch_once(&qword_1001DC7B8, &stru_1001AEA00);
          }
          id v33 = (id)qword_1001DC7B0;
          int v40 = _NRLogIsLevelEnabled(v33, 17LL);

          if (!v40) {
            goto LABEL_61;
          }
          if (qword_1001DC7B8 != -1) {
            dispatch_once(&qword_1001DC7B8, &stru_1001AEA00);
          }
          id v31 = (id)qword_1001DC7B0;
          _NRLogWithArgs(v31, 17LL, "called with all-zero nrUUID");
        }
      }

      else
      {
        if (qword_1001DC7B8 != -1) {
          dispatch_once(&qword_1001DC7B8, &stru_1001AEA00);
        }
        id v32 = (id)qword_1001DC7B0;
        int v39 = _NRLogIsLevelEnabled(v32, 17LL);

        if (!v39) {
          goto LABEL_61;
        }
        if (qword_1001DC7B8 != -1) {
          dispatch_once(&qword_1001DC7B8, &stru_1001AEA00);
        }
        id v31 = (id)qword_1001DC7B0;
        _NRLogWithArgs(v31, 17LL, "%s called with null nrUUID");
      }
    }

    else
    {
      if (qword_1001DC7B8 != -1) {
        dispatch_once(&qword_1001DC7B8, &stru_1001AEA00);
      }
      id v30 = (id)qword_1001DC7B0;
      int v38 = _NRLogIsLevelEnabled(v30, 17LL);

      if (!v38) {
        goto LABEL_61;
      }
      if (qword_1001DC7B8 != -1) {
        dispatch_once(&qword_1001DC7B8, &stru_1001AEA00);
      }
      id v31 = (id)qword_1001DC7B0;
      _NRLogWithArgs(v31, 17LL, "%s called with null queue");
    }

    goto LABEL_61;
  }

void sub_1000F8C10(uint64_t a1)
{
  if ([*(id *)(a1 + 32) state] == 9)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2) {
      id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    }
    else {
      id WeakRetained = 0LL;
    }
    id v4 = WeakRetained;
    [WeakRetained linkIsSuspended:*(void *)(a1 + 32)];
  }

  else
  {
    if (qword_1001DC950 != -1) {
      dispatch_once(&qword_1001DC950, &stru_1001AF898);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC948, 16LL))
    {
      if (qword_1001DC950 != -1) {
        dispatch_once(&qword_1001DC950, &stru_1001AF898);
      }
      _NRLogWithArgs( qword_1001DC948,  16LL,  "%s%.30s:%-4d %@: link %@ is not in suspended state anymore",  "",  "-[NRLinkManagerFixedInterface linkIsSuspended:]_block_invoke",  307LL,  *(void *)(a1 + 40),  *(void *)(a1 + 32));
    }
  }

void sub_1000F8D20(uint64_t a1)
{
  if ([*(id *)(a1 + 32) state] == 8)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2) {
      id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    }
    else {
      id WeakRetained = 0LL;
    }
    id v4 = WeakRetained;
    [WeakRetained linkIsReady:*(void *)(a1 + 32)];
  }

  else
  {
    if (qword_1001DC950 != -1) {
      dispatch_once(&qword_1001DC950, &stru_1001AF898);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC948, 16LL))
    {
      if (qword_1001DC950 != -1) {
        dispatch_once(&qword_1001DC950, &stru_1001AF898);
      }
      _NRLogWithArgs( qword_1001DC948,  16LL,  "%s%.30s:%-4d %@: link %@ is not in ready state anymore",  "",  "-[NRLinkManagerFixedInterface linkIsReady:]_block_invoke",  284LL,  *(void *)(a1 + 40),  *(void *)(a1 + 32));
    }
  }

void sub_1000F8E30(uint64_t a1)
{
  if ([*(id *)(a1 + 32) state] == 1)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2) {
      id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    }
    else {
      id WeakRetained = 0LL;
    }
    id v4 = WeakRetained;
    [WeakRetained linkIsAvailable:*(void *)(a1 + 32)];
  }

  else
  {
    if (qword_1001DC950 != -1) {
      dispatch_once(&qword_1001DC950, &stru_1001AF898);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC948, 16LL))
    {
      if (qword_1001DC950 != -1) {
        dispatch_once(&qword_1001DC950, &stru_1001AF898);
      }
      _NRLogWithArgs( qword_1001DC948,  16LL,  "%s%.30s:%-4d %@: link %@ is not in initial state anymore",  "",  "-[NRLinkManagerFixedInterface linkIsAvailable:]_block_invoke",  261LL,  *(void *)(a1 + 40),  *(void *)(a1 + 32));
    }
  }

void sub_1000F9A58(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC958;
  qword_1001DC958 = (uint64_t)v1;
}

id sub_1000F9A88()
{
  if (qword_1001DC960 != -1) {
    dispatch_once(&qword_1001DC960, &stru_1001AF8E0);
  }
  return (id)qword_1001DC958;
}

void sub_1000F9AC8(void *a1)
{
  uint64_t v2 = a1[4];
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
  }
  else {
    id WeakRetained = 0LL;
  }
  id v4 = WeakRetained;
  [WeakRetained linkDidReceiveData:a1[5] data:a1[6]];
}

void sub_1000F9B14(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
  }
  else {
    id WeakRetained = 0LL;
  }
  id v4 = WeakRetained;
  [WeakRetained linkIsUnavailable:*(void *)(a1 + 40)];
}

void sub_1000F9B60(uint64_t a1)
{
  if (a1)
  {
    *(_DWORD *)(a1 + 36) = nw_path_get_status(*(nw_path_t *)(a1 + 56));
    int v2 = *(_DWORD *)(a1 + 36);
    if (v2 == 2)
    {
      id v3 = [*(id *)(a1 + 40) copy];
      __int128 v35 = 0u;
      __int128 v36 = 0u;
      __int128 v37 = 0u;
      __int128 v38 = 0u;
      id v4 = v3;
      id v5 = [v4 countByEnumeratingWithState:&v35 objects:v41 count:16];
      if (v5)
      {
        id v6 = v5;
        uint64_t v7 = *(void *)v36;
        do
        {
          for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v36 != v7) {
              objc_enumerationMutation(v4);
            }
            id v9 = *(void **)(*((void *)&v35 + 1) + 8LL * (void)i);
            if (([v9 ikeClassCEstablished] & 1) != 0
              || [v9 ikeClassDEstablished])
            {
              [v9 suspend];
            }

            else
            {
              [v9 cancelWithReason:@"No network route"];
            }
          }

          id v6 = [v4 countByEnumeratingWithState:&v35 objects:v41 count:16];
        }

        while (v6);
      }

      int v2 = *(_DWORD *)(a1 + 36);
    }

    if (v2 == 1)
    {
      __int128 v33 = 0u;
      __int128 v34 = 0u;
      __int128 v31 = 0u;
      __int128 v32 = 0u;
      id obj = sub_100131A50((uint64_t)&OBJC_CLASS___NRDLocalDevice);
      id v10 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v31,  v40,  16LL);
      if (v10)
      {
        id v11 = v10;
        uint64_t v26 = *(void *)v32;
        do
        {
          for (j = 0LL; j != v11; j = (char *)j + 1)
          {
            if (*(void *)v32 != v26) {
              objc_enumerationMutation(obj);
            }
            id v14 = *(void **)(*((void *)&v31 + 1) + 8LL * (void)j);
            __int128 v27 = 0u;
            __int128 v28 = 0u;
            __int128 v29 = 0u;
            __int128 v30 = 0u;
            id v15 = *(id *)(a1 + 40);
            id v16 = [v15 countByEnumeratingWithState:&v27 objects:v39 count:16];
            if (v16)
            {
              id v17 = v16;
              uint64_t v18 = *(void *)v28;
LABEL_27:
              uint64_t v19 = 0LL;
              while (1)
              {
                if (*(void *)v28 != v18) {
                  objc_enumerationMutation(v15);
                }
                id v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v27 + 1) + 8 * v19) nrUUID]);
                unsigned __int8 v21 = [v20 isEqual:v14];

                if ((v21 & 1) != 0) {
                  break;
                }
                if (v17 == (id)++v19)
                {
                  id v17 = [v15 countByEnumeratingWithState:&v27 objects:v39 count:16];
                  if (v17) {
                    goto LABEL_27;
                  }
                  goto LABEL_33;
                }
              }
            }

            else
            {
LABEL_33:

              id v15 = v14;
              if ([(id)a1 shouldCreateLinkForNRUUID:v15])
              {
                id v22 = objc_alloc(&OBJC_CLASS___NRLinkQuickRelay);
                id v23 = *(id *)(a1 + 24);
                id StringFromNRLinkType = -[NRLinkQuickRelay initLinkWithQueue:linkDelegate:nrUUID:]( v22,  "initLinkWithQueue:linkDelegate:nrUUID:",  v23,  a1,  v15);

                if (!StringFromNRLinkType)
                {
                  id v24 = (void *)objc_claimAutoreleasedReturnValue([v15 UUIDString]);
                  [(id)a1 reportEvent:3017 details:v24];

                  id StringFromNRLinkType = 0LL;
                }
              }

              else
              {
                id StringFromNRLinkType = (id)createStringFromNRLinkType(*(unsigned __int8 *)(a1 + 8));
                [(id)a1 reportEvent:3017, @"unsupported link type: %@", StringFromNRLinkType detailsFormat];
              }
            }
          }

          id v11 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v31,  v40,  16LL);
        }

        while (v11);
      }
    }

    else
    {
      if (qword_1001DC960 != -1) {
        dispatch_once(&qword_1001DC960, &stru_1001AF8E0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC958, 1LL))
      {
        if (qword_1001DC960 != -1) {
          dispatch_once(&qword_1001DC960, &stru_1001AF8E0);
        }
        _NRLogWithArgs( qword_1001DC958,  1LL,  "%s%.30s:%-4d No network to serve QuickRelay link. Deferring creation of link until we have a network",  "",  "-[NRLinkManagerQuickRelay createLinkIfApplicable]",  172);
      }
    }
  }

void sub_1000F9F78(uint64_t a1)
{
  if ([*(id *)(a1 + 32) state] == 8)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2) {
      id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    }
    else {
      id WeakRetained = 0LL;
    }
    id v4 = WeakRetained;
    [WeakRetained linkIsReady:*(void *)(a1 + 32)];
  }

  else
  {
    if (qword_1001DC960 != -1) {
      dispatch_once(&qword_1001DC960, &stru_1001AF8E0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC958, 16LL))
    {
      if (qword_1001DC960 != -1) {
        dispatch_once(&qword_1001DC960, &stru_1001AF8E0);
      }
      _NRLogWithArgs( qword_1001DC958,  16LL,  "%s%.30s:%-4d %@: link %@ is not in ready state anymore",  "",  "-[NRLinkManagerQuickRelay linkIsReady:]_block_invoke",  245LL,  *(void *)(a1 + 40),  *(void *)(a1 + 32));
    }
  }

void sub_1000FA088(uint64_t a1)
{
  if ([*(id *)(a1 + 32) state] == 9)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2) {
      id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    }
    else {
      id WeakRetained = 0LL;
    }
    id v4 = WeakRetained;
    [WeakRetained linkIsSuspended:*(void *)(a1 + 32)];
  }

  else
  {
    if (qword_1001DC960 != -1) {
      dispatch_once(&qword_1001DC960, &stru_1001AF8E0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC958, 16LL))
    {
      if (qword_1001DC960 != -1) {
        dispatch_once(&qword_1001DC960, &stru_1001AF8E0);
      }
      _NRLogWithArgs( qword_1001DC958,  16LL,  "%s%.30s:%-4d %@: link %@ is not in suspended state anymore",  "",  "-[NRLinkManagerQuickRelay linkIsSuspended:]_block_invoke",  230LL,  *(void *)(a1 + 40),  *(void *)(a1 + 32));
    }
  }

void sub_1000FA198(uint64_t a1)
{
  if ([*(id *)(a1 + 32) state] == 1)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2) {
      id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    }
    else {
      id WeakRetained = 0LL;
    }
    id v4 = WeakRetained;
    [WeakRetained linkIsAvailable:*(void *)(a1 + 32)];
  }

  else
  {
    if (qword_1001DC960 != -1) {
      dispatch_once(&qword_1001DC960, &stru_1001AF8E0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC958, 16LL))
    {
      if (qword_1001DC960 != -1) {
        dispatch_once(&qword_1001DC960, &stru_1001AF8E0);
      }
      _NRLogWithArgs( qword_1001DC958,  16LL,  "%s%.30s:%-4d %@: link %@ is not in initial state anymore",  "",  "-[NRLinkManagerQuickRelay linkIsAvailable:]_block_invoke",  216LL,  *(void *)(a1 + 40),  *(void *)(a1 + 32));
    }
  }

void sub_1000FA2A8(__objc2_meth_list **p_class_meths)
{
  nw_parameters_t v2 = nw_parameters_create();
  id v3 = (char *)xpc_array_create(0LL, 0LL);
  if (!v3)
  {
    id v26 = sub_1000F9A88();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v26, 16LL);

    if (IsLevelEnabled)
    {
      id v28 = sub_1000F9A88();
      _NRLogWithArgs( v28,  16LL,  "%s%.30s:%-4d ABORTING: xpc_array_create(%p, %u) failed",  "",  "nr_xpc_array_create",  56,  0LL,  0);
    }

    nw_parameters_t v2 = (nw_parameters_t)_os_log_pack_size(28LL);
    id v4 = (char *)&v33[-1] - ((__chkstk_darwin(v2) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    __int128 v29 = __error();
    uint64_t v30 = _os_log_pack_fill( v4,  v2,  *v29,  &_mh_execute_header,  "%{public}s xpc_array_create(%p, %u) failed");
    sub_10005B18C(v30, (uint64_t)"nr_xpc_array_create");
    id v31 = sub_1000F9A88();
    _NRLogAbortWithPack(v31, v4);
    __break(1u);
LABEL_20:
    dispatch_once(&qword_1001DC960, &stru_1001AF8E0);
    goto LABEL_12;
  }

  id v4 = v3;
  xpc_array_set_uint64(v3, 0xFFFFFFFFFFFFFFFFLL, 0x1389uLL);
  nw_parameters_set_prohibited_interface_subtypes(v2, v4);
  uint64_t evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(0LL, v2);
  id v6 = p_class_meths[6];
  p_class_meths[6] = (__objc2_meth_list *)evaluator_for_endpoint;

  uint64_t v7 = p_class_meths[6];
  if (v7)
  {
    id v8 = v7;
    id v9 = p_class_meths[3];
    nw_path_evaluator_set_queue(v8, v9);

    objc_initWeak(&location, p_class_meths);
    id v10 = p_class_meths[6];
    id v11 = p_class_meths[3];
    v33[0] = _NSConcreteStackBlock;
    v33[1] = 3221225472LL;
    v33[2] = sub_1000FA718;
    v33[3] = &unk_1001AF8C0;
    objc_copyWeak(&v34, &location);
    nw_path_evaluator_set_update_handler(v10, v11, v33);

    uint64_t v12 = p_class_meths[6];
    nw_path_evaluator_start(v12);

    uint64_t v13 = p_class_meths[6];
    uint64_t v14 = nw_path_evaluator_copy_path(v13);
    id v15 = p_class_meths[7];
    p_class_meths[7] = (__objc2_meth_list *)v14;

    id v16 = objc_alloc(&OBJC_CLASS___APSConnection);
    uint64_t v17 = APSEnvironmentProduction;
    uint64_t v18 = APSConnectionOverrideNamedDelegatePort;
    uint64_t v19 = p_class_meths[3];
    id v20 = -[APSConnection initWithEnvironmentName:namedDelegatePort:queue:]( v16,  "initWithEnvironmentName:namedDelegatePort:queue:",  v17,  v18,  v19);
    unsigned __int8 v21 = p_class_meths[8];
    p_class_meths[8] = v20;

    if (!p_class_meths[8])
    {
      if (qword_1001DC960 != -1) {
        dispatch_once(&qword_1001DC960, &stru_1001AF8E0);
      }
      id v22 = (id)qword_1001DC958;
      char v23 = _NRLogIsLevelEnabled(v22, 17LL);

      if ((v23 & 1) != 0)
      {
        if (qword_1001DC960 != -1) {
          dispatch_once(&qword_1001DC960, &stru_1001AF8E0);
        }
        id v24 = (id)qword_1001DC958;
        _NRLogWithArgs(v24, 17LL, "[[APSConnection alloc] initWithEnvironmentName:namedDelegatePort:queue:]");
      }
    }

    __int128 v25 = p_class_meths[8];
    -[__objc2_meth_list setDelegate:](v25, "setDelegate:", p_class_meths);

    sub_1000FA824((uint64_t)p_class_meths);
    objc_destroyWeak(&v34);
    objc_destroyWeak(&location);
    goto LABEL_16;
  }

  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  if (qword_1001DC960 != -1) {
    goto LABEL_20;
  }
LABEL_12:
  if (_NRLogIsLevelEnabled(qword_1001DC958, 17LL))
  {
    if (p_class_meths[300] != (__objc2_meth_list *)-1LL) {
      dispatch_once(&qword_1001DC960, &stru_1001AF8E0);
    }
    _NRLogWithArgs(qword_1001DC958, 17LL, "nw_path_create_default_evaluator failed");
  }

void sub_1000FA6F0(_Unwind_Exception *a1)
{
}

void sub_1000FA718(uint64_t a1, void *a2)
{
  id v6 = a2;
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  id v5 = WeakRetained;
  if (WeakRetained && *((_DWORD *)WeakRetained + 3) != 1004)
  {
    if (qword_1001DC960 != -1) {
      dispatch_once(&qword_1001DC960, &stru_1001AF8E0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC958, 1LL))
    {
      if (qword_1001DC960 != -1) {
        dispatch_once(&qword_1001DC960, &stru_1001AF8E0);
      }
      _NRLogWithArgs( qword_1001DC958,  1LL,  "%s%.30s:%-4d received path update for QR link manager: %@",  "",  "-[NRLinkManagerQuickRelay setup]_block_invoke",  136LL,  v6);
    }

    objc_storeStrong(v5 + 7, a2);
    sub_1000F9B60((uint64_t)v5);
  }
}

void sub_1000FA824(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (dispatch_queue_s *)*(id *)(a1 + 24);
    dispatch_assert_queue_V2(v2);

    id v3 = [*(id *)(a1 + 40) copy];
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    id v4 = v3;
    id v5 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v13;
      do
      {
        for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v13 != v7) {
            objc_enumerationMutation(v4);
          }
          id v9 = *(void **)(*((void *)&v12 + 1) + 8LL * (void)i);
          id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 nrUUID]);
          id v11 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v10);

          if (!v11 || !v11[9]) {
            [v9 cancelWithReason:@"Device has been disabled %@", v11];
          }
        }

        id v6 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
      }

      while (v6);
    }

    sub_1000F9B60(a1);
  }

id sub_1000FBEC0()
{
  if (qword_1001DC978 != -1) {
    dispatch_once(&qword_1001DC978, &stru_1001AFA38);
  }
  return (id)qword_1001DC970;
}

id *sub_1000FBF00(id *a1, void *a2, void *a3, void *a4)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  if (a1)
  {
    v22.receiver = a1;
    v22.super_class = (Class)&OBJC_CLASS___NRDevicePairingCandidateContext;
    id v11 = (id *)objc_msgSendSuper2(&v22, "init");
    if (!v11)
    {
      id v13 = sub_1000FBEC0();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v13, 16LL);

      if (IsLevelEnabled)
      {
        id v15 = sub_1000FBEC0();
        _NRLogWithArgs( v15,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDevicePairingCandidateContext initWithCandidateInfo:queue:pairingManager:]",  969);
      }

      uint64_t v16 = _os_log_pack_size(12LL);
      uint64_t v17 = (char *)&v21 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v18 = __error();
      uint64_t v19 = _os_log_pack_fill(v17, v16, *v18, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v19 = 136446210;
      *(void *)(v19 + 4) = "-[NRDevicePairingCandidateContext initWithCandidateInfo:queue:pairingManager:]";
      id v20 = sub_1000FBEC0();
      _NRLogAbortWithPack(v20, v17);
    }

    a1 = v11;
    objc_storeWeak(v11 + 2, v10);
    objc_storeStrong(a1 + 3, a3);
    objc_storeStrong(a1 + 4, a2);
  }

  return a1;
}

void sub_1000FC09C(uint64_t a1, id *a2)
{
  if (*a2)
  {
    if (qword_1001DC978 != -1) {
      dispatch_once(&qword_1001DC978, &stru_1001AFA38);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC970, 1LL))
    {
      if (qword_1001DC978 != -1) {
        dispatch_once(&qword_1001DC978, &stru_1001AFA38);
      }
      _NRLogWithArgs( qword_1001DC970,  1LL,  "%s%.30s:%-4d Invalidating IKE Session %@",  "",  "+[NRDevicePairingCandidateContext invalidateIKESession:]",  949LL,  *a2);
    }

    [*a2 setStateUpdateBlock:0];
    [*a2 setChildStateUpdateBlock:0];
    [*a2 setConfigurationUpdateBlock:0];
    [*a2 setTrafficSelectorUpdateBlock:0];
    [*a2 setAdditionalAddressesUpdateBlock:0];
    [*a2 setShortDPDEventBlock:0];
    [*a2 setRedirectEventBlock:0];
    [*a2 setPrivateNotifyStatusEvent:0];
    [*a2 disconnect];
    [*a2 invalidate];
    id v3 = *a2;
    *a2 = 0LL;
  }

void sub_1000FC1F4(uint64_t a1)
{
  id v2 = *(id *)(a1 + 120);
  if (v2)
  {
    if (qword_1001DC978 != -1) {
      dispatch_once(&qword_1001DC978, &stru_1001AFA38);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC970, 1LL))
    {
      if (qword_1001DC978 != -1) {
        dispatch_once(&qword_1001DC978, &stru_1001AFA38);
      }
      _NRLogWithArgs( qword_1001DC970,  1LL,  "%s%.30s:%-4d %@ setting callbacks on control session",  "",  "-[NRDevicePairingCandidateContext setupIKECallbacksForControlSession]",  1854LL,  a1);
    }

    [v2 setClientQueue:*(void *)(a1 + 24)];
    objc_initWeak(&location, (id)a1);
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472LL;
    v5[2] = sub_1000FC3B0;
    v5[3] = &unk_1001AF978;
    objc_copyWeak(&v6, &location);
    [v2 setStateUpdateBlock:v5];
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472LL;
    v3[2] = sub_1000FC548;
    v3[3] = &unk_1001AF9A0;
    objc_copyWeak(&v4, &location);
    [v2 setPrivateNotifyStatusEvent:v3];
    objc_destroyWeak(&v4);
    objc_destroyWeak(&v6);
    objc_destroyWeak(&location);
  }
}

void sub_1000FC384(_Unwind_Exception *a1)
{
}

void sub_1000FC3B0(uint64_t a1, uint64_t a2, void *a3)
{
  id v6 = a3;
  if (qword_1001DC978 != -1) {
    dispatch_once(&qword_1001DC978, &stru_1001AFA38);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC970, 1LL))
  {
    if (qword_1001DC978 != -1) {
      dispatch_once(&qword_1001DC978, &stru_1001AFA38);
    }
    _NRLogWithArgs( qword_1001DC970,  1LL,  "%s%.30s:%-4d stateUpdateBlock",  "",  "-[NRDevicePairingCandidateContext setupIKECallbacksForControlSession]_block_invoke",  1859);
  }

  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    if (qword_1001DC978 != -1) {
      dispatch_once(&qword_1001DC978, &stru_1001AFA38);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC970, 0LL))
    {
      if (qword_1001DC978 != -1) {
        dispatch_once(&qword_1001DC978, &stru_1001AFA38);
      }
      _NRLogWithArgs( qword_1001DC970,  0LL,  "%s%.30s:%-4d %@ Control session received state update %zu error %@",  "",  "-[NRDevicePairingCandidateContext setupIKECallbacksForControlSession]_block_invoke",  1865LL,  WeakRetained,  a2,  v6);
    }

    if (a2 != 2 && (a2 == 3 || v6)) {
      sub_1000FC09C((uint64_t)&OBJC_CLASS___NRDevicePairingCandidateContext, WeakRetained + 15);
    }
  }
}

void sub_1000FC548(uint64_t a1, void *a2)
{
  id v16 = a2;
  if (qword_1001DC978 != -1) {
    dispatch_once(&qword_1001DC978, &stru_1001AFA38);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC970, 1LL))
  {
    if (qword_1001DC978 != -1) {
      dispatch_once(&qword_1001DC978, &stru_1001AFA38);
    }
    _NRLogWithArgs( qword_1001DC970,  1LL,  "%s%.30s:%-4d privateNotifyStatusEvent",  "",  "-[NRDevicePairingCandidateContext setupIKECallbacksForControlSession]_block_invoke_2",  1881);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v4 = (void *)objc_claimAutoreleasedReturnValue([v16 sortedArrayUsingComparator:&stru_1001AFCC8]);
    if (qword_1001DC978 != -1) {
      dispatch_once(&qword_1001DC978, &stru_1001AFA38);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC970, 0LL))
    {
      if (qword_1001DC978 != -1) {
        dispatch_once(&qword_1001DC978, &stru_1001AFA38);
      }
      _NRLogWithArgs( qword_1001DC970,  0LL,  "%s%.30s:%-4d %@ Control ssession got private notifies %@",  "",  "-[NRDevicePairingCandidateContext setupIKECallbacksForControlSession]_block_invoke_2",  1888LL,  WeakRetained,  v4);
    }

    __int128 v19 = 0u;
    __int128 v20 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    id v5 = v4;
    id v6 = [v5 countByEnumeratingWithState:&v17 objects:v25 count:16];
    if (v6)
    {
      uint64_t v7 = *(void *)v18;
      do
      {
        id v8 = 0LL;
        do
        {
          if (*(void *)v18 != v7) {
            objc_enumerationMutation(v5);
          }
          id v9 = *(void **)(*((void *)&v17 + 1) + 8LL * (void)v8);
          id v10 = [v9 notifyStatus];
          id v11 = (id)objc_claimAutoreleasedReturnValue([v9 notifyData]);
          if (qword_1001DC978 != -1) {
            dispatch_once(&qword_1001DC978, &stru_1001AFA38);
          }
          if ((_NRLogIsLevelEnabled(qword_1001DC970, 0LL) & 1) != 0)
          {
            if (qword_1001DC978 != -1) {
              dispatch_once(&qword_1001DC978, &stru_1001AFA38);
            }
            id v12 = (id)qword_1001DC970;
            _NRLogWithArgs( v12,  0,  "%s%.30s:%-4d %@ Received notify code %u len %llu for %s session",  "",  "-[NRDevicePairingCandidateContext handleNotifyCode:payload:controlSession:]",  1656,  WeakRetained,  v10,  [v11 length],  "control");
          }

          if ((int)v10 > 50700)
          {
            if ((int)v10 <= 50900)
            {
              if (((_DWORD)v10 - 50801) > 0xB || ((1 << ((_BYTE)v10 - 113)) & 0xC03) == 0)
              {
                int v14 = -50701;
LABEL_50:
                if (((_DWORD)v10 + v14) >= 2)
                {
LABEL_43:
                  if (qword_1001DC978 != -1) {
                    dispatch_once(&qword_1001DC978, &stru_1001AFA38);
                  }
                  if (_NRLogIsLevelEnabled(qword_1001DC970, 0LL))
                  {
                    if (qword_1001DC978 != -1) {
                      dispatch_once(&qword_1001DC978, &stru_1001AFA38);
                    }
                    id v15 = (id)qword_1001DC970;
                    _NRLogWithArgs( v15,  0LL,  "%s%.30s:%-4d %@ Received unknown notify code %u",  "",  "-[NRDevicePairingCandidateContext handleNotifyCode:payload:controlSession:]",  1806LL,  WeakRetained,  v10);
                  }

                  goto LABEL_57;
                }
              }

              goto LABEL_51;
            }

            if ((int)v10 <= 51400)
            {
              if ((_DWORD)v10 != 50901)
              {
                int v13 = 51301;
                goto LABEL_42;
              }
            }

            else if ((_DWORD)v10 != 51401 && (_DWORD)v10 != 51501)
            {
              int v13 = 51601;
              goto LABEL_42;
            }

void sub_1000FCB3C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, char a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37)
{
}

uint64_t sub_1000FCD08(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1000FCD18(uint64_t a1)
{
}

uint64_t sub_1000FCD20(uint64_t a1, unsigned __int8 *a2)
{
  unsigned int v4 = *(unsigned __int16 *)(a2 + 1);
  uint64_t v5 = __rev16(v4);
  int v6 = *a2;
  if (v6 == 2)
  {
    if (v5 > 0x1F)
    {
      uint64_t v7 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a2 + 3, v5);
      uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8LL);
      id v9 = *(void **)(v8 + 40);
      *(void *)(v8 + 40) = v7;

      return 1LL;
    }

    id v14 = sub_1000FBEC0();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v14, 16LL);

    if (IsLevelEnabled)
    {
      id v13 = sub_1000FBEC0();
      _NRLogWithArgs(v13, 16LL, "%s%.30s:%-4d Invalid TLV length %u for PIN salt");
      goto LABEL_18;
    }
  }

  else
  {
    if (v6 != 1)
    {
      if (qword_1001DC978 != -1) {
        dispatch_once(&qword_1001DC978, &stru_1001AFA38);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC970, 0LL))
      {
        if (qword_1001DC978 != -1) {
          dispatch_once(&qword_1001DC978, &stru_1001AFA38);
        }
        _NRLogWithArgs( qword_1001DC970,  0LL,  "%s%.30s:%-4d Unrecognized TLV type %u",  "",  "-[NRDevicePairingCandidateContext handleNotifyCode:payload:controlSession:]_block_invoke",  1685,  *a2);
      }

      return 1LL;
    }

    if (v4 == 256)
    {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a2[3];
      return 1LL;
    }

    id v11 = sub_1000FBEC0();
    int v12 = _NRLogIsLevelEnabled(v11, 16LL);

    if (v12)
    {
      id v13 = sub_1000FBEC0();
      _NRLogWithArgs(v13, 16LL, "%s%.30s:%-4d Invalid TLV length %u for auth method");
LABEL_18:

      return 0LL;
    }
  }

  return 0LL;
}

void sub_1000FD754(uint64_t a1)
{
  if (a1)
  {
    sub_1000FD7F0(a1);
    if (*(void *)(a1 + 64))
    {
      id WeakRetained = objc_loadWeakRetained((id *)(a1 + 16));
      uint64_t v3 = WeakRetained;
      if (WeakRetained) {
        unsigned int v4 = (void *)*((void *)WeakRetained + 9);
      }
      else {
        unsigned int v4 = 0LL;
      }
      uint64_t v5 = *(void *)(a1 + 64);
      id v6 = v4;
      [v6 cancelPeripheralConnection:v5];

      uint64_t v7 = *(void **)(a1 + 64);
      *(void *)(a1 + 64) = 0LL;
    }

    sub_1000FC09C((uint64_t)&OBJC_CLASS___NRDevicePairingCandidateContext, (id *)(a1 + 120));
    *(_BYTE *)(a1 + 9) = 0;
    sub_1000FC09C((uint64_t)&OBJC_CLASS___NRDevicePairingCandidateContext, (id *)(a1 + 128));
    *(_BYTE *)(a1 + 10) = 0;
  }

void sub_1000FD7F0(uint64_t a1)
{
  id v2 = (_OWORD *)(a1 + 72);
  os_log_t v1 = *(void **)(a1 + 72);
  if (v1)
  {
    unsigned int v4 = *(dispatch_source_s **)(a1 + 104);
    if (v4)
    {
      dispatch_source_cancel(v4);
      uint64_t v5 = *(void **)(a1 + 104);
      *(void *)(a1 + 104) = 0LL;

      os_log_t v1 = *(void **)(a1 + 72);
    }

    _OWORD *v2 = 0u;
    v2[1] = 0u;

    id v6 = *(void **)(a1 + 112);
    if (v6)
    {
      [v6 cancel];
      uint64_t v7 = *(void **)(a1 + 112);
      *(void *)(a1 + 112) = 0LL;
    }

    sub_1000FC09C((uint64_t)&OBJC_CLASS___NRDevicePairingCandidateContext, (id *)(a1 + 120));
    *(_BYTE *)(a1 + 9) = 0;
    sub_1000FC09C((uint64_t)&OBJC_CLASS___NRDevicePairingCandidateContext, (id *)(a1 + 128));
    *(_BYTE *)(a1 + 10) = 0;
    uint64_t v8 = *(void **)(a1 + 136);
    *(void *)(a1 + 136) = 0LL;

    if (*(void *)(a1 + 144))
    {
      uint64_t v9 = *(void *)(a1 + 152);
      if (v9 || (uint64_t v9 = *(void *)(a1 + 160)) != 0) {
        *(void *)(a1 + 144) = v9;
      }
    }

    *(void *)(a1 + 152) = 0LL;
    *(void *)(a1 + 160) = 0LL;
  }

void sub_1000FD8A8(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  id v2 = (void *)qword_1001DC970;
  qword_1001DC970 = (uint64_t)v1;
}

void sub_1000FD8D8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 88);
    if (v2)
    {
      uint64_t next_slot = os_channel_get_next_slot(v2, 0LL, v17);
      if (next_slot)
      {
        uint64_t v4 = next_slot;
        do
        {
          uint64_t v5 = v4;
          id v6 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", v19, v18);
          [*(id *)(v1 + 136) receivePacketData:v6];
          uint64_t v4 = os_channel_get_next_slot(*(void *)(v1 + 88), v4, v17);
        }

        while (v4);
        int v7 = os_channel_advance_slot(*(void *)(v1 + 88), v5);
        if (v7)
        {
          int v9 = v7;
          if (qword_1001DC978 != -1) {
            dispatch_once(&qword_1001DC978, &stru_1001AFA38);
          }
          id v10 = (id)qword_1001DC970;
          int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 17LL);

          if (IsLevelEnabled)
          {
            if (qword_1001DC978 != -1) {
              dispatch_once(&qword_1001DC978, &stru_1001AFA38);
            }
            id v12 = (id)qword_1001DC970;
            _NRLogWithArgs(v12, 17LL, "os_channel_advance_slot failed: %d", v9);
          }
        }

        int v8 = os_channel_sync(*(void *)(v1 + 80), 1LL);
        if (v8)
        {
          int v13 = v8;
          if (qword_1001DC978 != -1) {
            dispatch_once(&qword_1001DC978, &stru_1001AFA38);
          }
          id v14 = (id)qword_1001DC970;
          int v15 = _NRLogIsLevelEnabled(v14, 17LL);

          if (v15)
          {
            if (qword_1001DC978 != -1) {
              dispatch_once(&qword_1001DC978, &stru_1001AFA38);
            }
            id v16 = (id)qword_1001DC970;
            _NRLogWithArgs(v16, 17LL, "os_channel_advance_slot failed: %d", v13);
          }
        }
      }
    }
  }

NSMutableSet *sub_1000FDAD8(uint64_t a1)
{
  if (!a1) {
    return (NSMutableSet *)0LL;
  }
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  id v3 = *(id *)(a1 + 40);
  id v4 = [v3 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v14;
    do
    {
      int v7 = 0LL;
      do
      {
        if (*(void *)v14 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = objc_claimAutoreleasedReturnValue( objc_msgSend( *(id *)(a1 + 40),  "objectForKeyedSubscript:",  *(void *)(*((void *)&v13 + 1) + 8 * (void)v7),  (void)v13));
        int v9 = (id *)v8;
        if (v8 && (*(void *)(v8 + 144) || *(void *)(v8 + 152) || *(void *)(v8 + 160)))
        {
          id v10 = *(id *)(v8 + 64);
          id v11 = v10;
          if (!v10 || [v10 state] != (id)1 && objc_msgSend(v11, "state") != (id)2)
          {

            id v11 = (void *)objc_claimAutoreleasedReturnValue([v9[4] cbUUID]);
            -[NSMutableSet addObject:](v2, "addObject:", v11);
          }
        }

        int v7 = (char *)v7 + 1;
      }

      while (v5 != v7);
      id v5 = [v3 countByEnumeratingWithState:&v13 objects:v17 count:16];
    }

    while (v5);
  }

  return v2;
}

void sub_1000FDC74(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) allObjects]);
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v2 retrievePeripheralsWithIdentifiers:v3]);

  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472LL;
  id v7[2] = sub_1000FDD1C;
  v7[3] = &unk_1001B0720;
  id v5 = *(dispatch_queue_s **)(a1 + 48);
  void v7[4] = *(void *)(a1 + 56);
  id v8 = v4;
  id v6 = v4;
  dispatch_async(v5, v7);
}

void sub_1000FDD1C(uint64_t a1)
{
  uint64_t v2 = sub_1000FDAD8(*(void *)(a1 + 32));
  id v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  id obj = *(id *)(a1 + 40);
  id v4 = [obj countByEnumeratingWithState:&v24 objects:v28 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v25;
    do
    {
      for (uint64_t i = 0LL; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v25 != v6) {
          objc_enumerationMutation(obj);
        }
        id v8 = *(void **)(*((void *)&v24 + 1) + 8LL * (void)i);
        int v9 = (void *)objc_claimAutoreleasedReturnValue([v8 identifier]);
        unsigned int v10 = [v3 containsObject:v9];

        if (v10)
        {
          id v11 = *(void **)(a1 + 32);
          if (v11) {
            id v11 = (void *)v11[6];
          }
          id v12 = v11;
          __int128 v13 = (void *)objc_claimAutoreleasedReturnValue([v8 identifier]);
          __int128 v14 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:v13]);

          uint64_t v15 = *(void *)(a1 + 32);
          if (v15) {
            __int128 v16 = *(void **)(v15 + 40);
          }
          else {
            __int128 v16 = 0LL;
          }
          uint64_t v17 = objc_claimAutoreleasedReturnValue([v16 objectForKeyedSubscript:v14]);
          unsigned __int16 v18 = (id *)v17;
          if (v17 && (*(void *)(v17 + 144) || *(void *)(v17 + 152) || *(void *)(v17 + 160)))
          {
            id v19 = *(id *)(v17 + 64);
            __int128 v20 = v19;
            if (v19 && ([v19 state] == (id)1 || objc_msgSend(v20, "state") == (id)2))
            {
            }

            else
            {

              if (qword_1001DC978 != -1) {
                dispatch_once(&qword_1001DC978, &stru_1001AFA38);
              }
              if (_NRLogIsLevelEnabled(qword_1001DC970, 1LL))
              {
                if (qword_1001DC978 != -1) {
                  dispatch_once(&qword_1001DC978, &stru_1001AFA38);
                }
                _NRLogWithArgs( qword_1001DC970,  1LL,  "%s%.30s:%-4d Connecting to %@",  "",  "-[NRDevicePairingManagerContext connectToPeersIfNeeded]_block_invoke_2",  758LL,  v8);
              }

              objc_storeStrong(v18 + 8, v8);
              uint64_t v21 = *(void *)(a1 + 32);
              if (v21) {
                objc_super v22 = *(void **)(v21 + 72);
              }
              else {
                objc_super v22 = 0LL;
              }
              [v22 connectPeripheral:v8 options:0];
            }
          }
        }
      }

      id v5 = [obj countByEnumeratingWithState:&v24 objects:v28 count:16];
    }

    while (v5);
  }
}

void sub_1000FDFE8(uint64_t a1)
{
  if (!a1) {
    return;
  }
  objc_opt_self(&OBJC_CLASS___NRDevicePairingDirector);
  if (qword_1001DC968)
  {
    uint64_t v2 = (id *)(id)qword_1001DC968;
    goto LABEL_5;
  }

  id v3 = objc_alloc_init(&OBJC_CLASS___NRDevicePairingDirector);
  id v4 = (void *)qword_1001DC968;
  qword_1001DC968 = (uint64_t)v3;

  uint64_t v2 = (id *)(id)qword_1001DC968;
  if (v2)
  {
LABEL_5:
    id WeakRetained = objc_loadWeakRetained(v2 + 3);

    if (WeakRetained == (id)a1) {
      objc_storeWeak(v2 + 3, 0LL);
    }
  }

  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  id v6 = *(id *)(a1 + 40);
  id v7 = [v6 countByEnumeratingWithState:&v20 objects:v24 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v21;
    do
    {
      unsigned int v10 = 0LL;
      do
      {
        if (*(void *)v21 != v9) {
          objc_enumerationMutation(v6);
        }
        id v11 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( *(id *)(a1 + 40),  "objectForKeyedSubscript:",  *(void *)(*((void *)&v20 + 1) + 8 * (void)v10),  (void)v20));
        sub_1000FD754((uint64_t)v11);

        unsigned int v10 = (char *)v10 + 1;
      }

      while (v8 != v10);
      id v8 = [v6 countByEnumeratingWithState:&v20 objects:v24 count:16];
    }

    while (v8);
  }

  [*(id *)(a1 + 40) removeAllObjects];
  id v12 = *(void **)(a1 + 56);
  if (v12)
  {
    [v12 invalidate];
    __int128 v13 = *(void **)(a1 + 56);
    *(void *)(a1 + 56) = 0LL;
  }

  __int128 v14 = *(void **)(a1 + 64);
  if (v14)
  {
    [v14 invalidate];
    uint64_t v15 = *(void **)(a1 + 64);
    *(void *)(a1 + 64) = 0LL;
  }

  __int128 v16 = *(void **)(a1 + 72);
  if (v16)
  {
    [v16 setDelegate:0];
    uint64_t v17 = *(void **)(a1 + 72);
    *(void *)(a1 + 72) = 0LL;
  }

  unsigned __int16 v18 = *(void **)(a1 + 80);
  if (v18)
  {
    [v18 setDelegate:0];
    id v19 = *(void **)(a1 + 80);
    *(void *)(a1 + 80) = 0LL;
  }
}

void *sub_1000FE37C(void *a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    v18.receiver = a1;
    v18.super_class = (Class)&OBJC_CLASS___NRDevicePairingManagerConnection;
    id v5 = objc_msgSendSuper2(&v18, "init");
    if (!v5)
    {
      id v9 = sub_1000FBEC0();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 16LL);

      if (IsLevelEnabled)
      {
        id v11 = sub_1000FBEC0();
        _NRLogWithArgs( v11,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDevicePairingManagerConnection initWithConnection:]",  208);
      }

      uint64_t v12 = _os_log_pack_size(12LL);
      __int128 v13 = (char *)&v17 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      __int128 v14 = __error();
      uint64_t v15 = _os_log_pack_fill(v13, v12, *v14, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v15 = 136446210;
      *(void *)(v15 + 4) = "-[NRDevicePairingManagerConnection initWithConnection:]";
      id v16 = sub_1000FBEC0();
      _NRLogAbortWithPack(v16, v13);
    }

    a1 = v5;
    objc_storeStrong((id *)v5 + 1, a2);
    id v6 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    id v7 = (void *)a1[2];
    a1[2] = v6;
  }

  return a1;
}

id *sub_1000FE4F0(id *a1, void *a2, void *a3, void *a4)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  if (a1)
  {
    v26.receiver = a1;
    v26.super_class = (Class)&OBJC_CLASS___NRDevicePairingManagerContext;
    id v11 = (id *)objc_msgSendSuper2(&v26, "init");
    if (!v11)
    {
      id v17 = sub_1000FBEC0();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v17, 16LL);

      if (IsLevelEnabled)
      {
        id v19 = sub_1000FBEC0();
        _NRLogWithArgs( v19,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDevicePairingManagerContext initWithInfo:queue:managerConnection:]",  236);
      }

      uint64_t v20 = _os_log_pack_size(12LL);
      __int128 v21 = (char *)&v25 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      __int128 v22 = __error();
      uint64_t v23 = _os_log_pack_fill(v21, v20, *v22, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v23 = 136446210;
      *(void *)(v23 + 4) = "-[NRDevicePairingManagerContext initWithInfo:queue:managerConnection:]";
      id v24 = sub_1000FBEC0();
      _NRLogAbortWithPack(v24, v21);
    }

    a1 = v11;
    objc_storeWeak(v11 + 1, v10);
    objc_storeStrong(a1 + 2, a3);
    objc_storeStrong(a1 + 3, a2);
    uint64_t v12 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    id v13 = a1[5];
    a1[5] = v12;

    __int128 v14 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    id v15 = a1[6];
    a1[6] = v14;
  }

  return a1;
}

void sub_1000FE6B8(uint64_t a1, int64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  objc_opt_self(a1);
  id v9 = v7;
  if (!v9)
  {
    id v12 = sub_1000FBEC0();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 16LL);

    if (IsLevelEnabled)
    {
      id v14 = sub_1000FBEC0();
      _NRLogWithArgs( v14,  16LL,  "%s%.30s:%-4d ABORTING: nr_xpc_dictionary_create_reply called with NULL original",  "",  "nr_xpc_dictionary_create_reply",  88);
    }

    uint64_t v15 = _os_log_pack_size(12LL);
    id v16 = (char *)&v26 - ((__chkstk_darwin(v15) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v17 = __error();
    uint64_t v18 = _os_log_pack_fill( v16,  v15,  *v17,  &_mh_execute_header,  "%{public}s nr_xpc_dictionary_create_reply called with NULL original");
    *(_DWORD *)uint64_t v18 = 136446210;
    *(void *)(v18 + 4) = "nr_xpc_dictionary_create_reply";
LABEL_10:
    id v25 = sub_1000FBEC0();
    _NRLogAbortWithPack(v25, v16);
  }

  id v26 = v9;
  xpc_object_t reply = xpc_dictionary_create_reply(v9);
  if (!reply)
  {
    id v19 = sub_1000FBEC0();
    int v20 = _NRLogIsLevelEnabled(v19, 16LL);

    if (v20)
    {
      id v21 = sub_1000FBEC0();
      _NRLogWithArgs( v21,  16LL,  "%s%.30s:%-4d ABORTING: xpc_dictionary_create_reply failed",  "",  "nr_xpc_dictionary_create_reply",  92);
    }

    uint64_t v22 = _os_log_pack_size(12LL);
    id v16 = (char *)&v26 - ((__chkstk_darwin(v22) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v23 = __error();
    uint64_t v24 = _os_log_pack_fill( v16,  v22,  *v23,  &_mh_execute_header,  "%{public}s xpc_dictionary_create_reply failed",  v26);
    *(_DWORD *)uint64_t v24 = 136446210;
    *(void *)(v24 + 4) = "nr_xpc_dictionary_create_reply";
    goto LABEL_10;
  }

  id v11 = reply;

  xpc_dictionary_set_int64(v11, nrXPCKeyResult, a2);
  xpc_connection_send_message(v8, v11);
}

void sub_1000FE928(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    uint64_t v4 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 16) objectForKeyedSubscript:v3]);
    uint64_t v5 = v4;
    if (v4)
    {
      id v6 = *(_xpc_connection_s **)(v4 + 8);
      if (v6)
      {
        xpc_connection_cancel(v6);
        id v7 = *(void **)(v5 + 8);
        *(void *)(v5 + _Block_object_dispose(va, 8) = 0LL;
      }

      __int128 v16 = 0u;
      __int128 v17 = 0u;
      __int128 v14 = 0u;
      __int128 v15 = 0u;
      id v8 = *(id *)(v5 + 16);
      id v9 = [v8 countByEnumeratingWithState:&v14 objects:v18 count:16];
      if (v9)
      {
        id v10 = v9;
        uint64_t v11 = *(void *)v15;
        do
        {
          for (uint64_t i = 0LL; i != v10; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v15 != v11) {
              objc_enumerationMutation(v8);
            }
            id v13 = (void *)objc_claimAutoreleasedReturnValue( [*(id *)(v5 + 16) objectForKeyedSubscript:*(void *)(*((void *)&v14 + 1) + 8 * (void)i)]);
            sub_1000FDFE8((uint64_t)v13);
          }

          id v10 = [v8 countByEnumeratingWithState:&v14 objects:v18 count:16];
        }

        while (v10);
      }

      [*(id *)(v5 + 16) removeAllObjects];
      [*(id *)(a1 + 16) setObject:0 forKeyedSubscript:v3];
    }

    else
    {
      if (qword_1001DC978 != -1) {
        dispatch_once(&qword_1001DC978, &stru_1001AFA38);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC970, 16LL))
      {
        if (qword_1001DC978 != -1) {
          dispatch_once(&qword_1001DC978, &stru_1001AFA38);
        }
        _NRLogWithArgs( qword_1001DC970,  16LL,  "%s%.30s:%-4d Unable to find connection entry for %@",  "",  "-[NRDevicePairingDirector invalidateDevicePairingConnection:]",  3082LL,  v3);
      }
    }
  }
}

void sub_1000FEB34(void *a1, void *a2)
{
  id v6 = a1;
  id v7 = a2;
  uuid = xpc_dictionary_get_uuid(v6, nrXPCKeyDeviceIdentifier);
  if (!uuid)
  {
    id v24 = sub_1000FBEC0();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v24, 17LL);

    if (IsLevelEnabled)
    {
      id v26 = sub_1000FBEC0();
      _NRLogWithArgs(v26, 17LL, "Missing NRUUID from %@", v6);
    }

    goto LABEL_9;
  }

  id v9 = uuid;
  if (uuid_is_null(uuid))
  {
    if (qword_1001DC978 != -1) {
      dispatch_once(&qword_1001DC978, &stru_1001AFA38);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC970, 17LL))
    {
      if (qword_1001DC978 != -1) {
        dispatch_once(&qword_1001DC978, &stru_1001AFA38);
      }
      _NRLogWithArgs(qword_1001DC970, 17LL, "All-zero NRUUID from %@", v6);
    }

void sub_1000FEF60(void **a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  id v7 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v6);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 1LL);

  if (IsLevelEnabled)
  {
    id v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v9);
    _NRLogWithArgs( v10,  1LL,  "%s%.30s:%-4d unpairBluetoothDeviceWithNRUUID returned with result:%lld and error: %@",  "",  "-[NRDevicePairingDirector handleUnpairRequest:forConnection:]_block_invoke",  2982LL,  a2,  v5);
  }

  id v12 = sub_100129C28((uint64_t)&OBJC_CLASS___NRDLocalDevice, a1[4], 0);
  if (v12)
  {
    id v13 = a1[4];
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472LL;
    v20[2] = sub_1000FF12C;
    v20[3] = &unk_1001AF9F0;
    id v21 = v13;
    id v22 = a1[5];
    id v23 = a1[6];
    sub_100130BE8((uint64_t)&OBJC_CLASS___NRDLocalDevice, v21, v20);
  }

  else
  {
    __int128 v14 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v11);
    int v15 = _NRLogIsLevelEnabled(v14, 16LL);

    if (v15)
    {
      __int128 v17 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v16);
      _NRLogWithArgs( v17,  16LL,  "%s%.30s:%-4d localDevice not found for %@",  "",  "-[NRDevicePairingDirector handleUnpairRequest:forConnection:]_block_invoke",  2996LL,  a1[4]);
    }

    uint64_t v18 = a1[6];
    if (v18) {
      id v19 = (void *)v18[1];
    }
    else {
      id v19 = 0LL;
    }
    sub_1000FE6B8((uint64_t)&OBJC_CLASS___NRDevicePairingDirector, -2008LL, a1[5], v19);
  }
}

void sub_1000FF12C(uint64_t a1, uint64_t a2, void *a3)
{
  id v13 = a3;
  uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

  if (IsLevelEnabled)
  {
    uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v8);
    _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d unregisterDeviceWithNRUUID: nruuid %@ result %lld error %@",  "",  "-[NRDevicePairingDirector handleUnpairRequest:forConnection:]_block_invoke_2",  2989LL,  *(void *)(a1 + 32),  a2,  v13);
  }

  uint64_t v10 = *(void *)(a1 + 48);
  if (v10) {
    uint64_t v11 = *(void **)(v10 + 8);
  }
  else {
    uint64_t v11 = 0LL;
  }
  if (a2) {
    int64_t v12 = -3002LL;
  }
  else {
    int64_t v12 = 0LL;
  }
  sub_1000FE6B8((uint64_t)&OBJC_CLASS___NRDevicePairingDirector, v12, *(void **)(a1 + 40), v11);
}

BOOL sub_1000FF200(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  xpc_type_t type = xpc_get_type(v4);
  if (type == (xpc_type_t)&_xpc_type_uuid)
  {
    uint64_t v6 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", xpc_uuid_get_bytes(v4));
    [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) addObject:v6];
  }

  else
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }

  return type == (xpc_type_t)&_xpc_type_uuid;
}

void sub_1000FF2AC(uint64_t a1, void *a2)
{
  id v103 = a2;
  xpc_type_t type = xpc_get_type(v103);
  if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    if (qword_1001DC978 != -1) {
      dispatch_once(&qword_1001DC978, &stru_1001AFA38);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC970, 2LL))
    {
      if (qword_1001DC978 != -1) {
        dispatch_once(&qword_1001DC978, &stru_1001AFA38);
      }
      _NRLogWithArgs( qword_1001DC970,  2LL,  "%s%.30s:%-4d Received XPC dict: %@",  "",  "-[NRDevicePairingDirector addDevicePairingConnection:]_block_invoke",  3063LL,  v103);
    }

    uint64_t v5 = *(void *)(a1 + 32);
    id v4 = *(void **)(a1 + 40);
    xpc_object_t xdict = v103;
    id v6 = v4;
    if (!v5) {
      goto LABEL_111;
    }
    id v100 = v6;
    __int128 v102 = (void **)objc_claimAutoreleasedReturnValue([*(id *)(v5 + 16) objectForKeyedSubscript:v6]);
    if (!v102)
    {
      if (qword_1001DC978 != -1) {
        dispatch_once(&qword_1001DC978, &stru_1001AFA38);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC970, 16LL))
      {
        if (qword_1001DC978 != -1) {
          dispatch_once(&qword_1001DC978, &stru_1001AFA38);
        }
        _NRLogWithArgs( qword_1001DC970,  16LL,  "%s%.30s:%-4d Unable to find connection entry for %@",  "",  "-[NRDevicePairingDirector handleIncomingRequest:forConnection:]",  2025LL,  v100);
      }

      goto LABEL_110;
    }

    xpc_object_t value = xpc_dictionary_get_value(xdict, nrXPCKeyPairingManagerOperation);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(value);
    xpc_object_t object = v8;
    uint64_t v9 = v8;
    if (v8)
    {
      if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_uint64)
      {
        uint64_t v10 = xpc_uint64_get_value(v9);
        switch(v10)
        {
          case 1uLL:
            id v11 = xdict;
            int64_t v12 = v102;
            xpc_object_t v13 = xpc_dictionary_get_value(v11, nrXPCKeyPairingManagerInfo);
            __int128 v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
            int v15 = v14;
            uint64_t v16 = v12;
            if (v14 && xpc_get_type(v14) == (xpc_type_t)&_xpc_type_data)
            {
              __int128 v17 = objc_alloc(&OBJC_CLASS___NSData);
              bytes_ptr = xpc_data_get_bytes_ptr(v15);
              v119[0] = 0LL;
              uint64_t v95 = -[NSData initWithBytes:length:](v17, "initWithBytes:length:", bytes_ptr, xpc_data_get_length(v15));
              id v19 = +[NSKeyedUnarchiver unarchivedObjectOfClass:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClass:fromData:error:",  objc_opt_class(&OBJC_CLASS___NRDevicePairingManagerInfo),  v95,  v119);
              int v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
              id v21 = v16;
              xpc_object_t xarray = v119[0];
              if (xarray)
              {
                id v75 = sub_1000FBEC0();
                int IsLevelEnabled = _NRLogIsLevelEnabled(v75, 17LL);

                if (IsLevelEnabled)
                {
                  id v77 = sub_1000FBEC0();
                  _NRLogWithArgs(v77, 17LL, "Failed to unarchive NRDevicePairingManagerInfo %@", xarray);
                }
              }

              else
              {
                id v22 = v16[2];
                id v23 = (void *)objc_claimAutoreleasedReturnValue([v20 uuid]);
                id v24 = (void *)objc_claimAutoreleasedReturnValue([v22 objectForKeyedSubscript:v23]);

                if (!v24)
                {
                  id v25 = (void *)objc_claimAutoreleasedReturnValue([v20 pairingCriteria]);
                  id v26 = v25;
                  if (v25)
                  {
                    if ([v25 pairingTransport] == 1)
                    {
                      id v27 = sub_1000FE4F0( (id *)objc_alloc(&OBJC_CLASS___NRDevicePairingManagerContext),  v20,  *(void **)(v5 + 8),  v16);
                      id v28 = v16[2];
                      id v29 = (void *)objc_claimAutoreleasedReturnValue([v20 uuid]);
                      [v28 setObject:v27 forKeyedSubscript:v29];

                      if (qword_1001DC978 != -1) {
                        dispatch_once(&qword_1001DC978, &stru_1001AFA38);
                      }
                      if (_NRLogIsLevelEnabled(qword_1001DC970, 0LL))
                      {
                        if (qword_1001DC978 != -1) {
                          dispatch_once(&qword_1001DC978, &stru_1001AFA38);
                        }
                        id v30 = (id)qword_1001DC970;
                        uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v20 fullDescription]);
                        _NRLogWithArgs( v30,  0LL,  "%s%.30s:%-4d Registered %@",  "",  "-[NRDevicePairingDirector handleManagerRegisterRequest:forConnection:]",  2183LL,  v31);
                      }

                      sub_1000FE6B8((uint64_t)&OBJC_CLASS___NRDevicePairingDirector, 0LL, v11, v21[1]);

                      goto LABEL_39;
                    }

                    id v84 = sub_1000FBEC0();
                    int v85 = _NRLogIsLevelEnabled(v84, 17LL);

                    if (v85)
                    {
                      id v86 = sub_1000FBEC0();
                      _NRLogWithArgs( v86,  17,  "%@ requested unsupported transport %u",  v20,  [v26 pairingTransport]);
                    }
                  }

                  else
                  {
                    id v81 = sub_1000FBEC0();
                    int v82 = _NRLogIsLevelEnabled(v81, 17LL);

                    if (v82)
                    {
                      id v83 = sub_1000FBEC0();
                      _NRLogWithArgs(v83, 17LL, "%@ sent no criteria", v20);
                    }
                  }

                  id v21 = v16;
                  sub_1000FE6B8((uint64_t)&OBJC_CLASS___NRDevicePairingDirector, -2005LL, v11, v16[1]);
LABEL_39:

LABEL_40:
                  goto LABEL_41;
                }

                id v78 = sub_1000FBEC0();
                int v79 = _NRLogIsLevelEnabled(v78, 17LL);

                if (v79)
                {
                  id v80 = sub_1000FBEC0();
                  _NRLogWithArgs(v80, 17LL, "%@ is already registered", v20);
                }
              }

              id v21 = v16;
              sub_1000FE6B8((uint64_t)&OBJC_CLASS___NRDevicePairingDirector, -2005LL, v11, v16[1]);
              goto LABEL_40;
            }

            id v66 = sub_1000FBEC0();
            int v67 = _NRLogIsLevelEnabled(v66, 17LL);

            if (v67)
            {
              id v68 = sub_1000FBEC0();
              _NRLogWithArgs(v68, 17LL, "Failed to get pairing manager info from message");
            }

            id v21 = v16;
            sub_1000FE6B8((uint64_t)&OBJC_CLASS___NRDevicePairingDirector, -2005LL, v11, v16[1]);
LABEL_41:

            goto LABEL_109;
          case 2uLL:
            id v32 = xdict;
            __int128 v33 = v102;
            uint64_t v96 = v32;
            xpc_object_t v34 = xpc_dictionary_get_value(v32, nrXPCKeyPairingManagers);
            __int128 v35 = (void *)objc_claimAutoreleasedReturnValue(v34);
            xpc_object_t xarraya = v35;
            if (v35 && xpc_get_type(v35) == (xpc_type_t)&_xpc_type_array)
            {
              uint64_t v115 = 0LL;
              int v116 = &v115;
              uint64_t v117 = 0x2020000000LL;
              char v118 = 0;
              uint64_t v109 = 0LL;
              id v110 = &v109;
              uint64_t v111 = 0x3032000000LL;
              int v112 = sub_1000FCD08;
              int v113 = sub_1000FCD18;
              BOOL v114 = -[NSMutableSet initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableSet),  "initWithCapacity:",  xpc_array_get_count(xarraya));
              applier[0] = _NSConcreteStackBlock;
              applier[1] = 3221225472LL;
              applier[2] = sub_1000FF200;
              applier[3] = &unk_1001AF9C8;
              applier[4] = &v115;
              applier[5] = &v109;
              xpc_array_apply(xarraya, applier);
              if (*((_BYTE *)v116 + 24) || ![(id)v110[5] count])
              {
                id v72 = sub_1000FBEC0();
                char v73 = _NRLogIsLevelEnabled(v72, 17LL);

                if ((v73 & 1) != 0)
                {
                  id v74 = sub_1000FBEC0();
                  _NRLogWithArgs(v74, 17LL, "Failed to get pairing manager UUIDs from message");
                }

                id v51 = v33[1];
                sub_1000FE6B8((uint64_t)&OBJC_CLASS___NRDevicePairingDirector, -2005LL, v96, v51);
              }

              else
              {
                __int128 v106 = 0u;
                __int128 v107 = 0u;
                __int128 v104 = 0u;
                __int128 v105 = 0u;
                id v36 = (id)v110[5];
                id v37 = [v36 countByEnumeratingWithState:&v104 objects:v119 count:16];
                if (v37)
                {
                  uint64_t v38 = *(void *)v105;
                  do
                  {
                    int v39 = 0LL;
                    do
                    {
                      if (*(void *)v105 != v38) {
                        objc_enumerationMutation(v36);
                      }
                      uint64_t v40 = *(void *)(*((void *)&v104 + 1) + 8LL * (void)v39);
                      id v41 = v33[2];
                      id v42 = (void *)objc_claimAutoreleasedReturnValue([v41 objectForKeyedSubscript:v40]);

                      if (v42)
                      {
                        if (qword_1001DC978 != -1) {
                          dispatch_once(&qword_1001DC978, &stru_1001AFA38);
                        }
                        id v43 = (id)qword_1001DC970;
                        int v44 = _NRLogIsLevelEnabled(v43, 0LL);

                        if (v44)
                        {
                          if (qword_1001DC978 != -1) {
                            dispatch_once(&qword_1001DC978, &stru_1001AFA38);
                          }
                          id v45 = (id)qword_1001DC970;
                          _NRLogWithArgs( v45,  0LL,  "%s%.30s:%-4d Unregistered %@",  "",  "-[NRDevicePairingDirector handleManagerUnregisterRequest:forConnection:]",  2230LL,  v42);
                        }

                        sub_1000FDFE8((uint64_t)v42);
                        id v46 = v33[2];
                        [v46 setObject:0 forKeyedSubscript:v40];
LABEL_72:

                        goto LABEL_73;
                      }

                      *((_BYTE *)v116 + 24) = 1;
                      if (qword_1001DC978 != -1) {
                        dispatch_once(&qword_1001DC978, &stru_1001AFA38);
                      }
                      id v47 = (id)qword_1001DC970;
                      char v48 = _NRLogIsLevelEnabled(v47, 17LL);

                      if ((v48 & 1) != 0)
                      {
                        if (qword_1001DC978 != -1) {
                          dispatch_once(&qword_1001DC978, &stru_1001AFA38);
                        }
                        id v46 = (id)qword_1001DC970;
                        _NRLogWithArgs(v46, 17LL, "Pairing manager %@ is not registered", v40);
                        goto LABEL_72;
                      }

void sub_100100290( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, char a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, char a41)
{
}

void sub_100100810(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC980;
  qword_1001DC980 = (uint64_t)v1;
}

id sub_100100840()
{
  if (qword_1001DC988 != -1) {
    dispatch_once(&qword_1001DC988, &stru_1001AFA58);
  }
  return (id)qword_1001DC980;
}

void sub_100100880(id a1)
{
  uint64_t v1 = MGCopyAnswer(@"SupplementalBuildVersion", 0LL);
  uint64_t v2 = (void *)qword_1001DC990;
  qword_1001DC990 = v1;

  if (qword_1001DCA58 != -1) {
    dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCA50, 1LL))
  {
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    _NRLogWithArgs( qword_1001DCA50,  1LL,  "%s%.30s:%-4d deviceBuildVersion is %@",  "",  "_NRCopyDeviceBuildVersion_block_invoke",  61LL,  qword_1001DC990);
  }

  id v3 = (__CFString *)qword_1001DC990;
  if (!qword_1001DC990)
  {
    qword_1001DC990 = (uint64_t)@"Unknown";
    id v3 = @"Unknown";
  }

  if ((unint64_t)-[__CFString length](v3, "length") >= 0xFF)
  {
    uint64_t v4 = objc_claimAutoreleasedReturnValue([(id)qword_1001DC990 substringToIndex:254]);
    uint64_t v5 = (void *)qword_1001DC990;
    qword_1001DC990 = v4;
  }

void sub_1001009AC(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DCA50;
  qword_1001DCA50 = (uint64_t)v1;
}

void sub_1001009DC(id a1)
{
  uint64_t v1 = MGCopyAnswer(@"UserAssignedDeviceName", 0LL);
  uint64_t v2 = (void *)qword_1001DC9A0;
  qword_1001DC9A0 = v1;

  if (qword_1001DCA58 != -1) {
    dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCA50, 1LL))
  {
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    _NRLogWithArgs( qword_1001DCA50,  1LL,  "%s%.30s:%-4d deviceName is %@",  "",  "_NRCopyDeviceName_block_invoke",  79LL,  qword_1001DC9A0);
  }

  id v3 = (__CFString *)qword_1001DC9A0;
  if (!qword_1001DC9A0)
  {
    qword_1001DC9A0 = (uint64_t)@"Unknown";
    id v3 = @"Unknown";
  }

  if ((unint64_t)-[__CFString length](v3, "length") >= 0x10000)
  {
    uint64_t v4 = objc_claimAutoreleasedReturnValue([(id)qword_1001DC9A0 substringToIndex:0xFFFFLL]);
    uint64_t v5 = (void *)qword_1001DC9A0;
    qword_1001DC9A0 = v4;
  }

void sub_100100B08(id a1)
{
  int v3 = 0;
  size_t v2 = 4LL;
  if (sysctlbyname("kern.hv_vmm_present", &v3, &v2, 0LL, 0LL))
  {
    int v1 = *__error();
    if (strerror_r(v1, __strerrbuf, 0x80uLL)) {
      __strerrbuf[0] = 0;
    }
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      _NRLogWithArgs(qword_1001DCA50, 17LL, "Failed to read sysctl kern.hv_vmm_present: [%d] %s", v1, __strerrbuf);
    }
  }

  else
  {
    byte_1001DC9B0 = v3 != 0;
  }

void sub_100100C3C(id a1)
{
  CFBooleanRef v1 = (CFBooleanRef)MGCopyAnswer(@"PasswordConfigured", 0LL);
  byte_1001DC9C0 = v1 == kCFBooleanTrue;
  if (v1) {
    CFRelease(v1);
  }
}

id sub_100100C84()
{
  if (qword_1001DCA58 != -1) {
    dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
  }
  return (id)qword_1001DCA50;
}

uint64_t sub_100100CC4(int a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (![v5 length])
  {
    id v17 = sub_100100C84();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v17, 17LL);

    if (IsLevelEnabled)
    {
      id v19 = sub_100100C84();
      _NRLogWithArgs(v19, 17LL, "%s called with null filePath.length", "NRDSafeWriteDataToFileDescriptor");
    }

    goto LABEL_28;
  }

  memset(&v20, 0, sizeof(v20));
  if (fstat(a1, &v20))
  {
    id v7 = __error();
    uint64_t v8 = *v7;
    if (strerror_r(*v7, __strerrbuf, 0x80uLL)) {
      __strerrbuf[0] = 0;
    }
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      _NRLogWithArgs(qword_1001DCA50, 17LL, "Failed to stat %@: [%d] %s", v5, v8, __strerrbuf);
    }

uint64_t sub_1001010F0(void *a1, void *a2, int a3)
{
  id v5 = a1;
  id v6 = a2;
  if (!v5)
  {
    id v16 = sub_100100C84();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v16, 17LL);

    if (IsLevelEnabled)
    {
      id v18 = sub_100100C84();
      _NRLogWithArgs(v18, 17LL, "%s called with null filePath");
LABEL_32:
    }

uint64_t sub_1001013AC(void *a1, void *a2, int a3)
{
  id v5 = a1;
  id v6 = a2;
  if (!v5)
  {
    id v12 = sub_100100C84();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 17LL);

    if (!IsLevelEnabled) {
      goto LABEL_23;
    }
    id v14 = sub_100100C84();
    _NRLogWithArgs(v14, 17LL, "%s called with null filePath");
LABEL_22:

    uint64_t v10 = 0LL;
    goto LABEL_15;
  }

  if (![v5 length])
  {
    id v15 = sub_100100C84();
    int v16 = _NRLogIsLevelEnabled(v15, 17LL);

    if (!v16) {
      goto LABEL_23;
    }
    id v14 = sub_100100C84();
    _NRLogWithArgs(v14, 17LL, "%s called with null filePath.length");
    goto LABEL_22;
  }

  if (!v6)
  {
    id v17 = sub_100100C84();
    int v18 = _NRLogIsLevelEnabled(v17, 17LL);

    if (v18)
    {
      id v14 = sub_100100C84();
      _NRLogWithArgs(v14, 17LL, "%s called with null dictionaryToWrite");
      goto LABEL_22;
    }

unint64_t sub_1001015B8()
{
  if (qword_1001DC9D8 != -1) {
    dispatch_once(&qword_1001DC9D8, &stru_1001AFB58);
  }
  do
    unint64_t v0 = __ldxr((unint64_t *)&qword_1001DC9D0);
  while (__stxr(v0 + 1, (unint64_t *)&qword_1001DC9D0));
  if (!v0)
  {
    do
    {
      unint64_t v0 = __ldxr((unint64_t *)&qword_1001DC9D0);
      else {
        BOOL v2 = v0 == 0;
      }
    }

    while (v2);
  }

  if (qword_1001DCA58 != -1) {
    dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCA50, 1LL))
  {
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    _NRLogWithArgs( qword_1001DCA50,  1LL,  "%s%.30s:%-4d Returning sequence number: %llu",  "",  "NRDGetUniqueSequenceNumber",  310,  v0);
  }

  return v0;
}

void sub_1001016D4(id a1)
{
  mach_timebase_info info = 0LL;
  uint64_t v1 = mach_timebase_info(&info);
  uint64_t v2 = mach_boottime_usec(v1);
  qword_1001DC9D0 = v2 + ((mach_continuous_time() * info.numer / (1000 * info.denom)) >> 1);
}

id sub_10010172C(void *a1)
{
  id v1 = a1;
  id v2 = (id)NEHelperCacheCopyAppUUIDMapping([v1 UTF8String], 0);
  int v3 = v2;
  if (v2 && xpc_get_type(v2) == (xpc_type_t)&_xpc_type_array)
  {
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 3221225472LL;
    applier[2] = sub_100101814;
    applier[3] = &unk_1001AFD10;
    id v4 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](&OBJC_CLASS___NSMutableArray, "array"));
    id v7 = v4;
    xpc_array_apply(v3, applier);
    if (![v4 count])
    {

      id v4 = 0LL;
    }
  }

  else
  {
    id v4 = 0LL;
  }

  return v4;
}

uint64_t sub_100101814(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = v4;
  if (v4 && xpc_get_type(v4) == (xpc_type_t)&_xpc_type_uuid)
  {
    id v6 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", xpc_uuid_get_bytes(v5));
    [*(id *)(a1 + 32) addObject:v6];
  }

  return 1LL;
}

void sub_10010189C(id a1)
{
  id v1 = (dispatch_queue_attr_s *)_NRCopySerialQueueAttr(a1);
  dispatch_queue_t v2 = dispatch_queue_create("com.apple.networkrelay.powerlog", v1);

  if (!v2)
  {
    id v4 = sub_100100C84();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16LL);

    if (IsLevelEnabled)
    {
      id v6 = sub_100100C84();
      _NRLogWithArgs( v6,  16LL,  "%s%.30s:%-4d ABORTING: dispatch_queue_create(%s) failed",  "",  "nr_dispatch_queue_create",  118,  "com.apple.networkrelay.powerlog");
    }

    uint64_t v7 = _os_log_pack_size(22LL);
    id v8 = (char *)&v12 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v9 = __error();
    uint64_t v10 = _os_log_pack_fill( v8,  v7,  *v9,  &_mh_execute_header,  "%{public}s dispatch_queue_create(%s) failed");
    *(_DWORD *)uint64_t v10 = 136446466;
    *(void *)(v10 + 4) = "nr_dispatch_queue_create";
    *(_WORD *)(v10 + 12) = 2080;
    *(void *)(v10 + 14) = "com.apple.networkrelay.powerlog";
    id v11 = sub_100100C84();
    _NRLogAbortWithPack(v11, v8);
  }

  int v3 = (void *)qword_1001DC9E0;
  qword_1001DC9E0 = (uint64_t)v2;
}

void sub_100101A04(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if (qword_1001DCA58 != -1) {
    dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCA50, 0LL))
  {
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    _NRLogWithArgs(qword_1001DCA50, 0LL, "%s%.30s:%-4d Submitting power log: %@:%@", "", "NRDPowerLog", 558LL, v3, v4);
  }

  if (qword_1001DC9E8 != -1) {
    dispatch_once(&qword_1001DC9E8, &stru_1001AFB78);
  }
  id v5 = (dispatch_queue_s *)qword_1001DC9E0;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100101B68;
  block[3] = &unk_1001B0720;
  id v9 = v3;
  id v10 = v4;
  id v6 = v4;
  id v7 = v3;
  dispatch_async(v5, block);
}

uint64_t sub_100101B68(uint64_t a1)
{
  uint64_t result = PLShouldLogRegisteredEvent(90LL, *(void *)(a1 + 32));
  if ((_DWORD)result) {
    return PLLogRegisteredEvent(90LL, *(void *)(a1 + 32), *(void *)(a1 + 40), 0LL);
  }
  return result;
}

void sub_100101BAC(void *a1)
{
  id v1 = a1;
  int v2 = open((const char *)[v1 UTF8String], 0);
  if (v2 == -1)
  {
    if (*__error() != 2)
    {
      id v7 = __error();
      uint64_t v8 = *v7;
      if (strerror_r(*v7, __strerrbuf, 0x80uLL)) {
        __strerrbuf[0] = 0;
      }
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
      {
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        _NRLogWithArgs(qword_1001DCA50, 17LL, "open(%@, O_RDONLY): [%d] %s", v1, v8, __strerrbuf);
      }
    }
  }

  else
  {
    int v3 = v2;
    int v4 = fcntl(v2, 63);
    if (v4 != 4)
    {
      if (v4 == -1)
      {
        id v5 = __error();
        uint64_t v6 = *v5;
        if (strerror_r(*v5, __strerrbuf, 0x80uLL)) {
          __strerrbuf[0] = 0;
        }
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
        {
          if (qword_1001DCA58 != -1) {
            dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
          }
          _NRLogWithArgs(qword_1001DCA50, 17LL, "fcntl(%@, F_GETPROTECTIONCLASS): [%d] %s", v1, v6, __strerrbuf);
        }
      }

      else if (fcntl(v3, 64, 4LL) == -1)
      {
        id v9 = __error();
        uint64_t v10 = *v9;
        if (strerror_r(*v9, __strerrbuf, 0x80uLL)) {
          __strerrbuf[0] = 0;
        }
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
        {
          if (qword_1001DCA58 != -1) {
            dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
          }
          _NRLogWithArgs( qword_1001DCA50,  17LL,  "fcntl(%@, F_SETPROTECTIONCLASS, PROTECTION_CLASS_D): [%d] %s",  v1,  v10,  __strerrbuf);
        }
      }

      else
      {
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCA50, 0LL))
        {
          if (qword_1001DCA58 != -1) {
            dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
          }
          _NRLogWithArgs( qword_1001DCA50,  0LL,  "%s%.30s:%-4d successfully updated %@ to ClassD",  "",  "NRDUpdateToDataProtectionClassD",  595LL,  v1);
        }
      }
    }

    close(v3);
  }
}

uint64_t sub_100101EE8(void *a1, int a2)
{
  id v3 = a1;
  if (!v3)
  {
    id v13 = sub_100100C84();
    uint64_t IsLevelEnabled = _NRLogIsLevelEnabled(v13, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_36;
    }
    id v14 = sub_100100C84();
    _NRLogWithArgs(v14, 17LL, "%s called with null intfName", "NRSetInterfaceSubfamily");

    goto LABEL_35;
  }

  int v4 = socket(2, 2, 0);
  if (v4 < 0)
  {
    LODWORD(v10) = *__error();
    p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    if (qword_1001DCA58 == -1) {
      goto LABEL_31;
    }
    goto LABEL_42;
  }

  int v5 = v4;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  uint64_t v6 = [v3 UTF8String];
  if (!v6)
  {
    id v15 = sub_100100C84();
    int v16 = _NRLogIsLevelEnabled(v15, 16LL);

    p_class_meths = (__objc2_meth_list **)"_strict_strlcpy";
    if (v16)
    {
      id v17 = sub_100100C84();
      _NRLogWithArgs( v17,  16LL,  "%s%.30s:%-4d ABORTING: strict_strlcpy called with NULL src",  "",  "_strict_strlcpy",  240);
    }

    id v3 = (id)_os_log_pack_size(12LL);
    uint64_t v10 = &__strerrbuf[-((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL)];
    int v18 = __error();
    uint64_t v19 = _os_log_pack_fill( v10,  v3,  *v18,  &_mh_execute_header,  "%{public}s strict_strlcpy called with NULL src");
    *(_DWORD *)uint64_t v19 = 136446210;
    *(void *)(v19 + 4) = "_strict_strlcpy";
    id v20 = sub_100100C84();
    _NRLogAbortWithPack(v20, v10);
LABEL_42:
    dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
LABEL_31:
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
    {
      if (p_class_meths[331] != (__objc2_meth_list *)-1LL) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      _NRLogWithArgs( qword_1001DCA50,  17LL,  "Failed to create socket for setting interface sub family - %d",  (_DWORD)v10);
    }

BOOL sub_1001022B8(void *a1, const char *a2)
{
  id v5 = a1;
  if (v5)
  {
    int v6 = socket(2, 2, 0);
    if ((v6 & 0x80000000) == 0)
    {
      LODWORD(v7) = v6;
      __int128 v23 = 0u;
      __int128 v24 = 0u;
      uint64_t v8 = [v5 UTF8String];
      if (v8)
      {
        LOBYTE(v23) = *v8;
        if ((_BYTE)v23)
        {
          BYTE1(v23) = v8[1];
          if (BYTE1(v23))
          {
            BYTE2(v23) = v8[2];
            if (BYTE2(v23))
            {
              BYTE3(v23) = v8[3];
              if (BYTE3(v23))
              {
                BYTE4(v23) = v8[4];
                if (BYTE4(v23))
                {
                  BYTE5(v23) = v8[5];
                  if (BYTE5(v23))
                  {
                    BYTE6(v23) = v8[6];
                    if (BYTE6(v23))
                    {
                      BYTE7(v23) = v8[7];
                      if (BYTE7(v23))
                      {
                        BYTE8(v23) = v8[8];
                        if (BYTE8(v23))
                        {
                          BYTE9(v23) = v8[9];
                          if (BYTE9(v23))
                          {
                            BYTE10(v23) = v8[10];
                            if (BYTE10(v23))
                            {
                              BYTE11(v23) = v8[11];
                              if (BYTE11(v23))
                              {
                                BYTE12(v23) = v8[12];
                                if (BYTE12(v23))
                                {
                                  BYTE13(v23) = v8[13];
                                  if (BYTE13(v23))
                                  {
                                    BYTE14(v23) = v8[14];
                                    if (BYTE14(v23)) {
                                      HIBYTE(v23) = 0;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        LODWORD(v24) = (_DWORD)a2;
        int v9 = ioctl((int)v7, 0xC02069DCuLL, &v23);
        BOOL v2 = v9 >= 0;
        if (v9 < 0)
        {
          int v11 = *__error();
          if (strerror_r(v11, __strerrbuf, 0x80uLL)) {
            __strerrbuf[0] = 0;
          }
          if (qword_1001DCA58 != -1) {
            dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
          {
            if (qword_1001DCA58 != -1) {
              dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
            }
            _NRLogWithArgs( qword_1001DCA50,  17LL,  "ioctl SIOCSIFPEEREGRESSFUNCTIONALTYPE failed: [%d] %s",  v11,  __strerrbuf);
          }

          goto LABEL_41;
        }

        p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
        if (qword_1001DCA58 == -1)
        {
LABEL_22:
          if (_NRLogIsLevelEnabled(qword_1001DCA50, 1LL))
          {
            if (p_class_meths[331] != (__objc2_meth_list *)-1LL) {
              dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
            }
            _NRLogWithArgs( qword_1001DCA50,  1LL,  "%s%.30s:%-4d Set peer egress interface type for %@ to %u",  "",  "NRSetInterfacePeerDeviceEgressFunctionalType",  649LL,  v5,  a2);
          }

uint64_t sub_100102728(void *a1)
{
  id v1 = a1;
  if (!v1)
  {
    id v11 = sub_100100C84();
    uint64_t IsLevelEnabled = _NRLogIsLevelEnabled(v11, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_36;
    }
    id v12 = sub_100100C84();
    _NRLogWithArgs(v12, 17LL, "%s called with null intfName", "NRSetInterfaceNoACKPrioritization");

    goto LABEL_35;
  }

  int v2 = socket(2, 2, 0);
  if (v2 < 0)
  {
    LODWORD(v_Block_object_dispose(va, 8) = *__error();
    p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    if (qword_1001DCA58 == -1) {
      goto LABEL_31;
    }
    goto LABEL_42;
  }

  int v3 = v2;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  int v4 = [v1 UTF8String];
  if (!v4)
  {
    id v13 = sub_100100C84();
    int v14 = _NRLogIsLevelEnabled(v13, 16LL);

    p_class_meths = (__objc2_meth_list **)"_strict_strlcpy";
    if (v14)
    {
      id v15 = sub_100100C84();
      _NRLogWithArgs( v15,  16LL,  "%s%.30s:%-4d ABORTING: strict_strlcpy called with NULL src",  "",  "_strict_strlcpy",  240);
    }

    id v1 = (id)_os_log_pack_size(12LL);
    uint64_t v8 = &__strerrbuf[-((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL)];
    id v16 = __error();
    uint64_t v17 = _os_log_pack_fill( v8,  v1,  *v16,  &_mh_execute_header,  "%{public}s strict_strlcpy called with NULL src");
    *(_DWORD *)uint64_t v17 = 136446210;
    *(void *)(v17 + 4) = "_strict_strlcpy";
    id v18 = sub_100100C84();
    _NRLogAbortWithPack(v18, v8);
LABEL_42:
    dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
LABEL_31:
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
    {
      if (p_class_meths[331] != (__objc2_meth_list *)-1LL) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      _NRLogWithArgs(qword_1001DCA50, 17LL, "Failed to create socket for setting interface sub family - %d", (_DWORD)v8);
    }

NSUUID *sub_100102AF8(void *a1)
{
  id v1 = a1;
  if (!v1)
  {
    id v11 = sub_100100C84();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 17LL);

    if (IsLevelEnabled)
    {
      id v13 = sub_100100C84();
      _NRLogWithArgs(v13, 17LL, "%s called with null intfName", "NRCopyNetIfUUID");
    }

    goto LABEL_54;
  }

  int v2 = socket(2, 2, 0);
  if (v2 < 0)
  {
    LODWORD(v5) = *__error();
    p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    if (qword_1001DCA58 == -1) {
      goto LABEL_31;
    }
    goto LABEL_61;
  }

  int v3 = v2;
  int v4 = (char *)objc_msgSend(v1, "UTF8String", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  if (!v4)
  {
    id v14 = sub_100100C84();
    int v15 = _NRLogIsLevelEnabled(v14, 16LL);

    p_class_meths = (__objc2_meth_list **)"_strict_strlcpy";
    if (v15)
    {
      id v16 = sub_100100C84();
      _NRLogWithArgs( v16,  16LL,  "%s%.30s:%-4d ABORTING: strict_strlcpy called with NULL src",  "",  "_strict_strlcpy",  240);
    }

    id v1 = (id)_os_log_pack_size(12LL);
    int v5 = &v20 - ((__chkstk_darwin(v1) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v17 = __error();
    uint64_t v18 = _os_log_pack_fill( v5,  v1,  *v17,  &_mh_execute_header,  "%{public}s strict_strlcpy called with NULL src");
    *(_DWORD *)uint64_t v18 = 136446210;
    *(void *)(v18 + 4) = "_strict_strlcpy";
    id v19 = sub_100100C84();
    _NRLogAbortWithPack(v19, v5);
LABEL_61:
    dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
LABEL_31:
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
    {
      if (p_class_meths[331] != (__objc2_meth_list *)-1LL) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      _NRLogWithArgs( qword_1001DCA50,  17LL,  "Failed to create socket for SIOCGIFNEXUS: [%d] %s",  (_DWORD)v5,  __strerrbuf);
    }

    goto LABEL_54;
  }

  char v20 = *v4;
  if (v20)
  {
    if (v4[1])
    {
      if (v4[2])
      {
        if (v4[3])
        {
          if (v4[4])
          {
            if (v4[5])
            {
              if (v4[6])
              {
                if (v4[7])
                {
                  if (v4[8])
                  {
                    if (v4[9])
                    {
                      if (v4[10])
                      {
                        if (v4[11])
                        {
                          if (v4[12])
                          {
                            if (v4[13])
                            {
                              if (v4[14]) {
                                char v35 = 0;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  if (ioctl(v3, 0xC06069C3uLL, &v20) < 0)
  {
    int v7 = __error();
    uint64_t v8 = *v7;
    if ((_DWORD)v8 == 6)
    {
      if (strerror_r(6, __strerrbuf, 0x80uLL)) {
        __strerrbuf[0] = 0;
      }
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCA50, 16LL))
      {
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        _NRLogWithArgs( qword_1001DCA50,  16LL,  "%s%.30s:%-4d Failed to ioctl SIOCGIFNEXUS for %@: [%d] %s",  "",  "NRCopyNetIfUUID",  785LL,  v1,  6LL,  __strerrbuf);
      }
    }

    else
    {
      if (strerror_r(*v7, __strerrbuf, 0x80uLL)) {
        __strerrbuf[0] = 0;
      }
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
      {
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        _NRLogWithArgs(qword_1001DCA50, 17LL, "Failed to ioctl SIOCGIFNEXUS for %@: [%d] %s", v1, v8, __strerrbuf);
      }
    }

    close(v3);
    goto LABEL_54;
  }

  close(v3);
  if (uuid_is_null(v36))
  {
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 16LL))
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      _NRLogWithArgs(qword_1001DCA50, 16LL, "%s%.30s:%-4d Nexus UUID is NULL for %@", "", "NRCopyNetIfUUID", 793LL, v1);
    }

void sub_1001030C4(id a1)
{
}

void sub_1001030D0( void *a1, void *a2, void *a3, int a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v13 = a1;
  id v14 = a2;
  id v15 = a3;
  id v16 = 0LL;
  if (a5 && a4)
  {
    id v29 = &a9;
    id v17 = a5;
    id v16 = -[NSString initWithFormat:arguments:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:arguments:",  v17,  &a9);
  }

  objc_opt_self(&OBJC_CLASS___NRDKeyManager);
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  id v18 = (id)qword_1001DCC10;
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472LL;
  void v23[2] = sub_100103244;
  v23[3] = &unk_1001AFBE8;
  id v24 = v13;
  id v25 = v14;
  char v28 = a4;
  id v26 = v15;
  id v27 = v16;
  id v19 = v16;
  id v20 = v15;
  id v21 = v14;
  id v22 = v13;
  sub_100144478((uint64_t)v18, v23);
}

void sub_100103244(uint64_t a1)
{
  dispatch_semaphore_t v2 = dispatch_semaphore_create(0LL);
  if (objc_opt_class(&OBJC_CLASS___SDRDiagnosticReporter))
  {
    id v3 = objc_alloc_init(&OBJC_CLASS___SDRDiagnosticReporter);
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = *(void *)(a1 + 48);
    int v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSProcessInfo processInfo](&OBJC_CLASS___NSProcessInfo, "processInfo"));
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 processName]);
    int v9 = (void *)objc_claimAutoreleasedReturnValue( [v3 signatureWithDomain:@"NetworkRelay" type:v4 subType:v5 subtypeContext:v6 detectedProcess:v8 triggerThresholdValues:0]);

    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 1LL))
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      _NRLogWithArgs( qword_1001DCA50,  1LL,  "%s%.30s:%-4d Trigger ABC report signature %@",  "",  "NRTriggerABC_block_invoke",  854LL,  v9);
    }

    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472LL;
    void v24[2] = sub_100103608;
    v24[3] = &unk_1001AFBC0;
    id v25 = v9;
    id v26 = v2;
    id v10 = v9;
    [v3 snapshotWithSignature:v10 duration:0 event:0 payload:v24 reply:0.0];
  }

  else
  {
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 16LL))
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      _NRLogWithArgs( qword_1001DCA50,  16LL,  "%s%.30s:%-4d SystemDiagnosticReporter not available",  "",  "NRTriggerABC_block_invoke",  871);
    }
  }

  if (*(_BYTE *)(a1 + 64))
  {
    if (_NRIsAppleInternal())
    {
      dispatch_time_t v11 = dispatch_time(0LL, 100000000LL);
      dispatch_semaphore_wait(v2, v11);
    }

    id v12 = sub_100100C84();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 16LL);

    if (IsLevelEnabled)
    {
      id v14 = sub_100100C84();
      id v15 = v14;
      id v16 = *(const __CFString **)(a1 + 56);
      if (!v16) {
        id v16 = &stru_1001B1528;
      }
      _NRLogWithArgs(v14, 16LL, "%s%.30s:%-4d ABORTING: %@", "", "NRTriggerABC_block_invoke", 882LL, v16);
    }

    uint64_t v17 = _os_log_pack_size(22LL);
    id v18 = (char *)&v24[-1] - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v19 = __error();
    uint64_t v20 = _os_log_pack_fill(v18, v17, *v19, &_mh_execute_header, "%{public}s %@");
    id v21 = *(const __CFString **)(a1 + 56);
    if (!v21) {
      id v21 = &stru_1001B1528;
    }
    *(_DWORD *)uint64_t v20 = 136446466;
    *(void *)(v20 + 4) = "NRTriggerABC_block_invoke";
    *(_WORD *)(v20 + 12) = 2112;
    *(void *)(v20 + 14) = v21;
    id v22 = sub_100100C84();
    _NRLogAbortWithPack(v22, v18);
  }
}

void sub_100103608(uint64_t a1, void *a2)
{
  id v9 = a2;
  id v3 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:kSymptomDiagnosticReplySuccess]);
  unsigned int v4 = [v3 BOOLValue];

  if (v4)
  {
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 1LL))
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      _NRLogWithArgs( qword_1001DCA50,  1LL,  "%s%.30s:%-4d ABC report sent for signature %@",  "",  "NRTriggerABC_block_invoke_2",  861LL,  *(void *)(a1 + 32));
    }
  }

  else
  {
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:kSymptomDiagnosticReplyReasonString]);
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:kSymptomDiagnosticReplyReason]);
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 16LL))
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      uint64_t v7 = *(void *)(a1 + 32);
      id v8 = (id)qword_1001DCA50;
      _NRLogWithArgs( v8,  16,  "%s%.30s:%-4d Failed to send ABC report for signature %@ with reason %@ (%d)",  "",  "NRTriggerABC_block_invoke_2",  866,  v7,  v5,  [v6 intValue]);
    }
  }

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
}

BOOL sub_100103800()
{
  int v3 = 0;
  int v0 = sysctlbyname("net.link.generic.system.companion_sndbuf_limit", 0LL, 0LL, &v3, 4uLL);
  if (v0 < 0)
  {
    int v1 = *__error();
    if (strerror_r(v1, __strerrbuf, 0x80uLL)) {
      __strerrbuf[0] = 0;
    }
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 16LL))
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      _NRLogWithArgs( qword_1001DCA50,  16LL,  "%s%.30s:%-4d sysctl net.link.generic.system.companion_sndbuf_limit -> 0 failed: [%d] %s",  "",  "NRRecoverCompanionLinkFlows",  912,  v1,  __strerrbuf);
    }
  }

  return v0 >= 0;
}

NSString *sub_10010393C(uint64_t a1, char a2)
{
  unsigned int v4 = -[NSString initWithFormat:](objc_alloc(&OBJC_CLASS___NSString), "initWithFormat:", @"unknown:%d", a1);
  bzero(buffer, 0x400uLL);
  if ((int)a1 >= 1 && proc_pidpath(a1, buffer, 0x400u) >= 1 && buffer[0])
  {
    uint64_t v5 = -[NSString initWithFormat:](objc_alloc(&OBJC_CLASS___NSString), "initWithFormat:", @"%s:%d", buffer, a1);

    unsigned int v4 = v5;
  }

  if ((a2 & 1) == 0)
  {
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(-[NSString componentsSeparatedByString:](v4, "componentsSeparatedByString:", @"/"));
    uint64_t v7 = objc_claimAutoreleasedReturnValue([v6 lastObject]);

    return (NSString *)v7;
  }

  return v4;
}

void sub_100103A54(void *a1)
{
  id v1 = a1;
  if (v1)
  {
    int v2 = socket(30, 2, 0);
    if ((v2 & 0x80000000) == 0)
    {
      LODWORD(v3) = v2;
      __int128 v20 = 0u;
      __int128 v21 = 0u;
      unsigned int v4 = [v1 UTF8String];
      if (v4)
      {
        LOBYTE(v20) = *v4;
        if ((_BYTE)v20)
        {
          BYTE1(v20) = v4[1];
          if (BYTE1(v20))
          {
            BYTE2(v20) = v4[2];
            if (BYTE2(v20))
            {
              BYTE3(v20) = v4[3];
              if (BYTE3(v20))
              {
                BYTE4(v20) = v4[4];
                if (BYTE4(v20))
                {
                  BYTE5(v20) = v4[5];
                  if (BYTE5(v20))
                  {
                    BYTE6(v20) = v4[6];
                    if (BYTE6(v20))
                    {
                      BYTE7(v20) = v4[7];
                      if (BYTE7(v20))
                      {
                        BYTE8(v20) = v4[8];
                        if (BYTE8(v20))
                        {
                          BYTE9(v20) = v4[9];
                          if (BYTE9(v20))
                          {
                            BYTE10(v20) = v4[10];
                            if (BYTE10(v20))
                            {
                              BYTE11(v20) = v4[11];
                              if (BYTE11(v20))
                              {
                                BYTE12(v20) = v4[12];
                                if (BYTE12(v20))
                                {
                                  BYTE13(v20) = v4[13];
                                  if (BYTE13(v20))
                                  {
                                    BYTE14(v20) = v4[14];
                                    if (BYTE14(v20)) {
                                      HIBYTE(v20) = 0;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }

        LOBYTE(v21) = 4;
        BYTE3(v21) = 0;
        if (ioctl((int)v3, 0xC02069A9uLL, &v20) < 0)
        {
          uint64_t v7 = __error();
          int v8 = *v7;
          if (*v7 != 6)
          {
            if (strerror_r(*v7, __strerrbuf, 0x80uLL)) {
              __strerrbuf[0] = 0;
            }
            if (qword_1001DCA58 != -1) {
              dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
            }
            if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
            {
              if (qword_1001DCA58 != -1) {
                dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
              }
              id v9 = (id)qword_1001DCA50;
              _NRLogWithArgs( v9,  17,  "Failed to set interface availability for interface %s: [%d] %s",  (const char *)[v1 UTF8String],  v8,  __strerrbuf);
            }

            goto LABEL_42;
          }

          if (strerror_r(6, __strerrbuf, 0x80uLL)) {
            __strerrbuf[0] = 0;
          }
          if (qword_1001DCA58 != -1) {
            dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCA50, 16LL))
          {
            if (qword_1001DCA58 != -1) {
              dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
            }
            id v6 = (id)qword_1001DCA50;
            [v1 UTF8String];
            _NRLogWithArgs(v6, 16LL, "%s%.30s:%-4d Failed to set interface availability for interface %s: [%d] %s", "");
            goto LABEL_41;
          }

NSData *sub_100103FB0(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  id v6 = 0LL;
  if (v3 && v4)
  {
    if ([v4 length] && objc_msgSend(v3, "length"))
    {
      CCHmac( 4u,  objc_msgSend(v5, "bytes", 0, 0, 0, 0, 0, 0, 0, 0),  (size_t)objc_msgSend(v5, "length"),  objc_msgSend(v3, "bytes"),  (size_t)objc_msgSend(v3, "length"),  &v8);
      id v6 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v8, 64LL);
    }

    else
    {
      id v6 = 0LL;
    }
  }

  return v6;
}

NSMutableData *sub_1001040C8(void *a1, unsigned int a2, int a3)
{
  id v5 = a1;
  id v6 = v5;
  if (v5)
  {
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v5 addressData]);
    id v8 = [v7 length];
    uint64_t v30 = 0LL;
    __int128 v31 = 0uLL;
    int v32 = 0;
    [v7 getBytes:&v30 length:28];
    if ((unint64_t)v8 < 0x10 || (unint64_t)v8 < v30)
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      uint64_t v13 = qword_1001DCA50;
      id v24 = v7;
      id v25 = v6;
      uint64_t v23 = 1017LL;
      __int128 v21 = "";
      id v22 = "NRCreateAddressData";
      id v14 = "%s%.30s:%-4d addressData too short %@ for %@";
      goto LABEL_16;
    }

    __int16 v9 = __rev16(a2);
    id v10 = (const char *)BYTE1(v30);
    if (BYTE1(v30) == 2)
    {
      if (v30 > 0xFu)
      {
        *(_WORD *)id v29 = v9;
        *(_DWORD *)&void v29[2] = HIDWORD(v30);
        if (!a3)
        {
          __int128 v27 = 0uLL;
          __int16 v28 = 0;
          char v26 = 2;
          id v16 = -[NSMutableData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSMutableData),  "initWithBytes:length:",  &v26,  1LL);
          LODWORD(v27) = *(_DWORD *)v29;
          WORD2(v27) = *(_WORD *)&v29[4];
          -[NSMutableData appendBytes:length:](v16, "appendBytes:length:", &v27, 6LL);
          goto LABEL_32;
        }

        int v11 = objc_alloc(&OBJC_CLASS___NSData);
        uint64_t v12 = 6LL;
LABEL_42:
        id v16 = -[NSData initWithBytes:length:](v11, "initWithBytes:length:", v29, v12);
        goto LABEL_32;
      }

      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCA50, 16LL))
      {
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        uint64_t v13 = qword_1001DCA50;
        id v24 = v7;
        id v25 = v6;
        uint64_t v23 = 1043LL;
        __int128 v21 = "";
        id v22 = "NRCreateAddressData";
        id v14 = "%s%.30s:%-4d addressData4 too short %@ for %@";
        goto LABEL_16;
      }
    }

    else
    {
      if (BYTE1(v30) != 30)
      {
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        uint64_t v13 = qword_1001DCA50;
        __int128 v21 = v10;
        id v14 = "addressData has unknown address family %u";
        uint64_t v15 = 17LL;
        goto LABEL_30;
      }

      if ((unint64_t)v8 >= 0x1C && v30 > 0x1Bu)
      {
        *(_WORD *)id v29 = v9;
        *(_OWORD *)&void v29[2] = v31;
        if (!a3)
        {
          __int128 v27 = 0uLL;
          __int16 v28 = 0;
          char v26 = 30;
          id v16 = -[NSMutableData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSMutableData),  "initWithBytes:length:",  &v26,  1LL);
          __int128 v27 = *(_OWORD *)v29;
          __int16 v28 = *(_WORD *)&v29[16];
          -[NSMutableData appendBytes:length:](v16, "appendBytes:length:", &v27, 18LL);
          goto LABEL_32;
        }

        int v11 = objc_alloc(&OBJC_CLASS___NSData);
        uint64_t v12 = 18LL;
        goto LABEL_42;
      }

      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCA50, 16LL))
      {
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        uint64_t v13 = qword_1001DCA50;
        id v24 = v7;
        id v25 = v6;
        uint64_t v23 = 1024LL;
        __int128 v21 = "";
        id v22 = "NRCreateAddressData";
        id v14 = "%s%.30s:%-4d addressData6 too short %@ for %@";
LABEL_16:
        uint64_t v15 = 16LL;
LABEL_30:
        _NRLogWithArgs(v13, v15, v14, v21, v22, v23, v24, v25);
      }
    }

id sub_100104514(void *a1, int a2, int a3, int a4)
{
  id v7 = a1;
  id v8 = v7;
  if (v7)
  {
    id v9 = v7;
    id v10 = v9;
    if (a2)
    {
      memset(v20, 0, 19);
      if (![v9 length])
      {
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        uint64_t v11 = qword_1001DCA50;
        uint64_t v12 = 1076LL;
LABEL_17:
        _NRLogWithArgs( v11,  16LL,  "%s%.30s:%-4d Got data too short for address family %@",  "",  "NRCreateEndpointFromDataInner",  v12,  v10);
LABEL_36:
        id v14 = 0LL;
        goto LABEL_42;
      }

      [v10 getBytes:v20 length:1];
      a3 = v20[0];
      if ((unint64_t)[v10 length] <= 1)
      {
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        uint64_t v11 = qword_1001DCA50;
        uint64_t v12 = 1083LL;
        goto LABEL_17;
      }

      uint64_t v13 = objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "subdataWithRange:", 1, (char *)objc_msgSend( v10,  "length") - 1));

      id v10 = (void *)v13;
    }

    if (a3 == 2)
    {
      *(_WORD *)&v19[4] = 0;
      *(_DWORD *)id v19 = 0;
      if ((unint64_t)[v10 length] <= 5)
      {
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        _NRLogWithArgs( qword_1001DCA50,  16LL,  "%s%.30s:%-4d Got data too short for IPv4 %@",  "",  "NRCreateEndpointFromDataInner",  1110LL,  v10);
        goto LABEL_35;
      }

      [v10 getBytes:v19 length:6];
      *(_OWORD *)id v20 = xmmword_100156A10;
      *(_WORD *)&v20[2] = *(_WORD *)v19;
      *(_DWORD *)&void v20[4] = *(_DWORD *)&v19[2];
    }

    else
    {
      if (a3 != 30) {
        goto LABEL_36;
      }
      memset(v19, 0, sizeof(v19));
      if ((unint64_t)[v10 length] <= 0x11)
      {
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        _NRLogWithArgs( qword_1001DCA50,  16LL,  "%s%.30s:%-4d Got data too short for IPv6 %@",  "",  "NRCreateEndpointFromDataInner",  1093LL,  v10);
LABEL_35:
        id v14 = 0LL;
LABEL_42:

        goto LABEL_43;
      }

      [v10 getBytes:v19 length:18];
      *(void *)id v20 = 7708LL;
      int v21 = unk_100156910;
      *(_WORD *)&v20[2] = *(_WORD *)v19;
      *(_OWORD *)&v20[8] = *(_OWORD *)&v19[2];
      if (v19[2] == 254 && (v20[9] & 0xC0) == 0x80) {
        int v21 = a4;
      }
    }

    id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithAddress:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithAddress:",  v20));
    goto LABEL_42;
  }

  id v16 = sub_100100C84();
  int IsLevelEnabled = _NRLogIsLevelEnabled(v16, 17LL);

  if (IsLevelEnabled)
  {
    id v18 = sub_100100C84();
    _NRLogWithArgs(v18, 17LL, "%s called with null addressData", "NRCreateEndpointFromDataInner");
  }

  id v14 = 0LL;
LABEL_43:

  return v14;
}

void sub_10010495C(id a1)
{
  qword_1001DCA00 = symptom_framework_init(107LL, "com.apple.terminusd");
}

NSMutableSet *sub_100104984(void *a1, void **a2, void **a3, int a4)
{
  id v7 = a1;
  if (!v7)
  {
    id v32 = sub_100100C84();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v32, 17LL);

    if (IsLevelEnabled)
    {
      id v34 = sub_100100C84();
      _NRLogWithArgs(v34, 17LL, "%s called with null interfaceName", "NRCopyLocalAddressesInner");
    }

    goto LABEL_15;
  }

  char v35 = 0LL;
  if (getifaddrs(&v35) == -1)
  {
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      _NRLogWithArgs(qword_1001DCA50, 17LL, "getifaddrs failed");
    }

void sub_100104E0C(id a1)
{
}

void sub_100104E1C(id a1)
{
  unsigned int v1 = MGGetSInt32Answer(@"DeviceClassNumber", 0xFFFFFFFFLL) - 1;
  if (v1 <= 0xA && ((0x56Du >> v1) & 1) != 0) {
    byte_1001DCA20 = byte_100156914[v1];
  }
}

void sub_100104E68(id a1)
{
  unsigned int v1 = (dispatch_queue_attr_s *)_NRCopySerialQueueAttr(a1);
  dispatch_queue_attr_t v2 = dispatch_queue_attr_make_with_qos_class(v1, QOS_CLASS_USER_INITIATED, 0);
  id v3 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue(v2);

  if (!v3)
  {
    id v8 = sub_100100C84();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 16LL);

    if (IsLevelEnabled)
    {
      id v10 = sub_100100C84();
      _NRLogWithArgs( v10,  16LL,  "%s%.30s:%-4d ABORTING: dispatch_queue_attr_make_with_qos_class(%u) failed",  "",  "nr_dispatch_queue_create_with_qos",  130,  25);
    }

    id v4 = (const char *)_os_log_pack_size(18LL);
    uint64_t v11 = (char *)&v23 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unsigned int v12 = __error();
    uint64_t v13 = _os_log_pack_fill( v11,  v4,  *v12,  &_mh_execute_header,  "%{public}s dispatch_queue_attr_make_with_qos_class(%u) failed");
    *(_DWORD *)uint64_t v13 = 136446466;
    *(void *)(v13 + 4) = "nr_dispatch_queue_create_with_qos";
    *(_WORD *)(v13 + 12) = 1024;
    *(_DWORD *)(v13 + 14) = 25;
    id v14 = sub_100100C84();
    _NRLogAbortWithPack(v14, v11);
LABEL_7:
    id v15 = sub_100100C84();
    int v16 = _NRLogIsLevelEnabled(v15, 16LL);

    if (v16)
    {
      id v17 = sub_100100C84();
      _NRLogWithArgs( v17,  16LL,  "%s%.30s:%-4d ABORTING: dispatch_queue_create(%s) failed",  "",  "nr_dispatch_queue_create_with_qos",  134,  v4);
    }

    uint64_t v18 = _os_log_pack_size(22LL);
    id v19 = (char *)&v23 - ((__chkstk_darwin(v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v20 = __error();
    uint64_t v21 = _os_log_pack_fill( v19,  v18,  *v20,  &_mh_execute_header,  "%{public}s dispatch_queue_create(%s) failed");
    *(_DWORD *)uint64_t v21 = 136446466;
    *(void *)(v21 + 4) = "nr_dispatch_queue_create_with_qos";
    *(_WORD *)(v21 + 12) = 2080;
    *(void *)(v21 + 14) = v4;
    id v22 = sub_100100C84();
    _NRLogAbortWithPack(v22, v19);
  }

  id v4 = "terminusd.CoreBluetooth";
  dispatch_queue_t v5 = dispatch_queue_create("terminusd.CoreBluetooth", v3);
  if (!v5) {
    goto LABEL_7;
  }
  uint64_t v6 = (uint64_t)v5;

  id v7 = (void *)qword_1001DCA38;
  qword_1001DCA38 = v6;
}

void sub_1001050D4(id a1)
{
  unsigned int v1 = (dispatch_queue_attr_s *)_NRCopySerialQueueAttr(a1);
  dispatch_queue_attr_t v2 = dispatch_queue_attr_make_with_qos_class(v1, QOS_CLASS_USER_INITIATED, 0);
  id v3 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue(v2);

  if (!v3)
  {
    id v8 = sub_100100C84();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 16LL);

    if (IsLevelEnabled)
    {
      id v10 = sub_100100C84();
      _NRLogWithArgs( v10,  16LL,  "%s%.30s:%-4d ABORTING: dispatch_queue_attr_make_with_qos_class(%u) failed",  "",  "nr_dispatch_queue_create_with_qos",  130,  25);
    }

    id v4 = (const char *)_os_log_pack_size(18LL);
    uint64_t v11 = (char *)&v23 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unsigned int v12 = __error();
    uint64_t v13 = _os_log_pack_fill( v11,  v4,  *v12,  &_mh_execute_header,  "%{public}s dispatch_queue_attr_make_with_qos_class(%u) failed");
    *(_DWORD *)uint64_t v13 = 136446466;
    *(void *)(v13 + 4) = "nr_dispatch_queue_create_with_qos";
    *(_WORD *)(v13 + 12) = 1024;
    *(_DWORD *)(v13 + 14) = 25;
    id v14 = sub_100100C84();
    _NRLogAbortWithPack(v14, v11);
LABEL_7:
    id v15 = sub_100100C84();
    int v16 = _NRLogIsLevelEnabled(v15, 16LL);

    if (v16)
    {
      id v17 = sub_100100C84();
      _NRLogWithArgs( v17,  16LL,  "%s%.30s:%-4d ABORTING: dispatch_queue_create(%s) failed",  "",  "nr_dispatch_queue_create_with_qos",  134,  v4);
    }

    uint64_t v18 = _os_log_pack_size(22LL);
    id v19 = (char *)&v23 - ((__chkstk_darwin(v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v20 = __error();
    uint64_t v21 = _os_log_pack_fill( v19,  v18,  *v20,  &_mh_execute_header,  "%{public}s dispatch_queue_create(%s) failed");
    *(_DWORD *)uint64_t v21 = 136446466;
    *(void *)(v21 + 4) = "nr_dispatch_queue_create_with_qos";
    *(_WORD *)(v21 + 12) = 2080;
    *(void *)(v21 + 14) = v4;
    id v22 = sub_100100C84();
    _NRLogAbortWithPack(v22, v19);
  }

  id v4 = "terminusd.IdentityServices.QR";
  dispatch_queue_t v5 = dispatch_queue_create("terminusd.IdentityServices.QR", v3);
  if (!v5) {
    goto LABEL_7;
  }
  uint64_t v6 = (uint64_t)v5;

  id v7 = (void *)qword_1001DCA48;
  qword_1001DCA48 = v6;
}

void sub_100105340(void *a1)
{
  id v1 = a1;
  if (v1)
  {
    id v16 = v1;
    dispatch_queue_attr_t v2 = (void *)objc_claimAutoreleasedReturnValue([v1 allowedLinkTypes]);
    unsigned __int8 v3 = [v2 containsObject:&off_1001BC7D8];

    if ((v3 & 1) != 0)
    {
      id v4 = (void *)objc_claimAutoreleasedReturnValue([v16 allowedLinkSubtypes]);
      id v5 = [v4 count];

      if (!v5) {
        [v16 setAllowedLinkSubtypes:&off_1001BCA88];
      }
    }

    else
    {
      [v16 setIsReachableOverWiFi:0];
    }

    uint64_t v6 = objc_alloc(&OBJC_CLASS___NSOrderedSet);
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v16 allowedLinkTypes]);
    id v8 = -[NSOrderedSet initWithArray:](v6, "initWithArray:", v7);

    id v9 = (void *)objc_claimAutoreleasedReturnValue(-[NSOrderedSet array](v8, "array"));
    [v16 setAllowedLinkTypes:v9];

    id v10 = (void *)objc_claimAutoreleasedReturnValue([v16 allowedLinkSubtypes]);
    id v11 = [v10 count];

    if (v11)
    {
      unsigned int v12 = objc_alloc(&OBJC_CLASS___NSOrderedSet);
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v16 allowedLinkSubtypes]);
      id v14 = -[NSOrderedSet initWithArray:](v12, "initWithArray:", v13);

      id v15 = (void *)objc_claimAutoreleasedReturnValue(-[NSOrderedSet array](v14, "array"));
      [v16 setAllowedLinkSubtypes:v15];
    }

    if ([v16 proxyCapability] != (id)2) {
      [v16 setAllowsDirectToCloud:0];
    }
    if (qword_1001DC9B8 != -1) {
      dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
    }
    if (byte_1001DC9B0) {
      [v16 setAllowsDeviceDiscovery:1];
    }
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 0LL))
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      _NRLogWithArgs( qword_1001DCA50,  0LL,  "%s%.30s:%-4d Resolved properties: %@",  "",  "NRResolveOperationalProperties",  1349LL,  v16);
    }

    id v1 = v16;
  }
}

id sub_1001055B0(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  id v8 = v7;
  id v9 = 0LL;
  if (v5 && v6 && v7)
  {
    if ([v5 length] && objc_msgSend(v6, "length") && objc_msgSend(v8, "length"))
    {
      uint64_t v16 = 0LL;
      int v10 = CCKDFParametersCreateHkdf( &v16,  [v6 bytes],  objc_msgSend(v6, "length"),  objc_msgSend(v8, "bytes"),  objc_msgSend(v8, "length"));
      if (v10)
      {
        int v11 = v10;
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
        {
          if (qword_1001DCA58 != -1) {
            dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
          }
          _NRLogWithArgs(qword_1001DCA50, 17LL, "CCKDFParametersCreateHkdf failed: extract error: %d", v11);
        }
      }

      else
      {
        memset(v17, 0, sizeof(v17));
        int v13 = CCDeriveKey(v16, 12, [v5 bytes], objc_msgSend(v5, "length"), v17, 64);
        if (!v13)
        {
          id v9 = +[NSData _newZeroingDataWithBytes:length:]( &OBJC_CLASS___NSData,  "_newZeroingDataWithBytes:length:",  v17,  64LL);
          cc_clear(64LL, v17);
          if (!v16) {
            goto LABEL_15;
          }
          goto LABEL_22;
        }

        int v14 = v13;
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
        {
          id v15 = sub_100100C84();
          _NRLogWithArgs(v15, 17LL, "CCDeriveKey failed: error: %d", v14);
        }
      }

      id v9 = 0LL;
      if (v16) {
LABEL_22:
      }
        CCKDFParametersDestroy();
    }

    else
    {
      id v9 = 0LL;
    }
  }

BOOL sub_100105828(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  BOOL v6 = 0LL;
  if (v3 && v4)
  {
    uint64_t v7 = objc_opt_class(&OBJC_CLASS___NSData);
    BOOL v6 = (objc_opt_isKindOfClass(v3, v7) & 1) != 0
      && (uint64_t v8 = objc_opt_class(&OBJC_CLASS___NSData), (objc_opt_isKindOfClass(v5, v8) & 1) != 0)
      && (id v9 = [v3 length], v9 == objc_msgSend(v5, "length"))
      && [v3 length]
      && cc_cmp_safe([v3 length], objc_msgSend(v3, "bytes"), objc_msgSend(v5, "bytes")) == 0;
  }

  return v6;
}

int64_t sub_100105910(id a1, id a2, id a3)
{
  id v4 = a3;
  unsigned int v5 = [a2 notifyStatus];
  unsigned int v6 = [v4 notifyStatus];

  if (v5 < v6) {
    return -1LL;
  }
  else {
    return v5 > v6;
  }
}

uint64_t sub_100107E48(void *a1)
{
  id v1 = a1;
  dispatch_queue_attr_t v2 = v1;
  if (v1)
  {
    id v3 = v1[16];

    if (v3)
    {
      id v4 = v2[16];
      id v5 = [v4 proxyCapability];

      if (v5 == (id)1)
      {
LABEL_4:
        uint64_t v6 = 1LL;
        goto LABEL_10;
      }

      id v7 = v2[16];
      id v8 = [v7 proxyCapability];

      if (v8 == (id)2) {
        goto LABEL_6;
      }
      id v9 = v2[16];
      id v10 = [v9 bluetoothRole];

      if (v10 == (id)1) {
        goto LABEL_4;
      }
      id v11 = v2[16];
      id v12 = [v11 bluetoothRole];

      if (v12 == (id)2)
      {
LABEL_6:
        uint64_t v6 = 2LL;
        goto LABEL_10;
      }
    }

    uint64_t v6 = 3LL;
    goto LABEL_10;
  }

  id v14 = sub_100107F78();
  int IsLevelEnabled = _NRLogIsLevelEnabled(v14, 17LL);

  if (IsLevelEnabled)
  {
    id v16 = sub_100107F78();
    _NRLogWithArgs(v16, 17LL, "%s called with null localDevice", "NRLinkGetIKEv2Role");
  }

  uint64_t v6 = 0LL;
LABEL_10:

  return v6;
}

id sub_100107F78()
{
  if (qword_1001DCAC8 != -1) {
    dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
  }
  return (id)qword_1001DCAC0;
}

void sub_100107FB8(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  dispatch_queue_attr_t v2 = (void *)qword_1001DCAC0;
  qword_1001DCAC0 = (uint64_t)v1;
}

id sub_100107FE8(void *a1)
{
  os_log_t v1 = a1;
  dispatch_queue_attr_t v2 = v1;
  if (v1)
  {
    id v3 = v1[16];

    if (!v3 || (id v4 = v2[16], v5 = [v4 proxyCapability], v4, v5 != (id)2))
    {
      id IsLevelEnabled = 0LL;
      goto LABEL_7;
    }

    id v6 = v2[16];
    id IsLevelEnabled = [v6 hasCompanionDatapath];
  }

  else
  {
    id v9 = sub_100107F78();
    id IsLevelEnabled = (id)_NRLogIsLevelEnabled(v9, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_7;
    }
    id v6 = sub_100107F78();
    _NRLogWithArgs(v6, 17LL, "%s called with null localDevice", "NRLinkShouldConfigureCompanionProxyAgent");
    id IsLevelEnabled = 0LL;
  }

LABEL_7:
  return IsLevelEnabled;
}

NSString *sub_1001080C0(unsigned int a1)
{
  switch(a1)
  {
    case 0u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_attr_t v2 = "Invalid";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 1u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_attr_t v2 = "Initial";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 2u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_attr_t v2 = "SentPrelude";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 3u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_attr_t v2 = "ReceivedPrelude";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 4u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_attr_t v2 = "ExchangedPrelude";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 5u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_attr_t v2 = "StartedIKE";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 6u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_attr_t v2 = "ConnectedIKE";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 7u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_attr_t v2 = "ReceivedFirstIKENotify";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 8u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_attr_t v2 = "Ready";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 9u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_attr_t v2 = "Suspended";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    default:
      if (a1 != 255) {
        return -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown(%lld)",  a1);
      }
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_attr_t v2 = "Cancelled";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
  }

void sub_1001089FC(_Unwind_Exception *a1)
{
}

uint64_t sub_10010961C(void *a1, void *a2, void *a3, id *a4, id *a5, id *a6, void *a7)
{
  id v12 = a1;
  id v13 = a2;
  id v165 = a3;
  id v166 = a7;
  int32x4_t v168 = 0uLL;
  unsigned __int16 v169 = 0;
  if ((unint64_t)[v13 length] > 0x11)
  {
    id location = a6;
    [v13 getBytes:&v168 length:18];
    if (sub_10012B114((uint64_t)v12))
    {
      id v15 = v12;
      id v16 = v13;
      id v159 = v166;
      int32x4_t v174 = 0uLL;
      if (v15) {
        id v17 = v15[4];
      }
      else {
        id v17 = 0LL;
      }
      id v18 = v17;
      id v19 = v16;
      int32x4_t v175 = 0uLL;
      unsigned __int16 v176 = 0;
      id v163 = v19;
      if ((unint64_t)[v19 length] <= 0x11)
      {
        __int128 v33 = (void *)_NRCopyLogObjectForNRUUID(v18, v20);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v33, 17LL);

        if (IsLevelEnabled)
        {
          id v36 = (void *)_NRCopyLogObjectForNRUUID(v18, v35);
          _NRLogWithArgs(v36, 17LL, "Insufficient bytes from proxy payload");
        }

        if (v15) {
          id v37 = v15[4];
        }
        else {
          id v37 = 0LL;
        }
        id v38 = v37;
        uint64_t v40 = (void *)_NRCopyLogObjectForNRUUID(v38, v39);
        int v41 = _NRLogIsLevelEnabled(v40, 17LL);

        if (!v41)
        {
          id v72 = 0LL;
          id v162 = 0LL;
          uint64_t v14 = 0LL;
LABEL_160:

          goto LABEL_161;
        }

        if (v15) {
          id v42 = v15[4];
        }
        else {
          id v42 = 0LL;
        }
        id v158 = v42;
        host_with_numeric_port = (void *)_NRCopyLogObjectForNRUUID(v158, v43);
        _NRLogWithArgs(host_with_numeric_port, 17LL, "%@ Failed to parse privateNotifyProxyPayload", v159);
        id v157 = 0LL;
        goto LABEL_36;
      }

      [v163 getBytes:&v175 length:18];
      uint64_t v177 = 0LL;
      id v178 = &v177;
      uint64_t v179 = 0x3032000000LL;
      id v180 = sub_10010AE50;
      id v181 = sub_10010AE60;
      id v182 = 0LL;
      *(void *)&__int128 v170 = 0LL;
      *((void *)&v170 + 1) = &v170;
      *(void *)&__int128 v171 = 0x3032000000LL;
      *((void *)&v171 + 1) = sub_10010AE50;
      *(void *)&__int128 v172 = sub_10010AE60;
      *((void *)&v172 + 1) = 0LL;
      if ((unint64_t)[v163 length] >= 0x15)
      {
        uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v163, "subdataWithRange:", 18, objc_msgSend(v163, "length") - 18));
        v183.i64[0] = (uint64_t)_NSConcreteStackBlock;
        v183.i64[1] = 3221225472LL;
        id v184 = sub_10010AE68;
        id v185 = &unk_1001AFE20;
        id v186 = &v170;
        __int128 v187 = &v177;
        NRTLVParse(v21, &v183);
      }

      id v162 = *(id *)(*((void *)&v170 + 1) + 40LL);
      _Block_object_dispose(&v170, 8);

      int32x4_t v174 = v175;
      unsigned int v22 = v176;
      uint64_t v23 = (void *)v178[5];
      if (v23) {
        id v24 = v23;
      }
      id v157 = v23;
      _Block_object_dispose(&v177, 8);

      uint64_t v26 = __rev16(v22);
      if (v22)
      {
        __int128 v27 = v23;
      }

      else
      {
        __int128 v27 = v23;
        if (v23)
        {
LABEL_19:
          if (v162)
          {
            if ((vmaxv_u16((uint16x4_t)vmovn_s32(vtstq_s32(v174, v174))) & 1) != 0)
            {
              id v158 = (id)createIPv6AddrString(&v174, v25);
              id v28 = [v158 UTF8String];
            }

            else if (v27)
            {
              id v158 = (id)objc_claimAutoreleasedReturnValue([v27 hostname]);
              char v73 = (void *)objc_claimAutoreleasedReturnValue([v23 port]);
              LOWORD(v26) = (unsigned __int16)[v73 intValue];

              id v28 = [v158 UTF8String];
            }

            else
            {
              id v158 = 0LL;
              id v28 = [0 UTF8String];
            }

            host_with_numeric_port = (void *)nw_endpoint_create_host_with_numeric_port(v28, (unsigned __int16)v26);
            if (!host_with_numeric_port)
            {
              if (v15) {
                id v116 = v15[4];
              }
              else {
                id v116 = 0LL;
              }
              id v117 = v116;
              id v119 = (void *)_NRCopyLogObjectForNRUUID(v117, v118);
              int v120 = _NRLogIsLevelEnabled(v119, 17LL);

              if (!v120)
              {
                uint64_t v14 = 0LL;

                goto LABEL_158;
              }

              if (v15) {
                id v121 = v15[4];
              }
              else {
                id v121 = 0LL;
              }
              id v155 = v121;
              masque = (void *)_NRCopyLogObjectForNRUUID(v155, v122);
              _NRLogWithArgs(masque, 17LL, "%@ Could not create proxy endpoint", v159);
              uint64_t v14 = 0LL;
              goto LABEL_156;
            }

            id v155 = (id)nw_array_create();
            masque = (void *)nw_proxy_hop_create_masque(host_with_numeric_port);
            nw_proxy_hop_set_supports_raw_ip(masque, 0LL);
            nw_proxy_hop_set_supports_l4s(masque, 0LL);
            nw_proxy_hop_set_server_raw_public_key(masque, [v162 bytes], objc_msgSend(v162, "length"));
            objc_opt_self(&OBJC_CLASS___NRLinkDirector);
            if (qword_1001DC878 != -1) {
              dispatch_once(&qword_1001DC878, &stru_1001AEED0);
            }
            id v78 = (id)qword_1001DC870;
            int v79 = v78;
            if (v78) {
              id v80 = (void *)*((void *)v78 + 15);
            }
            else {
              id v80 = 0LL;
            }
            id v81 = v80;
            nw_proxy_hop_set_client_identity_reference(masque, v81);

            nw_proxy_hop_set_client_identity_is_raw_public_key(masque, 1LL);
            nw_proxy_hop_add_extra_header(masque, "Priority", "");
            nw_proxy_hop_add_extra_header(masque, "Require-Interface", "");
            nw_proxy_hop_add_extra_header(masque, "Prohibit-Interface", "");
            if (v15) {
              id v82 = v15[16];
            }
            else {
              id v82 = 0LL;
            }
            id v83 = v82;
            id v84 = (void *)objc_claimAutoreleasedReturnValue([v83 proxyProviderCriteria]);
            unsigned __int8 v85 = [v84 excludeClientApplication];

            if ((v85 & 1) == 0) {
              nw_proxy_hop_add_extra_header(masque, "Client-Application", "");
            }
            if (v15) {
              id v86 = v15[16];
            }
            else {
              id v86 = 0LL;
            }
            id v87 = v86;
            int v88 = (void *)objc_claimAutoreleasedReturnValue([v87 proxyProviderCriteria]);
            unsigned int v89 = [v88 allowsListenerClients];

            if (v89) {
              nw_proxy_hop_set_supports_udp_listen(masque, 1LL);
            }
            if (v15) {
              id v90 = v15[16];
            }
            else {
              id v90 = 0LL;
            }
            id v91 = v90;
            uint64_t v92 = (void *)objc_claimAutoreleasedReturnValue([v91 proxyProviderCriteria]);
            unsigned int v93 = [v92 allowsDemuxForwarding];

            if (v93) {
              nw_proxy_hop_set_enable_demux(masque, 1LL);
            }
            nw_proxy_hop_add_extra_header(masque, "Multipath", "");
            if (v15) {
              id v94 = v15[16];
            }
            else {
              id v94 = 0LL;
            }
            id v95 = v94;
            uint64_t v96 = (void *)objc_claimAutoreleasedReturnValue([v95 proxyProviderCriteria]);
            unsigned int v97 = [v96 hasProxyCriteriaAssigningTokens];

            if (v97) {
              nw_proxy_hop_add_token_header_with_agent_type( masque,  "Proxy-Usage-Token",  "",  "",  "com.apple.networkrelay",  "ProxyUsageTokenAgent");
            }
            nw_proxy_hop_set_masque_version(masque, 2LL);
            nw_array_append(v155, masque);
            default_privacy_proxy = (nw_proxy_config *)nw_proxy_config_create_default_privacy_proxy(v155);
            if (default_privacy_proxy)
            {
              id v99 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
              -[NSMutableSet addObjectsFromArray:](v99, "addObjectsFromArray:", &off_1001BCAA0);
              if (v158) {
                -[NSMutableSet addObject:](v99, "addObject:", v158);
              }
              __int128 v172 = 0u;
              __int128 v173 = 0u;
              __int128 v170 = 0u;
              __int128 v171 = 0u;
              id v100 = v99;
              id v101 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v100,  "countByEnumeratingWithState:objects:count:",  &v170,  &v177,  16LL);
              if (v101)
              {
                uint64_t v102 = *(void *)v171;
                do
                {
                  for (uint64_t i = 0LL; i != v101; uint64_t i = (char *)i + 1)
                  {
                    if (*(void *)v171 != v102) {
                      objc_enumerationMutation(v100);
                    }
                    nw_proxy_config_add_excluded_domain( default_privacy_proxy,  (const char *)[*(id *)(*((void *)&v170 + 1) + 8 * (void)i) UTF8String]);
                  }

                  id v101 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v100,  "countByEnumeratingWithState:objects:count:",  &v170,  &v177,  16LL);
                }

                while (v101);
              }

              nw_proxy_config_set_is_privacy_proxy(default_privacy_proxy, 0LL, 0LL);
              nw_proxy_config_set_is_companion_proxy(default_privacy_proxy, 1LL);
              id v154 = objc_alloc_init(&OBJC_CLASS___NSUUID);
              int32x4_t v183 = 0uLL;
              -[NSUUID getUUIDBytes:](v154, "getUUIDBytes:", &v183);
              nw_proxy_config_set_identifier(default_privacy_proxy, &v183);
              uint64_t v14 = nw_proxy_config_publish(default_privacy_proxy);
              if (v15) {
                id v104 = v15[4];
              }
              else {
                id v104 = 0LL;
              }
              id v105 = v104;
              uint64_t v107 = _NRCopyLogObjectForNRUUID(v105, v106);
              id v108 = (void *)v107;
              if ((_DWORD)v14)
              {
                int v109 = _NRLogIsLevelEnabled(v107, 0LL);

                if (v109)
                {
                  if (v15) {
                    id v110 = v15[4];
                  }
                  else {
                    id v110 = 0LL;
                  }
                  id v111 = v110;
                  int v113 = (void *)_NRCopyLogObjectForNRUUID(v111, v112);
                  _NRLogWithArgs( v113,  0LL,  "%s%.30s:%-4d %@ Registered MASQUE proxy agent %@\n",  "",  "NRLinkConfigureMASQUEProxyAgent",  1402LL,  v159,  v154);
                }

                if (location) {
                  objc_storeStrong(location, default_privacy_proxy);
                }
                BOOL v114 = v154;
                id v115 = *a5;
                *a5 = v114;
                goto LABEL_153;
              }

              int v130 = _NRLogIsLevelEnabled(v107, 17LL);

              if (v130)
              {
                if (v15) {
                  id v131 = v15[4];
                }
                else {
                  id v131 = 0LL;
                }
                id v115 = v131;
                id v133 = (void *)_NRCopyLogObjectForNRUUID(v115, v132);
                _NRLogWithArgs(v133, 17LL, "%@ Failed to register proxy agent %@\n", v159, v154);

LABEL_153:
              }
            }

            else
            {
              if (v15) {
                id v123 = v15[4];
              }
              else {
                id v123 = 0LL;
              }
              id v124 = v123;
              id v126 = (void *)_NRCopyLogObjectForNRUUID(v124, v125);
              int v127 = _NRLogIsLevelEnabled(v126, 17LL);

              if (!v127)
              {
                uint64_t v14 = 0LL;
                goto LABEL_155;
              }

              if (v15) {
                id v128 = v15[4];
              }
              else {
                id v128 = 0LL;
              }
              id v100 = (NSMutableSet *)v128;
              id v154 = (NSUUID *)_NRCopyLogObjectForNRUUID(v100, v129);
              _NRLogWithArgs(v154, 17LL, "%@ Could not create MASQUE proxy config", v159);
              uint64_t v14 = 0LL;
            }

LABEL_155:
LABEL_156:

            goto LABEL_157;
          }

          if (v15) {
            id v147 = v15[4];
          }
          else {
            id v147 = 0LL;
          }
          id v148 = v147;
          id v150 = (void *)_NRCopyLogObjectForNRUUID(v148, v149);
          int v151 = _NRLogIsLevelEnabled(v150, 17LL);

          if (!v151)
          {
            id v162 = 0LL;
            uint64_t v14 = 0LL;
            goto LABEL_159;
          }

          if (v15) {
            id v152 = v15[4];
          }
          else {
            id v152 = 0LL;
          }
          id v158 = v152;
          host_with_numeric_port = (void *)_NRCopyLogObjectForNRUUID(v158, v153);
          _NRLogWithArgs( host_with_numeric_port,  17LL,  "%@ proxyServerPublicKey not found in the privateNotifyProxyPayload",  v159);
LABEL_36:
          id v162 = 0LL;
          uint64_t v14 = 0LL;
LABEL_157:

LABEL_158:
LABEL_159:
          id v72 = v157;
          goto LABEL_160;
        }
      }

      if (v15) {
        id v138 = v15[4];
      }
      else {
        id v138 = 0LL;
      }
      id v139 = v138;
      uint64_t v141 = (void *)_NRCopyLogObjectForNRUUID(v139, v140);
      int v142 = _NRLogIsLevelEnabled(v141, 17LL);

      if (!v142)
      {
        id v72 = 0LL;
        uint64_t v14 = 0LL;
        goto LABEL_160;
      }

      if (v15) {
        id v143 = v15[4];
      }
      else {
        id v143 = 0LL;
      }
      id v158 = v143;
      id v161 = (void *)_NRCopyLogObjectForNRUUID(v158, v144);
      id v146 = (void *)createIPv6AddrString(&v174, v145);
      _NRLogWithArgs(v161, 17LL, "%@ Found invalid ipv6 addr %@.%u in privateNotifyProxyPayload", v159, v146, v26);

      id v157 = 0LL;
      uint64_t v14 = 0LL;

      goto LABEL_158;
    }

    *(void *)&__int128 v170 = 0LL;
    *((void *)&v170 + 1) = &v170;
    *(void *)&__int128 v171 = 0x2020000000LL;
    BYTE8(v171) = 0;
    uint64_t v177 = 0LL;
    id v178 = &v177;
    uint64_t v179 = 0x3032000000LL;
    id v180 = sub_10010AE50;
    id v181 = sub_10010AE60;
    id v182 = 0LL;
    if ((unint64_t)[v13 length] >= 0x15)
    {
      uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "subdataWithRange:", 18, objc_msgSend(v13, "length") - 18));
      v167[0] = _NSConcreteStackBlock;
      v167[1] = 3221225472LL;
      v167[2] = sub_10010AFBC;
      v167[3] = &unk_1001AFE20;
      v167[4] = &v170;
      v167[5] = &v177;
      NRTLVParse(v30, v167);
    }

    int32x4_t v183 = v168;
    unsigned int v31 = bswap32(v169) >> 16;
    if ((vmaxv_u16((uint16x4_t)vmovn_s32(vtstq_s32(v183, v183))) & 1) != 0)
    {
      id v32 = (NSString *)createIPv6AddrString(&v183, v29);
      if (!v165) {
        goto LABEL_41;
      }
    }

    else
    {
      int v44 = (void *)v178[5];
      if (v44)
      {
        id v32 = (NSString *)objc_claimAutoreleasedReturnValue([v44 hostname]);
        id v45 = (void *)objc_claimAutoreleasedReturnValue([(id)v178[5] port]);
        LOWORD(v31) = (unsigned __int16)[v45 intValue];

        if (!v165) {
          goto LABEL_41;
        }
      }

      else
      {
        id v32 = 0LL;
        if (!v165) {
          goto LABEL_41;
        }
      }
    }

    if (-[NSString hasPrefix:](v32, "hasPrefix:", @"fe80"))
    {
      id v46 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%@%%%@",  v32,  v165);

      id v32 = v46;
    }

LABEL_77:
    uint64_t v14 = 0LL;
LABEL_92:

    goto LABEL_93;
  }

  if (qword_1001DCAC8 != -1) {
    dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCAC0, 17LL))
  {
    if (qword_1001DCAC8 != -1) {
      dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
    }
    _NRLogWithArgs(qword_1001DCAC0, 17LL, "%@ Insufficient bytes from proxy payload", v166);
    uint64_t v14 = 0LL;
  }

  else
  {
    uint64_t v14 = 0LL;
  }
}

LABEL_161:
  return v14;
}

void sub_10010A9F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, char a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, uint64_t a50,char a51)
{
}

NSMutableArray *sub_10010AA54(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  id v8 = v7;
  if (!v5)
  {
    id v35 = sub_100107F78();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v35, 17LL);

    if (IsLevelEnabled)
    {
      id v37 = sub_100107F78();
      _NRLogWithArgs(v37, 17LL, "%s called with null proxyAgentUUID");
LABEL_18:

      id v28 = 0LL;
      goto LABEL_13;
    }

uint64_t sub_10010AE50(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10010AE60(uint64_t a1)
{
}

uint64_t sub_10010AE68(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3 = __rev16(*(unsigned __int16 *)(a2 + 1));
  int v4 = *a2;
  if (v4 == 3)
  {
    if (*(_WORD *)(a2 + 1))
    {
      id v9 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a2 + 3, v3);
      uint64_t v8 = 1LL;
      id v10 = sub_100104514(v9, 1, 0, 0);
      uint64_t v11 = objc_claimAutoreleasedReturnValue(v10);
      uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8LL);
      id v13 = *(void **)(v12 + 40);
      *(void *)(v12 + 40) = v11;
    }

    else
    {
      if (qword_1001DCAC8 != -1) {
        dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCAC0, 17LL))
      {
        if (qword_1001DCAC8 != -1) {
          dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
        }
        _NRLogWithArgs(qword_1001DCAC0, 17LL, "invalid tlv length for ProxyServerEndpoint");
      }

      return 0LL;
    }
  }

  else if (v4 == 2 && *(_WORD *)(a2 + 1))
  {
    id v5 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a2 + 3, v3);
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
    id v7 = *(void **)(v6 + 40);
    *(void *)(v6 + 40) = v5;

    return 1LL;
  }

  else
  {
    return 1LL;
  }

  return v8;
}

uint64_t sub_10010AFBC(uint64_t a1, unsigned __int8 *a2)
{
  int v4 = *a2;
  if (v4 == 3)
  {
    if (!*(_WORD *)(a2 + 1))
    {
      if (qword_1001DCAC8 != -1) {
        dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCAC0, 17LL))
      {
        if (qword_1001DCAC8 != -1) {
          dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
        }
        _NRLogWithArgs(qword_1001DCAC0, 17LL, "invalid tlv length for ProxyServerEndpoint");
      }

      return 0LL;
    }

    unsigned int v3 = *(unsigned __int16 *)(a2 + 1);
    id v5 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a2 + 3, __rev16(v3));
    uint64_t v6 = 1LL;
    id v7 = sub_100104514(v5, 1, 0, 0);
    uint64_t v8 = objc_claimAutoreleasedReturnValue(v7);
    uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8LL);
    id v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = v8;
  }

  else if (v4 == 1)
  {
    if (*(_WORD *)(a2 + 1))
    {
      if (qword_1001DCAC8 != -1) {
        dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCAC0, 17LL))
      {
        if (qword_1001DCAC8 != -1) {
          dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
        }
        _NRLogWithArgs(qword_1001DCAC0, 17LL, "invalid tlv length for SHOESUDPAssociate");
      }

      return 0LL;
    }

    uint64_t v6 = 1LL;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
  }

  else
  {
    return 1LL;
  }

  return v6;
}

uint64_t sub_10010B160(void *a1)
{
  id v1 = a1;
  uint64_t Nexus = NEVirtualInterfaceCreateNexus(kCFAllocatorDefault, 2LL, v1, 0LL, 1LL, 0LL, 0LL, 0LL, 0LL);
  if (!Nexus)
  {
    if (qword_1001DCAC8 != -1) {
      dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCAC0, 0LL))
    {
      if (qword_1001DCAC8 != -1) {
        dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
      }
      _NRLogWithArgs( qword_1001DCAC0,  0LL,  "%s%.30s:%-4d Retrying NEVirtualInterfaceCreateNexus()",  "",  "NRLinkVirtualInterfaceCreate",  2010);
    }

    uint64_t Nexus = NEVirtualInterfaceCreateNexus(kCFAllocatorDefault, 2LL, v1, 0LL, 1LL, 0LL, 0LL, 0LL, 0LL);
    if (!Nexus)
    {
      if (qword_1001DCAC8 != -1) {
        dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCAC0, 0LL))
      {
        if (qword_1001DCAC8 != -1) {
          dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
        }
        _NRLogWithArgs( qword_1001DCAC0,  0LL,  "%s%.30s:%-4d Retrying NEVirtualInterfaceCreateNexus()",  "",  "NRLinkVirtualInterfaceCreate",  2010);
      }

      uint64_t Nexus = NEVirtualInterfaceCreateNexus(kCFAllocatorDefault, 2LL, v1, 0LL, 1LL, 0LL, 0LL, 0LL, 0LL);
      if (!Nexus)
      {
        if (qword_1001DCAC8 != -1) {
          dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCAC0, 0LL))
        {
          if (qword_1001DCAC8 != -1) {
            dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
          }
          _NRLogWithArgs( qword_1001DCAC0,  0LL,  "%s%.30s:%-4d Retrying NEVirtualInterfaceCreateNexus()",  "",  "NRLinkVirtualInterfaceCreate",  2010);
        }

        uint64_t Nexus = NEVirtualInterfaceCreateNexus(kCFAllocatorDefault, 2LL, v1, 0LL, 1LL, 0LL, 0LL, 0LL, 0LL);
        if (!Nexus)
        {
          if (qword_1001DCAC8 != -1) {
            dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCAC0, 0LL))
          {
            if (qword_1001DCAC8 != -1) {
              dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
            }
            _NRLogWithArgs( qword_1001DCAC0,  0LL,  "%s%.30s:%-4d Retrying NEVirtualInterfaceCreateNexus()",  "",  "NRLinkVirtualInterfaceCreate",  2010);
          }

          uint64_t Nexus = NEVirtualInterfaceCreateNexus(kCFAllocatorDefault, 2LL, v1, 0LL, 1LL, 0LL, 0LL, 0LL, 0LL);
          if (!Nexus)
          {
            if (qword_1001DCAC8 != -1) {
              dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
            }
            if (_NRLogIsLevelEnabled(qword_1001DCAC0, 0LL))
            {
              if (qword_1001DCAC8 != -1) {
                dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
              }
              _NRLogWithArgs( qword_1001DCAC0,  0LL,  "%s%.30s:%-4d Retrying NEVirtualInterfaceCreateNexus()",  "",  "NRLinkVirtualInterfaceCreate",  2010);
            }

            uint64_t Nexus = NEVirtualInterfaceCreateNexus(kCFAllocatorDefault, 2LL, v1, 0LL, 1LL, 0LL, 0LL, 0LL, 0LL);
            if (!Nexus)
            {
              if (qword_1001DCAC8 != -1) {
                dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
              }
              if (_NRLogIsLevelEnabled(qword_1001DCAC0, 0LL))
              {
                if (qword_1001DCAC8 != -1) {
                  dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
                }
                _NRLogWithArgs( qword_1001DCAC0,  0LL,  "%s%.30s:%-4d Retrying NEVirtualInterfaceCreateNexus()",  "",  "NRLinkVirtualInterfaceCreate",  2010);
              }

              uint64_t Nexus = 0LL;
            }
          }
        }
      }
    }
  }

  return Nexus;
}

void sub_10010B608(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v10 = WeakRetained;
    id v3 = sub_100107F78();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 16LL);

    if (IsLevelEnabled)
    {
      id v8 = sub_100107F78();
      uint64_t v9 = "";
      _NRLogWithArgs(v8, 16LL, "%s%.30s:%-4d %@ not deallocated after 10s, likely leak");
    }

    sub_1001030D0(*(void **)(a1 + 32), @"Leak", @"NEIKEv2Session", 0, 0LL, v5, v6, v7, (uint64_t)v9);
    id WeakRetained = v10;
  }
}

void sub_10010B6C8(uint64_t a1)
{
  if (qword_1001DCAC8 != -1) {
    dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCAC0, 1LL))
  {
    if (qword_1001DCAC8 != -1) {
      dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
    }
    _NRLogWithArgs( qword_1001DCAC0,  1LL,  "%s%.30s:%-4d Attempting to get Nexus UUID for %@",  "",  "-[NRLink(NRLinkProtected) invalidateLink]_block_invoke",  925LL,  *(void *)(a1 + 32));
  }

  dispatch_queue_attr_t v2 = sub_100102AF8(*(void **)(a1 + 32));
  id v3 = v2;
  if (v2)
  {
    uint64_t v12 = v2;
    if ((-[NSUUID isEqual:](v2, "isEqual:", *(void *)(a1 + 40)) & 1) != 0)
    {
      id v5 = sub_100107F78();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16LL);

      if (IsLevelEnabled)
      {
        id v10 = sub_100107F78();
        uint64_t v11 = "";
        _NRLogWithArgs(v10, 16LL, "%s%.30s:%-4d UUID did not change for %@ after 10s, likely interface leak (%@)");
      }

      sub_1001030D0(*(void **)(a1 + 48), @"Leak", @"Interface", 0, 0LL, v7, v8, v9, (uint64_t)v11);
      goto LABEL_15;
    }

    if (qword_1001DCAC8 != -1) {
      dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
    }
    int v4 = _NRLogIsLevelEnabled(qword_1001DCAC0, 1LL);
    id v3 = v12;
    if (v4)
    {
      if (qword_1001DCAC8 != -1)
      {
        dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
        id v3 = v12;
      }

      _NRLogWithArgs( qword_1001DCAC0,  1LL,  "%s%.30s:%-4d UUID changed for %@ (old %@, new %@), no interface leak",  "",  "-[NRLink(NRLinkProtected) invalidateLink]_block_invoke",  933LL,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  v3);
LABEL_15:
      id v3 = v12;
    }
  }
}

void sub_10010B8C8(id a1)
{
  id v1 = [[NEIKEv2KeyIDIdentifier alloc] initWithKeyIDString:@"com.apple.networkrelay.companionlink.classD"];
  dispatch_queue_attr_t v2 = (void *)qword_1001DCA60;
  qword_1001DCA60 = (uint64_t)v1;
}

void sub_10010B8FC(id a1)
{
  id v1 = [[NEIKEv2KeyIDIdentifier alloc] initWithKeyIDString:@"com.apple.networkrelay.companionlink.classC"];
  dispatch_queue_attr_t v2 = (void *)qword_1001DCA70;
  qword_1001DCA70 = (uint64_t)v1;
}

id sub_10010B930()
{
  if (qword_1001DCA88 != -1) {
    dispatch_once(&qword_1001DCA88, &stru_1001AFD70);
  }
  return (id)qword_1001DCA80;
}

void sub_10010B970(id a1)
{
  id v1 = [[NEIKEv2KeyIDIdentifier alloc] initWithKeyIDString:@"com.apple.networkrelay.companionlink.classA"];
  dispatch_queue_attr_t v2 = (void *)qword_1001DCA80;
  qword_1001DCA80 = (uint64_t)v1;
}

id sub_10010B9A4()
{
  if (qword_1001DCA98 != -1) {
    dispatch_once(&qword_1001DCA98, &stru_1001AFD90);
  }
  return (id)qword_1001DCA90;
}

void sub_10010B9E4(id a1)
{
  id v1 = [[NEIKEv2KeyIDIdentifier alloc] initWithKeyIDString:@"com.apple.networkrelay.companionlink.pairing.ids"];
  dispatch_queue_attr_t v2 = (void *)qword_1001DCA90;
  qword_1001DCA90 = (uint64_t)v1;
}

id sub_10010BA18()
{
  if (qword_1001DCAA8 != -1) {
    dispatch_once(&qword_1001DCAA8, &stru_1001AFDB0);
  }
  return (id)qword_1001DCAA0;
}

void sub_10010BA58(id a1)
{
  id v1 = [[NEIKEv2KeyIDIdentifier alloc] initWithKeyIDString:@"com.apple.networkrelay.companionlink.pairing.oobk"];
  dispatch_queue_attr_t v2 = (void *)qword_1001DCAA0;
  qword_1001DCAA0 = (uint64_t)v1;
}

void sub_10010BA8C(id a1)
{
  id v1 = [[NEIKEv2KeyIDIdentifier alloc] initWithKeyIDString:@"com.apple.networkrelay.companionlink.pairing.control"];
  dispatch_queue_attr_t v2 = (void *)qword_1001DCAB0;
  qword_1001DCAB0 = (uint64_t)v1;
}

uint64_t sub_10010BAC0(int8x16_t *a1)
{
  int8x16_t v6 = *a1;
  int8x8_t v1 = veor_s8(*(int8x8_t *)v6.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL));
  v6.i32[0] = v1.i32[0] ^ v1.i32[1];
  dispatch_queue_attr_t v2 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v6, 16LL);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(-[NSData base64EncodedStringWithOptions:](v2, "base64EncodedStringWithOptions:", 0LL, v6.i64[0]));
  uint64_t v4 = objc_claimAutoreleasedReturnValue([v3 substringToIndex:6]);

  return v4;
}

id sub_10010BB80(void *a1)
{
  id v1 = a1;
  if ((unint64_t)[v1 length] > 0x11)
  {
    uint64_t v6 = 0LL;
    uint64_t v7 = &v6;
    uint64_t v8 = 0x3032000000LL;
    uint64_t v9 = sub_10010AE50;
    id v10 = sub_10010AE60;
    id v11 = 0LL;
    if ((unint64_t)[v1 length] >= 0x15)
    {
      id v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "subdataWithRange:", 18, objc_msgSend(v1, "length") - 18));
      v5[0] = _NSConcreteStackBlock;
      v5[1] = 3221225472LL;
      v5[2] = sub_10010BD24;
      v5[3] = &unk_1001AFDF8;
      void v5[4] = &v6;
      NRTLVParse(v3, v5);
    }

    id v2 = (id)v7[5];
    _Block_object_dispose(&v6, 8);
  }

  else
  {
    if (qword_1001DCAC8 != -1) {
      dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCAC0, 17LL))
    {
      if (qword_1001DCAC8 != -1) {
        dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
      }
      _NRLogWithArgs(qword_1001DCAC0, 17LL, "%@ Insufficient bytes from proxy payload", v1);
    }

    id v2 = 0LL;
  }

  return v2;
}

void sub_10010BD04( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

uint64_t sub_10010BD24(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)a2 == 4)
  {
    id v3 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  a2 + 3,  bswap32(*(unsigned __int16 *)(a2 + 1)) >> 16);
    id v4 = [[NRDeviceProxyProviderCriteria alloc] initWithReceivedData:v3];
    uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v6 = *(void **)(v5 + 40);
    *(void *)(v5 + 40) = v4;
  }

  return 1LL;
}

void sub_10010BDB0(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (v3)
  {
    if (v4)
    {
      __int128 v17 = 0u;
      __int128 v18 = 0u;
      __int128 v15 = 0u;
      __int128 v16 = 0u;
      id v6 = (id)objc_claimAutoreleasedReturnValue([v4 proposals]);
      id v7 = [v6 countByEnumeratingWithState:&v15 objects:v19 count:16];
      if (v7)
      {
        id v8 = v7;
        uint64_t v9 = *(void *)v16;
        do
        {
          for (uint64_t i = 0LL; i != v8; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v16 != v9) {
              objc_enumerationMutation(v6);
            }
            [*(id *)(*((void *)&v15 + 1) + 8 * (void)i) setLifetimeSeconds:21599];
          }

          id v8 = [v6 countByEnumeratingWithState:&v15 objects:v19 count:16];
        }

        while (v8);
      }

      goto LABEL_14;
    }

    id v13 = sub_100107F78();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v13, 17LL);

    if (IsLevelEnabled)
    {
      id v6 = sub_100107F78();
      _NRLogWithArgs(v6, 17LL, "%s called with null ikeSAConfiguration");
      goto LABEL_14;
    }
  }

  else
  {
    id v11 = sub_100107F78();
    int v12 = _NRLogIsLevelEnabled(v11, 17LL);

    if (v12)
    {
      id v6 = sub_100107F78();
      _NRLogWithArgs(v6, 17LL, "%s called with null localDevice");
LABEL_14:
    }
  }
}

void sub_10010BF54(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (v4)
  {
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    id v6 = (id)objc_claimAutoreleasedReturnValue([v4 proposals]);
    id v7 = [v6 countByEnumeratingWithState:&v13 objects:v17 count:16];
    if (v7)
    {
      id v8 = v7;
      uint64_t v9 = *(void *)v14;
      do
      {
        for (uint64_t i = 0LL; i != v8; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v14 != v9) {
            objc_enumerationMutation(v6);
          }
          [*(id *)(*((void *)&v13 + 1) + 8 * (void)i) setLifetimeSeconds:21221];
        }

        id v8 = [v6 countByEnumeratingWithState:&v13 objects:v17 count:16];
      }

      while (v8);
    }

    goto LABEL_11;
  }

  id v11 = sub_100107F78();
  int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 17LL);

  if (IsLevelEnabled)
  {
    id v6 = sub_100107F78();
    _NRLogWithArgs( v6,  17LL,  "%s called with null childSAConfiguration",  "NRLinkChildSAConfigurationSetInitiatorLifetime");
LABEL_11:
  }
}

id sub_10010C0B8()
{
  id v0 = objc_alloc_init(&OBJC_CLASS___NEIKEv2IKESAConfiguration);
  [v0 setAllowRedirect:0];
  [v0 setDisableSwitchToNATTPorts:1];
  [v0 setNonceSize:32];
  [v0 setStrictNonceSizeChecks:1];
  id v1 = objc_alloc_init(&OBJC_CLASS___NEIKEv2IKESAProposal);
  id v2 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v2);

  _NRIsAppleInternal(v3);
  id v4 = [[NEIKEv2EncryptionProtocol alloc] initWithEncryptionType:5];
  id v18 = v4;
  id v5 = [[NEIKEv2EncryptionProtocol alloc] initWithEncryptionType:6];
  id v19 = v5;
  id v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v18, 2LL));

  [v1 setEncryptionProtocols:v6];
  id v7 = [[NEIKEv2PRFProtocol alloc] initWithType:7];
  id v18 = v7;
  id v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v18, 1LL));

  [v1 setPrfProtocols:v8];
  id v9 = [[NEIKEv2KEMProtocol alloc] initWithMethod:32];
  id v18 = v9;
  id v10 = [[NEIKEv2KEMProtocol alloc] initWithMethod:31];
  id v19 = v10;
  id v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v18, 2LL));

  [v1 setKemProtocols:v11];
  [v1 setLifetimeSeconds:1000000];
  id v18 = v1;
  int v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v18, 1LL));

  [v0 setProposals:v12];
  __int128 v13 = objc_alloc(&OBJC_CLASS___NSSet);
  id v14 = [[NEIKEv2SignatureHashProtocol alloc] initWithHashType:5];
  id v15 = [[NEIKEv2SignatureHashProtocol alloc] initWithHashType:2];
  __int128 v16 = -[NSSet initWithObjects:](v13, "initWithObjects:", v14, v15, 0LL);
  [v0 setExtraSupportedSignatureHashes:v16];

  [v0 setPreferInitiatorProposalOrder:1];
  return v0;
}

NEIKEv2ChildSAConfiguration *sub_10010C340()
{
  id v0 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ChildSAConfiguration);
  -[NEIKEv2ChildSAConfiguration setMode:](v0, "setMode:", 1LL);
  id v1 = +[NEIKEv2TrafficSelector copyAllIPv6](&OBJC_CLASS___NEIKEv2TrafficSelector, "copyAllIPv6");
  v19[0] = v1;
  id v2 = +[NEIKEv2TrafficSelector copyAllIPv4](&OBJC_CLASS___NEIKEv2TrafficSelector, "copyAllIPv4");
  v19[1] = v2;
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v19, 2LL));
  -[NEIKEv2ChildSAConfiguration setLocalTrafficSelectors:](v0, "setLocalTrafficSelectors:", v3);

  id v4 = +[NEIKEv2TrafficSelector copyAllIPv6](&OBJC_CLASS___NEIKEv2TrafficSelector, "copyAllIPv6");
  v18[0] = v4;
  id v5 = +[NEIKEv2TrafficSelector copyAllIPv4](&OBJC_CLASS___NEIKEv2TrafficSelector, "copyAllIPv4");
  v18[1] = v5;
  id v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v18, 2LL));
  -[NEIKEv2ChildSAConfiguration setRemoteTrafficSelectors:](v0, "setRemoteTrafficSelectors:", v6);

  id v7 = objc_alloc_init(&OBJC_CLASS___NEIKEv2ChildSAProposal);
  [v7 setProtocol:3];
  id v8 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v8);

  _NRIsAppleInternal(v9);
  id v10 = [[NEIKEv2EncryptionProtocol alloc] initWithEncryptionType:9];
  id v20 = v10;
  id v11 = [[NEIKEv2EncryptionProtocol alloc] initWithEncryptionType:7];
  id v21 = v11;
  int v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v20, 2LL));

  [v7 setEncryptionProtocols:v12];
  id v13 = [[NEIKEv2KEMProtocol alloc] initWithMethod:32];
  id v20 = v13;
  id v14 = [[NEIKEv2KEMProtocol alloc] initWithMethod:31];
  id v21 = v14;
  id v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v20, 2LL));

  [v7 setKemProtocols:v15];
  [v7 setLifetimeSeconds:1000000];
  id v20 = v7;
  __int128 v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v20, 1LL));

  -[NEIKEv2ChildSAConfiguration setProposals:](v0, "setProposals:", v16);
  -[NEIKEv2ChildSAConfiguration setReplayWindowSize:](v0, "setReplayWindowSize:", 256LL);
  -[NEIKEv2ChildSAConfiguration setPreferInitiatorProposalOrder:](v0, "setPreferInitiatorProposalOrder:", 1LL);
  return v0;
}

NEIKEv2SessionConfiguration *sub_10010C5AC(int a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = objc_alloc_init(&OBJC_CLASS___NEIKEv2SessionConfiguration);
  -[NEIKEv2SessionConfiguration setNegotiateMOBIKE:](v7, "setNegotiateMOBIKE:", 0LL);
  -[NEIKEv2SessionConfiguration setNatTraversalKeepaliveDisabled:](v7, "setNatTraversalKeepaliveDisabled:", 1LL);
  -[NEIKEv2SessionConfiguration setDeadPeerDetectionEnabled:](v7, "setDeadPeerDetectionEnabled:", 0LL);
  -[NEIKEv2SessionConfiguration setIdleTimeoutEnabled:](v7, "setIdleTimeoutEnabled:", 0LL);
  -[NEIKEv2SessionConfiguration setConfigurationReply:](v7, "setConfigurationReply:", 0LL);
  id v8 = [v5 copy];
  -[NEIKEv2SessionConfiguration setLocalIdentifier:](v7, "setLocalIdentifier:", v8);

  if (a1)
  {
    id v9 = [v5 copy];
    -[NEIKEv2SessionConfiguration setRemoteIdentifier:](v7, "setRemoteIdentifier:", v9);
  }

  id v10 = [v6 copy];
  -[NEIKEv2SessionConfiguration setAuthenticationProtocol:](v7, "setAuthenticationProtocol:", v10);

  id v11 = [v6 copy];
  -[NEIKEv2SessionConfiguration setRemoteAuthentication:](v7, "setRemoteAuthentication:", v11);

  return v7;
}

NEIKEv2SessionConfiguration *sub_10010C6B8(int a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  switch((_DWORD)a3)
  {
    case 1:
      if (qword_1001DCA88 != -1) {
        dispatch_once(&qword_1001DCA88, &stru_1001AFD70);
      }
      id String = (id)qword_1001DCA80;
      if (v5)
      {
        uint64_t v7 = 11LL;
        goto LABEL_16;
      }

      goto LABEL_76;
    case 3:
      if (qword_1001DCA78 != -1) {
        dispatch_once(&qword_1001DCA78, &stru_1001AFD50);
      }
      id String = (id)qword_1001DCA70;
      if (v5)
      {
        uint64_t v7 = 10LL;
        goto LABEL_16;
      }

id sub_10010CD5C()
{
  char v6 = 0;
  objc_opt_self(&OBJC_CLASS___NRDKeyManager);
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  id v0 = (id)qword_1001DCC10;
  if (v0)
  {
    id v1 = v0;
    dispatch_assert_queue_V2(*((dispatch_queue_t *)v0 + 2));
    if (!v1[10])
    {
      v1[10] = 1;
      if (v1[8] == 4)
      {
        sub_100143DD4((uint64_t)v1);
        if (v1[9])
        {
          v1[8] = 3;
          sub_100144044((uint64_t)v1);
        }
      }
    }

    int v2 = v1[8] & 0xFD;

    if (v2 == 1) {
      char v6 = 0x80;
    }
  }

  uint64_t v3 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v6, 1LL);
  id v4 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:48701 notifyData:v3];

  return v4;
}

BOOL sub_10010CE6C(void *a1)
{
  id v1 = a1;
  int v2 = v1;
  if (v1) {
    uint64_t v3 = (void *)v1[16];
  }
  else {
    uint64_t v3 = 0LL;
  }
  id v4 = v3;

  BOOL v8 = 0;
  if (v4)
  {
    id v5 = v2 ? (void *)v2[16] : 0LL;
    id v6 = v5;
    id v7 = [v6 proxyCapability];

    if (v7 == (id)1) {
      BOOL v8 = 1;
    }
  }

  return v8;
}

id sub_10010CEF4(void *a1, void *a2)
{
  uint64_t v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    id v56 = sub_100107F78();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v56, 16LL);

    if (IsLevelEnabled)
    {
      id v58 = sub_100107F78();
      _NRLogWithArgs( v58,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "NRLinkCopyProxyPrivateNotify",  1911);
    }

    uint64_t v59 = _os_log_pack_size(12LL);
    id v5 = (char *)&v63 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    char v60 = __error();
    uint64_t v61 = _os_log_pack_fill( v5,  v59,  *v60,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    *(_DWORD *)uint64_t v61 = 136446210;
    *(void *)(v61 + 4) = "NRLinkCopyProxyPrivateNotify";
    id v62 = sub_100107F78();
    _NRLogAbortWithPack(v62, v5);
LABEL_49:
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    goto LABEL_4;
  }

  id v5 = v4;
  if (!sub_10012B114((uint64_t)v3))
  {
    unsigned int port = 62742;
    goto LABEL_10;
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    goto LABEL_49;
  }
LABEL_4:
  id v6 = (id)qword_1001DC870;
  id v7 = v6;
  if (v6 && *((void *)v6 + 19)) {
    unsigned int port = nw_masque_server_get_port();
  }
  else {
    unsigned int port = 0;
  }

LABEL_10:
  __int128 v72 = 0uLL;
  __int16 v73 = 0;
  if (!v5)
  {
    __int128 v71 = 0uLL;
    sub_10012E070(v3, &v71);
    __int128 v72 = v71;
    __int16 v73 = __rev16(port);
  }

  unsigned int v9 = -[NSMutableData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSMutableData),  "initWithBytes:length:",  &v72,  18LL);
  if (_os_feature_enabled_impl("Network", "shoes_udp_associate")
    && *((unsigned __int16 *)v3 + 14) >= 0x11u)
  {
    id v10 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
    NRTLVAdd(v10, 1LL, 0LL, 0LL);
    -[NSMutableData appendData:](v9, "appendData:", v10);
  }

  if (sub_10012B114((uint64_t)v3))
  {
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v11 = (id)qword_1001DC870;
    BOOL v12 = v11;
    if (v11) {
      id v13 = (void *)*((void *)v11 + 13);
    }
    else {
      id v13 = 0LL;
    }
    id v14 = v13;

    if ([v14 length])
    {
      id v15 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
      NRTLVAddData(v15, 2LL);
      -[NSMutableData appendData:](v9, "appendData:", v15);
    }

    else
    {
      id v16 = v3[4];
      id v18 = v3;
      id v19 = (void *)_NRCopyLogObjectForNRUUID(v16, v17);
      int v20 = _NRLogIsLevelEnabled(v19, 17LL);

      uint64_t v3 = v18;
      if (!v20)
      {
LABEL_25:

        goto LABEL_26;
      }

      id v15 = (NSMutableData *)v18[4];
      id v22 = (void *)_NRCopyLogObjectForNRUUID(v15, v21);
      _NRLogWithArgs(v22, 17LL, "MASQUE proxyServerPublicKey is NULL");

      uint64_t v3 = v18;
    }

    goto LABEL_25;
  }

NEIPsecNexus *sub_10010D5C4(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, const char *a6)
{
  id v12 = a1;
  id v13 = a2;
  id v14 = -[NEIPsecNexus initWithName:delegate:enableWithChannelCount:netifRingSize:kernelPipeTxRingSize:kernelPipeRxRingSize:]( objc_alloc(&OBJC_CLASS___NEIPsecNexus),  "initWithName:delegate:enableWithChannelCount:netifRingSize:kernelPipeTxRingSize:kernelPipeRxRingSize:",  v12,  v13,  a3,  a4,  a5,  a6);
  if (v14) {
    goto LABEL_36;
  }
  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  if (qword_1001DCAC8 != -1) {
    goto LABEL_42;
  }
  while (1)
  {
    if (_NRLogIsLevelEnabled(qword_1001DCAC0, 0LL))
    {
      if (p_class_meths[345] != (__objc2_meth_list *)-1LL) {
        dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
      }
      _NRLogWithArgs( qword_1001DCAC0,  0LL,  "%s%.30s:%-4d Retrying [NEIPsecNexus init]",  "",  "NRLinkIPsecNexusCreate",  2048);
    }

    id v14 = -[NEIPsecNexus initWithName:delegate:enableWithChannelCount:netifRingSize:kernelPipeTxRingSize:kernelPipeRxRingSize:]( objc_alloc(&OBJC_CLASS___NEIPsecNexus),  "initWithName:delegate:enableWithChannelCount:netifRingSize:kernelPipeTxRingSize:kernelPipeRxRingSize:",  v12,  v13,  a3,  a4,  a5,  a6);
    if (!v14)
    {
      if (p_class_meths[345] != (__objc2_meth_list *)-1LL) {
        dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCAC0, 0LL))
      {
        if (p_class_meths[345] != (__objc2_meth_list *)-1LL) {
          dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
        }
        _NRLogWithArgs( qword_1001DCAC0,  0LL,  "%s%.30s:%-4d Retrying [NEIPsecNexus init]",  "",  "NRLinkIPsecNexusCreate",  2048);
      }

      id v14 = -[NEIPsecNexus initWithName:delegate:enableWithChannelCount:netifRingSize:kernelPipeTxRingSize:kernelPipeRxRingSize:]( objc_alloc(&OBJC_CLASS___NEIPsecNexus),  "initWithName:delegate:enableWithChannelCount:netifRingSize:kernelPipeTxRingSize:kernelPipeRxRingSize:",  v12,  v13,  a3,  a4,  a5,  a6);
      if (!v14)
      {
        if (p_class_meths[345] != (__objc2_meth_list *)-1LL) {
          dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCAC0, 0LL))
        {
          if (p_class_meths[345] != (__objc2_meth_list *)-1LL) {
            dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
          }
          _NRLogWithArgs( qword_1001DCAC0,  0LL,  "%s%.30s:%-4d Retrying [NEIPsecNexus init]",  "",  "NRLinkIPsecNexusCreate",  2048);
        }

        id v14 = -[NEIPsecNexus initWithName:delegate:enableWithChannelCount:netifRingSize:kernelPipeTxRingSize:kernelPipeRxRingSize:]( objc_alloc(&OBJC_CLASS___NEIPsecNexus),  "initWithName:delegate:enableWithChannelCount:netifRingSize:kernelPipeTxRingSize:kernelPipeRxRingSize:",  v12,  v13,  a3,  a4,  a5,  a6);
        if (!v14)
        {
          if (p_class_meths[345] != (__objc2_meth_list *)-1LL) {
            dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCAC0, 0LL))
          {
            if (p_class_meths[345] != (__objc2_meth_list *)-1LL) {
              dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
            }
            _NRLogWithArgs( qword_1001DCAC0,  0LL,  "%s%.30s:%-4d Retrying [NEIPsecNexus init]",  "",  "NRLinkIPsecNexusCreate",  2048);
          }

          id v14 = -[NEIPsecNexus initWithName:delegate:enableWithChannelCount:netifRingSize:kernelPipeTxRingSize:kernelPipeRxRingSize:]( objc_alloc(&OBJC_CLASS___NEIPsecNexus),  "initWithName:delegate:enableWithChannelCount:netifRingSize:kernelPipeTxRingSize:kernelPipeRxRingSize:",  v12,  v13,  a3,  a4,  a5,  a6);
          if (!v14)
          {
            if (p_class_meths[345] != (__objc2_meth_list *)-1LL) {
              dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
            }
            if (_NRLogIsLevelEnabled(qword_1001DCAC0, 0LL))
            {
              if (p_class_meths[345] != (__objc2_meth_list *)-1LL) {
                dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
              }
              _NRLogWithArgs( qword_1001DCAC0,  0LL,  "%s%.30s:%-4d Retrying [NEIPsecNexus init]",  "",  "NRLinkIPsecNexusCreate",  2048);
            }

            id v14 = -[NEIPsecNexus initWithName:delegate:enableWithChannelCount:netifRingSize:kernelPipeTxRingSize:kernelPipeRxRingSize:]( objc_alloc(&OBJC_CLASS___NEIPsecNexus),  "initWithName:delegate:enableWithChannelCount:netifRingSize:kernelPipeTxRingSize:kernelPipeRxRingSize:",  v12,  v13,  a3,  a4,  a5,  a6);
            if (!v14)
            {
              if (p_class_meths[345] != (__objc2_meth_list *)-1LL) {
                dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
              }
              if (_NRLogIsLevelEnabled(qword_1001DCAC0, 0LL))
              {
                if (p_class_meths[345] != (__objc2_meth_list *)-1LL) {
                  dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
                }
                _NRLogWithArgs( qword_1001DCAC0,  0LL,  "%s%.30s:%-4d Retrying [NEIPsecNexus init]",  "",  "NRLinkIPsecNexusCreate",  2048);
              }

              id v22 = sub_100107F78();
              int IsLevelEnabled = _NRLogIsLevelEnabled(v22, 16LL);

              if (IsLevelEnabled)
              {
                id v24 = sub_100107F78();
                _NRLogWithArgs( v24,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nexus) != ((void *)0)",  "",  "NRLinkIPsecNexusCreate",  2052);
              }

              id v12 = (id)_os_log_pack_size(12LL);
              id v13 = (char *)&v27 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v25 = __error();
              uint64_t v26 = _os_log_pack_fill( v13,  v12,  *v25,  &_mh_execute_header,  "%{public}s Assertion Failed: (nexus) != ((void *)0)");
              *(_DWORD *)uint64_t v26 = 136446210;
              *(void *)(v26 + 4) = "NRLinkIPsecNexusCreate";
              goto LABEL_41;
            }
          }
        }
      }
    }

id *sub_10010DE08(id *a1, void *a2, void *a3)
{
  id v6 = a2;
  id v7 = a3;
  BOOL v8 = v7;
  if (!a1) {
    goto LABEL_12;
  }
  if (!v6)
  {
    id v17 = sub_10010E060();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v17, 17LL);

    if (IsLevelEnabled)
    {
      id v19 = sub_10010E060();
      _NRLogWithArgs(v19, 17LL, "%s called with null queue");
LABEL_11:

      id v15 = 0LL;
      goto LABEL_6;
    }

id sub_10010E060()
{
  if (qword_1001DCAD8 != -1) {
    dispatch_once(&qword_1001DCAD8, &stru_1001AFE60);
  }
  return (id)qword_1001DCAD0;
}

void sub_10010E0A0(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  int v2 = (void *)qword_1001DCAD0;
  qword_1001DCAD0 = (uint64_t)v1;
}

void sub_10010E0D0(uint64_t a1)
{
  int v2 = *(dispatch_queue_s **)(a1 + 24);
  if (v2) {
    dispatch_assert_queue_V2(v2);
  }
  *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = 0;
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) allValues]);
  __int128 v60 = 0u;
  __int128 v61 = 0u;
  __int128 v62 = 0u;
  __int128 v63 = 0u;
  id obj = v3;
  id v4 = [obj countByEnumeratingWithState:&v60 objects:v69 count:16];
  if (v4)
  {
    id v6 = v4;
    id v7 = 0LL;
    uint64_t v8 = *(void *)v61;
    do
    {
      for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v61 != v8) {
          objc_enumerationMutation(obj);
        }
        uint64_t v10 = *(void *)(*((void *)&v60 + 1) + 8LL * (void)i);
        if (v10)
        {
          if ([*(id *)(*((void *)&v60 + 1) + 8 * (void)i) linkType] == 1)
          {
            if (!v7) {
              id v7 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
            }
            -[NSMutableArray addObject:](v7, "addObject:", v10);
          }
        }

        else
        {
          id v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 16), v5);
          int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 16LL);

          if (IsLevelEnabled)
          {
            id v13 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 16), v5);
            _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d Invalid preferences found",  "",  "-[NRDevicePreferencesManager applyLinkPreferences]",  225);
          }
        }
      }

      id v6 = [obj countByEnumeratingWithState:&v60 objects:v69 count:16];
    }

    while (v6);
  }

  else
  {
    id v7 = 0LL;
  }

  id v14 = objc_alloc_init(&OBJC_CLASS___NRBluetoothLinkPreferences);
  __int128 v56 = 0u;
  __int128 v57 = 0u;
  __int128 v58 = 0u;
  __int128 v59 = 0u;
  id v15 = v7;
  id v16 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v15,  "countByEnumeratingWithState:objects:count:",  &v56,  v68,  16LL);
  if (v16)
  {
    id v18 = v16;
    uint64_t v19 = *(void *)v57;
    do
    {
      for (j = 0LL; j != v18; j = (char *)j + 1)
      {
        if (*(void *)v57 != v19) {
          objc_enumerationMutation(v15);
        }
        if (*(void *)(*((void *)&v56 + 1) + 8LL * (void)j))
        {
          objc_msgSend(v14, "combinePreferences:");
        }

        else
        {
          int v21 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 16), v17);
          int v22 = _NRLogIsLevelEnabled(v21, 17LL);

          if (v22)
          {
            int v23 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 16), v17);
            _NRLogWithArgs(v23, 17LL, "Invalid preferences found");
          }
        }
      }

      id v18 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v15,  "countByEnumeratingWithState:objects:count:",  &v56,  v68,  16LL);
    }

    while (v18);
  }

  *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = [v14 isNotEmpty];
  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v24 = (id **)(id)qword_1001DC870;
  uint64_t v25 = v24;
  if (v24)
  {
    uint64_t v26 = *(void **)(a1 + 16);
    uint64_t v27 = v24[5];
    id v28 = v14;
    id v29 = v26;
    if (!v27)
    {
LABEL_76:

      goto LABEL_77;
    }

    int v53 = v27;
    uint64_t v30 = (dispatch_queue_s *)v27[3];
    dispatch_assert_queue_V2(v30);

    p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    if (!v29)
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      id v46 = (id)qword_1001DC720;
      int v47 = _NRLogIsLevelEnabled(v46, 17LL);

      if (!v47) {
        goto LABEL_76;
      }
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      uint64_t v33 = (char *)(id)qword_1001DC720;
      _NRLogWithArgs( v33,  17LL,  "%s called with null nrUUID",  "-[NRLinkManagerBluetooth setLinkRequirements:forNRUUID:]");
      goto LABEL_75;
    }

    id v32 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v29);
    uint64_t v33 = v32;
    if (v32)
    {
      id v34 = *((id *)v32 + 5);
      if (v34)
      {
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC720, 0LL))
        {
          if (qword_1001DC728 != -1) {
            dispatch_once(&qword_1001DC728, &stru_1001AE510);
          }
          _NRLogWithArgs( qword_1001DC720,  0LL,  "%s%.30s:%-4d Requested BT link requirements for %@: %@",  "",  "-[NRLinkManagerBluetooth setLinkRequirements:forNRUUID:]",  759LL,  v29,  v28);
        }

        __int128 v66 = 0u;
        __int128 v67 = 0u;
        __int128 v64 = 0u;
        __int128 v65 = 0u;
        id v54 = v53[5];
        id v35 = [v54 countByEnumeratingWithState:&v64 objects:v70 count:16];
        if (v35)
        {
          id v36 = v35;
          id v37 = v34;
          id v50 = v29;
          id v51 = v28;
          id v52 = v25;
          uint64_t v38 = *(void *)v65;
LABEL_44:
          uint64_t v39 = 0LL;
          while (1)
          {
            if (*(void *)v65 != v38) {
              objc_enumerationMutation(v54);
            }
            uint64_t v40 = *(void *)(*((void *)&v64 + 1) + 8 * v39);
            int v41 = v40 ? *(void **)(v40 + 327) : 0LL;
            id v42 = v41;
            unsigned int v43 = [v42 isEqual:v37];

            if (v43) {
              break;
            }
            if (v36 == (id)++v39)
            {
              id v44 = [v54 countByEnumeratingWithState:&v64 objects:v70 count:16];
              id v36 = v44;
              if (!v44)
              {
                BOOL v45 = 0;
                goto LABEL_56;
              }

              goto LABEL_44;
            }
          }

          BOOL v45 = [(id)v40 state] == 8;
LABEL_56:
          id v28 = v51;
          uint64_t v25 = v52;
          id v29 = v50;
          id v34 = v37;
          p_class_meths = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
        }

        else
        {
          BOOL v45 = 0;
        }

        if (([v28 isNotEmpty] & 1) == 0)
        {

          id v28 = 0LL;
          BOOL v45 = 1;
        }

        [v53[13] setObject:v28 forKeyedSubscript:v34];
        if (v45)
        {
          sub_10002D2D0(v53, v28, v34);
        }

        else
        {
          if (p_class_meths[229] != (__objc2_meth_list *)-1LL) {
            dispatch_once(&qword_1001DC728, &stru_1001AE510);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC720, 0LL))
          {
            if (p_class_meths[229] != (__objc2_meth_list *)-1LL) {
              dispatch_once(&qword_1001DC728, &stru_1001AE510);
            }
            _NRLogWithArgs( qword_1001DC720,  0LL,  "%s%.30s:%-4d Deferring applying new BT link requirements until we have an active link");
          }
        }
      }

      else
      {
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC720, 0LL))
        {
          if (qword_1001DC728 != -1) {
            dispatch_once(&qword_1001DC728, &stru_1001AE510);
          }
          _NRLogWithArgs( qword_1001DC720,  0LL,  "%s%.30s:%-4d Ignoring setting BT link requirements for %@",  "",  "-[NRLinkManagerBluetooth setLinkRequirements:forNRUUID:]",  755LL,  v33);
        }
      }
    }

    else
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      id v48 = (id)qword_1001DC720;
      int v49 = _NRLogIsLevelEnabled(v48, 17LL);

      if (!v49) {
        goto LABEL_75;
      }
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      id v34 = (id)qword_1001DC720;
      _NRLogWithArgs(v34, 17LL, "%s called with null localDevice");
    }

LABEL_75:
    goto LABEL_76;
  }

void sub_10010E880(uint64_t a1)
{
  int v2 = *(dispatch_queue_s **)(a1 + 24);
  if (v2) {
    dispatch_assert_queue_V2(v2);
  }
  uint64_t v3 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  id v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) allValues]);
  id v5 = [v4 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v19;
    do
    {
      uint64_t v8 = 0LL;
      do
      {
        if (*(void *)v19 != v7) {
          objc_enumerationMutation(v4);
        }
        unsigned int v9 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v18 + 1) + 8 * (void)v8) allObjects]);
        -[NSMutableSet addObjectsFromArray:](v3, "addObjectsFromArray:", v9);

        uint64_t v8 = (char *)v8 + 1;
      }

      while (v6 != v8);
      id v6 = [v4 countByEnumeratingWithState:&v18 objects:v22 count:16];
    }

    while (v6);
  }

  uint64_t v10 = (id *)(a1 + 48);
  if ((-[NSMutableSet isEqual:](v3, "isEqual:", *(void *)(a1 + 48)) & 1) == 0)
  {
    id v11 = objc_alloc(&OBJC_CLASS___NSString);
    id v12 = *(id *)(a1 + 48);
    id v13 = (void *)((uint64_t (*)(void))_NRCopyPolicyTrafficClassifiersDescription)();
    id v14 = (void *)_NRCopyPolicyTrafficClassifiersDescription(v3);

    id v15 = -[NSString initWithFormat:](v11, "initWithFormat:", @"%@ to %@", v13, v14);
    id v16 = *(id *)(a1 + 16);
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v16 UUIDString]);
    sub_10011BB18(v16, 13001, v17, v15);

    objc_storeStrong(v10, v3);
  }
}

void sub_10010EA70(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (v3)
    {
      v8[0] = @"client";
      v8[1] = @"type";
      v9[0] = v3;
      v9[1] = &off_1001BC838;
      id v5 = (id)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v9,  v8,  2LL));
      sub_100101A04(@"NetworkRelay BT Link Assertion", v5);
    }

    else
    {
      id v6 = sub_10010E060();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 17LL);

      if (!IsLevelEnabled) {
        goto LABEL_5;
      }
      id v5 = sub_10010E060();
      _NRLogWithArgs( v5,  17LL,  "%s called with null clientName",  "-[NRDevicePreferencesManager addedClientForLinkPreferences:]");
    }
  }

void sub_10010EB74(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    if (v3)
    {
      v8[0] = @"client";
      v8[1] = @"type";
      v9[0] = v3;
      v9[1] = &off_1001BC850;
      id v5 = (id)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v9,  v8,  2LL));
      sub_100101A04(@"NetworkRelay BT Link Assertion", v5);
    }

    else
    {
      id v6 = sub_10010E060();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 17LL);

      if (!IsLevelEnabled) {
        goto LABEL_5;
      }
      id v5 = sub_10010E060();
      _NRLogWithArgs( v5,  17LL,  "%s called with null clientName",  "-[NRDevicePreferencesManager removedClientForLinkPreferences:]");
    }
  }

void sub_10010EC78(uint64_t a1, void *a2, void *a3)
{
  id v11 = a2;
  id v6 = a3;
  if (a1)
  {
    uint64_t v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 16), v5);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 16), v9);
      _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d Setting link preferences for %@ : %@",  "",  "-[NRDevicePreferencesManager setLinkPreferences:forIdentifier:]",  131LL,  v6,  v11);
    }

    [*(id *)(a1 + 32) setObject:v11 forKeyedSubscript:v6];
    sub_10010E0D0(a1);
  }
}

void sub_10010ED44(uint64_t a1, void *a2)
{
  id v8 = a2;
  if (a1 && [*(id *)(a1 + 32) count])
  {
    id v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 16), v3);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 16), v6);
      _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d Removing preferences for %@",  "",  "-[NRDevicePreferencesManager removeLinkPreferencesForIdentifier:]",  143LL,  v8);
    }

    [*(id *)(a1 + 32) setObject:0 forKeyedSubscript:v8];
    sub_10010E0D0(a1);
  }
}

NSString *sub_10010EE08(void *a1)
{
  os_log_t v1 = a1;
  SCDynamicStoreContext context = xpc_connection_get_context(v1);
  if (!context)
  {
    uint64_t pid = xpc_connection_get_pid(v1);
    id v4 = sub_10010393C(pid, 0);
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
    uint64_t v6 = objc_alloc(&OBJC_CLASS___NSString);
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v5 UUIDString]);
    id v8 = -[NSString initWithFormat:](v6, "initWithFormat:", @"%@%s%@", v4, "-", v7);

    uint64_t v9 = v8;
    if (v9)
    {
      uint64_t v10 = v9;
      id v11 = -[NSString UTF8String](v9, "UTF8String");
      if (!v11)
      {
        id v23 = sub_10010E060();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v23, 16LL);

        if (IsLevelEnabled)
        {
          id v25 = sub_10010E060();
          _NRLogWithArgs( v25,  16LL,  "%s%.30s:%-4d ABORTING: strict_strdup called with NULL string",  "",  "strict_strdup",  195);
        }

        uint64_t v26 = _os_log_pack_size(12LL);
        __int128 v20 = (char *)&v35 - ((__chkstk_darwin(v26) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v27 = __error();
        uint64_t v28 = _os_log_pack_fill( v20,  v26,  *v27,  &_mh_execute_header,  "%{public}s strict_strdup called with NULL string");
        *(_DWORD *)uint64_t v28 = 136446210;
        *(void *)(v28 + 4) = "strict_strdup";
LABEL_17:
        id v34 = sub_10010E060();
        _NRLogAbortWithPack(v34, v20);
      }

      id v12 = strdup(v11);
      if (v12)
      {
        SCDynamicStoreContext context = v12;

        xpc_connection_set_context(v1, context);
        xpc_connection_set_finalizer_f(v1, (xpc_finalizer_t)sub_10010F1B0);

        goto LABEL_6;
      }

      id v29 = sub_10010E060();
      int v30 = _NRLogIsLevelEnabled(v29, 16LL);

      uint64_t v17 = "strict_strdup";
      if (v30)
      {
        id v31 = sub_10010E060();
        _NRLogWithArgs(v31, 16LL, "%s%.30s:%-4d ABORTING: strdup() failed", "", "strict_strdup", 201);
      }

      uint64_t v32 = _os_log_pack_size(12LL);
      __int128 v20 = (char *)&v35 - ((__chkstk_darwin(v32) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v33 = *__error();
      uint64_t v22 = _os_log_pack_fill(v20, v32, v33, &_mh_execute_header, "%{public}s strdup() failed");
    }

    else
    {
      id v15 = sub_10010E060();
      int v16 = _NRLogIsLevelEnabled(v15, 16LL);

      uint64_t v17 = "nrStrDupFromNSString";
      if (v16)
      {
        id v18 = sub_10010E060();
        _NRLogWithArgs( v18,  16LL,  "%s%.30s:%-4d ABORTING: nrStrDupFromNSString called with NULL",  "",  "nrStrDupFromNSString",  45);
      }

      uint64_t v19 = _os_log_pack_size(12LL);
      __int128 v20 = (char *)&v35 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v21 = *__error();
      uint64_t v22 = _os_log_pack_fill(v20, v19, v21, &_mh_execute_header, "%{public}s nrStrDupFromNSString called with NULL");
    }

    *(_DWORD *)uint64_t v22 = 136446210;
    *(void *)(v22 + 4) = v17;
    goto LABEL_17;
  }

void sub_10010F1B0(void *a1)
{
  if (a1) {
    free(a1);
  }
}

id sub_10010F4BC()
{
  if (qword_1001DCB00 != -1) {
    dispatch_once(&qword_1001DCB00, &stru_1001B0308);
  }
  return (id)qword_1001DCAF8;
}

void sub_10010F4FC(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  int v2 = (void *)qword_1001DCAF8;
  qword_1001DCAF8 = (uint64_t)v1;
}

void sub_1001102CC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2 || !*(_BYTE *)(v2 + 21))
  {
    id v3 = sub_1001103B8(v2, *(void **)(a1 + 40));
    if (v3)
    {
      uint64_t v5 = *(void *)(a1 + 32);
      id v13 = v3;
      uint64_t v6 = v5 ? *(void *)(v5 + 24) : 0LL;
      uint64_t v7 = (void *)_NRCopyLogObjectForNRUUID(v6, v4);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0LL);

      id v3 = v13;
      if (IsLevelEnabled)
      {
        uint64_t v10 = *(void *)(a1 + 32);
        if (v10) {
          uint64_t v11 = *(void *)(v10 + 24);
        }
        else {
          uint64_t v11 = 0LL;
        }
        id v12 = (void *)_NRCopyLogObjectForNRUUID(v11, v9);
        _NRLogWithArgs( v12,  0LL,  "%s%.30s:%-4d NAN: data session request started for %@",  "",  "-[NRDiscoveryClient dataSessionRequestStarted:]_block_invoke",  2404LL,  v13);

        id v3 = v13;
      }
    }
  }

id sub_1001103B8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  id v5 = 0LL;
  if (a1 && v3)
  {
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 248), "allValues", 0));
    id v5 = [v6 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v5)
    {
      uint64_t v7 = *(void *)v13;
      while (2)
      {
        for (uint64_t i = 0LL; i != v5; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v13 != v7) {
            objc_enumerationMutation(v6);
          }
          uint64_t v9 = *(void **)(*((void *)&v12 + 1) + 8LL * (void)i);
          uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 initiatorDataSession]);

          if (v10 == v4)
          {
            id v5 = v9;
            goto LABEL_13;
          }
        }

        id v5 = [v6 countByEnumeratingWithState:&v12 objects:v16 count:16];
        if (v5) {
          continue;
        }
        break;
      }
    }

void sub_1001104F0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2 || !*(_BYTE *)(v2 + 21))
  {
    id v3 = sub_1001103B8(v2, *(void **)(a1 + 40));
    if (v3)
    {
      id v13 = v3;
      [v3 setLocalInterfaceIndex:0];
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5) {
        uint64_t v6 = *(void *)(v5 + 24);
      }
      else {
        uint64_t v6 = 0LL;
      }
      uint64_t v7 = (void *)_NRCopyLogObjectForNRUUID(v6, v4);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0LL);

      if (IsLevelEnabled)
      {
        uint64_t v10 = *(void *)(a1 + 32);
        if (v10) {
          uint64_t v11 = *(void *)(v10 + 24);
        }
        else {
          uint64_t v11 = 0LL;
        }
        __int128 v12 = (void *)_NRCopyLogObjectForNRUUID(v11, v9);
        _NRLogWithArgs( v12,  0LL,  "%s%.30s:%-4d NAN: data session session terminated for %@ with reason %zd",  "",  "-[NRDiscoveryClient dataSession:terminatedWithReason:]_block_invoke",  2390LL,  v13,  *(void *)(a1 + 48));
      }

      sub_1001105F4(*(void *)(a1 + 32), v13);
      id v3 = v13;
    }
  }

void sub_1001105F4(uint64_t a1, void *a2)
{
  id v6 = a2;
  if (a1 && ([v6 hasActiveDataSession] & 1) == 0)
  {
    id v3 = objc_alloc(&OBJC_CLASS___WiFiAwareDataSession);
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v6 initiatorDiscoveryResult]);
    uint64_t v5 = -[WiFiAwareDataSession initWithDiscoveryResult:serviceType:serviceSpecificInfo:]( v3,  "initWithDiscoveryResult:serviceType:serviceSpecificInfo:",  v4,  1LL,  0LL);

    -[WiFiAwareDataSession setDelegate:](v5, "setDelegate:", a1);
    -[WiFiAwareDataSession start](v5, "start");
    [v6 setInitiatorDataSession:v5];
  }
}

void sub_10011069C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2 || !*(_BYTE *)(v2 + 21))
  {
    id v3 = (void *)(a1 + 40);
    id v4 = sub_1001103B8(v2, *(void **)(a1 + 40));
    id v14 = v4;
    if (v4)
    {
      objc_msgSend(v4, "setLocalInterfaceIndex:", objc_msgSend(*(id *)(a1 + 40), "localInterfaceIndex"));
      sub_1001107B4(*(void *)(a1 + 32), v14);
    }

    else
    {
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5) {
        uint64_t v6 = *(void *)(v5 + 24);
      }
      else {
        uint64_t v6 = 0LL;
      }
      uint64_t v7 = (void *)_NRCopyLogObjectForNRUUID(v6, 0LL);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0LL);

      uint64_t v9 = 0LL;
      if (!IsLevelEnabled) {
        goto LABEL_12;
      }
      uint64_t v10 = *(void **)(a1 + 32);
      if (v10) {
        uint64_t v10 = (void *)v10[3];
      }
      uint64_t v11 = v10;
      id v13 = (void *)_NRCopyLogObjectForNRUUID(v11, v12);
      _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d NAN: ignoring data session started as there is no peer for session %@",  "",  "-[NRDiscoveryClient dataSession:confirmedForPeerDataAddress:serviceSpecificInfo:]_block_invoke",  2373LL,  *v3);
    }

    uint64_t v9 = v14;
LABEL_12:
  }

void sub_1001107B4(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (!a1) {
    goto LABEL_41;
  }
  uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v3);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

  if (IsLevelEnabled)
  {
    id v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v7);
    _NRLogWithArgs( v8,  0LL,  "%s%.30s:%-4d NAN: data session started with peer %@",  "",  "-[NRDiscoveryClient handleDataSessionStarted:]",  2411LL,  v4);
  }

  if ([v4 isInitiator])
  {
    uint64_t v9 = *(void **)(a1 + 240);
    uint64_t v10 = sub_100110C68(a1);
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v4 initiatorDiscoveryResult]);
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 publisherAddress]);
    id v13 = (void *)objc_claimAutoreleasedReturnValue([v4 initiatorDiscoveryResult]);
    v52[0] = _NSConcreteStackBlock;
    v52[1] = 3221225472LL;
    v52[2] = sub_100110DD4;
    v52[3] = &unk_1001B02E8;
    v52[4] = a1;
    objc_msgSend( v9,  "sendMessage:toPeerAddress:withInstanceID:completionHandler:",  v10,  v12,  objc_msgSend(v13, "publishID"),  v52);
  }

  id v14 = (void *)objc_claimAutoreleasedReturnValue([v4 serviceName]);
  __int128 v48 = 0u;
  __int128 v49 = 0u;
  __int128 v50 = 0u;
  __int128 v51 = 0u;
  id v15 = *(id *)(a1 + 96);
  id v16 = [v15 countByEnumeratingWithState:&v48 objects:v53 count:16];
  if (v16)
  {
    id v17 = v16;
    uint64_t v18 = *(void *)v49;
    while (2)
    {
      uint64_t v19 = 0LL;
      do
      {
        if (*(void *)v49 != v18) {
          objc_enumerationMutation(v15);
        }
        __int128 v20 = *(void **)(*((void *)&v48 + 1) + 8LL * (void)v19);
        if (v20) {
          uint64_t v21 = (void *)v20[2];
        }
        else {
          uint64_t v21 = 0LL;
        }
        if ([v21 isEqualToString:v14])
        {
          id v23 = v20;

          if (v20) {
            goto LABEL_35;
          }
          goto LABEL_20;
        }

        uint64_t v19 = (char *)v19 + 1;
      }

      while (v17 != v19);
      id v22 = [v15 countByEnumeratingWithState:&v48 objects:v53 count:16];
      id v17 = v22;
      if (v22) {
        continue;
      }
      break;
    }
  }

LABEL_20:
  id v24 = objc_alloc_init(&OBJC_CLASS___NRDeviceEndpoint);
  id v23 = v24;
  if (v24)
  {
    v24->_xpc_type_t type = *(_BYTE *)(a1 + 18);
    objc_storeStrong((id *)&v24->_serviceName, v14);
  }

  id v25 = (void *)objc_claimAutoreleasedReturnValue([v4 remoteIDSDeviceID]);

  if (v25)
  {
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v4 remoteIDSDeviceID]);
    if (v23) {
      objc_storeStrong((id *)&v23->_remoteIDSDeviceID, v26);
    }

    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    uint64_t v27 = (id)qword_1001DC870;
    uint64_t v28 = (NSUUID *)sub_1000AFCFC(v27, 0LL);
    id v29 = v28;
    if (v23)
    {
      id v29 = v28;
      localIDSDeviceID = (NSUUID *)v23->_localIDSDeviceID;
      v23->_localIDSDeviceID = (NSString *)&v29->super.isa;
LABEL_33:
    }
  }

  else
  {
    id v31 = objc_alloc(&OBJC_CLASS___NSUUID);
    uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v4 serviceName]);
    uint64_t v33 = -[NSUUID initWithUUIDString:](v31, "initWithUUIDString:", v32);
    if (v23) {
      objc_storeStrong((id *)&v23->_peerToken, v33);
    }

    id v34 = objc_alloc(&OBJC_CLASS___NSUUID);
    uint64_t v27 = *(id *)(a1 + 112);
    uint64_t v35 = -[NSUUID initWithUUIDString:](v34, "initWithUUIDString:", v27);
    id v29 = v35;
    if (v23)
    {
      id v29 = v35;
      localIDSDeviceID = v23->_localToken;
      v23->_localToken = v29;
      goto LABEL_33;
    }
  }

  [*(id *)(a1 + 96) addObject:v23];
LABEL_35:
  id v36 = (void *)objc_claimAutoreleasedReturnValue([v4 peerEndpoint]);
  nw_endpoint_t v37 = (nw_endpoint_t)[v36 copyCEndpoint];

  uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue([v4 peerEndpoint]);
  uint64_t v39 = (sockaddr *)[v38 address];

  if (v39->sa_family == 30
    && !*(_DWORD *)&v39[1].sa_data[6]
    && v39->sa_data[6] == 254
    && (v39->sa_data[7] & 0xC0) == 0x80)
  {
    sockaddr v40 = *v39;
    uint64_t v46 = *(void *)&v39[1].sa_len;
    sockaddr address = v40;
    unsigned int v47 = [v4 localInterfaceIndex];
    nw_endpoint_t v41 = nw_endpoint_create_address(&address);

    nw_endpoint_t v37 = v41;
  }

  id v42 = (nw_interface *)nw_interface_create_with_index([v4 localInterfaceIndex]);
  nw_endpoint_set_interface(v37, v42);
  unsigned int v43 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", nw_interface_get_name(v42));
  id v44 = (void *)objc_claimAutoreleasedReturnValue(v43);
  sub_100110E94(a1, v37, v14, v44);

LABEL_41:
}

void *sub_100110C68(uint64_t a1)
{
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NRNANServiceInfo);
  uint64_t v3 = (id *)v2;
  if (v2)
  {
    objc_storeStrong((id *)&v2->_serviceName, *(id *)(a1 + 112));
    objc_storeStrong(v3 + 2, *(id *)(a1 + 120));
    objc_storeStrong(v3 + 1, *(id *)(a1 + 136));
    objc_storeStrong(v3 + 3, *(id *)(a1 + 128));
  }

  id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 data]);
  uint64_t v6 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v5);
  uint64_t v7 = (void *)v6;
  if (v4)
  {
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 2LL);

    if (IsLevelEnabled)
    {
      uint64_t v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v9);
      _NRLogWithArgs( v10,  2LL,  "%s%.30s:%-4d Encoded protobuf: %@",  "",  "-[NRDiscoveryClient copyNANServiceSpecificInfo]",  2029LL,  v4);
    }

    id v11 = v4;
  }

  else
  {
    int v13 = _NRLogIsLevelEnabled(v6, 16LL);

    if (v13)
    {
      id v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v14);
      _NRLogWithArgs( v15,  16LL,  "%s%.30s:%-4d Failed to encode NAN service info protobuf %@",  "",  "-[NRDiscoveryClient copyNANServiceSpecificInfo]",  2026LL,  v3);
    }
  }

  return v4;
}

void sub_100110DD4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4) {
    uint64_t v5 = *(void *)(v4 + 24);
  }
  else {
    uint64_t v5 = 0LL;
  }
  uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(v5, a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

  if (IsLevelEnabled)
  {
    uint64_t v9 = *(void *)(a1 + 32);
    if (v9) {
      uint64_t v10 = *(void *)(v9 + 24);
    }
    else {
      uint64_t v10 = 0LL;
    }
    id v11 = (id)_NRCopyLogObjectForNRUUID(v10, v8);
    _NRLogWithArgs( v11,  0LL,  "%s%.30s:%-4d NAN: sent message to publisher w/ error %zd",  "",  "-[NRDiscoveryClient handleDataSessionStarted:]_block_invoke",  2418,  a2);
  }

void sub_100110E94(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (!a1) {
    goto LABEL_30;
  }
  if (nw_endpoint_get_type(v7) != nw_endpoint_type_address)
  {
    __int128 v20 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v10);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v20, 16LL);

    if (IsLevelEnabled)
    {
      id v23 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v22);
      _NRLogWithArgs( v23,  16LL,  "%s%.30s:%-4d invalid discovered endpoint type",  "",  "-[NRDiscoveryClient discoveredPeerDeviceEndpoint:serviceName:interfaceName:]",  1389);
    }

    goto LABEL_30;
  }

  __int128 v45 = 0u;
  __int128 v46 = 0u;
  __int128 v43 = 0u;
  __int128 v44 = 0u;
  id v11 = *(id *)(a1 + 96);
  id v12 = [v11 countByEnumeratingWithState:&v43 objects:v47 count:16];
  if (!v12) {
    goto LABEL_15;
  }
  id v13 = v12;
  uint64_t v14 = *(void *)v44;
LABEL_5:
  uint64_t v15 = 0LL;
  while (1)
  {
    if (*(void *)v44 != v14) {
      objc_enumerationMutation(v11);
    }
    id v16 = *(void **)(*((void *)&v43 + 1) + 8 * v15);
    id v17 = v16 ? (void *)v16[2] : 0LL;
    if (v13 == (id)++v15)
    {
      id v18 = [v11 countByEnumeratingWithState:&v43 objects:v47 count:16];
      id v13 = v18;
      if (!v18)
      {
LABEL_15:
        uint64_t v19 = v11;
        goto LABEL_29;
      }

      goto LABEL_5;
    }
  }

  uint64_t v19 = v16;

  if (!v16) {
    goto LABEL_30;
  }
  if (!v9)
  {
    uint64_t v33 = a1;
    id v34 = v19;
    uint64_t v35 = v7;
    id v36 = 0LL;
LABEL_28:
    sub_1001111C8(v33, v34, v35, v36);
    char v37 = v19[9];
    uint64_t v38 = *(dispatch_queue_s **)(a1 + 40);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_1001114BC;
    block[3] = &unk_1001B00A0;
    char v42 = v37;
    void block[4] = a1;
    id v41 = v19;
    uint64_t v39 = v19;
    dispatch_async(v38, block);
    v19[9] = 1;

    uint64_t v19 = v39;
    goto LABEL_29;
  }

  id v24 = sub_100104984(v9, 0LL, 0LL, 0);
  id v25 = nw_endpoint_copy_address_string(v7);
  if (!v25)
  {
LABEL_27:

    uint64_t v33 = a1;
    id v34 = v19;
    uint64_t v35 = v7;
    id v36 = v9;
    goto LABEL_28;
  }

  uint64_t v26 = v25;
  uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v25));
  free(v26);
  if (!-[NSMutableSet containsObject:](v24, "containsObject:", v27))
  {

    goto LABEL_27;
  }

  id v29 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v28);
  int v30 = _NRLogIsLevelEnabled(v29, 0LL);

  if (v30)
  {
    uint64_t v32 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v31);
    _NRLogWithArgs( v32,  0LL,  "%s%.30s:%-4d ignoring local endpoint %@",  "",  "-[NRDiscoveryClient discoveredPeerDeviceEndpoint:serviceName:interfaceName:]",  1412LL,  v7);
  }

  [*(id *)(a1 + 96) removeObject:v19];

LABEL_29:
LABEL_30:
}

void sub_1001111C8(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = (void *)nw_endpoint_copy_interface(v8);
  uint64_t v11 = sub_1001114F8(v10);
  if ((_DWORD)v11)
  {
    uint64_t v13 = v11;
LABEL_3:
    uint64_t v14 = v7 + 15;
    if (!v7[15])
    {
      uint64_t v15 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      objc_storeStrong(v7 + 15, v15);
    }

    id v33 = v9;
    if (!v7[16])
    {
      id v16 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      objc_storeStrong(v7 + 16, v16);
    }

    id v17 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithCEndpoint:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithCEndpoint:",  v8));
    id v18 = *v14;
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v13));
    __int128 v20 = (void *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:v19]);

    if (v20)
    {
      uint64_t v21 = -[NSMutableArray initWithArray:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithArray:", v20);
      -[NSMutableArray addObject:](v21, "addObject:", v17);
    }

    else
    {
      id v34 = v17;
      uint64_t v21 = (NSMutableArray *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v34,  1LL));
    }

    id v27 = *v14;
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v13));
    [v27 setObject:v21 forKeyedSubscript:v28];

    id v29 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  nw_interface_get_name((nw_interface_t)v10));
    int v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
    id v31 = v7[16];
    uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v13));
    [v31 setObject:v30 forKeyedSubscript:v32];

    id v9 = v33;
    goto LABEL_15;
  }

  if (v9)
  {
    uint64_t v22 = (void *)nw_interface_create_with_name([v9 UTF8String]);

    uint64_t v13 = sub_1001114F8(v22);
    uint64_t v10 = v22;
    if ((_DWORD)v13) {
      goto LABEL_3;
    }
  }

  id v23 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v12);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v23, 16LL);

  if (IsLevelEnabled)
  {
    uint64_t v26 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v25);
    _NRLogWithArgs( v26,  16LL,  "%s%.30s:%-4d invalid link type for endpoint type",  "",  "-[NRDiscoveryClient updateDeviceEndpoint:withNWEndpoint:interfaceName:]",  1318);
  }

uint64_t sub_1001114BC(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (*(_BYTE *)(result + 48))
  {
    if (!v1) {
      return result;
    }
    uint64_t v2 = *(void *)(v1 + 88);
    if (!v2) {
      return result;
    }
    return (*(uint64_t (**)(uint64_t, void))(v2 + 16))(v2, *(void *)(result + 40));
  }

  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 72);
    if (v2) {
      return (*(uint64_t (**)(uint64_t, void))(v2 + 16))(v2, *(void *)(result + 40));
    }
  }

  return result;
}

uint64_t sub_1001114F8(void *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    nw_interface_type_t type = nw_interface_get_type(v1);
    subnw_interface_type_t type = nw_interface_get_subtype(v2);
    if (type == nw_interface_type_wired)
    {
      uint64_t v5 = 4LL;
    }

    else
    {
      int v6 = subtype;
      name = nw_interface_get_name(v2);
      if (!strcmp("nan0", name))
      {
        uint64_t v5 = 6LL;
      }

      else
      {
        id v8 = nw_interface_get_name(v2);
        int v9 = strcmp("ir0", v8);
        else {
          int v11 = 0;
        }
        if (v6 == 1002) {
          unsigned int v12 = 5;
        }
        else {
          unsigned int v12 = v11;
        }
        if (v9) {
          uint64_t v5 = v12;
        }
        else {
          uint64_t v5 = 7LL;
        }
      }
    }
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  return v5;
}

void sub_1001115C4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2 || !*(_BYTE *)(v2 + 21))
  {
    id v3 = sub_1001103B8(v2, *(void **)(a1 + 40));
    if (v3)
    {
      id v13 = v3;
      [v3 setLocalInterfaceIndex:0];
      uint64_t v5 = *(void *)(a1 + 32);
      uint64_t v6 = v5 ? *(void *)(v5 + 24) : 0LL;
      uint64_t v7 = (void *)_NRCopyLogObjectForNRUUID(v6, v4);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 16LL);

      id v3 = v13;
      if (IsLevelEnabled)
      {
        uint64_t v10 = *(void *)(a1 + 32);
        if (v10) {
          uint64_t v11 = *(void *)(v10 + 24);
        }
        else {
          uint64_t v11 = 0LL;
        }
        unsigned int v12 = (void *)_NRCopyLogObjectForNRUUID(v11, v9);
        _NRLogWithArgs( v12,  16LL,  "%s%.30s:%-4d NAN: data session session request failed for %@ with error %zd",  "",  "-[NRDiscoveryClient dataSession:failedToStartWithError:]_block_invoke",  2359LL,  v13,  *(void *)(a1 + 48));

        id v3 = v13;
      }
    }
  }

void sub_1001116C0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    if (!*(_BYTE *)(v3 + 21) && *(void *)(a1 + 40) == *(void *)(v3 + 240))
    {
      uint64_t v4 = *(void *)(v3 + 24);
      goto LABEL_5;
    }
  }

  else if (!*(void *)(a1 + 40))
  {
    uint64_t v4 = 0LL;
LABEL_5:
    uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(v4, a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v7 = *(void **)(a1 + 32);
      if (v7) {
        uint64_t v7 = (void *)v7[3];
      }
      id v8 = v7;
      uint64_t v10 = (void *)_NRCopyLogObjectForNRUUID(v8, v9);
      _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d NAN: subscriber received discovery result %@",  "",  "-[NRDiscoveryClient subscriber:receivedDiscoveryResult:]_block_invoke",  2271LL,  *(void *)(a1 + 48));
    }

    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) serviceSpecificInfo]);
    id v90 = (void *)objc_claimAutoreleasedReturnValue([v11 blob]);

    unsigned int v12 = v90;
    if (!v90) {
      goto LABEL_73;
    }
    id v13 = *(NRDNANPeer **)(a1 + 32);
    id v14 = v90;
    uint64_t v15 = v14;
    if (!v13)
    {

LABEL_72:
      unsigned int v12 = v90;
LABEL_73:

      return;
    }

    id v16 = -[NRNANServiceInfo initWithData:](objc_alloc(&OBJC_CLASS___NRNANServiceInfo), "initWithData:", v14);
    uint64_t v18 = _NRCopyLogObjectForNRUUID(v13->_serviceName, v17);
    uint64_t v19 = (void *)v18;
    if (!v16)
    {
      int v87 = _NRLogIsLevelEnabled(v18, 16LL);

      if (v87)
      {
        unsigned int v89 = (void *)_NRCopyLogObjectForNRUUID(v13->_serviceName, v88);
        _NRLogWithArgs( v89,  16LL,  "%s%.30s:%-4d Failed to decode NAN service info protobuf",  "",  "-[NRDiscoveryClient processDiscoveredNANPeer:]",  1897);
      }

      goto LABEL_26;
    }

    int v20 = _NRLogIsLevelEnabled(v18, 2LL);

    if (v20)
    {
      uint64_t v22 = v13->_serviceName;
      id v24 = (void *)_NRCopyLogObjectForNRUUID(v22, v23);
      _NRLogWithArgs( v24,  2LL,  "%s%.30s:%-4d Decoded protobuf: %@",  "",  "-[NRDiscoveryClient processDiscoveredNANPeer:]",  1900LL,  v16);
    }

    serviceName = v16->_serviceName;
    if (serviceName
      && (uint64_t v26 = serviceName, v27 = -[NSString length](v26, "length"), v26, v27))
    {
      authTag = v16->_authTag;
      if (authTag)
      {
        id v29 = authTag;
        NSUInteger v30 = -[NSData length](v29, "length");

        if (v30)
        {
          uint64_t v110 = 0LL;
          id v111 = &v110;
          uint64_t v112 = 0x2020000000LL;
          char v113 = 0;
          v107[0] = _NSConcreteStackBlock;
          v107[1] = 3221225472LL;
          v107[2] = sub_1001120E4;
          v107[3] = &unk_1001B01F8;
          v107[4] = v13;
          id v31 = v16;
          id v108 = v31;
          int v109 = &v110;
          uint64_t v32 = objc_retainBlock(v107);
          uint64_t v101 = 0LL;
          uint64_t v102 = &v101;
          uint64_t v103 = 0x3032000000LL;
          id v104 = sub_1001125C8;
          id v105 = sub_1001125D8;
          id v106 = 0LL;
          unint64_t initiatorDiscoveryResult = (unint64_t)v13[3]._initiatorDiscoveryResult;
          if (initiatorDiscoveryResult <= 8 && ((1LL << initiatorDiscoveryResult) & 0x106) != 0)
          {
            id v34 = *(id *)&v13[2]._isInitiator;
            id v35 = v31[1];
            id v36 = v13[2]._responderDataSession;
            char v37 = (void *)objc_claimAutoreleasedReturnValue(-[WiFiAwarePublisherDataSessionHandle dataUsingEncoding:](v36, "dataUsingEncoding:", 4LL));
            id v38 = sub_1001055B0(v34, v35, v37);

            ((void (*)(void *, id, void))v32[2])(v32, v38, 0LL);
          }

          else
          {
            objc_initWeak(&location, v13);
            v95[0] = _NSConcreteStackBlock;
            v95[1] = 3221225472LL;
            v95[2] = sub_1001125E0;
            v95[3] = &unk_1001B0220;
            objc_copyWeak(&v99, &location);
            uint64_t v96 = v32;
            unsigned int v97 = &v110;
            id v98 = &v101;
            sub_1001128E8((uint64_t)v13, 28671LL, v95);

            objc_destroyWeak(&v99);
            objc_destroyWeak(&location);
          }

          if (*((_BYTE *)v111 + 24))
          {
            id v13 = objc_alloc_init(&OBJC_CLASS___NRDNANPeer);
            -[NRDNANPeer setRemoteIDSDeviceID:](v13, "setRemoteIDSDeviceID:", v102[5]);
            id v47 = v31[4];
            -[NRDNANPeer setServiceName:](v13, "setServiceName:", v47);
          }

          else
          {
            id v13 = 0LL;
          }

          _Block_object_dispose(&v101, 8);

          _Block_object_dispose(&v110, 8);
LABEL_32:

          if (v13)
          {
            uint64_t v48 = *(void *)(a1 + 32);
            if (!v48 || !*(void *)(v48 + 248))
            {
              __int128 v49 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
              uint64_t v50 = *(void *)(a1 + 32);
              if (v50) {
                objc_storeStrong((id *)(v50 + 248), v49);
              }

              uint64_t v48 = *(void *)(a1 + 32);
            }

            __int128 v51 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) publisherAddress]);
            id v52 = (void *)sub_100111FC4(v48, v51);

            __int128 v93 = 0u;
            __int128 v94 = 0u;
            __int128 v91 = 0u;
            __int128 v92 = 0u;
            uint64_t v53 = *(void *)(a1 + 32);
            if (v53) {
              id v54 = *(void **)(v53 + 248);
            }
            else {
              id v54 = 0LL;
            }
            id v55 = (NRDNANPeer *)objc_claimAutoreleasedReturnValue([v54 allValues]);
            id v56 = -[NRDNANPeer countByEnumeratingWithState:objects:count:]( v55,  "countByEnumeratingWithState:objects:count:",  &v91,  v114,  16LL);
            if (v56)
            {
              uint64_t v57 = *(void *)v92;
              while (2)
              {
                for (uint64_t i = 0LL; i != v56; uint64_t i = (char *)i + 1)
                {
                  if (*(void *)v92 != v57) {
                    objc_enumerationMutation(v55);
                  }
                  __int128 v59 = *(void **)(*((void *)&v91 + 1) + 8LL * (void)i);
                  __int128 v60 = (void *)objc_claimAutoreleasedReturnValue([v59 peerEndpoint]);
                  if ([v60 isEqual:v52]
                    && (unsigned int v61 = [v59 peerInstanceID],
                        v61 == [*(id *)(a1 + 48) publishID]))
                  {
                    unsigned int v62 = [v59 hasActiveDataSession];

                    if (v62)
                    {
                      uint64_t v79 = *(void *)(a1 + 32);
                      if (v79) {
                        uint64_t v80 = *(void *)(v79 + 24);
                      }
                      else {
                        uint64_t v80 = 0LL;
                      }
                      id v81 = (void *)_NRCopyLogObjectForNRUUID(v80, v63);
                      int v82 = _NRLogIsLevelEnabled(v81, 0LL);

                      if (v82)
                      {
                        uint64_t v84 = *(void *)(a1 + 32);
                        if (v84) {
                          uint64_t v85 = *(void *)(v84 + 24);
                        }
                        else {
                          uint64_t v85 = 0LL;
                        }
                        id v86 = (void *)_NRCopyLogObjectForNRUUID(v85, v83);
                        _NRLogWithArgs( v86,  0LL,  "%s%.30s:%-4d NAN: ignoring same discovery result",  "",  "-[NRDiscoveryClient subscriber:receivedDiscoveryResult:]_block_invoke",  2286);
                      }

                      goto LABEL_71;
                    }
                  }

                  else
                  {
                  }
                }

                id v56 = -[NRDNANPeer countByEnumeratingWithState:objects:count:]( v55,  "countByEnumeratingWithState:objects:count:",  &v91,  v114,  16LL);
                if (v56) {
                  continue;
                }
                break;
              }
            }

            uint64_t v64 = *(void *)(a1 + 32);
            if (v64) {
              __int128 v65 = *(void **)(v64 + 248);
            }
            else {
              __int128 v65 = 0LL;
            }
            id v55 = (NRDNANPeer *)objc_claimAutoreleasedReturnValue([v65 objectForKeyedSubscript:v52]);
            if (!v55) {
              id v55 = objc_alloc_init(&OBJC_CLASS___NRDNANPeer);
            }
            __int128 v66 = (void *)objc_claimAutoreleasedReturnValue(-[NRDNANPeer serviceName](v13, "serviceName"));
            -[NRDNANPeer setServiceName:](v55, "setServiceName:", v66);

            __int128 v67 = (void *)objc_claimAutoreleasedReturnValue(-[NRDNANPeer remoteIDSDeviceID](v13, "remoteIDSDeviceID"));
            -[NRDNANPeer setRemoteIDSDeviceID:](v55, "setRemoteIDSDeviceID:", v67);

            -[NRDNANPeer setPeerEndpoint:](v55, "setPeerEndpoint:", v52);
            -[NRDNANPeer setPeerInstanceID:](v55, "setPeerInstanceID:", [*(id *)(a1 + 48) publishID]);
            -[NRDNANPeer setIsInitiator:](v55, "setIsInitiator:", 1LL);
            -[NRDNANPeer setInitiatorDiscoveryResult:](v55, "setInitiatorDiscoveryResult:", *(void *)(a1 + 48));
            uint64_t v69 = *(void *)(a1 + 32);
            if (v69) {
              uint64_t v70 = *(void *)(v69 + 24);
            }
            else {
              uint64_t v70 = 0LL;
            }
            __int128 v71 = (void *)_NRCopyLogObjectForNRUUID(v70, v68);
            int v72 = _NRLogIsLevelEnabled(v71, 0LL);

            if (v72)
            {
              uint64_t v74 = *(void *)(a1 + 32);
              if (v74) {
                uint64_t v75 = *(void *)(v74 + 24);
              }
              else {
                uint64_t v75 = 0LL;
              }
              id v76 = (void *)_NRCopyLogObjectForNRUUID(v75, v73);
              _NRLogWithArgs( v76,  0LL,  "%s%.30s:%-4d NAN: subscriber discovered a valid peer %@",  "",  "-[NRDiscoveryClient subscriber:receivedDiscoveryResult:]_block_invoke",  2302LL,  v55);
            }

            uint64_t v77 = *(void *)(a1 + 32);
            if (v77) {
              id v78 = *(void **)(v77 + 248);
            }
            else {
              id v78 = 0LL;
            }
            [v78 setObject:v55 forKeyedSubscript:v52];
            sub_1001105F4(*(void *)(a1 + 32), v55);
LABEL_71:
          }

          goto LABEL_72;
        }
      }

      __int128 v44 = (void *)_NRCopyLogObjectForNRUUID(v13->_serviceName, v21);
      int v45 = _NRLogIsLevelEnabled(v44, 16LL);

      if (v45)
      {
        id v41 = v13->_serviceName;
        __int128 v43 = (void *)_NRCopyLogObjectForNRUUID(v41, v46);
        _NRLogWithArgs( v43,  16LL,  "%s%.30s:%-4d No auth tag %@",  "",  "-[NRDiscoveryClient processDiscoveredNANPeer:]",  1907LL,  v16);
        goto LABEL_25;
      }
    }

    else
    {
      uint64_t v39 = (void *)_NRCopyLogObjectForNRUUID(v13->_serviceName, v21);
      int v40 = _NRLogIsLevelEnabled(v39, 16LL);

      if (v40)
      {
        id v41 = v13->_serviceName;
        __int128 v43 = (void *)_NRCopyLogObjectForNRUUID(v41, v42);
        _NRLogWithArgs( v43,  16LL,  "%s%.30s:%-4d No service name %@",  "",  "-[NRDiscoveryClient processDiscoveredNANPeer:]",  1904LL,  v16);
LABEL_25:
      }
    }

void sub_100111F80( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, id location, char a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, char a45)
{
}

uint64_t sub_100111FC4(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (v3)
    {
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v3 ipv6LinkLocalAddress]);
      id v6 = [v5 length];

      if (v6 == (id)16)
      {
        v13[0] = 0LL;
        int v14 = 0;
        v13[1] = 0LL;
        uint64_t v12 = 7708LL;
        uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v4 ipv6LinkLocalAddress]);
        __memcpy_chk(v13, [v7 bytes], objc_msgSend(v7, "length"), 20);
        a1 = objc_claimAutoreleasedReturnValue(+[NWAddressEndpoint endpointWithAddress:](&OBJC_CLASS___NWAddressEndpoint, "endpointWithAddress:", &v12));

        goto LABEL_8;
      }
    }

    else
    {
      id v8 = sub_10010F4BC();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 17LL);

      if (IsLevelEnabled)
      {
        id v10 = sub_10010F4BC();
        _NRLogWithArgs( v10,  17LL,  "%s called with null macAddress",  "-[NRDiscoveryClient copyAddressEndpointFromWFAMacAddress:]");
      }
    }

    a1 = 0LL;
  }

void sub_1001120E4(void *a1, void *a2, void *a3)
{
  id v78 = a2;
  id v5 = a3;
  id v6 = (NSMutableData *)a1[4];
  if (!v6)
  {
LABEL_20:
    NSUInteger v27 = (void *)a1[5];
    if (v27) {
LABEL_21:
    }
      NSUInteger v27 = (void *)v27[4];
LABEL_22:
    uint64_t v28 = v27;
    id v29 = (void *)a1[5];
    if (v29) {
      id v29 = (void *)v29[1];
    }
    NSUInteger v30 = v29;
    id v31 = v78;
    if (v6)
    {
      uint64_t v32 = sub_100112C80((uint64_t)v6, v28, v30);
      id v33 = v32;
      if (v6[32].super.super.isa == (Class)4) {
        id v34 = (NSMutableData *)sub_100112D5C((uint64_t)v6, v32);
      }
      else {
        id v34 = (NSMutableData *)sub_100103FB0(v32, v31);
      }
      id v6 = v34;
    }

    id v35 = (void *)a1[5];
    if (v35) {
      id v35 = (void *)v35[2];
    }
    id v36 = v35;
    BOOL v37 = sub_100105828(v6, v36);

    if (!v37) {
      goto LABEL_40;
    }
    uint64_t v39 = a1[4];
    if (v39) {
      uint64_t v40 = *(void *)(v39 + 24);
    }
    else {
      uint64_t v40 = 0LL;
    }
    id v41 = (void *)_NRCopyLogObjectForNRUUID(v40, v38);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v41, 1LL);

    if (!IsLevelEnabled) {
      goto LABEL_39;
    }
    uint64_t v44 = a1[4];
    if (v44) {
      uint64_t v45 = *(void *)(v44 + 24);
    }
    else {
      uint64_t v45 = 0LL;
    }
    uint64_t v24 = _NRCopyLogObjectForNRUUID(v45, v43);
    uint64_t v25 = (void *)v24;
    int v26 = 1960;
    goto LABEL_38;
  }

  int v7 = BYTE2(v6[2].super.super.isa);
  if (v6[32].super.super.isa != (Class)4)
  {
    if (!BYTE2(v6[2].super.super.isa) || v7 == 255) {
      goto LABEL_20;
    }
    uint64_t v61 = a1[5];
    if (!v61) {
      goto LABEL_41;
    }
    unsigned int v62 = *(void **)(v61 + 24);
    if (!v62) {
      goto LABEL_41;
    }
    id v63 = v62;
    id v64 = [v63 length];

    if (!v64) {
      goto LABEL_41;
    }
    uint64_t v65 = a1[4];
    if (v65)
    {
      int v66 = *(unsigned __int8 *)(v65 + 18);
      __int128 v67 = (void *)a1[5];
      if (!v67) {
        goto LABEL_61;
      }
    }

    else
    {
      int v66 = 0;
      __int128 v67 = (void *)a1[5];
      if (!v67)
      {
LABEL_61:
        uint64_t v68 = v67;
        uint64_t v69 = (void *)a1[5];
        if (v69) {
          uint64_t v69 = (void *)v69[1];
        }
        uint64_t v70 = v69;
        id v71 = v78;
        if (v65)
        {
          int v72 = sub_1001129CC(v65, v66, v68, v70);
          uint64_t v73 = v72;
          if (*(void *)(v65 + 256) == 4LL) {
            uint64_t v74 = sub_100112D5C(v65, v72);
          }
          else {
            uint64_t v74 = sub_100103FB0(v72, v71);
          }
          uint64_t v65 = (uint64_t)v74;
        }

        uint64_t v75 = (void *)a1[5];
        if (v75) {
          uint64_t v75 = (void *)v75[3];
        }
        id v76 = v75;
        BOOL v77 = sub_100105828((void *)v65, v76);

        if (!v77) {
          goto LABEL_41;
        }
        id v6 = (NSMutableData *)a1[4];
        NSUInteger v27 = (void *)a1[5];
        if (v27) {
          goto LABEL_21;
        }
        goto LABEL_22;
      }
    }

    __int128 v67 = (void *)v67[4];
    goto LABEL_61;
  }

  if (!BYTE2(v6[2].super.super.isa) || v7 == 255)
  {
    id v8 = (void *)a1[5];
    if (!v8)
    {
LABEL_7:
      uint64_t v9 = v8;
      id v10 = (void *)a1[5];
      if (v10) {
        id v10 = (void *)v10[1];
      }
      uint64_t v11 = v10;
      id v6 = sub_100112C80((uint64_t)v6, v9, v11);

      uint64_t v13 = a1[4];
      uint64_t v12 = (void *)a1[5];
      if (v12) {
        uint64_t v12 = (void *)v12[2];
      }
      int v14 = v12;
      unsigned int v15 = sub_100112A90(v13, v14, v6, v5);

      if (!v15) {
        goto LABEL_40;
      }
      uint64_t v17 = a1[4];
      if (v17) {
        uint64_t v18 = *(void *)(v17 + 24);
      }
      else {
        uint64_t v18 = 0LL;
      }
      uint64_t v19 = (void *)_NRCopyLogObjectForNRUUID(v18, v16);
      int v20 = _NRLogIsLevelEnabled(v19, 1LL);

      if (!v20)
      {
LABEL_39:
        *(_BYTE *)(*(void *)(a1[6] + 8LL) + 24LL) = 1;
LABEL_40:

        goto LABEL_41;
      }

      uint64_t v22 = a1[4];
      if (v22) {
        uint64_t v23 = *(void *)(v22 + 24);
      }
      else {
        uint64_t v23 = 0LL;
      }
      uint64_t v24 = _NRCopyLogObjectForNRUUID(v23, v21);
      uint64_t v25 = (void *)v24;
      int v26 = 1936;
LABEL_38:
      _NRLogWithArgs( v24,  1LL,  "%s%.30s:%-4d Found a device over NAN",  "",  "-[NRDiscoveryClient processDiscoveredNANPeer:]_block_invoke",  v26);

      goto LABEL_39;
    }

uint64_t sub_1001125C8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1001125D8(uint64_t a1)
{
}

void sub_1001125E0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  uint64_t v9 = WeakRetained;
  if (WeakRetained && !*((_BYTE *)WeakRetained + 21))
  {
    if (v6 || ![v5 count])
    {
      id v10 = (void *)_NRCopyLogObjectForNRUUID(v9[3], v8);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 16LL);

      if (IsLevelEnabled)
      {
        uint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(v9[3], v12);
        _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d No fetched identities (%@)",  "",  "-[NRDiscoveryClient processDiscoveredNANPeer:]_block_invoke_2",  2001LL,  v6);
      }
    }

    else
    {
      int v14 = (void *)_NRCopyLogObjectForNRUUID(v9[3], v8);
      int v15 = _NRLogIsLevelEnabled(v14, 1LL);

      if (v15)
      {
        uint64_t v17 = (void *)_NRCopyLogObjectForNRUUID(v9[3], v16);
        _NRLogWithArgs( v17,  1,  "%s%.30s:%-4d Fetched %u identities",  "",  "-[NRDiscoveryClient processDiscoveredNANPeer:]_block_invoke_2",  1982,  [v5 count]);
      }

      __int128 v38 = 0u;
      __int128 v39 = 0u;
      __int128 v36 = 0u;
      __int128 v37 = 0u;
      id v18 = v5;
      id v19 = [v18 countByEnumeratingWithState:&v36 objects:v41 count:16];
      if (v19)
      {
        uint64_t v20 = *(void *)v37;
        while (2)
        {
          for (uint64_t i = 0LL; i != v19; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v37 != v20) {
              objc_enumerationMutation(v18);
            }
            uint64_t v22 = *(void **)(*((void *)&v36 + 1) + 8LL * (void)i);
            if ([v22 type] == 1)
            {
              id v19 = v22;
              goto LABEL_20;
            }
          }

          id v19 = [v18 countByEnumeratingWithState:&v36 objects:v41 count:16];
          if (v19) {
            continue;
          }
          break;
        }
      }

void sub_1001128E8(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  id v6 = *(void **)(a1 + 184);
  if (!v6)
  {
    int v7 = objc_alloc_init(&OBJC_CLASS___RPClient);
    uint64_t v8 = *(void **)(a1 + 184);
    *(void *)(a1 + 184) = v7;

    uint64_t v9 = *(void **)(a1 + 184);
    id v10 = *(id *)(a1 + 40);
    [v9 setDispatchQueue:v10];

    id v6 = *(void **)(a1 + 184);
  }

  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472LL;
  v12[2] = sub_1001129C0;
  v12[3] = &unk_1001AFEF8;
  id v11 = v5;
  id v13 = v11;
  [v6 getIdentitiesWithFlags:a2 completion:v12];
}

uint64_t sub_1001129C0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

NSMutableData *sub_1001129CC(uint64_t a1, int a2, void *a3, void *a4)
{
  char v12 = a2;
  id v7 = a4;
  uint64_t v8 = 0LL;
  if (a1)
  {
    if (a2)
    {
      id v9 = a3;
      uint64_t v8 = -[NSMutableData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSMutableData),  "initWithBytes:length:",  &v12,  1LL);
      id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 dataUsingEncoding:4]);

      -[NSMutableData appendData:](v8, "appendData:", v10);
      if ([v7 length]) {
        -[NSMutableData appendData:](v8, "appendData:", v7);
      }
    }
  }

  return v8;
}

id sub_100112A90(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = v9;
  if (!a1) {
    goto LABEL_19;
  }
  if (!v7)
  {
    id v21 = sub_10010F4BC();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v21, 17LL);

    if (!IsLevelEnabled) {
      goto LABEL_19;
    }
    id v23 = sub_10010F4BC();
    _NRLogWithArgs(v23, 17LL, "%s called with null signature");
LABEL_18:

    goto LABEL_19;
  }

  if (!v8)
  {
    id v24 = sub_10010F4BC();
    int v25 = _NRLogIsLevelEnabled(v24, 17LL);

    if (!v25) {
      goto LABEL_19;
    }
    id v23 = sub_10010F4BC();
    _NRLogWithArgs(v23, 17LL, "%s called with null data");
    goto LABEL_18;
  }

  if (!v9)
  {
    id v26 = sub_10010F4BC();
    int v27 = _NRLogIsLevelEnabled(v26, 17LL);

    if (v27)
    {
      id v23 = sub_10010F4BC();
      _NRLogWithArgs(v23, 17LL, "%s called with null identity");
      goto LABEL_18;
    }

NSMutableData *sub_100112C80(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  if (a1)
  {
    id v6 = (NSMutableData *)objc_claimAutoreleasedReturnValue([a2 dataUsingEncoding:4]);
    if (*(void *)(a1 + 200))
    {
      id v7 = -[NSMutableData initWithData:](objc_alloc(&OBJC_CLASS___NSMutableData), "initWithData:", v6);
      id v8 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 200) dataUsingEncoding:4]);
      -[NSMutableData appendData:](v7, "appendData:", v8);

      id v6 = v7;
    }

    if ([v5 length])
    {
      id v9 = -[NSMutableData initWithData:](objc_alloc(&OBJC_CLASS___NSMutableData), "initWithData:", v6);
      -[NSMutableData appendData:](v9, "appendData:", v5);

      id v6 = v9;
    }
  }

  else
  {
    id v6 = 0LL;
  }

  return v6;
}

id sub_100112D5C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (!v3)
  {
    id v16 = sub_10010F4BC();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v16, 17LL);

    if (IsLevelEnabled)
    {
      id v18 = sub_10010F4BC();
      _NRLogWithArgs(v18, 17LL, "%s called with null data");
LABEL_15:
    }

void sub_100112EEC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    if (*(_BYTE *)(v2 + 21)) {
      return;
    }
    uint64_t v3 = *(void *)(v2 + 240);
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  if (*(void *)(a1 + 40) == v3)
  {
    uint64_t v4 = sub_100111FC4(v2, *(void **)(a1 + 48));
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5) {
      id v6 = *(void **)(v5 + 248);
    }
    else {
      id v6 = 0LL;
    }
    id v20 = (id)v4;
    id v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:"));
    id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 initiatorDiscoveryResult]);
    if ([v8 publishID] == *(unsigned __int8 *)(a1 + 56))
    {
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v7 responderDataSession]);

      if (v9) {
        goto LABEL_20;
      }
      uint64_t v10 = *(void *)(a1 + 32);
      int v11 = v10 ? *(void **)(v10 + 248) : 0LL;
      [v11 setObject:0 forKeyedSubscript:v20];
      if (!v7) {
        goto LABEL_20;
      }
      sub_100113070(*(void *)(a1 + 32), v7);
      uint64_t v13 = *(void *)(a1 + 32);
      uint64_t v14 = v13 ? *(void *)(v13 + 24) : 0LL;
      id v15 = (void *)_NRCopyLogObjectForNRUUID(v14, v12);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v15, 0LL);

      if (!IsLevelEnabled) {
        goto LABEL_20;
      }
      uint64_t v18 = *(void *)(a1 + 32);
      if (v18) {
        uint64_t v19 = *(void *)(v18 + 24);
      }
      else {
        uint64_t v19 = 0LL;
      }
      id v8 = (void *)_NRCopyLogObjectForNRUUID(v19, v17);
      _NRLogWithArgs( v8,  0LL,  "%s%.30s:%-4d NAN: subscriber lost discovered peer %@",  "",  "-[NRDiscoveryClient subscriber:lostDiscoveryResultForPublishID:address:]_block_invoke",  2257LL,  v7);
    }

LABEL_20:
  }

void sub_100113070(uint64_t a1, void *a2)
{
  id v8 = a2;
  if (a1)
  {
    if ([v8 hasActiveDataSession])
    {
      uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v8 initiatorDataSession]);

      if (v3)
      {
        uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v8 initiatorDataSession]);
        [v4 stop];

        [v8 setInitiatorDataSession:0];
      }

      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([v8 responderDataSession]);

      if (v5)
      {
        id v6 = *(void **)(a1 + 232);
        id v7 = (void *)objc_claimAutoreleasedReturnValue([v8 responderDataSession]);
        [v6 terminateDataSession:v7 completionHandler:&stru_1001B01D0];

        [v8 setResponderDataSession:0];
      }
    }

    [v8 setLocalInterfaceIndex:0];
  }
}

void sub_10011314C(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[4];
  if (v3)
  {
    if (*(_BYTE *)(v3 + 21) || a1[5] != *(void *)(v3 + 240)) {
      return;
    }
    uint64_t v4 = *(void *)(v3 + 24);
  }

  else
  {
    if (a1[5]) {
      return;
    }
    uint64_t v4 = 0LL;
  }

  uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(v4, a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

  if (IsLevelEnabled)
  {
    uint64_t v8 = a1[4];
    if (v8) {
      uint64_t v9 = *(void *)(v8 + 24);
    }
    else {
      uint64_t v9 = 0LL;
    }
    id v10 = (id)_NRCopyLogObjectForNRUUID(v9, v7);
    _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d NAN: subscriber terminated %zd",  "",  "-[NRDiscoveryClient subscriber:terminatedWithReason:]_block_invoke",  2234,  a1[6]);
  }

void sub_10011322C(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[4];
  if (v3)
  {
    if (*(_BYTE *)(v3 + 21) || a1[5] != *(void *)(v3 + 240)) {
      return;
    }
    uint64_t v4 = *(void *)(v3 + 24);
  }

  else
  {
    if (a1[5]) {
      return;
    }
    uint64_t v4 = 0LL;
  }

  uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(v4, a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

  if (IsLevelEnabled)
  {
    uint64_t v8 = a1[4];
    if (v8) {
      uint64_t v9 = *(void *)(v8 + 24);
    }
    else {
      uint64_t v9 = 0LL;
    }
    id v10 = (id)_NRCopyLogObjectForNRUUID(v9, v7);
    _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d NAN: subscriber failed to start %zd",  "",  "-[NRDiscoveryClient subscriber:failedToStartWithError:]_block_invoke",  2221,  a1[6]);
  }

void sub_10011330C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    if (*(_BYTE *)(v3 + 21) || *(void *)(a1 + 40) != *(void *)(v3 + 240)) {
      return;
    }
    uint64_t v4 = *(void *)(v3 + 24);
  }

  else
  {
    if (*(void *)(a1 + 40)) {
      return;
    }
    uint64_t v4 = 0LL;
  }

  uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(v4, a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

  if (IsLevelEnabled)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      uint64_t v9 = *(void *)(v8 + 24);
    }
    else {
      uint64_t v9 = 0LL;
    }
    id v10 = (id)_NRCopyLogObjectForNRUUID(v9, v7);
    _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d NAN: subscriber started",  "",  "-[NRDiscoveryClient subscriberStarted:]_block_invoke",  2208);
  }

void sub_1001133E4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    if (v2 != *(void *)(v3 + 232)) {
      return;
    }
  }

  else if (v2)
  {
    return;
  }

  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) initiatorDataAddress]);
  id v20 = (id)sub_100111FC4(v3, v4);

  uint64_t v5 = *(void *)(a1 + 40);
  if (v5) {
    id v6 = *(void **)(v5 + 248);
  }
  else {
    id v6 = 0LL;
  }
  uint64_t v7 = (NRDNANPeer *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:v20]);
  if (-[NRDNANPeer hasActiveDataSession](v7, "hasActiveDataSession"))
  {
    uint64_t v9 = *(void *)(a1 + 40);
    if (v9) {
      uint64_t v10 = *(void *)(v9 + 24);
    }
    else {
      uint64_t v10 = 0LL;
    }
    int v11 = (void *)_NRCopyLogObjectForNRUUID(v10, v8);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v14 = *(void *)(a1 + 40);
      if (v14) {
        uint64_t v15 = *(void *)(v14 + 24);
      }
      else {
        uint64_t v15 = 0LL;
      }
      id v16 = (void *)_NRCopyLogObjectForNRUUID(v15, v13);
      _NRLogWithArgs( v16,  0LL,  "%s%.30s:%-4d NAN: publisher already has an active data session with %@",  "",  "-[NRDiscoveryClient publisher:dataConfirmedForHandle:localInterfaceIndex:serviceSpecificInfo:]_block_invoke",  2158LL,  v7);
    }
  }

  else
  {
    if (!v7) {
      uint64_t v7 = objc_alloc_init(&OBJC_CLASS___NRDNANPeer);
    }
    -[NRDNANPeer setLocalInterfaceIndex:](v7, "setLocalInterfaceIndex:", *(unsigned int *)(a1 + 56));
    -[NRDNANPeer setResponderDataSession:](v7, "setResponderDataSession:", *(void *)(a1 + 48));
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v20 hostname]);
    -[NRDNANPeer setServiceName:](v7, "setServiceName:", v17);

    -[NRDNANPeer setPeerEndpoint:](v7, "setPeerEndpoint:", v20);
    -[NRDNANPeer setPeerInstanceID:](v7, "setPeerInstanceID:", [*(id *)(a1 + 48) datapathID]);
    uint64_t v18 = *(void *)(a1 + 40);
    if (v18) {
      uint64_t v19 = *(void **)(v18 + 248);
    }
    else {
      uint64_t v19 = 0LL;
    }
    [v19 setObject:v7 forKeyedSubscript:v20];
    sub_1001107B4(*(void *)(a1 + 40), v7);
  }
}

void sub_1001135B4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    if (v2 != *(void *)(v3 + 232)) {
      return;
    }
LABEL_5:
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) initiatorDataAddress]);
    id v20 = (id)sub_100111FC4(v3, v4);

    uint64_t v5 = *(void *)(a1 + 40);
    if (v5) {
      id v6 = *(void **)(v5 + 248);
    }
    else {
      id v6 = 0LL;
    }
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:v20]);
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 responderDataSession]);
    if (v8 == *(void **)(a1 + 48))
    {
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v7 initiatorDataSession]);

      if (v9) {
        goto LABEL_10;
      }
      uint64_t v10 = *(void *)(a1 + 40);
      int v11 = v10 ? *(void **)(v10 + 248) : 0LL;
      [v11 setObject:0 forKeyedSubscript:v20];
      if (!v7) {
        goto LABEL_10;
      }
      sub_100113070(*(void *)(a1 + 40), v7);
      uint64_t v13 = *(void *)(a1 + 40);
      uint64_t v14 = v13 ? *(void *)(v13 + 24) : 0LL;
      uint64_t v15 = (void *)_NRCopyLogObjectForNRUUID(v14, v12);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v15, 0LL);

      if (!IsLevelEnabled) {
        goto LABEL_10;
      }
      uint64_t v18 = *(void *)(a1 + 40);
      if (v18) {
        uint64_t v19 = *(void *)(v18 + 24);
      }
      else {
        uint64_t v19 = 0LL;
      }
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(v19, v17);
      _NRLogWithArgs( v8,  0LL,  "%s%.30s:%-4d NAN: publisher data session terminated for %@ with reason %zd",  "",  "-[NRDiscoveryClient publisher:dataTerminatedForHandle:reason:]_block_invoke",  2142LL,  v7,  *(void *)(a1 + 56));
    }

LABEL_10:
    return;
  }

  if (!v2) {
    goto LABEL_5;
  }
}

void sub_100113754(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[4];
  uint64_t v3 = a1[5];
  if (v3)
  {
    if (v4 != *(void *)(v3 + 232)) {
      return;
    }
    uint64_t v5 = *(void *)(v3 + 24);
  }

  else
  {
    if (v4) {
      return;
    }
    uint64_t v5 = 0LL;
  }

  id v6 = (void *)_NRCopyLogObjectForNRUUID(v5, a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

  if (IsLevelEnabled)
  {
    uint64_t v9 = a1[5];
    if (v9) {
      uint64_t v10 = *(void *)(v9 + 24);
    }
    else {
      uint64_t v10 = 0LL;
    }
    id v11 = (id)_NRCopyLogObjectForNRUUID(v10, v8);
    _NRLogWithArgs( v11,  0LL,  "%s%.30s:%-4d NAN: publisher terminated with reason %zd",  "",  "-[NRDiscoveryClient publisher:terminatedWithReason:]_block_invoke",  2107,  a1[6]);
  }

void sub_100113824(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[4];
  uint64_t v3 = a1[5];
  if (v3)
  {
    if (v4 != *(void *)(v3 + 232)) {
      return;
    }
    uint64_t v5 = *(void *)(v3 + 24);
  }

  else
  {
    if (v4) {
      return;
    }
    uint64_t v5 = 0LL;
  }

  id v6 = (void *)_NRCopyLogObjectForNRUUID(v5, a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

  if (IsLevelEnabled)
  {
    uint64_t v9 = a1[5];
    if (v9) {
      uint64_t v10 = *(void *)(v9 + 24);
    }
    else {
      uint64_t v10 = 0LL;
    }
    id v11 = (id)_NRCopyLogObjectForNRUUID(v10, v8);
    _NRLogWithArgs( v11,  0LL,  "%s%.30s:%-4d NAN: publisher failed with error %zd",  "",  "-[NRDiscoveryClient publisher:failedToStartWithError:]_block_invoke",  2097,  a1[6]);
  }

id sub_1001138F4(uint64_t a1, unsigned int a2, char a3, int a4)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v4 = *(void **)(a1 + 120);
  if (!v4) {
    return 0LL;
  }
  unsigned int v6 = (a3 - 101);
  unint64_t v7 = 0x40300020100uLL >> (8 * a2);
  if (a2 >= 6) {
    LOBYTE(v7) = 0;
  }
  if (v6 >= 4) {
    LOBYTE(v_Block_object_dispose(va, 8) = v7;
  }
  else {
    unsigned int v8 = 0x7060502u >> (8 * v6);
  }
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  v8));
  uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v9]);

  if (!v10) {
    return 0LL;
  }
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  id v11 = v10;
  id v12 = [v11 countByEnumeratingWithState:&v20 objects:v24 count:16];
  if (v12)
  {
    if (a4)
    {
      id v13 = v12;
      uint64_t v14 = *(void *)v21;
      id v15 = (id)a4;
LABEL_12:
      uint64_t v16 = 0LL;
      while (1)
      {
        if (*(void *)v21 != v14) {
          objc_enumerationMutation(v11);
        }
        uint64_t v17 = *(void **)(*((void *)&v20 + 1) + 8 * v16);
        if (objc_msgSend(v17, "addressFamily", (void)v20) == v15) {
          break;
        }
        if (v13 == (id)++v16)
        {
          id v13 = [v11 countByEnumeratingWithState:&v20 objects:v24 count:16];
          id v18 = 0LL;
          if (v13) {
            goto LABEL_12;
          }
          goto LABEL_23;
        }
      }
    }

    else
    {
      uint64_t v17 = (void *)**((void **)&v20 + 1);
      objc_msgSend(**((id **)&v20 + 1), "addressFamily", (void)v20);
    }

    id v18 = v17;
  }

  else
  {
    id v18 = 0LL;
  }

void sub_100113AAC(id a1)
{
  uint64_t v1 = objc_alloc(&OBJC_CLASS___NRDiscoveryManager);
  uint64_t v4 = sub_100146AFC();
  uint64_t v2 = sub_100113B04(v1, v4);
  uint64_t v3 = (void *)qword_1001DCAE8;
  qword_1001DCAE8 = (uint64_t)v2;
}

void *sub_100113B04(void *a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    v18.receiver = a1;
    v18.super_class = (Class)&OBJC_CLASS___NRDiscoveryManager;
    id v5 = objc_msgSendSuper2(&v18, "init");
    if (!v5)
    {
      id v9 = sub_10010F4BC();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 16LL);

      if (IsLevelEnabled)
      {
        id v11 = sub_10010F4BC();
        _NRLogWithArgs( v11,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDiscoveryManager initWithQueue:]",  273);
      }

      uint64_t v12 = _os_log_pack_size(12LL);
      id v13 = (char *)&v17 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v14 = __error();
      uint64_t v15 = _os_log_pack_fill(v13, v12, *v14, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v15 = 136446210;
      *(void *)(v15 + 4) = "-[NRDiscoveryManager initWithQueue:]";
      id v16 = sub_10010F4BC();
      _NRLogAbortWithPack(v16, v13);
    }

    a1 = v5;
    objc_storeStrong((id *)v5 + 2, a2);
    uint64_t v6 = objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
    unint64_t v7 = (void *)a1[3];
    a1[3] = v6;
  }

  return a1;
}

id *sub_100113C7C(id *a1, void *a2, void *a3)
{
  id v6 = a2;
  id v7 = a3;
  if (a1)
  {
    v23.receiver = a1;
    v23.super_class = (Class)&OBJC_CLASS___NRDiscoveryClient;
    unsigned int v8 = (id *)objc_msgSendSuper2(&v23, "init");
    if (!v8)
    {
      id v14 = sub_10010F4BC();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v14, 16LL);

      if (IsLevelEnabled)
      {
        id v16 = sub_10010F4BC();
        _NRLogWithArgs( v16,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDiscoveryClient initWithQueue:nrUUID:]",  349);
      }

      uint64_t v17 = _os_log_pack_size(12LL);
      objc_super v18 = (char *)&v22 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v19 = __error();
      uint64_t v20 = _os_log_pack_fill(v18, v17, *v19, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v20 = 136446210;
      *(void *)(v20 + 4) = "-[NRDiscoveryClient initWithQueue:nrUUID:]";
      id v21 = sub_10010F4BC();
      _NRLogAbortWithPack(v21, v18);
    }

    a1 = v8;
    do
      unint64_t v9 = __ldxr(&qword_1001DC2A8);
    while (__stxr(v9 + 1, &qword_1001DC2A8));
    void v8[4] = (id)v9;
    objc_storeStrong(v8 + 5, a2);
    objc_storeStrong(a1 + 3, a3);
    uint64_t v10 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    id v11 = a1[12];
    a1[12] = v10;

    id v12 = a1[26];
    a1[26] = @"_nrd._tcp";
  }

  return a1;
}

void sub_100113E44(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0LL);

  if (IsLevelEnabled)
  {
    id v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v5);
    _NRLogWithArgs(v6, 0LL, "%s%.30s:%-4d Cancelling %@", "", "-[NRDiscoveryClient cancel]", 367LL, a1);
  }

  *(_BYTE *)(a1 + 21) = 1;
  id v7 = *(void **)(a1 + 56);
  if (v7)
  {
    [v7 invalidate];
    unsigned int v8 = *(void **)(a1 + 56);
    *(void *)(a1 + 56) = 0LL;
  }

  if ([*(id *)(a1 + 64) count])
  {
    __int128 v55 = 0u;
    __int128 v56 = 0u;
    __int128 v53 = 0u;
    __int128 v54 = 0u;
    id v9 = *(id *)(a1 + 64);
    id v10 = [v9 countByEnumeratingWithState:&v53 objects:v60 count:16];
    if (v10)
    {
      id v11 = v10;
      uint64_t v12 = *(void *)v54;
      do
      {
        for (uint64_t i = 0LL; i != v11; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v54 != v12) {
            objc_enumerationMutation(v9);
          }
          [*(id *)(*((void *)&v53 + 1) + 8 * (void)i) invalidate];
        }

        id v11 = [v9 countByEnumeratingWithState:&v53 objects:v60 count:16];
      }

      while (v11);
    }

    id v14 = *(void **)(a1 + 64);
    *(void *)(a1 + 64) = 0LL;
  }

  __int128 v51 = 0u;
  __int128 v52 = 0u;
  __int128 v49 = 0u;
  __int128 v50 = 0u;
  uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 168) allValues]);
  id v16 = [v15 countByEnumeratingWithState:&v49 objects:v59 count:16];
  if (v16)
  {
    id v17 = v16;
    uint64_t v18 = *(void *)v50;
    do
    {
      for (j = 0LL; j != v17; j = (char *)j + 1)
      {
        if (*(void *)v50 != v18) {
          objc_enumerationMutation(v15);
        }
        nw_browser_cancel(*(nw_browser_t *)(*((void *)&v49 + 1) + 8LL * (void)j));
      }

      id v17 = [v15 countByEnumeratingWithState:&v49 objects:v59 count:16];
    }

    while (v17);
  }

  uint64_t v20 = *(void **)(a1 + 168);
  *(void *)(a1 + 16_Block_object_dispose(va, 8) = 0LL;

  sub_100114230(a1);
  __int128 v47 = 0u;
  __int128 v48 = 0u;
  __int128 v45 = 0u;
  __int128 v46 = 0u;
  id v21 = *(id *)(a1 + 176);
  id v22 = [v21 countByEnumeratingWithState:&v45 objects:v58 count:16];
  if (v22)
  {
    id v23 = v22;
    uint64_t v24 = *(void *)v46;
    do
    {
      for (uint64_t k = 0LL; k != v23; uint64_t k = (char *)k + 1)
      {
        if (*(void *)v46 != v24) {
          objc_enumerationMutation(v21);
        }
        nw_resolver_cancel(*(void *)(*((void *)&v45 + 1) + 8LL * (void)k));
      }

      id v23 = [v21 countByEnumeratingWithState:&v45 objects:v58 count:16];
    }

    while (v23);
  }

  id v26 = *(void **)(a1 + 176);
  *(void *)(a1 + 176) = 0LL;

  int v27 = *(void **)(a1 + 216);
  if (v27)
  {
    [v27 invalidate];
    id v28 = *(void **)(a1 + 216);
    *(void *)(a1 + 216) = 0LL;
  }

  uint64_t v29 = *(void **)(a1 + 224);
  if (v29)
  {
    [v29 invalidate];
    uint64_t v30 = *(void **)(a1 + 224);
    *(void *)(a1 + 224) = 0LL;
  }

  __int128 v43 = 0u;
  __int128 v44 = 0u;
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  id v31 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 248) allValues]);
  id v32 = [v31 countByEnumeratingWithState:&v41 objects:v57 count:16];
  if (v32)
  {
    id v33 = v32;
    uint64_t v34 = *(void *)v42;
    do
    {
      for (m = 0LL; m != v33; m = (char *)m + 1)
      {
        if (*(void *)v42 != v34) {
          objc_enumerationMutation(v31);
        }
        sub_100113070(a1, *(void **)(*((void *)&v41 + 1) + 8LL * (void)m));
      }

      id v33 = [v31 countByEnumeratingWithState:&v41 objects:v57 count:16];
    }

    while (v33);
  }

  __int128 v36 = *(void **)(a1 + 248);
  *(void *)(a1 + 24_Block_object_dispose(va, 8) = 0LL;

  __int128 v37 = *(void **)(a1 + 232);
  if (v37)
  {
    [v37 stop];
    __int128 v38 = *(void **)(a1 + 232);
    *(void *)(a1 + 232) = 0LL;
  }

  __int128 v39 = *(void **)(a1 + 240);
  if (v39)
  {
    [v39 stop];
    uint64_t v40 = *(void **)(a1 + 240);
    *(void *)(a1 + 240) = 0LL;
  }

void sub_100114230(uint64_t a1)
{
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 160), "allValues", 0));
  id v3 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v12;
    do
    {
      for (uint64_t i = 0LL; i != v4; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v12 != v5) {
          objc_enumerationMutation(v2);
        }
        nw_listener_cancel(*(nw_listener_t *)(*((void *)&v11 + 1) + 8LL * (void)i));
      }

      id v4 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }

    while (v4);
  }

  id v7 = *(void **)(a1 + 160);
  *(void *)(a1 + 160) = 0LL;

  objc_opt_self(&OBJC_CLASS___NRDiscoveryManager);
  if (qword_1001DCAF0 != -1) {
    dispatch_once(&qword_1001DCAF0, &stru_1001AFE80);
  }
  unsigned int v8 = (id *)(id)qword_1001DCAE8;
  id v9 = v8;
  if (v8) {
    [v8[4] removeObject:*(void *)(a1 + 112)];
  }

  id v10 = *(void **)(a1 + 112);
  *(void *)(a1 + 112) = 0LL;
}

void sub_10011439C(uint64_t a1, uint64_t a2)
{
  if (!*(_BYTE *)(a1 + 15)) {
    return;
  }
  id v62 = *(id *)(a1 + 104);
  if (![v62 count])
  {
LABEL_16:

    return;
  }

  id v4 = *(id *)(a1 + 104);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", a2));
  unsigned int v6 = [v4 containsObject:v5];

  if (!v6) {
    return;
  }
  id v7 = *(id *)(a1 + 120);
  if (!v7 || (uint64_t v9 = *(void *)(a1 + 112), v7, !v9))
  {
    id v16 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v8);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v16, 17LL);

    if (!IsLevelEnabled) {
      return;
    }
    id v62 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v18);
    _NRLogWithArgs(v62, 17LL, "invalid advertising configuration");
    goto LABEL_16;
  }

  if ((_DWORD)a2 == 7)
  {
    id v10 = *(id *)(a1 + 104);
    if (([v10 containsObject:&off_1001BC880] & 1) != 0
      && ([*(id *)(a1 + 104) containsObject:&off_1001BC898] & 1) != 0)
    {
      id v11 = sub_1000A2C08((uint64_t)&OBJC_CLASS___NRLinkDirector);
      __int128 v12 = v11;
      if (v11) {
        __int128 v13 = (void *)*((void *)v11 + 6);
      }
      else {
        __int128 v13 = 0LL;
      }
      id v14 = v13;
      int v15 = sub_100140520((uint64_t)v14);

      if (v15) {
        a2 = 2LL;
      }
      else {
        a2 = 7LL;
      }
    }

    else
    {

      a2 = 7LL;
    }
  }

  uint64_t v19 = (id *)(a1 + 160);
  id v20 = *(id *)(a1 + 160);
  id v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", a2));
  id v22 = (void *)objc_claimAutoreleasedReturnValue([v20 objectForKeyedSubscript:v21]);

  if (!v22 && (a2 & 0xFFFFFFFD) != 1)
  {
    if ((_DWORD)a2 == 6)
    {
      sub_100116DB8(a1);
    }

    else
    {
      id v23 = *(id *)(a1 + 112);
      id v24 = *(id *)(a1 + 208);
      id v25 = *(id *)(a1 + 120);
      id v26 = *(id *)(a1 + 128);
      id v60 = *(id *)(a1 + 264);
      uint64_t v58 = v23;
      id v59 = *(id *)(a1 + 136);
      advertise_descriptor = nw_advertise_descriptor_create_bonjour_service( (const char *)[v23 UTF8String],  (const char *)objc_msgSend(v24, "UTF8String"),  0);
      nw_advertise_descriptor_set_no_auto_rename(advertise_descriptor, 1);
      dictionary = nw_txt_record_create_dictionary();
      nw_txt_record_set_key( dictionary,  "nrAT",  (const uint8_t *)[v25 bytes],  (size_t)objc_msgSend(v25, "length"));
      uint64_t v57 = v26;
      if (v26) {
        nw_txt_record_set_key( dictionary,  "nrD",  (const uint8_t *)[v26 bytes],  (size_t)objc_msgSend(v26, "length"));
      }
      id v63 = dictionary;
      if (v60) {
        nw_txt_record_set_key( dictionary,  "nrAD",  (const uint8_t *)[v60 bytes],  (size_t)objc_msgSend(v60, "length"));
      }
      BOOL v28 = (BOOL)v59;
      if (v59) {
        BOOL v28 = nw_txt_record_set_key( dictionary,  "nrN",  (const uint8_t *)[v59 bytes],  (size_t)objc_msgSend(v59, "length"));
      }
      if (_NRIsAppleInternal(v28))
      {
        if (qword_1001DC9B8 != -1) {
          dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
        }
        if (byte_1001DC9B0)
        {
          *(void *)xpc_object_t value = sub_100116FBC();
          nw_txt_record_set_key(dictionary, "nrF", value, 8uLL);
        }
      }

      nw_advertise_descriptor_set_txt_record_object(advertise_descriptor, dictionary);
      secure_tcp = nw_parameters_create_secure_tcp( _nw_parameters_configure_protocol_disable,  _nw_parameters_configure_protocol_default_configuration);
      uint64_t v30 = secure_tcp;
      parameters = secure_tcp;
      switch((int)a2)
      {
        case 2:
          nw_parameters_set_required_interface_subtype(secure_tcp, 1001LL);
          goto LABEL_41;
        case 4:
          nw_parameters_set_required_interface_type(secure_tcp, nw_interface_type_wired);
          goto LABEL_41;
        case 5:
          id v31 = (nw_interface *)nw_interface_create_with_name("awdl0");
          if (v31) {
            goto LABEL_40;
          }
          id v32 = sub_10010F4BC();
          int v33 = _NRLogIsLevelEnabled(v32, 16LL);

          if (!v33) {
            goto LABEL_46;
          }
          id v34 = sub_10010F4BC();
          __int128 v35 = v34;
          int v36 = 5;
          int v37 = 1246;
          goto LABEL_50;
        case 7:
          id v31 = (nw_interface *)nw_interface_create_with_name("ir0");
          if (v31)
          {
LABEL_40:
            __int128 v38 = v31;
            uint64_t v30 = parameters;
            nw_parameters_require_interface(parameters, v31);

LABEL_41:
            id v55 = v25;
            objc_initWeak((id *)value, (id)a1);
            __int128 v39 = nw_listener_create(v30);
            nw_listener_set_advertise_descriptor(v39, advertise_descriptor);
            uint64_t v40 = (dispatch_queue_s *)*(id *)(a1 + 40);
            nw_listener_set_queue(v39, v40);

            nw_listener_set_new_connection_handler(v39, &stru_1001B0028);
            v64[0] = _NSConcreteStackBlock;
            v64[1] = 3221225472LL;
            v64[2] = sub_100117050;
            v64[3] = &unk_1001B0050;
            objc_copyWeak(&v67, (id *)value);
            char v68 = a2;
            __int128 v41 = v39;
            uint64_t v65 = v41;
            id v42 = v58;
            id v66 = v42;
            nw_listener_set_event_handler(v41, v64);
            nw_listener_start(v41);
            if (!*v19)
            {
              __int128 v43 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
              objc_storeStrong((id *)(a1 + 160), v43);
            }

            id v44 = *(id *)(a1 + 24);
            __int128 v46 = (void *)_NRCopyLogObjectForNRUUID(v44, v45);
            int v47 = _NRLogIsLevelEnabled(v46, 0LL);

            if (v47)
            {
              id v48 = *(id *)(a1 + 24);
              __int128 v50 = (void *)_NRCopyLogObjectForNRUUID(v48, v49);
              _NRLogWithArgs( v50,  0LL,  "%s%.30s:%-4d advertiser created w/ service name %@ for link type %u",  "",  "-[NRDiscoveryClient startAdvertisingOverLinkType:]",  1301LL,  v42,  a2);
            }

            id v51 = *v19;
            __int128 v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", a2));
            [v51 setObject:v41 forKeyedSubscript:v52];

            objc_destroyWeak(&v67);
            objc_destroyWeak((id *)value);
            id v25 = v55;
          }

          else
          {
            id v53 = sub_10010F4BC();
            int v54 = _NRLogIsLevelEnabled(v53, 16LL);

            if (v54)
            {
              id v34 = sub_10010F4BC();
              __int128 v35 = v34;
              int v36 = 7;
              int v37 = 1261;
LABEL_50:
              _NRLogWithArgs( v34,  16LL,  "%s%.30s:%-4d no interface for type %d",  "",  "-[NRDiscoveryClient startAdvertisingOverLinkType:]",  v37,  v36);
            }
          }

void sub_100114AB8(_Unwind_Exception *a1)
{
}

void sub_100114AF8(uint64_t a1, uint64_t a2)
{
  id v31 = *(id *)(a1 + 104);
  if (![v31 count])
  {
LABEL_13:

    return;
  }

  id v4 = *(id *)(a1 + 104);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", a2));
  unsigned int v6 = [v4 containsObject:v5];

  if (!v6) {
    return;
  }
  id v7 = *(id *)(a1 + 168);
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", a2));
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v8]);

  if (v9) {
    return;
  }
  if (!*(void *)(a1 + 144))
  {
    id v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v10);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 16LL);

    if (!IsLevelEnabled) {
      return;
    }
    id v31 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v13);
    _NRLogWithArgs(v31, 16LL, "%s%.30s:%-4d unsupported", "", "-[NRDiscoveryClient startBrowsingOverLinkType:]", 779);
    goto LABEL_13;
  }

  if ((_DWORD)a2 == 6)
  {
    sub_100114F68(a1);
  }

  else
  {
    secure_tcp = nw_parameters_create_secure_tcp( _nw_parameters_configure_protocol_disable,  _nw_parameters_configure_protocol_default_configuration);
    int v15 = secure_tcp;
    switch((_DWORD)a2)
    {
      case 2:
        nw_parameters_set_required_interface_subtype(secure_tcp, 1001LL);
        break;
      case 4:
        nw_parameters_set_required_interface_type(secure_tcp, nw_interface_type_wired);
        break;
      case 5:
        id v16 = (nw_interface *)nw_interface_create_with_name("awdl0");
        nw_parameters_require_interface(v15, v16);

        break;
    }

    objc_initWeak(location, (id)a1);
    bonjour_service = nw_browse_descriptor_create_bonjour_service( (const char *)[*(id *)(a1 + 208) UTF8String],  0);
    nw_browse_descriptor_set_include_txt_record(bonjour_service, 1);
    nw_browser_t v18 = nw_browser_create(bonjour_service, v15);
    state_changed_handler[0] = _NSConcreteStackBlock;
    state_changed_handler[1] = 3221225472LL;
    state_changed_handler[2] = sub_100115084;
    state_changed_handler[3] = &unk_1001AFF48;
    objc_copyWeak(&v39, location);
    char v40 = a2;
    uint64_t v19 = v18;
    __int128 v38 = v19;
    nw_browser_set_state_changed_handler(v19, state_changed_handler);
    id v20 = *(void **)(a1 + 24);
    if (v20)
    {
      id v21 = v20;
      id v22 = sub_100129C28((uint64_t)&OBJC_CLASS___NRDLocalDevice, v21, 0);
    }

    else
    {
      id v22 = 0LL;
    }

    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_100115208;
    handler[3] = &unk_1001AFF98;
    objc_copyWeak(&v35, location);
    char v36 = a2;
    id v23 = v19;
    int v33 = v23;
    id v24 = v22;
    id v34 = v24;
    nw_browser_set_browse_results_changed_handler(v23, handler);
    id v25 = (dispatch_queue_s *)*(id *)(a1 + 40);
    nw_browser_set_queue(v23, v25);

    nw_browser_start(v23);
    id v26 = *(void **)(a1 + 168);
    if (!v26)
    {
      int v27 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      BOOL v28 = *(void **)(a1 + 168);
      *(void *)(a1 + 16_Block_object_dispose(va, 8) = v27;

      id v26 = *(void **)(a1 + 168);
    }

    id v29 = v26;
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", a2));
    [v29 setObject:v23 forKeyedSubscript:v30];

    objc_destroyWeak(&v35);
    objc_destroyWeak(&v39);

    objc_destroyWeak(location);
  }

void sub_100114F24(_Unwind_Exception *a1)
{
}

void sub_100114F68(uint64_t a1)
{
  if (_os_feature_enabled_impl("terminus", "NANLink") && !*(void *)(a1 + 240))
  {
    id v8 = [[WiFiAwareSubscribeConfiguration alloc] initWithServiceName:*(void *)(a1 + 208)];
    [v8 setAuthenticationType:0];
    uint64_t v2 = -[WiFiAwareSubscriber initWithConfiguration:]( objc_alloc(&OBJC_CLASS___WiFiAwareSubscriber),  "initWithConfiguration:",  v8);
    -[WiFiAwareSubscriber setDelegate:](v2, "setDelegate:", a1);
    -[WiFiAwareSubscriber start](v2, "start");
    objc_storeStrong((id *)(a1 + 240), v2);
    id v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v3);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

    if (IsLevelEnabled)
    {
      id v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v6);
      _NRLogWithArgs(v7, 0LL, "%s%.30s:%-4d NAN: subscriber start", "", "-[NRDiscoveryClient startNANSubscriber]", 2196);
    }
  }

void sub_100115084(uint64_t a1, uint64_t a2, void *a3)
{
  id v21 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v6 = WeakRetained;
  if (WeakRetained)
  {
    if (!*((_BYTE *)WeakRetained + 21))
    {
      uint64_t v7 = *(unsigned __int8 *)(a1 + 48);
      id v8 = *((id *)WeakRetained + 21);
      uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v7));
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKeyedSubscript:v9]);
      id v11 = *(void **)(a1 + 32);

      if (v10 == v11)
      {
        uint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(v6[3], v12);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v13, 0LL);

        if (IsLevelEnabled)
        {
          id v16 = (void *)_NRCopyLogObjectForNRUUID(v6[3], v15);
          _NRLogWithArgs( v16,  0LL,  "%s%.30s:%-4d browser entered state: %u (%@)",  "",  "-[NRDiscoveryClient startBrowsingOverLinkType:]_block_invoke",  815LL,  a2,  v21);
        }

        if ((_DWORD)a2 == 1)
        {
          id v17 = (void *)_NRCopyLogObjectForNRUUID(v6[3], v15);
          int v18 = _NRLogIsLevelEnabled(v17, 0LL);

          if (v18)
          {
            id v20 = (void *)_NRCopyLogObjectForNRUUID(v6[3], v19);
            _NRLogWithArgs( v20,  0LL,  "%s%.30s:%-4d browsing started",  "",  "-[NRDiscoveryClient startBrowsingOverLinkType:]_block_invoke",  817);
          }
        }
      }
    }
  }
}

void sub_100115208(uint64_t a1, void *a2, void *a3, int a4)
{
  uint64_t v7 = a2;
  id v8 = a3;
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v10 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    if (!*((_BYTE *)WeakRetained + 21))
    {
      uint64_t v11 = *(unsigned __int8 *)(a1 + 56);
      id v12 = WeakRetained[21];
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v11));
      id v14 = (void *)objc_claimAutoreleasedReturnValue([v12 objectForKeyedSubscript:v13]);
      uint64_t v15 = *(void **)(a1 + 32);

      if (v14 == v15)
      {
        nw_browse_result_change_t changes = nw_browse_result_get_changes(v7, v8);
        int v18 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v10 + 24), v17);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 0LL);

        if (IsLevelEnabled)
        {
          id v21 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v10 + 24), v20);
          _NRLogWithArgs( v21,  0LL,  "%s%.30s:%-4d browser results changed: complete=%d change=%#llx",  "",  "-[NRDiscoveryClient startBrowsingOverLinkType:]_block_invoke_2",  836,  a4,  changes);
        }

        if ((changes & 2) != 0)
        {
          nw_endpoint_t v22 = nw_browse_result_copy_endpoint(v8);
          id v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v10 + 24), v23);
          int v25 = _NRLogIsLevelEnabled(v24, 1LL);

          nw_endpoint_t v75 = v22;
          if (v25)
          {
            int v27 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v10 + 24), v26);
            _NRLogWithArgs( v27,  1LL,  "%s%.30s:%-4d added endpoint %@",  "",  "-[NRDiscoveryClient startBrowsingOverLinkType:]_block_invoke_2",  842LL,  v22);
          }
        }

        else
        {
          nw_endpoint_t v75 = 0LL;
        }

        if ((changes & 4) != 0 && (endpoint = nw_browse_result_copy_endpoint(v7)) != 0LL)
        {
          if (*(void *)(v10 + 80))
          {
            bonjour_service_name = nw_endpoint_get_bonjour_service_name(endpoint);
            if (bonjour_service_name)
            {
              uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  bonjour_service_name));
              __int128 v89 = 0u;
              __int128 v90 = 0u;
              __int128 v87 = 0u;
              __int128 v88 = 0u;
              id v29 = *(id *)(v10 + 96);
              id v30 = [v29 countByEnumeratingWithState:&v87 objects:v91 count:16];
              if (v30)
              {
                uint64_t v31 = *(void *)v88;
                while (2)
                {
                  id v32 = 0LL;
                  do
                  {
                    if (*(void *)v88 != v31) {
                      objc_enumerationMutation(v29);
                    }
                    int v33 = *(void **)(*((void *)&v87 + 1) + 8LL * (void)v32);
                    if (v33) {
                      id v34 = (void *)v33[2];
                    }
                    else {
                      id v34 = 0LL;
                    }
                    if ([v34 isEqualToString:v73])
                    {
                      BOOL v62 = v33 == 0LL;
                      char v36 = v33;

                      if (v62)
                      {
                        char v36 = 0LL;
                        goto LABEL_59;
                      }

                      uint64_t v63 = *(unsigned __int8 *)(a1 + 56);
                      id v64 = v36[15];
                      uint64_t v65 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  v63));
                      [v64 setObject:0 forKeyedSubscript:v65];

                      if ([v36[15] count])
                      {
                        if (!*(void *)(v10 + 88)) {
                          goto LABEL_59;
                        }
                        id v66 = *(dispatch_queue_s **)(v10 + 40);
                        block[0] = _NSConcreteStackBlock;
                        block[1] = 3221225472LL;
                        block[2] = sub_10011599C;
                        block[3] = &unk_1001B0720;
                        id v82 = (id)v10;
                        char v36 = v36;
                        uint64_t v83 = v36;
                        dispatch_async(v66, block);

                        id v29 = v82;
                      }

                      else
                      {
                        [*(id *)(v10 + 96) removeObject:v36];
                        id v67 = *(void **)(v10 + 80);
                        if (!v67) {
                          goto LABEL_59;
                        }
                        id v68 = v67;
                        uint64_t v69 = *(dispatch_queue_s **)(v10 + 40);
                        v84[0] = _NSConcreteStackBlock;
                        v84[1] = 3221225472LL;
                        v84[2] = sub_10011598C;
                        v84[3] = &unk_1001B05A0;
                        id v86 = v68;
                        char v36 = v36;
                        uint64_t v85 = v36;
                        id v29 = v68;
                        dispatch_async(v69, v84);
                      }

                      goto LABEL_58;
                    }

                    id v32 = (char *)v32 + 1;
                  }

                  while (v30 != v32);
                  id v35 = [v29 countByEnumeratingWithState:&v87 objects:v91 count:16];
                  id v30 = v35;
                  if (v35) {
                    continue;
                  }
                  break;
                }
              }

              char v36 = 0LL;
LABEL_58:

LABEL_59:
            }
          }
        }

        else
        {
          endpoint = 0LL;
        }

        if (!v75) {
          goto LABEL_53;
        }
        int v37 = nw_browse_result_copy_endpoint(v8);
        id v39 = nw_endpoint_get_bonjour_service_name(v37);
        if (v39)
        {
          char v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v39));
          __int128 v41 = (void *)objc_claimAutoreleasedReturnValue([v40 lowercaseString]);

          objc_opt_self(&OBJC_CLASS___NRDiscoveryManager);
          if (qword_1001DCAF0 != -1) {
            dispatch_once(&qword_1001DCAF0, &stru_1001AFE80);
          }
          id v42 = (id *)(id)qword_1001DCAE8;
          if (!v42
            || (__int128 v43 = v42,
                unsigned __int8 v44 = [v42[4] containsObject:v41],
                v43,
                (v44 & 1) == 0))
          {
            nw_txt_record_t v71 = nw_browse_result_copy_txt_record_object(v8);
            id v74 = sub_1001159B8(v71, "nrN");
            __int128 v46 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v10 + 24), v45);
            int v47 = _NRLogIsLevelEnabled(v46, 0LL);

            if (v47)
            {
              id v48 = *(id *)(v10 + 24);
              __int128 v50 = (void *)_NRCopyLogObjectForNRUUID(v48, v49);
              _NRLogWithArgs( v50,  0LL,  "%s%.30s:%-4d discovered endpoint %@ serviceName %@",  "",  "-[NRDiscoveryClient startBrowsingOverLinkType:]_block_invoke_2",  896LL,  v37,  v41);
            }

            unint64_t v51 = *(void *)(v10 + 256);
            if (v51 <= 8 && ((1LL << v51) & 0x106) != 0)
            {
              id v52 = *(id *)(v10 + 152);
              if (v74)
              {
                id v53 = *(void **)(v10 + 152);
                id v54 = *(id *)(v10 + 200);
                id v55 = v53;
                __int128 v56 = (void *)objc_claimAutoreleasedReturnValue([v54 dataUsingEncoding:4]);
                id v70 = sub_1001055B0(v55, v74, v56);

                id v52 = v70;
              }

              uint64_t v57 = *(void **)(a1 + 40);
              if (v57) {
                uint64_t v57 = (void *)v57[6];
              }
              uint64_t v58 = v57;
              sub_100115B2C(v10, v8, v37, v41, v52, v58, 0LL);
            }

            else
            {
              v76[0] = _NSConcreteStackBlock;
              v76[1] = 3221225472LL;
              v76[2] = sub_1001163A4;
              void v76[3] = &unk_1001AFF70;
              objc_copyWeak(&v80, (id *)(a1 + 48));
              BOOL v77 = v8;
              id v78 = v37;
              id v79 = v41;
              sub_1001128E8(v10, 28671LL, v76);

              objc_destroyWeak(&v80);
            }
          }
        }

        else
        {
          id v59 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v10 + 24), v38);
          int v60 = _NRLogIsLevelEnabled(v59, 16LL);

          if (!v60)
          {
LABEL_52:

LABEL_53:
            goto LABEL_54;
          }

          __int128 v41 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v10 + 24), v61);
          _NRLogWithArgs( v41,  16LL,  "%s%.30s:%-4d no service name",  "",  "-[NRDiscoveryClient startBrowsingOverLinkType:]_block_invoke_2",  885);
        }

        goto LABEL_52;
      }
    }
  }

void sub_100115970(_Unwind_Exception *a1)
{
}

uint64_t sub_10011598C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32));
}

uint64_t sub_10011599C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    uint64_t v1 = *(void *)(v1 + 88);
  }
  return (*(uint64_t (**)(uint64_t, void))(v1 + 16))(v1, *(void *)(a1 + 40));
}

id sub_1001159B8(void *a1, const char *a2)
{
  uint64_t v3 = a1;
  id v4 = v3;
  if (!a2)
  {
    id v7 = sub_10010F4BC();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 17LL);

    if (IsLevelEnabled)
    {
      id v9 = sub_10010F4BC();
      _NRLogWithArgs(v9, 17LL, "%s called with null key");
LABEL_9:
    }

void sub_100115B14( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_100115B2C(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7)
{
  uint64_t v13 = a2;
  id v14 = a3;
  id obj = a4;
  id v15 = a4;
  id v16 = a5;
  id v91 = a6;
  id v96 = a6;
  id v17 = a7;
  nw_txt_record_t v18 = nw_browse_result_copy_txt_record_object(v13);
  id v19 = sub_1001159B8(v18, "nrN");
  unint64_t v101 = 0LL;
  if (_NRIsAppleInternal(v19))
  {
    if (qword_1001DC9B8 != -1) {
      dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
    }
    if (byte_1001DC9B0)
    {
      id v21 = sub_1001159B8(v18, "nrF");
      if ([v21 length] == (id)8) {
        __memcpy_chk(&v101, [v21 bytes], objc_msgSend(v21, "length"), 8);
      }
    }
  }

  __int128 v94 = v17;
  id v95 = v19;
  if (*(void *)(a1 + 256) == 4LL)
  {
    id v93 = v16;
    nw_endpoint_t v22 = v15;
    id v23 = v14;
    id v24 = sub_1001159B8(v18, "nrAT");
    if ([v24 length])
    {
      int v25 = sub_100112C80(a1, v22, v19);
      unsigned int v27 = sub_100112A90(a1, v24, v25, v17);
      if (!v27) {
        goto LABEL_26;
      }
      BOOL v28 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v26);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v28, 0LL);

      if (IsLevelEnabled)
      {
        id v30 = *(id *)(a1 + 24);
        id v32 = (void *)_NRCopyLogObjectForNRUUID(v30, v31);
        _NRLogWithArgs( v32,  0LL,  "%s%.30s:%-4d discovered a valid peer %@",  "",  "-[NRDiscoveryClient addDiscoveredDeviceIfApplicable:endpoint:serviceName:psk:idsDeviceID:peerIdentity:selfIdentity:]",  1006LL,  v23);
      }

      BOOL v33 = 1;
      unsigned int v34 = 1;
      int v25 = sub_1001159B8(v18, "nrD");
      if ([v25 length])
      {
        __int128 v89 = v13;
        id v35 = sub_1001129CC(a1, *(unsigned __int8 *)(a1 + 18), v22, v95);
        unsigned int v34 = sub_100112A90(a1, v25, v35, v94);
        if (v34)
        {
          int v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v36);
          int v87 = _NRLogIsLevelEnabled(v37, 0LL);

          if (v87)
          {
            id v39 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v38);
            _NRLogWithArgs( v39,  0LL,  "%s%.30s:%-4d discovered a valid device type",  "",  "-[NRDiscoveryClient addDiscoveredDeviceIfApplicable:endpoint:serviceName:psk:idsDeviceID:peerIdentity:selfIdentity:]",  1025);
          }
        }

        uint64_t v13 = v89;
      }

      else
      {
LABEL_26:
        unsigned int v34 = 0;
      }

      BOOL v33 = v27;
    }

    else
    {
      BOOL v33 = 0;
      unsigned int v34 = 0;
    }

void sub_1001163A4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  id v9 = WeakRetained;
  if (WeakRetained && !*((_BYTE *)WeakRetained + 21))
  {
    if (v6 || ![v5 count])
    {
      id v10 = (void *)_NRCopyLogObjectForNRUUID(v9[3], v8);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 16LL);

      if (IsLevelEnabled)
      {
        uint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(v9[3], v12);
        _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d no fetched identities (%@)",  "",  "-[NRDiscoveryClient startBrowsingOverLinkType:]_block_invoke_5",  947LL,  v6);
      }
    }

    else
    {
      id v14 = (void *)_NRCopyLogObjectForNRUUID(v9[3], v8);
      int v15 = _NRLogIsLevelEnabled(v14, 1LL);

      if (v15)
      {
        id v17 = (void *)_NRCopyLogObjectForNRUUID(v9[3], v16);
        _NRLogWithArgs( v17,  1,  "%s%.30s:%-4d fetched %u identities",  "",  "-[NRDiscoveryClient startBrowsingOverLinkType:]_block_invoke_5",  925,  [v5 count]);
      }

      uint64_t v36 = (uint64_t)v9;
      __int128 v43 = 0u;
      __int128 v44 = 0u;
      __int128 v41 = 0u;
      __int128 v42 = 0u;
      id v18 = v5;
      id v19 = [v18 countByEnumeratingWithState:&v41 objects:v46 count:16];
      id v35 = v5;
      if (v19)
      {
        id v20 = v19;
        uint64_t v21 = *(void *)v42;
        while (2)
        {
          for (uint64_t i = 0LL; i != v20; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v42 != v21) {
              objc_enumerationMutation(v18);
            }
            id v23 = *(void **)(*((void *)&v41 + 1) + 8LL * (void)i);
            if ([v23 type] == 1)
            {
              id v34 = v23;
              goto LABEL_20;
            }
          }

          id v20 = [v18 countByEnumeratingWithState:&v41 objects:v46 count:16];
          if (v20) {
            continue;
          }
          break;
        }
      }

      id v34 = 0LL;
LABEL_20:

      __int128 v39 = 0u;
      __int128 v40 = 0u;
      __int128 v37 = 0u;
      __int128 v38 = 0u;
      id v24 = v18;
      id v25 = [v24 countByEnumeratingWithState:&v37 objects:v45 count:16];
      if (v25)
      {
        id v26 = v25;
        uint64_t v27 = *(void *)v38;
        do
        {
          for (j = 0LL; j != v26; j = (char *)j + 1)
          {
            if (*(void *)v38 != v27) {
              objc_enumerationMutation(v24);
            }
            id v29 = *(void **)(*((void *)&v37 + 1) + 8LL * (void)j);
            if ([v29 type] != 1)
            {
              id v30 = *(void **)(a1 + 32);
              uint64_t v31 = *(void **)(a1 + 40);
              id v32 = *(void **)(a1 + 48);
              BOOL v33 = (void *)objc_claimAutoreleasedReturnValue([v29 idsDeviceID]);
              sub_100115B2C(v36, v30, v31, v32, 0LL, v33, v29);
            }
          }

          id v26 = [v24 countByEnumeratingWithState:&v37 objects:v45 count:16];
        }

        while (v26);
      }

      id v6 = 0LL;
      id v5 = v35;
      id v9 = (void *)v36;
    }
  }
}

uint64_t sub_1001166C0(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  subnw_interface_type_t type = nw_interface_get_subtype(v3);
  uint64_t v6 = *(void *)(a1 + 32);
  if (subtype != 5001)
  {
    if (v6) {
      uint64_t v14 = *(void *)(v6 + 24);
    }
    else {
      uint64_t v14 = 0LL;
    }
    int v15 = (void *)_NRCopyLogObjectForNRUUID(v14, v5);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v15, 2LL);

    if (IsLevelEnabled)
    {
      uint64_t v18 = *(void *)(a1 + 32);
      if (v18) {
        uint64_t v19 = *(void *)(v18 + 24);
      }
      else {
        uint64_t v19 = 0LL;
      }
      id v20 = (void *)_NRCopyLogObjectForNRUUID(v19, v17);
      _NRLogWithArgs( v20,  2LL,  "%s%.30s:%-4d resolving over interface %@",  "",  "-[NRDiscoveryClient addDiscoveredDeviceIfApplicable:endpoint:serviceName:psk:idsDeviceID:peerIdentity:selfIdenti ty:]_block_invoke",  1095LL,  v3);
    }

    uint64_t v13 = nw_parameters_create();
    nw_parameters_require_interface(v13, v3);
    uint64_t v21 = *(void *)(a1 + 32);
    if (v21) {
      nw_endpoint_t v22 = *(void **)(v21 + 96);
    }
    else {
      nw_endpoint_t v22 = 0LL;
    }
    [v22 addObject:*(void *)(a1 + 40)];
    sub_100116840(*(void *)(a1 + 32), *(void **)(a1 + 48), v13, *(void **)(a1 + 56));
    goto LABEL_17;
  }

  if (v6) {
    uint64_t v7 = *(void *)(v6 + 24);
  }
  else {
    uint64_t v7 = 0LL;
  }
  uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(v7, v5);
  int v9 = _NRLogIsLevelEnabled(v8, 0LL);

  if (v9)
  {
    uint64_t v11 = *(void *)(a1 + 32);
    if (v11) {
      uint64_t v12 = *(void *)(v11 + 24);
    }
    else {
      uint64_t v12 = 0LL;
    }
    uint64_t v13 = (nw_parameters *)_NRCopyLogObjectForNRUUID(v12, v10);
    _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d skipping companion interface %@",  "",  "-[NRDiscoveryClient addDiscoveredDeviceIfApplicable:endpoint:serviceName:psk:idsDeviceID:peerIdentity:selfIdentity:]_block_invoke",  1092LL,  v3);
LABEL_17:
  }

  return 1LL;
}

void sub_100116840(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (a1)
  {
    objc_initWeak(&location, (id)a1);
    uint64_t v10 = (void *)nw_resolver_create_with_endpoint(v7, v8);
    id v11 = *(id *)(a1 + 40);
    v23[0] = _NSConcreteStackBlock;
    v23[1] = 3221225472LL;
    void v23[2] = sub_100116A40;
    v23[3] = &unk_1001B00F0;
    objc_copyWeak(&v27, &location);
    id v12 = v10;
    id v24 = v12;
    id v25 = v8;
    id v26 = v9;
    nw_resolver_set_update_handler(v12, v11, v23);

    uint64_t v13 = *(void **)(a1 + 176);
    if (!v13)
    {
      uint64_t v14 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      int v15 = *(void **)(a1 + 176);
      *(void *)(a1 + 176) = v14;

      uint64_t v13 = *(void **)(a1 + 176);
    }

    [v13 addObject:v12];
    id v16 = *(id *)(a1 + 24);
    uint64_t v18 = (void *)_NRCopyLogObjectForNRUUID(v16, v17);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 0LL);

    if (IsLevelEnabled)
    {
      id v20 = *(id *)(a1 + 24);
      nw_endpoint_t v22 = (void *)_NRCopyLogObjectForNRUUID(v20, v21);
      _NRLogWithArgs( v22,  0LL,  "%s%.30s:%-4d resolving endpoint %@",  "",  "-[NRDiscoveryClient resolveEndpoint:parameters:serviceName:]",  1473LL,  v7);
    }

    objc_destroyWeak(&v27);
    objc_destroyWeak(&location);
  }
}

void sub_100116A18(_Unwind_Exception *a1)
{
}

void sub_100116A40(uint64_t a1, int a2, void *a3)
{
  id v13 = a3;
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 56));
  id v7 = WeakRetained;
  if (WeakRetained)
  {
    if (!*((_BYTE *)WeakRetained + 21)
      && ([WeakRetained[22] containsObject:*(void *)(a1 + 32)] & 1) != 0)
    {
      if (nw_array_get_count(v13))
      {
        [v7[22] removeObject:*(void *)(a1 + 32)];
        v14[0] = _NSConcreteStackBlock;
        v14[1] = 3221225472LL;
        v14[2] = sub_100116BAC;
        v14[3] = &unk_1001B00C8;
        int v15 = v7;
        id v16 = *(id *)(a1 + 40);
        id v17 = *(id *)(a1 + 48);
        nw_array_apply(v13, v14);
      }

      if (a2 == 2) {
        nw_resolver_cancel(*(void *)(a1 + 32));
      }
      goto LABEL_13;
    }

    id WeakRetained = (id *)v7[3];
  }

  id v8 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained, v6);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 2LL);

  if (IsLevelEnabled)
  {
    if (v7) {
      id v11 = v7[3];
    }
    else {
      id v11 = 0LL;
    }
    id v12 = (void *)_NRCopyLogObjectForNRUUID(v11, v10);
    _NRLogWithArgs( v12,  2LL,  "%s%.30s:%-4d ignoring",  "",  "-[NRDiscoveryClient resolveEndpoint:parameters:serviceName:]_block_invoke",  1443);
  }

uint64_t sub_100116BAC(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  nw_endpoint_type_t type = nw_endpoint_get_type(v4);
  uint64_t v7 = *(void *)(a1 + 32);
  if (type == nw_endpoint_type_address)
  {
    if (v7) {
      uint64_t v8 = *(void *)(v7 + 24);
    }
    else {
      uint64_t v8 = 0LL;
    }
    id v9 = (void *)_NRCopyLogObjectForNRUUID(v8, v6);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v12 = *(void *)(a1 + 32);
      if (v12) {
        uint64_t v13 = *(void *)(v12 + 24);
      }
      else {
        uint64_t v13 = 0LL;
      }
      uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(v13, v11);
      _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d resolved to address endpoint %@",  "",  "-[NRDiscoveryClient resolveEndpoint:parameters:serviceName:]_block_invoke_2",  1454LL,  v4);
    }

    int v15 = nw_parameters_copy_required_interface(*(nw_parameters_t *)(a1 + 40));
    id v16 = v15;
    if (v15)
    {
      id v17 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  nw_interface_get_name(v15));
      uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
    }

    else
    {
      uint64_t v18 = 0LL;
    }

    sub_100110E94(*(void *)(a1 + 32), v4, *(void **)(a1 + 48), v18);
  }

  else
  {
    if (v7) {
      uint64_t v19 = *(void *)(v7 + 24);
    }
    else {
      uint64_t v19 = 0LL;
    }
    id v20 = (void *)_NRCopyLogObjectForNRUUID(v19, v6);
    int v21 = _NRLogIsLevelEnabled(v20, 0LL);

    if (v21)
    {
      uint64_t v23 = *(void *)(a1 + 32);
      if (v23) {
        uint64_t v24 = *(void *)(v23 + 24);
      }
      else {
        uint64_t v24 = 0LL;
      }
      id v25 = (void *)_NRCopyLogObjectForNRUUID(v24, v22);
      _NRLogWithArgs( v25,  0LL,  "%s%.30s:%-4d resolved to endpoint %@",  "",  "-[NRDiscoveryClient resolveEndpoint:parameters:serviceName:]_block_invoke_2",  1451LL,  v4);
    }

    sub_100116840(*(void *)(a1 + 32), v4, *(void *)(a1 + 40), *(void *)(a1 + 48));
  }

  return 1LL;
}

uint64_t sub_100116D54(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a3 == 4)
  {
    uint64_t v6 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a4, a5);
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8LL);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }

  return 1LL;
}

void sub_100116DB8(uint64_t a1)
{
  if (_os_feature_enabled_impl("terminus", "NANLink") && !*(void *)(a1 + 232))
  {
    id v15 = sub_100110C68(a1);
    if (v15)
    {
      id v3 = [[WiFiAwarePublishDatapathConfiguration alloc] initWithServiceType:1 securityConfiguration:0];
      id v4 = objc_alloc_init(&OBJC_CLASS___WiFiAwarePublishServiceSpecificInfo);
      [v4 setBlob:v15];
      [v4 setInstanceName:*(void *)(a1 + 112)];
      id v5 = [[WiFiAwarePublishConfiguration alloc] initWithServiceName:*(void *)(a1 + 208)];
      [v5 setAuthenticationType:0];
      [v5 setDatapathConfiguration:v3];
      [v5 setServiceSpecificInfo:v4];
      uint64_t v6 = -[WiFiAwarePublisher initWithConfiguration:]( objc_alloc(&OBJC_CLASS___WiFiAwarePublisher),  "initWithConfiguration:",  v5);
      -[WiFiAwarePublisher setDelegate:](v6, "setDelegate:", a1);
      -[WiFiAwarePublisher start](v6, "start");
      objc_storeStrong((id *)(a1 + 232), v6);
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v7);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 0LL);

      if (IsLevelEnabled)
      {
        uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v10);
        _NRLogWithArgs( v11,  0LL,  "%s%.30s:%-4d NAN: publisher start",  "",  "-[NRDiscoveryClient startNANAdvertiser]",  2083);
      }
    }

    else
    {
      uint64_t v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v2);
      int v13 = _NRLogIsLevelEnabled(v12, 16LL);

      if (!v13)
      {
LABEL_11:

        return;
      }

      id v3 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v14);
      _NRLogWithArgs( v3,  16LL,  "%s%.30s:%-4d failed to create publish dictionary",  "",  "-[NRDiscoveryClient startNANAdvertiser]",  2063);
    }

    goto LABEL_11;
  }

uint64_t sub_100116FBC()
{
  if (qword_1001DC9B8 != -1) {
    dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
  }
  if (qword_1001DC9C8 != -1) {
    dispatch_once(&qword_1001DC9C8, &stru_1001AFB38);
  }
  if (byte_1001DC9C0) {
    return 3LL;
  }
  else {
    return 1LL;
  }
}

void sub_100117050(uint64_t a1, uint64_t a2, void *a3)
{
  error = a3;
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v6 = WeakRetained;
  if (WeakRetained)
  {
    if (!*((_BYTE *)WeakRetained + 21))
    {
      uint64_t v7 = *(unsigned __int8 *)(a1 + 56);
      id v8 = WeakRetained[20];
      id v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v7));
      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKeyedSubscript:v9]);
      uint64_t v11 = *(void **)(a1 + 32);

      if (v10 == v11)
      {
        int v13 = (void *)_NRCopyLogObjectForNRUUID(v6[3], v12);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v13, 0LL);

        if (IsLevelEnabled)
        {
          id v16 = (void *)_NRCopyLogObjectForNRUUID(v6[3], v15);
          _NRLogWithArgs( v16,  0LL,  "%s%.30s:%-4d listener entered state: %u (%@)",  "",  "-[NRDiscoveryClient startAdvertisingOverLinkType:]_block_invoke_2",  1284LL,  a2,  error);
        }

        if (error)
        {
          if (nw_error_get_error_domain(error) == nw_error_domain_dns && nw_error_get_error_code(error) == -65548)
          {
            sub_100114230((uint64_t)v6);
            sub_100117244((uint64_t)v6, v17);
          }

          else
          {
            sub_100117794((uint64_t)v6, *(unsigned __int8 *)(a1 + 56));
            sub_10011439C(v6, *(unsigned __int8 *)(a1 + 56));
          }
        }

        else if ((_DWORD)a2 == 2)
        {
          uint64_t v18 = (void *)_NRCopyLogObjectForNRUUID(v6[3], v15);
          int v19 = _NRLogIsLevelEnabled(v18, 0LL);

          if (v19)
          {
            id v20 = v6[3];
            uint64_t v22 = (void *)_NRCopyLogObjectForNRUUID(v20, v21);
            _NRLogWithArgs( v22,  0LL,  "%s%.30s:%-4d advertiser started w/ service name %@",  "",  "-[NRDiscoveryClient startAdvertisingOverLinkType:]_block_invoke_2",  1294LL,  *(void *)(a1 + 40));
          }
        }
      }
    }
  }
}

void sub_100117244(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 15) && !*(void *)(a1 + 112))
  {
    if (!*(void *)(a1 + 144))
    {
      uint64_t v18 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), a2);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 16LL);

      if (!IsLevelEnabled) {
        goto LABEL_33;
      }
      uint64_t v21 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v20);
      _NRLogWithArgs(v21, 16LL, "%s%.30s:%-4d unsupported: no PSK");
      goto LABEL_32;
    }

    if (!*(void *)(a1 + 136))
    {
      uint64_t v22 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), a2);
      int v23 = _NRLogIsLevelEnabled(v22, 16LL);

      if (!v23) {
        goto LABEL_33;
      }
      uint64_t v21 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v24);
      _NRLogWithArgs(v21, 16LL, "%s%.30s:%-4d unsupported: no nonce");
      goto LABEL_32;
    }

    id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
    id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 UUIDString]);
    uint64_t v5 = objc_claimAutoreleasedReturnValue([v4 lowercaseString]);
    uint64_t v6 = *(void **)(a1 + 112);
    *(void *)(a1 + 112) = v5;

    objc_opt_self(&OBJC_CLASS___NRDiscoveryManager);
    if (qword_1001DCAF0 != -1) {
      dispatch_once(&qword_1001DCAF0, &stru_1001AFE80);
    }
    uint64_t v7 = (id)qword_1001DCAE8;
    id v8 = *(id *)(a1 + 112);
    if (v7)
    {
      id v9 = (void *)v7[4];
      if (!v9)
      {
        uint64_t v10 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        uint64_t v11 = (void *)v7[4];
        void v7[4] = v10;

        id v9 = (void *)v7[4];
      }

      [v9 addObject:v8];
    }

    id v12 = *(id *)(a1 + 112);
    id v13 = *(id *)(a1 + 144);
    id v14 = *(id *)(a1 + 136);
    uint64_t v15 = sub_100112C80(a1, v12, v14);
    id v16 = v15;
    if (*(void *)(a1 + 256) == 4LL) {
      uint64_t v17 = sub_100112D5C(a1, v15);
    }
    else {
      uint64_t v17 = sub_100103FB0(v15, v13);
    }
    uint64_t v21 = v17;

    if (v21)
    {
      if (qword_1001DCA28 != -1) {
        dispatch_once(&qword_1001DCA28, &stru_1001AFC48);
      }
      int v26 = byte_1001DCA20;
      id v27 = *(id *)(a1 + 112);
      id v28 = *(id *)(a1 + 144);
      id v29 = *(id *)(a1 + 136);
      id v30 = sub_1001129CC(a1, v26, v27, v29);
      uint64_t v31 = v30;
      if (*(void *)(a1 + 256) == 4LL) {
        id v32 = sub_100112D5C(a1, v30);
      }
      else {
        id v32 = sub_100103FB0(v30, v28);
      }
      uint64_t v36 = v32;

      objc_storeStrong((id *)(a1 + 120), v21);
      objc_storeStrong((id *)(a1 + 128), v36);
      __int128 v38 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v37);
      int v39 = _NRLogIsLevelEnabled(v38, 1LL);

      if (v39)
      {
        id v41 = *(id *)(a1 + 24);
        __int128 v43 = (void *)_NRCopyLogObjectForNRUUID(v41, v42);
        Logid String = (void *)_NRKeyCreateLogString(*(void *)(a1 + 120));

        _NRLogWithArgs( v43,  1LL,  "%s%.30s:%-4d created advertisement auth tag: %@",  "",  "-[NRDiscoveryClient setupAdvertisingMetadataIfNeeded]",  1145LL,  LogString);
      }

      if (*(void *)(a1 + 128))
      {
        int v45 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v40);
        int v46 = _NRLogIsLevelEnabled(v45, 1LL);

        if (v46)
        {
          id v47 = *(id *)(a1 + 24);
          uint64_t v49 = (void *)_NRCopyLogObjectForNRUUID(v47, v48);
          id v50 = (void *)_NRKeyCreateLogString(*(void *)(a1 + 128));

          _NRLogWithArgs( v49,  1LL,  "%s%.30s:%-4d created advertisement device type hash: %@",  "",  "-[NRDiscoveryClient setupAdvertisingMetadataIfNeeded]",  1147LL,  v50);
        }
      }
    }

    else
    {
      BOOL v33 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v25);
      int v34 = _NRLogIsLevelEnabled(v33, 16LL);

      if (!v34)
      {
        uint64_t v21 = 0LL;
        goto LABEL_32;
      }

      uint64_t v36 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v35);
      _NRLogWithArgs( v36,  16LL,  "%s%.30s:%-4d no auth tag",  "",  "-[NRDiscoveryClient setupAdvertisingMetadataIfNeeded]",  1135);
    }

LABEL_32:
  }

void sub_100117794(uint64_t a1, uint64_t a2)
{
  id v4 = *(id *)(a1 + 160);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", a2));
  listener = (nw_listener *)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v5]);

  uint64_t v6 = listener;
  if (listener)
  {
    nw_listener_cancel(listener);
    id v7 = *(id *)(a1 + 160);
    id v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", a2));
    [v7 setObject:0 forKeyedSubscript:v8];

    uint64_t v6 = listener;
  }
}

void sub_100117864(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = WeakRetained;
  if (!WeakRetained || *((_BYTE *)WeakRetained + 21)) {
    goto LABEL_26;
  }
  id v3 = WeakRetained[3];
  if (v3)
  {
    id v4 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v3);
    uint64_t v5 = v4;
    if (v4)
    {
      if (v4[15])
      {
        char v6 = 1;
        if (!v4[12]) {
          goto LABEL_19;
        }
      }

      else
      {
        if (v4[14]) {
          BOOL v7 = 1;
        }
        else {
          BOOL v7 = *((unsigned __int16 *)v4 + 14) > 0x12u;
        }
        char v6 = v7;
        if (!v4[12])
        {
LABEL_19:
          id v8 = v2[3];
          objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
          uint64_t v9 = objc_claimAutoreleasedReturnValue([(id)qword_1001DCBA0 objectForKeyedSubscript:v8]);

          id v10 = v2[25];
          v2[25] = (id)v9;

          if (!v2[25]) {
            v2[25] = @"nr-pairing";
          }
          goto LABEL_21;
        }
      }

      if (!v4[13]) {
        char v6 = 0;
      }
      if ((v6 & 1) != 0) {
        goto LABEL_21;
      }
      goto LABEL_19;
    }
  }

  else
  {
    uint64_t v5 = 0LL;
  }

void sub_100117A88(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    if (*(_BYTE *)(v3 + 21)) {
      return;
    }
    *(_BYTE *)(v3 + 20) = 1;
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4)
    {
      if (!*(_BYTE *)(v4 + 15) || (sub_100117244(*(void *)(a1 + 32), a2), (uint64_t v4 = *(void *)(a1 + 32)) != 0))
      {
        if (*(_BYTE *)(v4 + 16))
        {
          __int128 v35 = 0u;
          __int128 v36 = 0u;
          memset(v37, 0, sizeof(v37));
          id v5 = *(id *)(v4 + 104);
          id v6 = [v5 countByEnumeratingWithState:&v35 objects:&v40 count:16];
          if (v6)
          {
            uint64_t v7 = *(void *)v36;
            do
            {
              for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v36 != v7) {
                  objc_enumerationMutation(v5);
                }
                sub_100114AF8( v4,  [*(id *)(*((void *)&v35 + 1) + 8 * (void)i) unsignedShortValue]);
              }

              id v6 = [v5 countByEnumeratingWithState:&v35 objects:&v40 count:16];
            }

            while (v6);
          }
        }
      }
    }
  }

  uint64_t v9 = *(void **)(a1 + 40);
  if (v9) {
    uint64_t v9 = (void *)v9[16];
  }
  int v34 = v9;
  id v10 = (void *)objc_claimAutoreleasedReturnValue([v34 allowedLinkTypes]);
  if ([v10 containsObject:&off_1001BC868]
    && (uint64_t v11 = *(_BYTE **)(a1 + 40)) != 0LL
    && v11[9]
    && v11[20])
  {
    int v12 = v11[10];

    if (!v12)
    {
      uint64_t v14 = *(void *)(a1 + 32);
      if (v14)
      {
        if ((_NRIsAppleInternal(v13) & 1) != 0)
        {
          if (!*(void *)(v14 + 216))
          {
            id v16 = objc_alloc_init(&OBJC_CLASS___CBAdvertiser);
            uint64_t v17 = *(void **)(v14 + 216);
            *(void *)(v14 + 216) = v16;

            [*(id *)(v14 + 216) setNearbyActionType:5];
            [*(id *)(v14 + 216) setDispatchQueue:*(void *)(v14 + 40)];
            do
              uint32_t v18 = arc4random_uniform(0xFFFFu);
            while (!(_WORD)v18);
            __int16 v39 = bswap32(v18) >> 16;
            int v19 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v39, 2LL);
            uint64_t v20 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
            -[NSMutableData appendData:](v20, "appendData:", v19);
            uint64_t v21 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
            -[NSMutableData appendData:](v21, "appendData:", v19);
            uint64_t v22 = *(void **)(v14 + 200);
            if (v22)
            {
              id v23 = v22;
              uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v23 dataUsingEncoding:4]);
              -[NSMutableData appendData:](v21, "appendData:", v24);
            }

            *(void *)&__int128 v35 = 0LL;
            *((void *)&v35 + 1) = &v35;
            *(void *)&__int128 v36 = 0x3032000000LL;
            *((void *)&v36 + 1) = sub_1001125C8;
            *(void *)&v37[0] = sub_1001125D8;
            *((void *)&v37[0] + 1) = 0LL;
            objc_initWeak(&location, (id)v14);
            uint64_t v40 = _NSConcreteStackBlock;
            uint64_t v41 = 3221225472LL;
            uint64_t v42 = sub_10011916C;
            __int128 v43 = &unk_1001B0190;
            objc_copyWeak(&v47, &location);
            int v46 = &v35;
            uint64_t v25 = v21;
            __int128 v44 = v25;
            int v26 = v20;
            int v45 = v26;
            __int16 v48 = v39;
            sub_1001128E8(v14, 1LL, &v40);

            objc_destroyWeak(&v47);
            objc_destroyWeak(&location);
            _Block_object_dispose(&v35, 8);
          }

          if (!*(void *)(v14 + 224))
          {
            id v27 = objc_alloc_init(&OBJC_CLASS___CBDiscovery);
            id v28 = *(void **)(v14 + 224);
            *(void *)(v14 + 224) = v27;

            [*(id *)(v14 + 224) setDispatchQueue:*(void *)(v14 + 40)];
            [*(id *)(v14 + 224) setDiscoveryFlags:0x20000002000000];
            objc_initWeak(&location, (id)v14);
            uint64_t v40 = _NSConcreteStackBlock;
            uint64_t v41 = 3221225472LL;
            uint64_t v42 = sub_1001185F4;
            __int128 v43 = &unk_1001B0118;
            objc_copyWeak((id *)&v44, &location);
            [*(id *)(v14 + 224) setDeviceFoundHandler:&v40];
            id v29 = *(void **)(v14 + 224);
            *(void *)&__int128 v35 = _NSConcreteStackBlock;
            *((void *)&v35 + 1) = 3221225472LL;
            *(void *)&__int128 v36 = sub_1001189F8;
            *((void *)&v36 + 1) = &unk_1001B0140;
            objc_copyWeak((id *)v37, &location);
            [v29 activateWithCompletion:&v35];
            objc_destroyWeak((id *)v37);
            objc_destroyWeak((id *)&v44);
            objc_destroyWeak(&location);
          }
        }

        else
        {
          id v30 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v14 + 24), v15);
          int IsLevelEnabled = _NRLogIsLevelEnabled(v30, 16LL);

          if (IsLevelEnabled)
          {
            BOOL v33 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v14 + 24), v32);
            _NRLogWithArgs( v33,  16LL,  "%s%.30s:%-4d unsupported",  "",  "-[NRDiscoveryClient discoverOverBluetooth]",  1735);
          }
        }
      }
    }
  }

  else
  {
  }

void sub_100117F90( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, id location)
{
}

void sub_100117FEC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    if (!*(_BYTE *)(v1 + 21)) {
      sub_100118018(*(void *)(a1 + 32), *(void **)(a1 + 40));
    }
  }

  else
  {
    sub_100118018(0LL, *(void **)(a1 + 40));
  }

void sub_100118018(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  if (a1)
  {
    uint64_t v4 = *(void **)(a1 + 24);
    if (v4) {
      id v5 = sub_100129C28((uint64_t)&OBJC_CLASS___NRDLocalDevice, v4, 0);
    }
    else {
      id v5 = 0LL;
    }
    int v42 = 0;
    uint64_t __buf = 0LL;
    arc4random_buf(&__buf, 0xCuLL);
    id v6 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &__buf, 12LL);
    uint64_t v7 = *(void **)(a1 + 136);
    *(void *)(a1 + 136) = v6;

    id v8 = *(id *)(a1 + 200);
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 dataUsingEncoding:4]);

    if (*(_BYTE *)(a1 + 22))
    {
      uint64_t v10 = objc_claimAutoreleasedReturnValue([@"terminusdStaticSecret" dataUsingEncoding:4]);
      uint64_t v11 = *(id **)(a1 + 152);
      *(void *)(a1 + 152) = v10;
      uint64_t v12 = 8LL;
LABEL_34:

      *(void *)(a1 + 256) = v12;
      uint64_t v31 = *(void **)(a1 + 152);
      id v32 = *(id *)(a1 + 136);
      id v33 = v31;
      id v34 = sub_1001055B0(v33, v32, v9);
      __int128 v35 = *(void **)(a1 + 144);
      *(void *)(a1 + 144) = v34;

      v3[2](v3);
LABEL_35:

      goto LABEL_36;
    }

    if (v5)
    {
      if (v5[15])
      {
        int v13 = 1;
      }

      else
      {
        if (v5[14]) {
          BOOL v14 = 1;
        }
        else {
          BOOL v14 = *((unsigned __int16 *)v5 + 14) > 0x12u;
        }
        int v13 = v14;
      }

      if (v5[12])
      {
        if (!v5[13]) {
          int v13 = 0;
        }
        if (v13 == 1)
        {
          uint64_t v15 = (id *)*((id *)v5 + 9);
          id v16 = v15;
          if (v15)
          {
            id v17 = v15[3];
            uint32_t v18 = v17;
            int v19 = v17 ? (void *)*((void *)v17 + 2) : 0LL;
          }

          else
          {
            uint32_t v18 = 0LL;
            int v19 = 0LL;
          }

          id v20 = v19;
          BOOL v21 = v20 == 0LL;

          if (!v21)
          {
            uint64_t v22 = (id *)*((id *)v5 + 9);
            uint64_t v11 = v22;
            if (v22)
            {
              id v23 = v22[3];
              uint64_t v24 = v23;
              if (v23) {
                uint64_t v25 = (void *)*((void *)v23 + 2);
              }
              else {
                uint64_t v25 = 0LL;
              }
            }

            else
            {
              uint64_t v24 = 0LL;
              uint64_t v25 = 0LL;
            }

            objc_storeStrong((id *)(a1 + 152), v25);

            uint64_t v12 = 2LL;
            goto LABEL_34;
          }
        }
      }

      int v26 = (void *)*((void *)v5 + 19);
      if (v26) {
        int v26 = (void *)v26[2];
      }
      id v27 = v26;
      BOOL v28 = v27 == 0LL;

      if (!v28)
      {
        id v29 = (void *)*((void *)v5 + 19);
        if (v29) {
          id v29 = (void *)v29[2];
        }
        id v30 = v29;
        uint64_t v11 = *(id **)(a1 + 152);
        *(void *)(a1 + 152) = v30;
        uint64_t v12 = 1LL;
        goto LABEL_34;
      }
    }

    *(void *)(a1 + 256) = 4LL;
    objc_initWeak(&location, (id)a1);
    v36[0] = _NSConcreteStackBlock;
    v36[1] = 3221225472LL;
    v36[2] = sub_10011837C;
    v36[3] = &unk_1001AFF20;
    objc_copyWeak(&v39, &location);
    __int128 v38 = v3;
    id v37 = v9;
    sub_1001128E8(a1, 1LL, v36);

    objc_destroyWeak(&v39);
    objc_destroyWeak(&location);
    goto LABEL_35;
  }

void sub_100118358( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
}

void sub_10011837C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v9 = WeakRetained;
  if (WeakRetained && !WeakRetained[21])
  {
    if (v6 || ![v5 count])
    {
      uint64_t v10 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v9 + 3), v8);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 16LL);

      if (!IsLevelEnabled)
      {
LABEL_7:
        BOOL v14 = (void *)*((void *)v9 + 19);
        uint64_t v15 = *(void **)(a1 + 32);
        id v16 = *((id *)v9 + 17);
        id v17 = v14;
        id v18 = sub_1001055B0(v17, v16, v15);
        int v19 = (void *)*((void *)v9 + 18);
        *((void *)v9 + 1_Block_object_dispose(va, 8) = v18;

        (*(void (**)(void))(*(void *)(a1 + 40) + 16LL))();
        goto LABEL_8;
      }

      id v13 = (id)_NRCopyLogObjectForNRUUID(*((void *)v9 + 3), v12);
      _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d no identities fetched (%@)",  "",  "-[NRDiscoveryClient fillInPSKDataForAuthTagWithCompletion:]_block_invoke",  675LL,  v6);
    }

    else
    {
      id v20 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v9 + 3), v8);
      int v21 = _NRLogIsLevelEnabled(v20, 16LL);

      if (v21)
      {
        id v23 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v9 + 3), v22);
        _NRLogWithArgs( v23,  16,  "%s%.30s:%-4d fetched %u identities",  "",  "-[NRDiscoveryClient fillInPSKDataForAuthTagWithCompletion:]_block_invoke",  669,  [v5 count]);
      }

      __int128 v33 = 0u;
      __int128 v34 = 0u;
      __int128 v31 = 0u;
      __int128 v32 = 0u;
      id v13 = v5;
      id v24 = [v13 countByEnumeratingWithState:&v31 objects:v35 count:16];
      if (v24)
      {
        id v25 = v24;
        uint64_t v26 = *(void *)v32;
        do
        {
          for (uint64_t i = 0LL; i != v25; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v32 != v26) {
              objc_enumerationMutation(v13);
            }
            BOOL v28 = *(void **)(*((void *)&v31 + 1) + 8LL * (void)i);
            uint64_t v29 = objc_claimAutoreleasedReturnValue([v28 deviceIRKData]);
            id v30 = (void *)*((void *)v9 + 19);
            *((void *)v9 + 19) = v29;

            objc_storeStrong((id *)v9 + 24, v28);
          }

          id v25 = [v13 countByEnumeratingWithState:&v31 objects:v35 count:16];
        }

        while (v25);
      }
    }

    goto LABEL_7;
  }

void sub_1001185F4(uint64_t a1, void *a2)
{
  id v34 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v4 = WeakRetained;
  if (WeakRetained && !*((_BYTE *)WeakRetained + 21))
  {
    if (qword_1001DCB00 != -1) {
      dispatch_once(&qword_1001DCB00, &stru_1001B0308);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCAF8, 1LL))
    {
      if (qword_1001DCB00 != -1) {
        dispatch_once(&qword_1001DCB00, &stru_1001B0308);
      }
      _NRLogWithArgs( qword_1001DCAF8,  1LL,  "%s%.30s:%-4d found device %@",  "",  "-[NRDiscoveryClient discoverOverBluetooth]_block_invoke",  1756LL,  v34);
    }

    id v5 = (void *)objc_claimAutoreleasedReturnValue([v34 watchSetupData]);
    id v6 = (void *)objc_claimAutoreleasedReturnValue([v34 identifier]);
    id v7 = v5;
    id v8 = v6;
    uint64_t v10 = (void *)_NRCopyLogObjectForNRUUID(v4[3], v9);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 1LL);

    if (IsLevelEnabled)
    {
      id v13 = (void *)_NRCopyLogObjectForNRUUID(v4[3], v12);
      Logid String = (void *)_NRKeyCreateLogString(v7);
      _NRLogWithArgs( v13,  1,  "%s%.30s:%-4d received data %@ len %u",  "",  "-[NRDiscoveryClient verifyBLEAdvertisements:identifier:]",  1811,  LogString,  [v7 length]);
    }

    unsigned __int16 v41 = 0;
    id v15 = v7;
    id v17 = v15;
    if (v15)
    {
      [v15 getBytes:&v41 length:2];
      id v18 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "subdataWithRange:", 2, (char *)objc_msgSend(v17, "length") - 2));
      id v20 = (void *)_NRCopyLogObjectForNRUUID(v4[3], v19);
      int v21 = _NRLogIsLevelEnabled(v20, 1LL);

      if (v21)
      {
        id v23 = (void *)_NRCopyLogObjectForNRUUID(v4[3], v22);
        _NRLogWithArgs( v23,  1LL,  "%s%.30s:%-4d received networkrelay nonce %u",  "",  "-[NRDiscoveryClient verifyBLEAdvertisements:identifier:]",  1827,  v41);
      }

      id v24 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
      id v25 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v41, 2LL);
      -[NSMutableData appendData:](v24, "appendData:", v25);
      uint64_t v26 = (void *)v4[25];
      if (v26)
      {
        id v27 = v26;
        BOOL v28 = (void *)objc_claimAutoreleasedReturnValue([v27 dataUsingEncoding:4]);
        -[NSMutableData appendData:](v24, "appendData:", v28);
      }

      objc_initWeak(&location, v4);
      v35[0] = _NSConcreteStackBlock;
      v35[1] = 3221225472LL;
      void v35[2] = sub_100118AB4;
      v35[3] = &unk_1001AFF70;
      objc_copyWeak(&v39, &location);
      uint64_t v29 = v24;
      __int128 v36 = v29;
      id v30 = v18;
      id v37 = v30;
      id v38 = v8;
      sub_1001128E8((uint64_t)v4, 28671LL, v35);

      objc_destroyWeak(&v39);
      objc_destroyWeak(&location);
    }

    else
    {
      __int128 v31 = (void *)_NRCopyLogObjectForNRUUID(v4[3], v16);
      int v32 = _NRLogIsLevelEnabled(v31, 1LL);

      if (!v32)
      {
LABEL_21:

LABEL_22:
        goto LABEL_23;
      }

      id v30 = (id)_NRCopyLogObjectForNRUUID(v4[3], v33);
      _NRLogWithArgs( v30,  1LL,  "%s%.30s:%-4d no data",  "",  "-[NRDiscoveryClient verifyBLEAdvertisements:identifier:]",  1820);
    }

    goto LABEL_21;
  }

void sub_1001189DC(_Unwind_Exception *a1)
{
}

void sub_1001189F8(uint64_t a1, void *a2)
{
  id v11 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v5 = WeakRetained;
  if (WeakRetained) {
    id WeakRetained = (void *)WeakRetained[3];
  }
  id v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained, v4);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 1LL);

  if (IsLevelEnabled)
  {
    if (v5) {
      uint64_t v9 = v5[3];
    }
    else {
      uint64_t v9 = 0LL;
    }
    uint64_t v10 = (void *)_NRCopyLogObjectForNRUUID(v9, v8);
    _NRLogWithArgs( v10,  1LL,  "%s%.30s:%-4d started discovery with err %@",  "",  "-[NRDiscoveryClient discoverOverBluetooth]_block_invoke_2",  1761LL,  v11);
  }
}

void sub_100118AB4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  id v9 = WeakRetained;
  if (!WeakRetained || WeakRetained[21]) {
    goto LABEL_3;
  }
  if (v6 || ![v5 count])
  {
    uint64_t v10 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v9 + 3), v8);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 16LL);

    if (IsLevelEnabled)
    {
      id v13 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v9 + 3), v12);
      _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d no identities fetched (%@)",  "",  "-[NRDiscoveryClient verifyBLEAdvertisements:identifier:]_block_invoke",  1865LL,  v6);
    }

    goto LABEL_3;
  }

  BOOL v14 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v9 + 3), v8);
  int v15 = _NRLogIsLevelEnabled(v14, 1LL);

  if (v15)
  {
    id v17 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v9 + 3), v16);
    _NRLogWithArgs( v17,  1,  "%s%.30s:%-4d fetched %u identities",  "",  "-[NRDiscoveryClient verifyBLEAdvertisements:identifier:]_block_invoke",  1845,  [v5 count]);
  }

  __int128 v78 = 0u;
  __int128 v79 = 0u;
  __int128 v76 = 0u;
  __int128 v77 = 0u;
  id v18 = v5;
  id v19 = [v18 countByEnumeratingWithState:&v76 objects:v90 count:16];
  if (v19)
  {
    uint64_t v20 = *(void *)v77;
    while (2)
    {
      for (uint64_t i = 0LL; i != v19; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v77 != v20) {
          objc_enumerationMutation(v18);
        }
        uint64_t v22 = *(void **)(*((void *)&v76 + 1) + 8LL * (void)i);
        if ([v22 type] == 1)
        {
          id v19 = v22;
          goto LABEL_20;
        }
      }

      id v19 = [v18 countByEnumeratingWithState:&v76 objects:v90 count:16];
      if (v19) {
        continue;
      }
      break;
    }
  }

uint64_t sub_100119140(uint64_t result)
{
  if (*(_BYTE *)(result + 56))
  {
    uint64_t v1 = *(void *)(result + 40);
    if (!v1) {
      return result;
    }
    return (*(uint64_t (**)(uint64_t, void))(v1 + 16))(v1, *(void *)(result + 32));
  }

  uint64_t v1 = *(void *)(result + 48);
  if (v1) {
    return (*(uint64_t (**)(uint64_t, void))(v1 + 16))(v1, *(void *)(result + 32));
  }
  return result;
}

void sub_10011916C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  id v9 = WeakRetained;
  if (WeakRetained && !*((_BYTE *)WeakRetained + 21))
  {
    if (v6 || ![v5 count])
    {
      uint64_t v10 = (void *)_NRCopyLogObjectForNRUUID(v9[3], v8);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 16LL);

      if (IsLevelEnabled)
      {
        id v13 = (void *)_NRCopyLogObjectForNRUUID(v9[3], v12);
        _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d no identities fetched (%@)",  "",  "-[NRDiscoveryClient startBLEAdvertisements]_block_invoke",  1804LL,  v6);
      }
    }

    else
    {
      BOOL v14 = (void *)_NRCopyLogObjectForNRUUID(v9[3], v8);
      int v15 = _NRLogIsLevelEnabled(v14, 1LL);

      if (v15)
      {
        id v17 = (void *)_NRCopyLogObjectForNRUUID(v9[3], v16);
        _NRLogWithArgs( v17,  1,  "%s%.30s:%-4d fetched %u identities",  "",  "-[NRDiscoveryClient startBLEAdvertisements]_block_invoke",  1790,  [v5 count]);
      }

      __int128 v34 = 0u;
      __int128 v35 = 0u;
      __int128 v32 = 0u;
      __int128 v33 = 0u;
      id v18 = v5;
      id v19 = [v18 countByEnumeratingWithState:&v32 objects:v36 count:16];
      if (v19)
      {
        id v20 = v19;
        uint64_t v21 = *(void *)v33;
        do
        {
          for (uint64_t i = 0LL; i != v20; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v33 != v21) {
              objc_enumerationMutation(v18);
            }
            uint64_t v23 = objc_claimAutoreleasedReturnValue( [*(id *)(*((void *)&v32 + 1) + 8 * (void)i) authTagForData:*(void *)(a1 + 32) type:3 error:0]);
            uint64_t v24 = *(void *)(*(void *)(a1 + 48) + 8LL);
            uint64_t v25 = *(void **)(v24 + 40);
            *(void *)(v24 + 40) = v23;

            [*(id *)(a1 + 40) appendData:*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)];
          }

          id v20 = [v18 countByEnumeratingWithState:&v32 objects:v36 count:16];
        }

        while (v20);
      }

      uint64_t v26 = (void *)v9[27];
      if (v26)
      {
        [v26 setWatchSetupData:*(void *)(a1 + 40)];
        id v27 = (void *)v9[27];
        v28[0] = _NSConcreteStackBlock;
        v28[1] = 3221225472LL;
        v28[2] = sub_100119430;
        v28[3] = &unk_1001B0168;
        uint64_t v29 = v9;
        id v30 = *(id *)(a1 + 40);
        __int16 v31 = *(_WORD *)(a1 + 64);
        [v27 activateWithCompletion:v28];
      }
    }
  }
}

void sub_100119430(uint64_t a1, void *a2)
{
  id v14 = a2;
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4) {
    uint64_t v5 = *(void *)(v4 + 24);
  }
  else {
    uint64_t v5 = 0LL;
  }
  id v6 = (void *)_NRCopyLogObjectForNRUUID(v5, v3);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 1LL);

  if (IsLevelEnabled)
  {
    uint64_t v8 = *(void **)(a1 + 32);
    if (v8) {
      uint64_t v8 = (void *)v8[3];
    }
    id v9 = v8;
    id v11 = (void *)_NRCopyLogObjectForNRUUID(v9, v10);
    Logid String = (void *)_NRKeyCreateLogString(*(void *)(a1 + 40));
    id v13 = [*(id *)(a1 + 40) length];

    _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d advertising with data: %@ (len %u, nonce %u err %@)",  "",  "-[NRDiscoveryClient startBLEAdvertisements]_block_invoke_2",  1800LL,  LogString,  v13,  *(unsigned __int16 *)(a1 + 48),  v14);
  }
}

id sub_100119684()
{
  if (qword_1001DCB10 != -1) {
    dispatch_once(&qword_1001DCB10, &stru_1001B0350);
  }
  return (id)qword_1001DCB08;
}

void sub_1001196C4(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DCB08;
  qword_1001DCB08 = (uint64_t)v1;
}

void sub_100119A10(uint64_t a1, double a2, double a3, double a4)
{
  if (a1)
  {
    unint64_t v5 = *(void *)(a1 + 32);
    unint64_t v6 = *(void *)(a1 + 40);
    double v7 = 0.0;
    if (v5) {
      BOOL v8 = v6 > v5;
    }
    else {
      BOOL v8 = 0;
    }
    double v9 = 0.0;
    if (v8)
    {
      if (qword_1001DC9F0 != -1) {
        dispatch_once(&qword_1001DC9F0, &stru_1001AFB98);
      }
      LODWORD(a3) = dword_1001DC9F8;
      LODWORD(a4) = *(_DWORD *)algn_1001DC9FC;
      a4 = (double)*(unint64_t *)&a4;
      a3 = (double)*(unint64_t *)&a3 * 0.000001;
      double v9 = a3 * (double)(v6 - v5) / a4;
    }

    unint64_t v10 = *(void *)(a1 + 48);
    unint64_t v11 = *(void *)(a1 + 56);
    if (v10) {
      BOOL v12 = v11 > v10;
    }
    else {
      BOOL v12 = 0;
    }
    if (v12)
    {
      if (qword_1001DC9F0 != -1) {
        dispatch_once(&qword_1001DC9F0, &stru_1001AFB98);
      }
      LODWORD(a3) = dword_1001DC9F8;
      LODWORD(a4) = *(_DWORD *)algn_1001DC9FC;
      double v7 = (double)*(unint64_t *)&a3 * 0.000001 * (double)(v11 - v10) / (double)*(unint64_t *)&a4;
    }

    id v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithDouble:]( &OBJC_CLASS___NSNumber,  "numberWithDouble:",  round(*(double *)(a1 + 16) * 1000.0) * 0.001));
    [*(id *)(a1 + 8) setObject:v13 forKeyedSubscript:@"uptimeInSec"];

    id v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", round(v7) * 0.001));
    [*(id *)(a1 + 8) setObject:v14 forKeyedSubscript:@"ikeClassDSetupTimeInSec"];

    int v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](&OBJC_CLASS___NSNumber, "numberWithDouble:", round(v9) * 0.001));
    [*(id *)(a1 + 8) setObject:v15 forKeyedSubscript:@"ikeClassCSetupTimeInSec"];

    if (*(void *)(a1 + 72))
    {
      uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:"));
      [*(id *)(a1 + 8) setObject:v16 forKeyedSubscript:@"ikeClassDAttempts"];
    }

    if (*(void *)(a1 + 64))
    {
      id v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:"));
      [*(id *)(a1 + 8) setObject:v17 forKeyedSubscript:@"ikeClassCAttempts"];
    }

    if (*(void *)(a1 + 24))
    {
      id v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:"));
      [*(id *)(a1 + 8) setObject:v18 forKeyedSubscript:@"totalIKEControlPackets"];
    }

    if (*(void *)(a1 + 80))
    {
      id v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:"));
      [*(id *)(a1 + 8) setObject:v19 forKeyedSubscript:@"totalBytesSent"];
    }

    if (*(void *)(a1 + 88))
    {
      id v20 = (id)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:"));
      [*(id *)(a1 + 8) setObject:v20 forKeyedSubscript:@"totalBytesReceived"];
    }
  }

void sub_100119D38(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = *(id *)(a1 + 8);
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    id v5 = (id)objc_claimAutoreleasedReturnValue([v4 allValues]);
    id v6 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
    double v7 = v5;
    if (v6)
    {
      id v8 = v6;
      uint64_t v9 = *(void *)v14;
      while (2)
      {
        for (uint64_t i = 0LL; i != v8; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v14 != v9) {
            objc_enumerationMutation(v5);
          }
          if ([*(id *)(*((void *)&v13 + 1) + 8 * (void)i) BOOLValue])
          {

            if (qword_1001DCB10 != -1) {
              dispatch_once(&qword_1001DCB10, &stru_1001B0350);
            }
            if (_NRLogIsLevelEnabled(qword_1001DCB08, 0LL))
            {
              if (qword_1001DCB10 != -1) {
                dispatch_once(&qword_1001DCB10, &stru_1001B0350);
              }
              _NRLogWithArgs( qword_1001DCB08,  0LL,  "%s%.30s:%-4d AnalyticsReport - %@ : %@",  "",  "-[NRAnalytics reportEvent:]",  75LL,  v3,  v4);
            }

            v11[0] = _NSConcreteStackBlock;
            v11[1] = 3221225472LL;
            v11[2] = sub_100119F40;
            v11[3] = &unk_1001B0330;
            id v12 = v4;
            AnalyticsSendEventLazy(v3, v11);
            double v7 = v12;
            goto LABEL_18;
          }
        }

        id v8 = [v5 countByEnumeratingWithState:&v13 objects:v17 count:16];
        if (v8) {
          continue;
        }
        break;
      }

      double v7 = v5;
    }

id sub_100119F40(uint64_t a1)
{
  return *(id *)(a1 + 32);
}

void *sub_10011B994(void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    v18.receiver = a1;
    v18.super_class = (Class)&OBJC_CLASS___NRAnalyticsLinkUpgradeReport;
    id v4 = objc_msgSendSuper2(&v18, "init");
    if (!v4)
    {
      id v9 = sub_100119684();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 16LL);

      if (IsLevelEnabled)
      {
        id v11 = sub_100119684();
        _NRLogWithArgs( v11,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRAnalyticsLinkUpgradeReport initWithDictionary:]",  378);
      }

      uint64_t v12 = _os_log_pack_size(12LL);
      __int128 v13 = (char *)&v17 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      __int128 v14 = __error();
      uint64_t v15 = _os_log_pack_fill(v13, v12, *v14, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v15 = 136446210;
      *(void *)(v15 + 4) = "-[NRAnalyticsLinkUpgradeReport initWithDictionary:]";
      id v16 = sub_100119684();
      _NRLogAbortWithPack(v16, v13);
    }

    id v5 = v4;
    id v6 = -[NSMutableDictionary initWithDictionary:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithDictionary:",  v3);
    -[NSMutableDictionary addEntriesFromDictionary:](v6, "addEntriesFromDictionary:", v5[1]);
    double v7 = (void *)v5[1];
    v5[1] = v6;

    a1 = v5;
  }

  return a1;
}

void sub_10011BB18(void *a1, int a2, void *a3, void *a4)
{
  id v7 = a1;
  id v8 = a4;
  id v9 = a3;
  int v10 = _NRIsAppleInternal();
  *(void *)&__int128 buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 3221225472LL;
  id v27 = sub_10011E5F4;
  BOOL v28 = &unk_1001B0370;
  char v29 = v10;
  if (qword_1001DCB28 != -1) {
    dispatch_once(&qword_1001DCB28, &buf);
  }
  id v11 = -[__CFString length](v9, "length");
  id v12 = -[__CFString length](v8, "length");
  __int128 v13 = objc_alloc(&OBJC_CLASS___NSString);
  BOOL v14 = v11 == 0LL;
  if (v11) {
    uint64_t v15 = v9;
  }
  else {
    uint64_t v15 = &stru_1001B1528;
  }
  if (v14) {
    id v16 = "";
  }
  else {
    id v16 = " ";
  }
  if (a2 <= 3999)
  {
    if (a2 <= 2000)
    {
      switch(a2)
      {
        case 1000:
          uint64_t v17 = @"LD_Create";
          break;
        case 1001:
          uint64_t v17 = @"LD_Start";
          break;
        case 1002:
          uint64_t v17 = @"LD_Ready";
          break;
        case 1003:
          uint64_t v17 = @"LD_Cancel";
          break;
        case 1004:
          uint64_t v17 = @"LD_ReceivedLinkAvailable";
          break;
        case 1005:
          uint64_t v17 = @"LD_ReceivedLinkReady";
          break;
        case 1006:
          uint64_t v17 = @"LD_ReceivedLinkSuspended";
          break;
        case 1007:
          uint64_t v17 = @"LD_ReceivedLinkUnavailable";
          break;
        case 1008:
          uint64_t v17 = @"LD_PreferWiFiRequest";
          break;
        case 1009:
          uint64_t v17 = @"LD_RejectPreferWiFiRequest";
          break;
        case 1010:
          uint64_t v17 = @"LD_UpdateWiFiAddress";
          break;
        case 1011:
          uint64_t v17 = @"LD_ToggleWiFi";
          break;
        case 1012:
          uint64_t v17 = @"LD_PrimaryLinkChanged";
          break;
        case 1013:
          uint64_t v17 = @"LD_CancelAllLinks";
          break;
        case 1014:
          uint64_t v17 = @"LD_UnknownNRUUID";
          break;
        case 1015:
          uint64_t v17 = @"LD_SaveOrphanedDeviceMonitorConnection";
          break;
        case 1016:
          uint64_t v17 = @"LD_AdoptOrphanedDeviceMonitorConnection";
          break;
        case 1017:
          uint64_t v17 = @"LD_RemoveOrphanedDeviceMonitorConnection";
          break;
        case 1018:
          uint64_t v17 = @"LD_ReceivedIRATLinkRecommendation";
          break;
        case 1019:
          uint64_t v17 = @"LD_RecommendedLinkReceived";
          break;
        case 1020:
          uint64_t v17 = @"LD_PreferWiFiRequestAckSent";
          break;
        case 1021:
          uint64_t v17 = @"LD_PreferWiFiRequestAckReceived";
          break;
        case 1022:
          uint64_t v17 = @"LD_SaveOrphanedDevicePreferencesConnection";
          break;
        case 1023:
          uint64_t v17 = @"LD_AdoptOrphanedDevicePreferencesConnection";
          break;
        case 1024:
          uint64_t v17 = @"LD_RemoveOrphanedDevicePreferencesConnection";
          break;
        case 1025:
          uint64_t v17 = @"LD_DisableRangeExtension";
          break;
        case 1026:
          uint64_t v17 = @"LD_DisablePreferWiFi";
          break;
        case 1027:
          uint64_t v17 = @"LD_FixedInterfaceModeEnable";
          break;
        case 1028:
          uint64_t v17 = @"LD_FixedInterfaceModeDisable";
          break;
        case 1029:
          uint64_t v17 = @"LD_ForcedWoWEnable";
          break;
        case 1030:
          uint64_t v17 = @"LD_ForcedWoWDisable";
          break;
        case 1031:
          uint64_t v17 = @"LD_AvoidCompanionNotifyPosted";
          break;
        case 1032:
          uint64_t v17 = @"LD_AOVPNDetected";
          break;
        case 1033:
          uint64_t v17 = @"LD_DeviceSetupInProgress";
          break;
        case 1034:
          uint64_t v17 = @"LD_IgnorePreferWiFiRequest";
          break;
        case 1035:
          uint64_t v17 = @"LD_SendBufferLimitSet";
          break;
        case 1036:
          uint64_t v17 = @"LD_SendBufferLimitReset";
          break;
        case 1037:
          uint64_t v17 = @"LD_AOVPNConfigAdded";
          break;
        case 1038:
          uint64_t v17 = @"LD_AOVPNConfigRemoved";
          break;
        case 1039:
          uint64_t v17 = @"LD_EnableBluetoothPacketParser";
          break;
        case 1040:
          uint64_t v17 = @"LD_UpdateAWDLAddress";
          break;
        case 1041:
          uint64_t v17 = @"LD_AddEphemeralDevice";
          break;
        case 1042:
          uint64_t v17 = @"LD_RemoveEphemeralDevice";
          break;
        case 1043:
          uint64_t v17 = @"LD_ForceStartQuickRelay";
          break;
        case 1044:
        case 1045:
        case 1046:
        case 1052:
        case 1053:
        case 1054:
        case 1055:
        case 1056:
        case 1057:
        case 1058:
        case 1059:
        case 1060:
        case 1061:
        case 1062:
        case 1063:
        case 1064:
        case 1065:
        case 1066:
        case 1067:
        case 1068:
        case 1069:
        case 1070:
        case 1071:
        case 1072:
        case 1073:
        case 1074:
        case 1075:
        case 1076:
        case 1077:
        case 1078:
        case 1079:
        case 1080:
        case 1081:
        case 1082:
        case 1083:
        case 1084:
        case 1085:
        case 1086:
        case 1087:
        case 1088:
        case 1089:
        case 1090:
        case 1091:
        case 1092:
        case 1093:
        case 1094:
        case 1095:
        case 1096:
        case 1097:
        case 1098:
        case 1099:
        case 1100:
        case 1101:
        case 1102:
        case 1103:
        case 1104:
        case 1105:
        case 1106:
        case 1107:
        case 1108:
        case 1109:
        case 1110:
        case 1111:
        case 1112:
        case 1113:
        case 1114:
        case 1115:
        case 1116:
        case 1117:
        case 1118:
        case 1119:
        case 1120:
        case 1121:
        case 1122:
        case 1123:
        case 1124:
        case 1125:
        case 1126:
        case 1127:
        case 1128:
        case 1129:
        case 1130:
        case 1131:
        case 1132:
        case 1133:
        case 1134:
        case 1135:
        case 1136:
        case 1137:
        case 1138:
        case 1139:
        case 1140:
        case 1141:
        case 1142:
        case 1143:
        case 1144:
        case 1145:
        case 1146:
        case 1147:
        case 1148:
        case 1149:
        case 1150:
        case 1151:
        case 1152:
        case 1153:
        case 1154:
        case 1155:
        case 1156:
        case 1157:
        case 1158:
        case 1159:
        case 1160:
        case 1161:
        case 1162:
        case 1163:
        case 1164:
        case 1165:
        case 1166:
        case 1167:
        case 1168:
        case 1169:
        case 1170:
        case 1171:
        case 1172:
        case 1173:
        case 1174:
        case 1175:
        case 1176:
        case 1177:
        case 1178:
        case 1179:
        case 1180:
        case 1181:
        case 1182:
        case 1183:
        case 1184:
        case 1185:
        case 1186:
        case 1187:
        case 1188:
        case 1189:
        case 1190:
        case 1191:
        case 1192:
        case 1193:
        case 1194:
        case 1195:
        case 1196:
        case 1197:
        case 1198:
        case 1199:
        case 1200:
        case 1201:
        case 1202:
        case 1203:
        case 1204:
        case 1205:
        case 1206:
        case 1207:
        case 1208:
        case 1209:
        case 1210:
        case 1211:
        case 1212:
        case 1213:
        case 1214:
        case 1215:
        case 1216:
        case 1217:
        case 1218:
        case 1219:
        case 1220:
        case 1221:
        case 1222:
        case 1223:
        case 1224:
        case 1225:
        case 1226:
        case 1227:
        case 1228:
        case 1229:
        case 1230:
        case 1231:
        case 1232:
        case 1233:
        case 1234:
        case 1235:
        case 1236:
        case 1237:
        case 1238:
        case 1239:
        case 1240:
        case 1241:
        case 1242:
        case 1243:
        case 1244:
        case 1245:
        case 1246:
        case 1247:
        case 1248:
        case 1249:
        case 1250:
        case 1251:
        case 1252:
        case 1253:
        case 1254:
        case 1255:
        case 1256:
        case 1257:
        case 1258:
        case 1259:
        case 1260:
        case 1261:
        case 1262:
        case 1263:
        case 1264:
        case 1265:
        case 1266:
        case 1267:
        case 1268:
        case 1269:
        case 1270:
        case 1271:
        case 1272:
        case 1273:
        case 1274:
        case 1275:
        case 1276:
        case 1277:
        case 1278:
        case 1279:
        case 1280:
        case 1281:
        case 1282:
        case 1283:
        case 1284:
        case 1285:
        case 1286:
        case 1287:
        case 1288:
        case 1289:
        case 1290:
        case 1291:
        case 1292:
        case 1293:
        case 1294:
        case 1295:
        case 1296:
        case 1297:
        case 1298:
        case 1299:
        case 1300:
        case 1301:
        case 1302:
        case 1303:
        case 1304:
        case 1305:
        case 1306:
        case 1307:
        case 1308:
        case 1309:
        case 1310:
        case 1311:
        case 1312:
        case 1313:
        case 1314:
        case 1315:
        case 1316:
        case 1317:
        case 1318:
        case 1319:
        case 1320:
        case 1321:
        case 1322:
        case 1323:
        case 1324:
        case 1325:
        case 1326:
        case 1327:
        case 1328:
        case 1329:
        case 1330:
        case 1331:
        case 1332:
        case 1333:
        case 1334:
        case 1335:
        case 1336:
        case 1337:
        case 1338:
        case 1339:
        case 1340:
        case 1341:
        case 1342:
        case 1343:
        case 1344:
        case 1345:
        case 1346:
        case 1347:
        case 1348:
        case 1349:
        case 1350:
        case 1351:
        case 1352:
        case 1353:
        case 1354:
        case 1355:
        case 1356:
        case 1357:
        case 1358:
        case 1359:
        case 1360:
        case 1361:
        case 1362:
        case 1363:
        case 1364:
        case 1365:
        case 1366:
        case 1367:
        case 1368:
        case 1369:
        case 1370:
        case 1371:
        case 1372:
        case 1373:
        case 1374:
        case 1375:
        case 1376:
        case 1377:
        case 1378:
        case 1379:
        case 1380:
        case 1381:
        case 1382:
        case 1383:
        case 1384:
        case 1385:
        case 1386:
        case 1387:
        case 1388:
        case 1389:
        case 1390:
        case 1391:
        case 1392:
        case 1393:
        case 1394:
        case 1395:
        case 1396:
        case 1397:
        case 1398:
        case 1399:
        case 1400:
        case 1401:
        case 1402:
        case 1403:
        case 1404:
        case 1405:
        case 1406:
        case 1407:
        case 1408:
        case 1409:
        case 1410:
        case 1411:
        case 1412:
        case 1413:
        case 1414:
        case 1415:
        case 1416:
        case 1417:
        case 1418:
        case 1419:
        case 1420:
        case 1421:
        case 1422:
        case 1423:
        case 1424:
        case 1425:
        case 1426:
        case 1427:
        case 1428:
        case 1429:
        case 1430:
        case 1431:
        case 1432:
        case 1433:
        case 1434:
        case 1435:
        case 1436:
        case 1437:
        case 1438:
        case 1439:
        case 1440:
        case 1441:
        case 1442:
        case 1443:
        case 1444:
        case 1445:
        case 1446:
        case 1447:
        case 1448:
        case 1449:
        case 1450:
        case 1451:
        case 1452:
        case 1453:
        case 1454:
        case 1455:
        case 1456:
        case 1457:
        case 1458:
        case 1459:
        case 1460:
        case 1461:
        case 1462:
        case 1463:
        case 1464:
        case 1465:
        case 1466:
        case 1467:
        case 1468:
        case 1469:
        case 1470:
        case 1471:
        case 1472:
        case 1473:
        case 1474:
        case 1475:
        case 1476:
        case 1477:
        case 1478:
        case 1479:
        case 1480:
        case 1481:
        case 1482:
        case 1483:
        case 1484:
        case 1485:
        case 1486:
        case 1487:
        case 1488:
        case 1489:
        case 1490:
        case 1491:
        case 1492:
        case 1493:
        case 1494:
        case 1495:
        case 1496:
        case 1497:
        case 1498:
        case 1499:
          goto LABEL_322;
        case 1047:
          uint64_t v17 = @"LD_ManagerCreateFailed";
          break;
        case 1048:
          uint64_t v17 = @"LD_PluggedInStateChanged";
          break;
        case 1049:
          uint64_t v17 = @"LD_ThermalPressureChanged";
          break;
        case 1050:
          uint64_t v17 = @"LD_LinkUpgradeRequest";
          break;
        case 1051:
          uint64_t v17 = @"LD_UpdateCountryCode";
          break;
        case 1500:
          uint64_t v17 = @"DC_Create";
          break;
        case 1501:
          uint64_t v17 = @"DC_Start";
          break;
        case 1502:
          uint64_t v17 = @"DC_Cancel";
          break;
        default:
          if (a2) {
            goto LABEL_322;
          }
          uint64_t v17 = @"Invalid";
          break;
      }
    }

    else
    {
      switch(a2)
      {
        case 3000:
          uint64_t v17 = @"L_Create";
          break;
        case 3001:
          uint64_t v17 = @"L_Start";
          break;
        case 3002:
          uint64_t v17 = @"L_Suspend";
          break;
        case 3003:
          uint64_t v17 = @"L_Resume";
          break;
        case 3004:
          uint64_t v17 = @"L_Ready";
          break;
        case 3005:
          uint64_t v17 = @"L_Cancel";
          break;
        case 3006:
          uint64_t v17 = @"L_SendData";
          break;
        case 3007:
          uint64_t v17 = @"L_ReceiveData";
          break;
        case 3008:
          uint64_t v17 = @"L_ChangeState";
          break;
        case 3009:
          uint64_t v17 = @"L_IKEChangeState";
          break;
        case 3010:
          uint64_t v17 = @"L_ReceivedPrelude";
          break;
        case 3011:
          uint64_t v17 = @"L_InitiateIKEPairingFromIDS";
          break;
        case 3012:
          uint64_t v17 = @"L_RespondIKEPairingFromIDS";
          break;
        case 3013:
          uint64_t v17 = @"L_InitiateIKEPairingWithOOBK";
          break;
        case 3014:
          uint64_t v17 = @"L_RespondIKEPairingWithOOBK";
          break;
        case 3015:
          uint64_t v17 = @"L_InitiateIKE";
          break;
        case 3016:
          uint64_t v17 = @"L_RespondIKE";
          break;
        case 3017:
          uint64_t v17 = @"L_CreationFailed";
          break;
        case 3018:
          uint64_t v17 = @"L_IKEDisconnectionError";
          break;
        case 3019:
          uint64_t v17 = @"L_RejectingIKENoKeys";
          break;
        case 3020:
          uint64_t v17 = @"L_RejectingIKEKeysLocked";
          break;
        case 3021:
          uint64_t v17 = @"L_RejectingIKEBadAuth";
          break;
        case 3022:
          uint64_t v17 = @"L_RejectingIKENoIdentity";
          break;
        case 3023:
          uint64_t v17 = @"L_RejectingIKEBadIdentity";
          break;
        case 3024:
          uint64_t v17 = @"L_RejectingIKENoChildConfig";
          break;
        case 3025:
          uint64_t v17 = @"L_RetryInterfaceCreation";
          break;
        case 3026:
          uint64_t v17 = @"L_RetryIKESessionCreation";
          break;
        case 3027:
        case 3028:
        case 3029:
        case 3030:
        case 3031:
        case 3032:
        case 3033:
        case 3034:
        case 3035:
        case 3036:
        case 3037:
        case 3038:
        case 3039:
        case 3040:
        case 3041:
        case 3042:
        case 3043:
        case 3044:
        case 3045:
        case 3046:
        case 3047:
        case 3048:
        case 3049:
        case 3050:
        case 3051:
        case 3052:
        case 3053:
        case 3054:
        case 3055:
        case 3056:
        case 3057:
        case 3058:
        case 3059:
        case 3060:
        case 3061:
        case 3062:
        case 3063:
        case 3064:
        case 3065:
        case 3066:
        case 3067:
        case 3068:
        case 3069:
        case 3070:
        case 3071:
        case 3072:
        case 3073:
        case 3074:
        case 3075:
        case 3076:
        case 3077:
        case 3078:
        case 3079:
        case 3080:
        case 3081:
        case 3082:
        case 3083:
        case 3084:
        case 3085:
        case 3086:
        case 3087:
        case 3088:
        case 3089:
        case 3090:
        case 3091:
        case 3092:
        case 3093:
        case 3094:
        case 3095:
        case 3096:
        case 3097:
        case 3098:
        case 3099:
        case 3102:
        case 3103:
        case 3104:
        case 3105:
        case 3106:
        case 3107:
        case 3108:
        case 3109:
        case 3110:
        case 3111:
        case 3112:
        case 3113:
        case 3114:
        case 3115:
        case 3116:
        case 3117:
        case 3118:
        case 3119:
        case 3120:
        case 3121:
        case 3122:
        case 3123:
        case 3124:
        case 3125:
        case 3126:
        case 3127:
        case 3128:
        case 3129:
        case 3130:
        case 3131:
        case 3132:
        case 3133:
        case 3134:
        case 3135:
        case 3136:
        case 3137:
        case 3138:
        case 3139:
        case 3140:
        case 3141:
        case 3142:
        case 3143:
        case 3144:
        case 3145:
        case 3146:
        case 3147:
        case 3148:
        case 3149:
        case 3150:
        case 3151:
        case 3152:
        case 3153:
        case 3154:
        case 3155:
        case 3156:
        case 3157:
        case 3158:
        case 3159:
        case 3160:
        case 3161:
        case 3162:
        case 3163:
        case 3164:
        case 3165:
        case 3166:
        case 3167:
        case 3168:
        case 3169:
        case 3170:
        case 3171:
        case 3172:
        case 3173:
        case 3174:
        case 3175:
        case 3176:
        case 3177:
        case 3178:
        case 3179:
        case 3180:
        case 3181:
        case 3182:
        case 3183:
        case 3184:
        case 3185:
        case 3186:
        case 3187:
        case 3188:
        case 3189:
        case 3190:
        case 3191:
        case 3192:
        case 3193:
        case 3194:
        case 3195:
        case 3196:
        case 3197:
        case 3198:
        case 3199:
        case 3202:
        case 3203:
        case 3204:
        case 3205:
        case 3206:
        case 3207:
        case 3208:
        case 3209:
        case 3211:
        case 3212:
        case 3213:
        case 3214:
        case 3215:
        case 3216:
        case 3217:
        case 3218:
        case 3219:
        case 3220:
        case 3221:
        case 3222:
        case 3223:
        case 3224:
        case 3225:
        case 3226:
        case 3227:
        case 3228:
        case 3229:
        case 3230:
        case 3231:
        case 3232:
        case 3233:
        case 3234:
        case 3235:
        case 3236:
        case 3237:
        case 3238:
        case 3239:
        case 3240:
        case 3241:
        case 3242:
        case 3243:
        case 3244:
        case 3245:
        case 3246:
        case 3247:
        case 3248:
        case 3249:
        case 3250:
        case 3251:
        case 3252:
        case 3253:
        case 3254:
        case 3255:
        case 3256:
        case 3257:
        case 3258:
        case 3259:
        case 3260:
        case 3261:
        case 3262:
        case 3263:
        case 3264:
        case 3265:
        case 3266:
        case 3267:
        case 3268:
        case 3269:
        case 3270:
        case 3271:
        case 3272:
        case 3273:
        case 3274:
        case 3275:
        case 3276:
        case 3277:
        case 3278:
        case 3279:
        case 3280:
        case 3281:
        case 3282:
        case 3283:
        case 3284:
        case 3285:
        case 3286:
        case 3287:
        case 3288:
        case 3289:
        case 3290:
        case 3291:
        case 3292:
        case 3293:
        case 3294:
        case 3295:
        case 3296:
        case 3297:
        case 3298:
        case 3299:
          goto LABEL_322;
        case 3100:
          uint64_t v17 = @"L_BluetoothPipeDisconnected";
          break;
        case 3101:
          uint64_t v17 = @"L_BluetoothCreationFailedWithPipe";
          break;
        case 3200:
          uint64_t v17 = @"L_WiFiCreationFailed";
          break;
        case 3201:
          uint64_t v17 = @"L_AWDLCreationFailed";
          break;
        case 3210:
          uint64_t v17 = @"L_WiredCreationFailed";
          break;
        case 3300:
          uint64_t v17 = @"L_PowerAssertionEnable";
          break;
        case 3301:
          uint64_t v17 = @"L_PowerAssertionEnableFailure";
          break;
        case 3302:
          uint64_t v17 = @"L_PowerAssertionDisable";
          break;
        case 3303:
          uint64_t v17 = @"L_PowerAssertionDisableFailure";
          break;
        default:
          switch(a2)
          {
            case 2001:
              uint64_t v17 = @"LM_Start";
              break;
            case 2002:
              uint64_t v17 = @"LM_Ready";
              break;
            case 2003:
              uint64_t v17 = @"LM_Cancel";
              break;
            case 2004:
              uint64_t v17 = @"LM_LinkAvailable";
              break;
            case 2005:
              uint64_t v17 = @"LM_LinkReady";
              break;
            case 2006:
              uint64_t v17 = @"LM_LinkSuspended";
              break;
            case 2007:
              uint64_t v17 = @"LM_LinkUnavailable";
              break;
            case 2008:
              uint64_t v17 = @"LM_LinkReceivedData";
              break;
            case 2009:
              uint64_t v17 = @"LM_CancelAllLinks";
              break;
            case 2010:
              uint64_t v17 = @"LM_AlwaysOnWiFiQueryStart";
              break;
            case 2011:
              uint64_t v17 = @"LM_AlwaysOnWiFiQueryInProgress";
              break;
            case 2012:
              uint64_t v17 = @"LM_AlwaysOnWiFiQueryComplete";
              break;
            case 2013:
              uint64_t v17 = @"LM_LinkQualityUpdate";
              break;
            case 2014:
              uint64_t v17 = @"LM_AWDLSetupStart";
              break;
            case 2015:
              uint64_t v17 = @"LM_AWDLSetupFailed";
              break;
            case 2016:
              uint64_t v17 = @"LM_AWDLSetupComplete";
              break;
            default:
              switch(a2)
              {
                case 3400:
                  uint64_t v17 = @"L_UpgradeSendLocalKeys";
                  break;
                case 3401:
                  uint64_t v17 = @"L_UpgradeReceiveRemoteKeys";
                  break;
                case 3402:
                  uint64_t v17 = @"L_UpgradeSendLocalKeysEncryptedWithIDS";
                  break;
                case 3403:
                  uint64_t v17 = @"L_UpgradeReceiveRemoteKeysEncryptedWithIDS";
                  break;
                case 3500:
                  uint64_t v17 = @"BT_PeripheralManagerStateChange";
                  break;
                case 3501:
                  uint64_t v17 = @"BT_PeripheralManagerAdvertisingStart";
                  break;
                case 3502:
                  uint64_t v17 = @"BT_PeripheralManagerAdvertisingStarted";
                  break;
                case 3503:
                  uint64_t v17 = @"BT_PeripheralManagerAdvertisingStartFailed";
                  break;
                case 3504:
                  uint64_t v17 = @"BT_PeripheralManagerAdvertisingStop";
                  break;
                case 3505:
                  uint64_t v17 = @"BT_PeripheralManagerAdvertisingStopped";
                  break;
                case 3506:
                  uint64_t v17 = @"BT_PeripheralManagerAdvertisingStopFailed";
                  break;
                default:
                  goto LABEL_322;
              }

              break;
          }

          break;
      }
    }
  }

  else
  {
    if (a2 <= 10000)
    {
      if (a2 > 4899)
      {
        if (a2 > 5400)
        {
          switch(a2)
          {
            case 5500:
              uint64_t v17 = @"QueryKeys";
              break;
            case 5501:
              uint64_t v17 = @"QueriedKeys";
              break;
            case 5502:
              uint64_t v17 = @"QueryKeysFailed";
              break;
            case 5503:
              uint64_t v17 = @"EncryptLocalSuccess";
              break;
            case 5504:
              uint64_t v17 = @"EncryptLocalFailed";
              break;
            case 5505:
              uint64_t v17 = @"DecryptRemoteSuccess";
              break;
            case 5506:
              uint64_t v17 = @"DecryptRemoteFailed";
              break;
            default:
              switch(a2)
              {
                case 9000:
                  uint64_t v17 = @"DaemonStart";
                  break;
                case 9001:
                  uint64_t v17 = @"CompanionLinkChangeEnabledState";
                  break;
                case 9002:
                  uint64_t v17 = @"TestServerSetup";
                  break;
                case 9003:
                  uint64_t v17 = @"SimulatedCrash";
                  break;
                default:
                  if (a2 != 5401) {
                    goto LABEL_322;
                  }
                  uint64_t v17 = @"NotifyClientsFirstUnlockClassC";
                  break;
              }

              break;
          }
        }

        else
        {
          switch(a2)
          {
            case 4900:
              uint64_t v17 = @"BT_MiscNoBTCallbacksReceived";
              break;
            case 4901:
            case 4902:
            case 4903:
            case 4904:
            case 4905:
            case 4906:
            case 4907:
            case 4908:
            case 4909:
            case 4910:
            case 4911:
            case 4912:
            case 4913:
            case 4914:
            case 4915:
            case 4916:
            case 4917:
            case 4918:
            case 4919:
            case 4920:
            case 4921:
            case 4922:
            case 4923:
            case 4924:
            case 4925:
            case 4926:
            case 4927:
            case 4928:
            case 4929:
            case 4930:
            case 4931:
            case 4932:
            case 4933:
            case 4934:
            case 4935:
            case 4936:
            case 4937:
            case 4938:
            case 4939:
            case 4940:
            case 4941:
            case 4942:
            case 4943:
            case 4944:
            case 4945:
            case 4946:
            case 4947:
            case 4948:
            case 4949:
            case 4950:
            case 4951:
            case 4952:
            case 4953:
            case 4954:
            case 4955:
            case 4956:
            case 4957:
            case 4958:
            case 4959:
            case 4960:
            case 4961:
            case 4962:
            case 4963:
            case 4964:
            case 4965:
            case 4966:
            case 4967:
            case 4968:
            case 4969:
            case 4970:
            case 4971:
            case 4972:
            case 4973:
            case 4974:
            case 4975:
            case 4976:
            case 4977:
            case 4978:
            case 4979:
            case 4980:
            case 4981:
            case 4982:
            case 4983:
            case 4984:
            case 4985:
            case 4986:
            case 4987:
            case 4988:
            case 4989:
            case 4990:
            case 4991:
            case 4992:
            case 4993:
            case 4994:
            case 4995:
            case 4996:
            case 4997:
            case 4998:
            case 4999:
              goto LABEL_322;
            case 5000:
              uint64_t v17 = @"Device_Create";
              break;
            case 5001:
              uint64_t v17 = @"Device_Register";
              break;
            case 5002:
              uint64_t v17 = @"Device_Unregister";
              break;
            case 5003:
              uint64_t v17 = @"Device_Enable";
              break;
            case 5004:
              uint64_t v17 = @"Device_Disable";
              break;
            case 5005:
              uint64_t v17 = @"Device_GenerateLocalKeys";
              break;
            case 5006:
              uint64_t v17 = @"Device_SaveRemoteKeys";
              break;
            case 5007:
              uint64_t v17 = @"Device_Registered";
              break;
            case 5008:
              uint64_t v17 = @"Device_RegisterFailed";
              break;
            case 5009:
              uint64_t v17 = @"Device_UnknownNRUUID";
              break;
            case 5010:
              uint64_t v17 = @"Device_InvalidOperationOnUnregisteredDevice";
              break;
            case 5011:
              uint64_t v17 = @"Device_UpdateOperationalProperties";
              break;
            case 5012:
              uint64_t v17 = @"Device_MergeOperationalProperties";
              break;
            default:
              if (a2 != 5400) {
                goto LABEL_322;
              }
              uint64_t v17 = @"LockStateUpdate";
              break;
          }
        }
      }

      else
      {
        switch(a2)
        {
          case 4000:
            uint64_t v17 = @"BT_PeripheralConnect";
            break;
          case 4001:
            uint64_t v17 = @"BT_PeripheralConnected";
            break;
          case 4002:
            uint64_t v17 = @"BT_PeripheralConnectFailed";
            break;
          case 4003:
            uint64_t v17 = @"BT_PeripheralDisconnect";
            break;
          case 4004:
            uint64_t v17 = @"BT_PeripheralDisconnected";
            break;
          case 4005:
            uint64_t v17 = @"BT_PeripheralConnectSkipMissingPeripheral";
            break;
          case 4006:
            uint64_t v17 = @"BT_PeripheralConnectSkipMissingUUID";
            break;
          case 4007:
            uint64_t v17 = @"BT_PeripheralAddReference";
            break;
          case 4008:
            uint64_t v17 = @"BT_PeripheralRemoveReference";
            break;
          case 4009:
            uint64_t v17 = @"BT_PeripheralRetrieveAll";
            break;
          case 4010:
            uint64_t v17 = @"BT_PeripheralRetrievedAll";
            break;
          case 4011:
            uint64_t v17 = @"BT_PeripheralNotRetrieving";
            break;
          case 4012:
            uint64_t v17 = @"BT_PeripheralScanStart";
            break;
          case 4013:
            uint64_t v17 = @"BT_PeripheralDiscovered";
            break;
          case 4014:
            uint64_t v17 = @"BT_PeripheralScanStop";
            break;
          case 4015:
            uint64_t v17 = @"BT_PeripheralHasUnpairedBluetooth";
            break;
          case 4100:
            uint64_t v17 = @"BT_CentralManagerStateChange";
            break;
          case 4200:
            uint64_t v17 = @"BT_PipeManagerStateChange";
            break;
          case 4201:
            uint64_t v17 = @"BT_PipeRegister";
            break;
          case 4202:
            uint64_t v17 = @"BT_PipeRegistered";
            break;
          case 4203:
            uint64_t v17 = @"BT_PipeRegisteredUnknown";
            break;
          case 4204:
            uint64_t v17 = @"BT_PipeRegisterFailed";
            break;
          case 4205:
            uint64_t v17 = @"BT_PipeRegisterFailedUnknown";
            break;
          case 4206:
            uint64_t v17 = @"BT_PipeUnregister";
            break;
          case 4207:
            uint64_t v17 = @"BT_PipeUnregistered";
            break;
          case 4208:
            uint64_t v17 = @"BT_PipeUnregisteredUnknown";
            break;
          case 4209:
            uint64_t v17 = @"BT_PipeConnect";
            break;
          case 4210:
            uint64_t v17 = @"BT_PipeConnected";
            break;
          case 4211:
            uint64_t v17 = @"BT_PipeDisconnected";
            break;
          case 4212:
            uint64_t v17 = @"BT_PipeDisconnectedFail";
            break;
          case 4213:
            uint64_t v17 = @"BT_PipeCycleRegistrationCheck";
            break;
          case 4214:
            uint64_t v17 = @"BT_PipeCycleRegistrationStart";
            break;
          case 4215:
            uint64_t v17 = @"BT_PipeCycleRegistrationReenable";
            break;
          case 4216:
            uint64_t v17 = @"BT_PipeCycleRegistrationSkip";
            break;
          case 4217:
            uint64_t v17 = @"BT_PipeReceivedUrgentPrelude";
            break;
          case 4301:
            uint64_t v17 = @"BT_DatagramPipeRegister";
            break;
          case 4302:
            uint64_t v17 = @"BT_DatagramPipeRegistered";
            break;
          case 4303:
            uint64_t v17 = @"BT_DatagramPipeRegisterFailed";
            break;
          case 4304:
            uint64_t v17 = @"BT_DatagramPipeUnregister";
            break;
          case 4305:
            uint64_t v17 = @"BT_DatagramPipeUnregistered";
            break;
          case 4306:
            uint64_t v17 = @"BT_DatagramPipeConnected";
            break;
          case 4307:
            uint64_t v17 = @"BT_DatagramPipeDisconnected";
            break;
          case 4401:
            uint64_t v17 = @"BT_UrgentPipeRegister";
            break;
          case 4402:
            uint64_t v17 = @"BT_UrgentPipeRegistered";
            break;
          case 4403:
            uint64_t v17 = @"BT_UrgentPipeRegisterFailed";
            break;
          case 4404:
            uint64_t v17 = @"BT_UrgentPipeUnregister";
            break;
          case 4405:
            uint64_t v17 = @"BT_UrgentPipeUnregistered";
            break;
          case 4406:
            uint64_t v17 = @"BT_UrgentPipeConnected";
            break;
          case 4407:
            uint64_t v17 = @"BT_UrgentPipeDisconnected";
            break;
          default:
            goto LABEL_322;
        }
      }

      goto LABEL_323;
    }

    if (a2 <= 14000)
    {
      if (a2 > 11000)
      {
        if (a2 > 12000)
        {
          if (a2 <= 12002)
          {
            if (a2 == 12001) {
              uint64_t v17 = @"CompanionProxyCreated";
            }
            else {
              uint64_t v17 = @"CompanionProxyRegistered";
            }
            goto LABEL_323;
          }

          if (a2 == 12003)
          {
            uint64_t v17 = @"CompanionProxyUnregistered";
            goto LABEL_323;
          }

          if (a2 == 13001)
          {
            uint64_t v17 = @"PolicyTrafficClassUpdate";
            goto LABEL_323;
          }

          goto LABEL_322;
        }

        switch(a2)
        {
          case 11001:
            uint64_t v17 = @"BeginActivity";
            break;
          case 11002:
            uint64_t v17 = @"EndActivity";
            break;
          case 11003:
            uint64_t v17 = @"LocalEndpointUpdated";
            break;
          case 11004:
            uint64_t v17 = @"ReceivedLiveLinkAdvisory";
            break;
          case 11005:
            uint64_t v17 = @"LocalAWDLEndpointUpdated";
            break;
          default:
            goto LABEL_322;
        }
      }

      else
      {
        switch(a2)
        {
          case 10001:
            uint64_t v17 = @"IDSServiceCreated";
            break;
          case 10002:
            uint64_t v17 = @"IDSSessionCreated";
            break;
          case 10003:
            uint64_t v17 = @"IDSSessionSentInvitation";
            break;
          case 10004:
            uint64_t v17 = @"IDSSessionReceivedInvitation";
            break;
          case 10005:
            uint64_t v17 = @"IDSSessionInvitationCollided";
            break;
          case 10006:
            uint64_t v17 = @"IDSSessionAcceptInvitation";
            break;
          case 10007:
            uint64_t v17 = @"IDSSessionCancelInvitation";
            break;
          case 10008:
            uint64_t v17 = @"IDSSessionStarted";
            break;
          case 10009:
            uint64_t v17 = @"IDSSessionEnded";
            break;
          case 10010:
            uint64_t v17 = @"IKERestart";
            break;
          case 10011:
            uint64_t v17 = @"IKESessionClassDConnecting";
            break;
          case 10012:
            uint64_t v17 = @"IKESessionClassDConnected";
            break;
          case 10013:
            uint64_t v17 = @"IKECancelled";
            break;
          case 10014:
            uint64_t v17 = @"IDSSessionInvalidate";
            break;
          case 10015:
            uint64_t v17 = @"CloudLinkEnable";
            break;
          case 10016:
            uint64_t v17 = @"CloudLinkDisable";
            break;
          case 10017:
            uint64_t v17 = @"LinkIdleTimeout";
            break;
          case 10018:
            uint64_t v17 = @"RestartOnResume";
            break;
          case 10019:
            uint64_t v17 = @"ReplaceExistingSession";
            break;
          case 10020:
            uint64_t v17 = @"ConnectionStateChange";
            break;
          case 10021:
            uint64_t v17 = @"ConnectionReadError";
            break;
          case 10022:
            uint64_t v17 = @"ConnectionWriteError";
            break;
          case 10023:
            uint64_t v17 = @"DeferIKEClassD";
            break;
          case 10024:
            uint64_t v17 = @"DeferIKEClassC";
            break;
          case 10025:
            uint64_t v17 = @"DeferIDSSessionInvitation";
            break;
          case 10026:
            uint64_t v17 = @"IDSSessionDeclineInvitation";
            break;
          default:
            goto LABEL_322;
        }
      }
    }

    else
    {
      if (a2 <= 18001)
      {
        if (a2 <= 16000)
        {
          switch(a2)
          {
            case 14001:
              uint64_t v17 = @"DirectToCloudCreated";
              break;
            case 14002:
              uint64_t v17 = @"DirectToCloudRegistered";
              break;
            case 14003:
              uint64_t v17 = @"DirectToCloudUnregistered";
              break;
            case 14004:
              uint64_t v17 = @"DirectToCloudRequestAvailable";
              break;
            case 14005:
              uint64_t v17 = @"DirectToCloudRequestUnavailable";
              break;
            case 14006:
              uint64_t v17 = @"DirectToCloudLinkRecommendationQueryStart";
              break;
            case 14007:
              uint64_t v17 = @"DirectToCloudLinkRecommendationResponseReceived";
              break;
            default:
              switch(a2)
              {
                case 15001:
                  uint64_t v17 = @"PreferWiFiAgentCreated";
                  break;
                case 15002:
                  uint64_t v17 = @"PreferWiFiAgentRegistered";
                  break;
                case 15003:
                  uint64_t v17 = @"PreferWiFiAgentUnregistered";
                  break;
                case 15004:
                  uint64_t v17 = @"PreferWiFiAgentActivated";
                  break;
                default:
                  goto LABEL_322;
              }

              break;
          }

          goto LABEL_323;
        }

        if (a2 > 17000)
        {
          switch(a2)
          {
            case 17001:
              uint64_t v17 = @"QuickRelayAgentCreated";
              break;
            case 17002:
              uint64_t v17 = @"QuickRelayAgentRegistered";
              break;
            case 17003:
              uint64_t v17 = @"QuickRelayAgentUnregistered";
              break;
            case 17004:
              uint64_t v17 = @"QuickRelayAgentSuspended";
              break;
            case 17005:
              uint64_t v17 = @"QuickRelayAgentActivated";
              break;
            default:
              if (a2 != 18001) {
                goto LABEL_322;
              }
              uint64_t v17 = @"BTLinkPreferencesAgentCreated";
              break;
          }

          goto LABEL_323;
        }

        switch(a2)
        {
          case 16001:
            uint64_t v17 = @"PhoneCallRelayAgentCreated";
            goto LABEL_323;
          case 16002:
            uint64_t v17 = @"PhoneCallRelayAgentRegistered";
            goto LABEL_323;
          case 16003:
            uint64_t v17 = @"PhoneCallRelayAgentUnregistered";
            goto LABEL_323;
        }

LABEL_322:
        uint64_t v17 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown(%lld)",  a2);
        goto LABEL_323;
      }

      if (a2 <= 20002)
      {
        if (a2 <= 19000)
        {
          if (a2 == 18002)
          {
            uint64_t v17 = @"BTLinkPreferencesAgentRegistered";
            goto LABEL_323;
          }

          if (a2 == 18003)
          {
            uint64_t v17 = @"BTLinkPreferencesAgentUnregistered";
            goto LABEL_323;
          }

          goto LABEL_322;
        }

        switch(a2)
        {
          case 19001:
            uint64_t v17 = @"CmpLnkViabilityAgentCreated";
            break;
          case 19002:
            uint64_t v17 = @"CmpLnkViabilityAgentRegistered";
            break;
          case 19003:
            uint64_t v17 = @"CmpLnkViabilityAgentUnregistered";
            break;
          case 19004:
            uint64_t v17 = @"CmpLnkViabilityAgentSuspended";
            break;
          case 19005:
            uint64_t v17 = @"CmpLnkViabilityAgentActivated";
            break;
          default:
            if (a2 == 20001)
            {
              uint64_t v17 = @"CompanionProxyConfigCreated";
            }

            else
            {
              if (a2 != 20002) {
                goto LABEL_322;
              }
              uint64_t v17 = @"CompanionProxyConfigRegistered";
            }

            break;
        }
      }

      else if (a2 > 30100)
      {
        switch(a2)
        {
          case 40001:
            uint64_t v17 = @"NWActivityFragmentReporterCreate";
            break;
          case 40002:
            uint64_t v17 = @"NWActivityFragmentReporterStart";
            break;
          case 40003:
            uint64_t v17 = @"NWActivityFragmentReporterCancel";
            break;
          case 40004:
            uint64_t v17 = @"NWActivityFragmentReporterReceivedFragmentRequest";
            break;
          default:
            if (a2 != 30101) {
              goto LABEL_322;
            }
            uint64_t v17 = @"LaunchOnDemandLaunchEventReceived";
            break;
        }
      }

      else
      {
        switch(a2)
        {
          case 30001:
            uint64_t v17 = @"AutoLinkUpgradeMonitorCreate";
            break;
          case 30002:
            uint64_t v17 = @"AutoLinkUpgradeMonitorStart";
            break;
          case 30003:
            uint64_t v17 = @"AutoLinkUpgradeMonitorCancel";
            break;
          case 30004:
            uint64_t v17 = @"AutoLinkUpgradeMonitorReceivedUpdate";
            break;
          default:
            if (a2 != 20003) {
              goto LABEL_322;
            }
            uint64_t v17 = @"CompanionProxyConfigUnregistered";
            break;
        }
      }
    }
  }

LABEL_323:
  if (v12) {
    objc_super v18 = " ";
  }
  else {
    objc_super v18 = "";
  }
  if (v12) {
    id v19 = v8;
  }
  else {
    id v19 = &stru_1001B1528;
  }
  id v20 = -[NSString initWithFormat:](v13, "initWithFormat:", @"%@%s%@%s%@", v15, v16, v17, v18, v19);

  if (qword_1001DCB38 != -1) {
    dispatch_once(&qword_1001DCB38, &stru_1001B0390);
  }
  id v21 = (id)qword_1001DCB30;
  if (v7)
  {
    uint64_t v22 = _NRCopyEventLogObjectForNRUUID(v7);

    id v21 = (id)v22;
  }

  if (os_log_type_enabled((os_log_t)v21, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138543362;
    *(void *)((char *)&buf + 4) = v20;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)v21, OS_LOG_TYPE_DEFAULT, "%{public}@", (uint8_t *)&buf, 0xCu);
  }

  if (v10)
  {
    uint64_t v23 = objc_alloc(&OBJC_CLASS___NSString);
    uint64_t v24 = (void *)_NRCopyTimeString();
    uint64_t v25 = -[NSString initWithFormat:](v23, "initWithFormat:", @"\n    %@ : %@", v24, v20);

    os_unfair_lock_lock(&stru_1001DCB20);
    [(id)qword_1001DCB18 setObject:v25 atIndexedSubscript:byte_1001DCB24];
    byte_1001DCB24 = (byte_1001DCB24 + 1) & 0x7F;
    os_unfair_lock_unlock(&stru_1001DCB20);
  }
}

uint64_t sub_10011E5F4(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 32))
  {
    os_log_t v1 = -[NSMutableArray initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithCapacity:", 128LL);
    uint64_t v2 = (void *)qword_1001DCB18;
    qword_1001DCB18 = (uint64_t)v1;
  }

  return _NRLogRegisterSimCrashHook(sub_10011E668);
}

void sub_10011E638(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "events");
  uint64_t v2 = (void *)qword_1001DCB30;
  qword_1001DCB30 = (uint64_t)v1;
}

uint64_t sub_10011E668(uint64_t a1)
{
  return sub_10011BB18(0LL, 9003LL, 0LL, a1);
}

NSMutableString *sub_10011E67C(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = v1;
    uint64_t v4 = objc_opt_class(&OBJC_CLASS___NSArray);
    if ((objc_opt_isKindOfClass(v3, v4) & 1) != 0)
    {
      id v5 = @"");
      id v6 = CFSTR("(");
    }

    else
    {
      uint64_t v8 = objc_opt_class(&OBJC_CLASS___NSSet);
      if ((objc_opt_isKindOfClass(v3, v8) & 1) == 0)
      {
        id v7 = (NSMutableString *)objc_claimAutoreleasedReturnValue([v3 description]);
LABEL_21:

        goto LABEL_22;
      }

      id v5 = @"}");
      id v6 = CFSTR("({");
    }

    id v7 = -[NSMutableString initWithString:](objc_alloc(&OBJC_CLASS___NSMutableString), "initWithString:", v6);
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    __int128 v22 = 0u;
    __int128 v23 = 0u;
    id v9 = v3;
    id v10 = [v9 countByEnumeratingWithState:&v20 objects:v24 count:16];
    if (v10)
    {
      id v11 = v10;
      uint64_t v12 = *(void *)v21;
      char v13 = 1;
      do
      {
        if (*(void *)v21 != v12) {
          objc_enumerationMutation(v9);
        }
        BOOL v14 = (void *)**((void **)&v20 + 1);
        if ((v13 & 1) == 0) {
          -[NSMutableString appendString:](v7, "appendString:", @", ", (void)v20);
        }
        uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "description", (void)v20));
        -[NSMutableString appendString:](v7, "appendString:", v15);

        if ((unint64_t)v11 >= 2)
        {
          for (uint64_t i = 1LL; (id)i != v11; ++i)
          {
            if (*(void *)v21 != v12) {
              objc_enumerationMutation(v9);
            }
            uint64_t v17 = *(void **)(*((void *)&v20 + 1) + 8 * i);
            -[NSMutableString appendString:](v7, "appendString:", @", ");
            objc_super v18 = (void *)objc_claimAutoreleasedReturnValue([v17 description]);
            -[NSMutableString appendString:](v7, "appendString:", v18);
          }
        }

        id v11 = [v9 countByEnumeratingWithState:&v20 objects:v24 count:16];
        char v13 = 0;
      }

      while (v11);
    }

    -[NSMutableString appendString:](v7, "appendString:", v5);
    goto LABEL_21;
  }

  id v7 = (NSMutableString *)@"(null)";
LABEL_22:

  return v7;
}

void sub_10011E988(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
    {
      if (qword_1001DCB48 != -1) {
        dispatch_once(&qword_1001DCB48, &stru_1001B0518);
      }
      _NRLogWithArgs( qword_1001DCB40,  1LL,  "%s%.30s:%-4d %@ DTLS write error %@",  "",  "-[NRDDTLSStack processOutboundUnencryptedData:]_block_invoke",  112LL,  *(void *)(a1 + 32),  v3);
    }
  }

  else
  {
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
    {
      if (qword_1001DCB48 != -1) {
        dispatch_once(&qword_1001DCB48, &stru_1001B0518);
      }
      _NRLogWithArgs( qword_1001DCB40,  1LL,  "%s%.30s:%-4d %@ DTLS write success",  "",  "-[NRDDTLSStack processOutboundUnencryptedData:]_block_invoke",  115LL,  *(void *)(a1 + 32));
    }
  }
}

void sub_10011EAE4(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DCB40;
  qword_1001DCB40 = (uint64_t)v1;
}

void sub_10011EB14(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
    {
      if (qword_1001DCB48 != -1) {
        dispatch_once(&qword_1001DCB48, &stru_1001B0518);
      }
      _NRLogWithArgs( qword_1001DCB40,  1LL,  "%s%.30s:%-4d %@ UDP write error %@",  "",  "-[NRDDTLSStack processInboundEncryptedData:]_block_invoke",  126LL,  *(void *)(a1 + 32),  v3);
    }
  }

  else
  {
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
    {
      if (qword_1001DCB48 != -1) {
        dispatch_once(&qword_1001DCB48, &stru_1001B0518);
      }
      _NRLogWithArgs( qword_1001DCB40,  1LL,  "%s%.30s:%-4d %@ UDP write success",  "",  "-[NRDDTLSStack processInboundEncryptedData:]_block_invoke",  129LL,  *(void *)(a1 + 32));
    }
  }
}

void sub_10011EC70(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  if (a1 && !*(_BYTE *)(a1 + 11))
  {
    dispatch_time_t v6 = dispatch_time(0x8000000000000000LL, 1000000000LL);
    id v7 = *(dispatch_queue_s **)(a1 + 48);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10011ED2C;
    block[3] = &unk_1001B03E0;
    void block[4] = a1;
    int v10 = a3;
    id v9 = v5;
    dispatch_after(v6, v7, block);
  }
}

uint64_t sub_10011ED2C(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 32);
  if (!v2 || !*(_BYTE *)(v2 + 11))
  {
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
    {
      if (qword_1001DCB48 != -1) {
        dispatch_once(&qword_1001DCB48, &stru_1001B0518);
      }
      uint64_t v4 = *(void *)(v1 + 32);
      id v3 = *(void **)(v1 + 40);
      uint64_t v5 = *(unsigned int *)(v1 + 48);
      id v6 = (id)qword_1001DCB40;
      _NRLogWithArgs( v6,  1,  "%s%.30s:%-4d %@ retransmit #%u of %llu outbound encrypted bytes",  "",  "-[NRDDTLSStack retransmitOutboundEncryptedData:retransmitCount:]_block_invoke",  146,  v4,  v5,  [v3 length]);
    }

    uint64_t v7 = *(void *)(v1 + 32);
    if (v7)
    {
      id WeakRetained = objc_loadWeakRetained((id *)(v7 + 64));
      uint64_t v9 = *(void *)(v1 + 32);
    }

    else
    {
      uint64_t v9 = 0LL;
      id WeakRetained = 0LL;
    }

    [WeakRetained handleDTLSStack:v9 outboundEncryptedData:*(void *)(v1 + 40)];

    return sub_10011EC70(*(void *)(v1 + 32), *(void *)(v1 + 40), (*(_DWORD *)(v1 + 48) + 1));
  }

  return result;
}

void sub_10011EE7C(uint64_t a1)
{
  if (a1 && !*(_BYTE *)(a1 + 9))
  {
    *(_BYTE *)(a1 + 9) = 1;
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
    {
      if (qword_1001DCB48 != -1) {
        dispatch_once(&qword_1001DCB48, &stru_1001B0518);
      }
      uint64_t v2 = *(void *)(a1 + 40);
      id v3 = (id)qword_1001DCB40;
      _NRLogWithArgs( v3,  1LL,  "%s%.30s:%-4d %@ reading on UDP %@",  "",  "-[NRDDTLSStack readOnUDPConnection]",  158LL,  a1,  v2);
    }

    uint64_t v4 = *(nw_connection **)(a1 + 40);
    completion[0] = _NSConcreteStackBlock;
    completion[1] = 3221225472LL;
    completion[2] = sub_10011EFA4;
    completion[3] = &unk_1001B0408;
    completion[4] = a1;
    nw_connection_receive(v4, 1u, 0xFFFFFFFF, completion);
  }

void sub_10011EFA4(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v19 = a2;
  id v8 = a3;
  id v9 = a5;
  uint64_t v10 = *(void *)(a1 + 32);
  if (v10) {
    *(_BYTE *)(v10 + 9) = 0;
  }
  if (v19 && !v9)
  {
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
    {
      if (qword_1001DCB48 != -1) {
        dispatch_once(&qword_1001DCB48, &stru_1001B0518);
      }
      id v11 = (id)qword_1001DCB40;
      uint64_t v12 = *(void *)(a1 + 32);
      id v13 = [v19 length];
      uint64_t v14 = *(void *)(a1 + 32);
      if (v14) {
        uint64_t v14 = *(void *)(v14 + 40);
      }
      _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d %@ passing %llu outbound encrypted bytes to client from UDP %@",  "",  "-[NRDDTLSStack readOnUDPConnection]_block_invoke",  168LL,  v12,  v13,  v14);
    }

    uint64_t v15 = *(void *)(a1 + 32);
    if (v15)
    {
      id WeakRetained = objc_loadWeakRetained((id *)(v15 + 64));
      uint64_t v17 = *(void *)(a1 + 32);
    }

    else
    {
      uint64_t v17 = 0LL;
      id WeakRetained = 0LL;
    }

    [WeakRetained handleDTLSStack:v17 outboundEncryptedData:v19];

    uint64_t v18 = *(void *)(a1 + 32);
    if (v18)
    {
      if (*(_BYTE *)(v18 + 12))
      {
LABEL_19:
        sub_10011EE7C(v18);
        goto LABEL_26;
      }

      *(_BYTE *)(v18 + 12) = 1;
      uint64_t v18 = *(void *)(a1 + 32);
    }

    sub_10011EC70(v18, v19, 1);
    uint64_t v18 = *(void *)(a1 + 32);
    goto LABEL_19;
  }

  if (qword_1001DCB48 != -1) {
    dispatch_once(&qword_1001DCB48, &stru_1001B0518);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
  {
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    _NRLogWithArgs( qword_1001DCB40,  1LL,  "%s%.30s:%-4d %@ UDP read sadness %@",  "",  "-[NRDDTLSStack readOnUDPConnection]_block_invoke",  164LL,  *(void *)(a1 + 32),  v9);
  }

void sub_10011F1D0(uint64_t a1)
{
  if (a1 && !*(_BYTE *)(a1 + 10))
  {
    *(_BYTE *)(a1 + 10) = 1;
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
    {
      if (qword_1001DCB48 != -1) {
        dispatch_once(&qword_1001DCB48, &stru_1001B0518);
      }
      uint64_t v2 = *(void *)(a1 + 32);
      id v3 = (id)qword_1001DCB40;
      _NRLogWithArgs( v3,  1LL,  "%s%.30s:%-4d %@ reading on DTLS %@",  "",  "-[NRDDTLSStack readOnDTLSConnection]",  184LL,  a1,  v2);
    }

    uint64_t v4 = *(nw_connection **)(a1 + 32);
    completion[0] = _NSConcreteStackBlock;
    completion[1] = 3221225472LL;
    completion[2] = sub_10011F2F8;
    completion[3] = &unk_1001B0408;
    completion[4] = a1;
    nw_connection_receive(v4, 1u, 0xFFFFFFFF, completion);
  }

void sub_10011F2F8(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v18 = a2;
  id v8 = a3;
  id v9 = a5;
  uint64_t v10 = *(void *)(a1 + 32);
  if (v10) {
    *(_BYTE *)(v10 + 10) = 0;
  }
  if (!v18 || v9)
  {
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
    {
      if (qword_1001DCB48 != -1) {
        dispatch_once(&qword_1001DCB48, &stru_1001B0518);
      }
      _NRLogWithArgs( qword_1001DCB40,  1LL,  "%s%.30s:%-4d %@ DTLS read sadness %@",  "",  "-[NRDDTLSStack readOnDTLSConnection]_block_invoke",  190LL,  *(void *)(a1 + 32),  v9);
    }
  }

  else
  {
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
    {
      if (qword_1001DCB48 != -1) {
        dispatch_once(&qword_1001DCB48, &stru_1001B0518);
      }
      id v11 = (id)qword_1001DCB40;
      uint64_t v12 = *(void *)(a1 + 32);
      id v13 = [v18 length];
      uint64_t v14 = *(void *)(a1 + 32);
      if (v14) {
        uint64_t v14 = *(void *)(v14 + 32);
      }
      _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d %@ passing %llu inbound decrypted bytes to client from DTLS %@",  "",  "-[NRDDTLSStack readOnDTLSConnection]_block_invoke",  194LL,  v12,  v13,  v14);
    }

    uint64_t v15 = *(void *)(a1 + 32);
    if (v15)
    {
      id WeakRetained = objc_loadWeakRetained((id *)(v15 + 64));
      uint64_t v17 = *(void *)(a1 + 32);
    }

    else
    {
      uint64_t v17 = 0LL;
      id WeakRetained = 0LL;
    }

    [WeakRetained handleDTLSStack:v17 inboundDecryptedData:v18];

    sub_10011F1D0(*(void *)(a1 + 32));
  }
}

void sub_10011F4FC(uint64_t a1)
{
  if (a1)
  {
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
    {
      if (qword_1001DCB48 != -1) {
        dispatch_once(&qword_1001DCB48, &stru_1001B0518);
      }
      _NRLogWithArgs(qword_1001DCB40, 1LL, "%s%.30s:%-4d %@ is ready", "", "-[NRDDTLSStack handleIsReady]", 202LL, a1);
    }

    sub_10011F1D0(a1);
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
    [WeakRetained handleIsReady:a1];
  }

void sub_10011F5E0(uint64_t a1, void *a2)
{
  options = a2;
  sec_protocol_options_set_tls_server_name(options, "::1");
  sec_protocol_options_set_peer_authentication_required(options, 0);
  sec_protocol_options_append_tls_ciphersuite(options, tls_ciphersuite_RSA_WITH_AES_128_CBC_SHA|0x80);
  sec_protocol_options_append_tls_ciphersuite(options, (tls_ciphersuite_t)0xAEu);
  sec_protocol_options_append_tls_ciphersuite(options, (tls_ciphersuite_t)0x8Du);
  sec_protocol_options_append_tls_ciphersuite(options, (tls_ciphersuite_t)0x8Cu);
  sec_protocol_options_add_pre_shared_key(options, *(dispatch_data_t *)(a1 + 32), *(dispatch_data_t *)(a1 + 32));
}

void sub_10011F668(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5) {
    id v6 = *(dispatch_queue_s **)(v5 + 48);
  }
  else {
    id v6 = 0LL;
  }
  nw_connection_set_queue(v3, v6);
  if (qword_1001DCB48 != -1) {
    dispatch_once(&qword_1001DCB48, &stru_1001B0518);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
  {
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    _NRLogWithArgs( qword_1001DCB40,  1LL,  "%s%.30s:%-4d %@ DTLS Server got new connection %@",  "",  "-[NRDDTLSStack startDTLS]_block_invoke_2",  244LL,  *(void *)(a1 + 32),  v4);
  }

  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_10011FB18;
  handler[3] = &unk_1001B0458;
  void handler[4] = *(void *)(a1 + 32);
  id v9 = v4;
  uint64_t v7 = v4;
  nw_connection_set_state_changed_handler(v7, handler);
  nw_connection_start(v7);
}

void sub_10011F7A8(uint64_t a1, void *a2)
{
  id v3 = a2;
  sec_protocol_options_set_peer_authentication_required(v3, 0);
  verify_block[0] = _NSConcreteStackBlock;
  verify_block[1] = 3221225472LL;
  verify_block[2] = sub_10011FA14;
  verify_block[3] = &unk_1001B04A8;
  uint64_t v4 = *(void *)(a1 + 32);
  verify_void block[4] = v4;
  if (v4) {
    uint64_t v5 = *(dispatch_queue_s **)(v4 + 48);
  }
  else {
    uint64_t v5 = 0LL;
  }
  sec_protocol_options_set_verify_block(v3, verify_block, v5);
  sec_protocol_options_append_tls_ciphersuite(v3, tls_ciphersuite_RSA_WITH_AES_128_CBC_SHA|0x80);
  sec_protocol_options_append_tls_ciphersuite(v3, (tls_ciphersuite_t)0xAEu);
  sec_protocol_options_append_tls_ciphersuite(v3, (tls_ciphersuite_t)0x8Du);
  sec_protocol_options_append_tls_ciphersuite(v3, (tls_ciphersuite_t)0x8Cu);
  sec_protocol_options_add_pre_shared_key(v3, *(dispatch_data_t *)(a1 + 40), *(dispatch_data_t *)(a1 + 40));
}

void sub_10011F870(uint64_t a1, uint64_t a2, void *a3)
{
  id v8 = a3;
  if (qword_1001DCB48 != -1) {
    dispatch_once(&qword_1001DCB48, &stru_1001B0518);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
  {
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    uint64_t v5 = *(void *)(a1 + 32);
    id v6 = (id)qword_1001DCB40;
    uint64_t v7 = nw_connection_state_to_string(a2);
    _NRLogWithArgs( v6,  1LL,  "%s%.30s:%-4d %@ client DTLS connection got state %s error %@",  "",  "-[NRDDTLSStack startDTLS]_block_invoke_6",  309LL,  v5,  v7,  v8);
  }

  if ((_DWORD)a2 == 3)
  {
    sub_10011F4FC(*(void *)(a1 + 32));
  }

  else if ((a2 & 0xFFFFFFFE) == 4)
  {
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
    {
      if (qword_1001DCB48 != -1) {
        dispatch_once(&qword_1001DCB48, &stru_1001B0518);
      }
      _NRLogWithArgs( qword_1001DCB40,  1LL,  "%s%.30s:%-4d %@ client DTLS Sadness",  "",  "-[NRDDTLSStack startDTLS]_block_invoke_6",  313LL,  *(void *)(a1 + 32));
    }
  }
}

void sub_10011FA14(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v9 = a2;
  id v7 = a3;
  id v8 = a4;
  if (qword_1001DCB48 != -1) {
    dispatch_once(&qword_1001DCB48, &stru_1001B0518);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
  {
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    _NRLogWithArgs( qword_1001DCB40,  1LL,  "%s%.30s:%-4d %@ client verify block called",  "",  "-[NRDDTLSStack startDTLS]_block_invoke_5",  278LL,  *(void *)(a1 + 32));
  }

  v8[2](v8, 1LL);
}

void sub_10011FB18(uint64_t a1, uint64_t a2, void *a3)
{
  id v18 = a3;
  if (qword_1001DCB48 != -1) {
    dispatch_once(&qword_1001DCB48, &stru_1001B0518);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
  {
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 40);
    id v7 = (id)qword_1001DCB40;
    uint64_t v8 = nw_connection_state_to_string(a2);
    _NRLogWithArgs( v7,  1LL,  "%s%.30s:%-4d %@ server connection %@ got state %s error %@",  "",  "-[NRDDTLSStack startDTLS]_block_invoke_3",  249LL,  v5,  v6,  v8,  v18);
  }

  if ((_DWORD)a2 == 3)
  {
    uint64_t v9 = *(void *)(a1 + 32);
    if (!v9) {
      goto LABEL_31;
    }
    if (!*(void *)(v9 + 32)) {
      goto LABEL_22;
    }
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCB40, 17LL))
    {
      if (qword_1001DCB48 != -1) {
        dispatch_once(&qword_1001DCB48, &stru_1001B0518);
      }
      uint64_t v10 = *(void *)(a1 + 32);
      if (v10) {
        uint64_t v11 = *(void *)(v10 + 32);
      }
      else {
        uint64_t v11 = 0LL;
      }
      uint64_t v12 = *(void *)(a1 + 40);
      id v13 = (id)qword_1001DCB40;
      _NRLogWithArgs(v13, 17LL, "Got new connection %@ on DTLS listener when we already had %@", v11, v12);
    }

    uint64_t v14 = *(void *)(a1 + 32);
    uint64_t v15 = v14 ? *(nw_connection **)(v14 + 32) : 0LL;
    nw_connection_cancel(v15);
    uint64_t v16 = *(void *)(a1 + 32);
    if (v16
      && (v17 = *(void **)(v16 + 32), *(void *)(v16 + 32) = 0LL, v17, (uint64_t v9 = *(void *)(a1 + 32)) != 0))
    {
LABEL_22:
      objc_storeStrong((id *)(v9 + 32), *(id *)(a1 + 40));
      sub_10011F4FC(*(void *)(a1 + 32));
    }

    else
    {
LABEL_31:
      sub_10011F4FC(0LL);
    }
  }

  else if ((a2 & 0xFFFFFFFE) == 4)
  {
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
    {
      if (qword_1001DCB48 != -1) {
        dispatch_once(&qword_1001DCB48, &stru_1001B0518);
      }
      _NRLogWithArgs( qword_1001DCB40,  1LL,  "%s%.30s:%-4d %@ DTLS server Sadness",  "",  "-[NRDDTLSStack startDTLS]_block_invoke_3",  260LL,  *(void *)(a1 + 32));
    }
  }
}

id *sub_10011FDB8(id *a1, void *a2, char a3, void *a4)
{
  id v8 = a2;
  uint64_t v9 = a4;
  if (!a1) {
    goto LABEL_18;
  }
  v38.receiver = a1;
  v38.super_class = (Class)&OBJC_CLASS___NRDDTLSStack;
  uint64_t v10 = (id *)objc_msgSendSuper2(&v38, "init");
  if (!v10)
  {
    id v23 = sub_1001201D4();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v23, 16LL);

    if (IsLevelEnabled)
    {
      id v25 = sub_1001201D4();
      _NRLogWithArgs( v25,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDDTLSStack initDTLSWithQueue:server:delegate:]",  325);
    }

    id v8 = (id)_os_log_pack_size(12LL);
    uint64_t v9 = (char *)handler - ((__chkstk_darwin(v8) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v26 = __error();
    uint64_t v27 = _os_log_pack_fill(v9, v8, *v26, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)uint64_t v27 = 136446210;
    *(void *)(v27 + 4) = "-[NRDDTLSStack initDTLSWithQueue:server:delegate:]";
    id v28 = sub_1001201D4();
    _NRLogAbortWithPack(v28, v9);
LABEL_16:
    id v29 = sub_1001201D4();
    int v30 = _NRLogIsLevelEnabled(v29, 17LL);

    if (v30)
    {
      id v31 = sub_1001201D4();
      _NRLogWithArgs(v31, 17LL, "%s called with null queue", "-[NRDDTLSStack initDTLSWithQueue:server:delegate:]");

      __int128 v21 = 0LL;
      goto LABEL_12;
    }

id sub_1001201D4()
{
  if (qword_1001DCB48 != -1) {
    dispatch_once(&qword_1001DCB48, &stru_1001B0518);
  }
  return (id)qword_1001DCB40;
}

uint64_t sub_100120214()
{
  while (1)
  {
    while (1)
    {
      __int16 v0 = word_1001DCB50;
      unsigned int v1 = (unsigned __int16)word_1001DCB50++ + 1;
      if ((unsigned __int16)(v0 + 2) <= 0xC001u)
      {
        uint32_t v2 = arc4random_uniform(0x3FFFu);
        unsigned int v1 = v2 - 0x4000;
        word_1001DCB50 = v2 - 0x4000;
      }

      *(_WORD *)&v7[10] = 0;
      *(void *)&v7[12] = 0LL;
      uint64_t v8 = 0LL;
      *(_WORD *)id v7 = 7708;
      *(void *)&id v7[2] = bswap32(v1) >> 16;
      int v3 = socket(30, 2, 0);
      if ((v3 & 0x80000000) == 0) {
        break;
      }
      int v5 = *__error();
      if (strerror_r(v5, __strerrbuf, 0x80uLL)) {
        __strerrbuf[0] = 0;
      }
      if (qword_1001DCB48 != -1) {
        dispatch_once(&qword_1001DCB48, &stru_1001B0518);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCB40, 17LL))
      {
        if (qword_1001DCB48 != -1) {
          dispatch_once(&qword_1001DCB48, &stru_1001B0518);
        }
        _NRLogWithArgs(qword_1001DCB40, 17LL, "socket open failed: [%d] %s", v5, __strerrbuf);
      }
    }

    int v4 = v3;
    if (!bind(v3, (const sockaddr *)v7, 0x1Cu)) {
      break;
    }
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
    {
      if (qword_1001DCB48 != -1) {
        dispatch_once(&qword_1001DCB48, &stru_1001B0518);
      }
      _NRLogWithArgs( qword_1001DCB40,  1LL,  "%s%.30s:%-4d socket bind failed for %u (sockFD %d)",  "",  "NRDIsUDPPortAvailable",  57,  (unsigned __int16)v1,  v4);
    }

    close(v4);
  }

  close(v4);
  return (unsigned __int16)word_1001DCB50;
}

void sub_100120448(uint64_t a1, uint64_t a2, void *a3)
{
  id v30 = a3;
  if (qword_1001DCB48 != -1) {
    dispatch_once(&qword_1001DCB48, &stru_1001B0518);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
  {
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    uint64_t v5 = *(void *)(a1 + 32);
    id v6 = (id)qword_1001DCB40;
    uint64_t v7 = nw_connection_state_to_string(a2);
    _NRLogWithArgs( v6,  1LL,  "%s%.30s:%-4d %@ UDP connection got state %s error %@",  "",  "-[NRDDTLSStack initDTLSWithQueue:server:delegate:]_block_invoke",  354LL,  v5,  v7,  v30);
  }

  if ((_DWORD)a2 == 3)
  {
    sub_10011EE7C(*(void *)(a1 + 32));
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
      if (qword_1001DCB48 != -1) {
        dispatch_once(&qword_1001DCB48, &stru_1001B0518);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
      {
        if (qword_1001DCB48 != -1) {
          dispatch_once(&qword_1001DCB48, &stru_1001B0518);
        }
        _NRLogWithArgs( qword_1001DCB40,  1LL,  "%s%.30s:%-4d %@ starting DTLS",  "",  "-[NRDDTLSStack startDTLS]",  209LL,  v8);
      }

      *(void *)&__int128 v9 = -1LL;
      *((void *)&v9 + 1) = -1LL;
      buffer[0] = v9;
      buffer[1] = v9;
      dispatch_data_t v10 = dispatch_data_create(buffer, 0x20uLL, 0LL, 0LL);
      __int16 v45 = 0;
      *(_DWORD *)__str = 0;
      snprintf(__str, 6uLL, "%u", *(unsigned __int16 *)(v8 + 14));
      __int16 v43 = 0;
      *(_DWORD *)unsigned int port = 0;
      snprintf(port, 6uLL, "%u", *(unsigned __int16 *)(v8 + 16));
      nw_endpoint_t host = nw_endpoint_create_host("::", __str);
      if (*(_BYTE *)(v8 + 8))
      {
        configure_dtls = _NSConcreteStackBlock;
        uint64_t v32 = 3221225472LL;
        __int128 v33 = sub_10011F5E0;
        __int128 v34 = &unk_1001B0430;
        __int16 v35 = v10;
        uint64_t v12 = nw_parameters_create_secure_udp(&configure_dtls, _nw_parameters_configure_protocol_default_configuration);
        nw_parameters_set_local_address(v12, host);
        nw_listener_t v13 = nw_listener_create(v12);
        uint64_t v14 = *(void **)(v8 + 24);
        *(void *)(v8 + 24) = v13;

        nw_connection_t v15 = *(dispatch_queue_s **)(v8 + 48);
        id v16 = (nw_listener *)*(id *)(v8 + 24);
        nw_listener_set_queue(v16, v15);

        uint64_t v17 = *(nw_listener **)(v8 + 24);
        handler = _NSConcreteStackBlock;
        uint64_t v38 = 3221225472LL;
        id v39 = sub_10011F668;
        id v40 = &unk_1001B0480;
        uint64_t v41 = v8;
        nw_listener_set_new_connection_handler(v17, &handler);
        nw_listener_start(*(nw_listener_t *)(v8 + 24));
        if (qword_1001DCB48 != -1) {
          dispatch_once(&qword_1001DCB48, &stru_1001B0518);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
        {
          if (qword_1001DCB48 != -1) {
            dispatch_once(&qword_1001DCB48, &stru_1001B0518);
          }
          uint64_t v18 = *(void *)(v8 + 24);
          id v19 = (id)qword_1001DCB40;
          _NRLogWithArgs( v19,  1LL,  "%s%.30s:%-4d %@ started DTLS listener %@",  "",  "-[NRDDTLSStack startDTLS]",  266LL,  v8,  v18);
        }

        __int128 v20 = v35;
      }

      else
      {
        configure_dtls = _NSConcreteStackBlock;
        uint64_t v32 = 3221225472LL;
        __int128 v33 = sub_10011F7A8;
        __int128 v34 = &unk_1001B04D0;
        __int16 v35 = (dispatch_data_s *)v8;
        __int128 v36 = v10;
        __int128 v21 = nw_parameters_create_secure_udp(&configure_dtls, _nw_parameters_configure_protocol_default_configuration);
        nw_parameters_set_local_address(v21, host);
        __int128 v22 = nw_endpoint_create_host("localhost", port);
        nw_connection_t v23 = nw_connection_create(v22, v21);
        uint64_t v24 = *(void **)(v8 + 32);
        *(void *)(v8 + 32) = v23;

        id v25 = *(nw_connection **)(v8 + 32);
        handler = _NSConcreteStackBlock;
        uint64_t v38 = 3221225472LL;
        id v39 = sub_10011F870;
        id v40 = &unk_1001B04F8;
        uint64_t v41 = v8;
        nw_connection_set_state_changed_handler(v25, &handler);
        uint64_t v26 = *(dispatch_queue_s **)(v8 + 48);
        uint64_t v27 = (nw_connection *)*(id *)(v8 + 32);
        nw_connection_set_queue(v27, v26);

        nw_connection_start(*(nw_connection_t *)(v8 + 32));
        if (qword_1001DCB48 != -1) {
          dispatch_once(&qword_1001DCB48, &stru_1001B0518);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
        {
          if (qword_1001DCB48 != -1) {
            dispatch_once(&qword_1001DCB48, &stru_1001B0518);
          }
          uint64_t v28 = *(void *)(v8 + 32);
          id v29 = (id)qword_1001DCB40;
          _NRLogWithArgs( v29,  1LL,  "%s%.30s:%-4d %@ started DTLS connection %@",  "",  "-[NRDDTLSStack startDTLS]",  319LL,  v8,  v28);
        }

        __int128 v20 = v36;
      }
    }
  }

  else if ((a2 & 0xFFFFFFFE) == 4)
  {
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
    {
      if (qword_1001DCB48 != -1) {
        dispatch_once(&qword_1001DCB48, &stru_1001B0518);
      }
      _NRLogWithArgs( qword_1001DCB40,  1LL,  "%s%.30s:%-4d %@ UDP Sadness",  "",  "-[NRDDTLSStack initDTLSWithQueue:server:delegate:]_block_invoke",  359LL,  *(void *)(a1 + 32));
    }
  }
}

id sub_100120A64(uint64_t a1)
{
  if (qword_1001DCB60 != -1) {
    dispatch_once(&qword_1001DCB60, &stru_1001B0538);
  }
  return (id)qword_1001DCB58;
}

void sub_100120AA8(id a1)
{
  id v1 = sub_100120AD4(objc_alloc(&OBJC_CLASS___NRDPolicySessionManager));
  uint32_t v2 = (void *)qword_1001DCB58;
  qword_1001DCB58 = (uint64_t)v1;
}

id sub_100120AD4(void *a1)
{
  if (!a1) {
    return 0LL;
  }
  v30.receiver = a1;
  v30.super_class = (Class)&OBJC_CLASS___NRDPolicySessionManager;
  id v1 = objc_msgSendSuper2(&v30, "init");
  if (!v1)
  {
    id v10 = sub_100120DD4();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 16LL);

    if (IsLevelEnabled)
    {
      id v12 = sub_100120DD4();
      _NRLogWithArgs( v12,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDPolicySessionManager initManager]",  37);
    }

    uint64_t v13 = _os_log_pack_size(12LL);
    uint64_t v14 = (char *)&v29 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v15 = *__error();
    uint64_t v16 = _os_log_pack_fill(v14, v13, v15, &_mh_execute_header, "%{public}s [super init] failed");
    goto LABEL_16;
  }

  id v2 = v1;
  int v3 = sub_100146AFC();
  int v4 = (void *)*((void *)v2 + 1);
  *((void *)v2 + 1) = v3;

  uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NEPolicySession);
  id v6 = (void *)*((void *)v2 + 2);
  *((void *)v2 + 2) = v5;

  [*((id *)v2 + 2) setPriority:101];
  if ([*((id *)v2 + 2) priority] != (id)101)
  {
    id v17 = sub_100120DD4();
    int v18 = _NRLogIsLevelEnabled(v17, 16LL);

    if (v18)
    {
      id v19 = sub_100120DD4();
      _NRLogWithArgs( v19,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: self.policySession.priority == NEPolicySessionPriorityControl1",  "",  "-[NRDPolicySessionManager initManager]",  41);
    }

    uint64_t v20 = _os_log_pack_size(12LL);
    uint64_t v14 = (char *)&v29 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    __int128 v21 = __error();
    uint64_t v22 = _os_log_pack_fill( v14,  v20,  *v21,  &_mh_execute_header,  "%{public}s Assertion Failed: self.policySession.priority == NEPolicySessionPriorityControl1");
    *(_DWORD *)uint64_t v22 = 136446210;
    *(void *)(v22 + 4) = "-[NRDPolicySessionManager initManager]";
    goto LABEL_17;
  }

  if (([*((id *)v2 + 2) lockSessionToCurrentProcess] & 1) == 0)
  {
    id v23 = sub_100120DD4();
    int v24 = _NRLogIsLevelEnabled(v23, 16LL);

    if (v24)
    {
      id v25 = sub_100120DD4();
      _NRLogWithArgs( v25,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: [self.policySession lockSessionToCurrentProcess]",  "",  "-[NRDPolicySessionManager initManager]",  42);
    }

    uint64_t v26 = _os_log_pack_size(12LL);
    uint64_t v14 = (char *)&v29 - ((v26 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v27 = *__error();
    uint64_t v16 = _os_log_pack_fill( v14,  v26,  v27,  &_mh_execute_header,  "%{public}s Assertion Failed: [self.policySession lockSessionToCurrentProcess]");
LABEL_16:
    *(_DWORD *)uint64_t v16 = 136446210;
    *(void *)(v16 + 4) = "-[NRDPolicySessionManager initManager]";
LABEL_17:
    id v28 = sub_100120DD4();
    _NRLogAbortWithPack(v28, v14);
    return 0LL;
  }

  uint64_t v7 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  uint64_t v8 = (void *)*((void *)v2 + 3);
  *((void *)v2 + 3) = v7;

  return v2;
}

id sub_100120DD4()
{
  if (qword_1001DCB70 != -1) {
    dispatch_once(&qword_1001DCB70, &stru_1001B0558);
  }
  return (id)qword_1001DCB68;
}

void sub_100120E14(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  id v2 = (void *)qword_1001DCB68;
  qword_1001DCB68 = (uint64_t)v1;
}

id sub_100120E44(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 8));
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 24) objectForKeyedSubscript:v5]);
    if (v7) {
      uint64_t v8 = -[NSMutableArray initWithArray:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithArray:", v7);
    }
    else {
      uint64_t v8 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    }
    __int128 v9 = v8;
    id v13 = [*(id *)(a1 + 16) addPolicy:v6];
    if (!v13) {
      sub_1001030D0( @"NRPolicySessionManager",  @"AddPolicy",  @"InvalidPolicyNumber",  1,  @"Failed to install policy: %@",  v10,  v11,  v12,  (uint64_t)v6);
    }
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInteger:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInteger:", v13));
    -[NSMutableArray addObject:](v9, "addObject:", v14);
    [*(id *)(a1 + 24) setObject:v9 forKeyedSubscript:v5];
  }

  else
  {
    uint64_t v14 = 0LL;
  }

  return v14;
}

void sub_100120F60(uint64_t a1, void *a2, void *a3)
{
  id v22 = a2;
  id v5 = a3;
  if (!a1) {
    goto LABEL_10;
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 8));
  id v6 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 24) objectForKeyedSubscript:v22]);
  uint64_t v7 = v6;
  if (!v6 || ![v6 containsObject:v5])
  {
LABEL_9:

LABEL_10:
    return;
  }

  uint64_t v8 = -[NSMutableArray initWithArray:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithArray:", v7);
  id v9 = *(id *)(a1 + 16);
  unsigned __int8 v10 = objc_msgSend(v9, "removePolicyWithID:", objc_msgSend(v5, "unsignedIntegerValue"));

  if ((v10 & 1) != 0)
  {
    -[NSMutableArray removeObject:](v8, "removeObject:", v5);
    if (-[NSMutableArray count](v8, "count")) {
      uint64_t v11 = v8;
    }
    else {
      uint64_t v11 = 0LL;
    }
    objc_msgSend(*(id *)(a1 + 24), "setObject:forKeyedSubscript:", v11, v22, v22);

    goto LABEL_9;
  }

  id v12 = sub_100120DD4();
  int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 16LL);

  if (IsLevelEnabled)
  {
    id v14 = sub_100120DD4();
    _NRLogWithArgs( v14,  16LL,  "%s%.30s:%-4d ABORTING: Failed to remove policy identifier: %@",  "",  "-[NRDPolicySessionManager removePolicyIDForIdentifier:policyID:]",  101LL,  v5);
  }

  uint64_t v15 = _os_log_pack_size(22LL);
  uint64_t v16 = (char *)&v22 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  id v17 = __error();
  uint64_t v18 = _os_log_pack_fill( v16,  v15,  *v17,  &_mh_execute_header,  "%{public}s Failed to remove policy identifier: %@");
  *(_DWORD *)uint64_t v18 = 136446466;
  *(void *)(v18 + 4) = "-[NRDPolicySessionManager removePolicyIDForIdentifier:policyID:]";
  *(_WORD *)(v18 + 12) = 2112;
  *(void *)(v18 + 14) = v5;
  id v19 = sub_100120DD4();
  uint64_t v20 = _NRLogAbortWithPack(v19, v16);
  sub_10012114C(v20, v21);
}

void sub_10012114C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 8));
    int v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 24) objectForKeyedSubscript:v3]);
    if (v4)
    {
      id v16 = v4;
      id v17 = v3;
      __int128 v20 = 0u;
      __int128 v21 = 0u;
      __int128 v18 = 0u;
      __int128 v19 = 0u;
      id v5 = v4;
      id v6 = [v5 countByEnumeratingWithState:&v18 objects:v22 count:16];
      if (v6)
      {
        id v7 = v6;
        uint64_t v8 = *(void *)v19;
        do
        {
          id v9 = 0LL;
          do
          {
            if (*(void *)v19 != v8) {
              objc_enumerationMutation(v5);
            }
            unsigned __int8 v10 = *(void **)(*((void *)&v18 + 1) + 8LL * (void)v9);
            id v11 = *(id *)(a1 + 16);
            unsigned __int8 v12 = objc_msgSend(v11, "removePolicyWithID:", objc_msgSend(v10, "unsignedIntegerValue"));

            if ((v12 & 1) == 0) {
              sub_1001030D0( @"NRPolicySessionManager",  @"RemovePolicy Failed",  0LL,  1,  @"Failed to remove policy identifier: %@",  v13,  v14,  v15,  (uint64_t)v10);
            }
            id v9 = (char *)v9 + 1;
          }

          while (v7 != v9);
          id v7 = [v5 countByEnumeratingWithState:&v18 objects:v22 count:16];
        }

        while (v7);
      }

      id v3 = v17;
      [*(id *)(a1 + 24) setObject:0 forKeyedSubscript:v17];
      int v4 = v16;
    }
  }
}

void sub_1001212F4( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 8));
    if (([*(id *)(a1 + 16) apply] & 1) == 0) {
      sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v10,  v11,  v12,  a9);
    }
  }

id sub_100121F34()
{
  if (qword_1001DCBD8 != -1) {
    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
  }
  return (id)qword_1001DCBD0;
}

void sub_100121F74(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  id v2 = (void *)qword_1001DCBD0;
  qword_1001DCBD0 = (uint64_t)v1;
}

char *sub_100123CC0(char *a1, void *a2)
{
  id v3 = a2;
  int v4 = v3;
  if (!a1) {
    goto LABEL_11;
  }
  if (!v3)
  {
    id v10 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 17LL);

    if (IsLevelEnabled)
    {
      id v12 = sub_100121F34();
      _NRLogWithArgs( v12,  17LL,  "%s called with null nrUUID",  "-[NRDLocalDevice initWithoutObservingChangesWithNRUUID:]");

      uint64_t v8 = 0LL;
      goto LABEL_5;
    }

void *sub_100123EA4(void *a1, void *a2)
{
  int v4 = a2;
  id v5 = v4;
  if (!a1) {
    goto LABEL_37;
  }
  if (!v4)
  {
    id v28 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v28, 17LL);

    if (!IsLevelEnabled) {
      goto LABEL_37;
    }
    id v16 = sub_100121F34();
    _NRLogWithArgs(v16, 17LL, "%s called with null legacyKeys", "-[NRDLDDataClassKeychainItems initWithLegacyKeys:]");
    goto LABEL_36;
  }

  v46.receiver = a1;
  v46.super_class = (Class)&OBJC_CLASS___NRDLDDataClassKeychainItems;
  id v6 = objc_msgSendSuper2(&v46, "init");
  if (v6)
  {
    a1 = v6;
    id v2 = (objc_class *)&OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
    if (v5[1])
    {
      id v7 = objc_alloc(&OBJC_CLASS___NRDLDKeychainItemSecKey);
      id v8 = v5[1];
      id v9 = sub_1001248D8((char *)v7, v8);
      id v10 = (void *)a1[1];
      a1[1] = v9;

      if (!a1[1]) {
        goto LABEL_37;
      }
    }

    if (!v5[3]) {
      goto LABEL_12;
    }
    uint64_t v11 = objc_alloc(&OBJC_CLASS___NRDLDKeychainItemSecKey);
    id v12 = v5[3];
    id v13 = sub_100124B98((char *)v11, v12);
    int v14 = (void *)a1[2];
    a1[2] = v13;

    id v15 = (void *)a1[2];
    if (!v15) {
      goto LABEL_37;
    }
    if (v5[2])
    {
      id v16 = sub_100124E58(v15);
      if (v16)
      {
        if ([v5[2] isEqualToData:v16])
        {
LABEL_11:

          goto LABEL_12;
        }

        id v38 = sub_100121F34();
        int v39 = _NRLogIsLevelEnabled(v38, 17LL);

        if (v39)
        {
          id v40 = sub_100121F34();
          _NRLogWithArgs(v40, 17LL, "Migrated public key != legacy public key!");
LABEL_35:
        }
      }

char *sub_1001242A0(char *a1, void *a2)
{
  id v4 = a2;
  id v5 = v4;
  if (!a1) {
    goto LABEL_11;
  }
  if (!v4)
  {
    id v10 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 17LL);

    if (IsLevelEnabled)
    {
      id v12 = sub_100121F34();
      _NRLogWithArgs(v12, 17LL, "%s called with null secretData", "-[NRDLDKeychainItemData initWithData:]");

      id v8 = 0LL;
      goto LABEL_5;
    }

void sub_100124478(_BYTE *a1)
{
  if (a1)
  {
    if (a1[22])
    {
      if (qword_1001DCBD8 != -1) {
        dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCBD0, 2LL))
      {
        if (qword_1001DCBD8 != -1) {
          dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        }
        _NRLogWithArgs( qword_1001DCBD0,  2LL,  "%s%.30s:%-4d startObservingChanges called with an observer already registered: %@",  "",  "-[NRDLocalDevice startObservingChanges]",  1659LL,  a1);
      }
    }

    else
    {
      __int128 v10 = 0u;
      __int128 v11 = 0u;
      __int128 v8 = 0u;
      __int128 v9 = 0u;
      uint64_t v2 = objc_opt_class(a1);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_10012468C;
      block[3] = &unk_1001B0578;
      void block[4] = objc_opt_self(v2);
      if (qword_1001DCBB8 != -1) {
        dispatch_once(&qword_1001DCBB8, block);
      }
      id v3 = (id)qword_1001DCBB0;
      id v4 = [v3 countByEnumeratingWithState:&v8 objects:v13 count:16];
      if (v4)
      {
        id v5 = v4;
        uint64_t v6 = *(void *)v9;
        do
        {
          for (uint64_t i = 0LL; i != v5; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v9 != v6) {
              objc_enumerationMutation(v3);
            }
            [a1 addObserver:a1 forKeyPath:*(void *)(*((void *)&v8 + 1) + 8 * (void)i) options:3 context:0];
          }

          id v5 = [v3 countByEnumeratingWithState:&v8 objects:v13 count:16];
        }

        while (v5);
      }

      a1[22] = 1;
    }
  }

void sub_10012468C(uint64_t a1)
{
  uint64_t v2 = -[NSSet initWithObjects:]( objc_alloc(&OBJC_CLASS___NSSet),  "initWithObjects:",  @"classDKeychainItems",  @"classCKeychainItems",  @"classAKeychainItemsLegacyOnly",  @"outOfBandKeychainItem",  @"outOfBandKey",  @"hasOutOfBandKey",  @"isChanged",  @"isObservingChanges",  @"observedProperties",  @"isEphemeral",  @"isEnabledAndHasCompletedPairing",  @"hasCompletedPairing",  @"supportsSecureCoding",  @"requiresAuthenticationWithIdentity",  @"isCompanionLink",  @"isCompanionLinkCheckedOnce",  0LL);
  unsigned int outCount = 0;
  id v3 = class_copyPropertyList(*(Class *)(a1 + 32), &outCount);
  id v4 = objc_alloc(&OBJC_CLASS___NSMutableArray);
  id v5 = -[NSMutableArray initWithCapacity:](v4, "initWithCapacity:", outCount);
  if (outCount)
  {
    for (unint64_t i = 0LL; i < outCount; ++i)
    {
      id v7 = -[NSString initWithCString:encoding:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithCString:encoding:",  property_getName(v3[i]),  4LL);
      if (!-[NSSet containsObject:](v2, "containsObject:", v7)) {
        -[NSMutableArray addObject:](v5, "addObject:", v7);
      }
    }
  }

  else if (!v3)
  {
    goto LABEL_8;
  }

  free(v3);
LABEL_8:
  __int128 v8 = -[NSArray initWithArray:](objc_alloc(&OBJC_CLASS___NSArray), "initWithArray:", v5);
  __int128 v9 = (void *)qword_1001DCBB0;
  qword_1001DCBB0 = (uint64_t)v8;

  if (qword_1001DCBD8 != -1) {
    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCBD0, 2LL))
  {
    if (qword_1001DCBD8 != -1) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    _NRLogWithArgs( qword_1001DCBD0,  2LL,  "%s%.30s:%-4d NRDLocalDevice observed proprties: %@",  "",  "+[NRDLocalDevice observedProperties]_block_invoke",  892LL,  qword_1001DCBB0);
  }
}

char *sub_1001248D8(char *a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (!a1) {
    goto LABEL_20;
  }
  if (!v3)
  {
    id v12 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 17LL);

    if (IsLevelEnabled)
    {
      id v14 = sub_100121F34();
      _NRLogWithArgs( v14,  17LL,  "%s called with null publicKeyData",  "-[NRDLDKeychainItemSecKey initWithPublicSigningKeyData:]");

      __int128 v10 = 0LL;
      goto LABEL_9;
    }

char *sub_100124B98(char *a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (!a1) {
    goto LABEL_20;
  }
  if (!v3)
  {
    id v12 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 17LL);

    if (IsLevelEnabled)
    {
      id v14 = sub_100121F34();
      _NRLogWithArgs( v14,  17LL,  "%s called with null privateKeyData",  "-[NRDLDKeychainItemSecKey initWithPrivateSigningKeyData:]");

      __int128 v10 = 0LL;
      goto LABEL_9;
    }

void *sub_100124E58(void *result)
{
  if (result)
  {
    CFTypeRef cf = 0LL;
    int v1 = SecKeyCopyPublicBytes(result[2], &cf);
    uint64_t result = cf;
    if (!cf || v1 != 0)
    {
      id v3 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 17LL);

      if (IsLevelEnabled)
      {
        id v5 = sub_100121F34();
        _NRLogWithArgs(v5, 17LL, "Failed to copy public key octets: %d", v1);
      }

      uint64_t result = cf;
      if (cf)
      {
        CFRelease(cf);
        return 0LL;
      }
    }
  }

  return result;
}

char *sub_100124F00(char *a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (!a1) {
    goto LABEL_20;
  }
  if (!v3)
  {
    id v12 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 17LL);

    if (IsLevelEnabled)
    {
      id v14 = sub_100121F34();
      _NRLogWithArgs( v14,  17LL,  "%s called with null privateKeyData",  "-[NRDLDKeychainItemSecKey initWithPrivateDHKeyData:]");

      __int128 v10 = 0LL;
      goto LABEL_9;
    }

void sub_1001251C0(_BYTE *a1)
{
  if (a1)
  {
    if (a1[22])
    {
      __int128 v10 = 0u;
      __int128 v11 = 0u;
      __int128 v8 = 0u;
      __int128 v9 = 0u;
      uint64_t v2 = objc_opt_class(a1);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_10012468C;
      block[3] = &unk_1001B0578;
      void block[4] = objc_opt_self(v2);
      if (qword_1001DCBB8 != -1) {
        dispatch_once(&qword_1001DCBB8, block);
      }
      id v3 = (id)qword_1001DCBB0;
      id v4 = [v3 countByEnumeratingWithState:&v8 objects:v13 count:16];
      if (v4)
      {
        id v5 = v4;
        uint64_t v6 = *(void *)v9;
        do
        {
          for (unint64_t i = 0LL; i != v5; unint64_t i = (char *)i + 1)
          {
            if (*(void *)v9 != v6) {
              objc_enumerationMutation(v3);
            }
            [a1 removeObserver:a1 forKeyPath:*(void *)(*((void *)&v8 + 1) + 8 * (void)i)];
          }

          id v5 = [v3 countByEnumeratingWithState:&v8 objects:v13 count:16];
        }

        while (v5);
      }

      a1[22] = 0;
    }

    else
    {
      if (qword_1001DCBD8 != -1) {
        dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCBD0, 2LL))
      {
        if (qword_1001DCBD8 != -1) {
          dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        }
        _NRLogWithArgs( qword_1001DCBD0,  2LL,  "%s%.30s:%-4d stopObservingChanges called with no observer registered: %@",  "",  "-[NRDLocalDevice stopObservingChanges]",  1676LL,  a1);
      }
    }
  }

id sub_1001253C8(id result)
{
  if (result)
  {
    v10.receiver = result;
    v10.super_class = (Class)&OBJC_CLASS___NRDLocalDevice;
    uint64_t result = objc_msgSendSuper2(&v10, "init");
    if (!result)
    {
      id v1 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v1, 16LL);

      if (IsLevelEnabled)
      {
        id v3 = sub_100121F34();
        _NRLogWithArgs( v3,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDLocalDevice initWithoutObservingChanges]",  1575);
      }

      uint64_t v4 = _os_log_pack_size(12LL);
      id v5 = (char *)&v9 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v6 = __error();
      uint64_t v7 = _os_log_pack_fill(v5, v4, *v6, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v7 = 136446210;
      *(void *)(v7 + 4) = "-[NRDLocalDevice initWithoutObservingChanges]";
      id v8 = sub_100121F34();
      _NRLogAbortWithPack(v8, v5);
    }
  }

  return result;
}

id *sub_100125504(id *a1, void *a2, void *a3, uint64_t a4)
{
  id v7 = a2;
  id v8 = a3;
  if (!a1) {
    goto LABEL_16;
  }
  if (!v7)
  {
    id v15 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v15, 17LL);

    if (IsLevelEnabled)
    {
      id v17 = sub_100121F34();
      _NRLogWithArgs( v17,  17LL,  "%s called with null itemName",  "-[NRDLDKeychainItemData initFromKeychainWithName:nrUUID:dataProtectionClass:]");

      id v13 = 0LL;
      goto LABEL_9;
    }

uint64_t sub_100125768(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v7 = a2;
  id v8 = a3;
  if (a1)
  {
    if (v7)
    {
      if (!*(_BYTE *)(a1 + 8))
      {
LABEL_8:
        a1 = 1LL;
        goto LABEL_12;
      }

      objc_opt_self(&OBJC_CLASS___NRDKeyManager);
      if (qword_1001DCC18 != -1) {
        dispatch_once(&qword_1001DCC18, &stru_1001B0910);
      }
      id v9 = (id)qword_1001DCC10;
      BOOL v10 = sub_100145390((uint64_t)v9, *(void **)(a1 + 16), v7, v8, a4, 0LL);

      if (v10)
      {
        *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = 0;
        goto LABEL_8;
      }
    }

    else
    {
      id v11 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 17LL);

      if (IsLevelEnabled)
      {
        id v13 = sub_100121F34();
        _NRLogWithArgs( v13,  17LL,  "%s called with null itemName",  "-[NRDLDKeychainItemData saveToKeychainWithName:nrUUID:dataProtectionClass:]");
      }
    }

    a1 = 0LL;
  }

_BYTE *sub_100125894(void *a1, void *a2)
{
  if (!a1)
  {
LABEL_8:
    uint64_t v6 = 0LL;
    goto LABEL_4;
  }

  v17.receiver = a1;
  v17.super_class = (Class)&OBJC_CLASS___NRDLDKeychainItemSecKey;
  id v3 = objc_msgSendSuper2(&v17, "init");
  if (!v3)
  {
    id v8 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 16LL);

    if (IsLevelEnabled)
    {
      id v10 = sub_100121F34();
      _NRLogWithArgs( v10,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDLDKeychainItemSecKey initWithKeyRef:]",  226);
    }

    uint64_t v11 = _os_log_pack_size(12LL);
    id v12 = (char *)&v16 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v13 = __error();
    uint64_t v14 = _os_log_pack_fill(v12, v11, *v13, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)uint64_t v14 = 136446210;
    *(void *)(v14 + 4) = "-[NRDLDKeychainItemSecKey initWithKeyRef:]";
    id v15 = sub_100121F34();
    _NRLogAbortWithPack(v15, v12);
    goto LABEL_8;
  }

  id v5 = v3;
  objc_setProperty_nonatomic(v3, v4, a2, 16LL);
  v5[8] = 1;
  uint64_t v6 = v5;
LABEL_4:

  return v6;
}

void *sub_100125A00(char *a1, void *a2, void *a3, uint64_t a4)
{
  id v7 = a2;
  id v8 = a3;
  if (!a1) {
    goto LABEL_73;
  }
  if (!v7)
  {
    id v28 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v28, 17LL);

    if (IsLevelEnabled)
    {
      id v30 = sub_100121F34();
      _NRLogWithArgs( v30,  17LL,  "%s called with null itemName",  "-[NRDLDKeychainItemSecKey initFromKeychainWithName:nrUUID:dataProtectionClass:]");

      id v21 = 0LL;
      goto LABEL_66;
    }

uint64_t sub_100126220(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v7 = a2;
  id v8 = a3;
  if (a1)
  {
    if (!v7)
    {
      id v29 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v29, 17LL);

      if (IsLevelEnabled)
      {
        id v31 = sub_100121F34();
        _NRLogWithArgs( v31,  17LL,  "%s called with null itemName",  "-[NRDLDKeychainItemSecKey saveToKeychainWithName:nrUUID:dataProtectionClass:]");
      }

      goto LABEL_78;
    }

    if (!*(_BYTE *)(a1 + 8))
    {
LABEL_75:
      a1 = 1LL;
      goto LABEL_79;
    }

    objc_opt_self(&OBJC_CLASS___NRDKeyManager);
    if (qword_1001DCC18 != -1) {
      dispatch_once(&qword_1001DCC18, &stru_1001B0910);
    }
    id v9 = (dispatch_queue_t *)(id)qword_1001DCC10;
    uint64_t v10 = *(void *)(a1 + 16);
    id v11 = v7;
    id v12 = v8;
    id v13 = v12;
    if (!v9)
    {

      goto LABEL_78;
    }

    dispatch_assert_queue_V2(v9[2]);
    if ((_DWORD)a4 == 3)
    {
      uint64_t v37 = v10;
      CFStringRef v14 = &kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly;
    }

    else
    {
      if ((_DWORD)a4 != 4)
      {
        id String = (void *)NRDataProtectionClassCreateString(a4);
        goto LABEL_15;
      }

      uint64_t v37 = v10;
      CFStringRef v14 = (const CFStringRef *)&kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate;
    }

    CFStringRef v15 = *v14;
    id String = (void *)NRDataProtectionClassCreateString(a4);
    if (v15)
    {
      objc_super v17 = objc_alloc(&OBJC_CLASS___NSString);
      if (v13) {
        id v18 = -[NSString initWithFormat:]( v17,  "initWithFormat:",  @"%@/%@/%@/%@",  @"com.apple.terminusd",  v13,  String,  v11);
      }
      else {
        id v18 = -[NSString initWithFormat:]( v17,  "initWithFormat:",  @"%@/%@",  @"com.apple.terminusd",  v11,  v33,  v34);
      }
      uint64_t v22 = v18;
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
      {
        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        _NRLogWithArgs( qword_1001DCC20,  0LL,  "%s%.30s:%-4d Adding %@ keychain key %@",  "",  "-[NRDKeyManager saveKey:toKeychainWithName:nrUUID:dataProtectionClass:]",  464LL,  String,  v22);
      }

      CFTypeID v40 = v22;
      v44[0] = kSecClass;
      v44[1] = kSecAttrApplicationTag;
      CFStringRef v45 = kSecClassKey;
      uint64_t v46 = objc_claimAutoreleasedReturnValue(-[NSString dataUsingEncoding:](v22, "dataUsingEncoding:", 4LL));
      id v39 = (void *)v46;
      v44[2] = kSecAttrAccessGroup;
      id v47 = @"com.apple.terminusd";
      int v38 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v45,  v44,  3LL));
      uint64_t v23 = SecItemDelete(v38);
      if ((_DWORD)v23 == -25308)
      {
        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        id v28 = v38;
        if (_NRLogIsLevelEnabled(qword_1001DCC20, 16LL))
        {
          if (qword_1001DCC28 != -1) {
            dispatch_once(&qword_1001DCC28, &stru_1001B0980);
          }
          _NRLogWithArgs( qword_1001DCC20,  16LL,  "%s%.30s:%-4d Failed to delete existing %@ keychain key %@: keychain locked",  "",  "-[NRDKeyManager saveKey:toKeychainWithName:nrUUID:dataProtectionClass:]",  482LL,  String,  v22);
        }
      }

      else
      {
        uint64_t v24 = v23;
        if ((_DWORD)v23 == -25300)
        {
LABEL_38:
          v42[0] = kSecClass;
          v42[1] = kSecAttrApplicationTag;
          v43[0] = kSecClassKey;
          v43[1] = v39;
          void v42[2] = kSecAttrAccessGroup;
          v42[3] = kSecAttrAccessible;
          v43[2] = @"com.apple.terminusd";
          v43[3] = v15;
          v42[4] = kSecValueRef;
          v43[4] = v37;
          CFTypeID v25 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v43,  v42,  5LL));
          uint64_t v26 = SecItemAdd(v25, 0LL);
          uint64_t v27 = v26;
          if ((_DWORD)v26)
          {
            if ((_DWORD)v26 == -25308)
            {
              if (qword_1001DCC28 != -1) {
                dispatch_once(&qword_1001DCC28, &stru_1001B0980);
              }
              if (_NRLogIsLevelEnabled(qword_1001DCC20, 16LL))
              {
                if (qword_1001DCC28 != -1) {
                  dispatch_once(&qword_1001DCC28, &stru_1001B0980);
                }
                _NRLogWithArgs( qword_1001DCC20,  16LL,  "%s%.30s:%-4d Failed to add %@ keychain key %@: keychain locked",  "",  "-[NRDKeyManager saveKey:toKeychainWithName:nrUUID:dataProtectionClass:]",  507LL,  String,  v40);
              }
            }

            else
            {
              if (qword_1001DCC28 != -1) {
                dispatch_once(&qword_1001DCC28, &stru_1001B0980);
              }
              if (_NRLogIsLevelEnabled(qword_1001DCC20, 17LL))
              {
                if (qword_1001DCC28 != -1) {
                  dispatch_once(&qword_1001DCC28, &stru_1001B0980);
                }
                _NRLogWithArgs( qword_1001DCC20,  17LL,  "Failed to add %@ keychain key %@: %d",  String,  v40,  v27,  v35,  v36);
              }
            }
          }

          else
          {
            if (qword_1001DCC28 != -1) {
              dispatch_once(&qword_1001DCC28, &stru_1001B0980);
            }
            if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
            {
              if (qword_1001DCC28 != -1) {
                dispatch_once(&qword_1001DCC28, &stru_1001B0980);
              }
              _NRLogWithArgs( qword_1001DCC20,  0LL,  "%s%.30s:%-4d Successfully added %@ keychain key %@",  "",  "-[NRDKeyManager saveKey:toKeychainWithName:nrUUID:dataProtectionClass:]",  503LL,  String,  v40);
            }
          }

          BOOL v41 = (_DWORD)v27 == 0;

          id v28 = v38;
          goto LABEL_72;
        }

        if (!(_DWORD)v23)
        {
          if (qword_1001DCC28 != -1) {
            dispatch_once(&qword_1001DCC28, &stru_1001B0980);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
          {
            if (qword_1001DCC28 != -1) {
              dispatch_once(&qword_1001DCC28, &stru_1001B0980);
            }
            _NRLogWithArgs( qword_1001DCC20,  0LL,  "%s%.30s:%-4d Successfully deleted existing %@ keychain key %@",  "",  "-[NRDKeyManager saveKey:toKeychainWithName:nrUUID:dataProtectionClass:]",  479LL,  String,  v40);
          }

          goto LABEL_38;
        }

        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        id v28 = v38;
        if (_NRLogIsLevelEnabled(qword_1001DCC20, 17LL))
        {
          if (qword_1001DCC28 != -1) {
            dispatch_once(&qword_1001DCC28, &stru_1001B0980);
          }
          _NRLogWithArgs( qword_1001DCC20,  17LL,  "Failed to delete existing %@ keychain key %@: %d",  String,  v40,  v24,  v35,  v36);
        }
      }

      BOOL v41 = 0;
LABEL_72:

      goto LABEL_73;
    }

char *sub_100126A7C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (!a1) {
    goto LABEL_19;
  }
  if (!v3)
  {
    id v11 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 17LL);

    if (IsLevelEnabled)
    {
      id v13 = sub_100121F34();
      _NRLogWithArgs(v13, 17LL, "%s called with null publicKeyData");
LABEL_18:

      id v9 = 0LL;
      goto LABEL_13;
    }

void *sub_100126D3C(void *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  SecKeyRef v6 = v5;
  if (!a1) {
    goto LABEL_8;
  }
  if (!v5)
  {
    id v22 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v22, 17LL);

    if (IsLevelEnabled)
    {
      id v24 = sub_100121F34();
      _NRLogWithArgs( v24,  17LL,  "%s called with null nrUUID",  "-[NRDLDDataClassKeychainItems initFromKeychainWithNRUUID:dataProtectionClass:]");
    }

    goto LABEL_8;
  }

  v35.receiver = a1;
  v35.super_class = (Class)&OBJC_CLASS___NRDLDDataClassKeychainItems;
  id v7 = objc_msgSendSuper2(&v35, "init");
  if (!v7)
  {
    id v26 = sub_100121F34();
    int v27 = _NRLogIsLevelEnabled(v26, 16LL);

    if (v27)
    {
      id v28 = sub_100121F34();
      _NRLogWithArgs( v28,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDLDDataClassKeychainItems initFromKeychainWithNRUUID:dataProtectionClass:]",  454);
    }

    uint64_t v29 = _os_log_pack_size(12LL);
    id v30 = (char *)&v34 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v31 = __error();
    uint64_t v32 = _os_log_pack_fill(v30, v29, *v31, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)uint64_t v32 = 136446210;
    *(void *)(v32 + 4) = "-[NRDLDDataClassKeychainItems initFromKeychainWithNRUUID:dataProtectionClass:]";
    id v33 = sub_100121F34();
    _NRLogAbortWithPack(v33, v30);
  }

  a1 = v7;
  CFDataRef v8 = sub_100125A00((char *)objc_alloc(&OBJC_CLASS___NRDLDKeychainItemSecKey), @"RemotePublicKey", v6, a3);
  id v9 = (void *)a1[1];
  a1[1] = v8;

  uint64_t v10 = a1[1];
  id v11 = sub_100125A00((char *)objc_alloc(&OBJC_CLASS___NRDLDKeychainItemSecKey), @"LocalPrivateKey", v6, a3);
  id v12 = (void *)a1[2];
  a1[2] = v11;

  uint64_t v13 = a1[2];
  id v14 = sub_100125A00((char *)objc_alloc(&OBJC_CLASS___NRDLDKeychainItemSecKey), @"DHPrivateKey", v6, a3);
  int v15 = (void *)a1[4];
  a1[4] = v14;

  uint64_t v16 = a1[4];
  int v17 = sub_100125504((id *)objc_alloc(&OBJC_CLASS___NRDLDKeychainItemData), @"SharedSecret", v6, a3);
  id v18 = (void *)a1[3];
  a1[3] = v17;

  v19.i64[0] = a1[3];
  v19.i64[1] = v16;
  v20.i64[0] = v10;
  v20.i64[1] = v13;
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32( (int32x4_t)vceqzq_s64(v20),  (int32x4_t)vceqzq_s64(v19))))) & 1) == 0)
  {
LABEL_8:
    id v21 = 0LL;
    goto LABEL_9;
  }

  a1 = a1;
  id v21 = a1;
LABEL_9:

  return v21;
}

void *sub_100126FE0(void *a1, uint64_t a2)
{
  if (!a1) {
    return 0LL;
  }
  v42.receiver = a1;
  v42.super_class = (Class)&OBJC_CLASS___NRDLDDataClassKeychainItems;
  id v3 = objc_msgSendSuper2(&v42, "init");
  if (v3)
  {
    uint64_t v4 = v3;
    CFErrorRef error = 0LL;
    if ((_DWORD)a2 == 4)
    {
      id v5 = (CFTypeRef *)&kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate;
    }

    else
    {
      if ((_DWORD)a2 != 3) {
        goto LABEL_14;
      }
      id v5 = (CFTypeRef *)&kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly;
    }

    if (*v5)
    {
      SecAccessControlRef v6 = SecAccessControlCreateWithFlags(kCFAllocatorDefault, *v5, 0x40000000uLL, &error);
      if (v6)
      {
        SecAccessControlRef v7 = v6;
        CFTypeID v40 = v4;
        if (error)
        {
          CFRelease(error);
          CFErrorRef error = 0LL;
        }

        v49[0] = kSecAttrKeyType;
        v49[1] = kSecAttrTokenID;
        uint64_t v8 = kSecAttrTokenIDAppleKeyStore;
        v50[0] = kSecAttrKeyTypeEd25519;
        v50[1] = kSecAttrTokenIDAppleKeyStore;
        v49[2] = kSecPrivateKeyAttrs;
        v47[0] = kSecAttrIsPermanent;
        v47[1] = kSecAttrAccessControl;
        v48[0] = &__kCFBooleanFalse;
        v48[1] = v7;
        id v9 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v48,  v47,  2LL,  v40));
        v50[2] = v9;
        uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v50,  v49,  3LL));

        v45[0] = kSecAttrKeyType;
        v45[1] = kSecAttrTokenID;
        v46[0] = kSecAttrKeyTypeX25519;
        v46[1] = v8;
        v45[2] = kSecPrivateKeyAttrs;
        v43[0] = kSecAttrIsPermanent;
        v43[1] = kSecAttrAccessControl;
        v44[0] = &__kCFBooleanFalse;
        v44[1] = v7;
        id v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v44,  v43,  2LL));
        v46[2] = v11;
        id v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v46,  v45,  3LL));

        CFRelease(v7);
        uint64_t v4 = v40;
        if (v40[2])
        {
          if (v40[4])
          {
LABEL_25:
            int v17 = v4;
LABEL_26:

            goto LABEL_27;
          }
        }

        else
        {
          SecKeyRef v18 = SecKeyCreateRandomKey((CFDictionaryRef)v10, &error);
          if (!v18) {
            goto LABEL_36;
          }
          SecKeyRef v19 = v18;
          if (error)
          {
            CFRelease(error);
            CFErrorRef error = 0LL;
          }

          int64x2_t v20 = sub_100125894(objc_alloc(&OBJC_CLASS___NRDLDKeychainItemSecKey), v19);
          id v21 = (void *)v40[2];
          v40[2] = v20;

          CFRelease(v19);
          if (v4[4]) {
            goto LABEL_25;
          }
        }

        SecKeyRef v22 = SecKeyCreateRandomKey((CFDictionaryRef)v12, &error);
        if (v22)
        {
          SecKeyRef v23 = v22;
          if (error)
          {
            CFRelease(error);
            CFErrorRef error = 0LL;
          }

          id v24 = sub_100125894(objc_alloc(&OBJC_CLASS___NRDLDKeychainItemSecKey), v23);
          CFTypeID v25 = (void *)v4[4];
          v4[4] = v24;

          CFRelease(v23);
          goto LABEL_25;
        }

uint64_t sub_1001274FC(void *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  SecAccessControlRef v6 = v5;
  if (!a1)
  {
LABEL_16:
    uint64_t v12 = 0LL;
    goto LABEL_11;
  }

  if (!v5)
  {
    id v14 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v14, 17LL);

    if (IsLevelEnabled)
    {
      id v16 = sub_100121F34();
      _NRLogWithArgs( v16,  17LL,  "%s called with null nrUUID",  "-[NRDLDDataClassKeychainItems saveToKeychainWithNRUUID:dataProtectionClass:]");
    }

    goto LABEL_16;
  }

  uint64_t v7 = a1[1];
  if (!v7)
  {
    int v8 = 0;
    uint64_t v9 = a1[2];
    if (!v9) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }

  int v8 = sub_100126220(v7, @"RemotePublicKey", v6, a3) ^ 1;
  uint64_t v9 = a1[2];
  if (v9) {
LABEL_5:
  }
    v8 |= sub_100126220(v9, @"LocalPrivateKey", v6, a3) ^ 1;
LABEL_6:
  uint64_t v10 = a1[4];
  if (v10) {
    v8 |= sub_100126220(v10, @"DHPrivateKey", v6, a3) ^ 1;
  }
  uint64_t v11 = a1[3];
  if (v11) {
    v8 |= sub_100125768(v11, @"SharedSecret", v6, a3) ^ 1;
  }
  uint64_t v12 = v8 ^ 1u;
LABEL_11:

  return v12;
}

void sub_100127630(void *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  if (a1)
  {
    id v24 = v5;
    if (!v5)
    {
      id v22 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v22, 17LL);

      id v5 = 0LL;
      if (!IsLevelEnabled) {
        goto LABEL_20;
      }
      SecKeyRef v19 = sub_100121F34();
      _NRLogWithArgs( v19,  17LL,  "%s called with null nrUUID",  "-[NRDLDDataClassKeychainItems deleteFromKeychainWithNRUUID:dataProtectionClass:]");
      goto LABEL_19;
    }

    SecAccessControlRef v6 = (void *)a1[1];
    if (v6)
    {
      id v7 = v6;
      id v8 = v24;
      objc_opt_self(&OBJC_CLASS___NRDKeyManager);
      if (qword_1001DCC18 != -1) {
        dispatch_once(&qword_1001DCC18, &stru_1001B0910);
      }
      id v9 = (id)qword_1001DCC10;
      sub_100144E1C((uint64_t)v9, @"RemotePublicKey", v8, a3);

      id v5 = v24;
    }

    uint64_t v10 = (void *)a1[2];
    if (v10)
    {
      id v11 = v10;
      id v12 = v24;
      objc_opt_self(&OBJC_CLASS___NRDKeyManager);
      if (qword_1001DCC18 != -1) {
        dispatch_once(&qword_1001DCC18, &stru_1001B0910);
      }
      id v13 = (id)qword_1001DCC10;
      sub_100144E1C((uint64_t)v13, @"LocalPrivateKey", v12, a3);

      id v5 = v24;
    }

    id v14 = (void *)a1[4];
    if (v14)
    {
      id v15 = v14;
      id v16 = v24;
      objc_opt_self(&OBJC_CLASS___NRDKeyManager);
      if (qword_1001DCC18 != -1) {
        dispatch_once(&qword_1001DCC18, &stru_1001B0910);
      }
      id v17 = (id)qword_1001DCC10;
      sub_100144E1C((uint64_t)v17, @"DHPrivateKey", v16, a3);

      id v5 = v24;
    }

    SecKeyRef v18 = (void *)a1[3];
    if (v18)
    {
      SecKeyRef v19 = v18;
      id v20 = v24;
      objc_opt_self(&OBJC_CLASS___NRDKeyManager);
      if (qword_1001DCC18 != -1) {
        dispatch_once(&qword_1001DCC18, &stru_1001B0910);
      }
      id v21 = (id)qword_1001DCC10;
      sub_1001462F4((uint64_t)v21, @"SharedSecret", v20, a3, 0LL);

      v19[8] = 1;
LABEL_19:

      id v5 = v24;
    }
  }

void *sub_1001278D0(void *a1, void *a2)
{
  id v3 = a2;
  if (!a1)
  {
LABEL_11:
    id v9 = 0LL;
    goto LABEL_5;
  }

  v21.receiver = a1;
  v21.super_class = (Class)&OBJC_CLASS___NRDDeviceIdentity;
  uint64_t v4 = objc_msgSendSuper2(&v21, "init");
  if (!v4)
  {
    id v11 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 16LL);

    if (IsLevelEnabled)
    {
      id v13 = sub_100121F34();
      _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDDeviceIdentity initWithDeviceIdentityPayload:]",  709);
    }

    id v3 = (id)_os_log_pack_size(12LL);
    a1 = (uint64_t *)((char *)&v20 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL));
    id v14 = __error();
    uint64_t v15 = _os_log_pack_fill(a1, v3, *v14, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)uint64_t v15 = 136446210;
    *(void *)(v15 + 4) = "-[NRDDeviceIdentity initWithDeviceIdentityPayload:]";
    id v16 = sub_100121F34();
    _NRLogAbortWithPack(v16, a1);
    goto LABEL_9;
  }

  a1 = v4;
  if ([v3 length] != (id)48)
  {
LABEL_9:
    id v17 = sub_100121F34();
    int v18 = _NRLogIsLevelEnabled(v17, 17LL);

    if (v18)
    {
      id v19 = sub_100121F34();
      _NRLogWithArgs( v19,  17LL,  "%s called with null payload.length == sizeof(uuid_t) + sizeof(ccec25519pubkey)",  "-[NRDDeviceIdentity initWithDeviceIdentityPayload:]");
    }

    goto LABEL_11;
  }

  v22[0] = 0LL;
  v22[1] = 0LL;
  objc_msgSend(v3, "getBytes:range:", v22, 0, 16);
  id v5 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v22);
  SecAccessControlRef v6 = (void *)a1[1];
  a1[1] = v5;

  uint64_t v7 = objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "subdataWithRange:", 16, 32));
  id v8 = (void *)a1[2];
  a1[2] = v7;

  a1 = a1;
  id v9 = a1;
LABEL_5:

  return v9;
}

void sub_100127AFC(uint64_t a1)
{
  uint64_t v2 = objc_opt_self(a1);
  id v3 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v3);

  if (qword_1001DCB78) {
    return;
  }
  objc_opt_self(&OBJC_CLASS___NRDKeyManager);
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  id v4 = (id)qword_1001DCC10;
  uint64_t v5 = objc_opt_class(&OBJC_CLASS___NRDLocalDevice);
  SecAccessControlRef v6 = sub_1001468B0((uint64_t)v4, v5, @"LocalDeviceConfigClassD", 4LL);
  uint64_t v7 = objc_claimAutoreleasedReturnValue(v6);
  id v8 = (void *)qword_1001DCB78;
  qword_1001DCB78 = v7;

  if (!qword_1001DCB78)
  {
    id v9 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    uint64_t v10 = (void *)qword_1001DCB78;
    qword_1001DCB78 = (uint64_t)v9;
  }

  if (qword_1001DCBD8 != -1) {
    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
  {
    if (qword_1001DCBD8 != -1) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    id v11 = (void *)qword_1001DCB78;
    id v12 = (id)qword_1001DCBD0;
    _NRLogWithArgs( v12,  0,  "%s%.30s:%-4d Loaded %llu ClassD local device configs from keychain",  "",  "+[NRDLocalDevice initializeLocalDeviceDatabaseIfNecessary]",  911,  [v11 count]);
  }

  if (qword_1001DCB78)
  {
    id v13 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    id v14 = (void *)qword_1001DCB80;
    qword_1001DCB80 = (uint64_t)v13;

    if (qword_1001DCB80)
    {
      uint64_t v58 = v2;
      __int128 v65 = 0u;
      __int128 v66 = 0u;
      __int128 v63 = 0u;
      __int128 v64 = 0u;
      id v15 = (id)qword_1001DCB78;
      id v16 = [v15 countByEnumeratingWithState:&v63 objects:v72 count:16];
      if (v16)
      {
        id v17 = v16;
        uint64_t v18 = *(void *)v64;
        do
        {
          for (unint64_t i = 0LL; i != v17; unint64_t i = (char *)i + 1)
          {
            if (*(void *)v64 != v18) {
              objc_enumerationMutation(v15);
            }
            uint64_t v20 = *(void *)(*((void *)&v63 + 1) + 8LL * (void)i);
            uint64_t v21 = objc_claimAutoreleasedReturnValue([(id)qword_1001DCB78 objectForKeyedSubscript:v20]);
            id v22 = (void *)v21;
            if (v21) {
              SecKeyRef v23 = *(void **)(v21 + 56);
            }
            else {
              SecKeyRef v23 = 0LL;
            }
            id v24 = v23;

            if (v24) {
              [(id)qword_1001DCB80 setObject:v20 forKeyedSubscript:v24];
            }
          }

          id v17 = [v15 countByEnumeratingWithState:&v63 objects:v72 count:16];
        }

        while (v17);
      }

      uint64_t v1 = v58;
      objc_opt_self(v58);
      __int128 v67 = 0u;
      __int128 v68 = 0u;
      __int128 v69 = 0u;
      __int128 v70 = 0u;
      id v25 = (id)qword_1001DCB78;
      id v26 = [v25 countByEnumeratingWithState:&v67 objects:v73 count:16];
      if (v26)
      {
        id v27 = v26;
        uint64_t v28 = *(void *)v68;
        do
        {
          for (j = 0LL; j != v27; j = (char *)j + 1)
          {
            if (*(void *)v68 != v28) {
              objc_enumerationMutation(v25);
            }
            id v30 = *(void **)(*((void *)&v67 + 1) + 8LL * (void)j);
            uint64_t v31 = objc_claimAutoreleasedReturnValue([(id)qword_1001DCB78 objectForKeyedSubscript:v30]);
            uint64_t v32 = (void *)v31;
            if (v31 && (*(_BYTE *)(v31 + 8) || *(_BYTE *)(v31 + 9)) && !*(void *)(v31 + 72))
            {
              id v33 = sub_100126D3C(objc_alloc(&OBJC_CLASS___NRDLDDataClassKeychainItems), v30, 4LL);
              id v34 = (void *)v32[9];
              v32[9] = v33;
            }
          }

          id v27 = [v25 countByEnumeratingWithState:&v67 objects:v73 count:16];
        }

        while (v27);
      }

      int v35 = (char *)objc_opt_self(v1);
      objc_opt_self(&OBJC_CLASS___NRDKeyManager);
      if (qword_1001DCC18 == -1) {
        goto LABEL_39;
      }
      goto LABEL_55;
    }

    id v50 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v50, 16LL);

    if (IsLevelEnabled)
    {
      id v52 = sub_100121F34();
      _NRLogWithArgs( v52,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrdLocalDevicesByIdentity) != ((void *)0)",  "",  "+[NRDLocalDevice initializeLocalDeviceDatabaseIfNecessary]",  915);
    }

    uint64_t v53 = _os_log_pack_size(12LL);
    int v35 = (char *)&v57 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v54 = __error();
    uint64_t v55 = _os_log_pack_fill( v35,  v53,  *v54,  &_mh_execute_header,  "%{public}s Assertion Failed: (nrdLocalDevicesByIdentity) != ((void *)0)");
    *(_DWORD *)uint64_t v55 = 136446210;
    *(void *)(v55 + 4) = "+[NRDLocalDevice initializeLocalDeviceDatabaseIfNecessary]";
  }

  else
  {
    id v44 = sub_100121F34();
    int v45 = _NRLogIsLevelEnabled(v44, 16LL);

    if (v45)
    {
      id v46 = sub_100121F34();
      _NRLogWithArgs( v46,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrdLocalDevices) != ((void *)0)",  "",  "+[NRDLocalDevice initializeLocalDeviceDatabaseIfNecessary]",  912);
    }

    uint64_t v47 = _os_log_pack_size(12LL);
    int v35 = (char *)&v57 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    __int16 v48 = __error();
    uint64_t v49 = _os_log_pack_fill( v35,  v47,  *v48,  &_mh_execute_header,  "%{public}s Assertion Failed: (nrdLocalDevices) != ((void *)0)");
    *(_DWORD *)uint64_t v49 = 136446210;
    *(void *)(v49 + 4) = "+[NRDLocalDevice initializeLocalDeviceDatabaseIfNecessary]";
  }

  id v56 = sub_100121F34();
  _NRLogAbortWithPack(v56, v35);
LABEL_55:
  dispatch_once(&qword_1001DCC18, &stru_1001B0910);
LABEL_39:
  id v36 = (id)qword_1001DCC10;
  v73[0] = _NSConcreteStackBlock;
  v73[1] = 3221225472LL;
  void v73[2] = sub_1001281C8;
  v73[3] = &unk_1001B0578;
  v73[4] = v35;
  sub_1001446A8((uint64_t)v36, v73);

  __int128 v59 = 0u;
  __int128 v60 = 0u;
  __int128 v61 = 0u;
  __int128 v62 = 0u;
  id v37 = (id)qword_1001DCB78;
  id v38 = [v37 countByEnumeratingWithState:&v59 objects:v71 count:16];
  if (v38)
  {
    id v39 = v38;
    uint64_t v40 = *(void *)v60;
    do
    {
      for (uint64_t k = 0LL; k != v39; uint64_t k = (char *)k + 1)
      {
        if (*(void *)v60 != v40) {
          objc_enumerationMutation(v37);
        }
        objc_super v42 = (void *)objc_claimAutoreleasedReturnValue( [(id)qword_1001DCB78 objectForKeyedSubscript:*(void *)(*((void *)&v59 + 1) + 8 * (void)k)]);
        sub_100128884((uint64_t)&OBJC_CLASS___NRDLocalDevice, v42);
      }

      id v39 = [v37 countByEnumeratingWithState:&v59 objects:v71 count:16];
    }

    while (v39);
  }

  uint64_t v43 = objc_opt_self(v1);
  sub_100128908(v43);
}

void sub_1001281C8(uint64_t a1)
{
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  id v2 = (id)qword_1001DCC10;
  uint64_t v3 = objc_opt_class(&OBJC_CLASS___NRDLDKeys);
  id v4 = sub_1001468B0((uint64_t)v2, v3, @"LocalDeviceKeysClassC", 3LL);
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(v4);

  if (v5)
  {
    if (qword_1001DCBD8 != -1) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
    {
      if (qword_1001DCBD8 != -1) {
        dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
      }
      id v6 = (id)qword_1001DCBD0;
      _NRLogWithArgs( v6,  0,  "%s%.30s:%-4d Loaded %llu legacy ClassC keys from keychain",  "",  "+[NRDLocalDevice loadClassCKeys]_block_invoke",  983,  [v5 count]);
    }

    uint64_t v38 = a1;
    id v39 = v5;
    __int128 v46 = 0u;
    __int128 v47 = 0u;
    __int128 v44 = 0u;
    __int128 v45 = 0u;
    id v7 = v5;
    id v8 = [v7 countByEnumeratingWithState:&v44 objects:v53 count:16];
    if (v8)
    {
      id v9 = v8;
      uint64_t v10 = *(void *)v45;
      do
      {
        for (unint64_t i = 0LL; i != v9; unint64_t i = (char *)i + 1)
        {
          if (*(void *)v45 != v10) {
            objc_enumerationMutation(v7);
          }
          id v12 = *(void **)(*((void *)&v44 + 1) + 8LL * (void)i);
          uint64_t v13 = objc_claimAutoreleasedReturnValue([(id)qword_1001DCB78 objectForKeyedSubscript:v12]);
          id v14 = (void *)v13;
          if (v13 && (*(_BYTE *)(v13 + 8) || *(_BYTE *)(v13 + 9)))
          {
            id v15 = objc_alloc(&OBJC_CLASS___NRDLDDataClassKeychainItems);
            id v16 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v12]);
            id v17 = sub_100123EA4(v15, v16);
            uint64_t v18 = (void *)v14[10];
            v14[10] = v17;

            if (qword_1001DCBD8 != -1) {
              dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
            }
            if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
            {
              if (qword_1001DCBD8 != -1) {
                dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
              }
              _NRLogWithArgs( qword_1001DCBD0,  0LL,  "%s%.30s:%-4d Migrated legacy ClassC keys for %@",  "",  "+[NRDLocalDevice loadClassCKeys]_block_invoke",  993LL,  v14);
            }
          }

          else
          {
            if (qword_1001DCBD8 != -1) {
              dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
            }
            if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
            {
              if (qword_1001DCBD8 != -1) {
                dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
              }
              id v19 = (id)qword_1001DCBD0;
              uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v12 UUIDString]);
              _NRLogWithArgs( v19,  0LL,  "%s%.30s:%-4d Skipping migrating legacy ClassC keys for %@",  "",  "+[NRDLocalDevice loadClassCKeys]_block_invoke",  988LL,  v20);
            }
          }
        }

        id v9 = [v7 countByEnumeratingWithState:&v44 objects:v53 count:16];
      }

      while (v9);
    }

    a1 = v38;
    uint64_t v5 = v39;
    if (sub_1001296B4(*(void *)(v38 + 32)))
    {
      objc_opt_self(&OBJC_CLASS___NRDKeyManager);
      if (qword_1001DCC18 != -1) {
        dispatch_once(&qword_1001DCC18, &stru_1001B0910);
      }
      id v21 = (id)qword_1001DCC10;
      char v22 = sub_1001462F4((uint64_t)v21, @"LocalDeviceKeysClassC", 0LL, 3LL, 0LL);

      if ((v22 & 1) == 0)
      {
        if (qword_1001DCBD8 != -1) {
          dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCBD0, 16LL))
        {
          if (qword_1001DCBD8 != -1) {
            dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
          }
          _NRLogWithArgs( qword_1001DCBD0,  16LL,  "%s%.30s:%-4d Failed to delete legacy ClassC keys from the keychain",  "",  "+[NRDLocalDevice loadClassCKeys]_block_invoke",  1002);
        }
      }
    }
  }

  uint64_t v23 = objc_opt_self(*(void *)(a1 + 32));
  objc_opt_self(&OBJC_CLASS___NRDKeyManager);
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  id v24 = (dispatch_queue_t *)(id)qword_1001DCC10;
  v48[0] = _NSConcreteStackBlock;
  v48[1] = 3221225472LL;
  uint64_t v49 = sub_100129E44;
  id v50 = &unk_1001B0578;
  uint64_t v51 = v23;
  id v25 = v48;
  if (v24)
  {
    dispatch_assert_queue_V2(v24[2]);
    else {
      v49((uint64_t)v25);
    }
  }

  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  id v26 = (id)qword_1001DCB78;
  id v27 = [v26 countByEnumeratingWithState:&v40 objects:v52 count:16];
  if (v27)
  {
    id v28 = v27;
    uint64_t v29 = *(void *)v41;
    do
    {
      for (j = 0LL; j != v28; j = (char *)j + 1)
      {
        if (*(void *)v41 != v29) {
          objc_enumerationMutation(v26);
        }
        uint64_t v31 = *(void **)(*((void *)&v40 + 1) + 8LL * (void)j);
        uint64_t v32 = objc_claimAutoreleasedReturnValue([(id)qword_1001DCB78 objectForKeyedSubscript:v31]);
        id v33 = (void *)v32;
        if (v32 && (*(_BYTE *)(v32 + 8) || *(_BYTE *)(v32 + 9)))
        {
          if (*(void *)(v32 + 80))
          {
            if (*(void *)(v32 + 152)) {
              goto LABEL_52;
            }
          }

          else
          {
            id v34 = sub_100126D3C(objc_alloc(&OBJC_CLASS___NRDLDDataClassKeychainItems), v31, 3LL);
            int v35 = (void *)v33[10];
            v33[10] = v34;

            if (v33[19]) {
              goto LABEL_52;
            }
          }

          id v36 = sub_100125504((id *)objc_alloc(&OBJC_CLASS___NRDLDKeychainItemData), @"OOBK", v31, 3LL);
          id v37 = (void *)v33[19];
          v33[19] = v36;
        }

void sub_100128884(uint64_t a1, void *a2)
{
  id v6 = a2;
  objc_opt_self(a1);
  if (_os_feature_enabled_impl("terminus", "MASQUEProxyServer"))
  {
    uint64_t v3 = v6;
    if (v6) {
      uint64_t v3 = (void *)v6[16];
    }
    uint64_t v4 = [v3 usesTLS];
  }

  else
  {
    uint64_t v4 = 0LL;
  }

  uint64_t v5 = v6;
  if (v6) {
    uint64_t v5 = (void *)v6[4];
  }
  sub_1001298FC((uint64_t)&OBJC_CLASS___NRDLocalDevice, v4, v5);
}

uint64_t sub_100128908(uint64_t a1)
{
  uint64_t v85 = objc_opt_self(a1);
  uint64_t v1 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v1);

  __int128 v104 = 0u;
  __int128 v105 = 0u;
  __int128 v102 = 0u;
  __int128 v103 = 0u;
  id v2 = (id)qword_1001DCB78;
  id v3 = [v2 countByEnumeratingWithState:&v102 objects:v114 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = 0LL;
    uint64_t v6 = *(void *)v103;
    do
    {
      for (unint64_t i = 0LL; i != v4; unint64_t i = (char *)i + 1)
      {
        if (*(void *)v103 != v6) {
          objc_enumerationMutation(v2);
        }
        uint64_t v9 = *(void *)(*((void *)&v102 + 1) + 8LL * (void)i);
        uint64_t v10 = (unsigned __int8 *)objc_claimAutoreleasedReturnValue([(id)qword_1001DCB78 objectForKeyedSubscript:v9]);
        if (v10)
        {
          int v11 = v10[24];

          if (v11)
          {
            if (!v5) {
              uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
            }
            id v8 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1001DCB78 objectForKeyedSubscript:v9]);
            -[NSMutableDictionary setObject:forKeyedSubscript:](v5, "setObject:forKeyedSubscript:", v8, v9);
          }
        }
      }

      id v4 = [v2 countByEnumeratingWithState:&v102 objects:v114 count:16];
    }

    while (v4);
  }

  else
  {
    uint64_t v5 = 0LL;
  }

  if (-[NSMutableDictionary count](v5, "count"))
  {
    __int128 v100 = 0u;
    __int128 v101 = 0u;
    __int128 v98 = 0u;
    __int128 v99 = 0u;
    id v12 = v5;
    id v13 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v12,  "countByEnumeratingWithState:objects:count:",  &v98,  v113,  16LL);
    if (v13)
    {
      id v14 = v13;
      uint64_t v15 = *(void *)v99;
      do
      {
        for (j = 0LL; j != v14; j = (char *)j + 1)
        {
          if (*(void *)v99 != v15) {
            objc_enumerationMutation(v12);
          }
          [(id)qword_1001DCB78 setObject:0 forKeyedSubscript:*(void *)(*((void *)&v98 + 1) + 8 * (void)j)];
        }

        id v14 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v12,  "countByEnumeratingWithState:objects:count:",  &v98,  v113,  16LL);
      }

      while (v14);
    }
  }

  objc_opt_self(&OBJC_CLASS___NRDKeyManager);
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  id v17 = (id)qword_1001DCC10;
  if (!v17) {
    goto LABEL_32;
  }
  uint64_t v18 = v17;
  dispatch_assert_queue_V2(*((dispatch_queue_t *)v17 + 2));
  if (!v18[10])
  {
    v18[10] = 1;
    if (v18[8] == 4)
    {
      sub_100143DD4((uint64_t)v18);
      if (v18[9])
      {
        v18[8] = 3;
        sub_100144044((uint64_t)v18);
      }
    }
  }

  int v19 = v18[8] & 0xFD;

  if (v19 == 1 && (sub_1001296B4(v85) & 1) == 0) {
    unsigned int v84 = 0;
  }
  else {
LABEL_32:
  }
    unsigned int v84 = 1;
  objc_opt_self(v85);
  __int128 v106 = 0u;
  __int128 v107 = 0u;
  __int128 v108 = 0u;
  __int128 v109 = 0u;
  id v20 = (id)qword_1001DCB78;
  id v21 = [v20 countByEnumeratingWithState:&v106 objects:v115 count:16];
  if (v21)
  {
    id v22 = v21;
    uint64_t v23 = *(void *)v107;
    int v24 = 1;
    do
    {
      for (uint64_t k = 0LL; k != v22; uint64_t k = (char *)k + 1)
      {
        if (*(void *)v107 != v23) {
          objc_enumerationMutation(v20);
        }
        id v26 = *(void **)(*((void *)&v106 + 1) + 8LL * (void)k);
        uint64_t v27 = objc_claimAutoreleasedReturnValue([(id)qword_1001DCB78 objectForKeyedSubscript:v26]);
        id v28 = (void *)v27;
        if (v27 && !*(_BYTE *)(v27 + 24) && (*(_BYTE *)(v27 + 8) || *(_BYTE *)(v27 + 9)))
        {
          uint64_t v29 = *(void **)(v27 + 72);
          if (v29) {
            v24 &= sub_1001274FC(v29, v26, 4LL);
          }
        }
      }

      id v22 = [v20 countByEnumeratingWithState:&v106 objects:v115 count:16];
    }

    while (v22);

    if ((v24 & 1) == 0) {
      unsigned int v84 = 0;
    }
  }

  else
  {
  }

  if (qword_1001DCBD8 != -1) {
    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCBD0, 2LL))
  {
    if (qword_1001DCBD8 != -1) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    _NRLogWithArgs( qword_1001DCBD0,  2LL,  "%s%.30s:%-4d Checking if ClassD configs need to be saved",  "",  "+[NRDLocalDevice saveAllDevicesToDiskWithForce:]",  1263);
  }

  __int128 v96 = 0u;
  __int128 v97 = 0u;
  __int128 v94 = 0u;
  __int128 v95 = 0u;
  id v30 = (id)qword_1001DCB78;
  id v31 = [v30 countByEnumeratingWithState:&v94 objects:v112 count:16];
  if (v31)
  {
    id v32 = v31;
    uint64_t v33 = *(void *)v95;
LABEL_57:
    uint64_t v34 = 0LL;
    while (1)
    {
      if (*(void *)v95 != v33) {
        objc_enumerationMutation(v30);
      }
      int v35 = *(void **)(*((void *)&v94 + 1) + 8 * v34);
      if (qword_1001DCBD8 != -1) {
        dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCBD0, 2LL))
      {
        if (qword_1001DCBD8 != -1) {
          dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        }
        id v36 = (id)qword_1001DCBD0;
        id v37 = (void *)objc_claimAutoreleasedReturnValue([v35 UUIDString]);
        uint64_t v38 = objc_claimAutoreleasedReturnValue([(id)qword_1001DCB78 objectForKeyedSubscript:v35]);
        id v39 = (void *)v38;
        if (v38)
        {
          __int128 v40 = "NO";
          if (*(_BYTE *)(v38 + 21)) {
            __int128 v40 = "YES";
          }
        }

        else
        {
          __int128 v40 = "NO";
        }

        _NRLogWithArgs( v36,  2LL,  "%s%.30s:%-4d Local device %@ ClassD config isChanged %s",  "",  "+[NRDLocalDevice saveAllDevicesToDiskWithForce:]",  1267LL,  v37,  v40);
      }

      __int128 v41 = (unsigned __int8 *)objc_claimAutoreleasedReturnValue([(id)qword_1001DCB78 objectForKeyedSubscript:v35]);
      if (v41)
      {
        int v42 = v41[21];

        if (v42) {
          break;
        }
      }

      if (v32 == (id)++v34)
      {
        id v43 = [v30 countByEnumeratingWithState:&v94 objects:v112 count:16];
        id v32 = v43;
        if (v43) {
          goto LABEL_57;
        }
        goto LABEL_75;
      }
    }

    if (qword_1001DCBD8 != -1) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
    {
      if (qword_1001DCBD8 != -1) {
        dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
      }
      __int128 v44 = (void *)qword_1001DCB78;
      id v45 = (id)qword_1001DCBD0;
      _NRLogWithArgs( v45,  0,  "%s%.30s:%-4d %saving %llu local device ClassD configs",  "",  "+[NRDLocalDevice saveAllDevicesToDiskWithForce:]",  1276,  "S",  [v44 count]);
    }

    objc_opt_self(&OBJC_CLASS___NRDKeyManager);
    if (qword_1001DCC18 != -1) {
      dispatch_once(&qword_1001DCC18, &stru_1001B0910);
    }
    __int128 v46 = (dispatch_queue_t *)(id)qword_1001DCC10;
    id v47 = (id)qword_1001DCB78;
    __int16 v48 = @"LocalDeviceConfigClassD";
    if (v46)
    {
      dispatch_assert_queue_V2(v46[2]);
      if (v47)
      {
        id v47 = v47;
        uint64_t v49 = @"LocalDeviceConfigClassD";
        dispatch_assert_queue_V2(v46[2]);
        v115[0] = 0LL;
        id v50 = (void *)objc_claimAutoreleasedReturnValue( +[NSKeyedArchiver archivedDataWithRootObject:requiringSecureCoding:error:]( &OBJC_CLASS___NSKeyedArchiver,  "archivedDataWithRootObject:requiringSecureCoding:error:",  v47,  1LL,  v115));
        id v51 = v115[0];
        id v52 = v51;
        if (v50 && !v51)
        {
          LOBYTE(v106) = 0;
          BOOL v53 = sub_100145390((uint64_t)v46, v50, @"LocalDeviceConfigClassD", 0LL, 4LL, &v106);

          if (v53)
          {
            if (qword_1001DCBD8 != -1) {
              dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
            }
            if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
            {
              if (qword_1001DCBD8 != -1) {
                dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
              }
              id v54 = (void *)qword_1001DCB78;
              id v55 = (id)qword_1001DCBD0;
              _NRLogWithArgs( v55,  0,  "%s%.30s:%-4d Saved %llu local device ClassD configs",  "",  "+[NRDLocalDevice saveAllDevicesToDiskWithForce:]",  1282,  [v54 count]);
            }

            __int128 v92 = 0u;
            __int128 v93 = 0u;
            __int128 v90 = 0u;
            __int128 v91 = 0u;
            id v56 = (id)qword_1001DCB78;
            id v57 = [v56 countByEnumeratingWithState:&v90 objects:v111 count:16];
            if (v57)
            {
              id v58 = v57;
              uint64_t v59 = *(void *)v91;
              do
              {
                for (m = 0LL; m != v58; m = (char *)m + 1)
                {
                  if (*(void *)v91 != v59) {
                    objc_enumerationMutation(v56);
                  }
                  __int128 v61 = (_BYTE *)objc_claimAutoreleasedReturnValue( [(id)qword_1001DCB78 objectForKeyedSubscript:*(void *)(*((void *)&v90 + 1) + 8 * (void)m)]);
                  if (v61) {
                    v61[21] = 0;
                  }
                }

                id v58 = [v56 countByEnumeratingWithState:&v90 objects:v111 count:16];
              }

              while (v58);
            }

            goto LABEL_121;
          }

          goto LABEL_118;
        }

        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCC20, 16LL))
        {
          if (qword_1001DCC28 != -1) {
            dispatch_once(&qword_1001DCC28, &stru_1001B0980);
          }
          _NRLogWithArgs( qword_1001DCC20,  16LL,  "%s%.30s:%-4d Failed to archive keychain data %@: %@",  "",  "-[NRDKeyManager _saveNRUUIDDictionary:toKeychainWithName:dataProtectionClass:retryBlock:]",  846LL,  @"LocalDeviceConfigClassD",  v52);
        }
      }

      else
      {
        id v81 = sub_10014387C();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v81, 17LL);

        if (IsLevelEnabled)
        {
          id v83 = sub_10014387C();
          _NRLogWithArgs( v83,  17LL,  "%s called with null dictToSave",  "-[NRDKeyManager saveNRUUIDDictionary:toKeychainWithName:dataProtectionClass:]");
        }
      }
    }

LABEL_118:
    id v62 = sub_100121F34();
    int v63 = _NRLogIsLevelEnabled(v62, 17LL);

    if (v63)
    {
      id v64 = sub_100121F34();
      _NRLogWithArgs( v64,  17,  "Failed to save %llu local device ClassD configs",  [(id)qword_1001DCB78 count]);
    }

    unsigned int v84 = 0;
    goto LABEL_121;
  }

LABEL_121:
  if (-[NSMutableDictionary count](v5, "count"))
  {
    __int128 v88 = 0u;
    __int128 v89 = 0u;
    __int128 v86 = 0u;
    __int128 v87 = 0u;
    __int128 v65 = v5;
    id v66 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v65,  "countByEnumeratingWithState:objects:count:",  &v86,  v110,  16LL);
    if (v66)
    {
      id v67 = v66;
      uint64_t v68 = *(void *)v87;
      do
      {
        for (n = 0LL; n != v67; n = (char *)n + 1)
        {
          if (*(void *)v87 != v68) {
            objc_enumerationMutation(v65);
          }
          uint64_t v70 = *(void *)(*((void *)&v86 + 1) + 8LL * (void)n);
          nw_txt_record_t v71 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v65, "objectForKeyedSubscript:", v70));
          [(id)qword_1001DCB78 setObject:v71 forKeyedSubscript:v70];
        }

        id v67 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v65,  "countByEnumeratingWithState:objects:count:",  &v86,  v110,  16LL);
      }

      while (v67);
    }
  }

  objc_opt_self(v85);
  if (qword_1001DCB88)
  {
    __int128 v108 = 0u;
    __int128 v109 = 0u;
    __int128 v106 = 0u;
    __int128 v107 = 0u;
    id v72 = (id)qword_1001DCB78;
    id v73 = [v72 countByEnumeratingWithState:&v106 objects:v115 count:16];
    if (v73)
    {
      id v74 = v73;
      uint64_t v75 = *(void *)v107;
LABEL_133:
      uint64_t v76 = 0LL;
      while (1)
      {
        if (*(void *)v107 != v75) {
          objc_enumerationMutation(v72);
        }
        __int128 v77 = (void *)objc_claimAutoreleasedReturnValue( [(id)qword_1001DCB78 objectForKeyedSubscript:*(void *)(*((void *)&v106 + 1) + 8 * v76)]);
        if (v77)
        {
          uint64_t v78 = v77[7];

          if (v78) {
            break;
          }
        }

        if (v74 == (id)++v76)
        {
          id v74 = [v72 countByEnumeratingWithState:&v106 objects:v115 count:16];
          if (v74) {
            goto LABEL_133;
          }
          goto LABEL_140;
        }
      }
    }

    else
    {
LABEL_140:

      if (qword_1001DCBD8 != -1) {
        dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
      {
        if (qword_1001DCBD8 != -1) {
          dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        }
        _NRLogWithArgs( qword_1001DCBD0,  0LL,  "%s%.30s:%-4d No remaining devices with a local identity UUID, deleting encrypted identity key",  "",  "+[NRDLocalDevice deleteLocalDeviceIdentityKeyIfNecessary]",  1166);
      }

      if (qword_1001DCB88)
      {
        objc_opt_self(&OBJC_CLASS___NRDKeyManager);
        if (qword_1001DCC18 != -1) {
          dispatch_once(&qword_1001DCC18, &stru_1001B0910);
        }
        id v79 = (id)qword_1001DCC10;
        sub_100144E1C((uint64_t)v79, @"IdentityKey", 0LL, 4LL);

        id v72 = (id)qword_1001DCB88;
      }

      else
      {
        id v72 = 0LL;
      }

      qword_1001DCB88 = 0LL;
    }
  }

  return v84;
}

uint64_t sub_1001296B4(uint64_t a1)
{
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  id v1 = (id)qword_1001DCC10;
  if (!v1) {
    goto LABEL_27;
  }
  id v2 = v1;
  dispatch_assert_queue_V2(*((dispatch_queue_t *)v1 + 2));
  if (!v2[10])
  {
    v2[10] = 1;
    if (v2[8] == 4)
    {
      sub_100143DD4((uint64_t)v2);
      if (v2[9])
      {
        v2[8] = 3;
        sub_100144044((uint64_t)v2);
      }
    }
  }

  int v3 = v2[8] & 0xFD;

  if (v3 == 1)
  {
    __int128 v18 = 0u;
    __int128 v19 = 0u;
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    id v4 = (id)qword_1001DCB78;
    id v5 = [v4 countByEnumeratingWithState:&v16 objects:v20 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v17;
      int v8 = 1;
      while (1)
      {
        for (unint64_t i = 0LL; i != v6; unint64_t i = (char *)i + 1)
        {
          if (*(void *)v17 != v7) {
            objc_enumerationMutation(v4);
          }
          uint64_t v10 = *(void **)(*((void *)&v16 + 1) + 8LL * (void)i);
          uint64_t v11 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_1001DCB78, "objectForKeyedSubscript:", v10, (void)v16));
          id v12 = (void *)v11;
          if (v11 && !*(_BYTE *)(v11 + 24) && (*(_BYTE *)(v11 + 8) || *(_BYTE *)(v11 + 9)))
          {
            id v13 = *(void **)(v11 + 80);
            if (v13)
            {
              if (!sub_1001274FC(v13, v10, 3LL))
              {
                int v8 = 0;
                uint64_t v14 = v12[19];
                if (!v14) {
                  goto LABEL_13;
                }
LABEL_26:
                v8 &= sub_100125768(v14, @"OOBK", v10, 3LL);
                goto LABEL_13;
              }

              [v12 setHasSavedClassCKeysInKeychain:1];
            }

            uint64_t v14 = v12[19];
            if (v14) {
              goto LABEL_26;
            }
          }

void sub_1001298FC(uint64_t a1, uint64_t a2, void *a3)
{
  id v22 = a3;
  uint64_t v5 = objc_opt_self(a1);
  id v6 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v6);

  if (v22)
  {
    uint64_t v7 = sub_100129B30(v5);
    if (v7)
    {
      uint64_t v9 = (void *)v7;
      if (*(void *)(v7 + 136) == a2) {
        goto LABEL_4;
      }
    }

    else
    {
      id v12 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 16LL);

      if (IsLevelEnabled)
      {
        id v14 = sub_100121F34();
        _NRLogWithArgs( v14,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice updateLocalDeviceFlagsInner:nrUUID:saveToDisk:]",  3540);
      }

      a2 = _os_log_pack_size(12LL);
      uint64_t v9 = (id *)((char *)&v22 - ((a2 + 15) & 0xFFFFFFFFFFFFFFF0LL));
      uint64_t v15 = __error();
      uint64_t v16 = _os_log_pack_fill( v9,  a2,  *v15,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)uint64_t v16 = 136446210;
      *(void *)(v16 + 4) = "+[NRDLocalDevice updateLocalDeviceFlagsInner:nrUUID:saveToDisk:]";
      id v17 = sub_100121F34();
      _NRLogAbortWithPack(v17, v9);
    }

    __int128 v18 = (void *)_NRCopyLogObjectForNRUUID(v22, v8);
    int v19 = _NRLogIsLevelEnabled(v18, 0LL);

    if (v19)
    {
      id v21 = (void *)_NRCopyLogObjectForNRUUID(v22, v20);
      _NRLogWithArgs( v21,  0LL,  "%s%.30s:%-4d %@ Updating local flags from %#llx to %#llx",  "",  "+[NRDLocalDevice updateLocalDeviceFlagsInner:nrUUID:saveToDisk:]",  3544LL,  v9,  v9[17],  a2);
    }

    objc_msgSend(v9, "setLocalFlags:", a2, v22);
    goto LABEL_4;
  }

  id v10 = sub_100121F34();
  int v11 = _NRLogIsLevelEnabled(v10, 17LL);

  if (!v11) {
    goto LABEL_5;
  }
  uint64_t v9 = sub_100121F34();
  _NRLogWithArgs( v9,  17LL,  "%s called with null nrUUID",  "+[NRDLocalDevice updateLocalDeviceFlagsInner:nrUUID:saveToDisk:]");
LABEL_4:

LABEL_5:
}

char *sub_100129B30(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_self(a1);
  if (!v3)
  {
    id v9 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 17LL);

    if (IsLevelEnabled)
    {
      id v11 = sub_100121F34();
      _NRLogWithArgs(v11, 17LL, "%s called with null nrUUID");
LABEL_9:
    }

char *sub_100129C28(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  uint64_t v6 = objc_opt_self(a1);
  if (!v5)
  {
    id v15 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v15, 17LL);

    if (IsLevelEnabled)
    {
      id v17 = sub_100121F34();
      _NRLogWithArgs(v17, 17LL, "%s called with null nrUUID");
LABEL_20:
    }

void sub_100129E44(uint64_t a1)
{
  char v10 = 0;
  objc_opt_self(&OBJC_CLASS___NRDKeyManager);
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  id v2 = (id)qword_1001DCC10;
  char v3 = sub_1001462F4((uint64_t)v2, @"LocalDeviceKeysClassA", 0LL, 1LL, &v10);

  if ((v3 & 1) == 0)
  {
    if (v10)
    {
      if (qword_1001DCBD8 != -1) {
        dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCBD0, 1LL))
      {
        if (qword_1001DCBD8 != -1) {
          dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        }
        _NRLogWithArgs( qword_1001DCBD0,  1LL,  "%s%.30s:%-4d ClassA keychain is locked, will retry deleting legacy keys after unlocking",  "",  "+[NRDLocalDevice deleteClassAKeysRetryIfNeeded]_block_invoke",  1074);
      }

      objc_opt_self(&OBJC_CLASS___NRDKeyManager);
      if (qword_1001DCC18 != -1) {
        dispatch_once(&qword_1001DCC18, &stru_1001B0910);
      }
      uint64_t v4 = (dispatch_queue_t *)(id)qword_1001DCC10;
      v6[0] = _NSConcreteStackBlock;
      v6[1] = 3221225472LL;
      uint64_t v7 = sub_10012A0B8;
      uint64_t v8 = &unk_1001B0578;
      uint64_t v9 = *(void *)(a1 + 32);
      id v5 = v6;
      if (v4)
      {
        dispatch_assert_queue_V2(v4[2]);
        else {
          v7((uint64_t)v5);
        }
      }
    }

    else
    {
      if (qword_1001DCBD8 != -1) {
        dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCBD0, 16LL))
      {
        if (qword_1001DCBD8 != -1) {
          dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        }
        _NRLogWithArgs( qword_1001DCBD0,  16LL,  "%s%.30s:%-4d Failed to delete legacy ClassA keys from the keychain",  "",  "+[NRDLocalDevice deleteClassAKeysRetryIfNeeded]_block_invoke",  1079);
      }
    }
  }

void sub_10012A0B8(uint64_t a1)
{
  uint64_t v1 = objc_opt_self(*(void *)(a1 + 32));
  objc_opt_self(&OBJC_CLASS___NRDKeyManager);
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  id v2 = (dispatch_queue_t *)(id)qword_1001DCC10;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472LL;
  id v5 = sub_100129E44;
  uint64_t v6 = &unk_1001B0578;
  uint64_t v7 = v1;
  char v3 = v4;
  if (v2)
  {
    dispatch_assert_queue_V2(v2[2]);
    else {
      ((void (*)(void *))v5)(v3);
    }
  }
}

uint64_t sub_10012A1A0(uint64_t a1, char a2)
{
  if (qword_1001DCB88) {
    return 1LL;
  }
  id v5 = sub_100125A00((char *)objc_alloc(&OBJC_CLASS___NRDLDKeychainItemSecKey), @"IdentityKey", 0LL, 4LL);
  uint64_t v6 = (void *)qword_1001DCB88;
  qword_1001DCB88 = (uint64_t)v5;

  if (qword_1001DCB88)
  {
    if (qword_1001DCBD8 != -1) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
    {
      if (qword_1001DCBD8 != -1) {
        dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
      }
      uint64_t v7 = (void *)qword_1001DCB88;
      id v8 = (id)qword_1001DCBD0;
      uint64_t v9 = sub_100124E58(v7);
      Logid String = (void *)_NRKeyCreateLogString(v9);
      _NRLogWithArgs( v8,  0LL,  "%s%.30s:%-4d Loaded encrypted identity key: %@",  "",  "+[NRDLocalDevice initializeLocalDeviceIdentityKeyCreateIfNecessary:]",  1095LL,  LogString);
    }

    return 1LL;
  }

  if ((a2 & 1) != 0)
  {
    CFErrorRef error = 0LL;
    SecAccessControlRef v11 = SecAccessControlCreateWithFlags( kCFAllocatorDefault,  kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate,  0x40000000uLL,  &error);
    if (v11)
    {
      SecAccessControlRef v12 = v11;
      if (error)
      {
        CFRelease(error);
        CFErrorRef error = 0LL;
      }

      v38[0] = kSecAttrKeyType;
      v38[1] = kSecAttrTokenID;
      v39[0] = kSecAttrKeyTypeX25519;
      v39[1] = kSecAttrTokenIDAppleKeyStore;
      v38[2] = kSecPrivateKeyAttrs;
      v36[0] = kSecAttrIsPermanent;
      v36[1] = kSecAttrAccessControl;
      v37[0] = &__kCFBooleanFalse;
      v37[1] = v12;
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v37,  v36,  2LL));
      v39[2] = v13;
      id v14 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v39,  v38,  3LL));

      CFRelease(v12);
      SecKeyRef v15 = SecKeyCreateRandomKey(v14, &error);
      if (v15)
      {
        SecKeyRef v16 = v15;
        if (error)
        {
          CFRelease(error);
          CFErrorRef error = 0LL;
        }

        if (qword_1001DCBD8 != -1) {
          dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
        {
          if (qword_1001DCBD8 != -1) {
            dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
          }
          id v17 = (id)qword_1001DCBD0;
          int v35 = 0LL;
          SecKeyCopyPublicBytes(v16, &v35);
          id v18 = v35;
          int v35 = 0LL;
          int v19 = (void *)_NRKeyCreateLogString(v18);

          _NRLogWithArgs( v17,  0LL,  "%s%.30s:%-4d Generated new encrypted identity key: %@",  "",  "+[NRDLocalDevice initializeLocalDeviceIdentityKeyCreateIfNecessary:]",  1140LL,  v19);
        }

        uint64_t v20 = sub_100125894(objc_alloc(&OBJC_CLASS___NRDLDKeychainItemSecKey), v16);
        id v21 = (void *)qword_1001DCB88;
        qword_1001DCB88 = (uint64_t)v20;

        CFRelease(v16);
        if ((sub_100126220(qword_1001DCB88, @"IdentityKey", 0LL, 4LL) & 1) != 0)
        {
          uint64_t v3 = 1LL;
LABEL_39:

          return v3;
        }

        if (qword_1001DCBD8 != -1) {
          dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCBD0, 16LL))
        {
          id v25 = sub_100121F34();
          _NRLogWithArgs( v25,  16LL,  "%s%.30s:%-4d Failed to save encrypted identity key to keychain, discarding",  "",  "+[NRDLocalDevice initializeLocalDeviceIdentityKeyCreateIfNecessary:]",  1146);
        }

        id v26 = (void *)qword_1001DCB88;
        qword_1001DCB88 = 0LL;
      }

      else
      {
        id v30 = sub_100121F34();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v30, 17LL);

        if (IsLevelEnabled)
        {
          id v32 = sub_100121F34();
          _NRLogWithArgs(v32, 17LL, "Failed to generate private key: %@", error);
        }

        if (error)
        {
          CFRelease(error);
          uint64_t v3 = 0LL;
          CFErrorRef error = 0LL;
          goto LABEL_39;
        }
      }

      uint64_t v3 = 0LL;
      goto LABEL_39;
    }

    id v27 = sub_100121F34();
    int v28 = _NRLogIsLevelEnabled(v27, 17LL);

    if (v28)
    {
      id v29 = sub_100121F34();
      _NRLogWithArgs(v29, 17LL, "Failed to generate key access control: %@", error);
    }

    if (error) {
      CFRelease(error);
    }
    return 0LL;
  }

  else
  {
    if (qword_1001DCBD8 != -1) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCBD0, 16LL))
    {
      if (qword_1001DCBD8 != -1) {
        dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
      }
      _NRLogWithArgs( qword_1001DCBD0,  16LL,  "%s%.30s:%-4d Failed to load identity key, not creating new one",  "",  "+[NRDLocalDevice initializeLocalDeviceIdentityKeyCreateIfNecessary:]",  1100);
    }

    sub_1001030D0( @"NRDLocalDevice",  @"EncryptedIdentifier",  @"KeyLoadFailure",  0,  0LL,  v22,  v23,  v24,  v33);
    return 0LL;
  }

NRDDecryptedIdentifier *sub_10012A74C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  objc_opt_self(a1);
  if (!sub_10012A1A0((uint64_t)&OBJC_CLASS___NRDLocalDevice, 0))
  {
    int v19 = 0LL;
    goto LABEL_15;
  }

  id v10 = objc_alloc(&OBJC_CLASS___NEIKEv2EncryptedKeyIDIdentifier);
  SecAccessControlRef v11 = (void *)objc_claimAutoreleasedReturnValue([v7 identifierData]);
  SecAccessControlRef v12 = (void *)objc_claimAutoreleasedReturnValue([v8 identifierData]);
  if (qword_1001DCB88) {
    uint64_t v13 = *(void *)(qword_1001DCB88 + 16);
  }
  else {
    uint64_t v13 = 0LL;
  }
  id v14 = [v10 initWithKeyID:v11 aad:v12 keyRef:v13];

  id v39 = 0LL;
  id v15 = [v14 decryptWithSession:v9 returnError:&v39];
  id v16 = v39;
  if (!v15)
  {
    id v31 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v31, 16LL);

    if (!IsLevelEnabled)
    {
      int v19 = 0LL;
      uint64_t v33 = @"DecryptionFailure";
      goto LABEL_27;
    }

    uint64_t v24 = (NSUUID *)sub_100121F34();
    uint64_t v38 = "";
    _NRLogWithArgs(v24, 16LL, "%s%.30s:%-4d Identifier decryption failed: %@");
    uint64_t v33 = @"DecryptionFailure";
    goto LABEL_22;
  }

  if ([v15 length] != (id)96)
  {
    id v34 = sub_100121F34();
    int v35 = _NRLogIsLevelEnabled(v34, 16LL);

    if (!v35)
    {
      int v19 = 0LL;
      uint64_t v33 = @"IncorrectLength";
      goto LABEL_27;
    }

    uint64_t v24 = (NSUUID *)sub_100121F34();
    _NRLogWithArgs( v24,  16,  "%s%.30s:%-4d Decrypted identifier length %zu != %zu",  "",  "+[NRDLocalDevice decryptDeviceIdentifier:serviceIdentifier:ikeSession:]",  1204,  (size_t)[v15 length],  0x60uLL);
    uint64_t v33 = @"IncorrectLength";
    goto LABEL_22;
  }

  id v17 = (unsigned __int8 *)[v15 bytes];
  if (*v17 != 1)
  {
    id v36 = sub_100121F34();
    int v37 = _NRLogIsLevelEnabled(v36, 16LL);

    if (!v37)
    {
      int v19 = 0LL;
      uint64_t v33 = @"IncorrectVersion";
      goto LABEL_27;
    }

    uint64_t v24 = (NSUUID *)sub_100121F34();
    _NRLogWithArgs( v24,  16LL,  "%s%.30s:%-4d Unknown encrypted identifier version %u",  "",  "+[NRDLocalDevice decryptDeviceIdentifier:serviceIdentifier:ikeSession:]",  1211,  *v17);
    uint64_t v33 = @"IncorrectVersion";
    goto LABEL_22;
  }

  id v18 = objc_alloc_init(&OBJC_CLASS___NRDDecryptedIdentifier);
  int v19 = v18;
  if (v18) {
    v18->_version = *v17;
  }
  uint64_t v20 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v17 + 1);
  if (v19)
  {
    identity = v19->_identity;
    v19->_identity = v20;

    uint64_t v22 = v19->_identity;
  }

  else
  {

    uint64_t v22 = 0LL;
  }

  uint64_t v23 = (void *)qword_1001DCB80;
  uint64_t v24 = v22;
  id v25 = (NSUUID *)objc_claimAutoreleasedReturnValue([v23 objectForKeyedSubscript:v24]);
  if (!v19)
  {

    uint64_t v33 = @"NoDeviceFound";
LABEL_22:

    int v19 = 0LL;
LABEL_27:
    sub_1001030D0(@"NRDLocalDevice", @"EncryptedIdentifier", v33, 0, 0LL, v27, v28, v29, (uint64_t)v38);
    goto LABEL_13;
  }

  nrUUID = v19->_nrUUID;
  v19->_nrUUID = v25;

  if (!v19->_nrUUID)
  {
    uint64_t v33 = @"NoDeviceFound";
    goto LABEL_27;
  }

NSMutableData *sub_10012AAD8(NSMutableData *a1)
{
  uint64_t v1 = a1;
  if (a1)
  {
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    __int128 v24 = 0u;
    __int128 v23 = 0u;
    id v2 = (id)qword_1001DCB78;
    id v3 = [v2 countByEnumeratingWithState:&v23 objects:v28 count:16];
    if (v3)
    {
      id v4 = v3;
      uint64_t v5 = *(void *)v24;
      do
      {
        uint64_t v6 = 0LL;
        do
        {
          if (*(void *)v24 != v5) {
            objc_enumerationMutation(v2);
          }
          id v7 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( (id)qword_1001DCB78,  "objectForKeyedSubscript:",  *(void *)(*((void *)&v23 + 1) + 8 * (void)v6),  (void)v23));
          if (v7)
          {
            uint64_t v8 = v7[7];

            if (v8)
            {
              char v10 = 0;
              goto LABEL_15;
            }
          }

          uint64_t v6 = (char *)v6 + 1;
        }

        while (v4 != v6);
        id v9 = [v2 countByEnumeratingWithState:&v23 objects:v28 count:16];
        id v4 = v9;
      }

      while (v9);
    }

    char v10 = 1;
LABEL_15:

    if (v1[7].super.super.isa) {
      goto LABEL_20;
    }
    SecAccessControlRef v11 = objc_alloc_init(&OBJC_CLASS___NSUUID);
    if (v11)
    {
      SecAccessControlRef v12 = (NSMutableData *)v11;
      -[NSMutableData setLocalIdentity:](v1, "setLocalIdentity:", v11);
      p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
      [(id)qword_1001DCB80 setObject:v1[4].super.super.isa forKeyedSubscript:v12];
      uint64_t v14 = objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
      if ((sub_100128908(v14) & 1) != 0)
      {

LABEL_20:
        SecAccessControlRef v12 = -[NSMutableData initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableData), "initWithCapacity:", 48LL);
        -[objc_class getUUIDBytes:](v1[7].super.super.isa, "getUUIDBytes:", v27);
        -[NSMutableData appendBytes:length:](v12, "appendBytes:length:", v27, 16LL);
        id v15 = sub_100124E58((void *)qword_1001DCB88);
        if (v15)
        {
          -[NSMutableData appendData:](v12, "appendData:", v15);
          uint64_t v1 = v12;
        }

        else
        {
          uint64_t v1 = 0LL;
        }

        goto LABEL_23;
      }
    }

    else
    {
      id v17 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v17, 16LL);

      p_class_meths = (__objc2_meth_list **)"-[NRDLocalDevice copyDeviceIdentityPayload]";
      if (IsLevelEnabled)
      {
        id v19 = sub_100121F34();
        _NRLogWithArgs( v19,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (randomUUID) != ((void *)0)",  "",  "-[NRDLocalDevice copyDeviceIdentityPayload]",  1367);
      }

      uint64_t v1 = (NSMutableData *)_os_log_pack_size(12LL);
      SecAccessControlRef v12 = (NSMutableData *)((char *)&v23 - (((unint64_t)&v1[1].super.super.isa + 7) & 0xFFFFFFFFFFFFFFF0LL));
      uint64_t v20 = __error();
      uint64_t v21 = _os_log_pack_fill( v12,  v1,  *v20,  &_mh_execute_header,  "%{public}s Assertion Failed: (randomUUID) != ((void *)0)");
      *(_DWORD *)uint64_t v21 = 136446210;
      *(void *)(v21 + 4) = "-[NRDLocalDevice copyDeviceIdentityPayload]";
      id v22 = sub_100121F34();
      _NRLogAbortWithPack(v22, v12);
    }

    -[__objc2_meth_list setObject:forKeyedSubscript:]( p_class_meths[368],  "setObject:forKeyedSubscript:",  0LL,  v12,  (void)v23);
    -[NSMutableData setLocalIdentity:](v1, "setLocalIdentity:", 0LL);
    uint64_t v1 = 0LL;
LABEL_23:
  }

  return v1;
}

id sub_10012ADD4(void *a1, uint64_t a2)
{
  if (a1)
  {
    switch((_DWORD)a2)
    {
      case 1:
        id v3 = (void *)a1[11];
        return v3;
      case 3:
        id v3 = (void *)a1[10];
        return v3;
      case 4:
        id v3 = (void *)a1[9];
        return v3;
    }

    if (qword_1001DCBD8 != -1) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCBD0, 17LL))
    {
      if (qword_1001DCBD8 != -1) {
        dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
      }
      id v5 = (id)qword_1001DCBD0;
      id String = (void *)NRDataProtectionClassCreateString(a2);
      _NRLogWithArgs(v5, 17LL, "Cannot get keychain items for %@", String);
    }
  }

  return 0LL;
}

void sub_10012AEE0(uint64_t a1)
{
  if (a1 && !*(_BYTE *)(a1 + 24))
  {
    id v2 = *(void **)(a1 + 32);
    id v3 = *(id *)(a1 + 72);
    sub_100127630(v3, v2, 4LL);

    id v4 = *(id *)(a1 + 32);
    id v5 = *(id *)(a1 + 80);
    id v6 = *(id *)(a1 + 152);
    objc_opt_self(&OBJC_CLASS___NRDKeyManager);
    if (qword_1001DCC18 != -1) {
      dispatch_once(&qword_1001DCC18, &stru_1001B0910);
    }
    id v7 = (id)qword_1001DCC10;
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472LL;
    v11[2] = sub_10012B020;
    v11[3] = &unk_1001B0748;
    id v12 = v5;
    id v13 = v4;
    id v14 = v6;
    id v8 = v6;
    id v9 = v4;
    id v10 = v5;
    sub_100144478((uint64_t)v7, v11);
  }

void sub_10012B020(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (v2)
  {
    id v4 = *(id *)(a1 + 40);
    objc_opt_self(&OBJC_CLASS___NRDKeyManager);
    if (qword_1001DCC18 != -1) {
      dispatch_once(&qword_1001DCC18, &stru_1001B0910);
    }
    id v3 = (id)qword_1001DCC10;
    sub_1001462F4((uint64_t)v3, @"OOBK", v4, 3LL, 0LL);

    *(_BYTE *)(v2 + _Block_object_dispose(va, 8) = 1;
  }

void *sub_10012B0E8(void *a1)
{
  if (a1)
  {
    uint64_t v1 = (void *)a1[19];
    if (v1) {
      uint64_t v1 = (void *)v1[2];
    }
    a1 = v1;
  }

  return a1;
}

uint64_t sub_10012B114(uint64_t a1)
{
  if (qword_1001DCBD8 != -1) {
    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCBD0, 2LL))
  {
    if (qword_1001DCBD8 != -1) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    _NRLogWithArgs( qword_1001DCBD0,  2LL,  "%s%.30s:%-4d Checking for compatibility. flags:%llu local:%llu remote:%llu",  "",  "-[NRDLocalDevice compatible:]",  1474,  1LL,  *(void *)(a1 + 136),  *(void *)(a1 + 144));
  }

  if ((*(_BYTE *)(a1 + 136) & 1) != 0) {
    return *(_BYTE *)(a1 + 144) & 1;
  }
  else {
    return 0LL;
  }
}

BOOL sub_10012B1F4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 72);
  if (!v1)
  {
    id v3 = sub_100126FE0(objc_alloc(&OBJC_CLASS___NRDLDDataClassKeychainItems), 4LL);
    id v4 = *(void **)(a1 + 72);
    *(void *)(a1 + 72) = v3;

    if (!*(void *)(a1 + 72))
    {
      id v8 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 16LL);

      if (IsLevelEnabled)
      {
        id v10 = sub_100121F34();
        _NRLogWithArgs( v10,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (self.classDKeychainItems) != ((void *)0)",  "",  "-[NRDLocalDevice fillInClassDKeys]",  1485);
      }

      uint64_t v11 = _os_log_pack_size(12LL);
      id v12 = (char *)&v16 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v13 = __error();
      uint64_t v14 = _os_log_pack_fill( v12,  v11,  *v13,  &_mh_execute_header,  "%{public}s Assertion Failed: (self.classDKeychainItems) != ((void *)0)");
      *(_DWORD *)uint64_t v14 = 136446210;
      *(void *)(v14 + 4) = "-[NRDLocalDevice fillInClassDKeys]";
      id v15 = sub_100121F34();
      _NRLogAbortWithPack(v15, v12);
    }

    id v5 = *(id *)(a1 + 32);
    id v6 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 description]);
    sub_10011BB18(v5, 5005, v6, @"ClassD");
  }

  return v1 == 0;
}

void sub_10012B37C(id *a1, int a2, void *a3)
{
  if (a1)
  {
    id v6 = a1[4];
    id v7 = a3;
    id v8 = (id)objc_claimAutoreleasedReturnValue([a1 description]);
    sub_10011BB18(v6, a2, v8, v7);
  }

void sub_10012B3FC(uint64_t a1)
{
  uint64_t v2 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v2);

  if (qword_1001DCBD8 != -1) {
    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
  {
    if (qword_1001DCBD8 != -1) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    _NRLogWithArgs( qword_1001DCBD0,  0LL,  "%s%.30s:%-4d Filling in currently unlocked keys for %@",  "",  "-[NRDLocalDevice fillInKeysForCurrentlyUnlocked]",  1495LL,  a1);
  }

  BOOL v3 = sub_10012B1F4(a1);
  id v4 = *(id *)(a1 + 80);
  if (v4)
  {
    id v5 = v4;
LABEL_21:

    goto LABEL_22;
  }

  if ([(id)a1 hasSavedClassCKeysInKeychain])
  {
    id v5 = 0LL;
    goto LABEL_21;
  }

  objc_opt_self(&OBJC_CLASS___NRDKeyManager);
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  id v6 = (id)qword_1001DCC10;
  id v5 = v6;
  if (!v6) {
    goto LABEL_21;
  }
  dispatch_assert_queue_V2(*((dispatch_queue_t *)v6 + 2));
  if (!v5[10])
  {
    v5[10] = 1;
    if (v5[8] == 4)
    {
      sub_100143DD4((uint64_t)v5);
      if (v5[9])
      {
        v5[8] = 3;
        sub_100144044((uint64_t)v5);
      }
    }
  }

  int v7 = v5[8] & 0xFD;

  if (v7 == 1)
  {
    id v8 = sub_100126FE0(objc_alloc(&OBJC_CLASS___NRDLDDataClassKeychainItems), 3LL);
    id v9 = *(void **)(a1 + 80);
    *(void *)(a1 + 80) = v8;

    if (!*(void *)(a1 + 80))
    {
      id v23 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v23, 16LL);

      if (IsLevelEnabled)
      {
        id v25 = sub_100121F34();
        _NRLogWithArgs( v25,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (self.classCKeychainItems) != ((void *)0)",  "",  "-[NRDLocalDevice fillInKeysForCurrentlyUnlocked]",  1502);
      }

      uint64_t v26 = _os_log_pack_size(12LL);
      uint64_t v27 = (char *)&v31 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v28 = __error();
      uint64_t v29 = _os_log_pack_fill( v27,  v26,  *v28,  &_mh_execute_header,  "%{public}s Assertion Failed: (self.classCKeychainItems) != ((void *)0)");
      *(_DWORD *)uint64_t v29 = 136446210;
      *(void *)(v29 + 4) = "-[NRDLocalDevice fillInKeysForCurrentlyUnlocked]";
      id v30 = sub_100121F34();
      _NRLogAbortWithPack(v30, v27);
    }

    id v10 = *(id *)(a1 + 32);
    id v5 = (_BYTE *)objc_claimAutoreleasedReturnValue([(id)a1 description]);
    sub_10011BB18(v10, 5005, v5, @"ClassC");

    BOOL v3 = 1;
    goto LABEL_21;
  }

void sub_10012B7E0(char *a1, void *a2)
{
  id v3 = a2;
  id v4 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v4);

  if (!v3)
  {
    id v6 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 16LL);

    if (IsLevelEnabled)
    {
      id v8 = sub_100121F34();
      _NRLogWithArgs( v8,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (completionBlock) != ((void *)0)",  "",  "-[NRDLocalDevice fillInClassCKeysWithCompletion:]",  1525);
    }

    id v3 = (id)_os_log_pack_size(12LL);
    a1 = (char *)&v13[-1] - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v9 = __error();
    uint64_t v10 = _os_log_pack_fill( a1,  v3,  *v9,  &_mh_execute_header,  "%{public}s Assertion Failed: (completionBlock) != ((void *)0)");
    *(_DWORD *)uint64_t v10 = 136446210;
    *(void *)(v10 + 4) = "-[NRDLocalDevice fillInClassCKeysWithCompletion:]";
    id v11 = sub_100121F34();
    _NRLogAbortWithPack(v11, a1);
    goto LABEL_10;
  }

  if (!*((void *)a1 + 10))
  {
    objc_opt_self(&OBJC_CLASS___NRDKeyManager);
    if (qword_1001DCC18 == -1)
    {
LABEL_5:
      id v5 = (id)qword_1001DCC10;
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472LL;
      void v13[2] = sub_10012B9D4;
      v13[3] = &unk_1001B05A0;
      v13[4] = a1;
      id v14 = v3;
      sub_100144478((uint64_t)v5, v13);

      goto LABEL_6;
    }

uint64_t sub_10012B9D4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2 || !*(void *)(v2 + 80))
  {
    id v3 = sub_100126FE0(objc_alloc(&OBJC_CLASS___NRDLDDataClassKeychainItems), 3LL);
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4) {
      objc_storeStrong((id *)(v4 + 80), v3);
    }

    uint64_t v5 = *(void *)(a1 + 32);
    if (!v5 || !*(void *)(v5 + 80))
    {
      id v8 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 16LL);

      if (IsLevelEnabled)
      {
        id v10 = sub_100121F34();
        _NRLogWithArgs( v10,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (self.classCKeychainItems) != ((void *)0)",  "",  "-[NRDLocalDevice fillInClassCKeysWithCompletion:]_block_invoke",  1534);
      }

      uint64_t v11 = _os_log_pack_size(12LL);
      uint64_t v12 = (char *)&v16 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v13 = __error();
      uint64_t v14 = _os_log_pack_fill( v12,  v11,  *v13,  &_mh_execute_header,  "%{public}s Assertion Failed: (self.classCKeychainItems) != ((void *)0)");
      *(_DWORD *)uint64_t v14 = 136446210;
      *(void *)(v14 + 4) = "-[NRDLocalDevice fillInClassCKeysWithCompletion:]_block_invoke";
      id v15 = sub_100121F34();
      _NRLogAbortWithPack(v15, v12);
    }

    sub_10012B37C((id *)v5, 5005, @"ClassC");
    uint64_t v6 = objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
    sub_100128908(v6);
  }

  return (*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 40) + 16LL))(*(void *)(a1 + 40), 1LL);
}

void sub_10012BB64(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v4);

  if (!v3)
  {
    id v5 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16LL);

    if (IsLevelEnabled)
    {
      id v7 = sub_100121F34();
      _NRLogWithArgs( v7,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (completionBlock) != ((void *)0)",  "",  "-[NRDLocalDevice fillInClassAKeysWithCompletion:]",  1546);
    }

    uint64_t v8 = _os_log_pack_size(12LL);
    id v9 = (char *)&v14[-1] - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v10 = __error();
    uint64_t v11 = _os_log_pack_fill( v9,  v8,  *v10,  &_mh_execute_header,  "%{public}s Assertion Failed: (completionBlock) != ((void *)0)");
    *(_DWORD *)uint64_t v11 = 136446210;
    *(void *)(v11 + 4) = "-[NRDLocalDevice fillInClassAKeysWithCompletion:]";
    id v12 = sub_100121F34();
    _NRLogAbortWithPack(v12, v9);
  }

  if (*(void *)(a1 + 88))
  {
    v3[2](v3, 1LL);
  }

  else
  {
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472LL;
    v14[2] = sub_10012BCFC;
    v14[3] = &unk_1001B05C8;
    void v14[4] = a1;
    id v15 = v3;
    sub_10012B7E0((char *)a1, v14);
  }
}

uint64_t sub_10012BCFC(uint64_t a1, char a2)
{
  if ((a2 & 1) != 0)
  {
    id v3 = *(void **)(a1 + 32);
    if (v3)
    {
      if (v3[11])
      {
LABEL_13:
        id v15 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16LL);
        return v15();
      }

      id v3 = (void *)v3[10];
    }

    uint64_t v4 = v3;
    id v5 = [v4 copy];
    uint64_t v6 = *(void *)(a1 + 32);
    if (v6) {
      objc_storeStrong((id *)(v6 + 88), v5);
    }

    uint64_t v7 = *(void *)(a1 + 32);
    if (!v7 || (uint64_t v8 = *(void **)(v7 + 88)) == 0LL)
    {
      id v20 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v20, 16LL);

      if (IsLevelEnabled)
      {
        id v22 = sub_100121F34();
        _NRLogWithArgs( v22,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (self.classAKeychainItemsLegacyOnly) != ((void *)0)",  "",  "-[NRDLocalDevice fillInClassAKeysWithCompletion:]_block_invoke",  1562);
      }

      uint64_t v23 = _os_log_pack_size(12LL);
      __int128 v24 = (char *)&v28 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v25 = __error();
      uint64_t v26 = _os_log_pack_fill( v24,  v23,  *v25,  &_mh_execute_header,  "%{public}s Assertion Failed: (self.classAKeychainItemsLegacyOnly) != ((void *)0)");
      *(_DWORD *)uint64_t v26 = 136446210;
      *(void *)(v26 + 4) = "-[NRDLocalDevice fillInClassAKeysWithCompletion:]_block_invoke";
      id v27 = sub_100121F34();
      _NRLogAbortWithPack(v27, v24);
    }

    id v9 = v8;
    id v10 = (void *)v9[1];
    v9[1] = 0LL;

    uint64_t v11 = *(void *)(a1 + 32);
    if (v11)
    {
      id v12 = *(id *)(v11 + 88);
      if (v12)
      {
        uint64_t v13 = v12;
        uint64_t v14 = (void *)*((void *)v12 + 3);
        *((void *)v12 + 3) = 0LL;
      }
    }

    sub_10012B37C(*(id **)(a1 + 32), 5005, @"ClassA");
    goto LABEL_13;
  }

  id v17 = sub_100121F34();
  int v18 = _NRLogIsLevelEnabled(v17, 17LL);

  if (v18)
  {
    id v19 = sub_100121F34();
    _NRLogWithArgs(v19, 17LL, "Cannot fill in ClassA keys due to ClassC failure");
  }

  id v15 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16LL);
  return v15();
}

char *sub_10012BF24(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(a1);
  uint64_t v4 = objc_autoreleasePoolPush();
  if (!v3) {
    goto LABEL_10;
  }
  id v5 = v3[5];
  if (!v5 && !*((_BYTE *)v3 + 24))
  {
    if (*((_BYTE *)v3 + 20)) {
      goto LABEL_5;
    }
LABEL_10:
    uint64_t v6 = 0LL;
    goto LABEL_8;
  }

LABEL_5:
  uint64_t v6 = sub_100123CC0((char *)objc_alloc(&OBJC_CLASS___NRDLocalDevice), v3[4]);
  [v6 setBluetoothUUID:v3[5]];
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue([v3 dateCreated]);
  [v6 setDateCreated:v7];

  [v6 setIsEmptyPairing:1];
  if (v6)
  {
    v6[21] = 1;
    v6[24] = *((_BYTE *)v3 + 24);
  }

  [v6 setHasCompletedBluetoothPairing:*((unsigned __int8 *)v3 + 10)];
  [v6 setSelfManagedBluetoothPairing:*((unsigned __int8 *)v3 + 20)];
LABEL_8:
  objc_autoreleasePoolPop(v4);

  return v6;
}

uint64_t sub_10012C014(id *a1)
{
  uint64_t v1 = a1;
  if (!a1) {
    return (uint64_t)v1;
  }
  uint64_t v2 = objc_alloc(&OBJC_CLASS___NSMutableString);
  id v3 = v1[4];
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 UUIDString]);
  id v5 = -[NSMutableString initWithFormat:](v2, "initWithFormat:", @"NRDLD[%@]", v4);

  if (*((_WORD *)v1 + 14)) {
    goto LABEL_8;
  }
  id v6 = v1[14];
  if (v6 || (id v6 = v1[15]) != 0LL)
  {

LABEL_8:
    -[NSMutableString appendString:](v5, "appendString:", @"\n\t\t");
    int v7 = *((unsigned __int16 *)v1 + 14);
    BOOL v8 = *((_WORD *)v1 + 14) == 0;
    if (*((_WORD *)v1 + 14)) {
      -[NSMutableString appendFormat:]( v5,  "appendFormat:",  @"inner link version %u",  *((unsigned __int16 *)v1 + 14));
    }
    id v9 = v1[14];

    id v10 = ", ";
    if (v9)
    {
      if (v7) {
        uint64_t v11 = ", ";
      }
      else {
        uint64_t v11 = "";
      }
      id v12 = v1[14];
      -[NSMutableString appendFormat:](v5, "appendFormat:", @"%sname %@", v11, v12);

      BOOL v8 = 0;
    }

    id v13 = v1[15];

    if (v13)
    {
      if (v8) {
        uint64_t v14 = "";
      }
      else {
        uint64_t v14 = ", ";
      }
      id v15 = v1[15];
      -[NSMutableString appendFormat:](v5, "appendFormat:", @"%sbuild %@", v14, v15);

      BOOL v8 = 0;
    }

    if (*((_BYTE *)v1 + 18))
    {
      if (v8) {
        id v10 = "";
      }
      StringFromNRDeviceEndpointType = (void *)createStringFromNRDeviceEndpointType();
      -[NSMutableString appendFormat:](v5, "appendFormat:", @"%stype %@", v10, StringFromNRDeviceEndpointType);
    }

    goto LABEL_24;
  }

  if (*((_BYTE *)v1 + 18)) {
    goto LABEL_8;
  }
LABEL_24:
  id v17 = v1[5];

  if (v17)
  {
    id v18 = v1[5];
    id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 UUIDString]);
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tBluetoothUUID: %@", v19);
  }

  id v20 = v1[6];

  if (v20)
  {
    id v21 = v1[6];
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tIDSDeviceID: %@", v21);
  }

  if (*((_BYTE *)v1 + 8)) {
    id v22 = "";
  }
  else {
    id v22 = "un";
  }
  if (*((_BYTE *)v1 + 9)) {
    uint64_t v23 = "en";
  }
  else {
    uint64_t v23 = "dis";
  }
  -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\t%sregistered, %sabled", v22, v23);
  if (*((_BYTE *)v1 + 24)) {
    -[NSMutableString appendFormat:](v5, "appendFormat:", @", ephemeral");
  }
  if (*((_BYTE *)v1 + 15)) {
    __int128 v24 = "IDS";
  }
  else {
    __int128 v24 = "OOBK";
  }
  -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tinitially paired using %s", v24);
  id v25 = (void *)objc_claimAutoreleasedReturnValue([v1 dateCreated]);
  -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tcreated: %@", v25);

  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v1 dateRegistered]);
  if (v26)
  {
    id v27 = (void *)objc_claimAutoreleasedReturnValue([v1 dateRegistered]);
    -[NSMutableString appendFormat:](v5, "appendFormat:", @", registered: %@", v27);
  }

  uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v1 dateEnabled]);

  if (v28)
  {
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue([v1 dateEnabled]);
    -[NSMutableString appendFormat:](v5, "appendFormat:", @", enabled: %@", v29);
  }

  id v30 = v1[19];
  if (v30) {
    id v30 = (void *)v30[2];
  }
  uint64_t v31 = v30;
  Logid String = (void *)_NRKeyCreateLogString(v31);
  -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tOut of Band Key: %@", LogString);

  if (*((_BYTE *)v1 + 16)) {
    uint64_t v33 = @"YES";
  }
  else {
    uint64_t v33 = @"NO";
  }
  -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tIsAltAccount: %@", v33);
  if (*((_BYTE *)v1 + 17)) {
    id v34 = @"YES";
  }
  else {
    id v34 = @"NO";
  }
  -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tAlways On Wi-Fi: %@", v34);
  -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tDevice Flags: l %#llx r %#llx", v1[17], v1[18]);
  id v35 = v1[13];

  if (v35)
  {
    id v36 = v1[13];
    int v37 = (void *)_NRCreateMACAddressString();
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tBluetooth MAC Address: %@", v37);
  }

  id v38 = v1[16];

  if (v38)
  {
    id v39 = v1[16];
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tLocal Operational properties: %@", v39);
  }

  id v40 = v1[8];

  if (v40)
  {
    id v41 = v1[8];
    int v42 = v41;
    if (v41) {
      id v43 = (void *)*((void *)v41 + 2);
    }
    else {
      id v43 = 0LL;
    }
    id v44 = v43;
    id v45 = (void *)_NRKeyCreateLogString(v44);
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tRemote Identity Public Key: %@", v45);

    id v46 = v1[8];
    id v47 = v46;
    if (v46) {
      __int16 v48 = (void *)*((void *)v46 + 1);
    }
    else {
      __int16 v48 = 0LL;
    }
    id v49 = v48;
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tRemote Device Identity: %@", v49);
  }

  id v50 = v1[7];

  if (v50)
  {
    id v51 = v1[7];
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tLocal Device Identity: %@", v51);

    if (*((_BYTE *)v1 + 11)) {
      id v52 = @"YES";
    }
    else {
      id v52 = @"NO";
    }
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tHas Authenticated Using Identity: %@", v52);
  }

  id v53 = v1[9];
  id v54 = v53;
  if (v53) {
    id v55 = (void *)*((void *)v53 + 1);
  }
  else {
    id v55 = 0LL;
  }
  id v56 = v55;

  if (v56)
  {
    id v57 = v1[9];
    id v58 = v57;
    if (v57) {
      uint64_t v59 = (void *)*((void *)v57 + 1);
    }
    else {
      uint64_t v59 = 0LL;
    }
    __int128 v60 = v59;
    __int128 v61 = sub_100124E58(v60);
    id v62 = (void *)_NRKeyCreateLogString(v61);
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tClass D Remote Public Key: %@", v62);
  }

  id v63 = v1[9];
  id v64 = v63;
  if (v63) {
    __int128 v65 = (void *)*((void *)v63 + 2);
  }
  else {
    __int128 v65 = 0LL;
  }
  id v66 = v65;

  if (v66)
  {
    id v67 = v1[9];
    uint64_t v68 = v67;
    if (v67) {
      __int128 v69 = (void *)*((void *)v67 + 2);
    }
    else {
      __int128 v69 = 0LL;
    }
    uint64_t v70 = v69;
    nw_txt_record_t v71 = sub_100124E58(v70);
    id v72 = (void *)_NRKeyCreateLogString(v71);
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tClass D Local Public Key: %@", v72);
  }

  id v73 = v1[9];
  id v74 = v73;
  if (v73) {
    uint64_t v75 = (void *)*((void *)v73 + 3);
  }
  else {
    uint64_t v75 = 0LL;
  }
  id v76 = v75;

  if (v76)
  {
    __int128 v77 = (id *)v1[9];
    uint64_t v78 = v77;
    if (v77)
    {
      id v79 = v77[3];
      id v80 = v79;
      if (v79) {
        id v81 = (void *)*((void *)v79 + 2);
      }
      else {
        id v81 = 0LL;
      }
    }

    else
    {
      id v80 = 0LL;
      id v81 = 0LL;
    }

    id v82 = v81;
    id v83 = (void *)_NRKeyCreateLogString(v82);
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tClass D Shared Secret: %@", v83);
  }

  id v84 = v1[10];
  uint64_t v85 = v84;
  if (v84) {
    __int128 v86 = (void *)*((void *)v84 + 1);
  }
  else {
    __int128 v86 = 0LL;
  }
  id v87 = v86;

  if (v87)
  {
    id v88 = v1[10];
    __int128 v89 = v88;
    if (v88) {
      __int128 v90 = (void *)*((void *)v88 + 1);
    }
    else {
      __int128 v90 = 0LL;
    }
    __int128 v91 = v90;
    __int128 v92 = sub_100124E58(v91);
    __int128 v93 = (void *)_NRKeyCreateLogString(v92);
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tClass C Remote Public Key: %@", v93);
  }

  id v94 = v1[10];
  __int128 v95 = v94;
  if (v94) {
    __int128 v96 = (void *)*((void *)v94 + 2);
  }
  else {
    __int128 v96 = 0LL;
  }
  id v97 = v96;

  if (v97)
  {
    id v98 = v1[10];
    __int128 v99 = v98;
    if (v98) {
      __int128 v100 = (void *)*((void *)v98 + 2);
    }
    else {
      __int128 v100 = 0LL;
    }
    __int128 v101 = v100;
    __int128 v102 = sub_100124E58(v101);
    __int128 v103 = (void *)_NRKeyCreateLogString(v102);
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tClass C Local Public Key: %@", v103);
  }

  id v104 = v1[10];
  __int128 v105 = v104;
  if (v104) {
    __int128 v106 = (void *)*((void *)v104 + 3);
  }
  else {
    __int128 v106 = 0LL;
  }
  id v107 = v106;

  if (v107)
  {
    __int128 v108 = (id *)v1[10];
    __int128 v109 = v108;
    if (v108)
    {
      id v110 = v108[3];
      id v111 = v110;
      if (v110) {
        uint64_t v112 = (void *)*((void *)v110 + 2);
      }
      else {
        uint64_t v112 = 0LL;
      }
    }

    else
    {
      id v111 = 0LL;
      uint64_t v112 = 0LL;
    }

    id v113 = v112;
    BOOL v114 = (void *)_NRKeyCreateLogString(v113);
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tClass C Shared Secret: %@", v114);
  }

  id v115 = v1[11];
  id v116 = v115;
  if (v115) {
    id v117 = (void *)*((void *)v115 + 1);
  }
  else {
    id v117 = 0LL;
  }
  id v118 = v117;

  if (v118)
  {
    id v119 = v1[11];
    int v120 = v119;
    if (v119) {
      id v121 = (void *)*((void *)v119 + 1);
    }
    else {
      id v121 = 0LL;
    }
    uint64_t v122 = v121;
    id v123 = sub_100124E58(v122);
    id v124 = (void *)_NRKeyCreateLogString(v123);
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tClass A Remote Public Key: %@", v124);
  }

  id v125 = v1[11];
  id v126 = v125;
  if (v125) {
    int v127 = (void *)*((void *)v125 + 2);
  }
  else {
    int v127 = 0LL;
  }
  id v128 = v127;

  if (v128)
  {
    id v129 = v1[11];
    int v130 = v129;
    if (v129) {
      id v131 = (void *)*((void *)v129 + 2);
    }
    else {
      id v131 = 0LL;
    }
    uint64_t v132 = v131;
    id v133 = sub_100124E58(v132);
    id v134 = (void *)_NRKeyCreateLogString(v133);
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tClass A Local Public Key: %@", v134);
  }

  id v135 = v1[11];
  int v136 = v135;
  if (v135) {
    uint64_t v137 = (void *)*((void *)v135 + 3);
  }
  else {
    uint64_t v137 = 0LL;
  }
  id v138 = v137;

  if (v138)
  {
    id v139 = (id *)v1[11];
    uint64_t v140 = v139;
    if (v139)
    {
      id v141 = v139[3];
      int v142 = v141;
      if (v141) {
        id v143 = (void *)*((void *)v141 + 2);
      }
      else {
        id v143 = 0LL;
      }
    }

    else
    {
      int v142 = 0LL;
      id v143 = 0LL;
    }

    id v144 = v143;
    uint64_t v145 = (void *)_NRKeyCreateLogString(v144);
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tClass A Shared Secret: %@", v145);
  }

  id v146 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v146);

  id v147 = sub_10012CD2C(v1, @"0");
  if (v147)
  {
    id v148 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v148);

    uint64_t v149 = sub_10012CD2C(v1, @"0");
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tClass D Local Inner Endpoint: %@", v149);
  }

  id v150 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v150);

  int v151 = sub_10012D254(v1, @"0");
  if (v151)
  {
    id v152 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v152);

    uint64_t v153 = sub_10012D254(v1, @"0");
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tClass D Remote Inner Endpoint: %@", v153);
  }

  id v154 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v154);

  id v155 = (void *)sub_10012D45C(v1, @"0");
  if (v155)
  {
    id v156 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v156);

    id v157 = (void *)sub_10012D45C(v1, @"0");
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tClass C Local Inner Endpoint: %@", v157);
  }

  id v158 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v158);

  id v159 = sub_10012D610(v1, @"0");
  if (v159)
  {
    id v160 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v160);

    id v161 = sub_10012D610(v1, @"0");
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tClass C Remote Inner Endpoint: %@", v161);
  }

  if (*((_BYTE *)v1 + 12)) {
    id v162 = "D";
  }
  else {
    id v162 = "";
  }
  if (*((_BYTE *)v1 + 13)) {
    id v163 = "C";
  }
  else {
    id v163 = "";
  }
  if (*((_BYTE *)v1 + 14)) {
    id v164 = "A";
  }
  else {
    id v164 = "";
  }
  else {
    id v165 = "";
  }
  -[NSMutableString appendFormat:]( v5,  "appendFormat:",  @"\n\t\tKeys confirmed: %s%s%s, keys saved in keychain: %s",  v162,  v163,  v164,  v165);
  id v166 = v1[12];

  if (v166)
  {
    id v167 = v1[12];
    int32x4_t v168 = (void *)_NRCreateDataStringTruncated();
    -[NSMutableString appendFormat:](v5, "appendFormat:", @"\n\t\tReceived Proxy Notify Payload: %@", v168);
  }

  uint64_t v1 = v5;

  return (uint64_t)v1;
}

void *sub_10012CD2C(void *a1, void *a2)
{
  uint64_t v2 = a1;
  if (a1)
  {
    id v3 = a2;
    uint64_t v4 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v4);

    id v5 = (void *)objc_claimAutoreleasedReturnValue([v2 localInnerIPv6AddressBytesClassD]);
    if (!v5)
    {
      if (v2[16]) {
        BOOL v6 = sub_100107E48(v2) == 1;
      }
      else {
        BOOL v6 = 0;
      }
      uint64_t v7 = objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
      BOOL v8 = sub_100146AFC();
      dispatch_assert_queue_V2((dispatch_queue_t)v8);

      __int128 v40 = xmmword_100156950;
      BYTE9(v40) = 13;
      if (v6)
      {
        id v33 = v3;
        __int128 v38 = 0u;
        __int128 v39 = 0u;
        __int128 v36 = 0u;
        __int128 v37 = 0u;
        id v9 = (id)qword_1001DCB78;
        id v10 = [v9 countByEnumeratingWithState:&v36 objects:v41 count:16];
        if (v10)
        {
          id v11 = v10;
          uint64_t v12 = *(void *)v37;
          while (2)
          {
            for (unint64_t i = 0LL; i != v11; unint64_t i = (char *)i + 1)
            {
              if (*(void *)v37 != v12) {
                objc_enumerationMutation(v9);
              }
              id v17 = (void *)objc_claimAutoreleasedReturnValue( [(id)qword_1001DCB78 objectForKeyedSubscript:*(void *)(*((void *)&v36 + 1) + 8 * (void)i)]);
              id v18 = (void *)objc_claimAutoreleasedReturnValue([v17 localInnerIPv6AddressBytesClassD]);

              if (v18)
              {
                uint64_t v34 = 0LL;
                uint64_t v35 = 0LL;
                id v19 = (void *)objc_claimAutoreleasedReturnValue([v17 localInnerIPv6AddressBytesClassD]);
                id v20 = [v19 length];

                if (v20 != (id)16) {
                  goto LABEL_33;
                }
                id v21 = (void *)objc_claimAutoreleasedReturnValue([v17 localInnerIPv6AddressBytesClassD]);
                [v21 getBytes:&v34 length:16];

                objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
                if (WORD1(v35) && WORD2(v35))
                {
                  if (qword_1001DCBD8 != -1) {
                    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
                  }
                  if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
                  {
                    if (qword_1001DCBD8 != -1) {
                      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
                    }
                    id v23 = (id)qword_1001DCBD0;
                    __int128 v24 = (void *)objc_claimAutoreleasedReturnValue([v17 localInnerIPv6AddressBytesClassD]);
                    IPv6AddrStringFromData = (void *)createIPv6AddrStringFromData();
                    _NRLogWithArgs( v23,  0LL,  "%s%.30s:%-4d reusing valid address from %@ : %@",  "",  "+[NRDLocalDevice createNewLocalClassDAddrData:]",  3718LL,  v17,  IPv6AddrStringFromData);
                  }

void *sub_10012D254(void *a1, void *a2)
{
  uint64_t v2 = a1;
  if (a1)
  {
    id v3 = a2;
    uint64_t v4 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v4);

    id v5 = (void *)objc_claimAutoreleasedReturnValue([v2 remoteInnerIPv6AddressBytesClassD]);
    if (!v5)
    {
      if (v2[16]) {
        BOOL v6 = sub_100107E48(v2) == 1;
      }
      else {
        BOOL v6 = 0;
      }
      uint64_t v7 = objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
      BOOL v8 = sub_100146AFC();
      dispatch_assert_queue_V2((dispatch_queue_t)v8);

      __int128 v17 = xmmword_100156A00;
      if (v6) {
        sub_10012E200(v7, &v17);
      }
      else {
        HIBYTE(v17) = 2;
      }
      id v9 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v17, 16LL);
      [v2 setRemoteInnerIPv6AddressBytesClassD:v9];

      uint64_t v10 = objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
      sub_100128908(v10);
      if (qword_1001DCBD8 != -1) {
        dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
      {
        if (qword_1001DCBD8 != -1) {
          dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        }
        id v11 = (id)qword_1001DCBD0;
        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v2 remoteInnerIPv6AddressBytesClassD]);
        IPv6AddrStringFromData = (void *)createIPv6AddrStringFromData();
        _NRLogWithArgs( v11,  0LL,  "%s%.30s:%-4d Generated new remote classD inner address %@ for %@",  "",  "-[NRDLocalDevice copyRemoteClassDInnerEndpointWithPort:]",  3881LL,  IPv6AddrStringFromData,  v2);
      }
    }

    id v14 = (void *)objc_claimAutoreleasedReturnValue([v2 remoteInnerIPv6AddressBytesClassD]);
    id v15 = sub_10012D958((uint64_t)&OBJC_CLASS___NRDLocalDevice, v14, v3);
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(v15);
  }

  return v2;
}

uint64_t sub_10012D45C(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v4);

  id v5 = (void *)objc_claimAutoreleasedReturnValue([a1 localInnerIPv6AddressBytesClassC]);
  if (!v5)
  {
    __int128 v15 = 0uLL;
    sub_10012E070(a1, &v15);
    BYTE9(v15) = 12;
    BOOL v6 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v15, 16LL);
    [a1 setLocalInnerIPv6AddressBytesClassC:v6];

    uint64_t v7 = objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
    sub_100128908(v7);
    if (qword_1001DCBD8 != -1) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
    {
      if (qword_1001DCBD8 != -1) {
        dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
      }
      id v8 = (id)qword_1001DCBD0;
      id v9 = (void *)objc_claimAutoreleasedReturnValue([a1 localInnerIPv6AddressBytesClassC]);
      IPv6AddrStringFromData = (void *)createIPv6AddrStringFromData();
      _NRLogWithArgs( v8,  0LL,  "%s%.30s:%-4d Generated new local classC inner address %@ for %@",  "",  "-[NRDLocalDevice copyLocalClassCInnerEndpointWithPort:]",  3869LL,  IPv6AddrStringFromData,  a1);
    }
  }

  id v11 = (void *)objc_claimAutoreleasedReturnValue([a1 localInnerIPv6AddressBytesClassC]);
  id v12 = sub_10012D958((uint64_t)&OBJC_CLASS___NRDLocalDevice, v11, v3);
  uint64_t v13 = objc_claimAutoreleasedReturnValue(v12);

  return v13;
}

void *sub_10012D610(void *a1, void *a2)
{
  uint64_t v2 = a1;
  if (a1)
  {
    id v3 = a2;
    uint64_t v4 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v4);

    id v5 = (void *)objc_claimAutoreleasedReturnValue([v2 remoteInnerIPv6AddressBytesClassC]);
    if (!v5)
    {
      __int128 v14 = 0uLL;
      sub_10012D7C8(v2, &v14);
      BYTE9(v14) = 12;
      BOOL v6 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v14, 16LL);
      [v2 setRemoteInnerIPv6AddressBytesClassC:v6];

      uint64_t v7 = objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
      sub_100128908(v7);
      if (qword_1001DCBD8 != -1) {
        dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
      {
        if (qword_1001DCBD8 != -1) {
          dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        }
        id v8 = (id)qword_1001DCBD0;
        id v9 = (void *)objc_claimAutoreleasedReturnValue([v2 remoteInnerIPv6AddressBytesClassC]);
        IPv6AddrStringFromData = (void *)createIPv6AddrStringFromData();
        _NRLogWithArgs( v8,  0LL,  "%s%.30s:%-4d Generated new remote classC inner address %@ for %@",  "",  "-[NRDLocalDevice copyRemoteClassCInnerEndpointWithPort:]",  3896LL,  IPv6AddrStringFromData,  v2);
      }
    }

    id v11 = (void *)objc_claimAutoreleasedReturnValue([v2 remoteInnerIPv6AddressBytesClassC]);
    id v12 = sub_10012D958((uint64_t)&OBJC_CLASS___NRDLocalDevice, v11, v3);
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(v12);
  }

  return v2;
}

double sub_10012D7C8(void *a1, _OWORD *a2)
{
  uint64_t v4 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v4);

  if (!a2)
  {
    id v9 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 16LL);

    if (IsLevelEnabled)
    {
      id v11 = sub_100121F34();
      _NRLogWithArgs( v11,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (outBytes) != ((void *)0)",  "",  "-[NRDLocalDevice writeRemoteClassDInnerAddressBytes:]",  4038);
    }

    uint64_t v12 = _os_log_pack_size(12LL);
    uint64_t v13 = (char *)&v17 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    __int128 v14 = __error();
    uint64_t v15 = _os_log_pack_fill( v13,  v12,  *v14,  &_mh_execute_header,  "%{public}s Assertion Failed: (outBytes) != ((void *)0)");
    *(_DWORD *)uint64_t v15 = 136446210;
    *(void *)(v15 + 4) = "-[NRDLocalDevice writeRemoteClassDInnerAddressBytes:]";
    id v16 = sub_100121F34();
    _NRLogAbortWithPack(v16, v13);
  }

  uint64_t v18 = 0LL;
  __int128 v19 = 0uLL;
  int v20 = 0;
  id v5 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v5);

  BOOL v6 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v6);

  uint64_t v7 = sub_10012D254(a1, @"0");
  sub_10012DBE0((uint64_t)&OBJC_CLASS___NRDLocalDevice, &v18, v7);

  double result = *(double *)&v19;
  *a2 = v19;
  return result;
}

id sub_10012D958(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  objc_opt_self(a1);
  if (!v5)
  {
    id v10 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 16LL);

    if (IsLevelEnabled)
    {
      id v12 = sub_100121F34();
      _NRLogWithArgs( v12,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (addrData) != ((void *)0)",  "",  "+[NRDLocalDevice createEndpointFromAddrData:portString:]",  3558);
    }

    uint64_t v13 = _os_log_pack_size(12LL);
    __int128 v14 = &v24[-((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL)];
    uint64_t v15 = __error();
    uint64_t v16 = _os_log_pack_fill( v14,  v13,  *v15,  &_mh_execute_header,  "%{public}s Assertion Failed: (addrData) != ((void *)0)");
    *(_DWORD *)uint64_t v16 = 136446210;
    *(void *)(v16 + 4) = "+[NRDLocalDevice createEndpointFromAddrData:portString:]";
LABEL_13:
    id v23 = sub_100121F34();
    _NRLogAbortWithPack(v23, v14);
  }

  if ([v5 length] != (id)16)
  {
    id v17 = sub_100121F34();
    int v18 = _NRLogIsLevelEnabled(v17, 16LL);

    if (v18)
    {
      id v19 = sub_100121F34();
      _NRLogWithArgs( v19,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: addrData.length == sizeof(struct in6_addr)",  "",  "+[NRDLocalDevice createEndpointFromAddrData:portString:]",  3559);
    }

    uint64_t v20 = _os_log_pack_size(12LL);
    __int128 v14 = &v24[-((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL)];
    id v21 = __error();
    uint64_t v22 = _os_log_pack_fill( v14,  v20,  *v21,  &_mh_execute_header,  "%{public}s Assertion Failed: addrData.length == sizeof(struct in6_addr)");
    *(_DWORD *)uint64_t v22 = 136446210;
    *(void *)(v22 + 4) = "+[NRDLocalDevice createEndpointFromAddrData:portString:]";
    goto LABEL_13;
  }

  if (v6) {
    unsigned int v7 = bswap32([v6 intValue]) >> 16;
  }
  else {
    LOWORD(v7) = 0;
  }
  memset(&v25[2], 0, 24);
  v25[0] = 7708;
  v25[1] = v7;
  [v5 getBytes:&v25[4] length:16];
  id v8 = (void *)objc_claimAutoreleasedReturnValue(+[NWAddressEndpoint endpointWithAddress:](&OBJC_CLASS___NWAddressEndpoint, "endpointWithAddress:", v25));

  return v8;
}

void sub_10012DBE0(uint64_t a1, _OWORD *a2, void *a3)
{
  id v5 = a3;
  objc_opt_self(a1);
  id v6 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v6);

  if (!a2)
  {
    id v8 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 16LL);

    if (IsLevelEnabled)
    {
      id v10 = sub_100121F34();
      _NRLogWithArgs( v10,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (outSockAddrBytes) != ((void *)0)",  "",  "+[NRDLocalDevice writeSockAddrBytes:forEndpoint:]",  3958);
    }

    id v5 = (id)_os_log_pack_size(12LL);
    unsigned int v7 = (char *)&v36 - (((unint64_t)v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v11 = *__error();
    uint64_t v12 = _os_log_pack_fill( v7,  v5,  v11,  &_mh_execute_header,  "%{public}s Assertion Failed: (outSockAddrBytes) != ((void *)0)");
    goto LABEL_15;
  }

  if (!v5)
  {
    id v13 = sub_100121F34();
    int v14 = _NRLogIsLevelEnabled(v13, 16LL);

    if (v14)
    {
      id v15 = sub_100121F34();
      _NRLogWithArgs( v15,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (endpoint) != ((void *)0)",  "",  "+[NRDLocalDevice writeSockAddrBytes:forEndpoint:]",  3959);
    }

    id v5 = (id)_os_log_pack_size(12LL);
    unsigned int v7 = (char *)&v36 - (((unint64_t)v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v16 = *__error();
    uint64_t v12 = _os_log_pack_fill(v7, v5, v16, &_mh_execute_header, "%{public}s Assertion Failed: (endpoint) != ((void *)0)");
LABEL_15:
    *(_DWORD *)uint64_t v12 = 136446210;
    *(void *)(v12 + 4) = "+[NRDLocalDevice writeSockAddrBytes:forEndpoint:]";
    id v17 = sub_100121F34();
    _NRLogAbortWithPack(v17, v7);
    goto LABEL_16;
  }

  memset(v37, 0, 28);
  unsigned int v7 = (char *)objc_claimAutoreleasedReturnValue([v5 addressData]);
  if ((unint64_t)[v7 length] <= 0x1B)
  {
LABEL_16:
    id v18 = sub_100121F34();
    int v19 = _NRLogIsLevelEnabled(v18, 16LL);

    if (v19)
    {
      id v20 = sub_100121F34();
      _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: addressData.length >= sizeof(sin6); Bad addressData %@ %@",
        "",
        "+[NRDLocalDevice writeSockAddrBytes:forEndpoint:]",
        3962LL,
        v7,
        v5);
    }

    uint64_t v21 = _os_log_pack_size(32LL);
    uint64_t v22 = (char *)&v36 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v23 = *__error();
    uint64_t v24 = _os_log_pack_fill( v22,  v21,  v23,  &_mh_execute_header,  "%{public}s Assertion Failed: addressData.length >= sizeof(sin6); Bad addressData %@ %@");
    goto LABEL_25;
  }

  [v7 getBytes:v37 length:28];
  if (BYTE1(v37[0]) != 30)
  {
    id v25 = sub_100121F34();
    int v26 = _NRLogIsLevelEnabled(v25, 16LL);

    if (v26)
    {
      id v27 = sub_100121F34();
      _NRLogWithArgs( v27,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: sin6.sin6_family == 30; Bad address family localInnerAddressData %@ %@",
        "",
        "+[NRDLocalDevice writeSockAddrBytes:forEndpoint:]",
        3965LL,
        v7,
        v5);
    }

    uint64_t v28 = _os_log_pack_size(32LL);
    uint64_t v22 = (char *)&v36 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v29 = __error();
    uint64_t v24 = _os_log_pack_fill( v22,  v28,  *v29,  &_mh_execute_header,  "%{public}s Assertion Failed: sin6.sin6_family == 30; Bad address family localInnerAddressData %@ %@");
    *(_DWORD *)uint64_t v24 = 136446722;
    *(void *)(v24 + 4) = "+[NRDLocalDevice writeSockAddrBytes:forEndpoint:]";
LABEL_26:
    *(_WORD *)(v24 + 12) = 2112;
    *(void *)(v24 + 14) = v7;
    *(_WORD *)(v24 + 22) = 2112;
    *(void *)(v24 + 24) = v5;
    id v35 = sub_100121F34();
    _NRLogAbortWithPack(v35, v22);
  }

  if (LOBYTE(v37[0]) <= 0x1Bu)
  {
    id v30 = sub_100121F34();
    int v31 = _NRLogIsLevelEnabled(v30, 16LL);

    if (v31)
    {
      id v32 = sub_100121F34();
      _NRLogWithArgs( v32,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: sin6.sin6_len >= sizeof(sin6); Bad sa_len localInnerAddressData %@ %@",
        "",
        "+[NRDLocalDevice writeSockAddrBytes:forEndpoint:]",
        3966LL,
        v7,
        v5);
    }

    uint64_t v33 = _os_log_pack_size(32LL);
    uint64_t v22 = (char *)&v36 - ((v33 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v34 = *__error();
    uint64_t v24 = _os_log_pack_fill( v22,  v33,  v34,  &_mh_execute_header,  "%{public}s Assertion Failed: sin6.sin6_len >= sizeof(sin6); Bad sa_len localInnerAddressData %@ %@");
LABEL_25:
    *(_DWORD *)uint64_t v24 = 136446722;
    *(void *)(v24 + 4) = "+[NRDLocalDevice writeSockAddrBytes:forEndpoint:]";
    goto LABEL_26;
  }

  if (LOBYTE(v37[0]) != 28) {
    LOBYTE(v37[0]) = 28;
  }
  *a2 = v37[0];
  *(_OWORD *)((char *)a2 + 12) = *(_OWORD *)((char *)v37 + 12);
}

double sub_10012E070(void *a1, _OWORD *a2)
{
  uint64_t v4 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v4);

  if (!a2)
  {
    id v9 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 16LL);

    if (IsLevelEnabled)
    {
      id v11 = sub_100121F34();
      _NRLogWithArgs( v11,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (outBytes) != ((void *)0)",  "",  "-[NRDLocalDevice writeLocalClassDInnerAddressBytes:]",  4006);
    }

    uint64_t v12 = _os_log_pack_size(12LL);
    id v13 = (char *)&v17 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v14 = __error();
    uint64_t v15 = _os_log_pack_fill( v13,  v12,  *v14,  &_mh_execute_header,  "%{public}s Assertion Failed: (outBytes) != ((void *)0)");
    *(_DWORD *)uint64_t v15 = 136446210;
    *(void *)(v15 + 4) = "-[NRDLocalDevice writeLocalClassDInnerAddressBytes:]";
    id v16 = sub_100121F34();
    _NRLogAbortWithPack(v16, v13);
  }

  uint64_t v18 = 0LL;
  __int128 v19 = 0uLL;
  int v20 = 0;
  id v5 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v5);

  id v6 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v6);

  unsigned int v7 = sub_10012CD2C(a1, @"0");
  sub_10012DBE0((uint64_t)&OBJC_CLASS___NRDLocalDevice, &v18, v7);

  double result = *(double *)&v19;
  *a2 = v19;
  return result;
}

void sub_10012E200(uint64_t a1, _WORD *a2)
{
  id v3 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v3);

  uint64_t v4 = a2 + 5;
  id v16 = a2 + 5;
  uint64_t v17 = a2;
  do
  {
    do
LABEL_6:
      arc4random_buf(v4, 6uLL);
    while (!*v4);
  }

  while (!a2[6] || !a2[7]);
  id v5 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a2, 16LL);
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  __int128 v22 = 0u;
  id obj = (id)qword_1001DCB78;
  id v6 = [obj countByEnumeratingWithState:&v19 objects:v23 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v20;
    do
    {
      id v9 = 0LL;
      do
      {
        if (*(void *)v20 != v8) {
          objc_enumerationMutation(obj);
        }
        id v10 = (void *)objc_claimAutoreleasedReturnValue( [(id)qword_1001DCB78 objectForKeyedSubscript:*(void *)(*((void *)&v19 + 1) + 8 * (void)v9)]);
        id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 localInnerIPv6AddressBytesClassD]);
        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v10 remoteInnerIPv6AddressBytesClassD]);
        id v13 = (void *)objc_claimAutoreleasedReturnValue([v10 localInnerIPv6AddressBytesClassC]);
        if ([v13 isEqual:v5])
        {

LABEL_3:
LABEL_4:

LABEL_5:
          uint64_t v4 = v16;
          a2 = v17;
          goto LABEL_6;
        }

        int v14 = (void *)objc_claimAutoreleasedReturnValue([v10 remoteInnerIPv6AddressBytesClassC]);
        unsigned __int8 v15 = [v14 isEqual:v5];

        if ((v15 & 1) != 0) {
          goto LABEL_5;
        }

        id v9 = (char *)v9 + 1;
      }

      while (v7 != v9);
      id v7 = [obj countByEnumeratingWithState:&v19 objects:v23 count:16];
    }

    while (v7);
  }
}

void *sub_10012E41C(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v2);

    return sub_10012D254(v1, @"0");
  }

  return result;
}

void *sub_10012E45C(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v2);

    return sub_10012D610(v1, @"0");
  }

  return result;
}

char *sub_10012E49C(uint64_t a1)
{
  uint64_t v1 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v1);

  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NSUUID);
  if (!v2)
  {
    id v9 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 16LL);

    if (IsLevelEnabled)
    {
      id v11 = sub_100121F34();
      _NRLogWithArgs( v11,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (randomUUID) != ((void *)0)",  "",  "+[NRDLocalDevice newLocalDeviceWithRandomNRUUID]",  2099);
    }

    id v3 = (NSUUID *)_os_log_pack_size(12LL);
    uint64_t v12 = (char *)&v16 - (((unint64_t)&v3[1].super.isa + 7) & 0xFFFFFFFFFFFFFFF0LL);
    id v13 = __error();
    uint64_t v14 = _os_log_pack_fill( v12,  v3,  *v13,  &_mh_execute_header,  "%{public}s Assertion Failed: (randomUUID) != ((void *)0)");
    *(_DWORD *)uint64_t v14 = 136446210;
    *(void *)(v14 + 4) = "+[NRDLocalDevice newLocalDeviceWithRandomNRUUID]";
    id v15 = sub_100121F34();
    _NRLogAbortWithPack(v15, v12);
    goto LABEL_9;
  }

  id v3 = v2;
  uint64_t v4 = objc_alloc(&OBJC_CLASS___NRDLocalDevice);
  if (!v4)
  {
LABEL_9:
    id v5 = 0LL;
    goto LABEL_5;
  }

  id v5 = sub_100123CC0((char *)v4, v3);
  sub_100124478(v5);
  if (v5)
  {
    v5[21] = 1;
    id v6 = *((id *)v5 + 4);
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v5 description]);
    sub_10011BB18(v6, 5000, v7, 0LL);
  }

char *sub_10012E648(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_self(a1);
  if (!v3)
  {
    id v26 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v26, 17LL);

    if (IsLevelEnabled)
    {
      id v28 = sub_100121F34();
      _NRLogWithArgs(v28, 17LL, "%s called with null bluetoothUUID");
LABEL_39:

      uint64_t v24 = 0LL;
      goto LABEL_34;
    }

char *sub_10012EA10(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  uint64_t v6 = objc_opt_self(a1);
  if (v5)
  {
    uint64_t v7 = v6;
    id v8 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v8);

    sub_100127AFC(v7);
    __int128 v32 = 0u;
    __int128 v33 = 0u;
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    id v9 = (id)qword_1001DCB78;
    id v10 = [v9 countByEnumeratingWithState:&v30 objects:v34 count:16];
    if (v10)
    {
      id v11 = v10;
      uint64_t v12 = *(void *)v31;
LABEL_4:
      uint64_t v13 = 0LL;
      while (1)
      {
        if (*(void *)v31 != v12) {
          objc_enumerationMutation(v9);
        }
        uint64_t v14 = objc_claimAutoreleasedReturnValue( [(id)qword_1001DCB78 objectForKeyedSubscript:*(void *)(*((void *)&v30 + 1) + 8 * v13)]);
        id v15 = (char *)v14;
        uint64_t v16 = v14 ? *(void *)(v14 + 48) : 0LL;

        if (v11 == (id)++v13)
        {
          id v17 = [v9 countByEnumeratingWithState:&v30 objects:v34 count:16];
          id v11 = v17;
          if (v17) {
            goto LABEL_4;
          }
          goto LABEL_14;
        }
      }
    }

    else
    {
LABEL_14:
      id v15 = 0LL;
    }

    if (v15 || !a3) {
      goto LABEL_27;
    }
    id v15 = sub_10012E49C(v7);
    if (qword_1001DCBD8 != -1) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    if (!_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
    {
LABEL_24:
      [v15 setIdsDeviceID:v5];
      if (v15) {
        uint64_t v23 = *((void *)v15 + 4);
      }
      else {
        uint64_t v23 = 0LL;
      }
      [(id)qword_1001DCB78 setObject:v15 forKeyedSubscript:v23];
      uint64_t v24 = objc_opt_self(v7);
      sub_100128908(v24);
LABEL_27:
      id v25 = v15;
      if (qword_1001DCBD8 != -1) {
        dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
      {
        if (qword_1001DCBD8 != -1) {
          dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        }
        _NRLogWithArgs( qword_1001DCBD0,  0LL,  "%s%.30s:%-4d Returning %@ for IDSDeviceID query %@",  "",  "+[NRDLocalDevice copyLocalDeviceForIDSDeviceID:shouldCreate:]",  2211LL,  v25,  v5);
      }

      goto LABEL_34;
    }

    if (qword_1001DCBD8 == -1)
    {
      id v18 = (void *)qword_1001DCBD0;
      if (v15)
      {
LABEL_22:
        id v19 = (void *)*((void *)v15 + 4);
LABEL_23:
        id v20 = v19;
        id v21 = v18;
        uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v20 UUIDString]);
        _NRLogWithArgs( v21,  0LL,  "%s%.30s:%-4d Creating new local device with random %@ for IDSDeviceID query %@",  "",  "+[NRDLocalDevice copyLocalDeviceForIDSDeviceID:shouldCreate:]",  2205LL,  v22,  v5);

        goto LABEL_24;
      }
    }

    else
    {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
      id v18 = (void *)qword_1001DCBD0;
      if (v15) {
        goto LABEL_22;
      }
    }

    id v19 = 0LL;
    goto LABEL_23;
  }

  id v27 = sub_100121F34();
  int IsLevelEnabled = _NRLogIsLevelEnabled(v27, 17LL);

  if (IsLevelEnabled)
  {
    id v29 = sub_100121F34();
    _NRLogWithArgs( v29,  17LL,  "%s called with null idsDeviceID",  "+[NRDLocalDevice copyLocalDeviceForIDSDeviceID:shouldCreate:]");
  }

  id v25 = 0LL;
LABEL_34:

  return v25;
}

void sub_10012ED8C( uint64_t a1, void *a2, uint64_t a3, int a4, unsigned int a5, void *a6, void *a7, int a8, void *a9, void *a10, void *a11, void *a12, void *a13)
{
  int v107 = a4;
  LODWORD(v10_Block_object_dispose(va, 8) = a8;
  unsigned int v109 = a5;
  uint64_t v106 = a3;
  uint64_t v16 = a2;
  id v111 = a6;
  id v110 = a9;
  id v112 = a10;
  id v17 = a11;
  id v18 = a12;
  id v19 = a13;
  uint64_t v20 = objc_opt_self(a1);
  id v21 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v21);

  if (!v16)
  {
    id v85 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v85, 17LL);

    a7 = v110;
    uint64_t v22 = v111;
    if (!IsLevelEnabled) {
      goto LABEL_118;
    }
    id v87 = sub_100121F34();
    _NRLogWithArgs(v87, 17LL, "%s called with null nrUUID");
    goto LABEL_140;
  }

  if ((_NRIsUUIDNonZero(v16) & 1) != 0)
  {
    uint64_t v22 = v111;
    if (v19)
    {
      if (!v111 && (v109 & 1) == 0)
      {
        if (qword_1001DCBD8 != -1) {
          dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        }
        a7 = v110;
        if (_NRLogIsLevelEnabled(qword_1001DCBD0, 17LL))
        {
          if (qword_1001DCBD8 != -1) {
            dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
          }
          _NRLogWithArgs( qword_1001DCBD0,  17LL,  "outOfBandKey was nil and !wasInitiallySetupUsingIDSPairing for NRUUID %@",  v16);
        }

        v19[2](v19, 22LL, @"outOfBandKey was nil and !wasInitiallySetupUsingIDSPairing");
        goto LABEL_118;
      }

      if ((_DWORD)a7)
      {
        if (qword_1001DCBD8 != -1) {
          dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        }
        a7 = v110;
        p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
        if (qword_1001DCBD8 == -1)
        {
LABEL_18:
          _NRLogWithArgs(p_class_meths[378], 17LL, "pairWithSPPLink is not supported");
LABEL_19:
          v19[2](v19, 22LL, @"pairWithSPPLink is not supported");
          goto LABEL_118;
        }

LABEL_144:
        dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        goto LABEL_18;
      }

      uint64_t v104 = v20;
      uint64_t v24 = sub_100129B30(v20, v16);
      if (!v24)
      {
        id v93 = sub_100121F34();
        int v94 = _NRLogIsLevelEnabled(v93, 16LL);

        if (v94)
        {
          id v95 = sub_100121F34();
          _NRLogWithArgs( v95,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice registerDeviceWithNRUUID:pairingProtocolVersion:peerNetworkRelayVersion:wasInitiallySetupUs ingIDSPairing:outOfBandKey:pairWithSPPLink:isAltAccountPairing:bluetoothMACAddress:operationalProperties:pee rEndpointDictionary:candidateService:completionBlock:]",  2354);
        }

        uint64_t v96 = _os_log_pack_size(12LL);
        p_class_meths = (__objc2_meth_list **)((char *)&v101 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL));
        id v97 = __error();
        uint64_t v98 = _os_log_pack_fill( p_class_meths,  v96,  *v97,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
        *(_DWORD *)uint64_t v98 = 136446210;
        *(void *)(v98 + 4) = "+[NRDLocalDevice registerDeviceWithNRUUID:pairingProtocolVersion:peerNetworkRelayVersion:"
                               "wasInitiallySetupUsingIDSPairing:outOfBandKey:pairWithSPPLink:isAltAccountPairing:bluetoo"
                               "thMACAddress:operationalProperties:peerEndpointDictionary:candidateService:completionBlock:]";
        id v99 = sub_100121F34();
        _NRLogAbortWithPack(v99, p_class_meths);
        goto LABEL_144;
      }

      id v25 = v24;
      [v24 setIsEmptyPairing:0];
      [v25 setOperationalProp:v112];
      if (v25[8])
      {
        a7 = v110;
        if (v25[9])
        {
          if (qword_1001DCBD8 != -1) {
            dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
          {
            if (qword_1001DCBD8 != -1) {
              dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
            }
            _NRLogWithArgs( qword_1001DCBD0,  0LL,  "%s%.30s:%-4d Skipping registration of already registered enabled device %@",  "",  "+[NRDLocalDevice registerDeviceWithNRUUID:pairingProtocolVersion:peerNetworkRelayVersion:wasInitiallySetup UsingIDSPairing:outOfBandKey:pairWithSPPLink:isAltAccountPairing:bluetoothMACAddress:operationalProperties :peerEndpointDictionary:candidateService:completionBlock:]",  2359LL,  v25);
          }

          v19[2](v19, 0LL, 0LL);
        }

        else
        {
          if (qword_1001DCBD8 != -1) {
            dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
          {
            if (qword_1001DCBD8 != -1) {
              dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
            }
            _NRLogWithArgs( qword_1001DCBD0,  0LL,  "%s%.30s:%-4d Enabling device due to registration of already registered disabled device %@",  "",  "+[NRDLocalDevice registerDeviceWithNRUUID:pairingProtocolVersion:peerNetworkRelayVersion:wasInitiallySetup UsingIDSPairing:outOfBandKey:pairWithSPPLink:isAltAccountPairing:bluetoothMACAddress:operationalProperties :peerEndpointDictionary:candidateService:completionBlock:]",  2362LL,  v25);
          }

          sub_10012FC24(v104, v16, v19);
        }

LABEL_117:
        goto LABEL_118;
      }

      a7 = v110;
      if (v111)
      {
        uint64_t v26 = *((void *)v25 + 19);
        if (v26)
        {
          id v27 = v111;
          id v28 = *(void **)(v26 + 16);
          *(void *)(v26 + 16) = v27;
        }

        else
        {
          id v29 = sub_1001242A0((char *)objc_alloc(&OBJC_CLASS___NRDLDKeychainItemData), v111);
          id v28 = (void *)*((void *)v25 + 19);
          *((void *)v25 + 19) = v29;
        }
      }

      [v25 setIsAltAccountDevice:v108];
      if (a7) {
        [v25 setBluetoothMACAddress:a7];
      }
      id v103 = v17;
      id v108 = v18;
      __int128 v105 = (id *)v25;
      if (v17)
      {
        if (qword_1001DCBD8 != -1) {
          dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        }
        __int128 v102 = v16;
        if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
        {
          if (qword_1001DCBD8 != -1) {
            dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
          }
          _NRLogWithArgs( qword_1001DCBD0,  0LL,  "%s%.30s:%-4d peer ip addr: %@",  "",  "+[NRDLocalDevice registerDeviceWithNRUUID:pairingProtocolVersion:peerNetworkRelayVersion:wasInitiallySetupUs ingIDSPairing:outOfBandKey:pairWithSPPLink:isAltAccountPairing:bluetoothMACAddress:operationalProperties:pee rEndpointDictionary:candidateService:completionBlock:]",  2382LL,  v17);
        }

        __int128 v30 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        __int128 v31 = v17;
        __int128 v32 = v30;
        __int128 v117 = 0u;
        __int128 v118 = 0u;
        __int128 v119 = 0u;
        __int128 v120 = 0u;
        id v33 = v31;
        id v34 = [v33 countByEnumeratingWithState:&v117 objects:v122 count:16];
        if (v34)
        {
          id v35 = v34;
          uint64_t v36 = *(void *)v118;
          do
          {
            for (unint64_t i = 0LL; i != v35; unint64_t i = (char *)i + 1)
            {
              if (*(void *)v118 != v36) {
                objc_enumerationMutation(v33);
              }
              __int128 v38 = *(void **)(*((void *)&v117 + 1) + 8LL * (void)i);
              __int128 v39 = (void *)objc_claimAutoreleasedReturnValue([v33 objectForKeyedSubscript:v38]);
              __int128 v40 = v38;
              if ([v40 unsignedShortValue] == 2)
              {

                __int128 v40 = &off_1001BC8B0;
              }

              -[NSMutableDictionary setObject:forKeyedSubscript:](v32, "setObject:forKeyedSubscript:", v39, v40);
            }

            id v35 = [v33 countByEnumeratingWithState:&v117 objects:v122 count:16];
          }

          while (v35);
        }

        id v41 = (void *)qword_1001DCB98;
        if (!qword_1001DCB98)
        {
          int v42 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
          id v43 = (void *)qword_1001DCB98;
          qword_1001DCB98 = (uint64_t)v42;

          id v41 = (void *)qword_1001DCB98;
        }

        uint64_t v16 = v102;
        [v41 setObject:v32 forKeyedSubscript:v102];

        a7 = v110;
        uint64_t v22 = v111;
        id v18 = v108;
        id v25 = (char *)v105;
      }

      if (v18)
      {
        id v44 = (void *)qword_1001DCBA0;
        if (!qword_1001DCBA0)
        {
          id v45 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
          id v46 = (void *)qword_1001DCBA0;
          qword_1001DCBA0 = (uint64_t)v45;

          id v44 = (void *)qword_1001DCBA0;
        }

        __int128 v115 = 0u;
        __int128 v116 = 0u;
        __int128 v113 = 0u;
        __int128 v114 = 0u;
        id v47 = (void *)objc_claimAutoreleasedReturnValue([v44 allValues]);
        id v48 = [v47 countByEnumeratingWithState:&v113 objects:v121 count:16];
        if (v48)
        {
          id v49 = v48;
          uint64_t v50 = *(void *)v114;
          while (2)
          {
            for (j = 0LL; j != v49; j = (char *)j + 1)
            {
              if (*(void *)v114 != v50) {
                objc_enumerationMutation(v47);
              }
              if ([*(id *)(*((void *)&v113 + 1) + 8 * (void)j) isEqualToString:v108])
              {
                if (qword_1001DCBD8 != -1) {
                  dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
                }
                id v18 = v108;
                id v25 = (char *)v105;
                if (_NRLogIsLevelEnabled(qword_1001DCBD0, 16LL))
                {
                  id v61 = sub_100121F34();
                  _NRLogWithArgs( v61,  16LL,  "%s%.30s:%-4d service %@ already exists",  "",  "+[NRDLocalDevice registerDeviceWithNRUUID:pairingProtocolVersion:peerNetworkRelayVersion:wasInitiall ySetupUsingIDSPairing:outOfBandKey:pairWithSPPLink:isAltAccountPairing:bluetoothMACAddress:operation alProperties:peerEndpointDictionary:candidateService:completionBlock:]",  2404LL,  v108);
                }

                v19[2](v19, 22LL, @"service already exists");

                id v17 = v103;
                goto LABEL_117;
              }
            }

            id v49 = [v47 countByEnumeratingWithState:&v113 objects:v121 count:16];
            if (v49) {
              continue;
            }
            break;
          }
        }

        [(id)qword_1001DCBA0 setObject:v108 forKeyedSubscript:v16];
        id v25 = (char *)v105;
      }

      Logid String = (void *)_NRKeyCreateLogString(v22);
      uint64_t v52 = v106;
      sub_10012FF4C(v25, 5001, @"ppv=%lld, %sOOBK %@", v53, v54, v55, v56, v57, v106);

      id v58 = v16;
      objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
      if (qword_1001DCB90)
      {
        uint64_t v59 = (NRAnalyticsLocalDevice *)objc_claimAutoreleasedReturnValue([(id)qword_1001DCB90 objectForKeyedSubscript:v58]);

        if (v59)
        {
          uint64_t v60 = mach_absolute_time();
LABEL_85:
          v59->_deviceRegistrationStart = v60;
          v59->_devicePairedWithOOBKey = v105[19] != 0LL;
LABEL_86:
          id v62 = v59;
          id v63 = v58;
          objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
          if (v62)
          {
            id v64 = (void *)qword_1001DCB90;
            if (!qword_1001DCB90)
            {
              __int128 v65 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
              id v66 = (void *)qword_1001DCB90;
              qword_1001DCB90 = (uint64_t)v65;

              id v64 = (void *)qword_1001DCB90;
            }

            [v64 setObject:v62 forKeyedSubscript:v63];
          }

          sub_10012B3FC((uint64_t)v105);
          [v105 setWasInitiallySetupUsingIDSPairing:v109];
          if (v52) {
            [v105 setPairingProtocolVersion:v52];
          }
          if (v107) {
            objc_msgSend(v105, "setLastSeenInnerLinkVersionHBO:");
          }
          [v105 setIsEnabled:1];
          sub_100128884((uint64_t)&OBJC_CLASS___NRDLocalDevice, v105);
          id v67 = v105[19];
          __int128 v102 = v62;
          if (v67 || v105[6])
          {
            uint64_t v68 = (void *)qword_1001DCBC0;
            if (!qword_1001DCBC0)
            {
              __int128 v69 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
              uint64_t v70 = (void *)qword_1001DCBC0;
              qword_1001DCBC0 = (uint64_t)v69;

              uint64_t v68 = (void *)qword_1001DCBC0;
            }

            nw_txt_record_t v71 = (NSMutableArray *)objc_claimAutoreleasedReturnValue([v68 objectForKeyedSubscript:v63]);
            a7 = v110;
            uint64_t v22 = v111;
            if (!v71) {
              nw_txt_record_t v71 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
            }
            if (qword_1001DCBD8 != -1) {
              dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
            }
            if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
            {
              if (qword_1001DCBD8 != -1) {
                dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
              }
              _NRLogWithArgs( qword_1001DCBD0,  0LL,  "%s%.30s:%-4d Started registration for %@",  "",  "+[NRDLocalDevice registerDeviceWithNRUUID:pairingProtocolVersion:peerNetworkRelayVersion:wasInitiallySet upUsingIDSPairing:outOfBandKey:pairWithSPPLink:isAltAccountPairing:bluetoothMACAddress:operationalProper ties:peerEndpointDictionary:candidateService:completionBlock:]",  2447LL,  v105);
            }

            id v72 = objc_retainBlock(v19);
            -[NSMutableArray addObject:](v71, "addObject:", v72);

            [(id)qword_1001DCBC0 setObject:v71 forKeyedSubscript:v63];
            char v73 = 1;
          }

          else
          {
            [v105 setIsRegistered:1];
            if (qword_1001DCBD8 != -1) {
              dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
            }
            if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
            {
              if (qword_1001DCBD8 != -1) {
                dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
              }
              _NRLogWithArgs( qword_1001DCBD0,  0LL,  "%s%.30s:%-4d Registered %@",  "",  "+[NRDLocalDevice registerDeviceWithNRUUID:pairingProtocolVersion:peerNetworkRelayVersion:wasInitiallySet upUsingIDSPairing:outOfBandKey:pairWithSPPLink:isAltAccountPairing:bluetoothMACAddress:operationalProper ties:peerEndpointDictionary:candidateService:completionBlock:]",  2452LL,  v105);
            }

            id v80 = v105[4];
            id v81 = (void *)objc_claimAutoreleasedReturnValue([v105 description]);
            sub_10011BB18(v80, 5007, v81, 0LL);

            id v82 = v63;
            objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
            if (qword_1001DCB90)
            {
              nw_txt_record_t v71 = (NSMutableArray *)objc_claimAutoreleasedReturnValue([(id)qword_1001DCB90 objectForKeyedSubscript:v82]);

              if (!v71)
              {
                char v73 = 0;
                a7 = v110;
                uint64_t v22 = v111;
                id v17 = v103;
                goto LABEL_108;
              }

              v71[4].super.super.Class isa = (Class)mach_absolute_time();
              LOBYTE(v71[2].super.super.isa) = 1;
              -[NSMutableArray submit](v71, "submit");
              id v83 = v82;
              objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
              if (qword_1001DCB90)
              {
                [(id)qword_1001DCB90 setObject:0 forKeyedSubscript:v83];
                if (![(id)qword_1001DCB90 count])
                {
                  id v84 = (void *)qword_1001DCB90;
                  qword_1001DCB90 = 0LL;
                }
              }

              char v73 = 0;
            }

            else
            {
              char v73 = 0;
              nw_txt_record_t v71 = v82;
            }

            a7 = v110;
            uint64_t v22 = v111;
          }

          id v17 = v103;

LABEL_108:
          id v74 = v105[5];
          if (v74)
          {
          }

          else
          {
            uint64_t v75 = (void *)objc_claimAutoreleasedReturnValue([v105[16] allowedLinkTypes]);
            unsigned int v76 = [v75 containsObject:&off_1001BC8C8];

            if (v76) {
              [v105 setSelfManagedBluetoothPairing:1];
            }
          }

          uint64_t v77 = objc_opt_self(v104);
          sub_100128908(v77);
          if ((v73 & 1) == 0) {
            v19[2](v19, 0LL, 0LL);
          }
          uint64_t v78 = sub_100146AFC();
          dispatch_async((dispatch_queue_t)v78, &stru_1001AEA60);

          objc_opt_self(&OBJC_CLASS___NRLinkDirector);
          id v25 = (char *)v105;
          if (qword_1001DC878 != -1) {
            dispatch_once(&qword_1001DC878, &stru_1001AEED0);
          }
          id v18 = v108;
          id v79 = (char *)(id)qword_1001DC870;
          sub_1000A49E8(v79);

          goto LABEL_117;
        }
      }

      else
      {
      }

      uint64_t v59 = objc_alloc_init(&OBJC_CLASS___NRAnalyticsLocalDevice);
      uint64_t v60 = mach_absolute_time();
      if (!v59) {
        goto LABEL_86;
      }
      goto LABEL_85;
    }

    id v91 = sub_100121F34();
    int v92 = _NRLogIsLevelEnabled(v91, 17LL);

    a7 = v110;
    if (!v92) {
      goto LABEL_118;
    }
    id v87 = sub_100121F34();
    _NRLogWithArgs(v87, 17LL, "%s called with null completionBlock");
LABEL_140:

    goto LABEL_118;
  }

  id v88 = sub_100121F34();
  int v89 = _NRLogIsLevelEnabled(v88, 17LL);

  a7 = v110;
  uint64_t v22 = v111;
  if (v89)
  {
    id v90 = sub_100121F34();
    _NRLogWithArgs(v90, 17LL, "called with all-zero nrUUID");
  }

void sub_10012FC24(uint64_t a1, void *a2, void *a3)
{
  id v22 = a2;
  id v5 = a3;
  uint64_t v6 = objc_opt_self(a1);
  uint64_t v7 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v7);

  if ((_NRIsUUIDNonZero(v22) & 1) != 0)
  {
    if (!v5)
    {
      id v20 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v20, 17LL);

      if (!IsLevelEnabled) {
        goto LABEL_19;
      }
      id v9 = sub_100121F34();
      _NRLogWithArgs(v9, 17LL, "%s called with null completionBlock");
      goto LABEL_18;
    }

    id v8 = sub_100129C28(v6, v22, 0);
    id v9 = v8;
    if (v8)
    {
      int v10 = v8[8];
      id v11 = *((id *)v8 + 4);
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v9 description]);
      if (v10)
      {
        sub_10011BB18(v11, 5003, v12, 0LL);

        [v9 setIsEnabled:1];
        uint64_t v13 = objc_opt_self(v6);
        sub_100128908(v13);
        if (qword_1001DCBD8 != -1) {
          dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
        {
          if (qword_1001DCBD8 != -1) {
            dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
          }
          _NRLogWithArgs( qword_1001DCBD0,  0LL,  "%s%.30s:%-4d Enabled device %@",  "",  "+[NRDLocalDevice enableDeviceWithNRUUID:completionBlock:]",  2693LL,  v9);
        }

        (*((void (**)(id, void, void))v5 + 2))(v5, 0LL, 0LL);
        goto LABEL_15;
      }

      sub_10011BB18(v11, 5010, v12, @"enable");

      id v15 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%@ is not registered",  v9);
      (*((void (**)(id, uint64_t, NSString *))v5 + 2))(v5, -2014LL, v15);
    }

    else
    {
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v22 UUIDString]);
      sub_10011BB18(v22, 5009, v14, @"enable");

      id v15 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown NRUUID %@",  v22);
      (*((void (**)(id, uint64_t, NSString *))v5 + 2))(v5, -2008LL, v15);
    }

LABEL_15:
    uint64_t v16 = sub_100146AFC();
    dispatch_async((dispatch_queue_t)v16, &stru_1001AEA60);

    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v17 = (char *)(id)qword_1001DC870;
    sub_1000A49E8(v17);

    goto LABEL_18;
  }

  id v18 = sub_100121F34();
  int v19 = _NRLogIsLevelEnabled(v18, 17LL);

  if (!v19) {
    goto LABEL_19;
  }
  id v9 = sub_100121F34();
  _NRLogWithArgs(v9, 17LL, "called with all-zero nrUUID");
LABEL_18:

LABEL_19:
}

void sub_10012FF4C( void *a1, int a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v11 = a3;
  uint64_t v12 = -[NSString initWithFormat:arguments:](objc_alloc(&OBJC_CLASS___NSString), "initWithFormat:arguments:", v11, &a9);

  uint64_t v13 = (void *)a1[4];
  uint64_t v14 = v12;
  id v15 = v13;
  uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([a1 description]);
  sub_10011BB18(v15, a2, v16, v14);
}

void sub_10012FFF8(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  p_class_meths = (__objc2_meth_list **)objc_opt_self(a1);
  uint64_t v7 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v7);

  if (!v5)
  {
    id v35 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v35, 17LL);

    if (!IsLevelEnabled) {
      goto LABEL_72;
    }
    id v9 = (id *)sub_100121F34();
    _NRLogWithArgs(v9, 17LL, "%s called with null nrUUID", "+[NRDLocalDevice confirmKeysForClass:nrUUID:]");
    goto LABEL_71;
  }

  id v8 = sub_100129C28((uint64_t)p_class_meths, v5, 0);
  if (!v8)
  {
    id v37 = sub_100121F34();
    int v38 = _NRLogIsLevelEnabled(v37, 16LL);

    if (v38)
    {
      id v39 = sub_100121F34();
      _NRLogWithArgs( v39,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice confirmKeysForClass:nrUUID:]",  2489);
    }

    id v5 = (id)_os_log_pack_size(12LL);
    id v9 = (id *)((char *)&v43 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL));
    __int128 v40 = __error();
    uint64_t v41 = _os_log_pack_fill( v9,  v5,  *v40,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    *(_DWORD *)uint64_t v41 = 136446210;
    *(void *)(v41 + 4) = "+[NRDLocalDevice confirmKeysForClass:nrUUID:]";
    id v42 = sub_100121F34();
    _NRLogAbortWithPack(v42, v9);
    goto LABEL_78;
  }

  id v9 = (id *)v8;
  if ((_DWORD)a2 == 1)
  {
    if (!v8[14])
    {
      [v8 setHasConfirmedClassAKeys:1];
      if (!*((_BYTE *)v9 + 15)) {
        goto LABEL_15;
      }
      goto LABEL_11;
    }

    goto LABEL_71;
  }

  if ((_DWORD)a2 != 3)
  {
    if ((_DWORD)a2 == 4)
    {
      if (!v8[12])
      {
        [v8 setHasConfirmedClassDKeys:1];
        if (!*((_BYTE *)v9 + 15))
        {
LABEL_15:
          if (*((_BYTE *)v9 + 14)) {
            BOOL v11 = 1;
          }
          else {
            BOOL v11 = *((unsigned __int16 *)v9 + 14) > 0x12u;
          }
          char v10 = v11;
          if (*((_BYTE *)v9 + 12))
          {
LABEL_22:
            if (!*((_BYTE *)v9 + 13)) {
              char v10 = 0;
            }
            if ((v10 & 1) != 0)
            {
              int v12 = *((unsigned __int8 *)v9 + 8);
              [v9 setIsRegistered:1];
              uint64_t v13 = objc_opt_self(p_class_meths);
              sub_100128908(v13);
              uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1001DCBC0 objectForKeyedSubscript:v5]);
              if (qword_1001DCBD8 != -1) {
                dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
              }
              if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
              {
                if (qword_1001DCBD8 != -1) {
                  dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
                }
                if (v12) {
                  id v15 = " (already registered)";
                }
                else {
                  id v15 = "";
                }
                id v16 = (id)qword_1001DCBD0;
                if ([v14 count]) {
                  id v17 = " (with clients)";
                }
                else {
                  id v17 = "";
                }
                id v18 = (void *)sub_10012C014(v9);
                _NRLogWithArgs( v16,  0LL,  "%s%.30s:%-4d Finished%s registration%s for %@",  "",  "+[NRDLocalDevice confirmKeysForClass:nrUUID:]",  2523LL,  v15,  v17,  v18);
              }

              if (v12) {
                goto LABEL_52;
              }
              id v19 = v9[4];
              id v20 = (void *)objc_claimAutoreleasedReturnValue([v9 description]);
              sub_10011BB18(v19, 5007, v20, 0LL);

              id v21 = v5;
              objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
              if (qword_1001DCB90)
              {
                uint64_t v22 = objc_claimAutoreleasedReturnValue([(id)qword_1001DCB90 objectForKeyedSubscript:v21]);

                if (!v22)
                {
LABEL_52:
                  if (v14)
                  {
                    __int128 v45 = 0u;
                    __int128 v46 = 0u;
                    __int128 v44 = 0u;
                    __int128 v43 = 0u;
                    id v28 = v14;
                    id v29 = [v28 countByEnumeratingWithState:&v43 objects:v47 count:16];
                    if (v29)
                    {
                      id v30 = v29;
                      uint64_t v31 = *(void *)v44;
                      do
                      {
                        for (unint64_t i = 0LL; i != v30; unint64_t i = (char *)i + 1)
                        {
                          if (*(void *)v44 != v31) {
                            objc_enumerationMutation(v28);
                          }
                          (*(void (**)(void))(*(void *)(*((void *)&v43 + 1) + 8LL * (void)i) + 16LL))(*(void *)(*((void *)&v43 + 1) + 8LL * (void)i));
                        }

                        id v30 = [v28 countByEnumeratingWithState:&v43 objects:v47 count:16];
                      }

                      while (v30);
                    }

                    objc_msgSend(v28, "removeAllObjects", (void)v43);
                    [(id)qword_1001DCBC0 setObject:0 forKeyedSubscript:v5];
                    if (![(id)qword_1001DCBC0 count])
                    {
                      id v33 = (void *)qword_1001DCBC0;
                      qword_1001DCBC0 = 0LL;
                    }
                  }

                  if (qword_1001DCB98) {
                    [(id)qword_1001DCB98 setObject:0 forKeyedSubscript:v5];
                  }
                  if (qword_1001DCBA0) {
                    [(id)qword_1001DCBA0 setObject:0 forKeyedSubscript:v5];
                  }
                  if (qword_1001DCBA8) {
                    [(id)qword_1001DCBA8 setObject:0 forKeyedSubscript:v5];
                  }
                  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
                  if (qword_1001DC878 != -1) {
                    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
                  }
                  id v34 = (char *)(id)qword_1001DC870;
                  sub_1000A49E8(v34);

                  goto LABEL_71;
                }

                *(void *)(v22 + 32) = mach_absolute_time();
                *(_BYTE *)(v22 + 16) = 1;
                [(id)v22 submit];
                id v23 = v21;
                objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
                if (qword_1001DCB90)
                {
                  [(id)qword_1001DCB90 setObject:0 forKeyedSubscript:v23];
                  if (![(id)qword_1001DCB90 count])
                  {
                    uint64_t v24 = (void *)qword_1001DCB90;
                    qword_1001DCB90 = 0LL;
                  }
                }
              }

              else
              {
                uint64_t v22 = (uint64_t)v21;
              }

              goto LABEL_52;
            }
          }

void sub_1001306B8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v8 = a3;
  id v9 = a4;
  char v10 = (void *)objc_opt_self(a1);
  BOOL v11 = (dispatch_queue_s *)sub_100146AFC();
  dispatch_assert_queue_V2(v11);

  if (v9)
  {
    int v12 = sub_100129C28((uint64_t)v10, v9, 0);
    if (v12)
    {
      BOOL v11 = (dispatch_queue_s *)v12;
      [v12 setIsRegistered:0];
      -[dispatch_queue_s setIsEnabled:](v11, "setIsEnabled:", 0LL);
      uint64_t v13 = objc_opt_self(v10);
      sub_100128908(v13);
      char v10 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1001DCBC0 objectForKeyedSubscript:v9]);
      p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
      if (qword_1001DCBD8 == -1) {
        goto LABEL_4;
      }
    }

    else
    {
      id v34 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v34, 16LL);

      if (IsLevelEnabled)
      {
        id v36 = sub_100121F34();
        _NRLogWithArgs( v36,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice reportRegistrationFailureCode:errorDescription:forNRUUID:]",  2564);
      }

      id v8 = (id)_os_log_pack_size(12LL);
      id v9 = (char *)&v40 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v37 = __error();
      uint64_t v38 = _os_log_pack_fill( v9,  v8,  *v37,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)uint64_t v38 = 136446210;
      *(void *)(v38 + 4) = "+[NRDLocalDevice reportRegistrationFailureCode:errorDescription:forNRUUID:]";
      id v39 = sub_100121F34();
      _NRLogAbortWithPack(v39, v9);
    }

    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
LABEL_4:
    if (_NRLogIsLevelEnabled(qword_1001DCBD0, 16LL))
    {
      if (p_class_meths[379] != (__objc2_meth_list *)-1LL) {
        dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
      }
      id v19 = (id)qword_1001DCBD0;
      id v20 = (void *)sub_10012C014((id *)v11);
      _NRLogWithArgs( v19,  16LL,  "%s%.30s:%-4d Registration failure [%lld] %@ for %@",  "",  "+[NRDLocalDevice reportRegistrationFailureCode:errorDescription:forNRUUID:]",  2571LL,  a2,  v8,  v20);
    }

    sub_10012FF4C(v11, 5008, @"[%lld] %@", v14, v15, v16, v17, v18, a2);
    id v21 = v9;
    objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
    uint64_t v22 = (uint64_t)v21;
    if (qword_1001DCB90)
    {
      uint64_t v22 = objc_claimAutoreleasedReturnValue([(id)qword_1001DCB90 objectForKeyedSubscript:v21]);

      if (!v22)
      {
LABEL_15:
        if (v10)
        {
          __int128 v42 = 0u;
          __int128 v43 = 0u;
          __int128 v41 = 0u;
          __int128 v40 = 0u;
          id v25 = v10;
          id v26 = [v25 countByEnumeratingWithState:&v40 objects:v44 count:16];
          if (v26)
          {
            id v27 = v26;
            uint64_t v28 = *(void *)v41;
            do
            {
              for (unint64_t i = 0LL; i != v27; unint64_t i = (char *)i + 1)
              {
                if (*(void *)v41 != v28) {
                  objc_enumerationMutation(v25);
                }
                (*(void (**)(void))(*(void *)(*((void *)&v40 + 1) + 8LL * (void)i) + 16LL))();
              }

              id v27 = [v25 countByEnumeratingWithState:&v40 objects:v44 count:16];
            }

            while (v27);
          }

          [v25 removeAllObjects];
          [(id)qword_1001DCBC0 setObject:0 forKeyedSubscript:v21];
          if (![(id)qword_1001DCBC0 count])
          {
            id v30 = (void *)qword_1001DCBC0;
            qword_1001DCBC0 = 0LL;
          }
        }

        if (qword_1001DCB98) {
          [(id)qword_1001DCB98 setObject:0 forKeyedSubscript:v21];
        }
        if (qword_1001DCBA0) {
          [(id)qword_1001DCBA0 setObject:0 forKeyedSubscript:v21];
        }
        if (qword_1001DCBA8) {
          [(id)qword_1001DCBA8 setObject:0 forKeyedSubscript:v21];
        }
        objc_opt_self(&OBJC_CLASS___NRLinkDirector);
        if (qword_1001DC878 != -1) {
          dispatch_once(&qword_1001DC878, &stru_1001AEED0);
        }
        uint64_t v31 = (char *)(id)qword_1001DC870;
        sub_1000A49E8(v31);

        goto LABEL_34;
      }

      *(void *)(v22 + 32) = mach_absolute_time();
      *(_BYTE *)(v22 + 16) = 0;
      [(id)v22 submit];
      id v23 = v21;
      objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
      if (qword_1001DCB90)
      {
        [(id)qword_1001DCB90 setObject:0 forKeyedSubscript:v23];
        if (![(id)qword_1001DCB90 count])
        {
          uint64_t v24 = (void *)qword_1001DCB90;
          qword_1001DCB90 = 0LL;
        }
      }
    }

    goto LABEL_15;
  }

  id v32 = sub_100121F34();
  int v33 = _NRLogIsLevelEnabled(v32, 17LL);

  if (!v33) {
    goto LABEL_35;
  }
  BOOL v11 = (dispatch_queue_s *)sub_100121F34();
  _NRLogWithArgs( v11,  17LL,  "%s called with null nrUUID",  "+[NRDLocalDevice reportRegistrationFailureCode:errorDescription:forNRUUID:]");
LABEL_34:

LABEL_35:
}

void sub_100130BE8(uint64_t a1, void *a2, void *a3)
{
  id v24 = a2;
  id v5 = a3;
  uint64_t v6 = objc_opt_self(a1);
  uint64_t v7 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v7);

  if (v24)
  {
    if ((_NRIsUUIDNonZero(v24) & 1) != 0)
    {
      if (v5)
      {
        id v8 = sub_100129C28((uint64_t)&OBJC_CLASS___NRDLocalDevice, v24, 0);
        id v9 = v8;
        if (v8)
        {
          id v10 = *((id *)v8 + 4);
          BOOL v11 = (void *)objc_claimAutoreleasedReturnValue([v9 description]);
          sub_10011BB18(v10, 5002, v11, 0LL);

          int v12 = sub_10012BF24((uint64_t)&OBJC_CLASS___NRDLocalDevice, v9);
          [(id)qword_1001DCB78 setObject:v12 forKeyedSubscript:v24];

          if (v9[7]) {
            objc_msgSend((id)qword_1001DCB80, "setObject:forKeyedSubscript:", 0);
          }
        }

        else
        {
          id v23 = sub_10012BF24((uint64_t)&OBJC_CLASS___NRDLocalDevice, 0LL);
          [(id)qword_1001DCB78 setObject:v23 forKeyedSubscript:v24];
        }

        sub_10009FF2C(v24, 0LL);
        sub_10012AEE0((uint64_t)v9);
        uint64_t v13 = objc_opt_self(v6);
        sub_100128908(v13);
        if (v9)
        {
          if (qword_1001DCBD8 != -1) {
            dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
          {
            if (qword_1001DCBD8 != -1) {
              dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
            }
            _NRLogWithArgs( qword_1001DCBD0,  0LL,  "%s%.30s:%-4d Unregistered device %@",  "",  "+[NRDLocalDevice unregisterDeviceWithNRUUID:completionBlock:]",  2631LL,  v9);
          }

          (*((void (**)(id, void, void))v5 + 2))(v5, 0LL, 0LL);
        }

        else
        {
          if (qword_1001DCBD8 != -1) {
            dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCBD0, 16LL))
          {
            if (qword_1001DCBD8 != -1) {
              dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
            }
            _NRLogWithArgs( qword_1001DCBD0,  16LL,  "%s%.30s:%-4d Did not unregister unknown NRUUID %@",  "",  "+[NRDLocalDevice unregisterDeviceWithNRUUID:completionBlock:]",  2634LL,  v24);
          }

          uint64_t v14 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown NRUUID %@",  v24);
          (*((void (**)(id, uint64_t, NSString *))v5 + 2))(v5, -2008LL, v14);
        }

        if (qword_1001DCB98) {
          [(id)qword_1001DCB98 setObject:0 forKeyedSubscript:v24];
        }
        if (qword_1001DCBA0) {
          [(id)qword_1001DCBA0 setObject:0 forKeyedSubscript:v24];
        }
        if (qword_1001DCBA8) {
          [(id)qword_1001DCBA8 setObject:0 forKeyedSubscript:v24];
        }
        if (qword_1001DCBC8) {
          [(id)qword_1001DCBC8 setObject:0 forKeyedSubscript:v24];
        }
        uint64_t v15 = sub_100146AFC();
        dispatch_async((dispatch_queue_t)v15, &stru_1001AEA60);

        objc_opt_self(&OBJC_CLASS___NRLinkDirector);
        if (qword_1001DC878 != -1) {
          dispatch_once(&qword_1001DC878, &stru_1001AEED0);
        }
        id v16 = (id)qword_1001DC870;
        sub_1000A49E8();
      }

      else
      {
        id v21 = sub_100121F34();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v21, 17LL);

        if (!IsLevelEnabled) {
          goto LABEL_34;
        }
        id v9 = sub_100121F34();
        _NRLogWithArgs(v9, 17LL, "%s called with null completionBlock");
      }
    }

    else
    {
      id v19 = sub_100121F34();
      int v20 = _NRLogIsLevelEnabled(v19, 17LL);

      if (!v20) {
        goto LABEL_34;
      }
      id v9 = sub_100121F34();
      _NRLogWithArgs(v9, 17LL, "called with all-zero nrUUID");
    }
  }

  else
  {
    id v17 = sub_100121F34();
    int v18 = _NRLogIsLevelEnabled(v17, 17LL);

    if (!v18) {
      goto LABEL_34;
    }
    id v9 = sub_100121F34();
    _NRLogWithArgs(v9, 17LL, "%s called with null nrUUID");
  }

LABEL_34:
}

void sub_100131034(uint64_t a1, void *a2, void *a3)
{
  id v24 = a2;
  id v5 = a3;
  uint64_t v6 = objc_opt_self(a1);
  uint64_t v7 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v7);

  if (v24)
  {
    if ((_NRIsUUIDNonZero(v24) & 1) == 0)
    {
      id v20 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v20, 17LL);

      if (!IsLevelEnabled) {
        goto LABEL_20;
      }
      id v9 = sub_100121F34();
      _NRLogWithArgs(v9, 17LL, "called with all-zero nrUUID");
      goto LABEL_19;
    }

    if (!v5)
    {
      id v22 = sub_100121F34();
      int v23 = _NRLogIsLevelEnabled(v22, 17LL);

      if (!v23) {
        goto LABEL_20;
      }
      id v9 = sub_100121F34();
      _NRLogWithArgs(v9, 17LL, "%s called with null completionBlock");
      goto LABEL_19;
    }

    id v8 = sub_100129C28(v6, v24, 0);
    id v9 = v8;
    if (v8)
    {
      int v10 = v8[8];
      id v11 = *((id *)v8 + 4);
      int v12 = (void *)objc_claimAutoreleasedReturnValue([v9 description]);
      if (v10)
      {
        sub_10011BB18(v11, 5004, v12, 0LL);

        [v9 setIsEnabled:0];
        uint64_t v13 = objc_opt_self(v6);
        sub_100128908(v13);
        if (qword_1001DCBD8 != -1) {
          dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
        {
          if (qword_1001DCBD8 != -1) {
            dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
          }
          _NRLogWithArgs( qword_1001DCBD0,  0LL,  "%s%.30s:%-4d Disabled device %@",  "",  "+[NRDLocalDevice disableDeviceWithNRUUID:completionBlock:]",  2721LL,  v9);
        }

        (*((void (**)(id, void, void))v5 + 2))(v5, 0LL, 0LL);
        goto LABEL_16;
      }

      sub_10011BB18(v11, 5010, v12, @"disable");

      uint64_t v15 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%@ is not registered",  v9);
      (*((void (**)(id, uint64_t, NSString *))v5 + 2))(v5, -2014LL, v15);
    }

    else
    {
      uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v24 UUIDString]);
      sub_10011BB18(v24, 5009, v14, @"disable");

      uint64_t v15 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown NRUUID %@",  v24);
      (*((void (**)(id, uint64_t, NSString *))v5 + 2))(v5, -2008LL, v15);
    }

LABEL_16:
    id v16 = sub_100146AFC();
    dispatch_async((dispatch_queue_t)v16, &stru_1001AEA60);

    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v17 = (id)qword_1001DC870;
    sub_1000A49E8();

    goto LABEL_19;
  }

  id v18 = sub_100121F34();
  int v19 = _NRLogIsLevelEnabled(v18, 17LL);

  if (!v19) {
    goto LABEL_20;
  }
  id v9 = sub_100121F34();
  _NRLogWithArgs(v9, 17LL, "%s called with null nrUUID");
LABEL_19:

LABEL_20:
}

uint64_t sub_10013139C(uint64_t a1)
{
  uint64_t v1 = objc_opt_self(a1);
  uint64_t v2 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v2);

  sub_100127AFC(v1);
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  id v3 = (id)qword_1001DCB78;
  uint64_t v4 = (uint64_t)[v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v11;
    while (2)
    {
      for (uint64_t i = 0LL; i != v4; ++i)
      {
        if (*(void *)v11 != v5) {
          objc_enumerationMutation(v3);
        }
        uint64_t v7 = (unsigned __int8 *)objc_claimAutoreleasedReturnValue( objc_msgSend( (id)qword_1001DCB78,  "objectForKeyedSubscript:",  *(void *)(*((void *)&v10 + 1) + 8 * i),  (void)v10));
        if (v7)
        {
          int v8 = v7[9];

          if (v8)
          {
            uint64_t v4 = 1LL;
            goto LABEL_12;
          }
        }
      }

      uint64_t v4 = (uint64_t)[v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
      if (v4) {
        continue;
      }
      break;
    }
  }

NSMutableArray *sub_1001314D4(uint64_t a1)
{
  uint64_t v1 = objc_opt_self(a1);
  uint64_t v2 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v2);

  sub_100127AFC(v1);
  id v3 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  id v4 = (id)qword_1001DCB78;
  id v5 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v14;
    do
    {
      for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v14 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void *)(*((void *)&v13 + 1) + 8LL * (void)i);
        uint64_t v10 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_1001DCB78, "objectForKeyedSubscript:", v9, (void)v13));
        __int128 v11 = (void *)v10;
        if (v10 && *(_BYTE *)(v10 + 9)) {
          -[NSMutableArray addObject:](v3, "addObject:", v9);
        }
      }

      id v6 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
    }

    while (v6);
  }

  return v3;
}

NSMutableArray *sub_10013163C(uint64_t a1)
{
  uint64_t v1 = objc_opt_self(a1);
  uint64_t v2 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v2);

  sub_100127AFC(v1);
  id v3 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  id v4 = (id)qword_1001DCB78;
  id v5 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v14;
    do
    {
      for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v14 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void *)(*((void *)&v13 + 1) + 8LL * (void)i);
        uint64_t v10 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_1001DCB78, "objectForKeyedSubscript:", v9, (void)v13));
        __int128 v11 = (void *)v10;
        if (v10 && *(_BYTE *)(v10 + 9) && *(void *)(v10 + 40)) {
          -[NSMutableArray addObject:](v3, "addObject:", v9);
        }
      }

      id v6 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
    }

    while (v6);
  }

  return v3;
}

NSMutableArray *sub_1001317AC(uint64_t a1)
{
  uint64_t v1 = objc_opt_self(a1);
  uint64_t v2 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v2);

  sub_100127AFC(v1);
  id v3 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  id v4 = (id)qword_1001DCB78;
  id v5 = [v4 countByEnumeratingWithState:&v15 objects:v19 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v16;
    do
    {
      for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v16 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void *)(*((void *)&v15 + 1) + 8LL * (void)i);
        uint64_t v10 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_1001DCB78, "objectForKeyedSubscript:", v9, (void)v15));
        __int128 v11 = (void *)v10;
        if (!v10 || !*(_BYTE *)(v10 + 9)) {
          goto LABEL_6;
        }
        if (*(_BYTE *)(v10 + 15))
        {
          char v12 = 1;
          if (*(_BYTE *)(v10 + 12)) {
            goto LABEL_21;
          }
        }

        else
        {
          if (*(_BYTE *)(v10 + 14)) {
            BOOL v13 = 1;
          }
          else {
            BOOL v13 = *(unsigned __int16 *)(v10 + 28) > 0x12u;
          }
          char v12 = v13;
          if (*(_BYTE *)(v10 + 12))
          {
LABEL_21:
            if (!*(_BYTE *)(v10 + 13)) {
              char v12 = 0;
            }
            if ((v12 & 1) != 0) {
              goto LABEL_6;
            }
          }
        }

        if (!sub_1001319A0(v10)) {
          goto LABEL_5;
        }
        if (qword_1001DC9B8 == -1)
        {
          if (byte_1001DC9B0) {
            goto LABEL_5;
          }
        }

        else
        {
          dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
          if (byte_1001DC9B0) {
LABEL_5:
          }
            -[NSMutableArray addObject:](v3, "addObject:", v9);
        }

BOOL sub_1001319A0(BOOL result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (!*(_BYTE *)(result + 23))
    {
      *(_BYTE *)(result + 23) = 1;
      if (*(void *)(result + 128))
      {
        id v2 = +[NRDeviceOperationalProperties copyPropertiesForDefaultPairedPhone]( &OBJC_CLASS___NRDeviceOperationalProperties,  "copyPropertiesForDefaultPairedPhone");
        id v3 = (void *)objc_claimAutoreleasedReturnValue([v2 allowedLinkTypes]);
        id v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v1 + 128) allowedLinkTypes]);
        unsigned int v5 = [v3 isEqualToArray:v4];

        if (v5) {
          *(_BYTE *)(v1 + 19) = 1;
        }
      }

      else
      {
        *(_BYTE *)(result + 19) = 1;
      }
    }

    return *(_BYTE *)(v1 + 19) != 0;
  }

  return result;
}

NSMutableArray *sub_100131A50(uint64_t a1)
{
  uint64_t v1 = objc_opt_self(a1);
  id v2 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v2);

  sub_100127AFC(v1);
  id v3 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v15 = 0u;
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v18 = 0u;
  id v4 = (id)qword_1001DCB78;
  id v5 = [v4 countByEnumeratingWithState:&v15 objects:v19 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v16;
    do
    {
      for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v16 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void *)(*((void *)&v15 + 1) + 8LL * (void)i);
        uint64_t v10 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_1001DCB78, "objectForKeyedSubscript:", v9, (void)v15));
        __int128 v11 = (void *)v10;
        if (v10 && *(_BYTE *)(v10 + 9))
        {
          if (*(_BYTE *)(v10 + 15))
          {
            int v12 = 1;
            if (!*(_BYTE *)(v10 + 12)) {
              goto LABEL_5;
            }
          }

          else
          {
            if (*(_BYTE *)(v10 + 14)) {
              BOOL v13 = 1;
            }
            else {
              BOOL v13 = *(unsigned __int16 *)(v10 + 28) > 0x12u;
            }
            int v12 = v13;
            if (!*(_BYTE *)(v10 + 12)) {
              goto LABEL_5;
            }
          }

          if (!*(_BYTE *)(v10 + 13)) {
            int v12 = 0;
          }
          if (v12 == 1) {
            -[NSMutableArray addObject:](v3, "addObject:", v9);
          }
        }

NSMutableArray *sub_100131C00(uint64_t a1)
{
  uint64_t v1 = objc_opt_self(a1);
  id v2 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v2);

  sub_100127AFC(v1);
  id v3 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  id v4 = (id)qword_1001DCB78;
  id v5 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v13;
    do
    {
      for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v13 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = objc_claimAutoreleasedReturnValue( objc_msgSend( (id)qword_1001DCB78,  "objectForKeyedSubscript:",  *(void *)(*((void *)&v12 + 1) + 8 * (void)i),  (void)v12));
        uint64_t v10 = (void *)v9;
        if (v9 && *(_BYTE *)(v9 + 9) && *(void *)(v9 + 40)) {
          -[NSMutableArray addObject:](v3, "addObject:");
        }
      }

      id v6 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
    }

    while (v6);
  }

  return v3;
}

uint64_t sub_100131D60(uint64_t a1)
{
  uint64_t v1 = objc_opt_self(a1);
  id v2 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v2);

  sub_100127AFC(v1);
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  id v3 = (id)qword_1001DCB78;
  uint64_t v4 = (uint64_t)[v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v11;
LABEL_4:
    uint64_t v6 = 0LL;
    while (1)
    {
      if (*(void *)v11 != v5) {
        objc_enumerationMutation(v3);
      }
      uint64_t v7 = objc_claimAutoreleasedReturnValue( objc_msgSend( (id)qword_1001DCB78,  "objectForKeyedSubscript:",  *(void *)(*((void *)&v10 + 1) + 8 * v6),  (void)v10));
      if (v7 && *(_BYTE *)(v7 + 9))
      {
        uint64_t v8 = *(void *)(v7 + 40);

        if (v8)
        {
          uint64_t v4 = 1LL;
          break;
        }
      }

      else
      {
      }

      if (v4 == ++v6)
      {
        uint64_t v4 = (uint64_t)[v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
        if (!v4) {
          break;
        }
        goto LABEL_4;
      }
    }
  }

  return v4;
}

id sub_100131EA8(uint64_t a1)
{
  uint64_t v1 = objc_opt_self(a1);
  id v2 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v2);

  sub_100127AFC(v1);
  __int128 v16 = 0u;
  __int128 v17 = 0u;
  __int128 v14 = 0u;
  __int128 v15 = 0u;
  id v3 = (id)qword_1001DCB78;
  id v4 = [v3 countByEnumeratingWithState:&v14 objects:v18 count:16];
  if (!v4)
  {
    id v6 = 0LL;
    goto LABEL_15;
  }

  id v5 = v4;
  id v6 = 0LL;
  uint64_t v7 = *(void *)v15;
LABEL_4:
  uint64_t v8 = 0LL;
  while (1)
  {
    if (*(void *)v15 != v7) {
      objc_enumerationMutation(v3);
    }
    uint64_t v9 = *(void **)(*((void *)&v14 + 1) + 8 * v8);
    uint64_t v10 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_1001DCB78, "objectForKeyedSubscript:", v9, (void)v14));
    __int128 v11 = (void *)v10;
    if (!v10 || !*(_BYTE *)(v10 + 9)) {
      goto LABEL_5;
    }
    if (!*(_BYTE *)(v10 + 24)) {
      break;
    }
    if (!v6) {
      id v6 = v9;
    }
LABEL_5:

    if (v5 == (id)++v8)
    {
      id v5 = [v3 countByEnumeratingWithState:&v14 objects:v18 count:16];
      if (!v5) {
        goto LABEL_15;
      }
      goto LABEL_4;
    }
  }

  id v12 = v9;

  id v6 = v12;
LABEL_15:

  return v6;
}

NSMutableData *sub_100132028(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = objc_opt_self(a1);
  if (v3)
  {
    id v5 = (NSMutableData *)sub_100129C28(v4, v3, 0);
    id v6 = sub_10012AAD8(v5);
  }

  else
  {
    id v8 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 17LL);

    if (!IsLevelEnabled)
    {
      id v6 = 0LL;
      goto LABEL_4;
    }

    id v5 = (NSMutableData *)sub_100121F34();
    _NRLogWithArgs(v5, 17LL, "%s called with null nrUUID", "+[NRDLocalDevice copyDeviceIdentityPayloadForNRUUID:]");
    id v6 = 0LL;
  }

LABEL_4:
  return v6;
}

void sub_1001320DC(uint64_t a1, void *a2, int a3, void *a4)
{
  id v9 = a2;
  uint64_t v10 = a4;
  __int128 v11 = (NSMutableData *)objc_opt_self(a1);
  id v12 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v12);

  if (v9)
  {
    if (v10)
    {
      __int128 v13 = sub_100129C28((uint64_t)v11, v9, 0);
      if (!v13)
      {
        id v72 = sub_100121F34();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v72, 16LL);

        if (IsLevelEnabled)
        {
          id v74 = sub_100121F34();
          _NRLogWithArgs( v74,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice queryPairingKeysForNRUUID:minDataProtectionClass:completionBlock:]",  3036);
        }

        id v9 = (id)_os_log_pack_size(12LL);
        uint64_t v10 = (char *)&v83 - (((unint64_t)v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v75 = __error();
        uint64_t v76 = _os_log_pack_fill( v10,  v9,  *v75,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
        *(_DWORD *)uint64_t v76 = 136446210;
        *(void *)(v76 + 4) = "+[NRDLocalDevice queryPairingKeysForNRUUID:minDataProtectionClass:completionBlock:]";
        id v77 = sub_100121F34();
        _NRLogAbortWithPack(v77, v10);
        goto LABEL_53;
      }

      id v12 = v13;
      id v84 = v11;
      sub_10012B3FC((uint64_t)v13);
      __int128 v14 = (NSMutableData *)*((id *)v12 + 9);
      __int128 v11 = v14;
      if (v14)
      {
        __int128 v15 = v14[2].super.super.isa;
        if (v15)
        {
          uint64_t v16 = *((void *)v12 + 9);
          if (v16) {
            uint64_t v17 = *(void *)(v16 + 32);
          }
          else {
            uint64_t v17 = 0LL;
          }

          if (!v17) {
            goto LABEL_17;
          }
          __int128 v11 = -[NSMutableData initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableData), "initWithCapacity:", 64LL);
          __int128 v18 = (void *)*((void *)v12 + 9);
          if (v18) {
            int v19 = (void *)v18[2];
          }
          else {
            int v19 = 0LL;
          }
          id v20 = v19;
          id v21 = v18;
          id v22 = sub_100124E58(v20);
          -[NSMutableData appendData:](v11, "appendData:", v22);

          int v23 = (void *)*((void *)v12 + 9);
          if (v23) {
            id v24 = (void *)v23[4];
          }
          else {
            id v24 = 0LL;
          }
          id v25 = v24;
          id v26 = v23;
          id v27 = sub_100124E58(v25);
          -[NSMutableData appendData:](v11, "appendData:", v27);

          if ((id)-[NSMutableData length](v11, "length") == (id)64)
          {
LABEL_18:
            int v33 = (NSMutableData *)*((id *)v12 + 10);
            uint64_t v4 = v33;
            if (v33)
            {
              id v34 = v33[2].super.super.isa;
              if (v34)
              {
                uint64_t v35 = *((void *)v12 + 10);
                if (v35) {
                  uint64_t v36 = *(void *)(v35 + 32);
                }
                else {
                  uint64_t v36 = 0LL;
                }

                if (!v36) {
                  goto LABEL_31;
                }
                uint64_t v4 = -[NSMutableData initWithCapacity:]( objc_alloc(&OBJC_CLASS___NSMutableData),  "initWithCapacity:",  64LL);
                id v37 = (void *)*((void *)v12 + 10);
                if (v37) {
                  uint64_t v38 = (void *)v37[2];
                }
                else {
                  uint64_t v38 = 0LL;
                }
                id v39 = v38;
                __int128 v40 = v37;
                __int128 v41 = sub_100124E58(v39);
                -[NSMutableData appendData:](v4, "appendData:", v41);

                __int128 v42 = (void *)*((void *)v12 + 10);
                if (v42) {
                  __int128 v43 = (void *)v42[4];
                }
                else {
                  __int128 v43 = 0LL;
                }
                __int128 v44 = v43;
                __int128 v45 = v42;
                __int128 v46 = sub_100124E58(v44);
                -[NSMutableData appendData:](v4, "appendData:", v46);

                if ((id)-[NSMutableData length](v4, "length") == (id)64) {
                  goto LABEL_32;
                }
                id v48 = (void *)_NRCopyLogObjectForNRUUID(v9, v47);
                int v49 = _NRLogIsLevelEnabled(v48, 16LL);

                if (v49)
                {
                  id v51 = (void *)_NRCopyLogObjectForNRUUID(v9, v50);
                  _NRLogWithArgs( v51,  16LL,  "%s%.30s:%-4d Bad localPublicClassCKeys.length %llu",  "",  "+[NRDLocalDevice queryPairingKeysForNRUUID:minDataProtectionClass:completionBlock:]",  3058,  -[NSMutableData length](v4, "length"));
                }
              }
            }

LABEL_31:
            uint64_t v4 = 0LL;
LABEL_32:
            uint64_t v52 = (NSMutableData *)*((id *)v12 + 11);
            id v5 = v52;
            if (!v52 || (uint64_t v53 = v52[2].super.super.isa) == 0LL)
            {
LABEL_55:

              goto LABEL_56;
            }

            uint64_t v54 = *((void *)v12 + 11);
            if (v54) {
              uint64_t v55 = *(void *)(v54 + 32);
            }
            else {
              uint64_t v55 = 0LL;
            }

            if (!v55)
            {
LABEL_56:
              id v5 = 0LL;
              if (a3 == 1) {
                goto LABEL_43;
              }
              goto LABEL_57;
            }

            id v5 = -[NSMutableData initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableData), "initWithCapacity:", 64LL);
            uint64_t v56 = (void *)*((void *)v12 + 11);
            if (v56) {
              uint64_t v57 = (void *)v56[2];
            }
            else {
              uint64_t v57 = 0LL;
            }
            id v58 = v57;
            uint64_t v59 = v56;
            uint64_t v60 = sub_100124E58(v58);
            -[NSMutableData appendData:](v5, "appendData:", v60);

            id v61 = (void *)*((void *)v12 + 11);
            if (v61) {
              id v62 = (void *)v61[4];
            }
            else {
              id v62 = 0LL;
            }
            id v63 = v62;
            id v64 = v61;
            __int128 v65 = sub_100124E58(v63);
            -[NSMutableData appendData:](v5, "appendData:", v65);

            if ((id)-[NSMutableData length](v5, "length") == (id)64)
            {
              if (a3 == 1)
              {
LABEL_43:
                if (!v4 || !v5)
                {
                  v94[0] = _NSConcreteStackBlock;
                  v94[1] = 3221225472LL;
                  v94[2] = sub_100132900;
                  v94[3] = &unk_1001B05F0;
                  id v67 = v12;
                  id v95 = v67;
                  uint64_t v101 = v84;
                  id v96 = v9;
                  char v102 = 1;
                  __int128 v100 = v10;
                  id v97 = v11;
                  uint64_t v98 = v4;
                  id v99 = v5;
                  sub_10012BB64((uint64_t)v67, v94);

LABEL_61:
                  goto LABEL_62;
                }

                goto LABEL_60;
              }

uint64_t sub_100132900(uint64_t a1, int a2)
{
  if (!a2) {
    goto LABEL_12;
  }
  uint64_t v3 = *(void *)(a1 + 32);
  if (!v3)
  {
    id v5 = 0LL;
LABEL_11:

    goto LABEL_12;
  }

  uint64_t v4 = (id *)*(id *)(v3 + 88);
  id v5 = v4;
  if (!v4) {
    goto LABEL_11;
  }
  id v6 = v4[2];
  if (!v6) {
    goto LABEL_11;
  }
  uint64_t v7 = v6;
  uint64_t v8 = *(void *)(a1 + 32);
  if (v8)
  {
    id v9 = *(id *)(v8 + 88);
    if (v9)
    {
      uint64_t v10 = v9[4];
      goto LABEL_8;
    }
  }

  else
  {
    id v9 = 0LL;
  }

  uint64_t v10 = 0LL;
LABEL_8:

  if (v10) {
    return sub_1001320DC( *(void *)(a1 + 80),  *(void *)(a1 + 40),  *(unsigned __int8 *)(a1 + 88),  *(void *)(a1 + 72));
  }
LABEL_12:
  if (qword_1001DCBD8 != -1) {
    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCBD0, 17LL))
  {
    if (qword_1001DCBD8 != -1) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    _NRLogWithArgs(qword_1001DCBD0, 17LL, "Cannot query pairing keys due to ClassA failure %@", *(void *)(a1 + 40));
  }

  sub_1001030D0(@"NRDLocalDevice", @"PairingKeys", @"InvalidClassAKeys", 0, 0LL, v12, v13, v14, v15);
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 16LL))();
}

uint64_t sub_100132A60(uint64_t a1, int a2)
{
  if (!a2) {
    goto LABEL_12;
  }
  uint64_t v3 = *(void *)(a1 + 32);
  if (!v3)
  {
    id v5 = 0LL;
LABEL_11:

    goto LABEL_12;
  }

  uint64_t v4 = (id *)*(id *)(v3 + 80);
  id v5 = v4;
  if (!v4) {
    goto LABEL_11;
  }
  id v6 = v4[2];
  if (!v6) {
    goto LABEL_11;
  }
  uint64_t v7 = v6;
  uint64_t v8 = *(void *)(a1 + 32);
  if (v8)
  {
    id v9 = *(id *)(v8 + 80);
    if (v9)
    {
      uint64_t v10 = v9[4];
      goto LABEL_8;
    }
  }

  else
  {
    id v9 = 0LL;
  }

  uint64_t v10 = 0LL;
LABEL_8:

  if (v10) {
    return sub_1001320DC( *(void *)(a1 + 80),  *(void *)(a1 + 40),  *(unsigned __int8 *)(a1 + 88),  *(void *)(a1 + 72));
  }
LABEL_12:
  if (qword_1001DCBD8 != -1) {
    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCBD0, 17LL))
  {
    if (qword_1001DCBD8 != -1) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    _NRLogWithArgs(qword_1001DCBD0, 17LL, "Cannot query pairing keys due to ClassC failure %@", *(void *)(a1 + 40));
  }

  sub_1001030D0(@"NRDLocalDevice", @"PairingKeys", @"InvalidClassCKeys", 0, 0LL, v12, v13, v14, v15);
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 16LL))();
}

void sub_100132BC0(uint64_t a1, void *a2, int a3, void *a4)
{
  id v7 = a2;
  id v8 = a4;
  uint64_t v9 = objc_opt_self(a1);
  uint64_t v10 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v10);

  if (!v7)
  {
    id v11 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 17LL);

    if (!IsLevelEnabled) {
      goto LABEL_4;
    }
    id v13 = sub_100121F34();
    _NRLogWithArgs(v13, 17LL, "%s called with null nrUUID");
LABEL_9:

    goto LABEL_4;
  }

  if (!v8)
  {
    id v14 = sub_100121F34();
    int v15 = _NRLogIsLevelEnabled(v14, 17LL);

    if (!v15) {
      goto LABEL_4;
    }
    id v13 = sub_100121F34();
    _NRLogWithArgs(v13, 17LL, "%s called with null completionBlock");
    goto LABEL_9;
  }

  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472LL;
  v16[2] = sub_100132D28;
  v16[3] = &unk_1001B0640;
  uint64_t v19 = v9;
  id v17 = v7;
  char v20 = a3;
  id v18 = v8;
  sub_1001320DC(v9, v17, a3, v16);

LABEL_4:
}

void sub_100132D28(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  id v11 = sub_100129C28(*(void *)(a1 + 48), *(void **)(a1 + 32), 0);
  if (v11)
  {
    uint64_t v12 = v11;
    id v13 = *((id *)v11 + 5);
    if (v13)
    {
      uint64_t v4 = v13;
      objc_opt_self(&OBJC_CLASS___NRDIDSKeyManager);
      if (qword_1001DC900 == -1) {
        goto LABEL_4;
      }
      goto LABEL_15;
    }

    id v28 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v28, 16LL);

    id v8 = "+[NRDLocalDevice queryPairingFromIDSKeysForNRUUID:minDataProtectionClass:completionBlock:]_block_invoke";
    if (IsLevelEnabled)
    {
      id v30 = sub_100121F34();
      _NRLogWithArgs( v30,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (bluetoothUUID) != ((void *)0)",  "",  "+[NRDLocalDevice queryPairingFromIDSKeysForNRUUID:minDataProtectionClass:completionBlock:]_block_invoke",  3124);
    }

    uint64_t v12 = (char *)_os_log_pack_size(12LL);
    id v25 = (char *)v34 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v31 = __error();
    uint64_t v32 = _os_log_pack_fill( v25,  v12,  *v31,  &_mh_execute_header,  "%{public}s Assertion Failed: (bluetoothUUID) != ((void *)0)");
    *(_DWORD *)uint64_t v32 = 136446210;
    *(void *)(v32 + 4) = "+[NRDLocalDevice queryPairingFromIDSKeysForNRUUID:minDataProtectionClass:completionBlock:]_block_invoke";
  }

  else
  {
    id v22 = sub_100121F34();
    int v23 = _NRLogIsLevelEnabled(v22, 16LL);

    if (v23)
    {
      id v24 = sub_100121F34();
      _NRLogWithArgs( v24,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice queryPairingFromIDSKeysForNRUUID:minDataProtectionClass:completionBlock:]_block_invoke",  3122);
    }

    uint64_t v12 = (char *)_os_log_pack_size(12LL);
    id v25 = (char *)v34 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v26 = __error();
    uint64_t v27 = _os_log_pack_fill( v25,  v12,  *v26,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    *(_DWORD *)uint64_t v27 = 136446210;
    *(void *)(v27 + 4) = "+[NRDLocalDevice queryPairingFromIDSKeysForNRUUID:minDataProtectionClass:completionBlock:]_block_invoke";
  }

  id v33 = sub_100121F34();
  _NRLogAbortWithPack(v33, v25);
LABEL_15:
  dispatch_once(&qword_1001DC900, &stru_1001AF6B8);
LABEL_4:
  id v14 = (dispatch_queue_t *)(id)qword_1001DC8F8;
  uint64_t v15 = *(unsigned __int8 *)(a1 + 56);
  v34[0] = _NSConcreteStackBlock;
  v34[1] = 3221225472LL;
  uint64_t v35 = sub_100133124;
  uint64_t v36 = &unk_1001B0618;
  char v38 = v15;
  id v37 = *(id *)(a1 + 40);
  id v16 = v4;
  id v17 = v8;
  id v18 = v9;
  id v19 = v10;
  char v20 = v34;
  if (v14)
  {
    dispatch_assert_queue_V2(v14[2]);
    if (v17)
    {
      v39[0] = _NSConcreteStackBlock;
      v39[1] = 3221225472LL;
      v39[2] = sub_1000F29F4;
      void v39[3] = &unk_1001AF758;
      void v39[4] = v14;
      char v45 = v15;
      __int128 v40 = v17;
      id v21 = v16;
      id v41 = v21;
      id v42 = v18;
      id v43 = v19;
      __int128 v44 = v20;
      sub_1000F257C((uint64_t)v14, v21, v15, v39);
    }

    else
    {
      v35((uint64_t)v20, 0LL, 0LL, 0LL, 0LL, 0LL);
    }
  }
}

void sub_100133124(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6)
{
  id v26 = a4;
  id v11 = a5;
  id v12 = a6;
  id v13 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v13);

  if (!a2)
  {
    id v15 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v15, 17LL);

    if (!IsLevelEnabled) {
      goto LABEL_9;
    }
    id v17 = sub_100121F34();
    _NRLogWithArgs(v17, 17LL, "%s called with null remotePublicIDSClassDSigningKey");
    goto LABEL_20;
  }

  if (!a3)
  {
    id v18 = sub_100121F34();
    int v19 = _NRLogIsLevelEnabled(v18, 17LL);

    if (!v19) {
      goto LABEL_9;
    }
    id v17 = sub_100121F34();
    _NRLogWithArgs(v17, 17LL, "%s called with null localPrivateIDSClassDSigningKey");
    goto LABEL_20;
  }

  if (!v26)
  {
    id v20 = sub_100121F34();
    int v21 = _NRLogIsLevelEnabled(v20, 17LL);

    if (!v21) {
      goto LABEL_9;
    }
    id v17 = sub_100121F34();
    _NRLogWithArgs(v17, 17LL, "%s called with null localPublicClassDKeysEncryptedWithIDS");
    goto LABEL_20;
  }

  int v14 = *(unsigned __int8 *)(a1 + 40);
  if ((v14 | 2) == 3)
  {
    if (v11)
    {
      if (v12 || v14 != 1) {
        goto LABEL_8;
      }
      id v24 = sub_100121F34();
      int v25 = _NRLogIsLevelEnabled(v24, 17LL);

      if (!v25) {
        goto LABEL_9;
      }
      id v17 = sub_100121F34();
      _NRLogWithArgs(v17, 17LL, "%s called with null localPublicClassAKeysEncryptedWithIDS");
    }

    else
    {
      id v22 = sub_100121F34();
      int v23 = _NRLogIsLevelEnabled(v22, 17LL);

      if (!v23) {
        goto LABEL_9;
      }
      id v17 = sub_100121F34();
      _NRLogWithArgs(v17, 17LL, "%s called with null localPublicClassCKeysEncryptedWithIDS");
    }

void sub_100133320(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v32 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = objc_opt_self(a1);
  id v11 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v11);

  if ([v32 length] == (id)48)
  {
    if (!v8)
    {
      id v19 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v19, 17LL);

      if (!IsLevelEnabled) {
        goto LABEL_10;
      }
      id v11 = sub_100121F34();
      _NRLogWithArgs(v11, 17LL, "%s called with null nrUUID");
      goto LABEL_9;
    }

    if (!v9)
    {
      id v21 = sub_100121F34();
      int v22 = _NRLogIsLevelEnabled(v21, 17LL);

      if (!v22) {
        goto LABEL_10;
      }
      id v11 = sub_100121F34();
      _NRLogWithArgs(v11, 17LL, "%s called with null deviceCompletionBlock");
      goto LABEL_9;
    }

    id v12 = sub_100129C28(v10, v8, 0);
    if (v12)
    {
      id v11 = v12;
      uint64_t v4 = sub_1001278D0(objc_alloc(&OBJC_CLASS___NRDDeviceIdentity), v32);
      id v13 = (void *)*((void *)v11 + 8);
      if (!v13)
      {
        [v11 setRemoteIdentity:v4];
        uint64_t v14 = objc_opt_self(v10);
        if ((sub_100128908(v14) & 1) != 0)
        {
          id v15 = *((id *)v11 + 4);
          id v16 = (void *)objc_claimAutoreleasedReturnValue([v11 description]);
          sub_10011BB18(v15, 5006, v16, @"Identity");
        }

        else
        {
          [v11 setRemoteIdentity:0];
        }

void sub_100133664(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v37 = a2;
  id v10 = a3;
  id v11 = a4;
  uint64_t v12 = objc_opt_self(a1);
  id v13 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v13);

  if ([v37 length] == (id)64)
  {
    if (!v10)
    {
      id v27 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v27, 17LL);

      if (!IsLevelEnabled) {
        goto LABEL_13;
      }
      id v13 = sub_100121F34();
      _NRLogWithArgs(v13, 17LL, "%s called with null nrUUID");
      goto LABEL_12;
    }

    if (!v11)
    {
      id v29 = sub_100121F34();
      int v30 = _NRLogIsLevelEnabled(v29, 17LL);

      if (!v30) {
        goto LABEL_13;
      }
      id v13 = sub_100121F34();
      _NRLogWithArgs(v13, 17LL, "%s called with null deviceCompletionBlock");
      goto LABEL_12;
    }

    uint64_t v14 = sub_100129C28(v12, v10, 0);
    if (v14)
    {
      id v13 = v14;
      sub_10012B1F4((uint64_t)v14);
      uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v37, "subdataWithRange:", 0, 32));
      id v15 = sub_1001248D8((char *)objc_alloc(&OBJC_CLASS___NRDLDKeychainItemSecKey), v4);
      uint64_t v16 = *((void *)v13 + 9);
      if (v16) {
        objc_storeStrong((id *)(v16 + 8), v15);
      }

      id v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v37, "subdataWithRange:", 32, 32));
      id v17 = *((id *)v13 + 9);
      id v6 = v17;
      if (v17)
      {
        int v18 = (void *)*((void *)v17 + 4);
LABEL_9:
        id v19 = v18;
        id v20 = sub_100126A7C((uint64_t)v19, v5);
        uint64_t v21 = *((void *)v13 + 9);
        if (v21) {
          objc_storeStrong((id *)(v21 + 24), v20);
        }

        id v22 = *((id *)v13 + 4);
        id v23 = (void *)objc_claimAutoreleasedReturnValue([v13 description]);
        sub_10011BB18(v22, 5006, v23, @"ClassD");

        uint64_t v24 = objc_opt_self(v12);
        sub_100128908(v24);
        (*((void (**)(char *, void *))v11 + 2))(v11, v13);

        goto LABEL_12;
      }
    }

    else
    {
      id v31 = sub_100121F34();
      int v32 = _NRLogIsLevelEnabled(v31, 16LL);

      if (v32)
      {
        id v33 = sub_100121F34();
        _NRLogWithArgs( v33,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice ingestRemoteClassDKeys:nrUUID:deviceCompletionBlock:]",  3198);
      }

      id v10 = (id)_os_log_pack_size(12LL);
      id v11 = (char *)&v37 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v34 = __error();
      uint64_t v35 = _os_log_pack_fill( v11,  v10,  *v34,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)uint64_t v35 = 136446210;
      *(void *)(v35 + 4) = "+[NRDLocalDevice ingestRemoteClassDKeys:nrUUID:deviceCompletionBlock:]";
      id v36 = sub_100121F34();
      _NRLogAbortWithPack(v36, v11);
    }

    int v18 = 0LL;
    goto LABEL_9;
  }

  id v25 = sub_100121F34();
  int v26 = _NRLogIsLevelEnabled(v25, 17LL);

  if (!v26) {
    goto LABEL_13;
  }
  id v13 = sub_100121F34();
  _NRLogWithArgs( v13,  17LL,  "%s called with null remoteClassDKeys.length == sizeof(ccec25519pubkey) + sizeof(ccec25519pubkey)");
LABEL_12:

LABEL_13:
}

void sub_1001339F8(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = objc_opt_self(a1);
  id v11 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v11);

  if ([v7 length] == (id)64)
  {
    if (v8)
    {
      if (v9)
      {
        uint64_t v12 = sub_100129C28(v10, v8, 0);
        if (!v12)
        {
          id v21 = sub_100121F34();
          int IsLevelEnabled = _NRLogIsLevelEnabled(v21, 16LL);

          if (IsLevelEnabled)
          {
            id v23 = sub_100121F34();
            _NRLogWithArgs( v23,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice ingestRemoteClassCKeys:nrUUID:deviceCompletionBlock:]",  3229);
          }

          uint64_t v24 = _os_log_pack_size(12LL);
          id v25 = (char *)&v30[-1] - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
          int v26 = __error();
          uint64_t v27 = _os_log_pack_fill( v25,  v24,  *v26,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
          *(_DWORD *)uint64_t v27 = 136446210;
          *(void *)(v27 + 4) = "+[NRDLocalDevice ingestRemoteClassCKeys:nrUUID:deviceCompletionBlock:]";
          id v28 = sub_100121F34();
          _NRLogAbortWithPack(v28, v25);
        }

        id v13 = v12;
        v30[0] = _NSConcreteStackBlock;
        v30[1] = 3221225472LL;
        v30[2] = sub_100133CC4;
        v30[3] = &unk_1001B0668;
        id v33 = v9;
        id v31 = v13;
        id v32 = v7;
        uint64_t v34 = v10;
        uint64_t v14 = v13;
        sub_10012B7E0(v14, v30);
      }

      else
      {
        id v19 = sub_100121F34();
        int v20 = _NRLogIsLevelEnabled(v19, 17LL);

        if (!v20) {
          goto LABEL_7;
        }
        uint64_t v14 = (char *)sub_100121F34();
        _NRLogWithArgs(v14, 17LL, "%s called with null deviceCompletionBlock");
      }
    }

    else
    {
      id v17 = sub_100121F34();
      int v18 = _NRLogIsLevelEnabled(v17, 17LL);

      if (!v18) {
        goto LABEL_7;
      }
      uint64_t v14 = (char *)sub_100121F34();
      _NRLogWithArgs(v14, 17LL, "%s called with null nrUUID");
    }
  }

  else
  {
    id v15 = sub_100121F34();
    int v16 = _NRLogIsLevelEnabled(v15, 17LL);

    if (!v16) {
      goto LABEL_7;
    }
    uint64_t v14 = (char *)sub_100121F34();
    _NRLogWithArgs( v14,  17LL,  "%s called with null remoteClassCKeys.length == sizeof(ccec25519pubkey) + sizeof(ccec25519pubkey)");
  }

LABEL_7:
}

void sub_100133CC4(uint64_t a1, char a2)
{
  if ((a2 & 1) != 0)
  {
    id v20 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "subdataWithRange:", 0, 32));
    uint64_t v3 = sub_1001248D8((char *)objc_alloc(&OBJC_CLASS___NRDLDKeychainItemSecKey), v20);
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4)
    {
      id v5 = (id *)*(id *)(v4 + 80);
      if (v5)
      {
        id v6 = v5;
        objc_storeStrong(v5 + 1, v3);
      }
    }

    id v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "subdataWithRange:", 32, 32));
    id v8 = *(id **)(a1 + 32);
    if (v8)
    {
      id v9 = (id **)v8[10];
      uint64_t v10 = v9;
      if (v9) {
        id v8 = v9[4];
      }
      else {
        id v8 = 0LL;
      }
    }

    else
    {
      uint64_t v10 = 0LL;
    }

    id v11 = v8;
    uint64_t v12 = sub_100126A7C((uint64_t)v11, v7);
    uint64_t v13 = *(void *)(a1 + 32);
    if (v13)
    {
      uint64_t v14 = (id *)*(id *)(v13 + 80);
      if (v14)
      {
        id v15 = v14;
        objc_storeStrong(v14 + 3, v12);
      }
    }

    sub_10012B37C(*(id **)(a1 + 32), 5006, @"ClassC");
    uint64_t v16 = objc_opt_self(*(void *)(a1 + 56));
    sub_100128908(v16);
    (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
  }

  else
  {
    id v17 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v17, 17LL);

    if (IsLevelEnabled)
    {
      id v19 = sub_100121F34();
      _NRLogWithArgs(v19, 17LL, "Failed to ingest remote ClassC keys due to ClassC fill in failure");
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
  }

void sub_100133E78(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = objc_opt_self(a1);
  id v11 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v11);

  if ([v7 length] == (id)64)
  {
    if (v8)
    {
      if (v9)
      {
        uint64_t v12 = sub_100129C28(v10, v8, 0);
        if (!v12)
        {
          id v21 = sub_100121F34();
          int IsLevelEnabled = _NRLogIsLevelEnabled(v21, 16LL);

          if (IsLevelEnabled)
          {
            id v23 = sub_100121F34();
            _NRLogWithArgs( v23,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice ingestRemoteClassAKeys:nrUUID:deviceCompletionBlock:]",  3265);
          }

          uint64_t v24 = _os_log_pack_size(12LL);
          id v25 = (char *)&v30[-1] - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
          int v26 = __error();
          uint64_t v27 = _os_log_pack_fill( v25,  v24,  *v26,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
          *(_DWORD *)uint64_t v27 = 136446210;
          *(void *)(v27 + 4) = "+[NRDLocalDevice ingestRemoteClassAKeys:nrUUID:deviceCompletionBlock:]";
          id v28 = sub_100121F34();
          _NRLogAbortWithPack(v28, v25);
        }

        uint64_t v13 = v12;
        v30[0] = _NSConcreteStackBlock;
        v30[1] = 3221225472LL;
        v30[2] = sub_100134144;
        v30[3] = &unk_1001B0668;
        id v33 = v9;
        id v31 = v13;
        id v32 = v7;
        uint64_t v34 = v10;
        uint64_t v14 = v13;
        sub_10012BB64((uint64_t)v14, v30);
      }

      else
      {
        id v19 = sub_100121F34();
        int v20 = _NRLogIsLevelEnabled(v19, 17LL);

        if (!v20) {
          goto LABEL_7;
        }
        uint64_t v14 = (char *)sub_100121F34();
        _NRLogWithArgs(v14, 17LL, "%s called with null deviceCompletionBlock");
      }
    }

    else
    {
      id v17 = sub_100121F34();
      int v18 = _NRLogIsLevelEnabled(v17, 17LL);

      if (!v18) {
        goto LABEL_7;
      }
      uint64_t v14 = (char *)sub_100121F34();
      _NRLogWithArgs(v14, 17LL, "%s called with null nrUUID");
    }
  }

  else
  {
    id v15 = sub_100121F34();
    int v16 = _NRLogIsLevelEnabled(v15, 17LL);

    if (!v16) {
      goto LABEL_7;
    }
    uint64_t v14 = (char *)sub_100121F34();
    _NRLogWithArgs( v14,  17LL,  "%s called with null remoteClassAKeys.length == sizeof(ccec25519pubkey) + sizeof(ccec25519pubkey)");
  }

LABEL_7:
}

void sub_100134144(uint64_t a1, char a2)
{
  if ((a2 & 1) != 0)
  {
    id v20 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "subdataWithRange:", 0, 32));
    uint64_t v3 = sub_1001248D8((char *)objc_alloc(&OBJC_CLASS___NRDLDKeychainItemSecKey), v20);
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4)
    {
      id v5 = (id *)*(id *)(v4 + 88);
      if (v5)
      {
        id v6 = v5;
        objc_storeStrong(v5 + 1, v3);
      }
    }

    id v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "subdataWithRange:", 32, 32));
    id v8 = *(id **)(a1 + 32);
    if (v8)
    {
      id v9 = (id **)v8[11];
      uint64_t v10 = v9;
      if (v9) {
        id v8 = v9[4];
      }
      else {
        id v8 = 0LL;
      }
    }

    else
    {
      uint64_t v10 = 0LL;
    }

    id v11 = v8;
    uint64_t v12 = sub_100126A7C((uint64_t)v11, v7);
    uint64_t v13 = *(void *)(a1 + 32);
    if (v13)
    {
      uint64_t v14 = (id *)*(id *)(v13 + 88);
      if (v14)
      {
        id v15 = v14;
        objc_storeStrong(v14 + 3, v12);
      }
    }

    sub_10012B37C(*(id **)(a1 + 32), 5006, @"ClassA");
    uint64_t v16 = objc_opt_self(*(void *)(a1 + 56));
    sub_100128908(v16);
    (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
  }

  else
  {
    id v17 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v17, 17LL);

    if (IsLevelEnabled)
    {
      id v19 = sub_100121F34();
      _NRLogWithArgs(v19, 17LL, "Failed to ingest remote ClassA keys due to ClassA fill in failure");
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16LL))();
  }

void sub_1001342F8(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v8 = a2;
  id v9 = a3;
  uint64_t v10 = a4;
  uint64_t v11 = objc_opt_self(a1);
  uint64_t v12 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v12);

  if (!v8)
  {
    id v21 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v21, 17LL);

    if (!IsLevelEnabled) {
      goto LABEL_10;
    }
    id v23 = sub_100121F34();
    _NRLogWithArgs(v23, 17LL, "%s called with null remoteClassDKeysEncryptedWithIDS");
LABEL_17:

    goto LABEL_10;
  }

  if (!v9)
  {
    id v24 = sub_100121F34();
    int v25 = _NRLogIsLevelEnabled(v24, 17LL);

    if (!v25) {
      goto LABEL_10;
    }
    id v23 = sub_100121F34();
    _NRLogWithArgs(v23, 17LL, "%s called with null nrUUID");
    goto LABEL_17;
  }

  if (!v10)
  {
    id v26 = sub_100121F34();
    int v27 = _NRLogIsLevelEnabled(v26, 17LL);

    if (!v27) {
      goto LABEL_10;
    }
    id v23 = sub_100121F34();
    _NRLogWithArgs(v23, 17LL, "%s called with null deviceCompletionBlock");
    goto LABEL_17;
  }

  uint64_t v13 = sub_100129C28(v11, v9, 0);
  if (!v13)
  {
    id v28 = sub_100121F34();
    int v29 = _NRLogIsLevelEnabled(v28, 16LL);

    if (v29)
    {
      id v30 = sub_100121F34();
      _NRLogWithArgs( v30,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice ingestRemoteClassDKeysEncryptedWithIDS:nrUUID:deviceCompletionBlock:]",  3301);
    }

    id v8 = (id)_os_log_pack_size(12LL);
    id v9 = (char *)v39 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v31 = __error();
    uint64_t v32 = _os_log_pack_fill( v9,  v8,  *v31,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    *(_DWORD *)uint64_t v32 = 136446210;
    *(void *)(v32 + 4) = "+[NRDLocalDevice ingestRemoteClassDKeysEncryptedWithIDS:nrUUID:deviceCompletionBlock:]";
    goto LABEL_24;
  }

  uint64_t v14 = v13;
  id v15 = *((id *)v13 + 5);
  if (!v15)
  {
    id v33 = sub_100121F34();
    int v34 = _NRLogIsLevelEnabled(v33, 16LL);

    uint64_t v10 = "+[NRDLocalDevice ingestRemoteClassDKeysEncryptedWithIDS:nrUUID:deviceCompletionBlock:]";
    if (v34)
    {
      id v35 = sub_100121F34();
      _NRLogWithArgs( v35,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (bluetoothUUID) != ((void *)0)",  "",  "+[NRDLocalDevice ingestRemoteClassDKeysEncryptedWithIDS:nrUUID:deviceCompletionBlock:]",  3303);
    }

    id v8 = (id)_os_log_pack_size(12LL);
    id v9 = (char *)v39 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v36 = __error();
    uint64_t v37 = _os_log_pack_fill( v9,  v8,  *v36,  &_mh_execute_header,  "%{public}s Assertion Failed: (bluetoothUUID) != ((void *)0)");
    *(_DWORD *)uint64_t v37 = 136446210;
    *(void *)(v37 + 4) = "+[NRDLocalDevice ingestRemoteClassDKeysEncryptedWithIDS:nrUUID:deviceCompletionBlock:]";
LABEL_24:
    id v38 = sub_100121F34();
    _NRLogAbortWithPack(v38, v9);
    goto LABEL_25;
  }

  uint64_t v4 = v15;
  sub_10012B1F4((uint64_t)v14);

  objc_opt_self(&OBJC_CLASS___NRDIDSKeyManager);
  if (qword_1001DC900 != -1) {
LABEL_25:
  }
    dispatch_once(&qword_1001DC900, &stru_1001AF6B8);
  uint64_t v16 = (dispatch_queue_t *)(id)qword_1001DC8F8;
  v39[0] = _NSConcreteStackBlock;
  v39[1] = 3221225472LL;
  v39[2] = sub_100134784;
  void v39[3] = &unk_1001B0690;
  uint64_t v42 = v11;
  __int128 v40 = v9;
  id v41 = v10;
  id v17 = v8;
  id v18 = v4;
  id v19 = v39;
  if (v16)
  {
    dispatch_assert_queue_V2(v16[2]);
    v43[0] = _NSConcreteStackBlock;
    v43[1] = 3221225472LL;
    void v43[2] = sub_1000F304C;
    v43[3] = &unk_1001AF780;
    v43[4] = v16;
    id v44 = v17;
    id v20 = v18;
    id v45 = v20;
    __int128 v46 = v19;
    sub_1000F257C((uint64_t)v16, v20, 4LL, v43);
  }

LABEL_10:
}

void sub_100134784(uint64_t a1, void *a2)
{
}

void sub_100134794(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = objc_opt_self(a1);
  uint64_t v11 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v11);

  if (!v7)
  {
    id v18 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 17LL);

    if (!IsLevelEnabled) {
      goto LABEL_7;
    }
    id v20 = sub_100121F34();
    _NRLogWithArgs(v20, 17LL, "%s called with null remoteClassCKeysEncryptedWithIDS");
LABEL_14:

    goto LABEL_7;
  }

  if (!v8)
  {
    id v21 = sub_100121F34();
    int v22 = _NRLogIsLevelEnabled(v21, 17LL);

    if (!v22) {
      goto LABEL_7;
    }
    id v20 = sub_100121F34();
    _NRLogWithArgs(v20, 17LL, "%s called with null nrUUID");
    goto LABEL_14;
  }

  if (!v9)
  {
    id v23 = sub_100121F34();
    int v24 = _NRLogIsLevelEnabled(v23, 17LL);

    if (!v24) {
      goto LABEL_7;
    }
    id v20 = sub_100121F34();
    _NRLogWithArgs(v20, 17LL, "%s called with null deviceCompletionBlock");
    goto LABEL_14;
  }

  uint64_t v12 = sub_100129C28(v10, v8, 0);
  if (!v12)
  {
    id v25 = sub_100121F34();
    int v26 = _NRLogIsLevelEnabled(v25, 16LL);

    if (v26)
    {
      id v27 = sub_100121F34();
      _NRLogWithArgs( v27,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice ingestRemoteClassCKeysEncryptedWithIDS:nrUUID:deviceCompletionBlock:]",  3328);
    }

    uint64_t v28 = _os_log_pack_size(12LL);
    int v29 = (char *)&v40[-1] - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v30 = __error();
    uint64_t v31 = _os_log_pack_fill( v29,  v28,  *v30,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    *(_DWORD *)uint64_t v31 = 136446210;
    *(void *)(v31 + 4) = "+[NRDLocalDevice ingestRemoteClassCKeysEncryptedWithIDS:nrUUID:deviceCompletionBlock:]";
LABEL_21:
    id v38 = sub_100121F34();
    _NRLogAbortWithPack(v38, v29);
  }

  uint64_t v13 = v12;
  id v14 = *((id *)v12 + 5);
  if (!v14)
  {
    id v32 = sub_100121F34();
    int v33 = _NRLogIsLevelEnabled(v32, 16LL);

    if (v33)
    {
      id v34 = sub_100121F34();
      _NRLogWithArgs( v34,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (bluetoothUUID) != ((void *)0)",  "",  "+[NRDLocalDevice ingestRemoteClassCKeysEncryptedWithIDS:nrUUID:deviceCompletionBlock:]",  3330);
    }

    uint64_t v35 = _os_log_pack_size(12LL);
    int v29 = (char *)&v40[-1] - ((v35 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v36 = __error();
    uint64_t v37 = _os_log_pack_fill( v29,  v35,  *v36,  &_mh_execute_header,  "%{public}s Assertion Failed: (bluetoothUUID) != ((void *)0)");
    *(_DWORD *)uint64_t v37 = 136446210;
    *(void *)(v37 + 4) = "+[NRDLocalDevice ingestRemoteClassCKeysEncryptedWithIDS:nrUUID:deviceCompletionBlock:]";
    goto LABEL_21;
  }

  id v15 = v14;
  v40[0] = _NSConcreteStackBlock;
  v40[1] = 3221225472LL;
  v40[2] = sub_100134B40;
  v40[3] = &unk_1001B06B8;
  id v45 = v9;
  id v41 = v13;
  id v42 = v7;
  id v43 = v15;
  uint64_t v46 = v10;
  id v44 = v8;
  id v16 = v15;
  id v17 = v13;
  sub_10012B7E0(v17, v40);

LABEL_7:
}

void sub_100134B40(uint64_t a1, char a2)
{
  if ((a2 & 1) != 0)
  {
    objc_opt_self(&OBJC_CLASS___NRDIDSKeyManager);
    if (qword_1001DC900 != -1) {
      dispatch_once(&qword_1001DC900, &stru_1001AF6B8);
    }
    uint64_t v3 = (dispatch_queue_t *)(id)qword_1001DC8F8;
    uint64_t v4 = *(void **)(a1 + 40);
    id v5 = *(void **)(a1 + 48);
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472LL;
    void v18[2] = sub_100134DCC;
    v18[3] = &unk_1001B0690;
    uint64_t v21 = *(void *)(a1 + 72);
    id v19 = *(id *)(a1 + 56);
    id v20 = *(id *)(a1 + 64);
    id v6 = v4;
    id v7 = v5;
    id v8 = v18;
    if (!v3) {
      goto LABEL_8;
    }
    dispatch_assert_queue_V2(v3[2]);
    if (v6)
    {
      if (v7)
      {
        v22[0] = _NSConcreteStackBlock;
        v22[1] = 3221225472LL;
        void v22[2] = sub_1000F324C;
        v22[3] = &unk_1001AF780;
        v22[4] = v3;
        id v23 = v6;
        id v9 = v7;
        id v24 = v9;
        id v25 = v8;
        sub_1000F257C((uint64_t)v3, v9, 3LL, v22);

LABEL_8:
        return;
      }

      id v16 = sub_1000F0648();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v16, 17LL);

      if (!IsLevelEnabled) {
        goto LABEL_8;
      }
      id v15 = sub_1000F0648();
      _NRLogWithArgs(v15, 17LL, "%s called with null bluetoothUUID");
    }

    else
    {
      id v13 = sub_1000F0648();
      int v14 = _NRLogIsLevelEnabled(v13, 17LL);

      if (!v14) {
        goto LABEL_8;
      }
      id v15 = sub_1000F0648();
      _NRLogWithArgs(v15, 17LL, "%s called with null remoteClassCKeysEncryptedWithIDS");
    }

    goto LABEL_8;
  }

  id v10 = sub_100121F34();
  int v11 = _NRLogIsLevelEnabled(v10, 16LL);

  if (v11)
  {
    id v12 = sub_100121F34();
    _NRLogWithArgs( v12,  16LL,  "%s%.30s:%-4d Failed to ingest remote ClassC keys encrypted with IDS due to ClassC fill in failure",  "",  "+[NRDLocalDevice ingestRemoteClassCKeysEncryptedWithIDS:nrUUID:deviceCompletionBlock:]_block_invoke",  3334);
  }

  (*(void (**)(void))(*(void *)(a1 + 64) + 16LL))();
}

void sub_100134DCC(uint64_t a1, void *a2)
{
}

void sub_100134DDC(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = objc_opt_self(a1);
  int v11 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v11);

  if (!v7)
  {
    id v18 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 17LL);

    if (!IsLevelEnabled) {
      goto LABEL_7;
    }
    id v20 = sub_100121F34();
    _NRLogWithArgs(v20, 17LL, "%s called with null remoteClassAKeysEncryptedWithIDS");
LABEL_14:

    goto LABEL_7;
  }

  if (!v8)
  {
    id v21 = sub_100121F34();
    int v22 = _NRLogIsLevelEnabled(v21, 17LL);

    if (!v22) {
      goto LABEL_7;
    }
    id v20 = sub_100121F34();
    _NRLogWithArgs(v20, 17LL, "%s called with null nrUUID");
    goto LABEL_14;
  }

  if (!v9)
  {
    id v23 = sub_100121F34();
    int v24 = _NRLogIsLevelEnabled(v23, 17LL);

    if (!v24) {
      goto LABEL_7;
    }
    id v20 = sub_100121F34();
    _NRLogWithArgs(v20, 17LL, "%s called with null deviceCompletionBlock");
    goto LABEL_14;
  }

  id v12 = sub_100129C28(v10, v8, 0);
  if (!v12)
  {
    id v25 = sub_100121F34();
    int v26 = _NRLogIsLevelEnabled(v25, 16LL);

    if (v26)
    {
      id v27 = sub_100121F34();
      _NRLogWithArgs( v27,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice ingestRemoteClassAKeysEncryptedWithIDS:nrUUID:deviceCompletionBlock:]",  3360);
    }

    uint64_t v28 = _os_log_pack_size(12LL);
    int v29 = (char *)&v40[-1] - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v30 = __error();
    uint64_t v31 = _os_log_pack_fill( v29,  v28,  *v30,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    *(_DWORD *)uint64_t v31 = 136446210;
    *(void *)(v31 + 4) = "+[NRDLocalDevice ingestRemoteClassAKeysEncryptedWithIDS:nrUUID:deviceCompletionBlock:]";
LABEL_21:
    id v38 = sub_100121F34();
    _NRLogAbortWithPack(v38, v29);
  }

  id v13 = v12;
  id v14 = *((id *)v12 + 5);
  if (!v14)
  {
    id v32 = sub_100121F34();
    int v33 = _NRLogIsLevelEnabled(v32, 16LL);

    if (v33)
    {
      id v34 = sub_100121F34();
      _NRLogWithArgs( v34,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (bluetoothUUID) != ((void *)0)",  "",  "+[NRDLocalDevice ingestRemoteClassAKeysEncryptedWithIDS:nrUUID:deviceCompletionBlock:]",  3362);
    }

    uint64_t v35 = _os_log_pack_size(12LL);
    int v29 = (char *)&v40[-1] - ((v35 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v36 = __error();
    uint64_t v37 = _os_log_pack_fill( v29,  v35,  *v36,  &_mh_execute_header,  "%{public}s Assertion Failed: (bluetoothUUID) != ((void *)0)");
    *(_DWORD *)uint64_t v37 = 136446210;
    *(void *)(v37 + 4) = "+[NRDLocalDevice ingestRemoteClassAKeysEncryptedWithIDS:nrUUID:deviceCompletionBlock:]";
    goto LABEL_21;
  }

  id v15 = v14;
  v40[0] = _NSConcreteStackBlock;
  v40[1] = 3221225472LL;
  v40[2] = sub_100135188;
  v40[3] = &unk_1001B06B8;
  id v45 = v9;
  id v41 = v13;
  id v42 = v7;
  id v43 = v15;
  uint64_t v46 = v10;
  id v44 = v8;
  id v16 = v15;
  id v17 = v13;
  sub_10012BB64((uint64_t)v17, v40);

LABEL_7:
}

void sub_100135188(uint64_t a1, char a2)
{
  if ((a2 & 1) != 0)
  {
    objc_opt_self(&OBJC_CLASS___NRDIDSKeyManager);
    if (qword_1001DC900 != -1) {
      dispatch_once(&qword_1001DC900, &stru_1001AF6B8);
    }
    uint64_t v3 = (dispatch_queue_t *)(id)qword_1001DC8F8;
    uint64_t v4 = *(void **)(a1 + 40);
    id v5 = *(void **)(a1 + 48);
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472LL;
    void v18[2] = sub_100135414;
    v18[3] = &unk_1001B0690;
    uint64_t v21 = *(void *)(a1 + 72);
    id v19 = *(id *)(a1 + 56);
    id v20 = *(id *)(a1 + 64);
    id v6 = v4;
    id v7 = v5;
    id v8 = v18;
    if (!v3) {
      goto LABEL_8;
    }
    dispatch_assert_queue_V2(v3[2]);
    if (v6)
    {
      if (v7)
      {
        v22[0] = _NSConcreteStackBlock;
        v22[1] = 3221225472LL;
        void v22[2] = sub_1000F344C;
        v22[3] = &unk_1001AF780;
        v22[4] = v3;
        id v23 = v6;
        id v9 = v7;
        id v24 = v9;
        id v25 = v8;
        sub_1000F257C((uint64_t)v3, v9, 1LL, v22);

LABEL_8:
        return;
      }

      id v16 = sub_1000F0648();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v16, 17LL);

      if (!IsLevelEnabled) {
        goto LABEL_8;
      }
      id v15 = sub_1000F0648();
      _NRLogWithArgs(v15, 17LL, "%s called with null bluetoothUUID");
    }

    else
    {
      id v13 = sub_1000F0648();
      int v14 = _NRLogIsLevelEnabled(v13, 17LL);

      if (!v14) {
        goto LABEL_8;
      }
      id v15 = sub_1000F0648();
      _NRLogWithArgs(v15, 17LL, "%s called with null remoteClassAKeysEncryptedWithIDS");
    }

    goto LABEL_8;
  }

  id v10 = sub_100121F34();
  int v11 = _NRLogIsLevelEnabled(v10, 16LL);

  if (v11)
  {
    id v12 = sub_100121F34();
    _NRLogWithArgs( v12,  16LL,  "%s%.30s:%-4d Failed to ingest remote ClassA keys encrypted with IDS due to ClassA fill in failure",  "",  "+[NRDLocalDevice ingestRemoteClassAKeysEncryptedWithIDS:nrUUID:deviceCompletionBlock:]_block_invoke",  3366);
  }

  (*(void (**)(void))(*(void *)(a1 + 64) + 16LL))();
}

void sub_100135414(uint64_t a1, void *a2)
{
}

void sub_100135424(uint64_t a1, void *a2, void *a3)
{
  id v27 = a2;
  id v5 = a3;
  uint64_t v6 = objc_opt_self(a1);
  id v7 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v7);

  if (v27)
  {
    if (v5)
    {
      id v8 = sub_100129C28(v6, v27, 0);
      if (!v8)
      {
        id v19 = sub_100121F34();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v19, 16LL);

        if (IsLevelEnabled)
        {
          id v21 = sub_100121F34();
          _NRLogWithArgs( v21,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice queryIDSDeviceIDForNRUUID:completionBlock:]",  3390);
        }

        uint64_t v22 = _os_log_pack_size(12LL);
        id v23 = (char *)&v27 - ((v22 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        id v24 = __error();
        uint64_t v25 = _os_log_pack_fill( v23,  v22,  *v24,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
        *(_DWORD *)uint64_t v25 = 136446210;
        *(void *)(v25 + 4) = "+[NRDLocalDevice queryIDSDeviceIDForNRUUID:completionBlock:]";
        id v26 = sub_100121F34();
        _NRLogAbortWithPack(v26, v23);
      }

      id v9 = v8;
      if (*((void *)v8 + 6))
      {
        v5[2](v5, v8);
      }

      else
      {
        id v10 = (void *)qword_1001DCBC8;
        if (!qword_1001DCBC8)
        {
          int v11 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
          id v12 = (void *)qword_1001DCBC8;
          qword_1001DCBC8 = (uint64_t)v11;

          id v10 = (void *)qword_1001DCBC8;
        }

        id v13 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", v27, v27));
        if (!v13) {
          id v13 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        }
        int v14 = objc_retainBlock(v5);
        -[NSMutableArray addObject:](v13, "addObject:", v14);

        [(id)qword_1001DCBC8 setObject:v13 forKeyedSubscript:v27];
      }
    }

    else
    {
      id v17 = sub_100121F34();
      int v18 = _NRLogIsLevelEnabled(v17, 17LL);

      if (!v18) {
        goto LABEL_12;
      }
      id v9 = sub_100121F34();
      _NRLogWithArgs(v9, 17LL, "%s called with null block");
    }
  }

  else
  {
    id v15 = sub_100121F34();
    int v16 = _NRLogIsLevelEnabled(v15, 17LL);

    if (!v16) {
      goto LABEL_12;
    }
    id v9 = sub_100121F34();
    _NRLogWithArgs(v9, 17LL, "%s called with null nrUUID");
  }

LABEL_12:
}

void sub_1001356B8(uint64_t a1, uint64_t a2, void *a3)
{
  id v18 = a3;
  id v5 = (const char *)objc_opt_self(a1);
  uint64_t v6 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v6);

  if (v18)
  {
    id v7 = sub_100129B30((uint64_t)v5, v18);
    if (v7)
    {
      id v8 = v7;
    }

    else
    {
      id v11 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 16LL);

      id v5 = "+[NRDLocalDevice updateLastSeenInnerLinkVersionHBO:nrUUID:]";
      if (IsLevelEnabled)
      {
        id v13 = sub_100121F34();
        _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice updateLastSeenInnerLinkVersionHBO:nrUUID:]",  3412);
      }

      a2 = _os_log_pack_size(12LL);
      id v8 = (char *)&v18 - ((a2 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v14 = __error();
      uint64_t v15 = _os_log_pack_fill( v8,  a2,  *v14,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)uint64_t v15 = 136446210;
      *(void *)(v15 + 4) = "+[NRDLocalDevice updateLastSeenInnerLinkVersionHBO:nrUUID:]";
      id v16 = sub_100121F34();
      _NRLogAbortWithPack(v16, v8);
    }

    objc_msgSend(v8, "setLastSeenInnerLinkVersionHBO:", a2, v18);
    uint64_t v17 = objc_opt_self(v5);
    sub_100128908(v17);
    goto LABEL_4;
  }

  id v9 = sub_100121F34();
  int v10 = _NRLogIsLevelEnabled(v9, 17LL);

  if (!v10) {
    goto LABEL_5;
  }
  id v8 = (char *)sub_100121F34();
  _NRLogWithArgs(v8, 17LL, "%s called with null nrUUID", "+[NRDLocalDevice updateLastSeenInnerLinkVersionHBO:nrUUID:]");
LABEL_4:

LABEL_5:
}

void sub_100135884(uint64_t a1, uint64_t a2, void *a3)
{
  id v18 = a3;
  id v5 = (const char *)objc_opt_self(a1);
  uint64_t v6 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v6);

  if (v18)
  {
    id v7 = sub_100129B30((uint64_t)v5, v18);
    if (v7)
    {
      id v8 = v7;
    }

    else
    {
      id v11 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 16LL);

      id v5 = "+[NRDLocalDevice updateDeviceEndpointType:nrUUID:]";
      if (IsLevelEnabled)
      {
        id v13 = sub_100121F34();
        _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice updateDeviceEndpointType:nrUUID:]",  3425);
      }

      a2 = _os_log_pack_size(12LL);
      id v8 = (char *)&v18 - ((a2 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v14 = __error();
      uint64_t v15 = _os_log_pack_fill( v8,  a2,  *v14,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)uint64_t v15 = 136446210;
      *(void *)(v15 + 4) = "+[NRDLocalDevice updateDeviceEndpointType:nrUUID:]";
      id v16 = sub_100121F34();
      _NRLogAbortWithPack(v16, v8);
    }

    objc_msgSend(v8, "setDeviceType:", a2, v18);
    uint64_t v17 = objc_opt_self(v5);
    sub_100128908(v17);
    goto LABEL_4;
  }

  id v9 = sub_100121F34();
  int v10 = _NRLogIsLevelEnabled(v9, 17LL);

  if (!v10) {
    goto LABEL_5;
  }
  id v8 = (char *)sub_100121F34();
  _NRLogWithArgs(v8, 17LL, "%s called with null nrUUID", "+[NRDLocalDevice updateDeviceEndpointType:nrUUID:]");
LABEL_4:

LABEL_5:
}

void sub_100135A50(uint64_t a1, void *a2, void *a3)
{
  id v22 = a2;
  id v5 = a3;
  uint64_t v6 = (const char *)objc_opt_self(a1);
  id v7 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v7);

  if (v22)
  {
    if (!v5)
    {
      id v12 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 17LL);

      if (!IsLevelEnabled) {
        goto LABEL_6;
      }
      id v9 = (char *)sub_100121F34();
      _NRLogWithArgs(v9, 17LL, "%s called with null nrUUID");
      goto LABEL_5;
    }

    id v8 = sub_100129B30((uint64_t)v6, v5);
    if (v8)
    {
      id v9 = v8;
    }

    else
    {
      id v14 = sub_100121F34();
      int v15 = _NRLogIsLevelEnabled(v14, 16LL);

      uint64_t v6 = "+[NRDLocalDevice updateLastSeenName:nrUUID:]";
      if (v15)
      {
        id v16 = sub_100121F34();
        _NRLogWithArgs( v16,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice updateLastSeenName:nrUUID:]",  3439);
      }

      id v5 = (id)_os_log_pack_size(12LL);
      id v9 = (char *)&v22 - (((unint64_t)v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v17 = __error();
      uint64_t v18 = _os_log_pack_fill( v9,  v5,  *v17,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)uint64_t v18 = 136446210;
      *(void *)(v18 + 4) = "+[NRDLocalDevice updateLastSeenName:nrUUID:]";
      id v19 = sub_100121F34();
      _NRLogAbortWithPack(v19, v9);
    }

    id v20 = objc_msgSend(v22, "copy", v22);
    [v9 setLastSeenName:v20];

    uint64_t v21 = objc_opt_self(v6);
    sub_100128908(v21);
    goto LABEL_5;
  }

  id v10 = sub_100121F34();
  int v11 = _NRLogIsLevelEnabled(v10, 17LL);

  if (!v11) {
    goto LABEL_6;
  }
  id v9 = (char *)sub_100121F34();
  _NRLogWithArgs(v9, 17LL, "%s called with null name");
LABEL_5:

LABEL_6:
}

void sub_100135C80(uint64_t a1, void *a2, void *a3)
{
  id v22 = a2;
  id v5 = a3;
  uint64_t v6 = (const char *)objc_opt_self(a1);
  id v7 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v7);

  if (v22)
  {
    if (!v5)
    {
      id v12 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 17LL);

      if (!IsLevelEnabled) {
        goto LABEL_6;
      }
      id v9 = (char *)sub_100121F34();
      _NRLogWithArgs(v9, 17LL, "%s called with null nrUUID");
      goto LABEL_5;
    }

    id v8 = sub_100129B30((uint64_t)v6, v5);
    if (v8)
    {
      id v9 = v8;
    }

    else
    {
      id v14 = sub_100121F34();
      int v15 = _NRLogIsLevelEnabled(v14, 16LL);

      uint64_t v6 = "+[NRDLocalDevice updateLastSeenBuildVersion:nrUUID:]";
      if (v15)
      {
        id v16 = sub_100121F34();
        _NRLogWithArgs( v16,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice updateLastSeenBuildVersion:nrUUID:]",  3453);
      }

      id v5 = (id)_os_log_pack_size(12LL);
      id v9 = (char *)&v22 - (((unint64_t)v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v17 = __error();
      uint64_t v18 = _os_log_pack_fill( v9,  v5,  *v17,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)uint64_t v18 = 136446210;
      *(void *)(v18 + 4) = "+[NRDLocalDevice updateLastSeenBuildVersion:nrUUID:]";
      id v19 = sub_100121F34();
      _NRLogAbortWithPack(v19, v9);
    }

    id v20 = objc_msgSend(v22, "copy", v22);
    [v9 setLastSeenBuildVersion:v20];

    uint64_t v21 = objc_opt_self(v6);
    sub_100128908(v21);
    goto LABEL_5;
  }

  id v10 = sub_100121F34();
  int v11 = _NRLogIsLevelEnabled(v10, 17LL);

  if (!v11) {
    goto LABEL_6;
  }
  id v9 = (char *)sub_100121F34();
  _NRLogWithArgs(v9, 17LL, "%s called with null buildVersion");
LABEL_5:

LABEL_6:
}

void sub_100135EB0(uint64_t a1, uint64_t a2, void *a3)
{
  id v18 = a3;
  id v5 = (const char *)objc_opt_self(a1);
  uint64_t v6 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v6);

  if (v18)
  {
    id v7 = sub_100129B30((uint64_t)v5, v18);
    if (v7)
    {
      id v8 = v7;
      if ((v7[17] != 0) == (_DWORD)a2) {
        goto LABEL_4;
      }
    }

    else
    {
      id v11 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 16LL);

      id v5 = "+[NRDLocalDevice updateLastSeenAlwaysOnWiFiSupported:nrUUID:]";
      if (IsLevelEnabled)
      {
        id v13 = sub_100121F34();
        _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice updateLastSeenAlwaysOnWiFiSupported:nrUUID:]",  3466);
      }

      a2 = _os_log_pack_size(12LL);
      id v8 = (char *)&v18 - ((a2 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v14 = __error();
      uint64_t v15 = _os_log_pack_fill( v8,  a2,  *v14,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)uint64_t v15 = 136446210;
      *(void *)(v15 + 4) = "+[NRDLocalDevice updateLastSeenAlwaysOnWiFiSupported:nrUUID:]";
      id v16 = sub_100121F34();
      _NRLogAbortWithPack(v16, v8);
    }

    objc_msgSend(v8, "setLastSeenAlwaysOnWiFiSupported:", a2, v18);
    uint64_t v17 = objc_opt_self(v5);
    sub_100128908(v17);
    goto LABEL_4;
  }

  id v9 = sub_100121F34();
  int v10 = _NRLogIsLevelEnabled(v9, 17LL);

  if (!v10) {
    goto LABEL_5;
  }
  id v8 = (char *)sub_100121F34();
  _NRLogWithArgs( v8,  17LL,  "%s called with null nrUUID",  "+[NRDLocalDevice updateLastSeenAlwaysOnWiFiSupported:nrUUID:]");
LABEL_4:

LABEL_5:
}

void sub_100136084(uint64_t a1, void *a2, void *a3)
{
  id v27 = a2;
  id v5 = a3;
  uint64_t v6 = objc_opt_self(a1);
  id v7 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v7);

  if (v27)
  {
    if (!v5)
    {
      id v12 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 17LL);

      if (!IsLevelEnabled) {
        goto LABEL_6;
      }
      id v9 = (id *)sub_100121F34();
      _NRLogWithArgs(v9, 17LL, "%s called with null nrUUID");
      goto LABEL_5;
    }

    id v8 = sub_100129B30(v6, v5);
    if (v8)
    {
      id v9 = (id *)v8;
    }

    else
    {
      id v14 = sub_100121F34();
      int v15 = _NRLogIsLevelEnabled(v14, 16LL);

      if (v15)
      {
        id v16 = sub_100121F34();
        _NRLogWithArgs( v16,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice updateReceivedProxyNotifyPayload:nrUUID:]",  3480);
      }

      id v5 = (id)_os_log_pack_size(12LL);
      id v9 = (id *)((char *)&v27 - (((unint64_t)v5 + 15) & 0xFFFFFFFFFFFFFFF0LL));
      uint64_t v17 = __error();
      uint64_t v18 = _os_log_pack_fill( v9,  v5,  *v17,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)uint64_t v18 = 136446210;
      *(void *)(v18 + 4) = "+[NRDLocalDevice updateReceivedProxyNotifyPayload:nrUUID:]";
      id v19 = sub_100121F34();
      _NRLogAbortWithPack(v19, v9);
    }

    id v20 = objc_msgSend(v27, "copy", v27);
    [v9 setReceivedProxyNotifyPayload:v20];

    if ([v9[16] proxyCapability] == (id)2)
    {
      id v21 = sub_10010BB80(v27);
      [v9[16] setProxyProviderCriteria:v21];

      if ([v9[16] hasPoliciesForProxyCriteria])
      {
        id v22 = sub_100121F34();
        int v23 = _NRLogIsLevelEnabled(v22, 0LL);

        if (v23)
        {
          id v24 = sub_100121F34();
          uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v9[16] proxyProviderCriteria]);
          _NRLogWithArgs( v24,  0LL,  "%s%.30s:%-4d received proxy criteria %@",  "",  "+[NRDLocalDevice updateReceivedProxyNotifyPayload:nrUUID:]",  3488LL,  v25);
        }
      }
    }

    uint64_t v26 = objc_opt_self(v6);
    sub_100128908(v26);
    goto LABEL_5;
  }

  id v10 = sub_100121F34();
  int v11 = _NRLogIsLevelEnabled(v10, 17LL);

  if (!v11) {
    goto LABEL_6;
  }
  id v9 = (id *)sub_100121F34();
  _NRLogWithArgs(v9, 17LL, "%s called with null receivedProxyNotifyPayload");
LABEL_5:

LABEL_6:
}

void sub_100136370(uint64_t a1, uint64_t a2, void *a3)
{
  id v18 = a3;
  id v5 = (const char *)objc_opt_self(a1);
  uint64_t v6 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v6);

  if (v18)
  {
    id v7 = sub_100129B30((uint64_t)v5, v18);
    if (v7)
    {
      id v8 = v7;
      if ((v7[16] != 0) == (_DWORD)a2) {
        goto LABEL_4;
      }
    }

    else
    {
      id v11 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 16LL);

      id v5 = "+[NRDLocalDevice updateIsAltAccountDevice:nrUUID:]";
      if (IsLevelEnabled)
      {
        id v13 = sub_100121F34();
        _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice updateIsAltAccountDevice:nrUUID:]",  3499);
      }

      a2 = _os_log_pack_size(12LL);
      id v8 = (char *)&v18 - ((a2 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v14 = __error();
      uint64_t v15 = _os_log_pack_fill( v8,  a2,  *v14,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)uint64_t v15 = 136446210;
      *(void *)(v15 + 4) = "+[NRDLocalDevice updateIsAltAccountDevice:nrUUID:]";
      id v16 = sub_100121F34();
      _NRLogAbortWithPack(v16, v8);
    }

    objc_msgSend(v8, "setIsAltAccountDevice:", a2, v18);
    uint64_t v17 = objc_opt_self(v5);
    sub_100128908(v17);
    goto LABEL_4;
  }

  id v9 = sub_100121F34();
  int v10 = _NRLogIsLevelEnabled(v9, 17LL);

  if (!v10) {
    goto LABEL_5;
  }
  id v8 = (char *)sub_100121F34();
  _NRLogWithArgs(v8, 17LL, "%s called with null nrUUID", "+[NRDLocalDevice updateIsAltAccountDevice:nrUUID:]");
LABEL_4:

LABEL_5:
}

void sub_100136544(uint64_t a1, void *a2)
{
  id v16 = a2;
  uint64_t v3 = (char *)objc_opt_self(a1);
  uint64_t v4 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v4);

  if (v16)
  {
    id v5 = sub_100129B30((uint64_t)v3, v16);
    if (v5)
    {
      id v6 = v5;
      if (v5[11]) {
        goto LABEL_4;
      }
    }

    else
    {
      id v9 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 16LL);

      if (IsLevelEnabled)
      {
        id v11 = sub_100121F34();
        _NRLogWithArgs( v11,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice updateHasAuthenticatedWithIdentityForNRUUID:]",  3512);
      }

      id v6 = (id)_os_log_pack_size(12LL);
      uint64_t v3 = (char *)&v16 - (((unint64_t)v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v12 = __error();
      uint64_t v13 = _os_log_pack_fill( v3,  v6,  *v12,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)uint64_t v13 = 136446210;
      *(void *)(v13 + 4) = "+[NRDLocalDevice updateHasAuthenticatedWithIdentityForNRUUID:]";
      id v14 = sub_100121F34();
      _NRLogAbortWithPack(v14, v3);
    }

    objc_msgSend(v6, "setHasAuthenticatedWithIdentity:", 1, v16);
    uint64_t v15 = objc_opt_self(v3);
    sub_100128908(v15);
    goto LABEL_4;
  }

  id v7 = sub_100121F34();
  int v8 = _NRLogIsLevelEnabled(v7, 17LL);

  if (!v8) {
    goto LABEL_5;
  }
  id v6 = sub_100121F34();
  _NRLogWithArgs( v6,  17LL,  "%s called with null nrUUID",  "+[NRDLocalDevice updateHasAuthenticatedWithIdentityForNRUUID:]");
LABEL_4:

LABEL_5:
}

void sub_100136708(uint64_t a1, uint64_t a2, void *a3)
{
  id v18 = a3;
  id v5 = (const char *)objc_opt_self(a1);
  id v6 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v6);

  if (v18)
  {
    id v7 = sub_100129B30((uint64_t)v5, v18);
    if (v7)
    {
      int v8 = v7;
      if (*((void *)v7 + 18) == a2) {
        goto LABEL_4;
      }
    }

    else
    {
      id v11 = sub_100121F34();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 16LL);

      id v5 = "+[NRDLocalDevice updateRemoteDeviceFlags:nrUUID:]";
      if (IsLevelEnabled)
      {
        id v13 = sub_100121F34();
        _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice updateRemoteDeviceFlags:nrUUID:]",  3525);
      }

      a2 = _os_log_pack_size(12LL);
      int v8 = (char *)&v18 - ((a2 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v14 = __error();
      uint64_t v15 = _os_log_pack_fill( v8,  a2,  *v14,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)uint64_t v15 = 136446210;
      *(void *)(v15 + 4) = "+[NRDLocalDevice updateRemoteDeviceFlags:nrUUID:]";
      id v16 = sub_100121F34();
      _NRLogAbortWithPack(v16, v8);
    }

    objc_msgSend(v8, "setRemoteFlags:", a2, v18);
    uint64_t v17 = objc_opt_self(v5);
    sub_100128908(v17);
    goto LABEL_4;
  }

  id v9 = sub_100121F34();
  int v10 = _NRLogIsLevelEnabled(v9, 17LL);

  if (!v10) {
    goto LABEL_5;
  }
  int v8 = (char *)sub_100121F34();
  _NRLogWithArgs(v8, 17LL, "%s called with null nrUUID", "+[NRDLocalDevice updateRemoteDeviceFlags:nrUUID:]");
LABEL_4:

LABEL_5:
}

double sub_1001368D4(void *a1, _OWORD *a2)
{
  uint64_t v4 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v4);

  if (!a2)
  {
    id v9 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 16LL);

    if (IsLevelEnabled)
    {
      id v11 = sub_100121F34();
      _NRLogWithArgs( v11,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (outBytes) != ((void *)0)",  "",  "-[NRDLocalDevice writeLocalClassCInnerAddressBytes:]",  4015);
    }

    uint64_t v12 = _os_log_pack_size(12LL);
    id v13 = (char *)&v17 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v14 = __error();
    uint64_t v15 = _os_log_pack_fill( v13,  v12,  *v14,  &_mh_execute_header,  "%{public}s Assertion Failed: (outBytes) != ((void *)0)");
    *(_DWORD *)uint64_t v15 = 136446210;
    *(void *)(v15 + 4) = "-[NRDLocalDevice writeLocalClassCInnerAddressBytes:]";
    id v16 = sub_100121F34();
    _NRLogAbortWithPack(v16, v13);
  }

  uint64_t v18 = 0LL;
  __int128 v19 = 0uLL;
  int v20 = 0;
  id v5 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v5);

  id v6 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v6);

  id v7 = (void *)sub_10012D45C(a1, @"0");
  sub_10012DBE0((uint64_t)&OBJC_CLASS___NRDLocalDevice, &v18, v7);

  double result = *(double *)&v19;
  *a2 = v19;
  return result;
}

double sub_100136A64(void *a1, _OWORD *a2)
{
  uint64_t v4 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v4);

  if (!a2)
  {
    id v9 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 16LL);

    if (IsLevelEnabled)
    {
      id v11 = sub_100121F34();
      _NRLogWithArgs( v11,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (outBytes) != ((void *)0)",  "",  "-[NRDLocalDevice writeRemoteClassCInnerAddressBytes:]",  4047);
    }

    uint64_t v12 = _os_log_pack_size(12LL);
    id v13 = (char *)&v17 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v14 = __error();
    uint64_t v15 = _os_log_pack_fill( v13,  v12,  *v14,  &_mh_execute_header,  "%{public}s Assertion Failed: (outBytes) != ((void *)0)");
    *(_DWORD *)uint64_t v15 = 136446210;
    *(void *)(v15 + 4) = "-[NRDLocalDevice writeRemoteClassCInnerAddressBytes:]";
    id v16 = sub_100121F34();
    _NRLogAbortWithPack(v16, v13);
  }

  uint64_t v18 = 0LL;
  __int128 v19 = 0uLL;
  int v20 = 0;
  id v5 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v5);

  id v6 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v6);

  id v7 = sub_10012D610(a1, @"0");
  sub_10012DBE0((uint64_t)&OBJC_CLASS___NRDLocalDevice, &v18, v7);

  double result = *(double *)&v19;
  *a2 = v19;
  return result;
}

void *sub_100136BF4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  objc_opt_self(a1);
  id v7 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v7);

  if (qword_1001DCB98)
  {
    int v8 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1001DCB98 objectForKeyedSubscript:v5]);

    if (v8)
    {
      id v9 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1001DCB98 objectForKeyedSubscript:v5]);
      int v8 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:v6]);
    }
  }

  else
  {
    int v8 = 0LL;
  }

  return v8;
}

uint64_t sub_100136CA4(void *a1)
{
  id v2 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v2);

  uint64_t v3 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v3);

  uint64_t v4 = sub_10012CD2C(a1, @"0");
  uint64_t v5 = objc_claimAutoreleasedReturnValue([v4 hostname]);

  return v5;
}

uint64_t sub_100136D08(void *a1)
{
  id v2 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v2);

  uint64_t v3 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v3);

  uint64_t v4 = (void *)sub_10012D45C(a1, @"0");
  uint64_t v5 = objc_claimAutoreleasedReturnValue([v4 hostname]);

  return v5;
}

uint64_t sub_100136D6C(void *a1)
{
  id v2 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v2);

  uint64_t v3 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v3);

  uint64_t v4 = sub_10012D254(a1, @"0");
  uint64_t v5 = objc_claimAutoreleasedReturnValue([v4 hostname]);

  return v5;
}

uint64_t sub_100136DD0(void *a1)
{
  id v2 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v2);

  uint64_t v3 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v3);

  uint64_t v4 = sub_10012D610(a1, @"0");
  uint64_t v5 = objc_claimAutoreleasedReturnValue([v4 hostname]);

  return v5;
}

void *sub_100136E34(void *a1)
{
  uint64_t v1 = a1;
  if (a1)
  {
    id v2 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v2);

    uint64_t v3 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v3);

    uint64_t v4 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v4);

    uint64_t v5 = sub_10012D254(v1, @"0");
    id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 hostname]);

    v12[0] = v6;
    id v7 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v7);

    int v8 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v8);

    id v9 = sub_10012D610(v1, @"0");
    int v10 = (void *)objc_claimAutoreleasedReturnValue([v9 hostname]);

    v12[1] = v10;
    uint64_t v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v12, 2LL));
  }

  return v1;
}

uint64_t sub_100136F58(void *a1)
{
  id v2 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v2);

  __int128 v7 = 0uLL;
  int v9 = 0;
  uint64_t v8 = 0LL;
  uint64_t v3 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v3);

  uint64_t v4 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v4);

  uint64_t v5 = sub_10012CD2C(a1, @"0");
  sub_10012DBE0((uint64_t)&OBJC_CLASS___NRDLocalDevice, &v7, v5);

  WORD4(v7) = -32514;
  *(_DWORD *)((char *)&v7 + 10) = 0;
  HIWORD(v7) = 0;
  return objc_claimAutoreleasedReturnValue(+[NWAddressEndpoint endpointWithAddress:](&OBJC_CLASS___NWAddressEndpoint, "endpointWithAddress:", &v7));
}

uint64_t sub_100137014(void *a1)
{
  id v2 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v2);

  uint64_t v3 = (void *)sub_100136F58(a1);
  uint64_t v4 = objc_claimAutoreleasedReturnValue([v3 hostname]);

  return v4;
}

uint64_t sub_100137060(void *a1)
{
  id v2 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v2);

  uint64_t v3 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v3);

  uint64_t v4 = sub_10012CD2C(a1, @"0");
  v11[0] = v4;
  uint64_t v5 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v5);

  id v6 = (void *)sub_10012D45C(a1, @"0");
  v11[1] = v6;
  __int128 v7 = (void *)sub_100136F58(a1);
  v11[2] = v7;
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  @"192.0.0.6",  @"0"));
  v11[3] = v8;
  uint64_t v9 = objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v11, 4LL));

  return v9;
}

uint64_t sub_100137184(uint64_t a1, uint64_t a2, void *a3)
{
  id v7 = a3;
  uint64_t v8 = (char *)objc_opt_self(a1);
  uint64_t v9 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v9);

  if (!a2)
  {
    id v18 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 16LL);

    if (IsLevelEnabled)
    {
      id v20 = sub_100121F34();
      _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (addrBytes) != ((void *)0)",  "",  "+[NRDLocalDevice updateLocalClassDInnerAddressBytes:nrUUID:]",  4072);
    }

    id v7 = (id)_os_log_pack_size(12LL);
    uint64_t v8 = (char *)&v32 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v21 = *__error();
    uint64_t v22 = _os_log_pack_fill(v8, v7, v21, &_mh_execute_header, "%{public}s Assertion Failed: (addrBytes) != ((void *)0)");
    goto LABEL_21;
  }

  if (!v7)
  {
    id v23 = sub_100121F34();
    int v24 = _NRLogIsLevelEnabled(v23, 16LL);

    if (v24)
    {
      id v25 = sub_100121F34();
      _NRLogWithArgs( v25,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "+[NRDLocalDevice updateLocalClassDInnerAddressBytes:nrUUID:]",  4073);
    }

    id v7 = (id)_os_log_pack_size(12LL);
    uint64_t v8 = (char *)&v32 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v26 = *__error();
    uint64_t v22 = _os_log_pack_fill(v8, v7, v26, &_mh_execute_header, "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    goto LABEL_21;
  }

  int v10 = sub_100129C28((uint64_t)v8, v7, 0);
  if (!v10)
  {
    id v27 = sub_100121F34();
    int v28 = _NRLogIsLevelEnabled(v27, 16LL);

    if (v28)
    {
      id v29 = sub_100121F34();
      _NRLogWithArgs( v29,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice updateLocalClassDInnerAddressBytes:nrUUID:]",  4075);
    }

    id v7 = (id)_os_log_pack_size(12LL);
    uint64_t v8 = (char *)&v32 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v30 = *__error();
    uint64_t v22 = _os_log_pack_fill( v8,  v7,  v30,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
LABEL_21:
    *(_DWORD *)uint64_t v22 = 136446210;
    *(void *)(v22 + 4) = "+[NRDLocalDevice updateLocalClassDInnerAddressBytes:nrUUID:]";
    id v31 = sub_100121F34();
    _NRLogAbortWithPack(v31, v8);
LABEL_22:
    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    goto LABEL_6;
  }

  uint64_t v9 = (__objc2_meth_list *)v10;
  uint64_t v3 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a2, 16LL);
  id v11 = (void *)objc_claimAutoreleasedReturnValue(-[__objc2_meth_list localInnerIPv6AddressBytesClassD](v9, "localInnerIPv6AddressBytesClassD"));
  LODWORD(a2) = -[NSData isEqual:](v3, "isEqual:", v11);

  if ((a2 & 1) != 0) {
    goto LABEL_11;
  }
  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  if (qword_1001DCBD8 != -1) {
    goto LABEL_22;
  }
LABEL_6:
  if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
  {
    if (p_class_meths[379] != (__objc2_meth_list *)-1LL) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    id v12 = (id)qword_1001DCBD0;
    id v13 = (void *)objc_claimAutoreleasedReturnValue(-[__objc2_meth_list localInnerIPv6AddressBytesClassD](v9, "localInnerIPv6AddressBytesClassD"));
    id v14 = (void *)((uint64_t (*)(void))createIPv6AddrStringFromData)();
    IPv6AddrStringFromData = (void *)createIPv6AddrStringFromData(v3);
    _NRLogWithArgs( v12,  0LL,  "%s%.30s:%-4d Updating local classD inner address from %@ to %@ for %@",  "",  "+[NRDLocalDevice updateLocalClassDInnerAddressBytes:nrUUID:]",  4083LL,  v14,  IPv6AddrStringFromData,  v9);
  }

  -[__objc2_meth_list setLocalInnerIPv6AddressBytesClassD:](v9, "setLocalInnerIPv6AddressBytesClassD:", v3);
  uint64_t v16 = objc_opt_self(v8);
  sub_100128908(v16);
LABEL_11:

  return a2 ^ 1;
}

uint64_t sub_1001375A8(uint64_t a1, uint64_t a2, void *a3)
{
  id v7 = a3;
  uint64_t v8 = (char *)objc_opt_self(a1);
  uint64_t v9 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v9);

  if (!a2)
  {
    id v18 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 16LL);

    if (IsLevelEnabled)
    {
      id v20 = sub_100121F34();
      _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (addrBytes) != ((void *)0)",  "",  "+[NRDLocalDevice updateLocalClassCInnerAddressBytes:nrUUID:]",  4092);
    }

    id v7 = (id)_os_log_pack_size(12LL);
    uint64_t v8 = (char *)&v32 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v21 = *__error();
    uint64_t v22 = _os_log_pack_fill(v8, v7, v21, &_mh_execute_header, "%{public}s Assertion Failed: (addrBytes) != ((void *)0)");
    goto LABEL_21;
  }

  if (!v7)
  {
    id v23 = sub_100121F34();
    int v24 = _NRLogIsLevelEnabled(v23, 16LL);

    if (v24)
    {
      id v25 = sub_100121F34();
      _NRLogWithArgs( v25,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "+[NRDLocalDevice updateLocalClassCInnerAddressBytes:nrUUID:]",  4093);
    }

    id v7 = (id)_os_log_pack_size(12LL);
    uint64_t v8 = (char *)&v32 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v26 = *__error();
    uint64_t v22 = _os_log_pack_fill(v8, v7, v26, &_mh_execute_header, "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    goto LABEL_21;
  }

  int v10 = sub_100129C28((uint64_t)v8, v7, 0);
  if (!v10)
  {
    id v27 = sub_100121F34();
    int v28 = _NRLogIsLevelEnabled(v27, 16LL);

    if (v28)
    {
      id v29 = sub_100121F34();
      _NRLogWithArgs( v29,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice updateLocalClassCInnerAddressBytes:nrUUID:]",  4095);
    }

    id v7 = (id)_os_log_pack_size(12LL);
    uint64_t v8 = (char *)&v32 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v30 = *__error();
    uint64_t v22 = _os_log_pack_fill( v8,  v7,  v30,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
LABEL_21:
    *(_DWORD *)uint64_t v22 = 136446210;
    *(void *)(v22 + 4) = "+[NRDLocalDevice updateLocalClassCInnerAddressBytes:nrUUID:]";
    id v31 = sub_100121F34();
    _NRLogAbortWithPack(v31, v8);
LABEL_22:
    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    goto LABEL_6;
  }

  uint64_t v9 = (__objc2_meth_list *)v10;
  uint64_t v3 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a2, 16LL);
  id v11 = (void *)objc_claimAutoreleasedReturnValue(-[__objc2_meth_list localInnerIPv6AddressBytesClassC](v9, "localInnerIPv6AddressBytesClassC"));
  LODWORD(a2) = -[NSData isEqual:](v3, "isEqual:", v11);

  if ((a2 & 1) != 0) {
    goto LABEL_11;
  }
  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  if (qword_1001DCBD8 != -1) {
    goto LABEL_22;
  }
LABEL_6:
  if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
  {
    if (p_class_meths[379] != (__objc2_meth_list *)-1LL) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    id v12 = (id)qword_1001DCBD0;
    id v13 = (void *)objc_claimAutoreleasedReturnValue(-[__objc2_meth_list localInnerIPv6AddressBytesClassC](v9, "localInnerIPv6AddressBytesClassC"));
    IPv6AddrStringFromData = (void *)createIPv6AddrStringFromData(v13);
    uint64_t v15 = (void *)createIPv6AddrStringFromData(v3);
    _NRLogWithArgs( v12,  0LL,  "%s%.30s:%-4d Updating local classC inner address from %@ to %@ for %@",  "",  "+[NRDLocalDevice updateLocalClassCInnerAddressBytes:nrUUID:]",  4103LL,  IPv6AddrStringFromData,  v15,  v9);
  }

  -[__objc2_meth_list setLocalInnerIPv6AddressBytesClassC:](v9, "setLocalInnerIPv6AddressBytesClassC:", v3);
  uint64_t v16 = objc_opt_self(v8);
  sub_100128908(v16);
LABEL_11:

  return a2 ^ 1;
}

uint64_t sub_1001379CC(uint64_t a1, uint64_t a2, void *a3)
{
  id v7 = a3;
  uint64_t v8 = (char *)objc_opt_self(a1);
  uint64_t v9 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v9);

  if (!a2)
  {
    id v18 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 16LL);

    if (IsLevelEnabled)
    {
      id v20 = sub_100121F34();
      _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (addrBytes) != ((void *)0)",  "",  "+[NRDLocalDevice updateRemoteClassDInnerAddressBytes:nrUUID:]",  4112);
    }

    id v7 = (id)_os_log_pack_size(12LL);
    uint64_t v8 = (char *)&v32 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v21 = *__error();
    uint64_t v22 = _os_log_pack_fill(v8, v7, v21, &_mh_execute_header, "%{public}s Assertion Failed: (addrBytes) != ((void *)0)");
    goto LABEL_21;
  }

  if (!v7)
  {
    id v23 = sub_100121F34();
    int v24 = _NRLogIsLevelEnabled(v23, 16LL);

    if (v24)
    {
      id v25 = sub_100121F34();
      _NRLogWithArgs( v25,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "+[NRDLocalDevice updateRemoteClassDInnerAddressBytes:nrUUID:]",  4113);
    }

    id v7 = (id)_os_log_pack_size(12LL);
    uint64_t v8 = (char *)&v32 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v26 = *__error();
    uint64_t v22 = _os_log_pack_fill(v8, v7, v26, &_mh_execute_header, "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    goto LABEL_21;
  }

  int v10 = sub_100129C28((uint64_t)v8, v7, 0);
  if (!v10)
  {
    id v27 = sub_100121F34();
    int v28 = _NRLogIsLevelEnabled(v27, 16LL);

    if (v28)
    {
      id v29 = sub_100121F34();
      _NRLogWithArgs( v29,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice updateRemoteClassDInnerAddressBytes:nrUUID:]",  4115);
    }

    id v7 = (id)_os_log_pack_size(12LL);
    uint64_t v8 = (char *)&v32 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v30 = *__error();
    uint64_t v22 = _os_log_pack_fill( v8,  v7,  v30,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
LABEL_21:
    *(_DWORD *)uint64_t v22 = 136446210;
    *(void *)(v22 + 4) = "+[NRDLocalDevice updateRemoteClassDInnerAddressBytes:nrUUID:]";
    id v31 = sub_100121F34();
    _NRLogAbortWithPack(v31, v8);
LABEL_22:
    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    goto LABEL_6;
  }

  uint64_t v9 = (__objc2_meth_list *)v10;
  uint64_t v3 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a2, 16LL);
  id v11 = (void *)objc_claimAutoreleasedReturnValue(-[__objc2_meth_list remoteInnerIPv6AddressBytesClassD](v9, "remoteInnerIPv6AddressBytesClassD"));
  LODWORD(a2) = -[NSData isEqual:](v3, "isEqual:", v11);

  if ((a2 & 1) != 0) {
    goto LABEL_11;
  }
  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  if (qword_1001DCBD8 != -1) {
    goto LABEL_22;
  }
LABEL_6:
  if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
  {
    if (p_class_meths[379] != (__objc2_meth_list *)-1LL) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    id v12 = (id)qword_1001DCBD0;
    id v13 = (void *)objc_claimAutoreleasedReturnValue(-[__objc2_meth_list remoteInnerIPv6AddressBytesClassD](v9, "remoteInnerIPv6AddressBytesClassD"));
    IPv6AddrStringFromData = (void *)createIPv6AddrStringFromData(v13);
    uint64_t v15 = (void *)createIPv6AddrStringFromData(v3);
    _NRLogWithArgs( v12,  0LL,  "%s%.30s:%-4d Updating remote classD inner address from %@ to %@ for %@",  "",  "+[NRDLocalDevice updateRemoteClassDInnerAddressBytes:nrUUID:]",  4123LL,  IPv6AddrStringFromData,  v15,  v9);
  }

  -[__objc2_meth_list setRemoteInnerIPv6AddressBytesClassD:](v9, "setRemoteInnerIPv6AddressBytesClassD:", v3);
  uint64_t v16 = objc_opt_self(v8);
  sub_100128908(v16);
LABEL_11:

  return a2 ^ 1;
}

uint64_t sub_100137DF0(uint64_t a1, uint64_t a2, void *a3)
{
  id v7 = a3;
  uint64_t v8 = (char *)objc_opt_self(a1);
  uint64_t v9 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v9);

  if (!a2)
  {
    id v18 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 16LL);

    if (IsLevelEnabled)
    {
      id v20 = sub_100121F34();
      _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (addrBytes) != ((void *)0)",  "",  "+[NRDLocalDevice updateRemoteClassCInnerAddressBytes:nrUUID:]",  4132);
    }

    id v7 = (id)_os_log_pack_size(12LL);
    uint64_t v8 = (char *)&v32 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v21 = *__error();
    uint64_t v22 = _os_log_pack_fill(v8, v7, v21, &_mh_execute_header, "%{public}s Assertion Failed: (addrBytes) != ((void *)0)");
    goto LABEL_21;
  }

  if (!v7)
  {
    id v23 = sub_100121F34();
    int v24 = _NRLogIsLevelEnabled(v23, 16LL);

    if (v24)
    {
      id v25 = sub_100121F34();
      _NRLogWithArgs( v25,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "+[NRDLocalDevice updateRemoteClassCInnerAddressBytes:nrUUID:]",  4133);
    }

    id v7 = (id)_os_log_pack_size(12LL);
    uint64_t v8 = (char *)&v32 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v26 = *__error();
    uint64_t v22 = _os_log_pack_fill(v8, v7, v26, &_mh_execute_header, "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    goto LABEL_21;
  }

  int v10 = sub_100129C28((uint64_t)v8, v7, 0);
  if (!v10)
  {
    id v27 = sub_100121F34();
    int v28 = _NRLogIsLevelEnabled(v27, 16LL);

    if (v28)
    {
      id v29 = sub_100121F34();
      _NRLogWithArgs( v29,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice updateRemoteClassCInnerAddressBytes:nrUUID:]",  4135);
    }

    id v7 = (id)_os_log_pack_size(12LL);
    uint64_t v8 = (char *)&v32 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v30 = *__error();
    uint64_t v22 = _os_log_pack_fill( v8,  v7,  v30,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
LABEL_21:
    *(_DWORD *)uint64_t v22 = 136446210;
    *(void *)(v22 + 4) = "+[NRDLocalDevice updateRemoteClassCInnerAddressBytes:nrUUID:]";
    id v31 = sub_100121F34();
    _NRLogAbortWithPack(v31, v8);
LABEL_22:
    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    goto LABEL_6;
  }

  uint64_t v9 = (__objc2_meth_list *)v10;
  uint64_t v3 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a2, 16LL);
  id v11 = (void *)objc_claimAutoreleasedReturnValue(-[__objc2_meth_list remoteInnerIPv6AddressBytesClassC](v9, "remoteInnerIPv6AddressBytesClassC"));
  LODWORD(a2) = -[NSData isEqual:](v3, "isEqual:", v11);

  if ((a2 & 1) != 0) {
    goto LABEL_11;
  }
  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  if (qword_1001DCBD8 != -1) {
    goto LABEL_22;
  }
LABEL_6:
  if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
  {
    if (p_class_meths[379] != (__objc2_meth_list *)-1LL) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    id v12 = (id)qword_1001DCBD0;
    id v13 = (void *)objc_claimAutoreleasedReturnValue(-[__objc2_meth_list remoteInnerIPv6AddressBytesClassC](v9, "remoteInnerIPv6AddressBytesClassC"));
    IPv6AddrStringFromData = (void *)createIPv6AddrStringFromData(v13);
    uint64_t v15 = (void *)createIPv6AddrStringFromData(v3);
    _NRLogWithArgs( v12,  0LL,  "%s%.30s:%-4d Updating remote classC inner address from %@ to %@ for %@",  "",  "+[NRDLocalDevice updateRemoteClassCInnerAddressBytes:nrUUID:]",  4143LL,  IPv6AddrStringFromData,  v15,  v9);
  }

  -[__objc2_meth_list setRemoteInnerIPv6AddressBytesClassC:](v9, "setRemoteInnerIPv6AddressBytesClassC:", v3);
  uint64_t v16 = objc_opt_self(v8);
  sub_100128908(v16);
LABEL_11:

  return a2 ^ 1;
}

void sub_100138214(uint64_t a1, void *a2, void *a3)
{
  id v25 = a2;
  id v5 = a3;
  uint64_t v6 = objc_opt_self(a1);
  id v7 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v7);

  if (!v5)
  {
    id v11 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 16LL);

    if (IsLevelEnabled)
    {
      id v13 = sub_100121F34();
      _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "+[NRDLocalDevice updateBluetoothUUID:nrUUID:]",  4152);
    }

    uint64_t v14 = _os_log_pack_size(12LL);
    uint64_t v15 = (char *)&v25 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v16 = __error();
    uint64_t v17 = _os_log_pack_fill( v15,  v14,  *v16,  &_mh_execute_header,  "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    *(_DWORD *)uint64_t v17 = 136446210;
    *(void *)(v17 + 4) = "+[NRDLocalDevice updateBluetoothUUID:nrUUID:]";
LABEL_13:
    id v24 = sub_100121F34();
    _NRLogAbortWithPack(v24, v15);
  }

  uint64_t v8 = sub_100129C28(v6, v5, 0);
  if (!v8)
  {
    id v18 = sub_100121F34();
    int v19 = _NRLogIsLevelEnabled(v18, 16LL);

    if (v19)
    {
      id v20 = sub_100121F34();
      _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice updateBluetoothUUID:nrUUID:]",  4154);
    }

    uint64_t v21 = _os_log_pack_size(12LL);
    uint64_t v15 = (char *)&v25 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v22 = __error();
    uint64_t v23 = _os_log_pack_fill( v15,  v21,  *v22,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    *(_DWORD *)uint64_t v23 = 136446210;
    *(void *)(v23 + 4) = "+[NRDLocalDevice updateBluetoothUUID:nrUUID:]";
    goto LABEL_13;
  }

  uint64_t v9 = v8;
  if (![*((id *)v8 + 5) isEqual:v25] || (v25 != 0) != (v9[10] != 0))
  {
    objc_msgSend(v9, "setBluetoothUUID:");
    [v9 setHasCompletedBluetoothPairing:v25 != 0];
    uint64_t v10 = objc_opt_self(v6);
    sub_100128908(v10);
  }
}

void sub_100138494(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = objc_opt_self(a1);
  uint64_t v8 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v8);

  if (!v6)
  {
    id v18 = sub_100121F34();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 16LL);

    if (IsLevelEnabled)
    {
      id v20 = sub_100121F34();
      _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "+[NRDLocalDevice updateIDSDeviceID:nrUUID:]",  4174);
    }

    uint64_t v21 = _os_log_pack_size(12LL);
    uint64_t v22 = (char *)&v32 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v23 = __error();
    uint64_t v24 = _os_log_pack_fill( v22,  v21,  *v23,  &_mh_execute_header,  "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    *(_DWORD *)uint64_t v24 = 136446210;
    *(void *)(v24 + 4) = "+[NRDLocalDevice updateIDSDeviceID:nrUUID:]";
LABEL_21:
    id v31 = sub_100121F34();
    _NRLogAbortWithPack(v31, v22);
  }

  uint64_t v9 = sub_100129C28(v7, v6, 0);
  if (!v9)
  {
    id v25 = sub_100121F34();
    int v26 = _NRLogIsLevelEnabled(v25, 16LL);

    if (v26)
    {
      id v27 = sub_100121F34();
      _NRLogWithArgs( v27,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice updateIDSDeviceID:nrUUID:]",  4176);
    }

    uint64_t v28 = _os_log_pack_size(12LL);
    uint64_t v22 = (char *)&v32 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v29 = __error();
    uint64_t v30 = _os_log_pack_fill( v22,  v28,  *v29,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    *(_DWORD *)uint64_t v30 = 136446210;
    *(void *)(v30 + 4) = "+[NRDLocalDevice updateIDSDeviceID:nrUUID:]";
    goto LABEL_21;
  }

  uint64_t v10 = v9;
  if (([*((id *)v9 + 6) isEqualToString:v5] & 1) == 0)
  {
    [v10 setIdsDeviceID:v5];
    uint64_t v11 = objc_opt_self(v7);
    sub_100128908(v11);
    if (qword_1001DCBC8)
    {
      id v12 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1001DCBC8 objectForKeyedSubscript:v6]);

      if (v12)
      {
        id v13 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1001DCBC8 objectForKeyedSubscript:v6]);
        __int128 v32 = 0u;
        __int128 v33 = 0u;
        __int128 v34 = 0u;
        __int128 v35 = 0u;
        id v14 = [v13 countByEnumeratingWithState:&v32 objects:v36 count:16];
        if (v14)
        {
          id v15 = v14;
          uint64_t v16 = *(void *)v33;
          do
          {
            for (uint64_t i = 0LL; i != v15; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v33 != v16) {
                objc_enumerationMutation(v13);
              }
              (*(void (**)(void))(*(void *)(*((void *)&v32 + 1) + 8LL * (void)i) + 16LL))();
            }

            id v15 = [v13 countByEnumeratingWithState:&v32 objects:v36 count:16];
          }

          while (v15);
        }

        [(id)qword_1001DCBC8 setObject:0 forKeyedSubscript:v6];
      }
    }
  }
}

void sub_100139DFC(uint64_t a1)
{
  if (a1 && sub_10001E054(*(void *)(a1 + 112)) && *(void *)(a1 + 64))
  {
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v2 = (id)qword_1001DC870;
    if (v2 && (unsigned int v3 = v2[5], v2, v3 >= 0x1E))
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCBF0, 0LL))
      {
        if (qword_1001DCBF8 != -1) {
          dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
        }
        _NRLogWithArgs( qword_1001DCBF0,  0LL,  "%s%.30s:%-4d Deferring creating awdl link due to critical thermal conditions",  "",  "-[NRLinkManagerWiFi createAWDLLinkIfApplicable]",  1444);
      }
    }

    else
    {
      id v6 = sub_100131A50((uint64_t)&OBJC_CLASS___NRDLocalDevice);
      sub_100139FB8((id *)a1, v6);
      if (*(_BYTE *)(a1 + 39))
      {
        uint64_t v4 = sub_1001314D4((uint64_t)&OBJC_CLASS___NRDLocalDevice);
        sub_100139FB8((id *)a1, v4);
      }

      id v5 = sub_1001317AC((uint64_t)&OBJC_CLASS___NRDLocalDevice);
      if (-[NSMutableArray count](v5, "count")) {
        sub_100139FB8((id *)a1, v5);
      }
    }
  }

void sub_100139FB8(id *a1, void *a2)
{
  id v3 = a2;
  if (sub_10001E054((uint64_t)a1[14]) && a1[8])
  {
    __int128 v46 = 0u;
    __int128 v47 = 0u;
    __int128 v44 = 0u;
    __int128 v45 = 0u;
    id v36 = v3;
    id obj = v3;
    id v39 = [obj countByEnumeratingWithState:&v44 objects:v49 count:16];
    if (v39)
    {
      uint64_t v38 = *(void *)v45;
      do
      {
        for (uint64_t i = 0LL; i != v39; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v45 != v38) {
            objc_enumerationMutation(obj);
          }
          id v5 = *(void **)(*((void *)&v44 + 1) + 8LL * (void)i);
          __int128 v40 = 0u;
          __int128 v41 = 0u;
          __int128 v42 = 0u;
          __int128 v43 = 0u;
          id v6 = a1[19];
          id v7 = [v6 countByEnumeratingWithState:&v40 objects:v48 count:16];
          if (v7)
          {
            id v8 = v7;
            uint64_t v9 = *(void *)v41;
LABEL_15:
            uint64_t v10 = 0LL;
            while (1)
            {
              if (*(void *)v41 != v9) {
                objc_enumerationMutation(v6);
              }
              uint64_t v11 = *(void **)(*((void *)&v40 + 1) + 8 * v10);
              if ([v11 subtype] == 102)
              {
                id v12 = (void *)objc_claimAutoreleasedReturnValue([v11 nrUUID]);
                unsigned __int8 v13 = [v12 isEqual:v5];

                if ((v13 & 1) != 0) {
                  break;
                }
              }

              if (v8 == (id)++v10)
              {
                id v8 = [v6 countByEnumeratingWithState:&v40 objects:v48 count:16];
                if (!v8) {
                  goto LABEL_22;
                }
                goto LABEL_15;
              }
            }
          }

          else
          {
LABEL_22:

            id v14 = a1[14];
            id v15 = v14;
            if (v14) {
              uint64_t v16 = (void *)*((void *)v14 + 9);
            }
            else {
              uint64_t v16 = 0LL;
            }
            id v17 = v16;
            id v18 = (void *)objc_claimAutoreleasedReturnValue([v17 objectForKeyedSubscript:v5]);

            id v6 = (id)objc_claimAutoreleasedReturnValue([v18 firstObject]);
            if (v6)
            {
              id v19 = [v6 addressFamily];
              if (v19 == [a1[8] addressFamily])
              {
                id v20 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v5);
                uint64_t v21 = (id *)v20;
                if (v20)
                {
                  id v22 = *((id *)v20 + 16);
                  uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v22 allowedLinkTypes]);
                  if ([v23 containsObject:&off_1001BC910])
                  {
                    id v24 = v21[16];
                    id v25 = (void *)objc_claimAutoreleasedReturnValue([v24 allowedLinkSubtypes]);
                    unsigned __int8 v26 = [v25 containsObject:&off_1001BC958];

                    if ((v26 & 1) != 0)
                    {
                      id v27 = objc_alloc(&OBJC_CLASS___NRLinkAWDL);
                      id v28 = a1[3];
                      id v29 = a1[14];
                      if (v29) {
                        id v29 = (void *)v29[3];
                      }
                      uint64_t v30 = v29;
                      id v31 = a1[8];
                      __int128 v32 = (void *)objc_claimAutoreleasedReturnValue([v31 port]);
                      id v33 = -[NRLinkAWDL initLinkWithQueue:linkDelegate:nrUUID:wifiInterfaceName:localOuterEndpoint:remoteOuterEndpoint:listenerPortString:]( v27,  "initLinkWithQueue:linkDelegate:nrUUID:wifiInterfaceName:localOuterEndpoint:remoteOuterEndp oint:listenerPortString:",  v28,  a1,  v5,  v30,  v31,  v6,  v32);

                      if (!v33) {
                        [a1 reportEvent:3201];
                      }

LABEL_8:
                      goto LABEL_9;
                    }
                  }

                  else
                  {
                  }
                }

                if (qword_1001DCBF8 != -1) {
                  dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                }
                if (_NRLogIsLevelEnabled(qword_1001DCBF0, 0LL))
                {
                  if (qword_1001DCBF8 != -1) {
                    dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                  }
                  _NRLogWithArgs( qword_1001DCBF0,  0LL,  "%s%.30s:%-4d Deferring creating link for %@ as AWDL is unsupported",  "",  "-[NRLinkManagerWiFi createAWDLLinkForNRUUIDs:]",  1411LL,  v21);
                }

                goto LABEL_8;
              }

              if (qword_1001DCBF8 != -1) {
                dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
              }
              if (_NRLogIsLevelEnabled(qword_1001DCBF0, 0LL))
              {
                if (qword_1001DCBF8 != -1) {
                  dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                }
                id v34 = a1[8];
                id v35 = (id)qword_1001DCBF0;
                _NRLogWithArgs( v35,  0LL,  "%s%.30s:%-4d Deferring creating link as the address families do not match: %@/%@",  "",  "-[NRLinkManagerWiFi createAWDLLinkForNRUUIDs:]",  1399LL,  v34,  v6);
              }
            }

            else
            {
              if (qword_1001DCBF8 != -1) {
                dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
              }
              if (_NRLogIsLevelEnabled(qword_1001DCBF0, 0LL))
              {
                if (qword_1001DCBF8 != -1) {
                  dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                }
                _NRLogWithArgs( qword_1001DCBF0,  0LL,  "%s%.30s:%-4d Deferring creating link as the peer AWDL endpoint is unavailable",  "",  "-[NRLinkManagerWiFi createAWDLLinkForNRUUIDs:]",  1403);
                id v6 = 0LL;
              }

              else
              {
                id v6 = 0LL;
              }
            }
          }

void sub_10013A584(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  id v2 = (void *)qword_1001DCBF0;
  qword_1001DCBF0 = (uint64_t)v1;
}

void sub_10013A5B4(void *a1)
{
  uint64_t v2 = a1[4];
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
  }
  else {
    id WeakRetained = 0LL;
  }
  id v4 = WeakRetained;
  [WeakRetained linkDidReceiveData:a1[5] data:a1[6]];
}

id sub_10013A600()
{
  if (qword_1001DCBF8 != -1) {
    dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
  }
  return (id)qword_1001DCBF0;
}

void sub_10013A640(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
  }
  else {
    id WeakRetained = 0LL;
  }
  [WeakRetained linkIsUnavailable:*(void *)(a1 + 40)];

  if ([*(id *)(a1 + 40) subtype] == 101
    && (uint64_t v4 = *(void *)(a1 + 32)) != 0
    && sub_10001E054(*(void *)(v4 + 104)))
  {
    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCBF0, 1LL))
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      _NRLogWithArgs( qword_1001DCBF0,  1LL,  "%s%.30s:%-4d Forcing interface availability event, as the underlying transport is still available",  "",  "-[NRLinkManagerWiFi linkIsUnavailable:]_block_invoke",  502);
    }

    sub_10013A914(*(void *)(a1 + 32));
  }

  else if ([*(id *)(a1 + 40) subtype] == 102 {
         && (uint64_t v5 = *(void *)(a1 + 32)) != 0
  }
         && sub_10001E054(*(void *)(v5 + 112)))
  {
    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCBF0, 1LL))
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      _NRLogWithArgs( qword_1001DCBF0,  1LL,  "%s%.30s:%-4d Forcing interface availability event, as the underlying transport is still available",  "",  "-[NRLinkManagerWiFi linkIsUnavailable:]_block_invoke",  505);
    }

    sub_100139DFC(*(void *)(a1 + 32));
  }

  else if ([*(id *)(a1 + 40) subtype] == 104)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    if (v6)
    {
      if (sub_10001E054(*(void *)(v6 + 128)))
      {
        if (qword_1001DCBF8 != -1) {
          dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCBF0, 1LL))
        {
          if (qword_1001DCBF8 != -1) {
            dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
          }
          _NRLogWithArgs( qword_1001DCBF0,  1LL,  "%s%.30s:%-4d Forcing interface availability event, as the underlying transport is still available",  "",  "-[NRLinkManagerWiFi linkIsUnavailable:]_block_invoke",  508);
        }

        sub_10013B098(*(void *)(a1 + 32));
      }
    }
  }

void sub_10013A914(uint64_t a1)
{
  if (a1 && sub_10001E054(*(void *)(a1 + 104)) && *(void *)(a1 + 56))
  {
    id v39 = sub_100131A50((uint64_t)&OBJC_CLASS___NRDLocalDevice);
    if (-[NSMutableArray count](v39, "count"))
    {
      uint64_t v2 = v39;
      id v3 = (dispatch_queue_s *)*(id *)(a1 + 24);
      dispatch_assert_queue_V2(v3);

      if (!*(void *)(a1 + 216))
      {
        objc_opt_self(&OBJC_CLASS___NRLinkManagerWiFi);
        if (sub_10001E054(*(void *)(a1 + 104)))
        {
          if (*(void *)(a1 + 56))
          {
            __int128 v42 = 0u;
            __int128 v43 = 0u;
            __int128 v40 = 0u;
            __int128 v41 = 0u;
            uint64_t v38 = v2;
            uint64_t v4 = v2;
            id v5 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v4,  "countByEnumeratingWithState:objects:count:",  &v40,  v44,  16LL);
            if (v5)
            {
              id v6 = v5;
              uint64_t v7 = *(void *)v41;
LABEL_13:
              uint64_t v8 = 0LL;
              while (1)
              {
                if (*(void *)v41 != v7) {
                  objc_enumerationMutation(v4);
                }
                uint64_t v9 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(*((void *)&v40 + 1) + 8 * v8));
                uint64_t v10 = v9;
                uint64_t v11 = v9 ? (void *)*((void *)v9 + 16) : 0LL;
                id v12 = v11;

                if (v12)
                {
                  unsigned __int8 v13 = v10 ? (void *)*((void *)v10 + 16) : 0LL;
                  id v14 = v13;
                  unsigned int v15 = [v14 allowsDirectToCloud];

                  if (v15) {
                    break;
                  }
                }

                if (v6 == (id)++v8)
                {
                  id v6 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v4,  "countByEnumeratingWithState:objects:count:",  &v40,  v44,  16LL);
                  if (!v6) {
                    goto LABEL_46;
                  }
                  goto LABEL_13;
                }
              }

              uint64_t v16 = *(void *)(a1 + 216);
              uint64_t v2 = v38;
              if (!v16)
              {
                id v17 = objc_alloc(&OBJC_CLASS___NRDirectToCloudAgent);
                id v18 = *(id *)(a1 + 24);
                id v19 = sub_10006913C((id *)&v17->super.isa, v18);
                id v20 = *(void **)(a1 + 216);
                *(void *)(a1 + 216) = v19;

                [(id)a1 reportEvent:14001];
                uint64_t v16 = *(void *)(a1 + 216);
                if (!v16) {
                  goto LABEL_81;
                }
              }

              dispatch_assert_queue_V2(*(dispatch_queue_t *)(v16 + 32));
              if (*(_BYTE *)(v16 + 14)) {
                goto LABEL_67;
              }
              if (qword_1001DC818 != -1) {
                dispatch_once(&qword_1001DC818, &stru_1001AEB48);
              }
              if (_NRLogIsLevelEnabled(qword_1001DC810, 0LL))
              {
                if (qword_1001DC818 != -1) {
                  dispatch_once(&qword_1001DC818, &stru_1001AEB48);
                }
                id v21 = (id)qword_1001DC810;
                id v22 = (void *)objc_claimAutoreleasedReturnValue([(id)v16 agentDescription]);
                _NRLogWithArgs( v21,  0LL,  "%s%.30s:%-4d registerAgent: %@",  "",  "-[NRDirectToCloudAgent registerAgent]",  102LL,  v22);
              }

              uint64_t v23 = -[NWNetworkAgentRegistration initWithNetworkAgentClass:]( objc_alloc(&OBJC_CLASS___NWNetworkAgentRegistration),  "initWithNetworkAgentClass:",  objc_opt_class(v16));
              id v24 = *(void **)(v16 + 40);
              *(void *)(v16 + 40) = v23;

              if (*(void *)(v16 + 40))
              {
                objc_opt_self(&OBJC_CLASS___NRLinkDirector);
                if (qword_1001DC878 != -1) {
                  dispatch_once(&qword_1001DC878, &stru_1001AEED0);
                }
                id v25 = (id *)(id)qword_1001DC870;
                unsigned __int8 v26 = v25;
                if (v25)
                {
                  id v27 = v25[6];
                  id v28 = v27;
                  if (v27)
                  {
                    id v29 = (void *)v27[13];
                    if (v29) {
                      id v29 = (void *)v29[3];
                    }
                    id v27 = v29;
                  }
                }

                else
                {
                  id v28 = 0LL;
                  id v27 = 0LL;
                }

                uint64_t v30 = *(void **)(v16 + 48);
                *(void *)(v16 + 4_Block_object_dispose(va, 8) = v27;

                if (*(void *)(v16 + 48))
                {
                  if ([*(id *)(v16 + 40) registerNetworkAgent:v16])
                  {
                    *(_BYTE *)(v16 + 14) = 1;
                    [(id)v16 setActive:1];
                    uint64_t v31 = *(void *)(v16 + 48);
                    id v32 = *(id *)(v16 + 40);
                    [v32 addNetworkAgentToInterfaceNamed:v31];

                    [*(id *)(v16 + 40) updateNetworkAgent:v16];
                    sub_10011BB18(0LL, 14002, 0LL, 0LL);
                  }

                  else
                  {
                    if (qword_1001DC818 != -1) {
                      dispatch_once(&qword_1001DC818, &stru_1001AEB48);
                    }
                    if (_NRLogIsLevelEnabled(qword_1001DC810, 17LL))
                    {
                      if (qword_1001DC818 != -1) {
                        dispatch_once(&qword_1001DC818, &stru_1001AEB48);
                      }
                      _NRLogWithArgs(qword_1001DC810, 17LL, "unable register network agent");
                    }
                  }
                }

                else
                {
                  if (qword_1001DC818 != -1) {
                    dispatch_once(&qword_1001DC818, &stru_1001AEB48);
                  }
                  if (_NRLogIsLevelEnabled(qword_1001DC810, 17LL))
                  {
                    if (qword_1001DC818 != -1) {
                      dispatch_once(&qword_1001DC818, &stru_1001AEB48);
                    }
                    _NRLogWithArgs(qword_1001DC810, 17LL, "unable to find the WiFi interface");
                  }
                }
              }

              else
              {
                if (qword_1001DC818 != -1) {
                  dispatch_once(&qword_1001DC818, &stru_1001AEB48);
                }
                if (_NRLogIsLevelEnabled(qword_1001DC810, 17LL))
                {
                  if (qword_1001DC818 != -1) {
                    dispatch_once(&qword_1001DC818, &stru_1001AEB48);
                  }
                  _NRLogWithArgs(qword_1001DC810, 17LL, "unable to allocate registration object");
                }
              }

              if (*(_BYTE *)(v16 + 14)
                || (id v35 = *(void **)(v16 + 40)) != 0LL
                && ([v35 unregisterNetworkAgent],
                    id v36 = *(void **)(v16 + 40),
                    *(void *)(v16 + 40) = 0LL,
                    v36,
                    *(_BYTE *)(v16 + 14)))
              {
LABEL_67:
                if (*(void *)(a1 + 216) && *(_DWORD *)(a1 + 44) == -1)
                {
                  uint32_t v34 = notify_register_check( (const char *)[@"AvoidCompanionSupported" UTF8String],  (int *)(a1 + 44));
                  if (v34 || *(_DWORD *)(a1 + 44) == -1)
                  {
                    if (qword_1001DCBF8 != -1) {
                      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                    }
                    if (_NRLogIsLevelEnabled(qword_1001DCBF0, 17LL))
                    {
                      if (qword_1001DCBF8 != -1) {
                        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                      }
                      _NRLogWithArgs(qword_1001DCBF0, 17LL, "notify_register_check(%u) failed", v34);
                    }
                  }

                  else
                  {
                    sub_10013C8C0(a1, 1);
                  }
                }
              }

              else
              {
LABEL_81:
                if (qword_1001DCBF8 != -1) {
                  dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                }
                if (_NRLogIsLevelEnabled(qword_1001DCBF0, 17LL))
                {
                  id v37 = sub_10013A600();
                  _NRLogWithArgs(v37, 17LL, "Failed to register direct-to-cloud agent");
                }

                sub_10013BC04(a1);
              }
            }

            else
            {
LABEL_46:

              sub_10013BC04(a1);
              uint64_t v2 = v38;
            }
          }
        }
      }
    }

    else
    {
      sub_10013BC04(a1);
    }

    sub_10013BCA8(a1, v39);
    id v33 = sub_1001317AC((uint64_t)&OBJC_CLASS___NRDLocalDevice);
    if (-[NSMutableArray count](v33, "count")) {
      sub_10013BCA8(a1, v33);
    }
  }

void sub_10013B098(uint64_t a1)
{
  if (a1 && sub_10001E054(*(void *)(a1 + 128)))
  {
    id v3 = sub_100131A50((uint64_t)&OBJC_CLASS___NRDLocalDevice);
    sub_10013B128(a1, v3);
    uint64_t v2 = sub_1001317AC((uint64_t)&OBJC_CLASS___NRDLocalDevice);
    if (-[NSMutableArray count](v2, "count")) {
      sub_10013B128(a1, v2);
    }
  }

void sub_10013B128(uint64_t a1, void *a2)
{
  id v64 = a2;
  id v3 = &OBJC_IVAR___NRAnalyticsALUAdviceStats__timeSinceLastAdvice;
  if (sub_10001E054(*(void *)(a1 + 128)))
  {
    __int128 v65 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    uint64_t v4 = *(void **)(a1 + 128);
    uint64_t v76 = a1;
    if (v4) {
      uint64_t v4 = (void *)v4[7];
    }
    id v5 = v4;
    id v6 = [v5 count];

    if (v6)
    {
      uint64_t v7 = *(void **)(v76 + 128);
      if (v7) {
        uint64_t v7 = (void *)v7[7];
      }
      uint64_t v8 = v7;
      -[NSMutableArray addObjectsFromArray:](v65, "addObjectsFromArray:", v8);
    }

    uint64_t v9 = *(void **)(v76 + 128);
    if (v9) {
      uint64_t v9 = (void *)v9[8];
    }
    uint64_t v10 = v9;
    id v11 = [v10 count];

    if (v11)
    {
      id v12 = *(void **)(v76 + 128);
      if (v12) {
        id v12 = (void *)v12[8];
      }
      unsigned __int8 v13 = v12;
      -[NSMutableArray addObjectsFromArray:](v65, "addObjectsFromArray:", v13);
    }

    __int128 v96 = 0u;
    __int128 v97 = 0u;
    __int128 v94 = 0u;
    __int128 v95 = 0u;
    id obj = v64;
    id v68 = [obj countByEnumeratingWithState:&v94 objects:v101 count:16];
    if (v68)
    {
      id v14 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
      uint64_t v67 = *(void *)v95;
      do
      {
        uint64_t v15 = 0LL;
        do
        {
          if (*(void *)v95 != v67) {
            objc_enumerationMutation(obj);
          }
          id v81 = *(void **)(*((void *)&v94 + 1) + 8 * v15);
          uint64_t v16 = sub_100129B30((uint64_t)&v14[64], v81);
          uint64_t v69 = v15;
          id v70 = v16;
          if (v16) {
            id v17 = (void *)*((void *)v16 + 16);
          }
          else {
            id v17 = 0LL;
          }
          id v18 = v17;
          id v19 = (void *)objc_claimAutoreleasedReturnValue([v18 allowedLinkSubtypes]);
          unsigned int v20 = [v19 containsObject:&off_1001BC940];

          if (v20)
          {
            BOOL v21 = sub_100107E48(v70) == 1;
            char v22 = sub_1001319A0((BOOL)v70);
            id v23 = *(id *)(v76 + v3[98]);
            id v24 = v23;
            if (v23) {
              id v25 = (void *)*((void *)v23 + 9);
            }
            else {
              id v25 = 0LL;
            }
            id v26 = v25;
            id v27 = (void *)objc_claimAutoreleasedReturnValue([v26 objectForKeyedSubscript:v81]);

            id v74 = v27;
            if ([v27 count])
            {
              char v28 = v21 & ~v22;
              if ((v28 & 1) != 0)
              {
                char v29 = 0;
                uint64_t v30 = (void *)v76;
              }

              else
              {
                __int128 v92 = 0u;
                __int128 v93 = 0u;
                __int128 v90 = 0u;
                __int128 v91 = 0u;
                uint64_t v30 = (void *)v76;
                id v31 = *(id *)(v76 + 152);
                id v32 = [v31 countByEnumeratingWithState:&v90 objects:v100 count:16];
                if (v32)
                {
                  id v33 = v32;
                  uint64_t v34 = *(void *)v91;
                  while (2)
                  {
                    for (uint64_t i = 0LL; i != v33; uint64_t i = (char *)i + 1)
                    {
                      if (*(void *)v91 != v34) {
                        objc_enumerationMutation(v31);
                      }
                      id v36 = *(void **)(*((void *)&v90 + 1) + 8LL * (void)i);
                      if ([v36 subtype] == 104)
                      {
                        id v37 = (void *)objc_claimAutoreleasedReturnValue([v36 nrUUID]);
                        unsigned int v38 = [v37 isEqual:v81];

                        if (v38)
                        {
                          if ([v36 state] != 255)
                          {
                            char v29 = 1;
                            goto LABEL_42;
                          }
                        }
                      }
                    }

                    id v33 = [v31 countByEnumeratingWithState:&v90 objects:v100 count:16];
                    if (v33) {
                      continue;
                    }
                    break;
                  }

                  char v29 = 0;
LABEL_42:
                  uint64_t v30 = (void *)v76;
                  id v3 = &OBJC_IVAR___NRAnalyticsALUAdviceStats__timeSinceLastAdvice;
                }

                else
                {
                  char v29 = 0;
                }
              }

              id v39 = &APSConnectionOverrideNamedDelegatePort_ptr;
              __int128 v88 = 0u;
              __int128 v89 = 0u;
              __int128 v86 = 0u;
              __int128 v87 = 0u;
              int v71 = v65;
              id v73 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v71,  "countByEnumeratingWithState:objects:count:",  &v86,  v99,  16LL);
              if (v73)
              {
                uint64_t v72 = *(void *)v87;
                char v77 = v28;
LABEL_47:
                uint64_t v40 = 0LL;
                while (1)
                {
                  if (*(void *)v87 != v72) {
                    objc_enumerationMutation(v71);
                  }
                  if (!(v28 & 1 | ((v29 & 1) == 0))) {
                    break;
                  }
                  uint64_t v75 = v40;
                  __int128 v41 = (void *)objc_claimAutoreleasedReturnValue( [v39[157] endpointWithHostname:*(void *)(*((void *)&v86 + 1) + 8 * v40) port:@"0"]);
                  __int128 v82 = 0u;
                  __int128 v83 = 0u;
                  __int128 v84 = 0u;
                  __int128 v85 = 0u;
                  id v80 = v74;
                  id v42 = [v80 countByEnumeratingWithState:&v82 objects:v98 count:16];
                  if (v42)
                  {
                    id v43 = v42;
                    uint64_t v44 = *(void *)v83;
                    uint64_t v78 = *(void *)v83;
LABEL_54:
                    uint64_t v45 = 0LL;
                    id v79 = v43;
                    while (1)
                    {
                      if (*(void *)v83 != v44) {
                        objc_enumerationMutation(v80);
                      }
                      if (!(v28 & 1 | ((v29 & 1) == 0))) {
                        break;
                      }
                      __int128 v47 = *(void **)(*((void *)&v82 + 1) + 8 * v45);
                      if ([v30 endpointsAreCompatible:v41 remoteEndpoint:v47])
                      {
                        id v48 = v39[157];
                        int v49 = (void *)objc_claimAutoreleasedReturnValue([v47 hostname]);
                        objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
                        if (qword_1001DC640 != -1) {
                          dispatch_once(&qword_1001DC640, &stru_1001ADE98);
                        }
                        id v50 = (id)qword_1001DC638;
                        id v51 = @"62743";
                        if (!v50) {
                          id v51 = 0LL;
                        }
                        uint64_t v52 = v51;
                        uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v48 endpointWithHostname:v49 port:v52]);

                        uint64_t v54 = objc_opt_class(&OBJC_CLASS___NRLinkInfraRelay);
                        id v55 = sub_10013B868((uint64_t)v30, v81, v41, v53, v54);
                        if (v55)
                        {
                          id v46 = v55;
                        }

                        else
                        {
                          uint64_t v56 = objc_alloc(&OBJC_CLASS___NRLinkInfraRelay);
                          if (v30) {
                            uint64_t v57 = (void *)v30[3];
                          }
                          else {
                            uint64_t v57 = 0LL;
                          }
                          id v58 = v57;
                          uint64_t v59 = *(void **)((char *)v30 + v3[98]);
                          if (v59) {
                            uint64_t v59 = (void *)v59[3];
                          }
                          uint64_t v60 = v59;
                          objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
                          if (qword_1001DC640 != -1) {
                            dispatch_once(&qword_1001DC640, &stru_1001ADE98);
                          }
                          id v61 = (id)qword_1001DC638;
                          id v62 = @"62743";
                          if (!v61) {
                            id v62 = 0LL;
                          }
                          id v63 = v62;
                          id v46 = -[NRLinkInfraRelay initLinkWithQueue:linkDelegate:nrUUID:wifiInterfaceName:localOuterEndpoint:remoteOuterEndpoint:listenerPortString:]( v56,  "initLinkWithQueue:linkDelegate:nrUUID:wifiInterfaceName:localOuterEndpoint:remoteOuter Endpoint:listenerPortString:",  v58,  v76,  v81,  v60,  v41,  v53,  v63);

                          if (v46) {
                            char v29 = 1;
                          }
                          else {
                            [(id)v76 reportEvent:3200];
                          }
                          uint64_t v30 = (void *)v76;
                          id v3 = &OBJC_IVAR___NRAnalyticsALUAdviceStats__timeSinceLastAdvice;
                          id v39 = &APSConnectionOverrideNamedDelegatePort_ptr;
                        }

                        char v28 = v77;

                        uint64_t v44 = v78;
                        id v43 = v79;
                      }

                      if (v43 == (id)++v45)
                      {
                        id v43 = [v80 countByEnumeratingWithState:&v82 objects:v98 count:16];
                        if (v43) {
                          goto LABEL_54;
                        }
                        break;
                      }
                    }
                  }

                  uint64_t v40 = v75 + 1;
                  if ((id)(v75 + 1) == v73)
                  {
                    id v73 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v71,  "countByEnumeratingWithState:objects:count:",  &v86,  v99,  16LL);
                    if (v73) {
                      goto LABEL_47;
                    }
                    break;
                  }
                }
              }
            }

            id v14 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
          }

          uint64_t v15 = v69 + 1;
        }

        while ((id)(v69 + 1) != v68);
        id v68 = [obj countByEnumeratingWithState:&v94 objects:v101 count:16];
      }

      while (v68);
    }
  }
}

id sub_10013B868(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5)
{
  id v41 = a2;
  id v9 = a3;
  id v10 = a4;
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  id v11 = *(id *)(a1 + 152);
  id v12 = [v11 countByEnumeratingWithState:&v42 objects:v46 count:16];
  id v39 = v10;
  uint64_t v40 = v9;
  if (v12)
  {
    id v13 = v12;
    uint64_t v14 = *(void *)v43;
    if (v9)
    {
LABEL_6:
      uint64_t v15 = 0LL;
      while (1)
      {
        if (*(void *)v43 != v14) {
          objc_enumerationMutation(v11);
        }
        uint64_t v16 = *(void **)(*((void *)&v42 + 1) + 8 * v15);
        if ((objc_opt_isKindOfClass(v16, a5) & 1) != 0)
        {
          id v17 = (void *)objc_claimAutoreleasedReturnValue([v16 nrUUID]);
          unsigned int v18 = [v17 isEqual:v41];

          if (v18)
          {
            id v19 = (void *)objc_claimAutoreleasedReturnValue([v16 localOuterEndpoint]);
            unsigned int v20 = (void *)objc_claimAutoreleasedReturnValue([v19 hostname]);
            BOOL v21 = (void *)objc_claimAutoreleasedReturnValue([v40 hostname]);
            unsigned int v22 = [v20 isEqualToString:v21];

            if (v22)
            {
              if (!v39) {
                break;
              }
              id v23 = (void *)objc_claimAutoreleasedReturnValue([v16 remoteOuterEndpoint]);
              id v24 = (void *)objc_claimAutoreleasedReturnValue([v23 hostname]);
              id v25 = (void *)objc_claimAutoreleasedReturnValue([v39 hostname]);
              unsigned int v26 = [v24 isEqualToString:v25];

              if (v26) {
                break;
              }
            }
          }
        }

        if (v13 == (id)++v15)
        {
          id v13 = [v11 countByEnumeratingWithState:&v42 objects:v46 count:16];
          if (!v13) {
            goto LABEL_25;
          }
          goto LABEL_6;
        }
      }
    }

    else if (v10)
    {
LABEL_17:
      uint64_t v28 = 0LL;
      while (1)
      {
        if (*(void *)v43 != v14) {
          objc_enumerationMutation(v11);
        }
        uint64_t v16 = *(void **)(*((void *)&v42 + 1) + 8 * v28);
        if ((objc_opt_isKindOfClass(v16, a5) & 1) != 0)
        {
          char v29 = (void *)objc_claimAutoreleasedReturnValue([v16 nrUUID]);
          unsigned int v30 = [v29 isEqual:v41];

          if (v30)
          {
            id v31 = (void *)objc_claimAutoreleasedReturnValue([v16 remoteOuterEndpoint]);
            id v32 = (void *)objc_claimAutoreleasedReturnValue([v31 hostname]);
            id v33 = (void *)objc_claimAutoreleasedReturnValue([v39 hostname]);
            unsigned __int8 v34 = [v32 isEqualToString:v33];

            if ((v34 & 1) != 0) {
              break;
            }
          }
        }

        if (v13 == (id)++v28)
        {
          id v13 = [v11 countByEnumeratingWithState:&v42 objects:v46 count:16];
          id v27 = 0LL;
          if (!v13) {
            goto LABEL_34;
          }
          goto LABEL_17;
        }
      }
    }

    else
    {
LABEL_27:
      uint64_t v35 = 0LL;
      while (1)
      {
        if (*(void *)v43 != v14) {
          objc_enumerationMutation(v11);
        }
        uint64_t v16 = *(void **)(*((void *)&v42 + 1) + 8 * v35);
        if ((objc_opt_isKindOfClass(v16, a5) & 1) != 0)
        {
          id v36 = (void *)objc_claimAutoreleasedReturnValue([v16 nrUUID]);
          unsigned __int8 v37 = [v36 isEqual:v41];

          if ((v37 & 1) != 0) {
            break;
          }
        }

        if (v13 == (id)++v35)
        {
          id v13 = [v11 countByEnumeratingWithState:&v42 objects:v46 count:16];
          id v27 = 0LL;
          if (!v13) {
            goto LABEL_34;
          }
          goto LABEL_27;
        }
      }
    }

    id v27 = v16;
  }

  else
  {
LABEL_25:
    id v27 = 0LL;
  }

void sub_10013BC04(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (dispatch_queue_s *)*(id *)(a1 + 24);
    dispatch_assert_queue_V2(v2);

    uint64_t v3 = *(void *)(a1 + 216);
    if (v3)
    {
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 32));
      sub_100068E04(v3);
      uint64_t v4 = *(void **)(a1 + 216);
      *(void *)(a1 + 216) = 0LL;

      if (*(_DWORD *)(a1 + 44) != -1)
      {
        sub_10013C8C0(a1, 0);
        notify_cancel(*(_DWORD *)(a1 + 44));
        *(_DWORD *)(a1 + 44) = -1;
      }
    }
  }

void sub_10013BCA8(uint64_t a1, void *a2)
{
  id v67 = a2;
  if (sub_10001E054(*(void *)(a1 + 104)) && *(void *)(a1 + 56))
  {
    __int128 v97 = 0u;
    __int128 v98 = 0u;
    __int128 v95 = 0u;
    __int128 v96 = 0u;
    id obj = v67;
    id v3 = [obj countByEnumeratingWithState:&v95 objects:v102 count:16];
    if (v3)
    {
      id v4 = v3;
      id v5 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
      p_class_meths = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
      uint64_t v7 = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
      uint64_t v8 = *(void *)v96;
      id v79 = (void *)a1;
      uint64_t v68 = *(void *)v96;
      do
      {
        uint64_t v9 = 0LL;
        id v69 = v4;
        do
        {
          if (*(void *)v96 != v8)
          {
            uint64_t v10 = v9;
            objc_enumerationMutation(obj);
            uint64_t v9 = v10;
          }

          uint64_t v71 = v9;
          id v11 = *(void **)(*((void *)&v95 + 1) + 8 * v9);
          id v12 = sub_100129B30((uint64_t)&v5[64], v11);
          id v13 = (id *)v12;
          if (v12)
          {
            if (v12[9])
            {
              id v14 = *((id *)v12 + 16);
              __int128 v82 = v11;
              if (v14)
              {
                uint64_t v15 = v14;
                id v16 = v13[16];
                uint64_t v17 = objc_claimAutoreleasedReturnValue([v16 allowedLinkSubtypes]);
                if (v17)
                {
                  unsigned int v18 = (void *)v17;
                  id v19 = v13[16];
                  unsigned int v20 = (void *)objc_claimAutoreleasedReturnValue([v19 allowedLinkTypes]);
                  if (![v20 containsObject:&off_1001BC910])
                  {

                    id v5 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
                    p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
                    uint64_t v8 = v68;
                    id v4 = v69;
                    uint64_t v7 = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
LABEL_96:
                    if (p_class_meths[383] != (__objc2_meth_list *)-1LL) {
                      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                    }
                    if (_NRLogIsLevelEnabled(v7[382], 0LL))
                    {
                      if (p_class_meths[383] != (__objc2_meth_list *)-1LL) {
                        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                      }
                      _NRLogWithArgs( v7[382],  0LL,  "%s%.30s:%-4d Deferring creating link for %@ as Infra is unsupported",  "",  "-[NRLinkManagerWiFi createLinkForNRUUIDs:]",  830LL,  v13);
                    }

                    goto LABEL_8;
                  }

                  id v21 = v13[16];
                  unsigned int v22 = (void *)objc_claimAutoreleasedReturnValue([v21 allowedLinkSubtypes]);
                  unsigned __int8 v80 = [v22 containsObject:&off_1001BC928];

                  id v5 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
                  p_class_meths = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
                  uint64_t v8 = v68;
                  id v4 = v69;
                  uint64_t v7 = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
                  id v11 = v82;
                  if ((v80 & 1) == 0) {
                    goto LABEL_96;
                  }
                }

                else
                {
                }
              }

              int v74 = sub_100107E48(v13);
              int v23 = sub_1001319A0((BOOL)v13);
              id v24 = *(id *)(a1 + 104);
              id v25 = v24;
              if (v24) {
                unsigned int v26 = (void *)*((void *)v24 + 9);
              }
              else {
                unsigned int v26 = 0LL;
              }
              id v27 = v26;
              char v77 = (void *)objc_claimAutoreleasedReturnValue([v27 objectForKeyedSubscript:v11]);

              uint64_t v28 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
              char v29 = *(void **)(a1 + 104);
              if (v29) {
                char v29 = (void *)v29[7];
              }
              unsigned int v30 = v29;
              id v31 = [v30 count];

              if (v31)
              {
                id v32 = *(void **)(a1 + 104);
                if (v32) {
                  id v32 = (void *)v32[7];
                }
                id v33 = v32;
                -[NSMutableArray addObjectsFromArray:](v28, "addObjectsFromArray:", v33);
              }

              unsigned __int8 v34 = *(void **)(a1 + 104);
              if (v34) {
                unsigned __int8 v34 = (void *)v34[8];
              }
              uint64_t v35 = v34;
              id v36 = [v35 count];

              if (v36)
              {
                unsigned __int8 v37 = *(void **)(a1 + 104);
                if (v37) {
                  unsigned __int8 v37 = (void *)v37[8];
                }
                unsigned int v38 = v37;
                -[NSMutableArray addObjectsFromArray:](v28, "addObjectsFromArray:", v38);
              }

              char v39 = (v74 == 1) & ~(_BYTE)v23;
              char v81 = v39;
              if (((v74 == 1) & ~v23) != 0)
              {
                LOBYTE(v40) = 0;
              }

              else
              {
                __int128 v93 = 0u;
                __int128 v94 = 0u;
                __int128 v91 = 0u;
                __int128 v92 = 0u;
                id v41 = *(id *)(a1 + 152);
                id v40 = [v41 countByEnumeratingWithState:&v91 objects:v101 count:16];
                if (v40)
                {
                  uint64_t v42 = *(void *)v92;
LABEL_50:
                  uint64_t v43 = 0LL;
                  while (1)
                  {
                    if (*(void *)v92 != v42) {
                      objc_enumerationMutation(v41);
                    }
                    __int128 v44 = *(void **)(*((void *)&v91 + 1) + 8 * v43);
                    if ([v44 subtype] == 101)
                    {
                      __int128 v45 = (void *)objc_claimAutoreleasedReturnValue([v44 nrUUID]);
                      unsigned int v46 = [v45 isEqual:v82];

                      id v11 = v82;
                      if (v46)
                      {
                      }
                    }

                    if (v40 == (id)++v43)
                    {
                      id v40 = [v41 countByEnumeratingWithState:&v91 objects:v101 count:16];
                      if (!v40) {
                        goto LABEL_58;
                      }
                      goto LABEL_50;
                    }
                  }

                  LOBYTE(v40) = 1;
LABEL_58:
                  a1 = (uint64_t)v79;
                  char v39 = v81;
                }
              }

              __int128 v89 = 0u;
              __int128 v90 = 0u;
              __int128 v87 = 0u;
              __int128 v88 = 0u;
              uint64_t v72 = v28;
              id v76 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v72,  "countByEnumeratingWithState:objects:count:",  &v87,  v100,  16LL);
              if (v76)
              {
                uint64_t v75 = *(void *)v88;
                BOOL v73 = (BOOL)v13;
LABEL_62:
                id v47 = 0LL;
                while (1)
                {
                  if (*(void *)v88 != v75) {
                    objc_enumerationMutation(v72);
                  }
                  uint64_t v78 = (char *)v47;
                  int v49 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  *(void *)(*((void *)&v87 + 1) + 8LL * (void)v47),  @"0"));
                  __int128 v83 = 0u;
                  __int128 v84 = 0u;
                  __int128 v85 = 0u;
                  __int128 v86 = 0u;
                  id v50 = v77;
                  id v51 = [v50 countByEnumeratingWithState:&v83 objects:v99 count:16];
                  if (v51)
                  {
                    id v52 = v51;
                    uint64_t v53 = *(void *)v84;
LABEL_70:
                    uint64_t v54 = 0LL;
                    while (1)
                    {
                      if (*(void *)v84 != v53) {
                        objc_enumerationMutation(v50);
                      }
                      id v55 = *(void **)(*((void *)&v83 + 1) + 8 * v54);
                      if ([(id)a1 endpointsAreCompatible:v49 remoteEndpoint:v55])
                      {
                        uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue([v55 hostname]);
                        objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
                        if (qword_1001DC640 != -1) {
                          dispatch_once(&qword_1001DC640, &stru_1001ADE98);
                        }
                        id v57 = (id)qword_1001DC638;
                        id v58 = @"62743";
                        if (!v57) {
                          id v58 = 0LL;
                        }
                        uint64_t v59 = v58;
                        uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v56,  v59));

                        uint64_t v61 = objc_opt_class(&OBJC_CLASS___NRLinkWiFi);
                        a1 = (uint64_t)v79;
                        id v11 = v82;
                        id v62 = sub_10013B868((uint64_t)v79, v82, v49, v60, v61);
                        if (!v62)
                        {
                          id v63 = sub_10013C5E0((uint64_t)v79, v82, v49, v60);
                          id v62 = (id)objc_claimAutoreleasedReturnValue(v63);
                          if (v62)
                          {
                            LOBYTE(v40) = 1;
                          }

                          else
                          {
                            [v79 reportEvent:3200];
                            id v62 = 0LL;
                          }
                        }

                        char v39 = v81;
                      }

                      if (v52 == (id)++v54)
                      {
                        id v52 = [v50 countByEnumeratingWithState:&v83 objects:v99 count:16];
                        if (v52) {
                          goto LABEL_70;
                        }
                        break;
                      }
                    }
                  }

                  id v13 = (id *)v73;
                  BOOL v64 = sub_1001319A0(v73);
                  if (v74 == 1 && v64 && ![v50 count])
                  {
                    id v65 = sub_10013C5E0(a1, v11, v49, 0LL);
                    uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue(v65);
                    id v48 = v78;
                    if (v66) {
                      LOBYTE(v40) = 1;
                    }
                    else {
                      [(id)a1 reportEvent:3200];
                    }

                    char v39 = v81;
                  }

                  else
                  {
                    id v48 = v78;
                  }

                  id v47 = v48 + 1;
                  if (v47 == v76)
                  {
                    id v76 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v72,  "countByEnumeratingWithState:objects:count:",  &v87,  v100,  16LL);
                    if (v76) {
                      goto LABEL_62;
                    }
                    break;
                  }
                }
              }

              id v5 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
              p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
              uint64_t v8 = v68;
              id v4 = v69;
              uint64_t v7 = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
            }

            else
            {
              if (p_class_meths[383] != (__objc2_meth_list *)-1LL) {
                dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
              }
              if (_NRLogIsLevelEnabled(v7[382], 0LL))
              {
                if (p_class_meths[383] != (__objc2_meth_list *)-1LL) {
                  dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                }
                _NRLogWithArgs( v7[382],  0LL,  "%s%.30s:%-4d Deferring creating link for disabled local device for %@",  "",  "-[NRLinkManagerWiFi createLinkForNRUUIDs:]",  815LL,  v11);
              }
            }
          }

          else
          {
            if (p_class_meths[383] != (__objc2_meth_list *)-1LL) {
              dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
            }
            if (_NRLogIsLevelEnabled(v7[382], 0LL))
            {
              if (p_class_meths[383] != (__objc2_meth_list *)-1LL) {
                dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
              }
              _NRLogWithArgs( v7[382],  0LL,  "%s%.30s:%-4d Deferring creating link for invalid local device for %@",  "",  "-[NRLinkManagerWiFi createLinkForNRUUIDs:]",  810LL,  v11);
            }
          }

id sub_10013C5E0(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (a1) {
    uint64_t v10 = *(void **)(a1 + 24);
  }
  else {
    uint64_t v10 = 0LL;
  }
  id v11 = v10;
  dispatch_assert_queue_V2(v11);

  if (!v7)
  {
    id v28 = sub_10013A600();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v28, 17LL);

    if (IsLevelEnabled)
    {
      id StringFromNRLinkType = sub_10013A600();
      _NRLogWithArgs(StringFromNRLinkType, 17LL, "%s called with null nrUUID");
      goto LABEL_25;
    }

id sub_10013C8C0(uint64_t a1, char a2)
{
  id result = (id)objc_opt_self(&OBJC_CLASS___NRLinkManagerWiFi);
  if ((a2 & 1) != 0 || !*(_BYTE *)(a1 + 35))
  {
    notify_set_state(*(_DWORD *)(a1 + 44), 1uLL);
    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCBF0, 0LL))
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      _NRLogWithArgs( qword_1001DCBF0,  0LL,  "%s%.30s:%-4d Setting notify token (%d) state AvoidCompanionSupported: %d",  "",  "-[NRLinkManagerWiFi updateAvoidCompanionStateWithForce:]",  704,  *(_DWORD *)(a1 + 44),  1);
    }

    id result = objc_msgSend( (id)a1,  "reportEvent:detailsFormat:",  1031,  @"token: %d, supported: %d",  *(unsigned int *)(a1 + 44),  1);
    *(_BYTE *)(a1 + 35) = 1;
  }

  return result;
}

void sub_10013C9F8(uint64_t a1)
{
  if ([*(id *)(a1 + 32) state] == 9)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2) {
      id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    }
    else {
      id WeakRetained = 0LL;
    }
    id v4 = WeakRetained;
    [WeakRetained linkIsSuspended:*(void *)(a1 + 32)];
  }

  else
  {
    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCBF0, 16LL))
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      _NRLogWithArgs( qword_1001DCBF0,  16LL,  "%s%.30s:%-4d %@: link %@ is not in suspended state anymore",  "",  "-[NRLinkManagerWiFi linkIsSuspended:]_block_invoke",  478LL,  *(void *)(a1 + 40),  *(void *)(a1 + 32));
    }
  }

void sub_10013CB08(uint64_t a1)
{
  if ([*(id *)(a1 + 32) state] == 8)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2) {
      id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    }
    else {
      id WeakRetained = 0LL;
    }
    id v4 = WeakRetained;
    [WeakRetained linkIsReady:*(void *)(a1 + 32)];
  }

  else
  {
    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCBF0, 16LL))
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      _NRLogWithArgs( qword_1001DCBF0,  16LL,  "%s%.30s:%-4d %@: link %@ is not in ready state anymore",  "",  "-[NRLinkManagerWiFi linkIsReady:]_block_invoke",  456LL,  *(void *)(a1 + 40),  *(void *)(a1 + 32));
    }
  }

void sub_10013CC18(uint64_t a1)
{
  if ([*(id *)(a1 + 32) state] == 1)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2) {
      id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    }
    else {
      id WeakRetained = 0LL;
    }
    id v4 = WeakRetained;
    [WeakRetained linkIsAvailable:*(void *)(a1 + 32)];
  }

  else
  {
    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCBF0, 16LL))
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      _NRLogWithArgs( qword_1001DCBF0,  16LL,  "%s%.30s:%-4d %@: link %@ is not in initial state anymore",  "",  "-[NRLinkManagerWiFi linkIsAvailable:]_block_invoke",  427LL,  *(void *)(a1 + 40),  *(void *)(a1 + 32));
    }
  }

id sub_10013CD28(uint64_t a1)
{
  return [*(id *)(a1 + 32) invalidate];
}

uint64_t sub_10013CD30(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = (dispatch_queue_s *)*(id *)(result + 24);
    dispatch_assert_queue_V2(v2);

    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    id result = _NRLogIsLevelEnabled(qword_1001DCBF0, 1LL);
    if ((_DWORD)result)
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      id result = _NRLogWithArgs( qword_1001DCBF0,  1LL,  "%s%.30s:%-4d Setting prefer Wi-Fi asserts: %d -> %d",  "",  "-[NRLinkManagerWiFi setPreferWiFiAsserts:]",  1884,  *(_DWORD *)(v1 + 40),  0);
    }

    *(_DWORD *)(v1 + 40) = 0;
  }

  return result;
}

void sub_10013CE1C(id a1)
{
  uint64_t v1 = (dispatch_queue_attr_s *)_NRCopySerialQueueAttr(a1);
  dispatch_queue_attr_t v2 = dispatch_queue_attr_make_with_qos_class(v1, QOS_CLASS_USER_INITIATED, 0);
  id v3 = (dispatch_queue_attr_s *)objc_claimAutoreleasedReturnValue(v2);

  if (!v3)
  {
    id v8 = sub_10013A600();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 16LL);

    if (IsLevelEnabled)
    {
      id v10 = sub_10013A600();
      _NRLogWithArgs( v10,  16LL,  "%s%.30s:%-4d ABORTING: dispatch_queue_attr_make_with_qos_class(%u) failed",  "",  "nr_dispatch_queue_create_with_qos",  130,  25);
    }

    id v4 = (const char *)_os_log_pack_size(18LL);
    id v11 = (char *)&v23 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v12 = __error();
    uint64_t v13 = _os_log_pack_fill( v11,  v4,  *v12,  &_mh_execute_header,  "%{public}s dispatch_queue_attr_make_with_qos_class(%u) failed");
    *(_DWORD *)uint64_t v13 = 136446466;
    *(void *)(v13 + 4) = "nr_dispatch_queue_create_with_qos";
    *(_WORD *)(v13 + 12) = 1024;
    *(_DWORD *)(v13 + 14) = 25;
    id v14 = sub_10013A600();
    _NRLogAbortWithPack(v14, v11);
LABEL_7:
    id v15 = sub_10013A600();
    int v16 = _NRLogIsLevelEnabled(v15, 16LL);

    if (v16)
    {
      id v17 = sub_10013A600();
      _NRLogWithArgs( v17,  16LL,  "%s%.30s:%-4d ABORTING: dispatch_queue_create(%s) failed",  "",  "nr_dispatch_queue_create_with_qos",  134,  v4);
    }

    uint64_t v18 = _os_log_pack_size(22LL);
    id v19 = (char *)&v23 - ((__chkstk_darwin(v18) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    unsigned int v20 = __error();
    uint64_t v21 = _os_log_pack_fill( v19,  v18,  *v20,  &_mh_execute_header,  "%{public}s dispatch_queue_create(%s) failed");
    *(_DWORD *)uint64_t v21 = 136446466;
    *(void *)(v21 + 4) = "nr_dispatch_queue_create_with_qos";
    *(_WORD *)(v21 + 12) = 2080;
    *(void *)(v21 + 14) = v4;
    id v22 = sub_10013A600();
    _NRLogAbortWithPack(v22, v19);
  }

  id v4 = "terminusd.CoreWiFi";
  dispatch_queue_t v5 = dispatch_queue_create("terminusd.CoreWiFi", v3);
  if (!v5) {
    goto LABEL_7;
  }
  uint64_t v6 = (uint64_t)v5;

  id v7 = (void *)qword_1001DCC08;
  qword_1001DCC08 = v6;
}

id sub_10013D088(uint64_t a1)
{
  return [*(id *)(a1 + 32) activate];
}

BOOL sub_10013D090(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(a1);
  id v4 = dispatch_group_create();
  if (qword_1001DCC00 != -1) {
    dispatch_once(&qword_1001DCC00, &stru_1001B08F0);
  }
  dispatch_group_async(v4, (dispatch_queue_t)qword_1001DCC08, v3);

  dispatch_time_t v5 = dispatch_time(0x8000000000000000LL, 3000000000LL);
  uint64_t v9 = dispatch_group_wait(v4, v5);
  if (v9) {
    sub_1001030D0( @"NRLinkManagerWiFi",  @"SemaphoreTimeout",  @"PerformBlockSync",  0,  0LL,  v6,  v7,  v8,  v11);
  }

  return v9 != 0;
}

uint64_t sub_10013D160(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10013D170(uint64_t a1)
{
}

void sub_10013D178(uint64_t a1)
{
  uint64_t v2 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) interfaceName]);
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_10013D1B0(uint64_t a1, void *a2, void *a3)
{
  if (a3)
  {
    id v4 = a3;
    if (v4[3] != 1004)
    {
      dispatch_time_t v5 = v4;
      sub_10013D678((uint64_t)v4, a2);
      id v4 = v5;
    }
  }

void sub_10013D1FC(uint64_t a1, uint64_t a2)
{
  if (a2 && *(_DWORD *)(a2 + 12) != 1004)
  {
    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCBF0, 16LL))
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      _NRLogWithArgs(qword_1001DCBF0, 16LL, "%s%.30s:%-4d SCD server restarted", "", "scdDisconnectCallback", 2532);
    }
  }

void sub_10013D2BC(uint64_t a1)
{
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  uint64_t v2 = (id)qword_1001DC870;
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    if (v2) {
      BOOL v4 = v2[8] != 0;
    }
    else {
      BOOL v4 = 0;
    }
    *(_BYTE *)(v3 + 39) = v4;
  }

  sub_10013D34C(*(void *)(a1 + 32));
}

void sub_10013D34C(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = sub_10013D5E8((void *)a1);
    uint64_t v3 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    __int128 v27 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    BOOL v4 = v2;
    id v5 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v4,  "countByEnumeratingWithState:objects:count:",  &v27,  v31,  16LL);
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v28;
      do
      {
        for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v28 != v7) {
            objc_enumerationMutation(v4);
          }
          uint64_t v11 = *(void **)(*((void *)&v27 + 1) + 8LL * (void)i);
          if (v11) {
            id v12 = (void *)v11[6];
          }
          else {
            id v12 = 0LL;
          }
          id v13 = v12;

          if (v13)
          {
            if (v11) {
              id v14 = (void *)v11[6];
            }
            else {
              id v14 = 0LL;
            }
            id v15 = v14;
            -[NSMutableArray addObject:](v3, "addObject:", v15);
          }

          if (v11) {
            int v16 = (void *)v11[4];
          }
          else {
            int v16 = 0LL;
          }
          id v17 = v16;

          if (v17)
          {
            if (v11) {
              uint64_t v18 = (void *)v11[4];
            }
            else {
              uint64_t v18 = 0LL;
            }
            id v19 = v18;
            -[NSMutableArray addObject:](v3, "addObject:", v19);
          }

          if (v11) {
            unsigned int v20 = (void *)v11[5];
          }
          else {
            unsigned int v20 = 0LL;
          }
          id v21 = v20;

          if (v21)
          {
            if (v11) {
              uint64_t v9 = (void *)v11[5];
            }
            else {
              uint64_t v9 = 0LL;
            }
            id v10 = v9;
            -[NSMutableArray addObject:](v3, "addObject:", v10);
          }
        }

        id v6 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v4,  "countByEnumeratingWithState:objects:count:",  &v27,  v31,  16LL);
      }

      while (v6);
    }

    if (*(void *)(a1 + 136)) {
      -[NSMutableArray addObject:](v3, "addObject:");
    }
    if (SCDynamicStoreSetNotificationKeys(*(SCDynamicStoreRef *)(a1 + 96), (CFArrayRef)v3, 0LL))
    {
      id v22 = (id)a1;
      id v23 = v22;
      if (*((_DWORD *)v22 + 3) != 1004) {
        sub_10013D678((uint64_t)v22, v3);
      }
    }

    else
    {
      id v24 = sub_10013A600();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v24, 17LL);

      if (!IsLevelEnabled) {
        goto LABEL_39;
      }
      id v23 = sub_10013A600();
      CFErrorRef Error = SCCopyLastError();
      _NRLogWithArgs(v23, 17LL, "SCDynamicStoreSetNotificationKeys failed: %@", Error);
    }

LABEL_39:
  }

NSMutableArray *sub_10013D5E8(void *a1)
{
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v3 = v2;
  if (a1[13]) {
    -[NSMutableArray addObject:](v2, "addObject:");
  }
  if (a1[14]) {
    -[NSMutableArray addObject:](v3, "addObject:");
  }
  if (a1[15]) {
    -[NSMutableArray addObject:](v3, "addObject:");
  }
  if (a1[16]) {
    -[NSMutableArray addObject:](v3, "addObject:");
  }
  return v3;
}

void sub_10013D678(uint64_t a1, void *a2)
{
  keys = a2;
  if (a1) {
    uint64_t v3 = *(void **)(a1 + 24);
  }
  else {
    uint64_t v3 = 0LL;
  }
  BOOL v4 = v3;
  dispatch_assert_queue_V2(v4);

  CFDictionaryRef v5 = SCDynamicStoreCopyMultiple(*(SCDynamicStoreRef *)(a1 + 96), keys, 0LL);
  if (qword_1001DCBF8 != -1) {
    dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
  }
  id v6 = (id)qword_1001DCBF0;
  int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 1LL);

  if (IsLevelEnabled)
  {
    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    id v8 = (id)qword_1001DCBF0;
    _NRLogWithArgs(v8, 1LL, "%s%.30s:%-4d SCD update: %@", "", "-[NRLinkManagerWiFi processSCDUpdate:]", 2285LL, v5);
  }

  CFDictionaryRef v170 = v5;
  __int128 v202 = 0u;
  __int128 v203 = 0u;
  __int128 v204 = 0u;
  __int128 v205 = 0u;
  id obj = sub_10013D5E8((void *)a1);
  id v9 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v202,  v214,  16LL);
  if (v9)
  {
    uint64_t v10 = *(void *)v203;
    do
    {
      for (uint64_t i = 0LL; i != v9; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v203 != v10) {
          objc_enumerationMutation(obj);
        }
        id v12 = *(void **)(*((void *)&v202 + 1) + 8LL * (void)i);
        if (v12) {
          id v13 = (void *)v12[4];
        }
        else {
          id v13 = 0LL;
        }
        id v14 = v13;
        unsigned int v15 = -[__CFArray containsObject:](keys, "containsObject:", v14);

        if (v15)
        {
          if (v12) {
            int v16 = (void *)v12[7];
          }
          else {
            int v16 = 0LL;
          }
          id v17 = v16;
          [v17 removeAllObjects];
        }

        if (v12) {
          uint64_t v18 = (void *)v12[5];
        }
        else {
          uint64_t v18 = 0LL;
        }
        id v19 = v18;
        unsigned int v20 = -[__CFArray containsObject:](keys, "containsObject:", v19);

        if (v20)
        {
          if (v12) {
            id v21 = (void *)v12[8];
          }
          else {
            id v21 = 0LL;
          }
          id v22 = v21;
          [v22 removeAllObjects];
        }
      }

      id v9 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v202,  v214,  16LL);
    }

    while (v9);
  }

  id v166 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  if (v5 && -[__CFDictionary count](v5, "count"))
  {
    __int128 v200 = 0u;
    __int128 v201 = 0u;
    __int128 v198 = 0u;
    __int128 v199 = 0u;
    int32x4_t v168 = obj;
    id v172 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v168,  "countByEnumeratingWithState:objects:count:",  &v198,  v213,  16LL);
    if (v172)
    {
      char v169 = 0;
      uint64_t v23 = 0LL;
      uint64_t v167 = *(void *)v199;
      for (uint64_t j = *(void *)v199; ; uint64_t j = *(void *)v199)
      {
        if (j != v167)
        {
          uint64_t v25 = v23;
          objc_enumerationMutation(v168);
          uint64_t v23 = v25;
        }

        uint64_t v26 = *(id **)(*((void *)&v198 + 1) + 8 * v23);
        uint64_t v177 = v26;
        uint64_t v171 = v23;
        if (v26) {
          uint64_t v26 = (id *)v26[4];
        }
        __int128 v27 = v26;
        unsigned int v28 = -[__CFArray containsObject:](keys, "containsObject:", v27);

        if (v28)
        {
          if (v177)
          {
            id v29 = v177[7];
            [v29 removeAllObjects];

            id v30 = v177[4];
          }

          else
          {
            [0 removeAllObjects];
            id v30 = 0LL;
          }

          id v31 = v30;
          to = (id *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKeyedSubscript:](v170, "objectForKeyedSubscript:", v31));

          id v32 = (void *)objc_claimAutoreleasedReturnValue([to objectForKeyedSubscript:kSCPropNetIPv4Addresses]);
          __int128 v196 = 0u;
          __int128 v197 = 0u;
          __int128 v194 = 0u;
          __int128 v195 = 0u;
          id v33 = v32;
          id v34 = [v33 countByEnumeratingWithState:&v194 objects:v212 count:16];
          if (v34)
          {
            uint64_t v35 = 0LL;
            uint64_t v36 = *(void *)v195;
            for (uint64_t k = *(void *)v195; ; uint64_t k = *(void *)v195)
            {
              if (k != v36) {
                objc_enumerationMutation(v33);
              }
              unsigned int v38 = *(void **)(*((void *)&v194 + 1) + 8 * v35);
              if (inet_pton(2, (const char *)[v38 UTF8String], (char *)&location + 4) == 1)
              {
                unsigned int v39 = bswap32(HIDWORD(location));
                if ((v39 & 0xFF000000) == 0
                  || (v39 & 0xFF000000) == 2130706432
                  || v39 >> 28 == 14
                  || HIDWORD(location) == -1
                  || (v39 & 0xFFFFFFF8) == -1073741824)
                {
                  if (qword_1001DCBF8 != -1) {
                    dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                  }
                  id v44 = (id)qword_1001DCBF0;
                  int v45 = _NRLogIsLevelEnabled(v44, 1LL);

                  if (v45)
                  {
                    if (qword_1001DCBF8 != -1) {
                      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                    }
                    id v46 = (id)qword_1001DCBF0;
                    _NRLogWithArgs( v46,  1LL,  "%s%.30s:%-4d Ignoring ipv4 address: %@",  "",  "-[NRLinkManagerWiFi processSCDUpdate:]",  2323LL,  v38);
                    goto LABEL_71;
                  }
                }

                else
                {
                  if (HIWORD(v39) != 43518)
                  {
                    if (v177) {
LABEL_85:
                    }
                      id v49 = v177[7];
                    else {
                      id v49 = 0LL;
                    }
                    id v46 = v49;
                    [v46 addObject:v38];
LABEL_71:

                    goto LABEL_72;
                  }

                  if (v177 && *((_BYTE *)v177 + 8)) {
                    goto LABEL_85;
                  }
                  if (qword_1001DCBF8 != -1) {
                    dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                  }
                  id v47 = (id)qword_1001DCBF0;
                  int v48 = _NRLogIsLevelEnabled(v47, 1LL);

                  if (v48)
                  {
                    if (qword_1001DCBF8 != -1) {
                      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                    }
                    id v46 = (id)qword_1001DCBF0;
                    _NRLogWithArgs( v46,  1LL,  "%s%.30s:%-4d Ignoring ipv4 address: %@",  "",  "-[NRLinkManagerWiFi processSCDUpdate:]",  2329LL,  v38);
                    goto LABEL_71;
                  }
                }
              }

LABEL_124:
                id v76 = (id *)v177[8];
LABEL_125:
                id v69 = v76;
                [v69 addObject:v61];
              }

              else
              {
                if (qword_1001DCBF8 != -1) {
                  dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                }
                id v77 = (id)qword_1001DCBF0;
                int v78 = _NRLogIsLevelEnabled(v77, 1LL);

                if (!v78) {
                  goto LABEL_127;
                }
                if (qword_1001DCBF8 != -1) {
                  dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                }
                id v69 = (id *)(id)qword_1001DCBF0;
                _NRLogWithArgs( v69,  1LL,  "%s%.30s:%-4d Ignoring ipv6 address: %@",  "",  "-[NRLinkManagerWiFi processSCDUpdate:]",  2374LL,  v61);
              }
            }

            goto LABEL_127;
          }

LABEL_223:
            continue;
          }
        }

        else
        {
          id v125 = *(id *)(a1 + 128);
          BOOL v126 = v108 == v125;

          if (v126) {
            sub_10013FF8C(a1);
          }
        }
      }
    }

    id v105 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v178,  "countByEnumeratingWithState:objects:count:",  &v190,  v211,  16LL);
  }

  while (v105);
LABEL_251:

  ++*(void *)(a1 + 144);
  *(void *)&__int128 v206 = 0LL;
  *((void *)&v206 + 1) = &v206;
  *(void *)&__int128 v207 = 0x2020000000LL;
  BYTE8(v207) = 0;
  id v150 = *(id *)(a1 + 176);
  id location = _NSConcreteStackBlock;
  uint64_t v216 = 3221225472LL;
  uint64_t v217 = sub_100140378;
  id v218 = &unk_1001B07E8;
  id v151 = v150;
  id v219 = v151;
  id v220 = &v206;
  sub_10013D090((uint64_t)&OBJC_CLASS___NRLinkManagerWiFi, &location);
  int v152 = *(unsigned __int8 *)(*((void *)&v206 + 1) + 24LL);

  _Block_object_dispose(&v206, 8);
  if (v152)
  {
    id v153 = *(id *)(a1 + 104);
    if ((sub_10001E054((uint64_t)v153) & 1) != 0)
    {
      BOOL v154 = 1;
      goto LABEL_258;
    }

    if (sub_100140244(a1))
    {
      BOOL v154 = *(_BYTE *)(a1 + 32) != 0;
LABEL_258:
      BOOL tob = v154;
    }

    else
    {
      BOOL tob = 0;
    }
  }

  else
  {
    BOOL tob = sub_100140244(a1) && *(_BYTE *)(a1 + 32) != 0;
  }

  id v155 = *(id *)(a1 + 128);
  int v156 = sub_10001E054((uint64_t)v155);

  if (qword_1001DCBF8 != -1) {
    dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
  }
  id v157 = (id)qword_1001DCBF0;
  int v158 = _NRLogIsLevelEnabled(v157, 1LL);

  if (v158)
  {
    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    id v159 = (id)qword_1001DCBF0;
    _NRLogWithArgs( v159,  1LL,  "%s%.30s:%-4d phs %d llphs %d",  "",  "-[NRLinkManagerWiFi processSCDUpdate:]",  2492,  tob,  v156);
  }

  if (((tob ^ (*(_BYTE *)(a1 + 37) != 0)) & 1) != 0 || (v169 & 1) != 0 && v156 != (*(_BYTE *)(a1 + 38) != 0))
  {
    *(_BYTE *)(a1 + 37) = tob;
    *(_BYTE *)(a1 + 3_Block_object_dispose(va, 8) = v156;
    __int128 v184 = 0u;
    __int128 v185 = 0u;
    __int128 v186 = 0u;
    __int128 v187 = 0u;
    id v160 = *(id *)(a1 + 264);
    id v161 = [v160 countByEnumeratingWithState:&v184 objects:v210 count:16];
    if (v161)
    {
      uint64_t v162 = *(void *)v185;
      do
      {
        for (juint64_t j = 0LL; jj != v161; juint64_t j = (char *)jj + 1)
        {
          if (*(void *)v185 != v162) {
            objc_enumerationMutation(v160);
          }
          uint64_t v164 = *(void *)(*((void *)&v184 + 1) + 8LL * (void)jj);
          if ((objc_opt_respondsToSelector(v164, "didUpdatePHSState:llphsActive:") & 1) != 0)
          {
            id v165 = sub_100146AFC();
            v181[0] = _NSConcreteStackBlock;
            v181[1] = 3221225472LL;
            v181[2] = sub_100140330;
            v181[3] = &unk_1001B08B0;
            v181[4] = v164;
            BOOL v182 = tob;
            char v183 = v156;
            dispatch_async((dispatch_queue_t)v165, v181);
          }
        }

        id v161 = [v160 countByEnumeratingWithState:&v184 objects:v210 count:16];
      }

      while (v161);
    }
  }
}

void sub_10013EFDC(_Unwind_Exception *a1)
{
}

void sub_10013EFF8(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (dispatch_queue_s *)*(id *)(a1 + 24);
    dispatch_assert_queue_V2(v2);

    uint64_t v3 = *(void **)(a1 + 104);
    if (v3) {
      uint64_t v3 = (void *)v3[7];
    }
    BOOL v4 = v3;
    id v5 = [v4 count];

    if (v5)
    {
      id v6 = *(void **)(a1 + 104);
      if (v6) {
        id v6 = (void *)v6[7];
      }
    }

    else
    {
      uint64_t v7 = *(void **)(a1 + 104);
      if (v7) {
        uint64_t v7 = (void *)v7[8];
      }
      id v8 = v7;
      id v9 = [v8 count];

      if (!v9) {
        goto LABEL_15;
      }
      id v6 = *(void **)(a1 + 104);
      if (v6) {
        id v6 = (void *)v6[8];
      }
    }

    uint64_t v10 = v6;
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v10 firstObject]);
    id v12 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v11,  @"0"));

    if (v12)
    {
      if ([*(id *)(a1 + 56) isEqual:v12])
      {
        id v13 = v12;
      }

      else
      {
        if (qword_1001DCBF8 != -1) {
          dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCBF0, 1LL))
        {
          if (qword_1001DCBF8 != -1) {
            dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
          }
          _NRLogWithArgs( qword_1001DCBF0,  1LL,  "%s%.30s:%-4d Interface is available",  "",  "-[NRLinkManagerWiFi interfaceAvailable]",  947);
        }

        id v17 = [*(id *)(a1 + 152) copy];
        __int128 v31 = 0u;
        __int128 v32 = 0u;
        __int128 v33 = 0u;
        __int128 v34 = 0u;
        id v18 = v17;
        id v19 = [v18 countByEnumeratingWithState:&v31 objects:v35 count:16];
        if (v19)
        {
          id v20 = v19;
          uint64_t v21 = *(void *)v32;
          do
          {
            for (uint64_t i = 0LL; i != v20; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v32 != v21) {
                objc_enumerationMutation(v18);
              }
              uint64_t v23 = *(void **)(*((void *)&v31 + 1) + 8LL * (void)i);
              if ([v23 subtype] == 101)
              {
                id v24 = (void *)objc_claimAutoreleasedReturnValue([v23 localOuterEndpoint]);
                unsigned __int8 v25 = [v24 isEqual:v12];

                if ((v25 & 1) == 0)
                {
                  [v23 setNoTransport:1];
                  [v23 cancelWithReason:@"Local endpoint changed"];
                }
              }
            }

            id v20 = [v18 countByEnumeratingWithState:&v31 objects:v35 count:16];
          }

          while (v20);
        }

        id v13 = v12;
        uint64_t v26 = (dispatch_queue_s *)*(id *)(a1 + 24);
        dispatch_assert_queue_V2(v26);

        objc_storeStrong((id *)(a1 + 56), v12);
        uint64_t v27 = nwi_state_copy([(id)a1 reportEvent:11003, @"%@", *(void *)(a1 + 56) detailsFormat]);
        if (v27)
        {
          uint64_t v28 = v27;
          id v29 = [v13 addressFamily];
          uint64_t first_ifstate = nwi_state_get_first_ifstate(v28, v29);
          if ((sub_1001403C0((void *)a1, first_ifstate, (uint64_t)v29) & 1) == 0)
          {
            do
            {
              if (!first_ifstate) {
                break;
              }
              uint64_t first_ifstate = nwi_ifstate_get_next(first_ifstate, v29);
            }

            while (!sub_1001403C0((void *)a1, first_ifstate, (uint64_t)v29));
          }

          nwi_state_release(v28);
        }

        sub_10013A914(a1);
      }

void sub_10013F484(id *a1)
{
  if (a1)
  {
    uint64_t v2 = (dispatch_queue_s *)a1[3];
    dispatch_assert_queue_V2(v2);

    uint64_t v3 = a1[14];
    if (v3) {
      uint64_t v3 = (void *)v3[8];
    }
    BOOL v4 = v3;
    id v5 = [v4 count];

    if (!v5) {
      goto LABEL_37;
    }
    id v6 = a1[14];
    uint64_t v7 = v6;
    if (v6) {
      id v8 = (void *)*((void *)v6 + 8);
    }
    else {
      id v8 = 0LL;
    }
    id v9 = v8;
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v9 firstObject]);
    objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
    if (qword_1001DC640 != -1) {
      dispatch_once(&qword_1001DC640, &stru_1001ADE98);
    }
    id v11 = (id)qword_1001DC638;
    id v12 = @"62743";
    if (!v11) {
      id v12 = 0LL;
    }
    id v13 = v12;
    id v14 = (id)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v10,  v13));

    if (v14)
    {
      if (([a1[8] isEqual:v14] & 1) == 0)
      {
        if (qword_1001DCBF8 != -1) {
          dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCBF0, 1LL))
        {
          if (qword_1001DCBF8 != -1) {
            dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
          }
          _NRLogWithArgs( qword_1001DCBF0,  1LL,  "%s%.30s:%-4d AWDL interface is available",  "",  "-[NRLinkManagerWiFi awdlAvailable]",  1328);
        }

        uint64_t v32 = (uint64_t)a1;
        id v15 = [a1[19] copy];
        __int128 v33 = 0u;
        __int128 v34 = 0u;
        __int128 v35 = 0u;
        __int128 v36 = 0u;
        id v16 = v15;
        id v17 = [v16 countByEnumeratingWithState:&v33 objects:v37 count:16];
        if (v17)
        {
          id v18 = v17;
          uint64_t v19 = *(void *)v34;
          do
          {
            for (uint64_t i = 0LL; i != v18; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v34 != v19) {
                objc_enumerationMutation(v16);
              }
              uint64_t v21 = *(void **)(*((void *)&v33 + 1) + 8LL * (void)i);
              if ([v21 subtype] == 102)
              {
                uint64_t v22 = objc_opt_class(&OBJC_CLASS___NRLinkAWDL);
                if ((objc_opt_isKindOfClass(v21, v22) & 1) != 0)
                {
                  id v23 = v21;
                  id v24 = (void *)objc_claimAutoreleasedReturnValue([v23 localOuterEndpoint]);
                  unsigned __int8 v25 = [v24 isEqual:v14];

                  if ((v25 & 1) == 0)
                  {
                    [v23 setNoTransport:1];
                    [v23 cancelWithReason:@"Local endpoint changed"];
                  }
                }

                else
                {
                  if (qword_1001DCBF8 != -1) {
                    dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                  }
                  if (_NRLogIsLevelEnabled(qword_1001DCBF0, 17LL))
                  {
                    if (qword_1001DCBF8 != -1) {
                      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                    }
                    _NRLogWithArgs(qword_1001DCBF0, 17LL, "Invalid link %@", v21);
                  }
                }
              }
            }

            id v18 = [v16 countByEnumeratingWithState:&v33 objects:v37 count:16];
          }

          while (v18);
        }

        id v28 = v14;
        id v29 = (dispatch_queue_s *)*(id *)(v32 + 24);
        dispatch_assert_queue_V2(v29);

        id v30 = *(void **)(v32 + 64);
        *(void *)(v32 + 64) = v28;
        id v14 = v28;

        [(id)v32 reportEvent:11005, @"%@", *(void *)(v32 + 64) detailsFormat];
        id WeakRetained = objc_loadWeakRetained((id *)(v32 + 160));
        [WeakRetained localAWDLEndpointChanged:v14];

        sub_100139DFC(v32);
      }
    }

    else
    {
LABEL_37:
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCBF0, 17LL))
      {
        if (qword_1001DCBF8 != -1) {
          dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
        }
        _NRLogWithArgs(qword_1001DCBF0, 17LL, "Could not get Wi-Fi endpoint");
      }

      uint64_t v26 = (dispatch_queue_s *)a1[3];
      dispatch_assert_queue_V2(v26);

      id v27 = a1[8];
      a1[8] = 0LL;

      [a1 reportEvent:11005 details:@"<nil>"];
      id v14 = 0LL;
    }
  }

void sub_10013F988(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    uint64_t v2 = (dispatch_queue_s *)*(id *)(a1 + 24);
    dispatch_assert_queue_V2(v2);

    if (sub_10001E054(*(void *)(v1 + 128)))
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCBF0, 1LL))
      {
        if (qword_1001DCBF8 != -1) {
          dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
        }
        _NRLogWithArgs( qword_1001DCBF0,  1LL,  "%s%.30s:%-4d IR interface is available",  "",  "-[NRLinkManagerWiFi irAvailable]",  1134);
      }

      id v3 = [*(id *)(v1 + 152) copy];
      __int128 v30 = 0u;
      __int128 v31 = 0u;
      __int128 v32 = 0u;
      __int128 v33 = 0u;
      id v4 = v3;
      id v5 = [v4 countByEnumeratingWithState:&v30 objects:v34 count:16];
      if (v5)
      {
        id v6 = v5;
        uint64_t v7 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
        uint64_t v8 = *(void *)v31;
        uint64_t v29 = v1;
        do
        {
          for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v31 != v8) {
              objc_enumerationMutation(v4);
            }
            uint64_t v10 = *(void **)(*((void *)&v30 + 1) + 8LL * (void)i);
            if ([v10 subtype] == 104 && objc_msgSend(v10, "state") != 255)
            {
              uint64_t v11 = objc_opt_class(&v7[52]);
              if ((objc_opt_isKindOfClass(v10, v11) & 1) != 0)
              {
                id v12 = v10;
                id v13 = (void *)objc_claimAutoreleasedReturnValue([v12 localOuterEndpoint]);
                if ([v13 addressFamily] != (id)2)
                {

                  goto LABEL_33;
                }

                id v14 = *(id *)(v1 + 128);
                id v15 = v14;
                if (v14) {
                  id v16 = (void *)*((void *)v14 + 7);
                }
                else {
                  id v16 = 0LL;
                }
                id v17 = v16;
                id v18 = (void *)objc_claimAutoreleasedReturnValue([v12 localOuterEndpoint]);

                uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v18 hostname]);
                unsigned __int8 v20 = [v17 containsObject:v19];

                uint64_t v1 = v29;
                uint64_t v7 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
                if ((v20 & 1) == 0) {
                  goto LABEL_13;
                }
LABEL_33:
                uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v12 localOuterEndpoint]);
                if ([v21 addressFamily] == (id)30)
                {
                  id v22 = *(id *)(v1 + 128);
                  id v23 = v22;
                  if (v22) {
                    id v24 = (void *)*((void *)v22 + 8);
                  }
                  else {
                    id v24 = 0LL;
                  }
                  id v25 = v24;
                  uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v12 localOuterEndpoint]);

                  id v27 = (void *)objc_claimAutoreleasedReturnValue([v26 hostname]);
                  unsigned __int8 v28 = [v25 containsObject:v27];

                  uint64_t v1 = v29;
                  uint64_t v7 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
                  if ((v28 & 1) != 0) {
                    goto LABEL_14;
                  }
LABEL_13:
                  [v12 setNoTransport:1];
                  [v12 cancelWithReason:@"Local endpoint changed"];
                }

                else
                {
                }

void sub_10013FD90(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v3 = WeakRetained;
  if (WeakRetained && *((_DWORD *)WeakRetained + 3) != 1004)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4) {
      uint64_t v5 = *(unsigned int *)(v4 + 16);
    }
    else {
      uint64_t v5 = 0LL;
    }
    id v9 = v3;
    if (*(void *)(a1 + 56) == v5)
    {
      if (sub_10001E054(v4))
      {
        uint64_t v6 = *(void *)(a1 + 32);
        id v3 = v9;
        if (v6 == v9[13])
        {
          sub_10013EFF8(*(void *)(a1 + 40));
          goto LABEL_23;
        }

        if (v6 == v9[14])
        {
          sub_10013F484(*(id **)(a1 + 40));
          goto LABEL_23;
        }

        if (v6 == v9[16])
        {
          sub_10013F988(*(void *)(a1 + 40));
LABEL_23:
          id v3 = v9;
        }
      }

      else
      {
        if (qword_1001DCBF8 != -1) {
          dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
        }
        int IsLevelEnabled = _NRLogIsLevelEnabled(qword_1001DCBF0, 1LL);
        id v3 = v9;
        if (IsLevelEnabled)
        {
          if (qword_1001DCBF8 != -1) {
            dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
          }
          _NRLogWithArgs(qword_1001DCBF0, 1LL, "%s%.30s:%-4d WiFi went away while quiescing");
          goto LABEL_23;
        }
      }
    }

    else
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      int v7 = _NRLogIsLevelEnabled(qword_1001DCBF0, 1LL);
      id v3 = v9;
      if (v7)
      {
        if (qword_1001DCBF8 != -1) {
          dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
        }
        _NRLogWithArgs(qword_1001DCBF0, 1LL, "%s%.30s:%-4d Not processing stale availability update");
        goto LABEL_23;
      }
    }
  }
}

void sub_10013FF8C(uint64_t a1)
{
  if (a1) {
    uint64_t v2 = *(void **)(a1 + 24);
  }
  else {
    uint64_t v2 = 0LL;
  }
  id v3 = v2;
  dispatch_assert_queue_V2(v3);

  if ((sub_10001E054(*(void *)(a1 + 128)) & 1) == 0)
  {
    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCBF0, 1LL))
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      _NRLogWithArgs( qword_1001DCBF0,  1LL,  "%s%.30s:%-4d IR interface is NOT available",  "",  "-[NRLinkManagerWiFi irUnavailable]",  1285);
    }
  }

  id v4 = [*(id *)(a1 + 152) copy];
  __int128 v18 = 0u;
  __int128 v19 = 0u;
  __int128 v20 = 0u;
  __int128 v21 = 0u;
  id v5 = v4;
  id v6 = [v5 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v19;
    do
    {
      for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v19 != v8) {
          objc_enumerationMutation(v5);
        }
        uint64_t v10 = *(void **)(*((void *)&v18 + 1) + 8LL * (void)i);
        if ([v10 subtype] == 104 && objc_msgSend(v10, "state") != 255)
        {
          if ((sub_10001E054(*(void *)(a1 + 128)) & 1) == 0)
          {
            [v10 setNoTransport:1];
            [v10 cancelWithReason:@"Interface went away"];
          }

          id v11 = *(id *)(a1 + 128);
          id v12 = v11;
          if (v11) {
            id v13 = (void *)*((void *)v11 + 9);
          }
          else {
            id v13 = 0LL;
          }
          id v14 = v13;
          uint64_t v15 = objc_claimAutoreleasedReturnValue([v10 nrUUID]);

          id v16 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:v15]);
          id v17 = (void *)objc_claimAutoreleasedReturnValue([v10 remoteOuterEndpoint]);
          LOBYTE(v15) = [v16 containsObject:v17];

          if ((v15 & 1) == 0) {
            [v10 cancelWithReason:@"peer went away"];
          }
        }
      }

      id v7 = [v5 countByEnumeratingWithState:&v18 objects:v22 count:16];
    }

    while (v7);
  }
}

BOOL sub_100140244(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v8 = 0LL;
  id v9 = &v8;
  uint64_t v10 = 0x2020000000LL;
  char v11 = 0;
  id v1 = *(id *)(a1 + 176);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100140344;
  v5[3] = &unk_1001B07E8;
  id v2 = v1;
  id v6 = v2;
  id v7 = &v8;
  sub_10013D090((uint64_t)&OBJC_CLASS___NRLinkManagerWiFi, v5);
  BOOL v3 = *((_BYTE *)v9 + 24) != 0;

  _Block_object_dispose(&v8, 8);
  return v3;
}

void sub_100140318( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

id sub_100140330(uint64_t a1)
{
  return [*(id *)(a1 + 32) didUpdatePHSState:*(unsigned __int8 *)(a1 + 40) llphsActive:*(unsigned __int8 *)(a1 + 41)];
}

id sub_100140344(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) opMode];
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = (result & 8) != 0;
  return result;
}

void sub_100140378(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) currentKnownNetworkProfile]);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [v2 isPersonalHotspot];
}

uint64_t sub_1001403C0(void *a1, uint64_t a2, uint64_t a3)
{
  if (a1) {
    id v6 = (void *)a1[3];
  }
  else {
    id v6 = 0LL;
  }
  id v7 = v6;
  dispatch_assert_queue_V2(v7);

  if (!a2) {
    return 0LL;
  }
  uint64_t ifname = nwi_ifstate_get_ifname(a2);
  id v9 = (void *)a1[13];
  if (v9) {
    id v9 = (void *)v9[3];
  }
  uint64_t v10 = v9;
  char v11 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", ifname);
  unsigned int v12 = [v10 isEqualToString:v11];

  if (!v12) {
    return 0LL;
  }
  int v19 = 0;
  uint64_t signature = nwi_ifstate_get_signature(a2, a3, &v19);
  if (signature)
  {
    uint64_t v14 = signature;
    uint64_t v15 = objc_alloc(&OBJC_CLASS___NSData);
    id v16 = -[NSData initWithBytes:length:](v15, "initWithBytes:length:", v14, v19);
    id v17 = (void *)a1[10];
    a1[10] = v16;
  }

  else
  {
    id v17 = (void *)a1[10];
    a1[10] = 0LL;
  }

  return 1LL;
}

void sub_1001404E4(id a1)
{
  if (MGGetBoolAnswer(@"wi-fi"))
  {
    if (objc_opt_class(&OBJC_CLASS___CWFInterface)) {
      byte_1001DCBE0 = 1;
    }
  }

uint64_t sub_100140520(uint64_t result)
{
  if (result) {
    return sub_10001E054(*(void *)(result + 128));
  }
  return result;
}

void sub_100140538(uint64_t a1, void *a2)
{
  id v5 = a2;
  if (a1)
  {
    id v4 = (dispatch_queue_s *)*(id *)(a1 + 24);
    dispatch_assert_queue_V2(v4);

    if (([*(id *)(a1 + 88) isEqual:v5] & 1) == 0)
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCBF0, 1LL))
      {
        if (qword_1001DCBF8 != -1) {
          dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
        }
        _NRLogWithArgs( qword_1001DCBF0,  1LL,  "%s%.30s:%-4d Setting the peer Wi-Fi signature as %@ ----> %@",  "",  "-[NRLinkManagerWiFi setPeerWiFiSignature:]",  561LL,  *(void *)(a1 + 88),  v5);
      }

      objc_storeStrong((id *)(a1 + 88), a2);
    }
  }
}

uint64_t sub_10014065C(void *a1)
{
  if (!a1) {
    return 0LL;
  }
  id v2 = (void *)objc_claimAutoreleasedReturnValue([a1 hostname]);
  objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
  if (qword_1001DC640 != -1) {
    dispatch_once(&qword_1001DC640, &stru_1001ADE98);
  }
  id v3 = (id)qword_1001DC638;
  id v4 = @"62743";
  if (!v3) {
    id v4 = 0LL;
  }
  id v5 = v4;
  uint64_t v1 = objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v2,  v5));

  return v1;
}

void sub_100140720(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    id v7 = (dispatch_queue_s *)a1[3];
    dispatch_assert_queue_V2(v7);

    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v45 = 0u;
    __int128 v46 = 0u;
    id v8 = v5;
    id v9 = [v8 countByEnumeratingWithState:&v45 objects:v50 count:16];
    if (v9)
    {
      id v10 = v9;
      char v11 = 0LL;
      uint64_t v12 = *(void *)v46;
      do
      {
        for (uint64_t i = 0LL; i != v10; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v46 != v12) {
            objc_enumerationMutation(v8);
          }
          uint64_t v14 = (void *)sub_10014065C(*(void **)(*((void *)&v45 + 1) + 8LL * (void)i));
          if (v14)
          {
            if (!v11) {
              char v11 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
            }
            -[NSMutableArray addObject:](v11, "addObject:", v14);
          }
        }

        id v10 = [v8 countByEnumeratingWithState:&v45 objects:v50 count:16];
      }

      while (v10);
    }

    else
    {
      char v11 = 0LL;
    }

    uint64_t v15 = a1[13];
    if (v15) {
      uint64_t v15 = (void *)v15[9];
    }
    id v16 = v15;
    id v17 = (void *)objc_claimAutoreleasedReturnValue([v16 objectForKeyedSubscript:v6]);

    if (!v17
      || (__int128 v18 = -[NSSet initWithArray:](objc_alloc(&OBJC_CLASS___NSSet), "initWithArray:", v11),
          int v19 = -[NSSet initWithArray:](objc_alloc(&OBJC_CLASS___NSSet), "initWithArray:", v17),
          unsigned __int8 v20 = -[NSSet isEqualToSet:](v18, "isEqualToSet:", v19),
          v19,
          v18,
          (v20 & 1) == 0))
    {
      __int128 v21 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v6);
      id v40 = v17;
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCBF0, 1LL))
      {
        if (qword_1001DCBF8 != -1) {
          dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
        }
        _NRLogWithArgs( qword_1001DCBF0,  1LL,  "%s%.30s:%-4d Setting the peer Wi-Fi endpoints as %@ ----> %@ for %@",  "",  "-[NRLinkManagerWiFi setPeerWiFiEndpoints:forNRUUID:]",  600LL,  v17,  v11,  v21);
      }

      id v22 = a1[13];
      id v23 = v22;
      id v39 = v5;
      unsigned __int8 v37 = v21;
      if (v22) {
        id v24 = (void *)*((void *)v22 + 9);
      }
      else {
        id v24 = 0LL;
      }
      id v25 = v24;
      [v25 setObject:v11 forKeyedSubscript:v6];

      uint64_t v38 = (uint64_t)a1;
      id v26 = [a1[19] copy];
      __int128 v41 = 0u;
      __int128 v42 = 0u;
      __int128 v43 = 0u;
      __int128 v44 = 0u;
      id v27 = v26;
      id v28 = [v27 countByEnumeratingWithState:&v41 objects:v49 count:16];
      if (v28)
      {
        id v29 = v28;
        uint64_t v30 = *(void *)v42;
        do
        {
          for (uint64_t j = 0LL; j != v29; uint64_t j = (char *)j + 1)
          {
            if (*(void *)v42 != v30) {
              objc_enumerationMutation(v27);
            }
            __int128 v32 = *(void **)(*((void *)&v41 + 1) + 8LL * (void)j);
            if ([v32 subtype] == 101)
            {
              __int128 v33 = (void *)objc_claimAutoreleasedReturnValue([v32 remoteOuterEndpoint]);
              unsigned __int8 v34 = -[NSMutableArray containsObject:](v11, "containsObject:", v33);

              if ((v34 & 1) == 0)
              {
                __int128 v35 = (void *)objc_claimAutoreleasedReturnValue([v32 nrUUID]);
                unsigned int v36 = [v35 isEqual:v6];

                if (v36) {
                  [v32 cancelWithReason:@"Peer Wi-Fi endpoint changed"];
                }
              }
            }
          }

          id v29 = [v27 countByEnumeratingWithState:&v41 objects:v49 count:16];
        }

        while (v29);
      }

      sub_10013A914(v38);
      id v5 = v39;
      id v17 = v40;
    }
  }
}

id sub_100140B30(uint64_t a1, void *a2)
{
  if (a1)
  {
    id v3 = a2;
    id v4 = (dispatch_queue_s *)*(id *)(a1 + 24);
    dispatch_assert_queue_V2(v4);

    id v5 = *(void **)(a1 + 104);
    if (v5) {
      id v5 = (void *)v5[9];
    }
    id v6 = v5;
    id v7 = (void *)objc_claimAutoreleasedReturnValue([v6 objectForKeyedSubscript:v3]);

    id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 firstObject]);
  }

  else
  {
    id v8 = 0LL;
  }

  return v8;
}

void sub_100140BC8(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    id v7 = (dispatch_queue_s *)a1[3];
    dispatch_assert_queue_V2(v7);

    id v8 = (void *)sub_10014065C(v5);
    id v9 = a1[14];
    if (v9) {
      id v9 = (void *)v9[9];
    }
    id v10 = v9;
    char v11 = (void *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:v6]);
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v11 firstObject]);

    if (!v12 || ([v12 isEqual:v8] & 1) == 0)
    {
      unsigned __int8 v34 = v12;
      id v13 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v6);
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCBF0, 1LL))
      {
        if (qword_1001DCBF8 != -1) {
          dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
        }
        uint64_t v14 = (void *)qword_1001DCBF0;
        uint64_t v15 = a1[14];
        id v16 = v14;
        id v17 = v8;
        if (v15) {
          __int128 v18 = (void *)v15[9];
        }
        else {
          __int128 v18 = 0LL;
        }
        id v19 = v18;
        unsigned __int8 v20 = (void *)objc_claimAutoreleasedReturnValue([v19 objectForKeyedSubscript:v6]);
        _NRLogWithArgs( v16,  1LL,  "%s%.30s:%-4d Setting the peer AWDL endpoint as %@ ----> %@ for %@",  "",  "-[NRLinkManagerWiFi setPeerAWDLEndpoint:nrUUID:]",  1054LL,  v20,  v17,  v13);

        id v8 = v17;
      }

      if (v8)
      {
        __int128 v41 = v8;
        __int128 v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v41, 1LL));
      }

      else
      {
        __int128 v21 = 0LL;
      }

      id v22 = a1[14];
      if (v22) {
        id v22 = (void *)v22[9];
      }
      __int128 v33 = v13;
      id v23 = v22;
      [v23 setObject:v21 forKeyedSubscript:v6];

      __int128 v35 = v8;
      if (v8) {

      }
      id v24 = [a1[19] copy];
      __int128 v36 = 0u;
      __int128 v37 = 0u;
      __int128 v38 = 0u;
      __int128 v39 = 0u;
      id v25 = v24;
      id v26 = [v25 countByEnumeratingWithState:&v36 objects:v40 count:16];
      if (v26)
      {
        id v27 = v26;
        uint64_t v28 = *(void *)v37;
        do
        {
          for (uint64_t i = 0LL; i != v27; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v37 != v28) {
              objc_enumerationMutation(v25);
            }
            uint64_t v30 = *(void **)(*((void *)&v36 + 1) + 8LL * (void)i);
            if ([v30 subtype] == 102)
            {
              __int128 v31 = (void *)objc_claimAutoreleasedReturnValue([v30 nrUUID]);
              unsigned int v32 = [v31 isEqual:v6];

              if (v32) {
                [v30 cancelWithReason:@"Peer AWDL endpoint changed"];
              }
            }
          }

          id v27 = [v25 countByEnumeratingWithState:&v36 objects:v40 count:16];
        }

        while (v27);
      }

      sub_100139DFC((uint64_t)a1);
      uint64_t v12 = v34;
      id v8 = v35;
    }
  }

  else
  {
    id v8 = v5;
  }
}

void sub_100140F48(uint64_t a1, int a2, void *a3)
{
  id v7 = a3;
  if (a1)
  {
    id v5 = (dispatch_queue_s *)*(id *)(a1 + 24);
    dispatch_assert_queue_V2(v5);

    if (*(_DWORD *)(a1 + 12) == 1003)
    {
      unsigned int v6 = [*(id *)(a1 + 208) containsObject:v7];
      if (a2)
      {
        if ((v6 & 1) == 0)
        {
          [*(id *)(a1 + 208) addObject:v7];
LABEL_8:
          sub_100141004(a1);
        }
      }

      else if (v6)
      {
        [*(id *)(a1 + 208) removeObject:v7];
        if (![*(id *)(a1 + 208) count]) {
          goto LABEL_8;
        }
      }
    }
  }
}

void sub_100141004(uint64_t a1)
{
  if (a1) {
    id v2 = *(void **)(a1 + 24);
  }
  else {
    id v2 = 0LL;
  }
  id v3 = v2;
  dispatch_assert_queue_V2(v3);

  if (qword_1001DCBF8 != -1) {
    dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCBF0, 0LL))
  {
    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    _NRLogWithArgs( qword_1001DCBF0,  0LL,  "%s%.30s:%-4d request to update WiFi state",  "",  "-[NRLinkManagerWiFi updateWiFiState]",  1766);
  }

  id v4 = [*(id *)(a1 + 208) count];
  id v5 = *(void **)(a1 + 192);
  if (v4)
  {
    if (v5) {
      goto LABEL_19;
    }
    unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue( +[CWFActivity activityWithType:reason:]( &OBJC_CLASS___CWFActivity,  "activityWithType:reason:",  1LL,  @"Terminus Background"));
    objc_storeStrong((id *)(a1 + 192), v6);
    id v7 = *(id *)(a1 + 176);
    id v8 = *(id *)(a1 + 24);
    objc_initWeak(&location, (id)a1);
    if (qword_1001DCC00 != -1) {
      dispatch_once(&qword_1001DCC00, &stru_1001B08F0);
    }
    id v9 = (void *)qword_1001DCC08;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100141868;
    block[3] = &unk_1001B07C0;
    id v10 = v7;
    id v68 = v10;
    id v11 = v6;
    id v69 = v11;
    id v12 = v8;
    id v70 = v12;
    id v13 = v9;
    objc_copyWeak(&v71, &location);
    dispatch_async(v13, block);

    [(id)a1 reportEvent:11001 details:@"Background"];
    objc_destroyWeak(&v71);

    objc_destroyWeak(&location);
  }

  else
  {
    if (!v5) {
      goto LABEL_19;
    }
    id v14 = v5;
    uint64_t v15 = *(void **)(a1 + 192);
    *(void *)(a1 + 192) = 0LL;

    id v16 = *(id *)(a1 + 176);
    if (qword_1001DCC00 != -1) {
      dispatch_once(&qword_1001DCC00, &stru_1001B08F0);
    }
    id v17 = (dispatch_queue_s *)qword_1001DCC08;
    v64[0] = _NSConcreteStackBlock;
    v64[1] = 3221225472LL;
    v64[2] = sub_100141980;
    v64[3] = &unk_1001B0720;
    id v65 = v16;
    id v66 = v14;
    id v11 = v14;
    id v10 = v16;
    dispatch_async(v17, v64);
    [(id)a1 reportEvent:11002 details:@"Background"];

    id v12 = v65;
  }

LABEL_19:
  __int128 v18 = *(void **)(a1 + 200);
  if (*(_BYTE *)(a1 + 34))
  {
    if (v18) {
      goto LABEL_29;
    }
    id v19 = (void *)objc_claimAutoreleasedReturnValue( +[CWFActivity activityWithType:reason:]( &OBJC_CLASS___CWFActivity,  "activityWithType:reason:",  3LL,  @"Terminus Direct-to-Cloud"));
    objc_storeStrong((id *)(a1 + 200), v19);
    id v20 = *(id *)(a1 + 176);
    id v21 = *(id *)(a1 + 24);
    objc_initWeak(&location, (id)a1);
    if (qword_1001DCC00 != -1) {
      dispatch_once(&qword_1001DCC00, &stru_1001B08F0);
    }
    id v22 = (void *)qword_1001DCC08;
    v59[0] = _NSConcreteStackBlock;
    v59[1] = 3221225472LL;
    v59[2] = sub_10014198C;
    v59[3] = &unk_1001B07C0;
    id v23 = v20;
    id v60 = v23;
    id v24 = v19;
    id v61 = v24;
    id v25 = v21;
    id v62 = v25;
    id v26 = v22;
    objc_copyWeak(&v63, &location);
    dispatch_async(v26, v59);

    [(id)a1 reportEvent:11001 details:@"Direct-to-Cloud"];
    objc_destroyWeak(&v63);

    objc_destroyWeak(&location);
  }

  else
  {
    if (!v18) {
      goto LABEL_29;
    }
    id v27 = v18;
    uint64_t v28 = *(void **)(a1 + 200);
    *(void *)(a1 + 200) = 0LL;

    id v29 = *(id *)(a1 + 176);
    if (qword_1001DCC00 != -1) {
      dispatch_once(&qword_1001DCC00, &stru_1001B08F0);
    }
    uint64_t v30 = (dispatch_queue_s *)qword_1001DCC08;
    v56[0] = _NSConcreteStackBlock;
    v56[1] = 3221225472LL;
    v56[2] = sub_100141AA4;
    v56[3] = &unk_1001B0720;
    id v57 = v29;
    id v58 = v27;
    id v24 = v27;
    id v23 = v29;
    dispatch_async(v30, v56);
    [(id)a1 reportEvent:11002 details:@"Direct-to-Cloud"];

    id v25 = v57;
  }

LABEL_29:
  __int128 v31 = (dispatch_queue_s *)*(id *)(a1 + 24);
  dispatch_assert_queue_V2(v31);

  if (*(void *)(a1 + 192))
  {
    if (*(void *)(a1 + 248) != 1LL)
    {
      uint64_t v32 = 1LL;
      goto LABEL_38;
    }
  }

  else
  {
    uint64_t v33 = *(void *)(a1 + 200);
    if (v33) {
      uint64_t v34 = 3LL;
    }
    else {
      uint64_t v34 = 0LL;
    }
    if (v34 != *(void *)(a1 + 248))
    {
      if (!v33)
      {
        __int128 v43 = *(void **)(a1 + 184);
        if (!v43)
        {
          uint64_t v32 = 0LL;
          goto LABEL_47;
        }

        id v44 = v43;
        __int128 v45 = *(void **)(a1 + 184);
        *(void *)(a1 + 184) = 0LL;

        id v46 = *(id *)(a1 + 176);
        if (qword_1001DCC00 != -1) {
          dispatch_once(&qword_1001DCC00, &stru_1001B08F0);
        }
        __int128 v47 = (dispatch_queue_s *)qword_1001DCC08;
        v53[0] = _NSConcreteStackBlock;
        v53[1] = 3221225472LL;
        void v53[2] = sub_100141AB0;
        v53[3] = &unk_1001B0720;
        id v54 = v46;
        id v55 = v44;
        id v40 = v44;
        id v39 = v46;
        dispatch_async(v47, v53);
        [(id)a1 reportEvent:11002 details:@"WoW"];

        uint64_t v32 = 0LL;
        id v41 = v54;
        goto LABEL_46;
      }

      uint64_t v32 = 3LL;
LABEL_38:
      if (*(void *)(a1 + 184))
      {
LABEL_47:
        *(void *)(a1 + 24_Block_object_dispose(va, 8) = v32;
        goto LABEL_48;
      }

      __int128 v35 = (void *)objc_claimAutoreleasedReturnValue( +[CWFActivity activityWithType:reason:]( &OBJC_CLASS___CWFActivity,  "activityWithType:reason:",  4LL,  @"Terminus WoW"));
      objc_storeStrong((id *)(a1 + 184), v35);
      id v36 = *(id *)(a1 + 176);
      id v37 = *(id *)(a1 + 24);
      objc_initWeak(&location, (id)a1);
      if (qword_1001DCC00 != -1) {
        dispatch_once(&qword_1001DCC00, &stru_1001B08F0);
      }
      __int128 v38 = (void *)qword_1001DCC08;
      v48[0] = _NSConcreteStackBlock;
      v48[1] = 3221225472LL;
      void v48[2] = sub_100141ABC;
      v48[3] = &unk_1001B07C0;
      id v39 = v36;
      id v49 = v39;
      id v40 = v35;
      id v50 = v40;
      id v41 = v37;
      id v51 = v41;
      __int128 v42 = v38;
      objc_copyWeak(&v52, &location);
      dispatch_async(v42, v48);

      [(id)a1 reportEvent:11001 details:@"WoW"];
      objc_destroyWeak(&v52);

      objc_destroyWeak(&location);
LABEL_46:

      goto LABEL_47;
    }
  }

void sub_100141844(_Unwind_Exception *a1)
{
}

void sub_100141868(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  id v15 = 0LL;
  unsigned __int8 v4 = [v2 beginActivity:v3 error:&v15];
  id v5 = v15;
  if ((v4 & 1) == 0)
  {
    unsigned int v6 = *(dispatch_queue_s **)(a1 + 48);
    objc_super block = _NSConcreteStackBlock;
    uint64_t v10 = 3221225472LL;
    id v11 = sub_1001423AC;
    id v12 = &unk_1001B0798;
    objc_copyWeak(&v14, (id *)(a1 + 56));
    id v13 = *(id *)(a1 + 40);
    dispatch_async(v6, &block);
    id v7 = sub_10013A600();
    LOBYTE(v6) = _NRLogIsLevelEnabled(v7, 17LL);

    if ((v6 & 1) != 0)
    {
      id v8 = sub_10013A600();
      _NRLogWithArgs( v8,  17LL,  "[CWFInterface beginActivity:CWFActivityTypeBackgroundApp] failed: %@",  v5,  block,  v10,  v11,  v12);
    }

    objc_destroyWeak(&v14);
  }
}

void sub_10014196C(_Unwind_Exception *a1)
{
}

id sub_100141980(uint64_t a1)
{
  return [*(id *)(a1 + 32) endActivity:*(void *)(a1 + 40)];
}

void sub_10014198C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  id v15 = 0LL;
  unsigned __int8 v4 = [v2 beginActivity:v3 error:&v15];
  id v5 = v15;
  if ((v4 & 1) == 0)
  {
    unsigned int v6 = *(dispatch_queue_s **)(a1 + 48);
    objc_super block = _NSConcreteStackBlock;
    uint64_t v10 = 3221225472LL;
    id v11 = sub_100142354;
    id v12 = &unk_1001B0798;
    objc_copyWeak(&v14, (id *)(a1 + 56));
    id v13 = *(id *)(a1 + 40);
    dispatch_async(v6, &block);
    id v7 = sub_10013A600();
    LOBYTE(v6) = _NRLogIsLevelEnabled(v7, 17LL);

    if ((v6 & 1) != 0)
    {
      id v8 = sub_10013A600();
      _NRLogWithArgs( v8,  17LL,  "[CWFInterface beginActivity:CWFActivityTypeWiFiBound] failed: %@",  v5,  block,  v10,  v11,  v12);
    }

    objc_destroyWeak(&v14);
  }
}

void sub_100141A90(_Unwind_Exception *a1)
{
}

id sub_100141AA4(uint64_t a1)
{
  return [*(id *)(a1 + 32) endActivity:*(void *)(a1 + 40)];
}

id sub_100141AB0(uint64_t a1)
{
  return [*(id *)(a1 + 32) endActivity:*(void *)(a1 + 40)];
}

void sub_100141ABC(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  id v15 = 0LL;
  unsigned __int8 v4 = [v2 beginActivity:v3 error:&v15];
  id v5 = v15;
  if ((v4 & 1) == 0)
  {
    unsigned int v6 = *(dispatch_queue_s **)(a1 + 48);
    objc_super block = _NSConcreteStackBlock;
    uint64_t v10 = 3221225472LL;
    id v11 = sub_1001422FC;
    id v12 = &unk_1001B0798;
    objc_copyWeak(&v14, (id *)(a1 + 56));
    id v13 = *(id *)(a1 + 40);
    dispatch_async(v6, &block);
    id v7 = sub_10013A600();
    LOBYTE(v6) = _NRLogIsLevelEnabled(v7, 17LL);

    if ((v6 & 1) != 0)
    {
      id v8 = sub_10013A600();
      _NRLogWithArgs( v8,  17LL,  "[CWFInterface beginActivity:CWFActivityTypeEnableWakeOnWireless] failed: %@",  v5,  block,  v10,  v11,  v12);
    }

    objc_destroyWeak(&v14);
  }
}

void sub_100141BC0(_Unwind_Exception *a1)
{
}

void sub_100141BD4(id val)
{
  uint64_t v2 = (void *)(*((void *)val + 32) + 1LL);
  *((void *)val + 32) = v2;
  objc_initWeak(&location, val);
  dispatch_time_t v3 = dispatch_time(0LL, 500000000LL);
  unsigned __int8 v4 = (dispatch_queue_s *)*((id *)val + 3);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100141CA8;
  block[3] = &unk_1001B0770;
  objc_copyWeak(v6, &location);
  v6[1] = v2;
  dispatch_after(v3, v4, block);

  objc_destroyWeak(v6);
  objc_destroyWeak(&location);
}

void sub_100141CA8(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  dispatch_time_t v3 = WeakRetained;
  if (WeakRetained && *((_DWORD *)WeakRetained + 3) == 1003 && WeakRetained[32] == *(id *)(a1 + 40))
  {
    __int128 v42 = 0u;
    __int128 v43 = 0u;
    __int128 v40 = 0u;
    __int128 v41 = 0u;
    unsigned __int8 v4 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained[28] allValues]);
    id v5 = [v4 countByEnumeratingWithState:&v40 objects:v45 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = 0LL;
      uint64_t v8 = *(void *)v41;
      do
      {
        for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v41 != v8) {
            objc_enumerationMutation(v4);
          }
          v7 |= (unint64_t)[*(id *)(*((void *)&v40 + 1) + 8 * (void)i) unsignedLongLongValue];
        }

        id v6 = [v4 countByEnumeratingWithState:&v40 objects:v45 count:16];
      }

      while (v6);
    }

    else
    {
      uint64_t v7 = 0LL;
    }

    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    if (!_NRLogIsLevelEnabled(qword_1001DCBF0, 1LL))
    {
LABEL_47:
      id v19 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
      __int128 v36 = 0u;
      __int128 v37 = 0u;
      __int128 v38 = 0u;
      __int128 v39 = 0u;
      id v20 = (void *)objc_claimAutoreleasedReturnValue([v3[29] allValues]);
      id v21 = [v20 countByEnumeratingWithState:&v36 objects:v44 count:16];
      if (v21)
      {
        id v22 = v21;
        uint64_t v23 = *(void *)v37;
        do
        {
          for (uint64_t j = 0LL; j != v22; uint64_t j = (char *)j + 1)
          {
            if (*(void *)v37 != v23) {
              objc_enumerationMutation(v20);
            }
            -[NSMutableSet addObjectsFromArray:]( v19,  "addObjectsFromArray:",  *(void *)(*((void *)&v36 + 1) + 8LL * (void)j));
          }

          id v22 = [v20 countByEnumeratingWithState:&v36 objects:v44 count:16];
        }

        while (v22);
      }

      id v25 = v3[31];
      if (v7)
      {
        if (!v25)
        {
LABEL_62:

          goto LABEL_63;
        }
      }

      else if (v25)
      {
        id v26 = objc_alloc(&OBJC_CLASS___NSString);
        uint64_t v35 = (uint64_t)v3[31];
        id v27 = -[NSString initWithFormat:]( v26,  "initWithFormat:",  @"Reporting WiFi client type %zd with no reason");
        sub_1001030D0(@"NRLinkManagerWiFi", @"PowerLog", v27, 0, 0LL, v28, v29, v30, v35);
      }

      __int128 v31 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", v3[31]));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v31,  "setObject:forKeyedSubscript:",  v32,  @"WiFiClientType");

      uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v3[23] != 0LL));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v31,  "setObject:forKeyedSubscript:",  v33,  @"WiFiWoWState");

      uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", v7));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v31,  "setObject:forKeyedSubscript:",  v34,  @"WiFiAssertionReason");

      -[NSMutableDictionary setObject:forKeyedSubscript:]( v31,  "setObject:forKeyedSubscript:",  v19,  @"WiFiAssertionClients");
      if (([v3[30] isEqualToDictionary:v31] & 1) == 0)
      {
        sub_100101A04(@"NetworkRelay Wi-Fi Assertion", v31);
        objc_storeStrong(v3 + 30, v31);
      }

      goto LABEL_62;
    }

    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    id v10 = (id)qword_1001DCBF0;
    id v11 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
    if ((v7 & 2) != 0)
    {
      id v12 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", "RangeExtension");
      if (-[NSMutableString length](v11, "length")) {
        -[NSMutableString appendString:](v11, "appendString:", @", ");
      }
      -[NSMutableString appendString:](v11, "appendString:", v12);

      if ((v7 & 4) == 0)
      {
LABEL_19:
        if ((v7 & 8) == 0) {
          goto LABEL_20;
        }
        goto LABEL_31;
      }
    }

    else if ((v7 & 4) == 0)
    {
      goto LABEL_19;
    }

    id v13 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", "PreferWiFi");
    if (-[NSMutableString length](v11, "length")) {
      -[NSMutableString appendString:](v11, "appendString:", @", ");
    }
    -[NSMutableString appendString:](v11, "appendString:", v13);

    if ((v7 & 8) == 0)
    {
LABEL_20:
      if ((v7 & 0x10) == 0) {
        goto LABEL_21;
      }
      goto LABEL_34;
    }

void sub_1001422FC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    dispatch_time_t v3 = (void *)WeakRetained[23];
    if (v3 == *(void **)(a1 + 32))
    {
      WeakRetained[23] = 0LL;
      unsigned __int8 v4 = WeakRetained;

      id WeakRetained = v4;
    }
  }
}

void sub_100142354(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    dispatch_time_t v3 = (void *)WeakRetained[25];
    if (v3 == *(void **)(a1 + 32))
    {
      WeakRetained[25] = 0LL;
      unsigned __int8 v4 = WeakRetained;

      id WeakRetained = v4;
    }
  }
}

void sub_1001423AC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    dispatch_time_t v3 = (void *)WeakRetained[24];
    if (v3 == *(void **)(a1 + 32))
    {
      WeakRetained[24] = 0LL;
      unsigned __int8 v4 = WeakRetained;

      id WeakRetained = v4;
    }
  }
}

void sub_100142404(void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v9 = v3;
    if (v3)
    {
      unsigned __int8 v4 = (void *)a1[28];
      if (v4) {
        [v4 setObject:0 forKeyedSubscript:v9];
      }
      id v5 = (void *)a1[29];
      if (v5) {
        [v5 setObject:0 forKeyedSubscript:v9];
      }
      sub_100141BD4(a1);
    }

    else
    {
      id v6 = sub_10013A600();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 17LL);

      id v3 = 0LL;
      if (!IsLevelEnabled) {
        goto LABEL_9;
      }
      id v8 = sub_10013A600();
      _NRLogWithArgs( v8,  17LL,  "%s called with null identifier",  "-[NRLinkManagerWiFi removeAssertionReasonForIdentifier:]");
    }

    id v3 = v9;
  }

void sub_1001424C8(id *a1, uint64_t a2, void *a3, void *a4)
{
  id v18 = a3;
  id v7 = a4;
  if (a1)
  {
    id v8 = v18;
    if (v18)
    {
      if (!a1[28])
      {
        id v9 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        id v10 = a1[28];
        a1[28] = v9;

        id v8 = v18;
      }

      if (a1[29])
      {
        if (a2)
        {
LABEL_7:
          id v11 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  a2));
          [a1[28] setObject:v11 forKeyedSubscript:v18];

          id v12 = v7;
LABEL_10:
          [a1[29] setObject:v12 forKeyedSubscript:v18];
          sub_100141BD4(a1);
          goto LABEL_11;
        }
      }

      else
      {
        id v13 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        id v14 = a1[29];
        a1[29] = v13;

        id v8 = v18;
        if (a2) {
          goto LABEL_7;
        }
      }

      [a1[28] setObject:0 forKeyedSubscript:v8];
      id v12 = 0LL;
      goto LABEL_10;
    }

    id v15 = sub_10013A600();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v15, 17LL);

    if (IsLevelEnabled)
    {
      id v17 = sub_10013A600();
      _NRLogWithArgs( v17,  17LL,  "%s called with null identifier",  "-[NRLinkManagerWiFi addAssertionReasonWithMask:identifier:clients:]");
    }
  }

void sub_100142640(uint64_t a1, char a2)
{
  if (a1)
  {
    unsigned __int8 v4 = (dispatch_queue_s *)*(id *)(a1 + 24);
    dispatch_assert_queue_V2(v4);

    if (*(void *)(a1 + 216))
    {
      *(_BYTE *)(a1 + 34) = a2;
      sub_100141004(a1);
    }
  }

BOOL sub_1001426B0(BOOL result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = (dispatch_queue_s *)*(id *)(result + 24);
    dispatch_assert_queue_V2(v2);

    return *(_DWORD *)(v1 + 40) > 0;
  }

  return result;
}

uint64_t sub_1001426F8(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = (dispatch_queue_s *)*(id *)(result + 24);
    dispatch_assert_queue_V2(v2);

    *(_DWORD *)(v1 + 48) += *(_DWORD *)(v1 + 40);
    sub_10013CD30(v1);
    *(_BYTE *)(v1 + 33) = 0;
    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    id result = _NRLogIsLevelEnabled(qword_1001DCBF0, 0LL);
    if ((_DWORD)result)
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      return _NRLogWithArgs( qword_1001DCBF0,  0LL,  "%s%.30s:%-4d cleared prefer Wi-Fi asserts (active=%d, cleared=%d)",  "",  "-[NRLinkManagerWiFi clearPreferWiFiAsserts]",  1878,  *(_DWORD *)(v1 + 40),  *(_DWORD *)(v1 + 48));
    }
  }

  return result;
}

BOOL sub_10014281C(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  uint64_t v2 = (dispatch_queue_s *)*(id *)(a1 + 24);
  dispatch_assert_queue_V2(v2);

  uint64_t v18 = 0LL;
  id v19 = &v18;
  uint64_t v20 = 0x2020000000LL;
  char v21 = 0;
  id v3 = *(id *)(a1 + 176);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472LL;
  v15[2] = sub_100142A58;
  v15[3] = &unk_1001B07E8;
  id v17 = &v18;
  id v4 = v3;
  id v16 = v4;
  if (sub_10013D090((uint64_t)&OBJC_CLASS___NRLinkManagerWiFi, v15))
  {
    id v12 = sub_10013A600();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 16LL);

    if (IsLevelEnabled)
    {
      id v14 = sub_10013A600();
      _NRLogWithArgs( v14,  16LL,  "%s%.30s:%-4d Timed out getting WiFi power state, assuming OFF",  "",  "-[NRLinkManagerWiFi isWiFiPoweredOn]",  1902);
    }

    BOOL v10 = 0LL;
  }

  else
  {
    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    id v5 = (id)qword_1001DCBF0;
    char v6 = _NRLogIsLevelEnabled(v5, 1LL);

    if ((v6 & 1) != 0)
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      id v7 = (id)qword_1001DCBF0;
      id v8 = v7;
      if (*((_BYTE *)v19 + 24)) {
        id v9 = "ON";
      }
      else {
        id v9 = "OFF";
      }
      _NRLogWithArgs( v7,  1LL,  "%s%.30s:%-4d WiFi power state = %s",  "",  "-[NRLinkManagerWiFi isWiFiPoweredOn]",  1899,  v9);
    }

    BOOL v10 = *((_BYTE *)v19 + 24) != 0;
  }

  _Block_object_dispose(&v18, 8);
  return v10;
}

void sub_100142A40( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

id sub_100142A58(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) powerOn];
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = (_BYTE)result;
  return result;
}

void sub_100142A88(uint64_t a1)
{
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v12 = 0u;
  __int128 v13 = 0u;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "interfaceNames", 0));
  id v3 = [v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v11;
    do
    {
      char v6 = 0LL;
      do
      {
        if (*(void *)v11 != v5) {
          objc_enumerationMutation(v2);
        }
        if ([*(id *)(*((void *)&v10 + 1) + 8 * (void)v6) isEqualToString:*(void *)(a1 + 40)])
        {
          uint64_t v7 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) SSID]);
          uint64_t v8 = *(void *)(*(void *)(a1 + 48) + 8LL);
          id v9 = *(void **)(v8 + 40);
          *(void *)(v8 + 40) = v7;
        }

        char v6 = (char *)v6 + 1;
      }

      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }

    while (v4);
  }
}

void sub_100142BAC(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) countryCode]);
  id v3 = v2;
  if (v2 && [v2 compare:@"XZ" options:1])
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 64) + 8LL) + 24LL) = 1;
  }

  else
  {
    id v4 = *(void **)(a1 + 32);
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = *(void *)(*(void *)(a1 + 56) + 8LL);
    id obj = *(id *)(v6 + 40);
    unsigned __int8 v7 = [v4 setCompanionCountryCode:v5 error:&obj];
    objc_storeStrong((id *)(v6 + 40), obj);
    *(_BYTE *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = v7;
  }
}

void sub_100142C54(uint64_t a1)
{
  uint64_t v2 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) countryCode]);
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

id sub_100142C8C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3)
  {
    BOOL v4 = *(_BYTE *)(v3 + 37) != 0;
    BOOL v5 = *(unsigned __int8 *)(v3 + 38) != 0;
  }

  else
  {
    BOOL v4 = 0LL;
    BOOL v5 = 0LL;
  }

  return [v2 didUpdatePHSState:v4 llphsActive:v5];
}

void sub_100142CD4(uint64_t a1)
{
  id v5 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) NANData]);
  uint64_t v2 = objc_claimAutoreleasedReturnValue([v5 interfaceName]);
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  BOOL v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_100142D28(uint64_t a1, uint64_t a2)
{
  id location = 0LL;
  p_id location = &location;
  uint64_t v35 = 0x3032000000LL;
  __int128 v36 = sub_10013D160;
  __int128 v37 = sub_10013D170;
  id v38 = 0LL;
  uint64_t v4 = nw_interface_create_with_name([@"awdl0" UTF8String]);
  id v5 = (void *)v4;
  if (v4 && nw_interface_get_subtype(v4) == 1002)
  {
    id v6 = p_location[5];
    p_location[5] = @"awdl0";
  }

  else
  {
    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    id v7 = (id)qword_1001DCBF0;
    int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 1LL);

    if (IsLevelEnabled)
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      id v9 = (id)qword_1001DCBF0;
      _NRLogWithArgs( v9,  1LL,  "%s%.30s:%-4d Falling back to retrieving AWDL interface from wifid",  "",  "-[NRLinkManagerWiFi setupWiFiManagerForAWDL]",  2229);
    }

    id v10 = *(id *)(a1 + 176);
    v30[0] = _NSConcreteStackBlock;
    v30[1] = 3221225472LL;
    v30[2] = sub_100143248;
    v30[3] = &unk_1001B07E8;
    uint64_t v32 = &location;
    id v6 = v10;
    id v31 = v6;
    if (sub_10013D090((uint64_t)&OBJC_CLASS___NRLinkManagerWiFi, v30))
    {
      id v18 = sub_10013A600();
      char v19 = _NRLogIsLevelEnabled(v18, 16LL);

      if ((v19 & 1) != 0)
      {
        id v20 = sub_10013A600();
        _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d Timed out getting AWDL interface name",  "",  "-[NRLinkManagerWiFi setupWiFiManagerForAWDL]",  2236);
      }

      goto LABEL_27;
    }
  }

  if (p_location[5])
  {
    __int128 v11 = objc_alloc(&OBJC_CLASS___NRSCDInterfaceConfig);
    __int128 v12 = sub_10001DAD4((id *)&v11->super.isa, p_location[5], 1);
    __int128 v13 = *(void **)(a1 + 112);
    *(void *)(a1 + 112) = v12;

    id v14 = *(id *)(a1 + 112);
    if (v14)
    {
      int v15 = v14[3];

      if (v15)
      {
        sub_10013D34C(a1);

        _Block_object_dispose(&location, 8);
        [(id)a1 reportEvent:2016];
        return;
      }
    }

    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    id v21 = (id)qword_1001DCBF0;
    int v22 = _NRLogIsLevelEnabled(v21, 17LL);

    if (v22)
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      id v6 = (id)qword_1001DCBF0;
      _NRLogWithArgs(v6, 17LL, "failed to find interface index for %@", p_location[5]);
      goto LABEL_27;
    }
  }

  else
  {
    id v16 = sub_10013A600();
    int v17 = _NRLogIsLevelEnabled(v16, 16LL);

    if (v17)
    {
      id v6 = sub_10013A600();
      _NRLogWithArgs( v6,  16LL,  "%s%.30s:%-4d Failed to determine AWDL interface",  "",  "-[NRLinkManagerWiFi setupWiFiManagerForAWDL]",  2242);
LABEL_27:
    }
  }

  _Block_object_dispose(&location, 8);
  sub_1001431E4(a1);
  else {
    uint64_t v23 = (2 * a2);
  }
  objc_msgSend((id)a1, "reportEvent:detailsFormat:", 2015, @"Retry in %us (attempt: %u)", v23, a2);
  objc_initWeak(&location, (id)a1);
  dispatch_time_t v24 = dispatch_time(0LL, 1000000000LL * v23);
  if (a1) {
    id v25 = *(void **)(a1 + 24);
  }
  else {
    id v25 = 0LL;
  }
  id v26 = v25;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_1001431F8;
  block[3] = &unk_1001B0860;
  objc_copyWeak(&v28, &location);
  int v29 = a2;
  dispatch_after(v24, v26, block);

  objc_destroyWeak(&v28);
  objc_destroyWeak(&location);
}

void sub_1001431C8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

void sub_1001431E4(uint64_t a1)
{
}

void sub_1001431F8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && WeakRetained[3] != 1004)
  {
    uint64_t v2 = WeakRetained;
    sub_100142D28();
    id WeakRetained = v2;
  }
}

void sub_100143248(uint64_t a1)
{
  id v5 = (id)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) AWDL]);
  uint64_t v2 = objc_claimAutoreleasedReturnValue([v5 interfaceName]);
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_10014329C(void *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = v1[9];
    if (v3)
    {
      uint64_t v4 = v3;
      id v5 = v2[9];
      id v6 = [v5 count];

      if (v6)
      {
        id v7 = v2[9];
        uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v7 allKeys]);
        id v9 = [v8 copy];

        __int128 v21 = 0u;
        __int128 v22 = 0u;
        __int128 v19 = 0u;
        __int128 v20 = 0u;
        id v10 = v9;
        id v11 = [v10 countByEnumeratingWithState:&v19 objects:v23 count:16];
        if (v11)
        {
          id v12 = v11;
          uint64_t v13 = *(void *)v20;
          do
          {
            for (uint64_t i = 0LL; i != v12; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v20 != v13) {
                objc_enumerationMutation(v10);
              }
              id v16 = *(void **)(*((void *)&v19 + 1) + 8LL * (void)i);
              int v17 = sub_100129C28((uint64_t)&OBJC_CLASS___NRDLocalDevice, v16, 0);
              id v18 = v17;
              if (!v17 || !v17[9])
              {
                id v15 = v2[9];
                objc_msgSend(v15, "setObject:forKeyedSubscript:", 0, v16, (void)v19);
              }
            }

            id v12 = [v10 countByEnumeratingWithState:&v19 objects:v23 count:16];
          }

          while (v12);
        }
      }
    }
  }
}

void sub_100143448(id *a1)
{
  if (a1)
  {
    uint64_t v2 = (dispatch_queue_s *)a1[3];
    dispatch_assert_queue_V2(v2);

    id v3 = [a1[19] copy];
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    id v4 = v3;
    id v5 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v13;
      do
      {
        for (uint64_t i = 0LL; i != v6; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v13 != v7) {
            objc_enumerationMutation(v4);
          }
          id v9 = *(void **)(*((void *)&v12 + 1) + 8LL * (void)i);
          id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 nrUUID]);
          id v11 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v10);

          if (!v11 || !v11[9]) {
            [v9 cancelWithReason:@"Device has been disabled %@", v11];
          }
        }

        id v6 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
      }

      while (v6);
    }

    sub_10014329C(a1[13]);
    sub_10014329C(a1[14]);
    sub_10014329C(a1[15]);
    sub_10014329C(a1[16]);
    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCBF0, 1LL))
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      _NRLogWithArgs( qword_1001DCBF0,  1LL,  "%s%.30s:%-4d Forcing interface availability event to check for new enabled devices",  "",  "-[NRLinkManagerWiFi checkEnabledDevices]",  2658);
    }

    sub_10013A914((uint64_t)a1);
    sub_100139DFC((uint64_t)a1);
    sub_10013B098((uint64_t)a1);
  }

void *sub_100143718(void *a1)
{
  if (!a1) {
    return 0LL;
  }
  v15.receiver = a1;
  v15.super_class = (Class)&OBJC_CLASS___NRDKeyManager;
  uint64_t v1 = objc_msgSendSuper2(&v15, "init");
  if (!v1)
  {
    id v6 = sub_10014387C();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 16LL);

    if (IsLevelEnabled)
    {
      id v8 = sub_10014387C();
      _NRLogWithArgs(v8, 16LL, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRDKeyManager initInternal]", 78);
    }

    uint64_t v9 = _os_log_pack_size(12LL);
    id v10 = (char *)&v14 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v11 = __error();
    uint64_t v12 = _os_log_pack_fill(v10, v9, *v11, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)uint64_t v12 = 136446210;
    *(void *)(v12 + 4) = "-[NRDKeyManager initInternal]";
    id v13 = sub_10014387C();
    _NRLogAbortWithPack(v13, v10);
    return 0LL;
  }

  uint64_t v2 = v1;
  id v3 = sub_100146AFC();
  id v4 = (void *)v2[2];
  v2[2] = v3;

  *((_DWORD *)v2 + 3) = -1;
  *((_BYTE *)v2 + _Block_object_dispose(va, 8) = 4;
  return v2;
}

id sub_10014387C()
{
  if (qword_1001DCC28 != -1) {
    dispatch_once(&qword_1001DCC28, &stru_1001B0980);
  }
  return (id)qword_1001DCC20;
}

void sub_1001438BC(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DCC20;
  qword_1001DCC20 = (uint64_t)v1;
}

id sub_1001438EC(uint64_t a1)
{
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  return (id)qword_1001DCC10;
}

void sub_100143930(id a1)
{
  os_log_t v1 = sub_100143718(objc_alloc(&OBJC_CLASS___NRDKeyManager));
  uint64_t v2 = (void *)qword_1001DCC10;
  qword_1001DCC10 = (uint64_t)v1;
}

void sub_10014395C(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 12) == -1)
  {
    objc_initWeak(&location, (id)a1);
    uint64_t v2 = *(dispatch_queue_s **)(a1 + 16);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_100143B8C;
    handler[3] = &unk_1001B0938;
    objc_copyWeak(&v10, &location);
    uint32_t v3 = notify_register_dispatch("com.apple.mobile.keybagd.lock_status", (int *)(a1 + 12), v2, handler);
    if (v3)
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      id v4 = (id)qword_1001DCC20;
      char IsLevelEnabled = _NRLogIsLevelEnabled(v4, 17LL);

      if ((IsLevelEnabled & 1) == 0) {
        goto LABEL_16;
      }
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      id v6 = (id)qword_1001DCC20;
      _NRLogWithArgs(v6, 17LL, "Failed to register for lock state notifications %u", v3);
    }

    else
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      id v7 = (id)qword_1001DCC20;
      int v8 = _NRLogIsLevelEnabled(v7, 0LL);

      if (!v8) {
        goto LABEL_16;
      }
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      id v6 = (id)qword_1001DCC20;
      _NRLogWithArgs( v6,  0LL,  "%s%.30s:%-4d Registered for lock state notifications",  "",  "-[NRDKeyManager startWatchingLockState]",  315);
    }

LABEL_16:
    sub_100143BB8(a1);
    objc_destroyWeak(&v10);
    objc_destroyWeak(&location);
  }

void sub_100143B6C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
}

void sub_100143B8C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  sub_100143BB8((uint64_t)WeakRetained);
}

void sub_100143BB8(uint64_t a1)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
    unsigned __int8 v2 = 1;
    *(_BYTE *)(a1 + 10) = 1;
    uint64_t v3 = MKBGetDeviceLockState(0LL);
    if ((_DWORD)v3)
    {
      sub_100143DD4(a1);
      if (*(_BYTE *)(a1 + 9)) {
        unsigned __int8 v2 = 3;
      }
      else {
        unsigned __int8 v2 = 4;
      }
    }

    else
    {
      *(_BYTE *)(a1 + 9) = 1;
    }

    uint64_t v4 = *(unsigned __int8 *)(a1 + 8);
    if ((_DWORD)v4 == v2)
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
      {
        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        id v16 = (id)qword_1001DCC20;
        id String = (void *)NRDataProtectionClassCreateString(*(unsigned __int8 *)(a1 + 8));
        if (v3 >= 8) {
          id v6 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown[%d]",  v3);
        }
        else {
          id v6 = (NSString *)*(&off_1001B09A0 + v3);
        }
        _NRLogWithArgs( v16,  0LL,  "%s%.30s:%-4d Keeping lock state %@ in response to %@",  "",  "-[NRDKeyManager handleLockStateChange]",  297LL,  String,  v6);
      }
    }

    else
    {
      id v7 = (void *)NRDataProtectionClassCreateString(v4);
      int v8 = (NSString *)NRDataProtectionClassCreateString(v2);
      uint64_t v14 = v8;
      if (v3 >= 8)
      {
        int v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown[%d]",  v3);
        objc_super v15 = v8;
      }

      else
      {
        objc_super v15 = (NSString *)*(&off_1001B09A0 + v3);
      }

      sub_100143FC8((uint64_t)v8, 5400, @"%@ -> %@ (%@)", v9, v10, v11, v12, v13, (uint64_t)v7);

      *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = v2;
      sub_100144044(a1);
    }
  }

void sub_100143DD4(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 9))
  {
    int v2 = MKBDeviceUnlockedSinceBoot();
    if (v2)
    {
      int v3 = v2;
      if (v2 == 1)
      {
        *(_BYTE *)(a1 + 9) = 1;
      }

      else
      {
        uint64_t v4 = __error();
        int v5 = *v4;
        if (*v4 == 3)
        {
          if (strerror_r(3, __strerrbuf, 0x80uLL)) {
            __strerrbuf[0] = 0;
          }
          if (qword_1001DCC28 != -1) {
            dispatch_once(&qword_1001DCC28, &stru_1001B0980);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCC20, 16LL))
          {
            if (qword_1001DCC28 != -1) {
              dispatch_once(&qword_1001DCC28, &stru_1001B0980);
            }
            id v6 = (id)qword_1001DCC20;
            _NRLogWithArgs( v6,  16LL,  "%s%.30s:%-4d MKBDeviceUnlockedSinceBoot() returned %d: [%d] %s",  "",  "-[NRDKeyManager checkIfDeviceHasBeenUnlockedOnceSinceBoot]",  263,  v3,  3,  __strerrbuf);
          }
        }

        else
        {
          if (strerror_r(*v4, __strerrbuf, 0x80uLL)) {
            __strerrbuf[0] = 0;
          }
          if (qword_1001DCC28 != -1) {
            dispatch_once(&qword_1001DCC28, &stru_1001B0980);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCC20, 17LL))
          {
            if (qword_1001DCC28 != -1) {
              dispatch_once(&qword_1001DCC28, &stru_1001B0980);
            }
            _NRLogWithArgs( qword_1001DCC20,  17LL,  "MKBDeviceUnlockedSinceBoot() returned %d: [%d] %s",  v3,  v5,  __strerrbuf);
          }
        }
      }
    }
  }

void sub_100143FC8( uint64_t a1, int a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v10 = a3;
  uint64_t v11 = -[NSString initWithFormat:arguments:](objc_alloc(&OBJC_CLASS___NSString), "initWithFormat:arguments:", v10, &a9);

  sub_10011BB18(0LL, a2, &stru_1001B1528, v11);
}

void sub_100144044(uint64_t a1)
{
  uint64_t v2 = *(unsigned __int8 *)(a1 + 8);
  if ((v2 | 2) != 3 || (uint64_t v3 = *(void *)(a1 + 32)) == 0)
  {
    int v5 = 0;
    uint64_t v6 = *(void *)(a1 + 24);
    if (!v6) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }

  (*(void (**)(void))(v3 + 16))();
  uint64_t v4 = *(void **)(a1 + 32);
  *(void *)(a1 + 32) = 0LL;

  uint64_t v2 = *(unsigned __int8 *)(a1 + 8);
  int v5 = 1;
  uint64_t v6 = *(void *)(a1 + 24);
  if (v6)
  {
LABEL_6:
    (*(void (**)(uint64_t, uint64_t))(v6 + 16))(v6, v2);
    LODWORD(v2) = *(unsigned __int8 *)(a1 + 8);
  }

uint64_t sub_1001442B0(uint64_t a1)
{
  uint64_t result = *(unsigned int *)(a1 + 12);
  if ((_DWORD)result != -1)
  {
    uint32_t v3 = notify_cancel(result);
    *(_DWORD *)(a1 + 12) = -1;
    if (v3)
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      uint64_t result = _NRLogIsLevelEnabled(qword_1001DCC20, 17LL);
      if ((_DWORD)result)
      {
        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        return _NRLogWithArgs(qword_1001DCC20, 17LL, "Failed to unregister for lock state notifications %u");
      }
    }

    else
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      uint64_t result = _NRLogIsLevelEnabled(qword_1001DCC20, 0LL);
      if ((_DWORD)result)
      {
        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        return _NRLogWithArgs(qword_1001DCC20, 0LL, "%s%.30s:%-4d Unregistered for lock state notifications");
      }
    }
  }

  return result;
}

BOOL sub_100144404(BOOL result)
{
  if (result)
  {
    os_log_t v1 = (_BYTE *)result;
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(result + 16));
    if (!v1[10])
    {
      v1[10] = 1;
      if (v1[8] == 4)
      {
        sub_100143DD4((uint64_t)v1);
        if (v1[9])
        {
          v1[8] = 3;
          sub_100144044((uint64_t)v1);
        }
      }
    }

    return (v1[8] & 0xFD) == 1;
  }

  return result;
}

void sub_100144478(uint64_t a1, void *a2)
{
  __int128 v19 = a2;
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
    if (v19)
    {
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
      if (!*(_BYTE *)(a1 + 10))
      {
        *(_BYTE *)(a1 + 10) = 1;
        if (*(_BYTE *)(a1 + 8) == 4)
        {
          sub_100143DD4(a1);
          if (*(_BYTE *)(a1 + 9))
          {
            *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = 3;
            sub_100144044(a1);
          }
        }
      }

      uint32_t v3 = v19;
      if ((*(_BYTE *)(a1 + 8) & 0xFD) == 1)
      {
        v19[2]();
      }

      else
      {
        uint64_t v4 = *(void **)(a1 + 40);
        if (!v4)
        {
          int v5 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
          uint64_t v6 = *(void **)(a1 + 40);
          *(void *)(a1 + 40) = v5;

          uint32_t v3 = v19;
          uint64_t v4 = *(void **)(a1 + 40);
          if (!v4)
          {
            id v11 = sub_10014387C();
            int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 16LL);

            if (IsLevelEnabled)
            {
              id v13 = sub_10014387C();
              _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (_classCUnlockedBlocks) != ((void *)0)",  "",  "-[NRDKeyManager runAfterClassCUnlock:]",  150);
            }

            uint64_t v14 = _os_log_pack_size(12LL);
            id v15 = (char *)&v19 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
            id v16 = __error();
            uint64_t v17 = _os_log_pack_fill( v15,  v14,  *v16,  &_mh_execute_header,  "%{public}s Assertion Failed: (_classCUnlockedBlocks) != ((void *)0)");
            *(_DWORD *)uint64_t v17 = 136446210;
            *(void *)(v17 + 4) = "-[NRDKeyManager runAfterClassCUnlock:]";
            id v18 = sub_10014387C();
            _NRLogAbortWithPack(v18, v15);
          }
        }

        id v7 = objc_retainBlock(v3);
        [v4 addObject:v7];

        sub_10014395C(a1);
      }
    }

    else
    {
      id v8 = sub_10014387C();
      int v9 = _NRLogIsLevelEnabled(v8, 17LL);

      if (v9)
      {
        id v10 = sub_10014387C();
        _NRLogWithArgs(v10, 17LL, "%s called with null classCUnlockedBlock", "-[NRDKeyManager runAfterClassCUnlock:]");
      }
    }
  }
}

void sub_1001446A8(uint64_t a1, void *a2)
{
  uint32_t v3 = a2;
  if (!a1) {
    goto LABEL_12;
  }
  __int128 v19 = v3;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
  if (!v19)
  {
    id v6 = sub_10014387C();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 17LL);

    uint32_t v3 = 0LL;
    if (!IsLevelEnabled) {
      goto LABEL_12;
    }
    id v8 = sub_10014387C();
    _NRLogWithArgs( v8,  17LL,  "%s called with null localDeviceClassCUnlockedBlock",  "-[NRDKeyManager runForLocalDeviceAfterClassCUnlock:]");

LABEL_11:
    uint32_t v3 = v19;
LABEL_12:

    return;
  }

  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
  if (!*(_BYTE *)(a1 + 10))
  {
    *(_BYTE *)(a1 + 10) = 1;
    if (*(_BYTE *)(a1 + 8) == 4)
    {
      sub_100143DD4(a1);
      if (*(_BYTE *)(a1 + 9))
      {
        *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = 3;
        sub_100144044(a1);
      }
    }
  }

  if ((*(_BYTE *)(a1 + 8) & 0xFD) == 1)
  {
    v19[2]();
    goto LABEL_11;
  }

  if (!*(void *)(a1 + 32))
  {
    uint64_t v4 = objc_retainBlock(v19);
    int v5 = *(void **)(a1 + 32);
    *(void *)(a1 + 32) = v4;

    goto LABEL_11;
  }

  id v9 = sub_10014387C();
  int v10 = _NRLogIsLevelEnabled(v9, 16LL);

  if (v10)
  {
    id v11 = sub_10014387C();
    _NRLogWithArgs( v11,  16LL,  "%s%.30s:%-4d ABORTING: Tried to register a second local device class C unlocked block",  "",  "-[NRDKeyManager runForLocalDeviceAfterClassCUnlock:]",  166);
  }

  uint64_t v12 = _os_log_pack_size(12LL);
  id v13 = (char *)&v19 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v14 = __error();
  uint64_t v15 = _os_log_pack_fill( v13,  v12,  *v14,  &_mh_execute_header,  "%{public}s Tried to register a second local device class C unlocked block");
  *(_DWORD *)uint64_t v15 = 136446210;
  *(void *)(v15 + 4) = "-[NRDKeyManager runForLocalDeviceAfterClassCUnlock:]";
  id v16 = sub_10014387C();
  uint64_t v17 = _NRLogAbortWithPack(v16, v13);
  sub_1001448A8(v17, v18);
}

void sub_1001448A8(uint64_t a1, void *a2)
{
  id v19 = a2;
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
    id v3 = v19;
    if (v19)
    {
      uint64_t v4 = *(void **)(a1 + 48);
      if (!v4)
      {
        int v5 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        id v6 = *(void **)(a1 + 48);
        *(void *)(a1 + 4_Block_object_dispose(va, 8) = v5;

        id v3 = v19;
        uint64_t v4 = *(void **)(a1 + 48);
        if (!v4)
        {
          id v11 = sub_10014387C();
          int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 16LL);

          if (IsLevelEnabled)
          {
            id v13 = sub_10014387C();
            _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (_classAUnlockedBlocks) != ((void *)0)",  "",  "-[NRDKeyManager runAfterNextClassAUnlock:]",  191);
          }

          uint64_t v14 = _os_log_pack_size(12LL);
          uint64_t v15 = (char *)&v19 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
          id v16 = __error();
          uint64_t v17 = _os_log_pack_fill( v15,  v14,  *v16,  &_mh_execute_header,  "%{public}s Assertion Failed: (_classAUnlockedBlocks) != ((void *)0)");
          *(_DWORD *)uint64_t v17 = 136446210;
          *(void *)(v17 + 4) = "-[NRDKeyManager runAfterNextClassAUnlock:]";
          id v18 = sub_10014387C();
          _NRLogAbortWithPack(v18, v15);
        }
      }

      id v7 = objc_retainBlock(v3);
      [v4 addObject:v7];

      sub_10014395C(a1);
    }

    else
    {
      id v8 = sub_10014387C();
      int v9 = _NRLogIsLevelEnabled(v8, 17LL);

      if (v9)
      {
        id v10 = sub_10014387C();
        _NRLogWithArgs( v10,  17LL,  "%s called with null classAUnlockedBlock",  "-[NRDKeyManager runAfterNextClassAUnlock:]");
      }
    }
  }
}

void sub_100144A74(uint64_t a1)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      _NRLogWithArgs( qword_1001DCC20,  0LL,  "%s%.30s:%-4d Deleting local identity %@",  "",  "-[NRDKeyManager deleteEphemeralLocalIdentityFromKeychain]",  415LL,  @"local-identity");
    }

    v3[0] = kSecClass;
    v3[1] = kSecAttrLabel;
    v4[0] = kSecClassIdentity;
    v4[1] = @"local-identity";
    v3[2] = kSecAttrAccessGroup;
    v3[3] = kSecAttrAccessible;
    void v4[2] = @"com.apple.terminusd.local-identity";
    v4[3] = kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate;
    os_log_t v1 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v4,  v3,  4LL));
    OSStatus v2 = SecItemDelete(v1);
    if (v2 == -25308)
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCC20, 16LL))
      {
        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        _NRLogWithArgs(qword_1001DCC20, 16LL, "%s%.30s:%-4d Failed to delete local identity: keychain locked");
      }
    }

    else if (v2 == -25300)
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
      {
        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        _NRLogWithArgs( qword_1001DCC20,  0LL,  "%s%.30s:%-4d Failed to delete local identity: item not found (not an error)");
      }
    }

    else if (v2)
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCC20, 17LL))
      {
        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        _NRLogWithArgs(qword_1001DCC20, 17LL, "Failed to delete local identity: %d");
      }
    }

    else
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
      {
        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        _NRLogWithArgs(qword_1001DCC20, 0LL, "%s%.30s:%-4d Successfully deleted local identity");
      }
    }
  }

uint64_t sub_100144E1C(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v7 = a2;
  id v8 = a3;
  if (!a1) {
    goto LABEL_59;
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
  if (!v7)
  {
    id v24 = sub_10014387C();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v24, 17LL);

    if (IsLevelEnabled)
    {
      id v26 = sub_10014387C();
      _NRLogWithArgs( v26,  17LL,  "%s called with null itemName",  "-[NRDKeyManager deleteKeyfromKeychainWithName:nrUUID:dataProtectionClass:]");

      uint64_t v22 = 0LL;
      goto LABEL_56;
    }

BOOL sub_100145390(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5, _BYTE *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  if (!a1) {
    goto LABEL_90;
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
  if (!v11)
  {
    id v40 = sub_10014387C();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v40, 17LL);

    if (IsLevelEnabled)
    {
      id v42 = sub_10014387C();
      _NRLogWithArgs(v42, 17LL, "%s called with null itemData");
LABEL_89:

      BOOL v38 = 0LL;
      goto LABEL_84;
    }

LABEL_90:
    BOOL v38 = 0LL;
    goto LABEL_84;
  }

  uint64_t v14 = objc_opt_class(&OBJC_CLASS___NSData);
  if ((objc_opt_isKindOfClass(v11, v14) & 1) == 0)
  {
    id v43 = sub_10014387C();
    int v44 = _NRLogIsLevelEnabled(v43, 17LL);

    if (v44)
    {
      id v42 = sub_10014387C();
      _NRLogWithArgs(v42, 17LL, "%s called with null [itemData isKindOfClass:[NSData class]]");
      goto LABEL_89;
    }

    goto LABEL_90;
  }

  if (a6) {
    *a6 = 0;
  }
  if ((_DWORD)a5 == 3)
  {
    int v15 = &kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly;
  }

  else
  {
    if ((_DWORD)a5 != 4)
    {
      id String = (void *)NRDataProtectionClassCreateString(a5);
      goto LABEL_30;
    }

    int v15 = (const CFStringRef *)&kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate;
  }

  CFStringRef v16 = *v15;
  id String = (void *)NRDataProtectionClassCreateString(a5);
  CFStringRef v49 = v16;
  if (!v16)
  {
LABEL_30:
    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    id v28 = (id)qword_1001DCC20;
    int v29 = _NRLogIsLevelEnabled(v28, 17LL);

    if (v29)
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      id v30 = (id)qword_1001DCC20;
      _NRLogWithArgs(v30, 17LL, "Cannot save item %@ to keychain for %@", v12, String);
    }

    BOOL v51 = 0;
    goto LABEL_83;
  }

  __int128 v47 = a6;
  id v18 = (NSString *)v12;
  if (v13)
  {
    id v19 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%@/%@/%@",  v13,  String,  v18);

    id v18 = v19;
  }

  if (qword_1001DCC28 != -1) {
    dispatch_once(&qword_1001DCC28, &stru_1001B0980);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
  {
    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    id v20 = (id)qword_1001DCC20;
    _NRLogWithArgs( v20,  0,  "%s%.30s:%-4d Updating %@ keychain item %@ length %llu",  "",  "-[NRDKeyManager saveData:toKeychainWithName:nrUUID:dataProtectionClass:keychainLocked:]",  650,  String,  v18,  [v11 length]);
  }

  v56[0] = kSecClass;
  v56[1] = kSecAttrService;
  v57[0] = kSecClassGenericPassword;
  v57[1] = @"com.apple.terminusd";
  v56[2] = kSecAttrAccount;
  v56[3] = kSecAttrAccessGroup;
  v57[2] = v18;
  v57[3] = @"com.apple.terminusd";
  uint64_t v21 = objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v57,  v56,  4LL));
  v54[0] = kSecAttrAccessible;
  v54[1] = kSecValueData;
  v55[0] = v16;
  v55[1] = v11;
  id v50 = v11;
  uint64_t v22 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v55,  v54,  2LL));
  __int128 v48 = (void *)v21;
  id v23 = (const __CFDictionary *)v21;
  id v24 = v22;
  uint64_t v25 = SecItemUpdate(v23, v22);
  if ((_DWORD)v25 == -25308)
  {
    if (v47) {
      *__int128 v47 = 1;
    }
    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    uint64_t v27 = v48;
    if (_NRLogIsLevelEnabled(qword_1001DCC20, 16LL))
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      _NRLogWithArgs( qword_1001DCC20,  16LL,  "%s%.30s:%-4d Failed to update %@ keychain item %@: keychain locked",  "",  "-[NRDKeyManager saveData:toKeychainWithName:nrUUID:dataProtectionClass:keychainLocked:]",  676LL,  String,  v18);
    }
  }

  else
  {
    uint64_t v26 = v25;
    if ((_DWORD)v25 == -25300)
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      unsigned __int8 v31 = v50;
      if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
      {
        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        id v32 = (id)qword_1001DCC20;
        unsigned __int8 v31 = v50;
        _NRLogWithArgs( v32,  0,  "%s%.30s:%-4d Adding %@ keychain item %@ length %llu",  "",  "-[NRDKeyManager saveData:toKeychainWithName:nrUUID:dataProtectionClass:keychainLocked:]",  687,  String,  v18,  [v50 length]);
      }

      v52[0] = kSecClass;
      v52[1] = kSecAttrService;
      v53[0] = kSecClassGenericPassword;
      v53[1] = @"com.apple.terminusd";
      v52[2] = kSecAttrAccount;
      v52[3] = kSecAttrAccessGroup;
      void v53[2] = v18;
      v53[3] = @"com.apple.terminusd";
      v52[4] = kSecAttrAccessible;
      void v52[5] = kSecValueData;
      void v53[4] = v49;
      void v53[5] = v31;
      uint64_t v33 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v53,  v52,  6LL));
      uint64_t v34 = SecItemAdd(v33, 0LL);
      uint64_t v35 = v34;
      if ((_DWORD)v34)
      {
        uint64_t v27 = v48;
        if ((_DWORD)v34 == -25308)
        {
          if (v47) {
            *__int128 v47 = 1;
          }
          if (qword_1001DCC28 != -1) {
            dispatch_once(&qword_1001DCC28, &stru_1001B0980);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCC20, 16LL))
          {
            if (qword_1001DCC28 != -1) {
              dispatch_once(&qword_1001DCC28, &stru_1001B0980);
            }
            _NRLogWithArgs( qword_1001DCC20,  16LL,  "%s%.30s:%-4d Failed to add %@ keychain item %@: keychain locked",  "",  "-[NRDKeyManager saveData:toKeychainWithName:nrUUID:dataProtectionClass:keychainLocked:]",  710LL,  String,  v18);
          }
        }

        else
        {
          if (qword_1001DCC28 != -1) {
            dispatch_once(&qword_1001DCC28, &stru_1001B0980);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCC20, 17LL))
          {
            if (qword_1001DCC28 != -1) {
              dispatch_once(&qword_1001DCC28, &stru_1001B0980);
            }
            _NRLogWithArgs(qword_1001DCC20, 17LL, "Failed to add %@ keychain item %@: %d", String, v18, v35, v45, v46);
          }
        }
      }

      else
      {
        uint64_t v27 = v48;
        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
        {
          __int128 v36 = v24;
          if (qword_1001DCC28 != -1) {
            dispatch_once(&qword_1001DCC28, &stru_1001B0980);
          }
          id v37 = (id)qword_1001DCC20;
          _NRLogWithArgs( v37,  0,  "%s%.30s:%-4d Successfully added %@ keychain item %@ length %llu",  "",  "-[NRDKeyManager saveData:toKeychainWithName:nrUUID:dataProtectionClass:keychainLocked:]",  703,  String,  v18,  [v50 length]);

          id v24 = v36;
        }
      }

      BOOL v51 = (_DWORD)v35 == 0;

      goto LABEL_81;
    }

    if (!(_DWORD)v25)
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      id v11 = v50;
      uint64_t v27 = v48;
      if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
      {
        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        _NRLogWithArgs( qword_1001DCC20,  0LL,  "%s%.30s:%-4d Successfully updated %@ keychain item %@",  "",  "-[NRDKeyManager saveData:toKeychainWithName:nrUUID:dataProtectionClass:keychainLocked:]",  668LL,  String,  v18);
      }

      BOOL v51 = 1;
      goto LABEL_82;
    }

    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    uint64_t v27 = v48;
    if (_NRLogIsLevelEnabled(qword_1001DCC20, 17LL))
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      _NRLogWithArgs(qword_1001DCC20, 17LL, "Failed to update %@ keychain item %@: %d", String, v18, v26, v45, v46);
    }
  }

  BOOL v51 = 0;
LABEL_81:
  id v11 = v50;
LABEL_82:

LABEL_83:
  BOOL v38 = v51;
LABEL_84:

  return v38;
}

id sub_100145CF4(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v7 = a2;
  id v8 = a3;
  if (!a1)
  {
    id v19 = 0LL;
    goto LABEL_61;
  }

  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
  if ((_DWORD)a4 == 3)
  {
    int v9 = &kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly;
  }

  else
  {
    if ((_DWORD)a4 != 4)
    {
      id String = (char *)NRDataProtectionClassCreateString(a4);
      goto LABEL_37;
    }

    int v9 = (const CFStringRef *)&kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate;
  }

  CFStringRef v10 = *v9;
  id String = (char *)NRDataProtectionClassCreateString(a4);
  if (!v10)
  {
LABEL_37:
    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    id v22 = (id)qword_1001DCC20;
    int IsLevelEnabled = _NRLogIsLevelEnabled(v22, 17LL);

    if (IsLevelEnabled)
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      id v24 = (id)qword_1001DCC20;
      _NRLogWithArgs(v24, 17LL, "Cannot save item %@ to keychain for %@", v7, String);
    }

    id v19 = 0LL;
    goto LABEL_60;
  }

  id v12 = (NSString *)v7;
  if (v8)
  {
    id v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%@/%@/%@",  v8,  String,  v12);

    id v12 = v13;
  }

  if (qword_1001DCC28 != -1) {
    dispatch_once(&qword_1001DCC28, &stru_1001B0980);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
  {
    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    _NRLogWithArgs( qword_1001DCC20,  0LL,  "%s%.30s:%-4d Reading %@ keychain item %@",  "",  "-[NRDKeyManager readDataFromKeychainWithName:nrUUID:dataProtectionClass:keychainLocked:]",  738LL,  String,  v12);
  }

  v39[0] = kSecClass;
  v39[1] = kSecAttrService;
  v40[0] = kSecClassGenericPassword;
  v40[1] = @"com.apple.terminusd";
  v39[2] = kSecAttrAccount;
  void v39[3] = kSecAttrAccessGroup;
  v40[2] = v12;
  v40[3] = @"com.apple.terminusd";
  void v39[4] = kSecReturnData;
  void v40[4] = &__kCFBooleanTrue;
  uint64_t v14 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v40,  v39,  5LL));
  CFTypeRef result = 0LL;
  uint64_t v15 = SecItemCopyMatching(v14, &result);
  CFStringRef v16 = (void *)result;
  if (!(_DWORD)v15 && result)
  {
    CFTypeRef result = 0LL;
    uint64_t v17 = objc_opt_class(&OBJC_CLASS___NSData);
    if ((objc_opt_isKindOfClass(v16, v17) & 1) != 0)
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
      {
        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        id v18 = (id)qword_1001DCC20;
        _NRLogWithArgs( v18,  0,  "%s%.30s:%-4d Successfully read %@ keychain item %@ length %llu",  "",  "-[NRDKeyManager readDataFromKeychainWithName:nrUUID:dataProtectionClass:keychainLocked:]",  776,  String,  v12,  [v16 length]);
      }

      id v19 = v16;
    }

    else
    {
      id v27 = sub_10014387C();
      int v28 = _NRLogIsLevelEnabled(v27, 17LL);

      if (v28)
      {
        id v29 = sub_10014387C();
        id v30 = (objc_class *)objc_opt_class(v16);
        unsigned __int8 v31 = NSStringFromClass(v30);
        id v32 = (void *)objc_claimAutoreleasedReturnValue(v31);
        _NRLogWithArgs(v29, 17LL, "Read %@ keychain item %@ with bad class %@", String, v12, v32);
      }

      id v19 = 0LL;
    }

    goto LABEL_59;
  }

  if (result)
  {
    CFRelease(result);
    CFTypeRef result = 0LL;
  }

  if ((_DWORD)v15 == -25308)
  {
    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    uint64_t v20 = qword_1001DCC20;
    __int128 v36 = String;
    id v37 = v12;
    uint64_t v35 = 759LL;
    uint64_t v33 = "";
    uint64_t v34 = "-[NRDKeyManager readDataFromKeychainWithName:nrUUID:dataProtectionClass:keychainLocked:]";
    uint64_t v21 = "%s%.30s:%-4d Failed to read %@ keychain item %@: keychain locked";
  }

  else
  {
    if ((_DWORD)v15 != -25300)
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      uint64_t v20 = qword_1001DCC20;
      uint64_t v34 = (const char *)v12;
      uint64_t v35 = v15;
      uint64_t v33 = String;
      uint64_t v21 = "Failed to read %@ keychain item %@: %d";
      uint64_t v25 = 17LL;
      goto LABEL_57;
    }

    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    uint64_t v20 = qword_1001DCC20;
    __int128 v36 = String;
    id v37 = v12;
    uint64_t v35 = 754LL;
    uint64_t v33 = "";
    uint64_t v34 = "-[NRDKeyManager readDataFromKeychainWithName:nrUUID:dataProtectionClass:keychainLocked:]";
    uint64_t v21 = "%s%.30s:%-4d Failed to read %@ keychain item %@: not found";
  }

  uint64_t v25 = 16LL;
LABEL_57:
  _NRLogWithArgs(v20, v25, v21, v33, v34, v35, v36, v37);
LABEL_58:
  id v19 = 0LL;
LABEL_59:

LABEL_60:
LABEL_61:

  return v19;
}

uint64_t sub_1001462F4(uint64_t a1, void *a2, void *a3, uint64_t a4, _BYTE *a5)
{
  id v9 = a2;
  id v10 = a3;
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
    if (v9)
    {
      if (a5) {
        *a5 = 0;
      }
      switch((_DWORD)a4)
      {
        case 1:
          id v11 = &kSecAttrAccessibleWhenUnlockedThisDeviceOnly;
          break;
        case 3:
          id v11 = &kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly;
          break;
        case 4:
          id v11 = (const CFStringRef *)&kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate;
          break;
        default:
          id String = (void *)NRDataProtectionClassCreateString(a4);
          goto LABEL_30;
      }

      CFStringRef v12 = *v11;
      id String = (void *)NRDataProtectionClassCreateString(a4);
      if (v12)
      {
        uint64_t v14 = (NSString *)v9;
        if (v10)
        {
          uint64_t v15 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%@/%@/%@",  v10,  String,  v14);

          uint64_t v14 = v15;
        }

        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
        {
          if (qword_1001DCC28 != -1) {
            dispatch_once(&qword_1001DCC28, &stru_1001B0980);
          }
          id v16 = (id)qword_1001DCC20;
          uint64_t v17 = (void *)NRDataProtectionClassCreateString(a4);
          _NRLogWithArgs( v16,  0LL,  "%s%.30s:%-4d Deleting %@ keychain item %@",  "",  "-[NRDKeyManager deleteDataFromKeychainWithName:nrUUID:dataProtectionClass:keychainLocked:]",  802LL,  v17,  v14);
        }

        v31[0] = kSecClass;
        v31[1] = kSecAttrService;
        v32[0] = kSecClassGenericPassword;
        v32[1] = @"com.apple.terminusd";
        v31[2] = kSecAttrAccount;
        v31[3] = kSecAttrAccessGroup;
        void v32[2] = v14;
        void v32[3] = @"com.apple.terminusd";
        id v18 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v32,  v31,  4LL));
        uint64_t v19 = SecItemDelete(v18);
        if ((_DWORD)v19 == -25308)
        {
          if (a5) {
            *a5 = 1;
          }
          if (qword_1001DCC28 != -1) {
            dispatch_once(&qword_1001DCC28, &stru_1001B0980);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCC20, 16LL))
          {
            if (qword_1001DCC28 != -1) {
              dispatch_once(&qword_1001DCC28, &stru_1001B0980);
            }
            _NRLogWithArgs( qword_1001DCC20,  16LL,  "%s%.30s:%-4d Failed to delete %@ keychain item %@: keychain locked",  "",  "-[NRDKeyManager deleteDataFromKeychainWithName:nrUUID:dataProtectionClass:keychainLocked:]",  825LL,  String,  v14);
          }
        }

        else
        {
          uint64_t v20 = v19;
          if ((_DWORD)v19 == -25300)
          {
            if (qword_1001DCC28 != -1) {
              dispatch_once(&qword_1001DCC28, &stru_1001B0980);
            }
            if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
            {
              if (qword_1001DCC28 != -1) {
                dispatch_once(&qword_1001DCC28, &stru_1001B0980);
              }
              _NRLogWithArgs( qword_1001DCC20,  0LL,  "%s%.30s:%-4d Failed to delete %@ keychain item %@: item not found (not an error)",  "",  "-[NRDKeyManager deleteDataFromKeychainWithName:nrUUID:dataProtectionClass:keychainLocked:]",  819LL,  String,  v14);
            }

            goto LABEL_51;
          }

          if (!(_DWORD)v19)
          {
            if (qword_1001DCC28 != -1) {
              dispatch_once(&qword_1001DCC28, &stru_1001B0980);
            }
            if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
            {
              if (qword_1001DCC28 != -1) {
                dispatch_once(&qword_1001DCC28, &stru_1001B0980);
              }
              _NRLogWithArgs( qword_1001DCC20,  0LL,  "%s%.30s:%-4d Successfully deleted %@ keychain item %@",  "",  "-[NRDKeyManager deleteDataFromKeychainWithName:nrUUID:dataProtectionClass:keychainLocked:]",  815LL,  String,  v14);
            }

NSMutableDictionary *sub_1001468B0(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v7 = a3;
  if (!a1) {
    goto LABEL_24;
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
  if (!a2)
  {
    id v18 = sub_10014387C();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 17LL);

    if (IsLevelEnabled)
    {
      id v20 = sub_10014387C();
      _NRLogWithArgs(v20, 17LL, "%s called with null classInDict");
LABEL_23:

      uint64_t v14 = 0LL;
      goto LABEL_18;
    }

__objc2_meth_list *sub_100146AFC()
{
  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  os_log_t v1 = (__objc2_meth_list *)qword_1001DCC38;
  if (!qword_1001DCC38)
  {
    os_log_t v1 = (__objc2_meth_list *)qword_1001DCC40;
    if (!qword_1001DCC40)
    {
      pthread_attr_init(&v13);
      pthread_attr_getschedparam(&v13, &v12);
      v12.sched_priority = 37;
      pthread_attr_setschedparam(&v13, &v12);
      pthread_attr_setschedpolicy(&v13, 4);
      uint64_t v2 = dispatch_pthread_root_queue_create(0LL, 0LL, &v13, &stru_1001B09E0);
      id v3 = (void *)qword_1001DCC40;
      qword_1001DCC40 = v2;

      if (qword_1001DCC40)
      {
        if (qword_1001DCC30 == -1)
        {
LABEL_5:
          os_log_t v1 = p_class_meths[391];
          return v1;
        }
      }

      else
      {
        id v5 = sub_100146CC0();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16LL);

        if (IsLevelEnabled)
        {
          id v7 = sub_100146CC0();
          _NRLogWithArgs( v7,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (terminusRootQueue) != ((void *)0)",  "",  "NRCopyTerminusdQueue",  92);
        }

        p_class_meths = (__objc2_meth_list **)_os_log_pack_size(12LL);
        id v8 = (char *)&v12 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        id v9 = __error();
        uint64_t v10 = _os_log_pack_fill( v8,  p_class_meths,  *v9,  &_mh_execute_header,  "%{public}s Assertion Failed: (terminusRootQueue) != ((void *)0)");
        *(_DWORD *)uint64_t v10 = 136446210;
        *(void *)(v10 + 4) = "NRCopyTerminusdQueue";
        id v11 = sub_100146CC0();
        _NRLogAbortWithPack(v11, v8);
      }

      dispatch_once(&qword_1001DCC30, &stru_1001B0A00);
      goto LABEL_5;
    }
  }

  return v1;
}

id sub_100146CC0()
{
  if (qword_1001DCC50 != -1) {
    dispatch_once(&qword_1001DCC50, &stru_1001B0A60);
  }
  return (id)qword_1001DCC48;
}

void sub_100146D00(id a1)
{
  os_log_t v1 = (dispatch_queue_s *)(id)qword_1001DCC40;
  if (!v1)
  {
    id v7 = sub_100146CC0();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 16LL);

    if (IsLevelEnabled)
    {
      id v9 = sub_100146CC0();
      _NRLogWithArgs( v9,  16LL,  "%s%.30s:%-4d ABORTING: nr_dispatch_queue_create_with_target called with NULL target",  "",  "nr_dispatch_queue_create_with_target",  164);
    }

    uint64_t v4 = (const char *)_os_log_pack_size(12LL);
    uint64_t v10 = (char *)&v22 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v11 = __error();
    uint64_t v12 = _os_log_pack_fill( v10,  v4,  *v11,  &_mh_execute_header,  "%{public}s nr_dispatch_queue_create_with_target called with NULL target");
    *(_DWORD *)uint64_t v12 = 136446210;
    *(void *)(v12 + 4) = "nr_dispatch_queue_create_with_target";
    id v13 = sub_100146CC0();
    _NRLogAbortWithPack(v13, v10);
LABEL_7:
    id v14 = sub_100146CC0();
    int v15 = _NRLogIsLevelEnabled(v14, 16LL);

    if (v15)
    {
      id v16 = sub_100146CC0();
      _NRLogWithArgs( v16,  16LL,  "%s%.30s:%-4d ABORTING: dispatch_queue_create_with_target(%s) failed",  "",  "nr_dispatch_queue_create_with_target",  168,  v4);
    }

    uint64_t v17 = _os_log_pack_size(22LL);
    id v18 = (char *)&v22 - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v19 = __error();
    uint64_t v20 = _os_log_pack_fill( v18,  v17,  *v19,  &_mh_execute_header,  "%{public}s dispatch_queue_create_with_target(%s) failed");
    *(_DWORD *)uint64_t v20 = 136446466;
    *(void *)(v20 + 4) = "nr_dispatch_queue_create_with_target";
    *(_WORD *)(v20 + 12) = 2080;
    *(void *)(v20 + 14) = v4;
    id v21 = sub_100146CC0();
    _NRLogAbortWithPack(v21, v18);
  }

  uint64_t v2 = v1;
  id v3 = (dispatch_queue_attr_s *)_NRCopySerialQueueAttr(v1);
  uint64_t v4 = "terminusd.main.root";
  dispatch_queue_t v5 = dispatch_queue_create_with_target_V2("terminusd.main.root", v3, v2);

  if (!v5) {
    goto LABEL_7;
  }

  id v6 = (void *)qword_1001DCC38;
  qword_1001DCC38 = (uint64_t)v5;
}

void sub_100146F60(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DCC48;
  qword_1001DCC48 = (uint64_t)v1;
}

void sub_100146F90(id a1)
{
  thread_act_t v1 = mach_thread_self();
  policy_mach_timebase_info info = 0;
  thread_policy_set(v1, 1u, &policy_info, 1u);
  if (proc_setthread_cpupercent(90LL, 50LL))
  {
    policy_mach_timebase_info info = 1;
    thread_policy_set(v1, 1u, &policy_info, 1u);
  }

  mach_port_deallocate(mach_task_self_, v1);
}

void start()
{
  if (qword_1001DCC50 != -1) {
    dispatch_once(&qword_1001DCC50, &stru_1001B0A60);
  }
  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  if (qword_1001DCC50 != -1) {
    goto LABEL_13;
  }
  while (1)
  {
    thread_act_t v1 = p_class_meths[393];
    if (qword_1001DC858 != -1) {
      dispatch_once(&qword_1001DC858, &stru_1001AEE78);
    }
    id v2 = (id)qword_1001DC850;
    _NRLogWithArgs(v1, 0LL, "%s%.30s:%-4d Starting %@", "", "main", 117LL, v2);

LABEL_8:
    id v3 = sub_100146AFC();
    if (v3)
    {
      dispatch_async((dispatch_queue_t)v3, &stru_1001B0A20);
      dispatch_main();
    }

    id v4 = sub_100146CC0();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16LL);

    if (IsLevelEnabled)
    {
      id v6 = sub_100146CC0();
      _NRLogWithArgs(v6, 16LL, "%s%.30s:%-4d ABORTING: Assertion Failed: (queue) != ((void *)0)", "", "main", 121);
    }

    uint64_t v7 = _os_log_pack_size(12LL);
    p_class_meths = (__objc2_meth_list **)((char *)&v11 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL));
    id v8 = __error();
    uint64_t v9 = _os_log_pack_fill( p_class_meths,  v7,  *v8,  &_mh_execute_header,  "%{public}s Assertion Failed: (queue) != ((void *)0)");
    *(_DWORD *)uint64_t v9 = 136446210;
    *(void *)(v9 + 4) = "main";
    id v10 = sub_100146CC0();
    _NRLogAbortWithPack(v10, p_class_meths);
LABEL_13:
    dispatch_once(&qword_1001DCC50, &stru_1001B0A60);
  }

void sub_1001471F8(id a1)
{
  rlimit v38 = (rlimit)xmmword_100156A20;
  if (setrlimit(8, &v38))
  {
    int v1 = *__error();
    if (strerror_r(v1, __strerrbuf, 0x80uLL)) {
      __strerrbuf[0] = 0;
    }
    if (qword_1001DCC50 != -1) {
      dispatch_once(&qword_1001DCC50, &stru_1001B0A60);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCC48, 17LL))
    {
      if (qword_1001DCC50 != -1) {
        dispatch_once(&qword_1001DCC50, &stru_1001B0A60);
      }
      _NRLogWithArgs(qword_1001DCC48, 17LL, "setrlimit(RLIMIT_NOFILE, %llu) failed: [%d] %s", 1024LL, v1, __strerrbuf);
    }
  }

  LOBYTE(v38.rlim_cur) = 0;
  id v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  unsigned int v3 = [v2 fileExistsAtPath:@"/var/mobile/Library/terminus" isDirectory:&v38];

  if (v3) {
    BOOL v4 = LOBYTE(v38.rlim_cur) == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    dispatch_queue_t v5 = @"/var/mobile/Library/terminus";
    if ([@"/var/mobile/Library/terminus" length])
    {
      if (([@"/var/mobile/Library/terminus" containsString:@".."] & 1) != 0
        || ([@"/var/mobile/Library/terminus" hasPrefix:@"/"] & 1) == 0)
      {
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
        {
          if (qword_1001DCA58 != -1) {
            dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
          }
          _NRLogWithArgs( qword_1001DCA50,  17LL,  "Refusing to write to %@",  @"/var/mobile/Library/terminus",  v36,  v37);
        }
      }

      else if (mkdir((const char *)[@"/var/mobile/Library/terminus" UTF8String], 0x1EDu) < 0 {
             && *__error() != 17)
      }
      {
        id v6 = __error();
        uint64_t v7 = *v6;
        if (strerror_r(*v6, __strerrbuf, 0x80uLL)) {
          __strerrbuf[0] = 0;
        }
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
        {
          if (qword_1001DCA58 != -1) {
            dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
          }
          _NRLogWithArgs( qword_1001DCA50,  17LL,  "Failed to create %@: [%d] %s",  @"/var/mobile/Library/terminus",  v7,  __strerrbuf);
        }
      }
    }

    else
    {
      id v33 = sub_100100C84();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v33, 17LL);

      if (IsLevelEnabled)
      {
        id v35 = sub_100100C84();
        _NRLogWithArgs(v35, 17LL, "%s called with null dirPath.length", "NRDCreateDirectoryPath");
      }
    }
  }

  else
  {
    if (qword_1001DCC50 != -1) {
      dispatch_once(&qword_1001DCC50, &stru_1001B0A60);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCC48, 0LL))
    {
      if (qword_1001DCC50 != -1) {
        dispatch_once(&qword_1001DCC50, &stru_1001B0A60);
      }
      _NRLogWithArgs( qword_1001DCC48,  0LL,  "%s%.30s:%-4d terminusd settings directory present",  "",  "main_block_invoke",  130);
    }
  }

  objc_opt_self(&OBJC_CLASS___NRDKeyManager);
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  id v8 = (id)qword_1001DCC10;
  sub_100144478((uint64_t)v8, &stru_1001B0A40);

  os_unfair_lock_lock((os_unfair_lock_t)&unk_1001DC848);
  uint64_t v9 = -[NSMutableDictionary initWithContentsOfFile:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithContentsOfFile:",  @"/var/mobile/Library/terminus/com.apple.terminus.plist");
  if (!v9)
  {
    id v32 = -[NSMutableDictionary initWithContentsOfFile:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithContentsOfFile:",  @"/Library/Preferences/com.apple.terminus.plist");
    if (v32)
    {
      uint64_t v9 = v32;
      if (sub_1001013AC(@"/var/mobile/Library/terminus/com.apple.terminus.plist", v32, 0))
      {
        if (qword_1001DC868 != -1) {
          dispatch_once(&qword_1001DC868, &stru_1001AEE98);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC860, 0LL))
        {
          if (qword_1001DC868 != -1) {
            dispatch_once(&qword_1001DC868, &stru_1001AEE98);
          }
          _NRLogWithArgs(qword_1001DC860, 0LL, "%s%.30s:%-4d successfully migrated settings file");
        }
      }

      else
      {
        if (qword_1001DC868 != -1) {
          dispatch_once(&qword_1001DC868, &stru_1001AEE98);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC860, 16LL))
        {
          if (qword_1001DC868 != -1) {
            dispatch_once(&qword_1001DC868, &stru_1001AEE98);
          }
          _NRLogWithArgs(qword_1001DC860, 16LL, "%s%.30s:%-4d failed to migrate settings file");
        }
      }
    }

    else
    {
      uint64_t v9 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    }
  }

  if (qword_1001DC868 != -1) {
    dispatch_once(&qword_1001DC868, &stru_1001AEE98);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC860, 0LL))
  {
    if (qword_1001DC868 != -1) {
      dispatch_once(&qword_1001DC868, &stru_1001AEE98);
    }
    _NRLogWithArgs(qword_1001DC860, 0LL, "%s%.30s:%-4d settingsDict %@", "", "terminusdSettingsInit", 79LL, v9);
  }

  id v10 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v9,  "objectForKeyedSubscript:",  @"PacketLogging"));
  uint64_t v11 = objc_opt_class(&OBJC_CLASS___NSNumber);
  if ((objc_opt_isKindOfClass(v10, v11) & 1) != 0) {
    unsigned __int8 v12 = [v10 BOOLValue];
  }
  else {
    unsigned __int8 v12 = 0;
  }
  gNRPacketLoggingEnabled = v12;
  id v13 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v9, "objectForKeyedSubscript:", @"MPKLLogging"));
  uint64_t v14 = objc_opt_class(&OBJC_CLASS___NSNumber);
  if ((objc_opt_isKindOfClass(v13, v14) & 1) != 0) {
    unsigned __int8 v15 = [v13 BOOLValue];
  }
  else {
    unsigned __int8 v15 = 0;
  }
  gNRMPKLLoggingEnabled = v15;
  id v16 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v9,  "objectForKeyedSubscript:",  @"IPsecIfRingSize"));
  uint64_t v17 = objc_opt_class(&OBJC_CLASS___NSNumber);
  if ((objc_opt_isKindOfClass(v16, v17) & 1) != 0 && [v16 unsignedIntValue])
  {
    dword_1001DC230 = [v16 unsignedIntValue];
    if (qword_1001DC868 != -1) {
      dispatch_once(&qword_1001DC868, &stru_1001AEE98);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC860, 0LL))
    {
      if (qword_1001DC868 != -1) {
        dispatch_once(&qword_1001DC868, &stru_1001AEE98);
      }
      _NRLogWithArgs( qword_1001DC860,  0LL,  "%s%.30s:%-4d gNRIPsecIfRingSize %u",  "",  "terminusdSettingsInit",  97,  dword_1001DC230);
    }
  }

  id v18 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v9,  "objectForKeyedSubscript:",  @"IPsecKPipeTxRingSize"));
  uint64_t v19 = objc_opt_class(&OBJC_CLASS___NSNumber);
  if ((objc_opt_isKindOfClass(v18, v19) & 1) != 0 && [v18 unsignedIntValue])
  {
    dword_1001DC234 = [v18 unsignedIntValue];
    if (qword_1001DC868 != -1) {
      dispatch_once(&qword_1001DC868, &stru_1001AEE98);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC860, 0LL))
    {
      if (qword_1001DC868 != -1) {
        dispatch_once(&qword_1001DC868, &stru_1001AEE98);
      }
      _NRLogWithArgs( qword_1001DC860,  0LL,  "%s%.30s:%-4d gNRIPsecKPipeTxRingSize %u",  "",  "terminusdSettingsInit",  102,  dword_1001DC234);
    }
  }

  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v9,  "objectForKeyedSubscript:",  @"IPsecKPipeRxRingSize"));
  uint64_t v21 = objc_opt_class(&OBJC_CLASS___NSNumber);
  if ((objc_opt_isKindOfClass(v20, v21) & 1) != 0 && [v20 unsignedIntValue])
  {
    dword_1001DC238 = [v20 unsignedIntValue];
    if (qword_1001DC868 != -1) {
      dispatch_once(&qword_1001DC868, &stru_1001AEE98);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC860, 0LL))
    {
      if (qword_1001DC868 != -1) {
        dispatch_once(&qword_1001DC868, &stru_1001AEE98);
      }
      _NRLogWithArgs( qword_1001DC860,  0LL,  "%s%.30s:%-4d ipsecKPipeRxRingSize %u",  "",  "terminusdSettingsInit",  107,  dword_1001DC238);
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001DC848);
  if (qword_1001DC868 != -1) {
    dispatch_once(&qword_1001DC868, &stru_1001AEE98);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC860, 1LL))
  {
    if (qword_1001DC868 != -1) {
      dispatch_once(&qword_1001DC868, &stru_1001AEE98);
    }
    if (gNRPacketLoggingEnabled) {
      uint64_t v22 = "en";
    }
    else {
      uint64_t v22 = "dis";
    }
    _NRLogWithArgs( qword_1001DC860,  1LL,  "%s%.30s:%-4d Initialized packet logging as %sabled",  "",  "terminusdSettingsInit",  111,  v22);
  }

  id v23 = sub_100146AFC();
  dispatch_async((dispatch_queue_t)v23, &stru_1001AEA60);

  objc_opt_self(&OBJC_CLASS___NRDKeyManager);
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  id v24 = (id)qword_1001DCC10;
  sub_100144478((uint64_t)v24, &stru_1001AEE58);

  id v25 = objc_alloc(&OBJC_CLASS___NSString);
  else {
    int v26 = "dis";
  }
  id v27 = -[NSString initWithFormat:]( v25,  "initWithFormat:",  @"(when the daemon started, the companion link was %sabled on this device)",  v26);
  sub_10011BB18(0LL, 9000, &stru_1001B1528, v27);
  uint64_t v28 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v28);

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v29 = (id)qword_1001DC870;
  if (v29)
  {
    unsigned __int8 v30 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v30);

    else {
      sub_1000A404C((uint64_t)v29);
    }
  }

  objc_opt_self(&OBJC_CLASS___TerminusdXPCServer);
  if (qword_1001DC768 != -1) {
    dispatch_once(&qword_1001DC768, &stru_1001AE748);
  }
}

void sub_100147D70(id a1)
{
}

id sub_100147F78(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1 && (int v2 = *(_DWORD *)(v1 + 16)) != 0)
  {
    *(_DWORD *)(v1 + 16) = v2 - 1;
    if (qword_1001DCC60 != -1) {
      dispatch_once(&qword_1001DCC60, &stru_1001B0AC8);
    }
    id result = (id)_NRLogIsLevelEnabled(qword_1001DCC58, 0LL);
    if ((_DWORD)result)
    {
      if (qword_1001DCC60 != -1) {
        dispatch_once(&qword_1001DCC60, &stru_1001B0AC8);
      }
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5) {
        LODWORD(v5) = *(_DWORD *)(v5 + 16);
      }
      id result = (id)_NRLogWithArgs( qword_1001DCC58,  0LL,  "%s%.30s:%-4d Phone call relay agent un-asserted (Total remaining assertions: %u)",  "",  "-[NRPhoneCallRelayAgent unassertAgentWithOptions:]_block_invoke",  181,  v5);
    }

    uint64_t v6 = *(void *)(a1 + 32);
    if (v6)
    {
      if (*(_DWORD *)(v6 + 16)) {
        return result;
      }
      id WeakRetained = objc_loadWeakRetained((id *)(v6 + 56));
    }

    else
    {
      id WeakRetained = 0LL;
    }

    [WeakRetained deviceHasPhoneCallRelayRequest:0];

    id result = [*(id *)(a1 + 32) isActive];
    if ((_DWORD)result)
    {
      [*(id *)(a1 + 32) setActive:0];
      uint64_t v8 = *(void *)(a1 + 32);
      if (v8) {
        uint64_t v9 = *(void **)(v8 + 48);
      }
      else {
        uint64_t v9 = 0LL;
      }
      return objc_msgSend(v9, "updateNetworkAgent:");
    }
  }

  else
  {
    if (qword_1001DCC60 != -1) {
      dispatch_once(&qword_1001DCC60, &stru_1001B0AC8);
    }
    id result = (id)_NRLogIsLevelEnabled(qword_1001DCC58, 17LL);
    if ((_DWORD)result)
    {
      if (qword_1001DCC60 != -1) {
        dispatch_once(&qword_1001DCC60, &stru_1001B0AC8);
      }
      return (id)_NRLogWithArgs(qword_1001DCC58, 17LL, "Received an unexpected unassertAgent call");
    }
  }

  return result;
}

void sub_100148150(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  int v2 = (void *)qword_1001DCC58;
  qword_1001DCC58 = (uint64_t)v1;
}

id sub_100148180(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    int v3 = *(_DWORD *)(v2 + 16);
    BOOL v4 = v3 == 0;
    *(_DWORD *)(v2 + 16) = v3 + 1;
  }

  else
  {
    BOOL v4 = 1;
  }

  if (qword_1001DCC60 != -1) {
    dispatch_once(&qword_1001DCC60, &stru_1001B0AC8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCC58, 0LL))
  {
    if (qword_1001DCC60 != -1) {
      dispatch_once(&qword_1001DCC60, &stru_1001B0AC8);
    }
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5) {
      LODWORD(v5) = *(_DWORD *)(v5 + 16);
    }
    _NRLogWithArgs( qword_1001DCC58,  0LL,  "%s%.30s:%-4d Phone call relay agent asserted (Total active assertions: %u)",  "",  "-[NRPhoneCallRelayAgent assertAgentWithOptions:]_block_invoke",  157,  v5);
  }

  if (v4)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    if (v6) {
      id WeakRetained = objc_loadWeakRetained((id *)(v6 + 56));
    }
    else {
      id WeakRetained = 0LL;
    }
    [WeakRetained deviceHasPhoneCallRelayRequest:1];
  }

  id result = [*(id *)(a1 + 32) isActive];
  if ((result & 1) == 0)
  {
    [*(id *)(a1 + 32) setActive:1];
    uint64_t v9 = *(void *)(a1 + 32);
    if (v9) {
      id v10 = *(void **)(v9 + 48);
    }
    else {
      id v10 = 0LL;
    }
    return objc_msgSend(v10, "updateNetworkAgent:");
  }

  return result;
}

void sub_1001482DC(uint64_t a1)
{
  if (a1 && *(_BYTE *)(a1 + 14))
  {
    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v2 = (id)qword_1001DCB58;
    sub_10012114C((uint64_t)v2, *(void **)(a1 + 64));

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v3 = (id)qword_1001DCB58;
    BOOL v4 = (id *)v3;
    if (v3)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v3 + 1));
      if (([v4[2] apply] & 1) == 0) {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v5,  v6,  v7,  v10);
      }
    }

    if (([*(id *)(a1 + 48) unregisterNetworkAgent] & 1) == 0)
    {
      if (qword_1001DCC60 != -1) {
        dispatch_once(&qword_1001DCC60, &stru_1001B0AC8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCC58, 17LL))
      {
        if (qword_1001DCC60 != -1) {
          dispatch_once(&qword_1001DCC60, &stru_1001B0AC8);
        }
        _NRLogWithArgs(qword_1001DCC58, 17LL, "Failed to unregister PhoneCallRelay agent");
      }
    }

    uint64_t v8 = *(void **)(a1 + 48);
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;

    *(_BYTE *)(a1 + 14) = 0;
    id v11 = (id)objc_claimAutoreleasedReturnValue([(id)a1 agentUUID]);
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v11 UUIDString]);
    sub_10011BB18(0LL, 16003, 0LL, v9);
  }

id *sub_100148544(id *a1, void *a2, void *a3)
{
  id v6 = a2;
  id v7 = a3;
  if (a1)
  {
    v27.receiver = a1;
    v27.super_class = (Class)&OBJC_CLASS___NRPhoneCallRelayAgent;
    uint64_t v8 = (id *)objc_msgSendSuper2(&v27, "init");
    if (!v8)
    {
      id v18 = sub_100148794();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 16LL);

      if (IsLevelEnabled)
      {
        id v20 = sub_100148794();
        _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRPhoneCallRelayAgent initWithQueue:delegate:]",  36);
      }

      uint64_t v21 = _os_log_pack_size(12LL);
      uint64_t v22 = (char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v23 = __error();
      uint64_t v24 = _os_log_pack_fill(v22, v21, *v23, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v24 = 136446210;
      *(void *)(v24 + 4) = "-[NRPhoneCallRelayAgent initWithQueue:delegate:]";
      id v25 = sub_100148794();
      _NRLogAbortWithPack(v25, v22);
    }

    a1 = v8;
    objc_storeStrong(v8 + 5, a2);
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
    [a1 setAgentUUID:v9];

    [a1 setUserActivated:1];
    [a1 setAgentDescription:@"Phone call relay netagent"];
    objc_storeWeak(a1 + 7, v7);
    uint64_t v10 = objc_alloc(&OBJC_CLASS___NSString);
    id v11 = (void *)objc_claimAutoreleasedReturnValue([a1 agentUUID]);
    unsigned __int8 v12 = (void *)objc_claimAutoreleasedReturnValue([v11 UUIDString]);
    id v13 = -[NSString initWithFormat:](v10, "initWithFormat:", @"NRPhoneCallRelayAgent-%@", v12);
    id v14 = a1[8];
    a1[8] = v13;

    unsigned __int8 v15 = (void *)objc_claimAutoreleasedReturnValue([a1 agentUUID]);
    id v16 = (void *)objc_claimAutoreleasedReturnValue([v15 UUIDString]);
    sub_10011BB18(0LL, 16001, 0LL, v16);
  }

  return a1;
}

id sub_100148794()
{
  if (qword_1001DCC60 != -1) {
    dispatch_once(&qword_1001DCC60, &stru_1001B0AC8);
  }
  return (id)qword_1001DCC58;
}

id objc_msgSend_handleSeqnoReqFromAddr_babelInterface_ForPrefix_plen_routerID_seqno_hopCount_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "handleSeqnoReqFromAddr:babelInterface:ForPrefix:plen:routerID:seqno:hopCount:");
}

id objc_msgSend_handleUpdateFromAddr_ForPrefix_plen_nextHop_babelInterface_routerID_seqno_interval_metric_ae_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "handleUpdateFromAddr:ForPrefix:plen:nextHop:babelInterface:routerID:seqno:interval:metric:ae:");
}

id objc_msgSend_initLinkWithQueue_linkDelegate_nrUUID_wifiInterfaceName_localOuterEndpoint_remoteOuterEndpoint_listenerPortString_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initLinkWithQueue:linkDelegate:nrUUID:wifiInterfaceName:localOuterEndpoint:remoteOuterEndpoint:listenerPortString:");
}

id objc_msgSend_initWithIKEConfig_firstChildConfig_sessionConfig_queue_ipsecInterface_ikeSocketHandler_kernelSASessionName_packetDelegate_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName:packetDelegate:");
}

id objc_msgSend_initWithListenerIKEConfig_kernelSASessionName_listenerUDPPort_listenerQueue_delegate_delegateQueue_includeP2P_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithListenerIKEConfig:kernelSASessionName:listenerUDPPort:listenerQueue:delegate:delegateQueue:includeP2P:");
}

id objc_msgSend_initWithListenerIKEConfig_kernelSASessionName_packetDelegate_listenerQueue_delegate_delegateQueue_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithListenerIKEConfig:kernelSASessionName:packetDelegate:listenerQueue:delegate:delegateQueue:");
}

id objc_msgSend_initWithName_delegate_enableWithChannelCount_netifRingSize_kernelPipeTxRingSize_kernelPipeRxRingSize_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithName:delegate:enableWithChannelCount:netifRingSize:kernelPipeTxRingSize:kernelPipeRxRingSize:");
}

id objc_msgSend_initWithName_delegate_enableWithChannelCount_netifRingSize_kernelPipeTxRingSize_kernelPipeRxRingSize_execUUID_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "initWithName:delegate:enableWithChannelCount:netifRingSize:kernelPipeTxRingSize:kernelPipeRxRingSize:execUUID:");
}

id objc_msgSend_initWithPrefix_neighbor_routerID_seqno_interval_receivedMetric_nextHop_instance_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithPrefix:neighbor:routerID:seqno:interval:receivedMetric:nextHop:instance:");
}

id objc_msgSend_initWithSrcIfIndex_dstIfIndex_name_type_domain_hostTarget_port_txtRecord_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithSrcIfIndex:dstIfIndex:name:type:domain:hostTarget:port:txtRecord:");
}

id objc_msgSend_requestConfigurationForListener_session_sessionConfig_childConfig_validateAuthBlock_responseBlock_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:");
}

id objc_msgSend_sendKeepaliveWithRetries_retryIntervalInMilliseconds_callbackQueue_callback_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sendKeepaliveWithRetries:retryIntervalInMilliseconds:callbackQueue:callback:");
}

id objc_msgSend_sendPrivateNotifies_maxRetries_retryIntervalInMilliseconds_callbackQueue_callback_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sendPrivateNotifies:maxRetries:retryIntervalInMilliseconds:callbackQueue:callback:");
}

id objc_msgSend_setLinkRequirementsForPeer_withClientName_packetsPerSecond_inputBytesPerSecond_outputBytesPerSecond_( void *a1, const char *a2, ...)
{
  return objc_msgSend( a1,  "setLinkRequirementsForPeer:withClientName:packetsPerSecond:inputBytesPerSecond:outputBytesPerSecond:");
}

id objc_msgSend_signatureWithDomain_type_subType_subtypeContext_detectedProcess_triggerThresholdValues_( void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "signatureWithDomain:type:subType:subtypeContext:detectedProcess:triggerThresholdValues:");
}

id objc_msgSend_writeToAE_plen_prefix_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "writeToAE:plen:prefix:");
}