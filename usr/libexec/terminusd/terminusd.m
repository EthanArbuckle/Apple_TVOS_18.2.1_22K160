id *sub_100002254(id *a1, char a2, char a3, void *a4)
{
  id v8;
  id *v9;
  id v11;
  int IsLevelEnabled;
  id v13;
  uint64_t v14;
  char *v15;
  int *v16;
  uint64_t v17;
  id v18;
  uint64_t v19;
  objc_super v20;
  v8 = a4;
  if (a1)
  {
    v20.receiver = a1;
    v20.super_class = (Class)&OBJC_CLASS___NRToken;
    v9 = (id *)objc_msgSendSuper2(&v20, "init");
    if (!v9)
    {
      v11 = sub_1000023C8();
      IsLevelEnabled = _NRLogIsLevelEnabled(v11, 16LL);

      if (IsLevelEnabled)
      {
        v13 = sub_1000023C8();
        _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRToken initWithType:action:value:]",  63);
      }

      v14 = _os_log_pack_size(12LL);
      v15 = (char *)&v19 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      v16 = __error();
      v17 = _os_log_pack_fill(v15, v14, *v16, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)v17 = 136446210;
      *(void *)(v17 + 4) = "-[NRToken initWithType:action:value:]";
      v18 = sub_1000023C8();
      _NRLogAbortWithPack(v18, v15);
    }

    a1 = v9;
    *((_BYTE *)v9 + 8) = a2;
    *((_BYTE *)v9 + 9) = a3;
    objc_storeStrong(v9 + 2, a4);
  }

  return a1;
}

id sub_1000023C8()
{
  if (qword_1001DC620 != -1) {
    dispatch_once(&qword_1001DC620, &stru_1001ADD28);
  }
  return (id)qword_1001DC618;
}

void sub_100002408(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  v2 = (void *)qword_1001DC618;
  qword_1001DC618 = (uint64_t)v1;
}

NSMutableData *sub_100002438(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  v2 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
  ((void (*)(void))NRTLVAdd)();
  if (*(void *)(a1 + 16)) {
    NRTLVAddData(v2, 2LL);
  }
  NRTLVAdd(v2, 3LL, 1LL, a1 + 9);
  return v2;
}

uint64_t sub_1000024BC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_1000024CC(uint64_t a1)
{
}

uint64_t sub_1000024D4(void *a1, unsigned __int8 *a2)
{
  unsigned int v3 = *(unsigned __int16 *)(a2 + 1);
  uint64_t v4 = __rev16(v3);
  int v5 = *a2;
  switch(v5)
  {
    case 3:
      if (v3 == 256)
      {
        unsigned __int8 v6 = a2[3];
        uint64_t v7 = a1[7];
        goto LABEL_8;
      }

      *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = 1;
      if (qword_1001DC620 != -1) {
        dispatch_once(&qword_1001DC620, &stru_1001ADD28);
      }
      uint64_t result = _NRLogIsLevelEnabled(qword_1001DC618, 16LL);
      if ((_DWORD)result)
      {
        if (qword_1001DC620 != -1) {
          dispatch_once(&qword_1001DC620, &stru_1001ADD28);
        }
        _NRLogWithArgs(qword_1001DC618, 16LL, "%s%.30s:%-4d unexpected size for token action %u");
        return 0LL;
      }

      break;
    case 2:
      v8 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a2 + 3, v4);
      uint64_t v9 = *(void *)(a1[6] + 8LL);
      v10 = *(void **)(v9 + 40);
      *(void *)(v9 + 40) = v8;

      return 1LL;
    case 1:
      if (v3 == 256)
      {
        unsigned __int8 v6 = a2[3];
        uint64_t v7 = a1[5];
LABEL_8:
        *(_BYTE *)(*(void *)(v7 + 8) + 24LL) = v6;
        return 1LL;
      }

      *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = 1;
      if (qword_1001DC620 != -1) {
        dispatch_once(&qword_1001DC620, &stru_1001ADD28);
      }
      uint64_t result = _NRLogIsLevelEnabled(qword_1001DC618, 16LL);
      if ((_DWORD)result)
      {
        if (qword_1001DC620 != -1) {
          dispatch_once(&qword_1001DC620, &stru_1001ADD28);
        }
        _NRLogWithArgs(qword_1001DC618, 16LL, "%s%.30s:%-4d unexpected size for token type %u");
        return 0LL;
      }

      break;
    default:
      return 1LL;
  }

  return result;
}

LABEL_19:
            v32 = (void *)objc_claimAutoreleasedReturnValue([v16 remoteIdentifier]);
            v33 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
            v34 = sub_10012A74C((uint64_t)&OBJC_CLASS___NRDLocalDevice, v32, v33, v161);

            if (v34)
            {
              if (qword_1001DC630 != -1) {
                dispatch_once(&qword_1001DC630, &stru_1001ADE00);
              }
              if (_NRLogIsLevelEnabled(qword_1001DC628, 1LL))
              {
                if (qword_1001DC630 != -1) {
                  dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                }
                v35 = (id)qword_1001DC628;
                v36 = v34->_identity;
                _NRLogWithArgs( v35,  1LL,  "%s%.30s:%-4d %@: Decrypted device identity %@",  "",  "-[NRPairingClient requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  1628LL,  v28,  v36);
              }

              v37 = v34->_nrUUID;

              if (v37)
              {
                v38 = v34->_nrUUID;
                v39 = -[NSUUID isEqual:](v38, "isEqual:", v28->_nrUUID);

                if ((v39 & 1) != 0)
                {

LABEL_29:
                  v40 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
                  if (qword_1001DCAA8 != -1) {
                    dispatch_once(&qword_1001DCAA8, &stru_1001AFDB0);
                  }
                  v41 = (uint64_t)v158;
                  v42 = (id)qword_1001DCAA0;
                  v43 = [v40 isEqual:v42];

                  if (v43)
                  {
                    sub_100003C00((uint64_t)v158, (id *)&v158->_ikeSessionPairing);
                    objc_storeStrong((id *)&v158->_ikeSessionPairing, a4);
                    sub_100003D60((uint64_t)v158);
                    v44 = [[NEIKEv2AuthenticationProtocol alloc] initWithMethod:2];
                    if (qword_1001DCAA8 != -1) {
                      dispatch_once(&qword_1001DCAA8, &stru_1001AFDB0);
                    }
                    v45 = v155;
                    v46 = (id)qword_1001DCAA0;
                    v47 = sub_10010C5AC(0, v46, v44);

                    if (v155)
                    {
                      v48 = (void *)*((void *)v155 + 19);
                      if (v48) {
                        v48 = (void *)v48[2];
                      }
                      v49 = v48;
                    }

                    else
                    {
                      v49 = 0LL;
                    }

                    -[NEIKEv2SessionConfiguration setSharedSecret:](v47, "setSharedSecret:", v49);

                    v50 = (void *)objc_claimAutoreleasedReturnValue(-[NEIKEv2SessionConfiguration sharedSecret](v47, "sharedSecret"));
                    if (v50)
                    {
                      if (v47)
                      {
                        if (qword_1001DC630 != -1) {
                          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                        }
                        if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
                        {
                          v51 = sub_100003B10();
                          _NRLogWithArgs( v51,  0LL,  "%s%.30s:%-4d %@: Receiving session for pairing with OOBK",  "",  "-[NRPairingClient requestConfigurationForListener:session:sessionConfig:childConfig:validate AuthBlock:responseBlock:]",  1667LL,  v158);
                        }

                        nrUUID = v158->_nrUUID;
                        v162[0] = _NSConcreteStackBlock;
                        v162[1] = 3221225472LL;
                        v162[2] = sub_100004220;
                        v162[3] = &unk_1001AEDC0;
                        v162[4] = v158;
                        v163 = v47;
                        v164 = v17;
                        v165 = v160;
                        v53 = v47;
                        v19 = v160;
                        sub_1001320DC((uint64_t)&OBJC_CLASS___NRDLocalDevice, nrUUID, 1, v162);

                        goto LABEL_89;
                      }

                      v19 = v160;
                      v160[2](v160, 0LL, 0LL, 0LL);
                    }

                    else
                    {
                      v125 = sub_100003B10();
                      IsLevelEnabled = _NRLogIsLevelEnabled(v125, 17LL);

                      v19 = v160;
                      if (IsLevelEnabled)
                      {
                        v127 = sub_100003B10();
                        _NRLogWithArgs(v127, 17LL, "%@: Missing out of band key", v158);

                        v19 = v160;
                      }
                    }

LABEL_89:
                    v14 = v156;
                    v15 = v161;
                    v18 = v157;
LABEL_131:

                    goto LABEL_132;
                  }

                  v56 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
                  if (qword_1001DCA68 != -1) {
                    dispatch_once(&qword_1001DCA68, &stru_1001AFD30);
                  }
                  v57 = (id)qword_1001DCA60;
                  if (([v56 isEqual:v57] & 1) == 0)
                  {
                    v58 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
                    if (qword_1001DCA78 != -1) {
                      dispatch_once(&qword_1001DCA78, &stru_1001AFD50);
                    }
                    v59 = (id)qword_1001DCA70;
                    if (([v58 isEqual:v59] & 1) == 0)
                    {
                      v89 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
                      v90 = sub_10010B930();
                      v153 = [v89 isEqual:v90];

                      if ((v153 & 1) == 0)
                      {
                        v91 = sub_100003B10();
                        v92 = _NRLogIsLevelEnabled(v91, 16LL);

                        v14 = v156;
                        v15 = v161;
                        if (v92)
                        {
                          v93 = sub_100003B10();
                          v94 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
                          _NRLogWithArgs( v93,  16LL,  "%s%.30s:%-4d %@: Unrecognized IKEv2 identifier %@",  "",  "-[NRPairingClient requestConfigurationForListener:session:sessionConfig:childConfig:validate AuthBlock:responseBlock:]",  1750LL,  v158,  v94);
                        }

                        v19 = v160;
                        v160[2](v160, 0LL, 0LL, 0LL);
                        v18 = v157;
                        goto LABEL_130;
                      }

LABEL_20:
          [*v6 connect];
LABEL_21:

          goto LABEL_22;
        }

        v38 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v12);
        v39 = _NRLogIsLevelEnabled(v38, 0LL);

        if (!v39)
        {
LABEL_22:

          return;
        }

        v41 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v40);
        v42 = [(id)a1 copyDescription];
        _NRLogWithArgs( v41,  0LL,  "%s%.30s:%-4d %@: Not starting %@ IKE initiator session because we do not have keys %@",  "",  "-[NRLinkQuickRelay setupIKEInitiatorSessionForClass:]",  1372LL,  v42,  String,  v9);
      }

      else
      {
        v45 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v10);
        v46 = _NRLogIsLevelEnabled(v45, 17LL);

        if (!v46) {
          goto LABEL_22;
        }
        v41 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v47);
        v42 = [(id)a1 copyDescription];
        _NRLogWithArgs( v41,  17LL,  "%@: Not starting %@ IKE initiator session because localDevice is missing",  v42,  String);
      }

      goto LABEL_22;
    }
  }

      -[NSMutableString appendFormat:](v15, "appendFormat:", @"PairingCompleted | ");

      if (a3) {
        goto LABEL_13;
      }
      goto LABEL_20;
    }
  }

            v16 = (char *)v16 + 1;
          }

          while (v16 != v15);
          v15 = [v13 countByEnumeratingWithState:&v146 objects:v156 count:16];
        }

        while (v15);
      }

      a3 = v126;
    }

    v71 = *(void **)(v5 + 632);
    if (v71) {
      v71 = (void *)v71[3];
    }
    v72 = v71;
    v73 = [v72 count];

    if (v73 && a3)
    {
      v144 = 0u;
      v145 = 0u;
      v142 = 0u;
      v143 = 0u;
      v74 = *(void **)(v5 + 632);
      if (v74) {
        v74 = (void *)v74[3];
      }
      obja = v74;
      v75 = [obja countByEnumeratingWithState:&v142 objects:v155 count:16];
      if (v75)
      {
        v76 = v75;
        v77 = *(void *)v143;
        do
        {
          for (k = 0LL; k != v76; k = (char *)k + 1)
          {
            if (*(void *)v143 != v77) {
              objc_enumerationMutation(obja);
            }
            v81 = *(void **)(*((void *)&v142 + 1) + 8LL * (void)k);
            if (sub_1000F72A0(*(void *)(v5 + 632), v81)
              && ((v82 = *(id *)(v5 + 128)) == 0LL
               || (v84 = v82, v85 = [*(id *)(v5 + 128) type], v84, v85 == 4)))
            {
              v86 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 96), v83);
              v87 = _NRLogIsLevelEnabled(v86, 0LL);

              if (v87)
              {
                v88 = *(id *)(v5 + 96);
                v90 = (void *)_NRCopyLogObjectForNRUUID(v88, v89);
                _NRLogWithArgs( v90,  0LL,  "%s%.30s:%-4d not using QR link for ASName %@",  "",  "-[NRDDeviceConductor handleASEndpointChanged:handleASResolving:]",  8437LL,  v81);
              }
            }

            else if ([*(id *)(v5 + 128) ikeClassDEstablished])
            {
              v92 = v81;
              v93 = v5;
              v94 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
              v95 = (void *)objc_claimAutoreleasedReturnValue([v92 dataUsingEncoding:4]);
              v96 = *(void *)(v93 + 632);
              v97 = v92;
              if (v96 && !*(_BYTE *)(v96 + 9))
              {
                objc_opt_self(&OBJC_CLASS___NRApplicationServiceManager);
                if (qword_1001DC930 != -1) {
                  dispatch_once(&qword_1001DC930, &stru_1001AF7E0);
                }
                v98 = sub_1000F4294(qword_1001DC928, v97);
              }

              else
              {
                v98 = 0LL;
              }

              if (!-[NSMutableArray count](v98, "count"))
              {
                v107 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v135 + 96), v106);
                v108 = _NRLogIsLevelEnabled(v107, 16LL);

                if (v108)
                {
                  v110 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v135 + 96), v109);
                  _NRLogWithArgs( v110,  16LL,  "%s%.30s:%-4d no public keys",  "",  "-[NRDDeviceConductor sendResolveRequestForASName:]",  8522);
                }
              }

              NRTLVAddData(v94, 5LL);
              v152 = 0u;
              v153 = 0u;
              v150 = 0u;
              v151 = 0u;
              v111 = v98;
              v112 = (char *)-[NSMutableArray countByEnumeratingWithState:objects:count:]( v111,  "countByEnumeratingWithState:objects:count:",  &v150,  v158,  16LL);
              if (v112)
              {
                v113 = v112;
                v114 = *(void *)v151;
                do
                {
                  for (m = 0LL; m != v113; ++m)
                  {
                    if (*(void *)v151 != v114) {
                      objc_enumerationMutation(v111);
                    }
                    NRTLVAddData(v94, 7LL);
                  }

                  v113 = (char *)-[NSMutableArray countByEnumeratingWithState:objects:count:]( v111,  "countByEnumeratingWithState:objects:count:",  &v150,  v158,  16LL);
                }

                while (v113);
              }

              v79 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
              NRTLVAddData(v79, 6LL);
              v80 = sub_100021C64(objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage), *(void **)(v135 + 96));
              sub_1000222F4((uint64_t)v80, 20, v79);
              sub_100023824((uint64_t)v80);

              int v5 = v135;
            }

            else
            {
              v99 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 96), v91);
              v100 = _NRLogIsLevelEnabled(v99, 0LL);

              if (v100)
              {
                v101 = *(id *)(v5 + 96);
                v103 = (void *)_NRCopyLogObjectForNRUUID(v101, v102);
                v104 = *(void **)(v5 + 632);
                if (v104) {
                  v104 = (void *)v104[3];
                }
                v105 = v104;
                _NRLogWithArgs( v103,  0LL,  "%s%.30s:%-4d starting QR link for ongoing AS resolve operations %@",  "",  "-[NRDDeviceConductor handleASEndpointChanged:handleASResolving:]",  8443LL,  v105);
              }

              if (!*(_BYTE *)(v5 + 70))
              {
                *(_BYTE *)(v5 + 70) = 1;
                [*(id *)(v5 + 192) assertAgentWithOptions:0];
              }
            }
          }

          v76 = [obja countByEnumeratingWithState:&v142 objects:v155 count:16];
        }

        while (v76);
      }
    }

    v116 = *(void **)(v5 + 632);
    if (v116) {
      v116 = (void *)v116[4];
    }
    v117 = v116;
    v118 = [v117 count];

    if (v118 && [*(id *)(v5 + 128) ikeClassDEstablished])
    {
      v140 = 0u;
      v141 = 0u;
      v138 = 0u;
      v139 = 0u;
      v119 = *(void **)(v5 + 632);
      if (v119) {
        v119 = (void *)v119[4];
      }
      v120 = v119;
      v121 = [v120 copy];

      v122 = [v121 countByEnumeratingWithState:&v138 objects:v154 count:16];
      if (v122)
      {
        v123 = v122;
        v124 = *(void *)v139;
        do
        {
          for (n = 0LL; n != v123; n = (char *)n + 1)
          {
            if (*(void *)v139 != v124) {
              objc_enumerationMutation(v121);
            }
            sub_1000D1D1C(v5, *(void **)(*((void *)&v138 + 1) + 8LL * (void)n));
          }

          v123 = [v121 countByEnumeratingWithState:&v138 objects:v154 count:16];
        }

        while (v123);
      }
    }
  }

  if (a2 == 1)
  {
    if (v10) {
      v10[4] |= 0x800u;
    }
    v17 = 616LL;
    goto LABEL_25;
  }

    v68 = 0LL;
    goto LABEL_13;
  }

  if (!v8)
  {
    v73 = sub_1000D54AC();
    v74 = _NRLogIsLevelEnabled(v73, 17LL);

    if (v74)
    {
      v72 = sub_1000D54AC();
      _NRLogWithArgs(v72, 17LL, "%s called with null queue");
      goto LABEL_18;
    }

    goto LABEL_19;
  }

  v82.receiver = a1;
  v82.super_class = (Class)&OBJC_CLASS___NRDDeviceConductor;
  v10 = (char *)objc_msgSendSuper2(&v82, "init");
  if (!v10)
  {
    v75 = sub_1000D54AC();
    v76 = _NRLogIsLevelEnabled(v75, 16LL);

    v11 = "-[NRDDeviceConductor initConductorWithNRUUID:queue:]";
    if (v76)
    {
      v77 = sub_1000D54AC();
      _NRLogWithArgs( v77,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDDeviceConductor initConductorWithNRUUID:queue:]",  307);
    }

    uint64_t v7 = (id)_os_log_pack_size(12LL);
    uint64_t v9 = (char *)&v81 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    v78 = __error();
    v79 = _os_log_pack_fill(v9, v7, *v78, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)v79 = 136446210;
    *(void *)(v79 + 4) = "-[NRDDeviceConductor initConductorWithNRUUID:queue:]";
    v80 = sub_1000D54AC();
    _NRLogAbortWithPack(v80, v9);
    goto LABEL_23;
  }

  v11 = v10;
  unsigned int v3 = (id *)(v10 + 96);
  objc_storeStrong((id *)v10 + 12, a2);
  objc_storeStrong((id *)v11 + 13, a3);
  dispatch_assert_queue_V2(*((dispatch_queue_t *)v11 + 13));
  v12 = (void *)*((void *)v11 + 26);
  *((void *)v11 + 26) = 0LL;

  v13 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
  v14 = (void *)*((void *)v11 + 14);
  *((void *)v11 + 14) = v13;

  v11[13] = 0;
  v15 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
  v16 = (void *)*((void *)v11 + 21);
  *((void *)v11 + 21) = v15;

  v17 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
  v18 = (void *)*((void *)v11 + 19);
  *((void *)v11 + 19) = v17;

  v19 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
  v20 = (void *)*((void *)v11 + 22);
  *((void *)v11 + 22) = v19;

  v21 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  v22 = (void *)*((void *)v11 + 30);
  *((void *)v11 + 30) = v21;

  v11[24] = 1;
  v11[38] = 1;
  v23 = @"Policy";
  v24 = objc_alloc(&OBJC_CLASS___NSString);
  v25 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v11 + 12) UUIDString]);
  v26 = -[NSString initWithFormat:](v24, "initWithFormat:", @"NRDDC-%@-%@", v25, @"Policy");

  v27 = (void *)*((void *)v11 + 34);
  *((void *)v11 + 34) = v26;

  v28 = @"NetInfo";
  v29 = objc_alloc(&OBJC_CLASS___NSString);
  v30 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v11 + 12) UUIDString]);
  v31 = -[NSString initWithFormat:](v29, "initWithFormat:", @"NRDDC-%@-%@", v30, @"NetInfo");

  v32 = (void *)*((void *)v11 + 35);
  *((void *)v11 + 35) = v31;

  v33 = @"CmpnNWDesc";
  v34 = objc_alloc(&OBJC_CLASS___NSString);
  v35 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v11 + 12) UUIDString]);
  v36 = -[NSString initWithFormat:](v34, "initWithFormat:", @"NRDDC-%@-%@", v35, @"CmpnNWDesc");

  v37 = (void *)*((void *)v11 + 36);
  *((void *)v11 + 36) = v36;

  v38 = @"CmpnLnkMon";
  v39 = objc_alloc(&OBJC_CLASS___NSString);
  v40 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v11 + 12) UUIDString]);
  v41 = -[NSString initWithFormat:](v39, "initWithFormat:", @"NRDDC-%@-%@", v40, @"CmpnLnkMon");

  v42 = (void *)*((void *)v11 + 67);
  *((void *)v11 + 67) = v41;

  v43 = @"flowDivert";
  v44 = objc_alloc(&OBJC_CLASS___NSString);
  v45 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v11 + 12) UUIDString]);
  v46 = -[NSString initWithFormat:](v44, "initWithFormat:", @"NRDDC-%@-%@", v45, @"flowDivert");

  v47 = (void *)*((void *)v11 + 37);
  *((void *)v11 + 37) = v46;

  v48 = @"cmpnAgentRemoval";
  v49 = objc_alloc(&OBJC_CLASS___NSString);
  v50 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v11 + 12) UUIDString]);
  v51 = -[NSString initWithFormat:](v49, "initWithFormat:", @"NRDDC-%@-%@", v50, @"cmpnAgentRemoval");

  v52 = (void *)*((void *)v11 + 39);
  *((void *)v11 + 39) = v51;

  v53 = @"proxyConfig";
  v54 = objc_alloc(&OBJC_CLASS___NSString);
  v55 = (void *)objc_claimAutoreleasedReturnValue([*((id *)v11 + 12) UUIDString]);
  v56 = -[NSString initWithFormat:](v54, "initWithFormat:", @"NRDDC-%@-%@", v55, @"proxyConfig");

  v57 = (void *)*((void *)v11 + 68);
  *((void *)v11 + 68) = v56;

  objc_opt_self(&OBJC_CLASS___NRLinkDirectorMessageManager);
  if (qword_1001DC708 != -1) {
LABEL_23:
  }
    dispatch_once(&qword_1001DC708, &stru_1001AE488);
  v58 = (id)qword_1001DC700;
  v59 = *v3;
  if (v58)
  {
    dispatch_assert_queue_V2(*((dispatch_queue_t *)v58 + 1));
    v60 = objc_claimAutoreleasedReturnValue([*((id *)v58 + 2) objectForKeyedSubscript:v59]);
    if (v60)
    {
      v62 = (NSMutableDictionary *)v60;
      v63 = (void *)_NRCopyLogObjectForNRUUID(v59, v61);
      v64 = _NRLogIsLevelEnabled(v63, 17LL);

      if (v64)
      {
        v66 = (void *)_NRCopyLogObjectForNRUUID(v59, v65);
        _NRLogWithArgs(v66, 17LL, "registering uuid when already registered");
      }
    }

    else
    {
      v62 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      [*((id *)v58 + 2) setObject:v62 forKeyedSubscript:v59];
    }
  }

  v67 = (void *)objc_claimAutoreleasedReturnValue([v11 description]);
  sub_10011BB18(*((void **)v11 + 12), 1500, 0LL, v67);

  a1 = v11;
  v68 = a1;
LABEL_13:

  return v68;
}

    v28 = 0LL;
    goto LABEL_13;
  }

  if (!v7)
  {
    v38 = sub_100107F78();
    v39 = _NRLogIsLevelEnabled(v38, 17LL);

    if (v39)
    {
      v37 = sub_100107F78();
      _NRLogWithArgs(v37, 17LL, "%s called with null policyIdentifierString");
      goto LABEL_18;
    }

    goto LABEL_19;
  }

  v43 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
  v47 = v9;
  v10 = objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v47, 1LL));

  v11 = v6;
  v12 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forInterfaceName:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forInterfaceName:",  5LL,  v6));
  v44 = v5;
  [v12 setNetworkAgentUUID:v5];
  v46 = v12;
  v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v46, 1LL));
  v14 = objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v13));

  v41 = (void *)v14;
  v42 = (void *)v10;
  v15 = [[NEPolicy alloc] initWithOrder:10 result:v14 conditions:v10];
  objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
  if (qword_1001DCB60 != -1) {
    dispatch_once(&qword_1001DCB60, &stru_1001B0538);
  }
  v16 = (id)qword_1001DCB58;
  v17 = v8;
  v18 = sub_100120E44((uint64_t)v16, v8, v15);
  v19 = (void *)objc_claimAutoreleasedReturnValue(v18);

  -[NSMutableArray addObject:](v43, "addObject:", v19);
  v20 = objc_alloc(&OBJC_CLASS___NEPolicy);
  v21 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult netAgentUUID:](&OBJC_CLASS___NEPolicyResult, "netAgentUUID:", v44));
  v22 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition scopedInterface:](&OBJC_CLASS___NEPolicyCondition, "scopedInterface:", v11));
  v45 = v22;
  v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v45, 1LL));
  v24 = [v20 initWithOrder:10 result:v21 conditions:v23];

  objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
  if (qword_1001DCB60 != -1) {
    dispatch_once(&qword_1001DCB60, &stru_1001B0538);
  }
  v25 = (id)qword_1001DCB58;
  v26 = sub_100120E44((uint64_t)v25, v17, v24);
  v27 = (void *)objc_claimAutoreleasedReturnValue(v26);

  v28 = v43;
  -[NSMutableArray addObject:](v43, "addObject:", v27);
  objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
  unsigned __int8 v6 = v11;
  if (qword_1001DCB60 != -1) {
    dispatch_once(&qword_1001DCB60, &stru_1001B0538);
  }
  int v5 = v44;
  v29 = (id)qword_1001DCB58;
  v30 = (id *)v29;
  if (v29)
  {
    dispatch_assert_queue_V2(*((dispatch_queue_t *)v29 + 1));
    if (([v30[2] apply] & 1) == 0) {
      sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v31,  v32,  v33,  v40);
    }
  }

  v8 = v17;
LABEL_13:

  return v28;
}

    v11 = 0LL;
    goto LABEL_11;
  }

  v28 = 0LL;
  v11 = [v9 verifySignature:v7 data:v8 error:&v28];
  v12 = v28;
  v13 = v12;
  if (v12 && [v12 code] != (id)-6754)
  {
    v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v14);
    v16 = _NRLogIsLevelEnabled(v15, 1LL);

    if (v16)
    {
      v17 = *(id *)(a1 + 24);
      v19 = (void *)_NRCopyLogObjectForNRUUID(v17, v18);
      _NRLogWithArgs( v19,  1LL,  "%s%.30s:%-4d verification failed with error %@",  "",  "-[NRDiscoveryClient verifyRPSignature:forData:withIdentity:]",  615LL,  v13);
    }

    v11 = 0LL;
  }

LABEL_11:
  return v11;
}

    uint64_t v9 = 0LL;
    goto LABEL_13;
  }

  if (!*(void *)(a1 + 16))
  {
    v14 = sub_100121F34();
    v15 = _NRLogIsLevelEnabled(v14, 17LL);

    if (v15)
    {
      v13 = sub_100121F34();
      _NRLogWithArgs(v13, 17LL, "%s called with null self.secKeyRef");
      goto LABEL_18;
    }

    goto LABEL_19;
  }

  v23[0] = kSecAttrKeyType;
  v23[1] = kSecAttrKeyClass;
  v24[0] = kSecAttrKeyTypeX25519;
  v24[1] = kSecAttrKeyClassPublic;
  int v5 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v24,  v23,  2LL));
  error = 0LL;
  unsigned __int8 v6 = SecKeyCreateWithData(v4, v5, &error);
  if (v6)
  {
    uint64_t v7 = v6;
    if (error)
    {
      CFRelease(error);
      error = 0LL;
    }

    v8 = SecKeyCopyKeyExchangeResult( *(SecKeyRef *)(a1 + 16),  kSecKeyAlgorithmECDHKeyExchangeStandard,  v7,  (CFDictionaryRef)&__NSDictionary0__struct,  &error);
    CFRelease(v7);
    if (v8)
    {
      if (error)
      {
        CFRelease(error);
        error = 0LL;
      }

      uint64_t v9 = sub_1001242A0((char *)objc_alloc(&OBJC_CLASS___NRDLDKeychainItemData), v8);
    }

    else
    {
      v19 = sub_100121F34();
      v20 = _NRLogIsLevelEnabled(v19, 17LL);

      if (v20)
      {
        v21 = sub_100121F34();
        _NRLogWithArgs(v21, 17LL, "Failed to compute shared secret: %@", error);
      }

      if (error)
      {
        CFRelease(error);
        uint64_t v9 = 0LL;
        error = 0LL;
      }

      else
      {
        uint64_t v9 = 0LL;
      }
    }
  }

  else
  {
    v16 = sub_100121F34();
    v17 = _NRLogIsLevelEnabled(v16, 17LL);

    if (v17)
    {
      v18 = sub_100121F34();
      _NRLogWithArgs(v18, 17LL, "Failed to ingest public DH key: %@", error);
    }

    if (error) {
      CFRelease(error);
    }
    uint64_t v9 = 0LL;
  }

LABEL_13:
  return v9;
}

LABEL_66:
                      v60 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
                      if (qword_1001DCA78 != -1) {
                        dispatch_once(&qword_1001DCA78, &stru_1001AFD50);
                      }
                      v61 = (id)qword_1001DCA70;
                      v62 = [v60 isEqual:v61];

                      if ((v62 & 1) != 0)
                      {
                        v63 = 3LL;
                      }

                      else
                      {
                        v64 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
                        if (qword_1001DCA88 != -1) {
                          dispatch_once(&qword_1001DCA88, &stru_1001AFD70);
                        }
                        v65 = (id)qword_1001DCA80;
                        v66 = [v64 isEqual:v65];

                        if (v66) {
                          v63 = 1LL;
                        }
                        else {
                          v63 = 4LL;
                        }
                      }

                      v18 = v157;
                      v67 = v161;
                      v68 = v157;
                      v19 = v160;
                      if ((v158->_state & 0xFE) == 6)
                      {
                        v69 = 0LL;
LABEL_113:

                        v116 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(v41 + 24));
                        if (v17)
                        {
                          v117 = (unsigned __int8 *)*(id *)(v41 + 40);
                          if (v117 && (v118 = v117[11], v117, v118))
                          {
                            v119 = sub_10010C340();
                            -[NEIKEv2ChildSAConfiguration setSequencePerTrafficClass:]( v119,  "setSequencePerTrafficClass:",  1LL);
                            v120 = v119;
                            v121 = 16LL;
                          }

                          else
                          {
                            v119 = sub_10010C340();
                            -[NEIKEv2ChildSAConfiguration setMode:](v119, "setMode:", 2LL);
                            v120 = v119;
                            v121 = 4LL;
                          }

                          -[NEIKEv2ChildSAConfiguration setReplayWindowSize:](v120, "setReplayWindowSize:", v121);
                        }

                        else
                        {
                          v119 = 0LL;
                        }

                        v122 = v154;
                        if (!v69) {
                          v122 = 1;
                        }
                        if ((v122 & 1) == 0) {
                          sub_100136544((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(v41 + 24));
                        }
                        if (v119)
                        {
                          v123 = *(void *)(v41 + 40);
                          if (v123) {
                            v124 = *(void *)(v123 + 40);
                          }
                          else {
                            v124 = 0LL;
                          }
                          (*((void (**)(id, NEIKEv2SessionConfiguration *, NEIKEv2ChildSAConfiguration *, uint64_t))v19
                           + 2))( v19,  v69,  v119,  v124);
                        }

                        else
                        {
                          (*((void (**)(id, NEIKEv2SessionConfiguration *, void, void))v19 + 2))( v19,  v69,  0LL,  0LL);
                        }

                        v14 = v156;
                        v15 = v161;
LABEL_130:
                        v45 = v155;
                        goto LABEL_131;
                      }

                      if (!v67)
                      {
                        v142 = sub_100003B10();
                        v143 = _NRLogIsLevelEnabled(v142, 17LL);

                        if (v143)
                        {
                          v144 = sub_100003B10();
                          _NRLogWithArgs( v144,  17LL,  "%s called with null session",  "-[NRPairingClient respondToIKESession:dataProtectionClass:validateAuthBlock:]");
                        }

                        v69 = 0LL;
                        v18 = v157;
                        v41 = (uint64_t)v158;
                        v19 = v160;
                        goto LABEL_113;
                      }

                      String = NRDataProtectionClassCreateString(v63);
                      v70 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v158->_nrUUID);
                      v71 = sub_10012ADD4(v70, v63);
                      v149 = v71;
                      if (v71) {
                        v72 = (void *)*((void *)v71 + 1);
                      }
                      else {
                        v72 = 0LL;
                      }
                      v73 = v72;

                      if (!v73)
                      {
                        v95 = (void *)String;
                        sub_100003B50(v158, 3019, @"%@ %@ %@", v74, v75, v76, v77, v78, String);
                        v69 = 0LL;
                        v19 = v160;
LABEL_112:

                        goto LABEL_113;
                      }

                      pairingParameters = v158->_pairingParameters;
                      v148 = (uint64_t (**)(void, NEIKEv2SessionConfiguration *))v68;
                      if (pairingParameters && pairingParameters->_isTransportModeIPsec)
                      {
                        if ((_DWORD)v63 == 3)
                        {
                          if (v70)
                          {
                            v96 = sub_100146AFC();
                            dispatch_assert_queue_V2((dispatch_queue_t)v96);

                            v81 = sub_10012D45C(v70, @"0");
                            v97 = sub_100146AFC();
                            dispatch_assert_queue_V2((dispatch_queue_t)v97);

                            v83 = sub_10012D610(v70, @"0");
                            goto LABEL_103;
                          }

    uint64_t v7 = _os_log_pack_size(12LL);
    int v5 = (void **)((char *)&v98 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL));
    v87 = *__error();
    v82 = _os_log_pack_fill( v5,  v7,  v87,  &_mh_execute_header,  "%{public}s Assertion Failed: (conditionPrefix) != ((void *)0)");
LABEL_62:
    *(_DWORD *)v82 = 136446210;
    *(void *)(v82 + 4) = "-[NRDDeviceConductor setupCatchAllInterfaceIfApplicable]";
    v83 = sub_1000D54AC();
    _NRLogAbortWithPack(v83, v5);
    goto LABEL_63;
  }

  return v21;
}

LABEL_150:
                          v159 = 0LL;
                          v81 = 0LL;
                          goto LABEL_104;
                        }

                        if ((_DWORD)v63 == 4)
                        {
                          if (v70)
                          {
                            v80 = sub_100146AFC();
                            dispatch_assert_queue_V2((dispatch_queue_t)v80);

                            v81 = (uint64_t)sub_10012CD2C(v70, @"0");
                            v82 = sub_100146AFC();
                            dispatch_assert_queue_V2((dispatch_queue_t)v82);

                            v83 = sub_10012D254(v70, @"0");
LABEL_103:
                            v159 = v83;
LABEL_104:
                            v18 = v157;
LABEL_105:
                            v146 = v70;
                            v98 = sub_10010C6B8(0, v70, v63);
                            v147 = (void *)v81;
                            if (v81 && v159)
                            {
                              v99 = objc_alloc(&OBJC_CLASS___NEIKEv2ConfigurationMessage);
                              v145 = [[NEIKEv2InitiatorTransportIPv6Address alloc] initWithAddress:v159];
                              v166[0] = v145;
                              v100 = [[NEIKEv2ResponderTransportIPv6Address alloc] initWithAddress:v147];
                              v166[1] = v100;
                              v101 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v166,  2LL));
                              v102 = [v99 initWithWithAttributes:v101];
                              -[NEIKEv2SessionConfiguration setConfigurationReply:](v98, "setConfigurationReply:", v102);

                              v18 = v157;
                            }

                            v103 = sub_100004570(v41, 1);
                            -[NEIKEv2SessionConfiguration setCustomIKEAuthPrivateNotifies:]( v98,  "setCustomIKEAuthPrivateNotifies:",  v103);
                            v19 = v160;
                            if ((v148[2](v148, v98) & 1) != 0)
                            {
                              v109 = (id *)sub_100004C0C(v41, v63);
                              sub_100003C00(v41, v109);
                              v110 = (id *)sub_100004C0C(v41, v63);
                              objc_storeStrong(v110, a4);
                              sub_100004D7C(v41, v63);
                              v95 = (void *)String;
                              sub_100003B50((void *)v41, 3016, @"%@ %@", v111, v112, v113, v114, v115, String);
                              v69 = v98;
                            }

                            else
                            {
                              v95 = (void *)String;
                              sub_100003B50((void *)v41, 3021, @"%@ %@", v104, v105, v106, v107, v108, String);
                              v69 = 0LL;
                            }

                            v70 = v146;
                            v68 = v148;
                            goto LABEL_112;
                          }

                          goto LABEL_150;
                        }
                      }

                      v159 = 0LL;
                      v81 = 0LL;
                      goto LABEL_105;
                    }
                  }

                  goto LABEL_66;
                }

                v139 = sub_100003B10();
                v140 = _NRLogIsLevelEnabled(v139, 16LL);

                v28 = v158;
                if (v140)
                {
                  v135 = sub_100003B10();
                  v138 = v34->_identity;
                  v141 = v34->_nrUUID;
                  _NRLogWithArgs( v135,  16LL,  "%s%.30s:%-4d %@: Different device found for identity %@ (%@ != %@)",  "",  "-[NRPairingClient requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBloc k:responseBlock:]",  1639LL,  v158,  v138,  v141,  v158->_nrUUID);

                  goto LABEL_141;
                }
              }

              else
              {
                v136 = sub_100003B10();
                v137 = _NRLogIsLevelEnabled(v136, 16LL);

                if (v137)
                {
                  v135 = sub_100003B10();
                  v138 = v34->_identity;
                  _NRLogWithArgs( v135,  16LL,  "%s%.30s:%-4d %@: No device found for identity %@",  "",  "-[NRPairingClient requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBloc k:responseBlock:]",  1632LL,  v28,  v138);
LABEL_141:

                  goto LABEL_142;
                }
              }
            }

            else
            {
              v128 = sub_100003B10();
              v129 = _NRLogIsLevelEnabled(v128, 16LL);

              if (v129)
              {
                v135 = sub_100003B10();
                _NRLogWithArgs( v135,  16LL,  "%s%.30s:%-4d %@: Failed to decrypt device identity",  "",  "-[NRPairingClient requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  1624LL,  v28);
LABEL_142:

                v28 = v158;
              }
            }

            v45 = v155;
            sub_100003B50(v28, 3023, @"%@ %@", v130, v131, v132, v133, v134, (uint64_t)v161);

            v15 = v161;
            v14 = v156;
            v18 = v157;
            v19 = v160;
            goto LABEL_131;
          }
        }

        goto LABEL_19;
      }

      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      v19 = v160;
      v15 = v161;
      if (_NRLogIsLevelEnabled(qword_1001DC628, 16LL))
      {
        if (qword_1001DC630 != -1) {
          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
        }
        v54 = (id)qword_1001DC628;
        v55 = (void *)objc_claimAutoreleasedReturnValue([v16 remoteIdentifier]);
        _NRLogWithArgs( v54,  16,  "%s%.30s:%-4d %@: Remote identifier has wrong type %zu",  "",  "-[NRPairingClient requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  1604,  self,  [v55 identifierType]);
LABEL_57:

        v19 = v160;
        v15 = v161;
      }
    }

    else
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      v19 = v160;
      v15 = v161;
      if (_NRLogIsLevelEnabled(qword_1001DC628, 16LL))
      {
        if (qword_1001DC630 != -1) {
          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
        }
        v54 = (id)qword_1001DC628;
        v55 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
        _NRLogWithArgs( v54,  16,  "%s%.30s:%-4d %@: Local identifier has wrong type %zu",  "",  "-[NRPairingClient requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  1600,  self,  [v55 identifierType]);
        goto LABEL_57;
      }
    }
  }

    v116 = -[NRBabelInstance copyNeighborWithAddr:babelInterface:isNewNeighbor:]( self,  "copyNeighborWithAddr:babelInterface:isNewNeighbor:",  a5,  v15,  0LL);
    v117 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  a3,  v11);
    v118 = objc_claimAutoreleasedReturnValue([v116 dtlsStack]);
    v119 = v117;
    if (v118)
    {
      *(_BYTE *)(v118 + 11) = 1;
      if (qword_1001DCB48 != -1) {
        dispatch_once(&qword_1001DCB48, &stru_1001B0518);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
      {
        if (qword_1001DCB48 != -1) {
          dispatch_once(&qword_1001DCB48, &stru_1001B0518);
        }
        v120 = (id)qword_1001DCB40;
        _NRLogWithArgs( v120,  1LL,  "%s%.30s:%-4d %@ writing %llu inbound encrypted bytes into UDP",  "",  "-[NRDDTLSStack processInboundEncryptedData:]",  122LL,  v118,  -[NSData length](v119, "length"));
      }

      v121 = (nw_connection *)*(id *)(v118 + 40);
      v122 = (dispatch_data_s *)-[NSData _createDispatchData](v119, "_createDispatchData");
      completion = _NSConcreteStackBlock;
      v162 = 3221225472LL;
      v163 = sub_10011EB14;
      v164 = &unk_1001B03B8;
      v165 = v118;
      nw_connection_send(v121, v122, _nw_content_context_default_message, 0, &completion);
    }

    goto LABEL_212;
  }

  v21 = *((unsigned __int8 *)a3 + 1);
  if ((_DWORD)v21 != 2)
  {
    if ((v17 & 1) == 0)
    {
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC8A8, 16LL))
      {
        v123 = sub_1000B07C8();
        _NRLogWithArgs( v123,  16LL,  "%s%.30s:%-4d %@Invalid Babel version number %u != %u",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3534LL,  self,  v21,  2LL);
      }

      goto LABEL_212;
    }

    goto LABEL_150;
  }

  v153 = self;
  v150 = [v15 dtlsEnabled];
  v22 = objc_alloc(&OBJC_CLASS___NSMutableString);
  IPv6AddrString = (void *)createIPv6AddrString(a5, v23);
  v149 = a6;
  v26 = (void *)createIPv6AddrString(a6, v25);
  v154 = -[NSMutableString initWithFormat:]( v22,  "initWithFormat:",  @"[%@] %@ > %@ Babel len(%u,%u)",  v15,  IPv6AddrString,  v26,  v19,  v11);

  completion = 0LL;
  v162 = 0LL;
  v160 = *a5;
  v159[0] = 0LL;
  v159[1] = 0LL;
  v158[0] = 0LL;
  v158[1] = 0LL;
  if (!v18)
  {
    v152 = 0;
    v30 = v153;
    goto LABEL_203;
  }

  v152 = 0;
  v27 = 0LL;
  v28 = (v19 + 4);
  v29 = 4LL;
  v30 = v153;
  v151 = v28;
  while (1)
  {
    v31 = &a3[v29];
    v32 = *(unsigned __int8 *)v31;
    if (*v31) {
      break;
    }
    -[NSMutableString appendString:](v154, "appendString:", @"Pad1, ");
    v29 = (v29 + 1);
LABEL_21:
  }

  v33 = v29 + 1LL;
  if (v33 >= v28)
  {
    if (qword_1001DC8B0 != -1) {
      dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC8A8, 16LL))
    {
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      v124 = (id)qword_1001DC8A8;
      if (v32 >= 0x10) {
        v125 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown[%u]",  v32);
      }
      else {
        v125 = off_1001AF1C0[(v32 - 1)];
      }
      _NRLogWithArgs( v124,  16LL,  "%s%.30s:%-4d %@TLV type %@ hanging off edge %u %u",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3582LL,  v30,  v125,  v29,  v28);
LABEL_182:
    }

    goto LABEL_203;
  }

  v155 = v27;
  v34 = a3[v33];
  v35 = v32 - 1;
  else {
    v36 = off_1001AF1C0[v35];
  }
  -[NSMutableString appendFormat:](v154, "appendFormat:", @"%@-%u ", v36, v34);

  v29 = (v29 + v34 + 2);
  v28 = v151;
  if (v29 <= v151)
  {
    if ((v32 - 9) > 1 || (v152 & 1) == 0)
    {
      v27 = v155;
      if ((_DWORD)v32 == 1) {
        goto LABEL_78;
      }
    }

    else
    {
      -[NRBabelInstance updateRoutes](v153, "updateRoutes");
      v152 = 0;
      v27 = v155;
    }

    v37 = v150;
    if ((v37 & v16) == 1)
    {
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      if (!_NRLogIsLevelEnabled(qword_1001DC8A8, 1LL))
      {
LABEL_78:
        v30 = v153;
        goto LABEL_21;
      }

      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      v38 = (id)qword_1001DC8A8;
      else {
        v39 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown[%u]",  v32);
      }
      v146 = v34;
      v30 = v153;
      _NRLogWithArgs( v38,  1LL,  "%s%.30s:%-4d %@Ignoring unencrypted TLV %@-%u",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3657LL,  v153,  v39,  v146);

      goto LABEL_50;
    }

    switch((int)v32)
    {
      case 2:
        if (v34 > 5)
        {
          v40 = sub_1000B07C8();
          IsLevelEnabled = _NRLogIsLevelEnabled(v40, 1LL);

          v30 = v153;
          if (IsLevelEnabled)
          {
            v42 = sub_1000B07C8();
            _NRLogWithArgs( v42,  1LL,  "%s%.30s:%-4d %@got AckReq for nonce %#x",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3661LL,  v153,  bswap32(*((unsigned __int16 *)v31 + 2)) >> 16);
          }

          -[NRBabelInstance handleAckReqFromAddr:babelInterface:nonce:interval:]( v153,  "handleAckReqFromAddr:babelInterface:nonce:interval:",  a5,  v15,  bswap32(*((unsigned __int16 *)v31 + 2)) >> 16,  bswap32(*((unsigned __int16 *)v31 + 3)) >> 16);
          goto LABEL_50;
        }

        v126 = sub_1000B07C8();
        v127 = _NRLogIsLevelEnabled(v126, 16LL);

        if (!v127) {
          goto LABEL_202;
        }
        v124 = sub_1000B07C8();
        v125 = @"AckReq";
        _NRLogWithArgs( v124,  16LL,  "%s%.30s:%-4d insufficient TLV length %u < %u for type %@",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3666LL,  v34,  6LL,  @"AckReq");
        break;
      case 3:
        if (v34 > 1)
        {
          v43 = sub_1000B07C8();
          v44 = _NRLogIsLevelEnabled(v43, 16LL);

          v30 = v153;
          if (!v44) {
            goto LABEL_50;
          }
          v45 = sub_1000B07C8();
          _NRLogWithArgs( v45,  16LL,  "%s%.30s:%-4d %@got Ack for nonce %#x",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3668LL,  v153,  bswap32(*((unsigned __int16 *)v31 + 1)) >> 16);
          goto LABEL_132;
        }

        v128 = sub_1000B07C8();
        v129 = _NRLogIsLevelEnabled(v128, 16LL);

        if (!v129) {
          goto LABEL_202;
        }
        v124 = sub_1000B07C8();
        v125 = @"Ack";
        _NRLogWithArgs( v124,  16LL,  "%s%.30s:%-4d insufficient TLV length %u < %u for type %@",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3670LL,  v34,  2LL,  @"Ack");
        break;
      case 4:
        if (v34 > 5)
        {
          v46 = v31[2];
          v30 = v153;
          v47 = sub_1000B07C8();
          v48 = _NRLogIsLevelEnabled(v47, 1LL);

          if (v48)
          {
            v49 = sub_1000B07C8();
            v51 = (void *)createIPv6AddrString(a5, v50);
            v53 = (void *)createIPv6AddrString(v149, v52);
            _NRLogWithArgs( v49,  1LL,  "%s%.30s:%-4d %@rechecking local address due to invalid personal Hello on %@ from %@ to %@",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3676LL,  v153,  v15,  v51,  v53);

            v30 = v153;
          }

          v28 = v151;
          v27 = v155;
          if ([v15 setupLocalAddressCheckAgainst:v149])
          {
LABEL_63:
            -[NRBabelInstance handleHelloFromAddr:babelInterface:seqno:interval:personal:]( v30,  "handleHelloFromAddr:babelInterface:seqno:interval:personal:",  a5,  v15,  bswap32(*((unsigned __int16 *)v31 + 2)) >> 16,  bswap32(*((unsigned __int16 *)v31 + 3)) >> 16,  (v46 >> 7) & 1);
            goto LABEL_21;
          }

          v111 = sub_1000B07C8();
          v112 = _NRLogIsLevelEnabled(v111, 16LL);

          if (!v112) {
            goto LABEL_50;
          }
          v106 = sub_1000B07C8();
          v108 = (void *)createIPv6AddrString(a5, v113);
          v115 = (void *)createIPv6AddrString(v149, v114);
          _NRLogWithArgs( v106,  16LL,  "%s%.30s:%-4d %@ignoring invalid personal Hello on %@ from %@ to %@",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3679LL,  v153,  v15,  v108,  v115);

          v30 = v153;
          goto LABEL_141;
        }

        v130 = sub_1000B07C8();
        v131 = _NRLogIsLevelEnabled(v130, 16LL);

        if (!v131) {
          goto LABEL_202;
        }
        v124 = sub_1000B07C8();
        v125 = @"Hello";
        _NRLogWithArgs( v124,  16LL,  "%s%.30s:%-4d insufficient TLV length %u < %u for type %@",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3689LL,  v34,  6LL,  @"Hello");
        break;
      case 5:
        if (v34 > 5)
        {
          v54 = *((unsigned __int8 *)v31 + 2);
          if (v31[2])
          {
            v157 = *v149;
            v55 = sub_1000BF4D0(&v157, v54, (void *)(v31 + 8), (int)v34 - 6, 0LL, 0LL, 0LL);
            if (v55 < 0)
            {
              v88 = sub_1000B07C8();
              v89 = _NRLogIsLevelEnabled(v88, 16LL);

              v30 = v153;
              v28 = v151;
              if (v89)
              {
                v90 = sub_1000B07C8();
                _NRLogWithArgs( v90,  16LL,  "%s%.30s:%-4d %@failed to decompress IHU",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3707LL,  v153);
              }
            }

            else
            {
              v56 = v55;
              v57 = sub_1000B07C8();
              v58 = _NRLogIsLevelEnabled(v57, 2LL);

              v30 = v153;
              v28 = v151;
              if (v58)
              {
                v59 = sub_1000B07C8();
                v61 = (void *)createIPv6AddrString(&v157, v60);
                _NRLogWithArgs( v59,  2LL,  "%s%.30s:%-4d %@ignoring IHU for other destination %@",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3711LL,  v153,  v61);

                v28 = v151;
              }
            }

            goto LABEL_51;
          }

          if ([v15 isLocalAddressEqualTo:v149])
          {
            v56 = 0;
LABEL_126:
            if ((sub_1000BF1F0((unsigned __int8 *)&v31[v56 + 8], (int)v34 - v56 - 6) & 1) != 0)
            {
              v30 = v153;
            }

            else
            {
              v30 = v153;
              -[NRBabelInstance handleIHUFromAddr:babelInterface:rxcost:interval:]( v153,  "handleIHUFromAddr:babelInterface:rxcost:interval:",  a5,  v15,  bswap32(*((unsigned __int16 *)v31 + 2)) >> 16,  bswap32(*((unsigned __int16 *)v31 + 3)) >> 16);
            }

            v28 = v151;
            goto LABEL_21;
          }

          v95 = sub_1000B07C8();
          v96 = _NRLogIsLevelEnabled(v95, 1LL);

          if (v96)
          {
            v97 = sub_1000B07C8();
            v99 = (void *)createIPv6AddrString(a5, v98);
            v101 = (void *)createIPv6AddrString(v149, v100);
            _NRLogWithArgs( v97,  1LL,  "%s%.30s:%-4d %@rechecking local address due to invalid IHU with AE 0 on %@ from %@ to %@",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3694LL,  v153,  v15,  v99,  v101);
          }

          if ([v15 setupLocalAddressCheckAgainst:v149])
          {
            v56 = 0;
            v27 = v155;
            goto LABEL_126;
          }

          v104 = sub_1000B07C8();
          v105 = _NRLogIsLevelEnabled(v104, 16LL);

          if (v105)
          {
            v106 = sub_1000B07C8();
            v108 = (void *)createIPv6AddrString(a5, v107);
            v110 = (void *)createIPv6AddrString(v149, v109);
            _NRLogWithArgs( v106,  16LL,  "%s%.30s:%-4d %@ignoring invalid IHU with AE 0 on %@ from %@ to %@",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3697LL,  v153,  v15,  v108,  v110);

            v30 = v153;
LABEL_141:

            goto LABEL_50;
          }

LABEL_132:
}

                if (qword_1001DC630 != -1) {
                  dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                }
                if (_NRLogIsLevelEnabled(qword_1001DC628, 1LL))
                {
                  if (qword_1001DC630 != -1) {
                    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                  }
                  v69 = (id)qword_1001DC628;
                  _NRLogWithArgs( v69,  1LL,  "%s%.30s:%-4d %@: Received unknown notify code %u",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1515LL,  WeakRetained,  v29);
                }

                goto LABEL_85;
              }

              if ((_DWORD)v29 != 51301)
              {
                if ((_DWORD)v29 == 51401)
                {
                  LOBYTE(v125) = 0;
                  [v15 getBytes:&v125 length:1];
                  if (qword_1001DC630 != -1) {
                    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                  }
                  v41 = (id)qword_1001DC628;
                  v42 = _NRLogIsLevelEnabled(v41, 0LL);

                  if (v42)
                  {
                    if (qword_1001DC630 != -1) {
                      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                    }
                    v43 = (id)qword_1001DC628;
                    _NRLogWithArgs( v43,  0LL,  "%s%.30s:%-4d %@: Received Always On Wi-Fi supported: %u",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1387LL,  WeakRetained,  v125);
                  }

                  sub_100135EB0((uint64_t)&OBJC_CLASS___NRDLocalDevice, v125 == 1, WeakRetained[3]);
                  goto LABEL_85;
                }

                goto LABEL_132;
              }

              goto LABEL_79;
            }

            if ((_DWORD)v29 != 50701)
            {
              if ((_DWORD)v29 != 50702) {
                goto LABEL_132;
              }
LABEL_79:
              if (qword_1001DC630 != -1) {
                dispatch_once(&qword_1001DC630, &stru_1001ADE00);
              }
              if (_NRLogIsLevelEnabled(qword_1001DC628, 1LL))
              {
                if (qword_1001DC630 != -1) {
                  dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                }
                _NRLogWithArgs( qword_1001DC628,  1LL,  "%s%.30s:%-4d %@: Received unexpected notify code %u",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1511LL,  WeakRetained,  v29);
              }

              goto LABEL_85;
            }

            sub_100136084((uint64_t)&OBJC_CLASS___NRDLocalDevice, v15, WeakRetained[3]);
          }

id sub_100003B10()
{
  if (qword_1001DC630 != -1) {
    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
  }
  return (id)qword_1001DC628;
}

void sub_100003B50( void *a1, int a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1)
  {
    id v11 = a3;
    v12 = -[NSString initWithFormat:arguments:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:arguments:",  v11,  &a9);

    v13 = (void *)a1[3];
    v14 = v12;
    id v15 = v13;
    v16 = (void *)objc_claimAutoreleasedReturnValue([a1 description]);
    sub_10011BB18(v15, a2, v16, v14);
  }
}

void sub_100003C00(uint64_t a1, id *a2)
{
  if (a1 && *a2)
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      _NRLogWithArgs( qword_1001DC628,  0LL,  "%s%.30s:%-4d %@: Invalidating IKE Session %@",  "",  "-[NRPairingClient invalidateIKESession:]",  914LL,  a1,  *a2);
    }

    [*a2 setStateUpdateBlock:0];
    [*a2 setChildStateUpdateBlock:0];
    [*a2 setConfigurationUpdateBlock:0];
    [*a2 setTrafficSelectorUpdateBlock:0];
    [*a2 setAdditionalAddressesUpdateBlock:0];
    [*a2 setShortDPDEventBlock:0];
    [*a2 setRedirectEventBlock:0];
    [*a2 setPrivateNotifyStatusEvent:0];
    [*a2 disconnect];
    [*a2 invalidate];
    id v4 = *a2;
    *a2 = 0LL;
  }

void sub_100003D60(uint64_t a1)
{
  if (a1 && (*(_BYTE *)(a1 + 8) & 0xFE) != 6)
  {
    v2 = *(void **)(a1 + 80);
    if (v2)
    {
      unsigned int v3 = (void *)objc_claimAutoreleasedReturnValue([v2 description]);
      [*(id *)(a1 + 80) setClientQueue:*(void *)(a1 + 32)];
      objc_initWeak(location, (id)a1);
      v36[0] = _NSConcreteStackBlock;
      v36[1] = 3221225472LL;
      v36[2] = sub_100006F98;
      v36[3] = &unk_1001AEC80;
      objc_copyWeak(&v38, location);
      id v4 = v3;
      id v37 = v4;
      [*(id *)(a1 + 80) setStateUpdateBlock:v36];
      v33[0] = _NSConcreteStackBlock;
      v33[1] = 3221225472LL;
      v33[2] = sub_1000074A8;
      v33[3] = &unk_1001AECA8;
      objc_copyWeak(&v35, location);
      id v5 = v4;
      id v34 = v5;
      [*(id *)(a1 + 80) setChildStateUpdateBlock:v33];
      v30[0] = _NSConcreteStackBlock;
      v30[1] = 3221225472LL;
      v30[2] = sub_100007670;
      v30[3] = &unk_1001AECD0;
      objc_copyWeak(&v32, location);
      id v6 = v5;
      id v31 = v6;
      [*(id *)(a1 + 80) setConfigurationUpdateBlock:v30];
      v27[0] = _NSConcreteStackBlock;
      v27[1] = 3221225472LL;
      v27[2] = sub_100007758;
      v27[3] = &unk_1001AECF8;
      v16 = &v29;
      objc_copyWeak(&v29, location);
      id v7 = v6;
      id v28 = v7;
      [*(id *)(a1 + 80) setTrafficSelectorUpdateBlock:v27];
      v24[0] = _NSConcreteStackBlock;
      v24[1] = 3221225472LL;
      v24[2] = sub_100007864;
      v24[3] = &unk_1001AED20;
      objc_copyWeak(&v26, location);
      id v8 = v7;
      id v25 = v8;
      [*(id *)(a1 + 80) setAdditionalAddressesUpdateBlock:v24];
      v21[0] = _NSConcreteStackBlock;
      v21[1] = 3221225472LL;
      v21[2] = sub_10000794C;
      v21[3] = &unk_1001B0798;
      objc_copyWeak(&v23, location);
      id v9 = v8;
      id v22 = v9;
      [*(id *)(a1 + 80) setShortDPDEventBlock:v21];
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 3221225472LL;
      v18[2] = sub_100007A30;
      v18[3] = &unk_1001AED20;
      objc_copyWeak(&v20, location);
      id v10 = v9;
      id v19 = v10;
      [*(id *)(a1 + 80) setPrivateNotifyStatusEvent:v18];
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      id v11 = (id)qword_1001DC628;
      char IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0LL);

      if ((IsLevelEnabled & 1) != 0)
      {
        if (qword_1001DC630 != -1) {
          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
        }
        id v13 = (id)qword_1001DC628;
        _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d %@: Setup IKE pairing %@ callbacks",  "",  "-[NRPairingClient setupIKECallbacksPairing]",  1154LL,  a1,  v10,  &v29);
      }

      objc_destroyWeak(&v20);
      objc_destroyWeak(&v23);

      objc_destroyWeak(&v26);
      objc_destroyWeak(v16);

      objc_destroyWeak(&v32);
      objc_destroyWeak(&v35);

      objc_destroyWeak(&v38);
      objc_destroyWeak(location);
    }

    else
    {
      id v14 = sub_100003B10();
      int v15 = _NRLogIsLevelEnabled(v14, 17LL);

      if (v15)
      {
        id v17 = sub_100003B10();
        _NRLogWithArgs( v17,  17LL,  "%s called with null _ikeSessionPairing",  "-[NRPairingClient setupIKECallbacksPairing]");
      }
    }
  }

void sub_10000418C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id *location, id *a15, id *a16)
{
}

void sub_100004220(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v36 = a2;
  id v7 = a3;
  id v8 = a4;
  uint64_t v9 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v9 + 8) & 0xFE) != 6)
  {
    id v10 = sub_100004570(v9, 0);
    if (_os_feature_enabled_impl("terminus", "EncryptedIdentity"))
    {
      uint64_t v11 = *(void *)(a1 + 32);
      if (v11) {
        v12 = *(void **)(v11 + 24);
      }
      else {
        v12 = 0LL;
      }
      id v13 = sub_100132028((uint64_t)&OBJC_CLASS___NRDLocalDevice, v12);
      if (v13)
      {
        id v14 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50351 notifyData:v13];
        -[NSMutableArray addObject:](v10, "addObject:", v14);
      }
    }

    if (v36)
    {
      id v15 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50411 notifyData:v36];
      -[NSMutableArray addObject:](v10, "addObject:", v15);
    }

    if (v7)
    {
      id v16 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50412 notifyData:v7];
      -[NSMutableArray addObject:](v10, "addObject:", v16);
    }

    if (v8)
    {
      id v17 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50413 notifyData:v8];
      -[NSMutableArray addObject:](v10, "addObject:", v17);
    }

    [*(id *)(a1 + 40) setCustomIKEAuthPrivateNotifies:v10];
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      _NRLogWithArgs( qword_1001DC628,  0LL,  "%s%.30s:%-4d %@: Responding to session for pairing with OOBK",  "",  "-[NRPairingClient requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBl ock:]_block_invoke",  1708LL,  *(void *)(a1 + 32));
    }

    v18 = *(id **)(a1 + 32);
    id v19 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) sharedSecret]);
    LogString = (void *)_NRKeyCreateLogString(v19);
    sub_100006F18(v18, 3014, LogString);

    uint64_t v21 = *(void *)(a1 + 32);
    if (v21) {
      id v22 = *(void **)(v21 + 24);
    }
    else {
      id v22 = 0LL;
    }
    id v23 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v22);
    if (*(void *)(a1 + 48))
    {
      uint64_t v24 = *(void *)(a1 + 32);
      if (v24
        && (id v25 = (unsigned __int8 *)*(id *)(v24 + 40)) != 0LL
        && (int v26 = v25[11], v25, v26))
      {
        v27 = sub_10010C340();
        -[NEIKEv2ChildSAConfiguration setSequencePerTrafficClass:](v27, "setSequencePerTrafficClass:", 1LL);
        id v28 = v27;
        uint64_t v29 = 16LL;
      }

      else
      {
        v27 = sub_10010C340();
        -[NEIKEv2ChildSAConfiguration setMode:](v27, "setMode:", 2LL);
        id v28 = v27;
        uint64_t v29 = 4LL;
      }

      -[NEIKEv2ChildSAConfiguration setReplayWindowSize:](v28, "setReplayWindowSize:", v29);
      uint64_t v30 = *(void *)(a1 + 56);
      uint64_t v31 = *(void *)(a1 + 40);
      if (v27)
      {
        uint64_t v32 = *(void *)(a1 + 32);
        if (v32)
        {
          id v33 = *(id *)(v32 + 40);
          id v34 = v33;
          if (v33)
          {
            uint64_t v35 = *((void *)v33 + 5);
LABEL_33:
            (*(void (**)(uint64_t, uint64_t, NEIKEv2ChildSAConfiguration *, uint64_t))(v30 + 16))( v30,  v31,  v27,  v35);

LABEL_35:
            goto LABEL_36;
          }
        }

        else
        {
          id v34 = 0LL;
        }

        uint64_t v35 = 0LL;
        goto LABEL_33;
      }
    }

    else
    {
      uint64_t v30 = *(void *)(a1 + 56);
      uint64_t v31 = *(void *)(a1 + 40);
    }

    (*(void (**)(uint64_t, uint64_t, void, void))(v30 + 16))(v30, v31, 0LL, 0LL);
    goto LABEL_35;
  }

LABEL_36:
}
}

  -[NSMutableArray addObject:](v3, "addObject:", @"RdBest");
  if ((a1 & 0x400000) == 0)
  {
LABEL_11:
    if ((a1 & 0x800000) == 0) {
      goto LABEL_12;
    }
    goto LABEL_38;
  }

    if (-[NEIPsecNexus virtualInterface](v14, "virtualInterface")) {
      break;
    }
    id v16 = sub_100107F78();
    id v17 = _NRLogIsLevelEnabled(v16, 16LL);

    a6 = "NRLinkIPsecNexusCreate";
    if (v17)
    {
      v18 = sub_100107F78();
      _NRLogWithArgs( v18,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nexus.virtualInterface) != ((void *)0)",  "",  "NRLinkIPsecNexusCreate",  2053);
    }

    v12 = (id)_os_log_pack_size(12LL);
    id v13 = (char *)&v27 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v19 = __error();
    uint64_t v20 = _os_log_pack_fill( v13,  v12,  *v19,  &_mh_execute_header,  "%{public}s Assertion Failed: (nexus.virtualInterface) != ((void *)0)");
    *(_DWORD *)uint64_t v20 = 136446210;
    *(void *)(v20 + 4) = "NRLinkIPsecNexusCreate";
LABEL_41:
    uint64_t v21 = sub_100107F78();
    _NRLogAbortWithPack(v21, v13);
LABEL_42:
    dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
  }

  return v14;
}
}

      goto LABEL_37;
    }
  }

  else
  {
    uint64_t v30 = sub_100121F34();
    uint64_t v31 = _NRLogIsLevelEnabled(v30, 16LL);

    if (v31)
    {
      uint64_t v32 = sub_100121F34();
      _NRLogWithArgs( v32,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDLDDataClassKeychainItems initWithLegacyKeys:]",  484);
    }

    id v5 = (id *)_os_log_pack_size(12LL);
    a1 = (uint64_t *)((char *)&v45 - (((unint64_t)v5 + 15) & 0xFFFFFFFFFFFFFFF0LL));
    id v33 = __error();
    id v34 = _os_log_pack_fill(a1, v5, *v33, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)id v34 = 136446210;
    *(void *)(v34 + 4) = "-[NRDLDDataClassKeychainItems initWithLegacyKeys:]";
    uint64_t v35 = sub_100121F34();
    _NRLogAbortWithPack(v35, a1);
  }

  id v36 = sub_100121F34();
  id v37 = _NRLogIsLevelEnabled(v36, 17LL);

  if (v37)
  {
    id v16 = sub_100121F34();
    _NRLogWithArgs(v16, 17LL, "Legacy public key is missing when migrating private key!");
    goto LABEL_11;
  }

        id v37 = sub_100121F34();
        char IsLevelEnabled = _NRLogIsLevelEnabled(v37, 17LL);

        if (IsLevelEnabled)
        {
          v39 = sub_100121F34();
          _NRLogWithArgs(v39, 17LL, "Failed to generate private key: %@", error);
        }

        if (error)
        {
          CFRelease(error);
          id v17 = 0LL;
          error = 0LL;
        }

        else
        {
          id v17 = 0LL;
        }

        goto LABEL_26;
      }

      goto LABEL_32;
    }

NSMutableArray *sub_100004570(uint64_t a1, int a2)
{
  if (!a1) {
    return 0LL;
  }
  id v4 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  LOWORD(v56) = 5632;
  id v5 = -[NSMutableData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSMutableData),  "initWithBytes:length:",  &v56,  2LL);
  id v6 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:48602 notifyData:v5];
  -[NSMutableArray addObject:](v4, "addObject:", v6);

  if (qword_1001DC9A8 != -1) {
    dispatch_once(&qword_1001DC9A8, &stru_1001AFAF8);
  }
  id v7 = (id)qword_1001DC9A0;
  id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 dataUsingEncoding:4]);

  id v9 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:48603 notifyData:v8];
  -[NSMutableArray addObject:](v4, "addObject:", v9);

  if (qword_1001DC998 != -1) {
    dispatch_once(&qword_1001DC998, &stru_1001AFAD8);
  }
  id v10 = (id)qword_1001DC990;
  uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([v10 dataUsingEncoding:4]);

  id v12 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:48604 notifyData:v11];
  -[NSMutableArray addObject:](v4, "addObject:", v12);

  if (qword_1001DCA28 != -1) {
    dispatch_once(&qword_1001DCA28, &stru_1001AFC48);
  }
  LOBYTE(v56) = byte_1001DCA20;
  id v13 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v56, 1LL);
  id v14 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:48606 notifyData:v13];
  -[NSMutableArray addObject:](v4, "addObject:", v14);

  id v15 = sub_10010CD5C();
  -[NSMutableArray addObject:](v4, "addObject:", v15);

  id v16 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 24));
  if (!v16)
  {
    id v44 = sub_100003B10();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v44, 16LL);

    if (IsLevelEnabled)
    {
      id v46 = sub_100003B10();
      _NRLogWithArgs( v46,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRPairingClient copyNotifyPayloadsToSendWithProxy:]",  844);
    }

LABEL_32:
    uint64_t v50 = _os_log_pack_size(12LL);
    v51 = (char *)&v55 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    v52 = __error();
    uint64_t v53 = _os_log_pack_fill( v51,  v50,  *v52,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    *(_DWORD *)uint64_t v53 = 136446210;
    *(void *)(v53 + 4) = "-[NRPairingClient copyNotifyPayloadsToSendWithProxy:]";
    id v54 = sub_100003B10();
    _NRLogAbortWithPack(v54, v51);
    return 0LL;
  }

  id v17 = v16;
  *(void *)&__int128 v56 = *((void *)v16 + 17);
  v18 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v56, 8LL);
  id v19 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:48605 notifyData:v18];

  -[NSMutableArray addObject:](v4, "addObject:", v19);
  uint64_t v20 = (unsigned __int8 *)*(id *)(a1 + 40);
  if (v20)
  {
    int v21 = v20[8];

    if (v21)
    {
      id v22 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 24));
      if (v22)
      {
        id v23 = v22;
        __int128 v56 = 0uLL;
        sub_10012D7C8(v22, &v56);
        uint64_t v24 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v56, 16LL);
        id v25 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50801 notifyData:v24];
        -[NSMutableArray addObject:](v4, "addObject:", v25);

        __int128 v56 = 0uLL;
        sub_10012E070(v23, &v56);
        int v26 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v56, 16LL);
        id v27 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50802 notifyData:v26];
        -[NSMutableArray addObject:](v4, "addObject:", v27);

        __int128 v56 = 0uLL;
        sub_100136A64(v23, &v56);
        id v28 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v56, 16LL);
        id v29 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50811 notifyData:v28];
        -[NSMutableArray addObject:](v4, "addObject:", v29);

        __int128 v56 = 0uLL;
        sub_1001368D4(v23, &v56);
        uint64_t v30 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v56, 16LL);
        id v31 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50812 notifyData:v30];
        -[NSMutableArray addObject:](v4, "addObject:", v31);

        goto LABEL_13;
      }

      id v47 = sub_100003B10();
      int v48 = _NRLogIsLevelEnabled(v47, 16LL);

      if (v48)
      {
        id v49 = sub_100003B10();
        _NRLogWithArgs( v49,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRPairingClient copyNotifyPayloadsToSendWithProxy:]",  850);
      }

      goto LABEL_32;
    }
  }

  -[NSMutableArray addObject:](v3, "addObject:", @"SvcVi");
  if ((a1 & 0x40000) == 0)
  {
LABEL_7:
    if ((a1 & 0x80000) == 0) {
      goto LABEL_8;
    }
    goto LABEL_34;
  }

        id v54 = sub_10010CE6C(v12);
        uint64_t v55 = sub_100075D34(a1, v54);
        __int128 v56 = sub_10007C250(a1);
        v57 = (void *)objc_claimAutoreleasedReturnValue(v56);
        if (v57) {
          -[NSMutableArray addObject:](v55, "addObject:", v57);
        }
        v58 = -[NSMutableArray suspendWhenReady](a1, "suspendWhenReady");
        if ((_DWORD)a4 == 4 && v58)
        {
          v59 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50901 notifyData:0];
          -[NSMutableArray addObject:](v55, "addObject:", v59);
        }

        -[NEIKEv2SessionConfiguration setCustomIKEAuthPrivateNotifies:](v81, "setCustomIKEAuthPrivateNotifies:", v55);
        -[NSMutableArray invalidateIKESessionForClass:](a1, "invalidateIKESessionForClass:", a4);
        v60 = (id *)sub_1000776BC((uint64_t)a1, a4);
        objc_storeStrong(v60, a2);
        sub_100077840(a1, a4);
        uint64_t v20 = (void *)String;
        -[NSMutableArray reportEvent:detailsFormat:]( a1,  "reportEvent:detailsFormat:",  3016LL,  @"%@ %@",  String,  v9);
        a1 = v81;

        id v14 = v81;
        uint64_t v11 = v80;
        goto LABEL_38;
      }

      goto LABEL_33;
    }

    id v13 = *(void *)(a1 + 32);
    id v14 = (void *)NEIKEv2CreateSessionStateString(a2);
    [WeakRetained reportEvent:3009, @"pairing session %@ changed state to %@", v13, v14 detailsFormat];

    if (a2 == 3)
    {
      id v10 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"pairing session IKE %@ disconnected",  *(void *)(a1 + 32));
      goto LABEL_4;
    }

    if (a2 == 2)
    {
      id v15 = mach_absolute_time();
      id v16 = *(void *)(WeakRetained + 1863);
      if (v16) {
        *(void *)(v16 + 120) = v15;
      }
      WeakRetained[234] = 1;
      if (!WeakRetained[242])
      {
        if (*(void *)(WeakRetained + 1287))
        {
          id v17 = sub_100075D34((NSMutableArray *)WeakRetained, 0);
          [WeakRetained reportEvent:3402 details:@"ClassD"];
          v18 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50401 notifyData:*(void *)(WeakRetained + 1287)];
          -[NSMutableArray addObject:](v17, "addObject:", v18);
          if (_os_feature_enabled_impl("terminus", "EncryptedIdentity"))
          {
            id v19 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained nrUUID]);
            uint64_t v20 = sub_100132028((uint64_t)&OBJC_CLASS___NRDLocalDevice, v19);

            if (v20)
            {
              [WeakRetained reportEvent:3400 details:@"Identity"];
              int v21 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50351 notifyData:v20];
              -[NSMutableArray addObject:](v17, "addObject:", v21);
            }
          }

          sub_10007F2EC((uint64_t)WeakRetained);
          id v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(WeakRetained + 1247) description]);
          id v23 = *(void **)(WeakRetained + 1247);
          uint64_t v24 = *((void *)WeakRetained + 1);
          v40[0] = _NSConcreteStackBlock;
          v40[1] = 3221225472LL;
          v40[2] = sub_10007F300;
          v40[3] = &unk_1001AEC58;
          id v25 = WeakRetained;
          v41 = v25;
          id v42 = v22;
          int v26 = v22;
          [v23 sendPrivateNotifies:v17 maxRetries:10 retryIntervalInMilliseconds:10000 callbackQueue:v24 callback:v40];
          sub_1000764AC((uint64_t)v25, v27);
          sub_10007669C((uint64_t)v25, v28);
        }

        id v10 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        if (*(void *)(WeakRetained + 1263))
        {
          [WeakRetained reportEvent:3400 details:@"ClassD"];
          id v29 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50411 notifyData:*(void *)(WeakRetained + 1263)];
          -[NSMutableArray addObject:](v10, "addObject:", v29);
          sub_10007F3EC((uint64_t)WeakRetained);
        }

        if (*(void *)(WeakRetained + 1271))
        {
          [WeakRetained reportEvent:3400 details:@"ClassC"];
          uint64_t v30 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50412 notifyData:*(void *)(WeakRetained + 1271)];
          -[NSMutableArray addObject:](v10, "addObject:", v30);
          sub_10007F400((uint64_t)WeakRetained);
        }

        if (*(void *)(WeakRetained + 1279))
        {
          [WeakRetained reportEvent:3400 details:@"ClassA"];
          id v31 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50413 notifyData:*(void *)(WeakRetained + 1279)];
          -[NSMutableArray addObject:](v10, "addObject:", v31);
          sub_10007F414((uint64_t)WeakRetained);
        }

        if (-[NSMutableArray count](v10, "count"))
        {
          if (_os_feature_enabled_impl("terminus", "EncryptedIdentity"))
          {
            uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained nrUUID]);
            id v33 = sub_100132028((uint64_t)&OBJC_CLASS___NRDLocalDevice, v32);

            if (v33)
            {
              [WeakRetained reportEvent:3400 details:@"Identity"];
              id v34 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50351 notifyData:v33];
              -[NSMutableArray addObject:](v10, "addObject:", v34);
            }
          }

          id v35 = sub_100075D34((NSMutableArray *)WeakRetained, 0);
          -[NSMutableArray addObjectsFromArray:](v10, "addObjectsFromArray:", v35);

          id v36 = *(void **)(WeakRetained + 1247);
          id v37 = *((void *)WeakRetained + 1);
          v38[0] = _NSConcreteStackBlock;
          v38[1] = 3221225472LL;
          v38[2] = sub_10007F428;
          v38[3] = &unk_1001AEEF8;
          unsigned __int8 v39 = WeakRetained;
          [v36 sendPrivateNotifies:v10 maxRetries:10 retryIntervalInMilliseconds:10000 callbackQueue:v37 callback:v38];
        }

        goto LABEL_32;
      }
    }
  }
}

    id v42 = 15000000000LL;
    if (!*(_BYTE *)(a1 + 27))
    {
      v43 = *(unsigned __int8 *)(a1 + 40);
      if (v43 == 5 || v43 == 2)
      {
        id v44 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v3);
        v45 = _NRLogIsLevelEnabled(v44, 0LL);

        if (v45)
        {
          id v47 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v46);
          _NRLogWithArgs( v47,  0LL,  "%s%.30s:%-4d Skipping companion Link viability hysteresis timer",  "",  "-[NRDDeviceConductor updateCompanionLinkViability]",  1467);
        }

        id v42 = 0LL;
      }
    }

    goto LABEL_38;
  }

  v18 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v3);
  id v19 = _NRLogIsLevelEnabled(v18, 0LL);

  if (!v19) {
    goto LABEL_16;
  }
  id v7 = *(id *)(a1 + 96);
  id v9 = _NRCopyLogObjectForNRUUID(v7, v20);
  id v10 = (void *)v9;
  uint64_t v11 = *(void *)(a1 + 128);
  id v12 = 1461LL;
LABEL_15:
  _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d Companion Link viable due to primary link: %@",  "",  "-[NRDDeviceConductor updateCompanionLinkViability]",  v12,  v11);

LABEL_16:
  int v21 = *(void *)(a1 + 384);
  ++*(void *)(a1 + 392);
  if (v21)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v21 + 40));
    if (([(id)v21 isActive] & 1) == 0)
    {
      [(id)v21 setActive:1];
      [*(id *)(v21 + 48) updateNetworkAgent:v21];
      id v22 = *(void **)(v21 + 32);
      id v23 = *(id *)(v21 + 64);
      uint64_t v24 = v22;
      id v25 = (void *)objc_claimAutoreleasedReturnValue([(id)v21 agentUUID]);
      int v26 = (void *)objc_claimAutoreleasedReturnValue([v25 UUIDString]);
      sub_10011BB18(v24, 19005, v23, v26);
    }
  }

  id v27 = *(void *)(a1 + 448);
  if (v27 && !*(_BYTE *)(a1 + 44) && !*(_BYTE *)(a1 + 58))
  {
    id v28 = (void *)NEVirtualInterfaceCopyName(v27);
    id v29 = objc_alloc(&OBJC_CLASS___NEPolicy);
    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult scopeSocketToInterfaceName:]( &OBJC_CLASS___NEPolicyResult,  "scopeSocketToInterfaceName:",  v28));
    id v31 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition accountIdentifier:]( &OBJC_CLASS___NEPolicyCondition,  "accountIdentifier:",  @"com.apple.networkrelay.cmpn-link-monitor"));
    location[0] = v31;
    uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
    location[1] = v32;
    id v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", location, 2LL));
    id v34 = [v29 initWithOrder:50 result:v30 conditions:v33];

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v35 = (id)qword_1001DCB58;
    id v36 = sub_100120E44((uint64_t)v35, *(void **)(a1 + 536), v34);

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v37 = (id)qword_1001DCB58;
    id v38 = (id *)v37;
    if (v37)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v37 + 1));
      if (([v38[2] apply] & 1) == 0) {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v39,  v40,  v41,  v52);
      }
    }

    *(_BYTE *)(a1 + 58) = 1;
  }
}

    id v25 = 0LL;
    goto LABEL_27;
  }

  if (!v8)
  {
    uint64_t v30 = sub_10013A600();
    id v31 = _NRLogIsLevelEnabled(v30, 17LL);

    if (v31)
    {
      StringFromNRLinkType = sub_10013A600();
      _NRLogWithArgs(StringFromNRLinkType, 17LL, "%s called with null localEndpoint");
      goto LABEL_25;
    }

    goto LABEL_32;
  }

  if ([(id)a1 shouldCreateLinkForNRUUID:v7])
  {
    if (v9)
    {
      id v12 = (void *)objc_claimAutoreleasedReturnValue([v9 hostname]);
      objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
      if (qword_1001DC640 != -1) {
        dispatch_once(&qword_1001DC640, &stru_1001ADE98);
      }
      id v13 = (id)qword_1001DC638;
      if (v13) {
        id v14 = @"62743";
      }
      else {
        id v14 = 0LL;
      }
      id v15 = v14;
      id v16 = objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v12,  v15));

      id v9 = (id)v16;
    }

    id v17 = objc_alloc(&OBJC_CLASS___NRLinkWiFi);
    if (a1) {
      v18 = *(void **)(a1 + 24);
    }
    else {
      v18 = 0LL;
    }
    StringFromNRLinkType = v18;
    uint64_t v20 = *(void **)(a1 + 104);
    if (v20) {
      uint64_t v20 = (void *)v20[3];
    }
    int v21 = v20;
    objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
    if (qword_1001DC640 != -1) {
      dispatch_once(&qword_1001DC640, &stru_1001ADE98);
    }
    id v22 = (id)qword_1001DC638;
    id v23 = @"62743";
    if (!v22) {
      id v23 = 0LL;
    }
    uint64_t v24 = v23;
    id v25 = -[NRLinkWiFi initLinkWithQueue:linkDelegate:nrUUID:wifiInterfaceName:localOuterEndpoint:remoteOuterEndpoint:listenerPortString:]( v17,  "initLinkWithQueue:linkDelegate:nrUUID:wifiInterfaceName:localOuterEndpoint:remoteOuterEndpoint:listenerPortString:",  StringFromNRLinkType,  a1,  v7,  v21,  v8,  v9,  v24);

    goto LABEL_26;
  }

  if (a1) {
    int v26 = *(unsigned __int8 *)(a1 + 8);
  }
  else {
    int v26 = 0LL;
  }
  StringFromNRLinkType = (id)createStringFromNRLinkType(v26);
  [(id)a1 reportEvent:3200, @"unsupported link type: %@", StringFromNRLinkType detailsFormat];
LABEL_25:
  id v25 = 0LL;
LABEL_26:

LABEL_27:
  return v25;
}

LABEL_13:
  if (a2)
  {
    uint64_t v32 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 24));
    id v33 = v32;
    if (v32) {
      id v34 = (void *)*((void *)v32 + 16);
    }
    else {
      id v34 = 0LL;
    }
    id v35 = v34;
    id v36 = [v35 proxyCapability];

    if (v36 == (id)1)
    {
      if (v33) {
        id v37 = (void *)*((void *)v33 + 16);
      }
      else {
        id v37 = 0LL;
      }
      id v38 = v37;
      unsigned __int8 v39 = [v38 hasCompanionDatapath];

      if ((v39 & 1) != 0)
      {
        v40 = 0LL;
      }

      else
      {
        v41 = *(void **)(a1 + 40);
        if (v41) {
          v41 = (void *)v41[4];
        }
        v40 = v41;
      }

      id v42 = sub_10010CEF4(v33, v40);
      -[NSMutableArray addObject:](v4, "addObject:", v42);
    }
  }

  return v4;
}
}
}

  id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), __src);
  id v13 = _NRLogIsLevelEnabled(v12, 17LL);

  if (v13)
  {
    id v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v14);
    id v16 = [(id)a1 copyDescription];
    id v17 = v16;
    v18 = "";
    if ((_DWORD)a4) {
      v18 = "urgent ";
    }
    _NRLogWithArgs(v15, 17LL, "%@: %spipe received no data", v16, v18);
  }

  [(id)a1 cancelWithReason:@"pipe received no data"];
}

  if (qword_1001DC8B0 != -1) {
    dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC8A8, 1LL))
  {
    if (qword_1001DC8B0 != -1) {
      dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
    }
    int v21 = (id)qword_1001DC8A8;
    id v22 = (void *)objc_claimAutoreleasedReturnValue([v14 neighbor]);
    _NRLogWithArgs( v21,  1LL,  "%s%.30s:%-4d already have pending seqno req for %@, ignoring request for %u from %@ to %@",  "",  "-[NRBabelInstance sendSeqnoReqIfNecessaryTo:forPrefix:routerID:seqno:hopCount:originator:]",  3116LL,  v17,  v10,  v15,  v22);
  }

      id v25 = 0LL;
      goto LABEL_14;
    }

    id v7 = *(NEIKEv2Listener **)((char *)&self->_ikeListener + 7);
    if (!v7)
    {
      id v8 = sub_1000C449C();
      id v9 = _NRLogIsLevelEnabled(v8, 17LL);

      if (v9)
      {
        id v10 = sub_1000C449C();
        _NRLogWithArgs(v10, 17LL, "%s called with null _ikeSessionClassD");
LABEL_12:

        goto LABEL_13;
      }

      goto LABEL_13;
    }
  }

  uint64_t v11 = v7;
  [v11 setClientQueue:self->super._queue];
  objc_initWeak(location, self);
  v62[0] = _NSConcreteStackBlock;
  v62[1] = 3221225472LL;
  v62[2] = sub_1000C4680;
  v62[3] = &unk_1001AF2D8;
  objc_copyWeak(&v65, location);
  v66 = v3;
  id v12 = String;
  v63 = v12;
  id v13 = v11;
  v64 = v13;
  [v13 setStateUpdateBlock:v62];
  v57[0] = _NSConcreteStackBlock;
  v57[1] = 3221225472LL;
  v57[2] = sub_1000C4DA4;
  v57[3] = &unk_1001AF300;
  objc_copyWeak(&v60, location);
  id v14 = v12;
  v58 = v14;
  id v15 = v13;
  v59 = v15;
  v61 = v3;
  [v15 setChildStateUpdateBlock:v57];
  v53[0] = _NSConcreteStackBlock;
  v53[1] = 3221225472LL;
  v53[2] = sub_1000C4EC8;
  v53[3] = &unk_1001AF328;
  objc_copyWeak(&v56, location);
  id v16 = v14;
  id v54 = v16;
  id v17 = v15;
  uint64_t v55 = v17;
  [v17 setConfigurationUpdateBlock:v53];
  v49[0] = _NSConcreteStackBlock;
  v49[1] = 3221225472LL;
  v49[2] = sub_1000C4F94;
  v49[3] = &unk_1001AF350;
  objc_copyWeak(&v52, location);
  v18 = v16;
  uint64_t v50 = v18;
  id v19 = v17;
  v51 = v19;
  [v19 setTrafficSelectorUpdateBlock:v49];
  v45[0] = _NSConcreteStackBlock;
  v45[1] = 3221225472LL;
  v45[2] = sub_1000C5080;
  v45[3] = &unk_1001AF378;
  objc_copyWeak(&v48, location);
  uint64_t v20 = v18;
  id v46 = v20;
  int v21 = v19;
  id v47 = v21;
  [v21 setAdditionalAddressesUpdateBlock:v45];
  v41[0] = _NSConcreteStackBlock;
  v41[1] = 3221225472LL;
  v41[2] = sub_1000C514C;
  v41[3] = &unk_1001AF3A0;
  objc_copyWeak(&v44, location);
  id v22 = v20;
  id v42 = v22;
  id v23 = v21;
  v43 = v23;
  [v23 setShortDPDEventBlock:v41];
  v37[0] = _NSConcreteStackBlock;
  v37[1] = 3221225472LL;
  v37[2] = sub_1000C520C;
  v37[3] = &unk_1001AF378;
  objc_copyWeak(&v40, location);
  uint64_t v24 = v22;
  id v38 = v24;
  id v25 = v23;
  unsigned __int8 v39 = v25;
  [v25 setPrivateNotifyStatusEvent:v37];
  id v27 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v26);
  LOBYTE(v11) = _NRLogIsLevelEnabled(v27, 0LL);

  if ((v11 & 1) != 0)
  {
    id v29 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v28);
    uint64_t v30 = -[NRLink copyDescription](self, "copyDescription");
    _NRLogWithArgs( v29,  0LL,  "%s%.30s:%-4d %@: Setup IKE %@ %@ callbacks",  "",  "-[NRLinkWired setupIKECallbacks:]",  562LL,  v30,  v24,  v25);
  }

  objc_destroyWeak(&v40);
  objc_destroyWeak(&v44);

  objc_destroyWeak(&v48);
  objc_destroyWeak(&v52);

  objc_destroyWeak(&v56);
  objc_destroyWeak(&v60);

  objc_destroyWeak(&v65);
  objc_destroyWeak(location);

LABEL_14:
}

  if ((*(_BYTE *)(a1 + 592) & 4) == 0)
  {
    id v9 = *(id *)(a1 + 624);
    if (v9 && v9[7] || (uint64_t v30 = *(void *)(a1 + 624)) == 0)
    {
    }

    else
    {
      id v31 = *(void *)(v30 + 48);

      if (v31)
      {
        uint64_t v32 = mach_absolute_time();
        id v33 = *(void *)(a1 + 624);
        if (v33) {
          *(void *)(v33 + 56) = v32;
        }
      }
    }
  }

  unsigned int v3 = v83;
  if (!*(_BYTE *)(a1 + 14))
  {
    id v29 = *(void *)(a1 + 592);
    if ((v29 & 4) == 0)
    {
LABEL_45:
      v3[12] = v29;
      v3[13] |= *(void *)(a1 + 600);
      id v34 = objc_alloc(&OBJC_CLASS___NRAnalyticsLinkUpgradeReport);
      id v35 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      id v38 = v83;
      unsigned __int8 v39 = v83[6];
      v40 = 0.0;
      p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
      id v42 = 0.0;
      if (v39)
      {
        v43 = v83[7];
        id v44 = v43 >= v39;
        v45 = v43 - v39;
        if (v45 != 0 && v44)
        {
          if (qword_1001DC9F0 != -1)
          {
            v81 = v45;
            dispatch_once(&qword_1001DC9F0, &stru_1001AFB98);
            v45 = v81;
            id v38 = v83;
            p_class_meths = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
          }

          LODWORD(v36) = dword_1001DC9F8;
          LODWORD(v37) = *(_DWORD *)algn_1001DC9FC;
          id v37 = (double)*(unint64_t *)&v37;
          id v36 = 0.000000001 * (double)*(unint64_t *)&v36;
          id v42 = (double)v45 * v36 / v37;
        }
      }

      id v46 = v38[8];
      if (v46)
      {
        id v47 = v38[9];
        id v44 = v47 >= v46;
        int v48 = v47 - v46;
        if (v48 != 0 && v44)
        {
          if (p_class_meths[318] != (__objc2_meth_list *)-1LL)
          {
            v82 = v48;
            dispatch_once(&qword_1001DC9F0, &stru_1001AFB98);
            int v48 = v82;
          }

          LODWORD(v36) = dword_1001DC9F8;
          LODWORD(v37) = *(_DWORD *)algn_1001DC9FC;
          v40 = (double)v48 * (0.000000001 * (double)*(unint64_t *)&v36) / (double)*(unint64_t *)&v37;
        }
      }

      id v49 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  *((unsigned __int8 *)v83 + 8)));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v49,  @"upgradeType");

      uint64_t v50 = v83;
      if (v83[4] || v83[12])
      {
        v51 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:"));
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v51,  @"startAdvice");

        v52 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  v83[12]));
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v52,  @"endAdvice");

        uint64_t v53 = sub_100066C9C(v83[5]);
        id v54 = (void *)objc_claimAutoreleasedReturnValue(v53);
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v54,  @"startReason");

        uint64_t v55 = sub_100066C9C(v83[13]);
        __int128 v56 = (void *)objc_claimAutoreleasedReturnValue(v55);
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v56,  @"endReason");

        uint64_t v50 = v83;
      }

      v57 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  *((unsigned __int8 *)v50 + 9)));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v57,  @"thermalState");

      v58 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  *((unsigned __int8 *)v83 + 10)));
      -[NSMutableDictionary setObject:forKeyedSubscript:](v35, "setObject:forKeyedSubscript:", v58, @"battery");

      v59 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  (unint64_t)v42));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v59,  @"adviceDuration");

      if (v40 > 0.0)
      {
        v60 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  (unint64_t)v40));
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v60,  @"clientTriggerDuration");

        if (v42 > 0.0)
        {
          v61 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  v83[6] <= (unint64_t)v83[8]));
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v61,  @"adviceStartBeforeClient");

          v62 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  v83[7] <= (unint64_t)v83[9]));
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v62,  @"adviceEndBeforeClient");
        }
      }

      v63 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  *((unsigned __int8 *)v83 + 11)));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v63,  @"primaryLinkType");

      v64 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  *((unsigned __int8 *)v83 + 12)));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v64,  @"primaryLinkSubtype");

      v65 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)v83 + 5)));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v65,  @"adviceCount");

      v66 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedInt:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedInt:",  *((unsigned int *)v83 + 6)));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v66,  @"clientTriggerCount");

      v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](&OBJC_CLASS___NSNumber, "numberWithInt:", v83[2] & 1));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v67,  @"clientTriggered");

      v68 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  (*((_DWORD *)v83 + 4) >> 1) & 1));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v68,  @"aluTriggered");

      v69 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  (*((_DWORD *)v83 + 4) >> 11) & 1));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v69,  @"upgradeSuccessful");

      v70 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  (*((_DWORD *)v83 + 4) >> 2) & 1));
      -[NSMutableDictionary setObject:forKeyedSubscript:](v35, "setObject:forKeyedSubscript:", v70, @"againstWRM");

      v71 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  (*((_DWORD *)v83 + 4) >> 3) & 1));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v71,  @"advisedWithNoLink");

      v72 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  (*((_DWORD *)v83 + 4) >> 4) & 1));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v72,  @"overlappingAdvice");

      v73 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  (*((_DWORD *)v83 + 4) >> 5) & 1));
      -[NSMutableDictionary setObject:forKeyedSubscript:](v35, "setObject:forKeyedSubscript:", v73, @"pluggedIn");

      v74 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  (*((_DWORD *)v83 + 4) >> 6) & 1));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v74,  @"lowPowerMode");

      v75 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  (*((_DWORD *)v83 + 4) >> 8) & 1));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v75,  @"activePhoneCall");

      v76 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  (*((_DWORD *)v83 + 4) >> 9) & 1));
      -[NSMutableDictionary setObject:forKeyedSubscript:](v35, "setObject:forKeyedSubscript:", v76, @"dtcRequest");

      v77 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithInt:]( &OBJC_CLASS___NSNumber,  "numberWithInt:",  (*((_DWORD *)v83 + 4) >> 10) & 1));
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v35,  "setObject:forKeyedSubscript:",  v77,  @"thermalWorsened");

      id v13 = sub_10011B994(v34, v35);
      [v13 submit];
      v78 = *((unsigned __int8 *)v83 + 8);
      if (v78 == 1)
      {
        v79 = 616LL;
        goto LABEL_69;
      }

      if (v78 == 2)
      {
        v79 = 624LL;
LABEL_69:
        v80 = *(void **)(a1 + v79);
        *(void *)(a1 + v79) = 0LL;
      }

      uint64_t v11 = application_service_name;

      if (v11)
      {
        id v12 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v11));
        id v13 = *(void **)(a1 + 24);
        *(void *)(a1 + 24) = v12;
LABEL_16:
      }
}

      id v12 = NEVirtualInterfaceSetRankLast(v11, 1LL);
      goto LABEL_16;
    }

    if ((v9 & 1) == 0)
    {
      id v13 = v5[16];
      if ([v13 hasPoliciesForProxyCriteria])
      {
        id v14 = v5[16];
        id v15 = (void *)objc_claimAutoreleasedReturnValue([v14 proxyProviderCriteria]);
        id v16 = [v15 forwardNonMatchingTraffic];

        if (v16)
        {
          uint64_t v11 = -[NRLink virtualInterface](self, "virtualInterface");
          goto LABEL_13;
        }
      }

      else
      {
      }
    }

    id v12 = NEVirtualInterfaceSetRankNever(-[NRLink virtualInterface](self, "virtualInterface"), 1LL);
    goto LABEL_16;
  }

  return NEVirtualInterfaceSetRankNever(-[NRLink virtualInterface](self, "virtualInterface"), 1LL) != 0;
}
  }

  return v5;
}
}
        }

        id v6 = [v4 countByEnumeratingWithState:&v16 objects:v20 count:16];
        if (!v6) {
          goto LABEL_29;
        }
      }
    }

    LOBYTE(v8) = 1;
LABEL_29:
  }

  else
  {
LABEL_27:
    LOBYTE(v8) = 0;
  }

  return v8 & 1;
}

LABEL_15:
  return v19;
}

uint64_t sub_100004C0C(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 1:
      uint64_t v2 = 104LL;
      return a1 + v2;
    case 4:
      uint64_t v2 = 88LL;
      return a1 + v2;
    case 3:
      uint64_t v2 = 96LL;
      return a1 + v2;
  }

  HIDWORD(v15) = a2;
  id v4 = sub_100003B10();
  int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16LL);

  if (IsLevelEnabled)
  {
    id v6 = sub_100003B10();
    String = (void *)NRDataProtectionClassCreateString(HIDWORD(v15));
    _NRLogWithArgs( v6,  16LL,  "%s%.30s:%-4d ABORTING: Cannot copy IKE session pointer for %@",  "",  "-[NRPairingClient ikeSessionPointerForDataProtectionClass:]",  781LL,  String);
  }

  uint64_t v8 = _os_log_pack_size(22LL);
  id v9 = (char *)&v15 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
  id v10 = __error();
  uint64_t v11 = _os_log_pack_fill( v9,  v8,  *v10,  &_mh_execute_header,  "%{public}s Cannot copy IKE session pointer for %@");
  uint64_t v12 = NRDataProtectionClassCreateString(HIDWORD(v15));
  *(_DWORD *)uint64_t v11 = 136446466;
  *(void *)(v11 + 4) = "-[NRPairingClient ikeSessionPointerForDataProtectionClass:]";
  *(_WORD *)(v11 + 12) = 2112;
  *(void *)(v11 + 14) = v12;
  id v13 = sub_100003B10();
  uint64_t v14 = _NRLogAbortWithPack(v13, v9);
  return sub_100004D7C(v14);
}

void sub_100004D7C(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a1 + 8) & 0xFE) != 6)
  {
    int v2 = a2;
    String = (void *)NRDataProtectionClassCreateString(a2);
    switch(v2)
    {
      case 1:
        id v5 = *(void **)(a1 + 104);
        if (v5)
        {
          uint64_t v6 = 8LL;
          goto LABEL_11;
        }

        id v12 = sub_100003B10();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 17LL);

        if (IsLevelEnabled)
        {
          id v11 = sub_100003B10();
          _NRLogWithArgs(v11, 17LL, "%s called with null _ikeSessionClassA");
          goto LABEL_27;
        }

        break;
      case 3:
        id v5 = *(void **)(a1 + 96);
        if (v5)
        {
          uint64_t v6 = 4LL;
          goto LABEL_11;
        }

        id v14 = sub_100003B10();
        int v15 = _NRLogIsLevelEnabled(v14, 17LL);

        if (v15)
        {
          id v11 = sub_100003B10();
          _NRLogWithArgs(v11, 17LL, "%s called with null _ikeSessionClassC");
          goto LABEL_27;
        }

        break;
      case 4:
        id v5 = *(void **)(a1 + 88);
        if (v5)
        {
          uint64_t v6 = 2LL;
LABEL_11:
          id v7 = v5;
          [v7 setClientQueue:*(void *)(a1 + 32)];
          objc_initWeak(&location, (id)a1);
          v16[0] = _NSConcreteStackBlock;
          v16[1] = 3221225472LL;
          v16[2] = sub_100005020;
          v16[3] = &unk_1001ADDE0;
          objc_copyWeak(v20, &location);
          char v21 = v2;
          id v17 = String;
          id v8 = v7;
          v20[1] = (id)v6;
          id v18 = v8;
          uint64_t v19 = a1;
          [v8 setStateUpdateBlock:v16];

          objc_destroyWeak(v20);
          objc_destroyWeak(&location);

LABEL_19:
          return;
        }

        id v9 = sub_100003B10();
        int v10 = _NRLogIsLevelEnabled(v9, 17LL);

        if (v10)
        {
          id v11 = sub_100003B10();
          _NRLogWithArgs(v11, 17LL, "%s called with null _ikeSessionClassD");
LABEL_27:
        }

        break;
      default:
        if (qword_1001DC630 != -1) {
          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC628, 17LL))
        {
          if (qword_1001DC630 != -1) {
            dispatch_once(&qword_1001DC630, &stru_1001ADE00);
          }
          _NRLogWithArgs(qword_1001DC628, 17LL, "%@: Cannot setup IKE callbacks", a1);
        }

        break;
    }

    id v8 = 0LL;
    goto LABEL_19;
  }

void sub_100005004(_Unwind_Exception *a1)
{
}

void sub_100005020(uint64_t a1, uint64_t a2, void *a3)
{
  id v36 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if (!WeakRetained) {
    goto LABEL_27;
  }
  if (!v36)
  {
    uint64_t v12 = *(void *)(a1 + 40);
    SessionStateString = (void *)NEIKEv2CreateSessionStateString(a2);
    sub_100003B50(WeakRetained, 3009, @"IKE session %@ changed state to %@", v13, v14, v15, v16, v17, v12);

    switch(a2)
    {
      case 1LL:
        goto LABEL_27;
      case 2LL:
        WeakRetained[6] |= *(void *)(a1 + 64);
        sub_100005794((uint64_t)WeakRetained, 4, 0);
        id v23 = (id)WeakRetained[3];
        uint64_t v24 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v23);
        id v25 = (void *)WeakRetained[14];
        WeakRetained[14] = v24;

        if ((~*((_DWORD *)WeakRetained + 12) & 6LL) != 0) {
          goto LABEL_24;
        }
        uint64_t v26 = WeakRetained[14];
        if ((WeakRetained[6] & 8) != 0)
        {
          if (!v26) {
            goto LABEL_23;
          }
        }

        else if (!v26 || *(unsigned __int16 *)(v26 + 28) <= 0x12u)
        {
LABEL_24:
          uint64_t v32 = (unsigned __int8 *)(id)WeakRetained[5];
          if (v32)
          {
            int v33 = v32[14];

            if (v33)
            {
              sub_100005BE0(*(void *)(a1 + 48), 4LL);
              sub_100005BE0(*(void *)(a1 + 48), 3LL);
              sub_100005BE0(*(void *)(a1 + 48), 1LL);
            }
          }

          goto LABEL_27;
        }

        if (*(unsigned __int16 *)(v26 + 28) >= 0x10u)
        {
          uint64_t v27 = WeakRetained[5];
          if (!v27 || !*(_BYTE *)(v27 + 8))
          {
            id v28 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
            id v29 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:51601 notifyData:0];
            -[NSMutableArray addObject:](v28, "addObject:", v29);
            objc_initWeak(&location, WeakRetained);
            uint64_t v30 = (void *)WeakRetained[10];
            uint64_t v31 = WeakRetained[4];
            v37[0] = _NSConcreteStackBlock;
            v37[1] = 3221225472LL;
            v37[2] = sub_100005E70;
            v37[3] = &unk_1001AF950;
            objc_copyWeak(&v38, &location);
            [v30 sendPrivateNotifies:v28 maxRetries:10 retryIntervalInMilliseconds:3000 callbackQueue:v31 callback:v37];
            objc_destroyWeak(&v38);
            objc_destroyWeak(&location);
          }

          goto LABEL_24;
        }

LABEL_23:
        sub_100005FF4((uint64_t)WeakRetained);
        goto LABEL_24;
      case 3LL:
        if (*(_BYTE *)(a1 + 72) == 1) {
          sub_100005354((uint64_t)WeakRetained);
        }
        sub_100003B50( WeakRetained,  3018,  @"%@ session %@ got IKE Disconnected state with no error",  v18,  v19,  v20,  v21,  v22,  *(void *)(a1 + 32));
        goto LABEL_6;
      default:
        sub_100005DB0((uint64_t)WeakRetained);
        sub_100005794((uint64_t)WeakRetained, 6, 0);
        goto LABEL_27;
    }
  }

  if (*(_BYTE *)(a1 + 72) == 1) {
    sub_100005354((uint64_t)WeakRetained);
  }
  uint64_t v6 = *(void *)(a1 + 32);
  id v35 = (void *)NEIKEv2CreateSessionStateString(a2);
  sub_100003B50(WeakRetained, 3018, @"%@ session %@ got IKE error %@ with state %@", v7, v8, v9, v10, v11, v6);

LABEL_6:
  if ((*(void *)(a1 + 64) & WeakRetained[6]) == 0LL) {
    sub_1000055CC(WeakRetained, *(unsigned __int8 *)(a1 + 72));
  }
LABEL_27:
}

      uint64_t v20 = (void *)String;
      -[NSMutableArray reportEvent:detailsFormat:]( a1,  "reportEvent:detailsFormat:",  3021LL,  @"%@ %@",  String,  v9,  v75);
      goto LABEL_24;
    }

    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue([v10 remoteIdentifier]);
    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([v10 localIdentifier]);
    id v23 = v9;
    uint64_t v24 = v22;
    v77 = v23;
    id v25 = sub_10012A74C((uint64_t)&OBJC_CLASS___NRDLocalDevice, v21, v22, v23);

    uint64_t v27 = _NRCopyLogObjectForNRUUID(a1[4].super.super.isa, v26);
    id v28 = (void *)v27;
    if (v25)
    {
      int IsLevelEnabled = _NRLogIsLevelEnabled(v27, 1LL);

      if (IsLevelEnabled)
      {
        uint64_t v31 = (void *)_NRCopyLogObjectForNRUUID(a1[4].super.super.isa, v30);
        uint64_t v32 = -[NSMutableArray copyDescription](a1, "copyDescription");
        int v33 = v25->_identity;
        _NRLogWithArgs( v31,  1LL,  "%s%.30s:%-4d %@: Decrypted device identity %@",  "",  "-[NRLinkBluetooth respondToIKESession:sessionConfig:dataProtectionClass:validateAuthBlock:]",  9140LL,  v32,  v33);
      }

      id v34 = v25->_nrUUID;

      if (v34)
      {
        id v36 = v25->_nrUUID;
        id v37 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray nrUUID](a1, "nrUUID"));
        id v38 = -[NSUUID isEqual:](v36, "isEqual:", v37);

        if ((v38 & 1) != 0)
        {

          uint64_t v11 = v80;
          uint64_t v14 = v81;
          uint64_t v9 = v77;
          if ((v80[2](v80, v81) & 1) != 0)
          {
            v40 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray nrUUID](a1, "nrUUID"));
            sub_100136544((uint64_t)&OBJC_CLASS___NRDLocalDevice, v40);

            goto LABEL_20;
          }

          goto LABEL_23;
        }

        v70 = (void *)_NRCopyLogObjectForNRUUID(a1[4].super.super.isa, v39);
        v71 = _NRLogIsLevelEnabled(v70, 16LL);

        uint64_t v9 = v77;
        if (v71)
        {
          v64 = (void *)_NRCopyLogObjectForNRUUID(a1[4].super.super.isa, v72);
          v65 = -[NSMutableArray copyDescription](a1, "copyDescription");
          v69 = v25->_identity;
          v73 = v25->_nrUUID;
          v74 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray nrUUID](a1, "nrUUID"));
          _NRLogWithArgs( v64,  16LL,  "%s%.30s:%-4d %@: Different device found for identity %@ (%@ != %@)",  "",  "-[NRLinkBluetooth respondToIKESession:sessionConfig:dataProtectionClass:validateAuthBlock:]",  9151LL,  v65,  v69,  v73,  v74);

          uint64_t v9 = v77;
          goto LABEL_46;
        }
      }

      else
      {
        v66 = (void *)_NRCopyLogObjectForNRUUID(a1[4].super.super.isa, v35);
        v67 = _NRLogIsLevelEnabled(v66, 16LL);

        uint64_t v9 = v77;
        if (v67)
        {
          v64 = (void *)_NRCopyLogObjectForNRUUID(a1[4].super.super.isa, v68);
          v65 = -[NSMutableArray copyDescription](a1, "copyDescription");
          v69 = v25->_identity;
          _NRLogWithArgs( v64,  16LL,  "%s%.30s:%-4d %@: No device found for identity %@",  "",  "-[NRLinkBluetooth respondToIKESession:sessionConfig:dataProtectionClass:validateAuthBlock:]",  9144LL,  v65,  v69);
LABEL_46:

          goto LABEL_47;
        }
      }
    }

    else
    {
      v62 = _NRLogIsLevelEnabled(v27, 16LL);

      uint64_t v9 = v77;
      if (v62)
      {
        v64 = (void *)_NRCopyLogObjectForNRUUID(a1[4].super.super.isa, v63);
        v65 = -[NSMutableArray copyDescription](a1, "copyDescription");
        _NRLogWithArgs( v64,  16LL,  "%s%.30s:%-4d %@: Failed to decrypt device identity",  "",  "-[NRLinkBluetooth respondToIKESession:sessionConfig:dataProtectionClass:validateAuthBlock:]",  9136LL,  v65);
LABEL_47:
      }
    }

    uint64_t v20 = (void *)String;
    -[NSMutableArray reportEvent:detailsFormat:]( a1,  "reportEvent:detailsFormat:",  3023LL,  @"%@ %@ %@",  String,  v9,  v12);

    goto LABEL_10;
  }
}
}

    os_log_t v1 = (void *)NEVirtualInterfaceCopyAddresses(v5[56]);
    unsigned int v3 = (void *)NEVirtualInterfaceCopyName(v5[56]);
    uint64_t v32 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v32);

    id v4 = (void *)sub_10012D45C((void *)v7, @"0");
    int v33 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v33);

    uint64_t v2 = sub_10012CD2C((void *)v7, @"0");
    sub_1000EBC48((uint64_t)v5, v5[12]);
    id v35 = 0;
    if (*(_BYTE *)(v7 + 12) && v2)
    {
      if (v1
        && (id v36 = (void *)objc_claimAutoreleasedReturnValue([v2 hostname]),
            id v37 = [v1 containsObject:v36],
            v36,
            (v37 & 1) != 0))
      {
        id v35 = 0;
      }

      else
      {
        v99 = v4;
        id v38 = v5[56];
        unsigned __int8 v39 = (void *)objc_claimAutoreleasedReturnValue([v2 hostname]);
        NEVirtualInterfaceAddAddress(v38, v39, @"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff");

        NEVirtualInterfaceAddAddress(v5[56], @"192.0.0.6", @"255.255.255.255");
        v40 = sub_100146AFC();
        dispatch_assert_queue_V2((dispatch_queue_t)v40);

        v41 = sub_10012D254((void *)v7, @"0");
        id v42 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:",  v41,  128LL));

        if (!v42)
        {
          v84 = sub_1000D54AC();
          v85 = _NRLogIsLevelEnabled(v84, 16LL);

          if (v85)
          {
            v86 = sub_1000D54AC();
            _NRLogWithArgs( v86,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (conditionPrefix) != ((void *)0)",  "",  "-[NRDDeviceConductor setupCatchAllInterfaceIfApplicable]",  7872);
          }

          goto LABEL_66;
        }

        v43 = objc_alloc(&OBJC_CLASS___NEPolicy);
        id v44 = v3;
        unsigned int v3 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v3,  0LL));
        v102[0] = v42;
        id v4 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
        v102[1] = v4;
        v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v102, 2LL));
        id v46 = [v43 initWithOrder:4000 result:v3 conditions:v45];

        if (!v46)
        {
          v88 = sub_1000D54AC();
          v89 = _NRLogIsLevelEnabled(v88, 16LL);

          if (v89)
          {
            v90 = sub_1000D54AC();
            _NRLogWithArgs( v90,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (policyPrefix) != ((void *)0)",  "",  "-[NRDDeviceConductor setupCatchAllInterfaceIfApplicable]",  7877);
          }

LABEL_24:
}

    uint64_t v10 = 0LL;
    goto LABEL_15;
  }

  uint64_t v19 = 0LL;
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSPropertyListSerialization dataWithPropertyList:format:options:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "dataWithPropertyList:format:options:error:",  v6,  200LL,  0LL,  &v19));
  uint64_t v8 = v19;
  uint64_t v9 = v8;
  if (!v7 || v8)
  {
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      _NRLogWithArgs(qword_1001DCA50, 17LL, "Failed to serialize %@: %@", v6, v9);
    }

    uint64_t v10 = 0LL;
  }

  else
  {
    uint64_t v10 = sub_1001010F0(v5, v7, a3);
  }

LABEL_15:
  return v10;
}

  return v18;
}
}

void sub_100005338(_Unwind_Exception *a1)
{
}

void sub_100005354(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if ((!v2 || !*(_BYTE *)(v2 + 8)) && (*(_BYTE *)(a1 + 48) & 8) == 0)
  {
    uint64_t v3 = *(void *)(a1 + 112);
    if (!v3 || *(unsigned __int16 *)(v3 + 28) <= 0x12u)
    {
      if (*(_BYTE *)(a1 + 13))
      {
        *(_BYTE *)(a1 + 12) = 1;
        id v4 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 24));
        if (!v4)
        {
          id v7 = sub_100003B10();
          int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 16LL);

          if (IsLevelEnabled)
          {
            id v9 = sub_100003B10();
            _NRLogWithArgs( v9,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRPairingClient scheduleIKESessionClassADueToConnectFailure]",  661);
          }

          uint64_t v10 = _os_log_pack_size(12LL);
          uint64_t v11 = (char *)v15 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v12 = __error();
          uint64_t v13 = _os_log_pack_fill( v11,  v10,  *v12,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
          *(_DWORD *)uint64_t v13 = 136446210;
          *(void *)(v13 + 4) = "-[NRPairingClient scheduleIKESessionClassADueToConnectFailure]";
          id v14 = sub_100003B10();
          _NRLogAbortWithPack(v14, v11);
          __break(1u);
        }

        id v5 = v4;
        if (!v4[14] && *((unsigned __int16 *)v4 + 14) <= 0x12u)
        {
          objc_initWeak(&location, (id)a1);
          id v6 = sub_1001438EC((uint64_t)&OBJC_CLASS___NRDKeyManager);
          v15[0] = _NSConcreteStackBlock;
          v15[1] = 3221225472LL;
          v15[2] = sub_100006D94;
          v15[3] = &unk_1001B0798;
          objc_copyWeak(&v17, &location);
          uint64_t v16 = v5;
          sub_1001448A8((uint64_t)v6, v15);

          objc_destroyWeak(&v17);
          objc_destroyWeak(&location);
        }
      }

      else
      {
        *(_BYTE *)(a1 + 13) = 1;
        sub_1000055CC(a1, 1LL);
      }
    }
  }

void sub_1000055A0(_Unwind_Exception *a1)
{
}

void sub_1000055CC(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a1 + 8) & 0xFE) != 6)
  {
    id String = (id)NRDataProtectionClassCreateString(a2);
    id v4 = (id *)sub_100004C0C(a1, a2);
    sub_100003C00(a1, v4);
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      _NRLogWithArgs( qword_1001DC628,  0LL,  "%s%.30s:%-4d %@: Restarting %@ session",  "",  "-[NRPairingClient restartIKESessionForDataProtectionClass:]",  688LL,  a1,  String);
    }

    if ((_DWORD)a2 == 1)
    {
      if (*(_BYTE *)(a1 + 12))
      {
        if (qword_1001DC630 != -1) {
          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
        {
          if (qword_1001DC630 != -1) {
            dispatch_once(&qword_1001DC630, &stru_1001ADE00);
          }
          _NRLogWithArgs( qword_1001DC628,  0LL,  "%s%.30s:%-4d %@: Not restarting ClassA session because attempt failed once. Will retry at next unlock",  "",  "-[NRPairingClient restartIKESessionForDataProtectionClass:]",  691LL,  a1);
        }

        goto LABEL_19;
      }

      uint64_t v5 = a1;
      uint64_t v6 = 1LL;
    }

    else
    {
      uint64_t v5 = a1;
      uint64_t v6 = a2;
    }

    sub_100006278(v5, v6);
LABEL_19:
  }

void sub_100005794(uint64_t a1, int a2, char a3)
{
  if (!a1) {
    return;
  }
  uint64_t v6 = *(void *)(a1 + 48);
  *(_BYTE *)(a1 + 8) = a2;
  *(void *)(a1 + 152) = v6;
  if (a2 == 7)
  {
    id v7 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 24));
    uint64_t v8 = v7;
    if (!v7)
    {
LABEL_20:
      objc_opt_self(&OBJC_CLASS___NRPairingClientManager);
      if (qword_1001DC660 != -1) {
        dispatch_once(&qword_1001DC660, &stru_1001ADF28);
      }
      uint64_t v11 = (id *)(id)qword_1001DC658;
      if (!v11
        || (uint64_t v12 = v11,
            uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v11[3] objectForKeyedSubscript:*(void *)(a1 + 24)]),
            id v14 = [v13 count],
            v13,
            v12,
            !v14))
      {
        id v28 = objc_alloc(&OBJC_CLASS___NSString);
        else {
          id v29 = *(&off_1001ADE20 + (a3 - 1));
        }
        uint64_t v30 = -[NSString initWithFormat:](v28, "initWithFormat:", @"pairing client failed %@", v29);
        sub_1001306B8((uint64_t)&OBJC_CLASS___NRDLocalDevice, -2017LL, v30, *(void **)(a1 + 24));

LABEL_30:
        goto LABEL_31;
      }

LABEL_24:
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC628, 17LL))
      {
        if (qword_1001DC630 != -1) {
          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
        }
        _NRLogWithArgs(qword_1001DC628, 17LL, "%@: Pairing client failed while local device registered", a1);
      }

      goto LABEL_30;
    }

    if (v7[15])
    {
      char v9 = 1;
      if (!v7[12]) {
        goto LABEL_19;
      }
    }

    else
    {
      if (v7[14]) {
        BOOL v10 = 1;
      }
      else {
        BOOL v10 = *((unsigned __int16 *)v7 + 14) > 0x12u;
      }
      char v9 = v10;
      if (!v7[12]) {
        goto LABEL_19;
      }
    }

    if (!v7[13]) {
      char v9 = 0;
    }
    if ((v9 & 1) != 0) {
      goto LABEL_24;
    }
LABEL_19:
    if (v7[8]) {
      goto LABEL_24;
    }
    goto LABEL_20;
  }
}

      -[NSMutableString appendString:](v10, "appendString:", @"immediate, ");
      goto LABEL_25;
    }
}
}

              if (v19)
              {
                BOOL v10 = v59;
                goto LABEL_35;
              }

              *(void *)(v4 + 439) += v16;
              id v14 = v59 + 1;
              uint64_t v13 = v58 + 1;
            }

            while ((id)(v58 + 1) != v57);
            v57 = [v9 countByEnumeratingWithState:&v60 objects:v67 count:16];
            if (v57) {
              continue;
            }
            break;
          }
        }

              continue;
            }
          }
        }
      }

      id v23 = [v13 countByEnumeratingWithState:&v47 objects:v62 count:16];
    }

    while (v23);
  }

  char v37 = *(void *)(a1 + 48);
  if (v37) {
    char v38 = *(void **)(v37 + 160);
  }
  else {
    char v38 = 0LL;
  }
  if ((unint64_t)[v38 count] >= 0x21)
  {
    __int128 v39 = objc_alloc(&OBJC_CLASS___NSString);
    __int128 v40 = *(void *)(a1 + 48);
    if (v40) {
      __int128 v41 = *(void **)(v40 + 160);
    }
    else {
      __int128 v41 = 0LL;
    }
    id v46 = [v41 count];
    __int128 v42 = -[NSString initWithFormat:](v39, "initWithFormat:", @"unexpected number of cached tokens %u");
    sub_1001030D0(@"MASQUEProxyTokens", v42, 0LL, 0, 0LL, v43, v44, v45, (uint64_t)v46);
  }
}

    dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
    goto LABEL_9;
  }

      if (!v8 || !v12) {
        goto LABEL_31;
      }
      uint64_t v11 = (id)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithCEndpoint:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithCEndpoint:",  v8));
      id v19 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 96));
      uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v11 port]);
      id v33 = v19;
      id v21 = sub_10012CD2C(v19, v20);

      id v22 = (void *)objc_claimAutoreleasedReturnValue([v21 port]);
      uint64_t v32 = v21;
      id v23 = sub_1001040C8(v21, (unsigned __int16)[v22 intValue], 0);
      uint64_t v24 = objc_claimAutoreleasedReturnValue(v23);

      id v25 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
      uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v14 dataUsingEncoding:4]);
      NRTLVAddData(v25, 5LL);
      NRTLVAddData(v25, 7LL);
      id v31 = (void *)v24;
      NRTLVAddData(v25, 2LL);
      uint64_t v27 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
      NRTLVAddData(v27, 6LL);
      id v28 = sub_100021C64(objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage), *(void **)(a1 + 96));
      sub_1000222F4((uint64_t)v28, 21, v27);
      sub_100023824((uint64_t)v28);
      id v29 = *(void *)(a1 + 632);
      uint64_t v30 = v14;
      if (v29 && !*(_BYTE *)(v29 + 9)) {
        [*(id *)(v29 + 32) removeObject:v30];
      }

LABEL_30:
LABEL_31:

      id v4 = v34;
    }
  }
}
}

      return;
    }

    id v14 = 0LL;
    goto LABEL_18;
  }

  if (!v7)
  {
    id v21 = sub_10014387C();
    id v22 = _NRLogIsLevelEnabled(v21, 17LL);

    if (v22)
    {
      uint64_t v20 = sub_10014387C();
      _NRLogWithArgs(v20, 17LL, "%s called with null itemName");
      goto LABEL_23;
    }

    goto LABEL_24;
  }

  uint64_t v8 = sub_100145CF4(a1, v7, 0LL, a4);
  char v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
  if (v9)
  {
    id v23 = 0LL;
    BOOL v10 = +[NSKeyedUnarchiver unarchivedDictionaryWithKeysOfClass:objectsOfClass:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedDictionaryWithKeysOfClass:objectsOfClass:fromData:error:",  objc_opt_class(&OBJC_CLASS___NSUUID),  a2,  v9,  &v23);
    uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    uint64_t v12 = v23;
    uint64_t v13 = v12;
    if (!v11 || v12)
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCC20, 16LL))
      {
        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        id v15 = (id)qword_1001DCC20;
        id String = (void *)NRDataProtectionClassCreateString(a4);
        _NRLogWithArgs( v15,  16LL,  "%s%.30s:%-4d Failed to unarchive %@ keychain data %@: %@",  "",  "-[NRDKeyManager readNRUUIDDictionaryOfClass:fromKeychainWithName:dataProtectionClass:]",  936LL,  String,  v7,  v13);
      }

      id v14 = 0LL;
    }

    else
    {
      id v14 = -[NSMutableDictionary initWithDictionary:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithDictionary:",  v11);
    }
  }

  else
  {
    id v14 = 0LL;
  }

LABEL_18:
  return v14;
}

LABEL_31:
  id v15 = objc_retainBlock(*(id *)(a1 + 144));
  uint64_t v16 = *(dispatch_queue_s **)(a1 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100006260;
  block[3] = &unk_1001ADD68;
  id v17 = v15;
  id v33 = v17;
  char v34 = a2;
  char v35 = a3;
  dispatch_async(v16, block);
  if ((a2 - 5) <= 2 && !*(_BYTE *)(a1 + 11))
  {
    objc_opt_self(&OBJC_CLASS___NRPairingClientManager);
    if (qword_1001DC660 != -1) {
      dispatch_once(&qword_1001DC660, &stru_1001ADF28);
    }
    uint64_t v18 = (id *)(id)qword_1001DC658;
    id v19 = *(id *)(a1 + 24);
    if (v18)
    {
      [v18[2] setObject:0 forKeyedSubscript:v19];
      id v31 = v19;
      uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v18[3] objectForKeyedSubscript:v19]);
      __int128 v39 = 0u;
      __int128 v40 = 0u;
      __int128 v41 = 0u;
      __int128 v42 = 0u;
      id v21 = v20;
      id v22 = [v21 countByEnumeratingWithState:&v39 objects:v43 count:16];
      if (v22)
      {
        id v23 = v22;
        uint64_t v24 = *(void *)v40;
        do
        {
          for (i = 0LL; i != v23; i = (char *)i + 1)
          {
            if (*(void *)v40 != v24) {
              objc_enumerationMutation(v21);
            }
            uint64_t v26 = *(void *)(*((void *)&v39 + 1) + 8LL * (void)i);
            if (v26) {
              uint64_t v27 = *(dispatch_queue_s **)(v26 + 8);
            }
            else {
              uint64_t v27 = 0LL;
            }
            v36[0] = _NSConcreteStackBlock;
            v36[1] = 3221225472LL;
            v36[2] = sub_10000F8A8;
            v36[3] = &unk_1001B08B0;
            void v36[4] = v26;
            char v37 = a2;
            char v38 = a3;
            dispatch_async(v27, v36);
          }

          id v23 = [v21 countByEnumeratingWithState:&v39 objects:v43 count:16];
        }

        while (v23);
      }

      id v19 = v31;
      [v18[3] setObject:0 forKeyedSubscript:v31];
    }
  }
}

        free(v18);
        return;
      }
    }

    else
    {
    }

    id v33 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v31);
    char v34 = _NRLogIsLevelEnabled(v33, 16LL);

    if (v34)
    {
      id v36 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v35);
      _NRLogWithArgs( v36,  16LL,  "%s%.30s:%-4d no valid interfaces for discovery proxy",  "",  "-[NRDiscoveryProxyServer startDiscoveryProxyServer]",  654);
    }

    sub_10001B5C8((_BYTE *)a1, 4);
    goto LABEL_31;
  }
  }
}

  -[NSMutableArray addObject:](v3, "addObject:", @"SvcVo");
  if ((a1 & 0x8000) == 0)
  {
LABEL_6:
    if ((a1 & 0x40000) == 0) {
      goto LABEL_7;
    }
    goto LABEL_33;
  }
}

    id v28 = 0LL;
    goto LABEL_32;
  }

  BOOL v10 = *(void *)((char *)v7 + 975);
  if (!v10)
  {
    id v22 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v9 + 4), v8);
    id v23 = _NRLogIsLevelEnabled(v22, 16LL);

    if (v23)
    {
      id v17 = (id)_NRCopyLogObjectForNRUUID(*((void *)v9 + 4), v24);
      uint64_t v18 = [v9 copyDescription];
      _NRLogWithArgs( v17,  16LL,  "%s%.30s:%-4d %@: Tried to NRLBTSendControlMessage but _linkOutputRing is NULL",  "",  "NRLBTSendControlMessage",  2828LL,  v18);
      goto LABEL_19;
    }

    goto LABEL_31;
  }

  uint64_t v11 = *(_DWORD *)(v9 + 287);
  if (v11 <= *(_DWORD *)(v9 + 291))
  {
    next_slot = os_channel_get_next_slot(v10, 0LL, v35);
    if (next_slot && v36 >= 5u && v36 - 5 >= a3)
    {
      uint64_t v30 = next_slot;
      id v31 = v37;
      *char v37 = 5;
      *(_WORD *)(v31 + 1) = __rev16(a3);
      memcpy(v31 + 3, a2, a3);
      *(_WORD *)&v31[a3 + 3] = ~(unsigned __int16)os_inet_checksum(v31, a3 + 3LL, 0LL);
      id v36 = a3 + 5;
      os_channel_set_slot_properties(*(void *)(v9 + 975), v30, v35);
      os_channel_advance_slot(*(void *)(v9 + 975), v30);
      if (a4) {
        id v28 = mach_absolute_time();
      }
      else {
        id v28 = 0LL;
      }
      os_channel_sync(*(void *)(v9 + 959), 0LL);
      goto LABEL_32;
    }

    uint64_t v11 = *(_DWORD *)(v9 + 287);
  }

  uint64_t v13 = *(_DWORD *)(v9 + 279) - v11;
  if (v13 <= 4)
  {
    id v14 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v9 + 4), v8);
    id v15 = _NRLogIsLevelEnabled(v14, 16LL);

    if (v15)
    {
      id v17 = (id)_NRCopyLogObjectForNRUUID(*((void *)v9 + 4), v16);
      uint64_t v18 = [v9 copyDescription];
      _NRLogWithArgs( v17,  16LL,  "%s%.30s:%-4d %@: NRLBTSendControlMessage but out of room1",  "",  "NRLBTSendControlMessage",  2863LL,  v18);
LABEL_19:

LABEL_20:
      id v28 = 0LL;
      goto LABEL_32;
    }

    goto LABEL_31;
  }

  if (v13 - 5 < a3)
  {
    id v25 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v9 + 4), v8);
    uint64_t v26 = _NRLogIsLevelEnabled(v25, 16LL);

    if (v26)
    {
      id v17 = (id)_NRCopyLogObjectForNRUUID(*((void *)v9 + 4), v27);
      uint64_t v18 = [v9 copyDescription];
      _NRLogWithArgs( v17,  16LL,  "%s%.30s:%-4d %@: NRLBTSendControlMessage but out of room2",  "",  "NRLBTSendControlMessage",  2867LL,  v18);
      goto LABEL_19;
    }

    goto LABEL_31;
  }

  id v29 = *(void *)(v9 + 447) + v11;
  *(_BYTE *)id v29 = 5;
  *(_WORD *)(v29 + 1) = __rev16(a3);
  memcpy((void *)(v29 + 3), a2, a3);
  *(_WORD *)(v29 + a3 + 3LL) = ~(unsigned __int16)os_inet_checksum(v29, a3 + 3LL, 0LL);
  *(_DWORD *)(v9 + 287) += a3;
  if (a4) {
    id v28 = mach_absolute_time();
  }
  else {
    id v28 = 0LL;
  }
  sub_100070E0C(v9, *(void *)(v9 + 367));
LABEL_32:

  return v28;
}
}

          if (p_class_meths[278] != (__objc2_meth_list *)-1LL) {
            dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
          }
          int IsLevelEnabled = _NRLogIsLevelEnabled(qword_1001DC8A8, 16LL);
          id v31 = v25;
          if (IsLevelEnabled)
          {
            if (p_class_meths[278] != (__objc2_meth_list *)-1LL) {
              dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
            }
            id v36 = (id)qword_1001DC8A8;
            if ([v32 routerID] == (id)a7) {
              char v37 = "";
            }
            else {
              char v37 = "not ";
            }
            char v38 = [v32 seqno];
            __int128 v39 = [v32 seqno];
            else {
              __int128 v40 = 1;
            }
            __int128 v41 = ((int)(((_DWORD)v9 - v39) << 16) >> 31) | 1;
            if (v39 == (_DWORD)v9) {
              __int128 v40 = 0;
            }
            _NRLogWithArgs( v36,  16LL,  "%s%.30s:%-4d SEQSTUFF routerID %sequal, compare(%u,%u) = %d",  "",  "-[NRBabelInstance handleSeqnoReqFromAddr:babelInterface:ForPrefix:plen:routerID:seqno:hopCount:]",  3152,  v37,  v38,  v9,  v40);

            id v25 = v79;
            id v31 = v79;
            p_class_meths = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
          }
}

    if (-[NSMutableArray count](v13, "count"))
    {
      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v46 = v14;
      id v47 = (id)qword_1001DCB58;
      int v48 = (id *)v47;
      if (v47)
      {
        dispatch_assert_queue_V2(*((dispatch_queue_t *)v47 + 1));
        if (([v48[2] apply] & 1) == 0) {
          sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v49,  v50,  v51,  v541);
        }
      }

      v52 = (char *)objc_claimAutoreleasedReturnValue([v11 policyIDs]);
      uint64_t v53 = [objc_alloc((Class)v12[143]) initWithArray:v52];
      [v53 addObjectsFromArray:v13];
      [v11 setPolicyIDs:v53];
      uint64_t v55 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v54);
      __int128 v56 = _NRLogIsLevelEnabled(v55, 0LL);

      if (v56)
      {
        v58 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v57);
        _NRLogWithArgs( v58,  0LL,  "%s%.30s:%-4d Successfully set policies for TLS link: %@",  "",  "-[NRDDeviceConductor setPoliciesForNonCompanionDatapath:]",  3477LL,  v11);
      }
    }

    else
    {
      id v46 = v14;
      v59 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v45);
      v60 = _NRLogIsLevelEnabled(v59, 0LL);

      if (!v60)
      {
LABEL_43:

        goto LABEL_44;
      }

      v52 = (char *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v61);
      _NRLogWithArgs( v52,  0LL,  "%s%.30s:%-4d No new policies added for link: %@",  "",  "-[NRDDeviceConductor setPoliciesForNonCompanionDatapath:]",  3479LL,  v11);
    }

    uint64_t v16 = 0LL;
LABEL_32:

    goto LABEL_33;
  }

  uint64_t v18 = sub_100100C84();
  int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 17LL);

  if (IsLevelEnabled)
  {
    uint64_t v20 = sub_100100C84();
    _NRLogWithArgs(v20, 17LL, "%s called with null addressEndpoint", "NRCreateAddressData");
  }

  uint64_t v16 = 0LL;
LABEL_33:

  return v16;
}

    id v14 = -[NSString initWithUTF8String:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithUTF8String:",  "LinkRecommendation");
    if (-[NSMutableString length](v11, "length")) {
      -[NSMutableString appendString:](v11, "appendString:", @", ");
    }
    -[NSMutableString appendString:](v11, "appendString:", v14);

    if ((v7 & 0x10) == 0)
    {
LABEL_21:
      if ((v7 & 0x20) == 0) {
        goto LABEL_22;
      }
      goto LABEL_37;
    }

void sub_100005BE0(uint64_t a1, int a2)
{
  if (a1)
  {
    uint64_t v4 = *(void *)(a1 + 40);
    if (!v4 || !*(_BYTE *)(v4 + 8))
    {
      if (*(_BYTE *)(a1 + 14))
      {
        uint64_t v5 = (id *)sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 24));
        if (a2 != 4 || (*(_BYTE *)(a1 + 48) & 2) != 0)
        {
          uint64_t v11 = *(void *)(a1 + 40);
          if (v11 && *(_BYTE *)(v11 + 14) && (*(_BYTE *)(a1 + 48) & 2) == 0) {
            goto LABEL_37;
          }
          if (a2 != 3 || (*(_BYTE *)(a1 + 48) & 4) != 0)
          {
            if (v11 && *(_BYTE *)(v11 + 14))
            {
              if (a2 != 1) {
                goto LABEL_37;
              }
              uint64_t v16 = *(void *)(a1 + 48);
              if ((v16 & 4) == 0) {
                goto LABEL_37;
              }
            }

            else
            {
              if (a2 != 1)
              {
LABEL_37:

                return;
              }

              uint64_t v16 = *(void *)(a1 + 48);
            }

            if ((v16 & 8) != 0) {
              goto LABEL_37;
            }
            id v21 = v5;
            if (v5)
            {
              id v17 = v5[11];
              uint64_t v18 = v17;
              id v19 = v17 ? (void *)*((void *)v17 + 1) : 0LL;
            }

            else
            {
              uint64_t v18 = 0LL;
              id v19 = 0LL;
            }

            id v20 = v19;

            uint64_t v5 = v21;
            if (!v20) {
              goto LABEL_37;
            }
            uint64_t v10 = 1LL;
          }

          else
          {
            id v21 = v5;
            if (v5)
            {
              id v12 = v5[10];
              uint64_t v13 = v12;
              if (v12) {
                id v14 = (void *)*((void *)v12 + 1);
              }
              else {
                id v14 = 0LL;
              }
            }

            else
            {
              uint64_t v13 = 0LL;
              id v14 = 0LL;
            }

            id v15 = v14;

            uint64_t v5 = v21;
            if (!v15) {
              goto LABEL_37;
            }
            uint64_t v10 = 3LL;
          }
        }

        else
        {
          id v21 = v5;
          if (v5)
          {
            id v6 = v5[9];
            id v7 = v6;
            if (v6) {
              uint64_t v8 = (void *)*((void *)v6 + 1);
            }
            else {
              uint64_t v8 = 0LL;
            }
          }

          else
          {
            id v7 = 0LL;
            uint64_t v8 = 0LL;
          }

          id v9 = v8;

          uint64_t v5 = v21;
          if (!v9) {
            goto LABEL_37;
          }
          uint64_t v10 = 4LL;
        }

        sub_1000055CC(a1, v10);
        uint64_t v5 = v21;
        goto LABEL_37;
      }
    }
  }

void sub_100005DB0(uint64_t a1)
{
  if (a1)
  {
    sub_100003C00(a1, (id *)(a1 + 88));
    sub_100003C00(a1, (id *)(a1 + 96));
    sub_100003C00(a1, (id *)(a1 + 104));
    sub_100003C00(a1, (id *)(a1 + 80));
    uint64_t v2 = *(void **)(a1 + 72);
    if (v2)
    {
      [v2 cancel];
      uint64_t v3 = *(void **)(a1 + 72);
      *(void *)(a1 + 72) = 0LL;
    }

    objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
    if (qword_1001DC640 != -1) {
      dispatch_once(&qword_1001DC640, &stru_1001ADE98);
    }
    id v4 = (id)qword_1001DC638;
    sub_10000F034((uint64_t)v4, (void *)a1);
  }

void sub_100005E70(uint64_t a1, int a2)
{
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && (WeakRetained[8] & 0xFE) != 6)
  {
    uint64_t v4 = (uint64_t)WeakRetained;
    if (a2)
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
      {
        if (qword_1001DC630 != -1) {
          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
        }
        _NRLogWithArgs( qword_1001DC628,  0LL,  "%s%.30s:%-4d %@: pairing ACK was received",  "",  "-[NRPairingClient finalizePairing]_block_invoke",  1236LL,  v4);
      }

      sub_100005FF4(v4);
    }

    else
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC628, 16LL))
      {
        if (qword_1001DC630 != -1) {
          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
        }
        _NRLogWithArgs( qword_1001DC628,  16LL,  "%s%.30s:%-4d %@: pairing ACK was not received",  "",  "-[NRPairingClient finalizePairing]_block_invoke",  1240LL,  v4);
      }

      sub_100005794(v4, 7, 7);
    }

    WeakRetained = (_BYTE *)v4;
  }
}

void sub_100005FF4(uint64_t a1)
{
  if (qword_1001DC630 != -1) {
    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    _NRLogWithArgs( qword_1001DC628,  0LL,  "%s%.30s:%-4d %@: pairing completed",  "",  "-[NRPairingClient handlePairingComplete]",  1159LL,  a1);
  }

  uint64_t v2 = *(void *)(a1 + 48);
  if ((v2 & 2) != 0)
  {
    sub_10012FFF8((uint64_t)&OBJC_CLASS___NRDLocalDevice, 4LL, *(void **)(a1 + 24));
    uint64_t v2 = *(void *)(a1 + 48);
    if ((v2 & 4) == 0)
    {
LABEL_9:
      if ((v2 & 8) == 0) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
  }

  else if ((v2 & 4) == 0)
  {
    goto LABEL_9;
  }

  sub_10012FFF8((uint64_t)&OBJC_CLASS___NRDLocalDevice, 3LL, *(void **)(a1 + 24));
  uint64_t v2 = *(void *)(a1 + 48);
  if ((v2 & 8) != 0)
  {
LABEL_10:
    sub_10012FFF8((uint64_t)&OBJC_CLASS___NRDLocalDevice, 1LL, *(void **)(a1 + 24));
    uint64_t v2 = *(void *)(a1 + 48);
  }

LABEL_11:
  *(void *)(a1 + 48) = v2 | 0x10;
  sub_100005794(a1, 5, 0);
  uint64_t v3 = *(void **)(a1 + 72);
  if (v3)
  {
    [v3 cancel];
    uint64_t v4 = *(void **)(a1 + 72);
    *(void *)(a1 + 72) = 0LL;
  }

  uint64_t v5 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 24));
  id v12 = v5;
  uint64_t v6 = *(void *)(a1 + 40);
  if (!v6 || !*(_BYTE *)(v6 + 13))
  {
    objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
    if (qword_1001DC640 != -1) {
      dispatch_once(&qword_1001DC640, &stru_1001ADE98);
    }
    id v7 = (id)qword_1001DC638;
    sub_10000F034((uint64_t)v7, (void *)a1);

LABEL_20:
    sub_100003C00(a1, (id *)(a1 + 80));
    sub_100003C00(a1, (id *)(a1 + 88));
    sub_100003C00(a1, (id *)(a1 + 96));
    sub_100003C00(a1, (id *)(a1 + 104));
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v8 = (id)qword_1001DC870;
  id v9 = v8;
  if (v8) {
    uint64_t v10 = (void *)*((void *)v8 + 6);
  }
  else {
    uint64_t v10 = 0LL;
  }
  id v11 = v10;
  sub_100140F48((uint64_t)v11, 0, *(void **)(a1 + 64));
}

  if ([v6 isUnpairRequest])
  {
    if (qword_1001DC6B0 != -1) {
      dispatch_once(&qword_1001DC6B0, &stru_1001AE320);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC6A8, 1LL))
    {
      if (qword_1001DC6B0 != -1) {
        dispatch_once(&qword_1001DC6B0, &stru_1001AE320);
      }
      _NRLogWithArgs( qword_1001DC6A8,  1LL,  "%s%.30s:%-4d not removing pairer as it is unpairing",  "",  "-[NRBluetoothPairingManager removePairerForNRUUID:]",  184);
    }
  }

  else
  {
    id v12 = (void *)objc_claimAutoreleasedReturnValue(-[NRBluetoothPairingManager enqueuedPairers](self, "enqueuedPairers"));
    [v12 removeObject:v6];

    activePairer = self->_activePairer;
    if (activePairer)
    {
      id v14 = (void *)objc_claimAutoreleasedReturnValue(-[NRBluetoothPairer nrUUID](activePairer, "nrUUID"));
      id v15 = [v14 isEqual:v4];

      if (v15) {
        -[NRBluetoothPairingManager startNextPairer](self, "startNextPairer");
      }
    }
  }
}

      sub_10001B5C8((_BYTE *)a1, 4);
      return;
    }

    if (v7 >= 9u)
    {
      id v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v8);
      uint64_t v10 = _NRLogIsLevelEnabled(v9, 16LL);

      if (v10)
      {
        id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v11);
        _NRLogWithArgs(v12, 16LL, "%s%.30s:%-4d unexpected number of interfaces for discovery proxy %u");
LABEL_10:

        goto LABEL_11;
      }

      goto LABEL_11;
    }

    uint64_t v16 = v7;
    id v17 = calloc(v7, 8uLL);
    if (!v17)
    {
      __int128 v41 = sub_10001AE98();
      __int128 v42 = _NRLogIsLevelEnabled(v41, 16LL);

      if (v42)
      {
        v43 = sub_10001AE98();
        _NRLogWithArgs( v43,  16LL,  "%s%.30s:%-4d ABORTING: strict_calloc(%zu, %zu) failed",  "",  "strict_calloc",  108,  v16,  8uLL);
      }

      id v44 = _os_log_pack_size(32LL);
      v45 = (char *)&v49 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v46 = __error();
      id v47 = _os_log_pack_fill( v45,  v44,  *v46,  &_mh_execute_header,  "%{public}s strict_calloc(%zu, %zu) failed");
      *(_DWORD *)id v47 = 136446722;
      *(void *)(v47 + 4) = "strict_calloc";
      *(_WORD *)(v47 + 12) = 2048;
      *(void *)(v47 + 14) = v16;
      *(_WORD *)(v47 + 22) = 2048;
      *(void *)(v47 + 24) = 8LL;
      int v48 = sub_10001AE98();
      _NRLogAbortWithPack(v48, v45);
    }

    uint64_t v18 = v17;
    v51 = 0u;
    v52 = 0u;
    uint64_t v50 = 0u;
    id v49 = 0u;
    id v19 = *(id *)(a1 + 96);
    id v20 = [v19 countByEnumeratingWithState:&v49 objects:v53 count:16];
    if (v20)
    {
      id v21 = v20;
      id v22 = 0LL;
      id v23 = *(void *)v50;
      do
      {
        for (i = 0LL; i != v21; i = (char *)i + 1)
        {
          if (*(void *)v50 != v23) {
            objc_enumerationMutation(v19);
          }
          id v25 = *(void **)(*((void *)&v49 + 1) + 8LL * (void)i);
          if (objc_msgSend(v25, "length", (void)v49))
          {
            v18[(int)v22] = [v25 UTF8String];
            id v22 = (v22 + 1);
          }

          else
          {
            uint64_t v27 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v26);
            id v28 = _NRLogIsLevelEnabled(v27, 17LL);

            if (v28)
            {
              uint64_t v30 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v29);
              _NRLogWithArgs(v30, 17LL, "invalid interface name for discovery proxy");
            }
          }
        }

        id v21 = [v19 countByEnumeratingWithState:&v49 objects:v53 count:16];
      }

      while (v21);

      if ((_DWORD)v22)
      {
        uint64_t v32 = advertising_proxy_enable_with_interfaces(a1 + 80, *(void *)(a1 + 40), sub_10001C9E8, v18, v22);
        if ((_DWORD)v32)
        {
          sub_10001CDA4(a1, v32);
        }

        else
        {
          char v37 = (void *)qword_1001DC6B8;
          if (!qword_1001DC6B8)
          {
            char v38 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
            __int128 v39 = (void *)qword_1001DC6B8;
            qword_1001DC6B8 = (uint64_t)v38;

            char v37 = (void *)qword_1001DC6B8;
          }

          __int128 v40 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLong:",  *(void *)(a1 + 80)));
          [v37 setObject:a1 forKeyedSubscript:v40];
        }

  a1 = v8;
  id v14 = a1;
LABEL_15:

  return v14;
}

  id v11 = v5;
  [v11 setClientQueue:a1[1]];
  objc_initWeak(location, a1);
  v61[0] = _NSConcreteStackBlock;
  v61[1] = 3221225472LL;
  v61[2] = sub_100077E4C;
  v61[3] = &unk_1001AEBE0;
  objc_copyWeak(&v65, location);
  v66 = v2;
  id v12 = String;
  v62 = v12;
  uint64_t v13 = v11;
  v63 = v13;
  v64 = a1;
  [v13 setStateUpdateBlock:v61];
  v56[0] = _NSConcreteStackBlock;
  v56[1] = 3221225472LL;
  v56[2] = sub_1000789A8;
  v56[3] = &unk_1001AF300;
  objc_copyWeak(&v59, location);
  id v14 = v12;
  v57 = v14;
  id v15 = v13;
  v58 = v15;
  v60 = v2;
  [v15 setChildStateUpdateBlock:v56];
  v52[0] = _NSConcreteStackBlock;
  v52[1] = 3221225472LL;
  v52[2] = sub_100078B88;
  v52[3] = &unk_1001AF328;
  objc_copyWeak(&v55, location);
  uint64_t v16 = v14;
  uint64_t v53 = v16;
  id v17 = v15;
  id v54 = v17;
  [v17 setConfigurationUpdateBlock:v52];
  v48[0] = _NSConcreteStackBlock;
  v48[1] = 3221225472LL;
  v48[2] = sub_100078C54;
  v48[3] = &unk_1001AF350;
  objc_copyWeak(&v51, location);
  uint64_t v18 = v16;
  id v49 = v18;
  id v19 = v17;
  uint64_t v50 = v19;
  [v19 setTrafficSelectorUpdateBlock:v48];
  char v34 = String;
  v44[0] = _NSConcreteStackBlock;
  v44[1] = 3221225472LL;
  v44[2] = sub_100078D40;
  v44[3] = &unk_1001AF378;
  objc_copyWeak(&v47, location);
  id v20 = v18;
  v45 = v20;
  id v21 = v19;
  id v46 = v21;
  [v21 setAdditionalAddressesUpdateBlock:v44];
  v40[0] = _NSConcreteStackBlock;
  v40[1] = 3221225472LL;
  v40[2] = sub_100078E0C;
  v40[3] = &unk_1001AF3A0;
  objc_copyWeak(&v43, location);
  id v22 = v20;
  __int128 v41 = v22;
  id v23 = v21;
  __int128 v42 = v23;
  [v23 setShortDPDEventBlock:v40];
  v35[0] = _NSConcreteStackBlock;
  v35[1] = 3221225472LL;
  v35[2] = sub_100078ECC;
  v35[3] = &unk_1001AEC08;
  objc_copyWeak(&v38, location);
  uint64_t v24 = v22;
  id v36 = v24;
  id v25 = v23;
  char v37 = v25;
  __int128 v39 = v2;
  [v25 setPrivateNotifyStatusEvent:v35];
  uint64_t v27 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v26);
  id v28 = _NRLogIsLevelEnabled(v27, 0LL);

  if ((v28 & 1) != 0)
  {
    uint64_t v30 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v29);
    id v31 = [a1 copyDescription];
    _NRLogWithArgs( v30,  0LL,  "%s%.30s:%-4d %@: Setup IKE %@ %@ callbacks",  "",  "-[NRLinkBluetooth setupIKECallbacks:]",  8268LL,  v31,  v24,  v25);
  }

  objc_destroyWeak(&v38);
  objc_destroyWeak(&v43);

  objc_destroyWeak(&v47);
  objc_destroyWeak(&v51);

  objc_destroyWeak(&v55);
  objc_destroyWeak(&v59);

  objc_destroyWeak(&v65);
  objc_destroyWeak(location);

  id String = v34;
LABEL_21:
}

  id v8 = objc_opt_respondsToSelector(v2, "linkPeerIsAsleep:isAsleep:");
  uint64_t v2 = v9;
  if ((v8 & 1) != 0)
  {
    [v9 linkPeerIsAsleep:*(void *)(a1 + 32) isAsleep:v5];
    uint64_t v2 = v9;
  }
}

  if (a5) {
    *a5 = v10 == 0LL;
  }
  if (!v10)
  {
    id v14 = -[NRBabelNeighbor initWithAddress:babelInterface:]( objc_alloc(&OBJC_CLASS___NRBabelNeighbor),  "initWithAddress:babelInterface:",  a3,  v8);
    if (v14)
    {
      uint64_t v10 = v14;
      -[NSMutableArray addObject:](self->_neighbors, "addObject:", v14);
    }

    else
    {
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC8A8, 17LL))
      {
        if (qword_1001DC8B0 != -1) {
          dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
        }
        _NRLogWithArgs(qword_1001DC8A8, 17LL, "NRBabelNeighbor init failed", (void)v16);
      }

      uint64_t v10 = 0LL;
    }
  }

  return v10;
}

  return v9;
}

  if (a5) {
    *a5 = v10 == 0LL;
  }
  if (!v10)
  {
    id v14 = -[NRPendingOutgoingSeqnoReq initWithInstance:prefix:routerID:]( objc_alloc(&OBJC_CLASS___NRPendingOutgoingSeqnoReq),  "initWithInstance:prefix:routerID:",  self,  v8,  a4);
    if (v14)
    {
      uint64_t v10 = v14;
      -[NSMutableArray addObject:](self->_posrs, "addObject:", v14);
    }

    else
    {
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC8A8, 17LL))
      {
        if (qword_1001DC8B0 != -1) {
          dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
        }
        _NRLogWithArgs(qword_1001DC8A8, 17LL, "NRPendingOutgoingSeqnoReq init failed", (void)v16);
      }

      uint64_t v10 = 0LL;
    }
  }

  return v10;
}
}

    id v11 = 0LL;
    goto LABEL_5;
  }

  dispatch_assert_queue_V2(v7);
  if (!v8)
  {
    uint64_t v16 = sub_1000CA434();
    id v17 = _NRLogIsLevelEnabled(v16, 17LL);

    if (v17)
    {
      id v15 = sub_1000CA434();
      _NRLogWithArgs(v15, 17LL, "%s called with null managerDelegate");
      goto LABEL_10;
    }

    goto LABEL_11;
  }

  v27.receiver = self;
  v27.super_class = (Class)&OBJC_CLASS___NRLinkManager;
  id v9 = -[NRLinkManager init](&v27, "init");
  if (!v9)
  {
    uint64_t v18 = sub_1000CA434();
    id v19 = _NRLogIsLevelEnabled(v18, 16LL);

    if (v19)
    {
      id v20 = sub_1000CA434();
      _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRLinkManager initManagerWithQueue:managerDelegate:]",  19);
    }

    id v21 = _os_log_pack_size(12LL);
    id v22 = (char *)&v26 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v23 = __error();
    uint64_t v24 = _os_log_pack_fill(v22, v21, *v23, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)uint64_t v24 = 136446210;
    *(void *)(v24 + 4) = "-[NRLinkManager initManagerWithQueue:managerDelegate:]";
    id v25 = sub_1000CA434();
    _NRLogAbortWithPack(v25, v22);
  }

  p_isa = (id *)&v9->super.isa;
  v9->_type = 0;
  v9->_state = 1001;
  objc_storeWeak((id *)&v9->_managerDelegate, v8);
  objc_storeStrong(p_isa + 3, a3);
  self = p_isa;
  id v11 = self;
LABEL_5:

  return v11;
}

        generation = netInfo->_generation;
LABEL_12:
        if (netInfoGenerationSent != generation) {
          sub_1000DBDAC((uint64_t)self, self->_primaryLink);
        }
      }
    }

    if (self->_sendThermalPressureUpdateWhenAwake) {
      sub_1000DBA08((uint64_t)self, self->_primaryLink);
    }
    if (self->_sendDeviceStateUpdateWhenAwake) {
      sub_1000DBBF8((uint64_t)self, self->_primaryLink);
    }
  }

  sub_1000DAF94((uint64_t)self);
}
}

    LOBYTE(self) = 0;
  }

    id v8 = 0LL;
    goto LABEL_5;
  }

  v20.receiver = a1;
  v20.super_class = (Class)&OBJC_CLASS___NRDLocalDevice;
  uint64_t v5 = objc_msgSendSuper2(&v20, "init");
  if (!v5)
  {
    uint64_t v13 = sub_100121F34();
    id v14 = _NRLogIsLevelEnabled(v13, 16LL);

    if (v14)
    {
      id v15 = sub_100121F34();
      _NRLogWithArgs( v15,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDLocalDevice initWithoutObservingChangesWithNRUUID:]",  1589);
    }

    uint64_t v4 = (void *)_os_log_pack_size(12LL);
    a1 = (char *)&v19 - (((unint64_t)v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v16 = __error();
    id v17 = _os_log_pack_fill(a1, v4, *v16, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)id v17 = 136446210;
    *(void *)(v17 + 4) = "-[NRDLocalDevice initWithoutObservingChangesWithNRUUID:]";
    uint64_t v18 = sub_100121F34();
    _NRLogAbortWithPack(v18, a1);
    goto LABEL_11;
  }

  uint64_t v6 = v5;
  [v5 setNrUUID:v4];
  id v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
  [v6 setDateCreated:v7];

  a1 = v6;
  id v8 = a1;
LABEL_5:

  return v8;
}

    id v8 = 0LL;
    goto LABEL_5;
  }

  v20.receiver = a1;
  v20.super_class = (Class)&OBJC_CLASS___NRDLDKeychainItemData;
  uint64_t v6 = objc_msgSendSuper2(&v20, "init");
  if (!v6)
  {
    uint64_t v13 = sub_100121F34();
    id v14 = _NRLogIsLevelEnabled(v13, 16LL);

    if (v14)
    {
      id v15 = sub_100121F34();
      _NRLogWithArgs( v15,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDLDKeychainItemData initWithData:]",  148);
    }

    uint64_t v5 = (void *)_os_log_pack_size(12LL);
    a1 = (char *)&v19 - (((unint64_t)v5 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v16 = __error();
    id v17 = _os_log_pack_fill(a1, v5, *v16, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)id v17 = 136446210;
    *(void *)(v17 + 4) = "-[NRDLDKeychainItemData initWithData:]";
    uint64_t v18 = sub_100121F34();
    _NRLogAbortWithPack(v18, a1);
    goto LABEL_11;
  }

  id v7 = v6;
  objc_storeStrong((id *)v6 + 2, a2);
  v7[8] = 1;
  a1 = v7;
  id v8 = a1;
LABEL_5:

  return v8;
}

        uint64_t v10 = 1;
        if (*((_BYTE *)v9 + 12)) {
          goto LABEL_22;
        }
        goto LABEL_49;
      }

      goto LABEL_71;
    }

    p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    if (qword_1001DCBD8 == -1)
    {
LABEL_45:
      if (_NRLogIsLevelEnabled(qword_1001DCBD0, 17LL))
      {
        if (p_class_meths[379] != (__objc2_meth_list *)-1LL) {
          dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        }
        id v25 = (id)qword_1001DCBD0;
        id String = (void *)NRDataProtectionClassCreateString(a2);
        _NRLogWithArgs(v25, 17LL, "Cannot confirm keys for %@", String);
      }

      goto LABEL_71;
    }
}
}

uint64_t sub_100006260(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  *(unsigned __int8 *)(a1 + 40),  *(unsigned __int8 *)(a1 + 41));
}

void sub_100006278(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a1 + 8) & 0xFE) != 6)
  {
    uint64_t v4 = *(void *)(a1 + 40);
    if (!v4 || !*(_BYTE *)(v4 + 8))
    {
      uint64_t v5 = (id *)sub_100004C0C(a1, a2);
      if (!*v5)
      {
        uint64_t v6 = v5;
        id String = (void *)NRDataProtectionClassCreateString(a2);
        id v8 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 24));
        id v9 = v8;
        if (!v8)
        {
          id v49 = sub_100003B10();
          int IsLevelEnabled = _NRLogIsLevelEnabled(v49, 17LL);

          if (IsLevelEnabled)
          {
            id v51 = sub_100003B10();
            _NRLogWithArgs( v51,  17LL,  "%@: Not starting %@ IKE initiator session because localDevice is missing",  a1,  String);
          }

          sub_100005794(a1, 7, 3);
          goto LABEL_63;
        }

        if ((_DWORD)a2 == 1)
        {
          if (*((unsigned __int16 *)v8 + 14) > 0x12u)
          {
            if (qword_1001DC630 != -1) {
              dispatch_once(&qword_1001DC630, &stru_1001ADE00);
            }
            if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
            {
              id v10 = sub_100003B10();
              _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d %@: Not starting ClassA IKE initiator session because peer supports skipping ClassA pairing %@",  "",  "-[NRPairingClient setupIPsecInitiatorIfNecessary:]",  507LL,  a1,  v9);
            }

            goto LABEL_63;
          }

          id v11 = *((id *)v8 + 11);
        }

        else
        {
          id v11 = sub_10012ADD4(v8, a2);
        }

        id v12 = v11;

        if (!v12)
        {
          if (qword_1001DC630 != -1) {
            dispatch_once(&qword_1001DC630, &stru_1001ADE00);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
          {
            id v23 = sub_100003B10();
            _NRLogWithArgs( v23,  0LL,  "%s%.30s:%-4d %@: Not starting %@ IKE initiator session because we do not have keys %@",  "",  "-[NRPairingClient setupIPsecInitiatorIfNecessary:]",  511LL,  a1,  String,  v9);
          }

          sub_100005794(a1, 7, 8);
          goto LABEL_63;
        }

        v76 = sub_10010C6B8(1, v9, a2);
        if ((_DWORD)a2 != 1)
        {
          uint64_t v13 = *(void *)(a1 + 40);
          if (v13)
          {
            if (*(_BYTE *)(v13 + 11))
            {
              id v14 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  @"::",  @"0"));
              id v15 = objc_alloc(&OBJC_CLASS___NEIKEv2ConfigurationMessage);
              id v16 = [[NEIKEv2InitiatorTransportIPv6Address alloc] initWithAddress:v14];
              v84[0] = v16;
              id v17 = [[NEIKEv2ResponderTransportIPv6Address alloc] initWithAddress:v14];
              v84[1] = v17;
              uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v84,  2LL));
              id v19 = [v15 initWithWithAttributes:v18];
              -[NEIKEv2SessionConfiguration setConfigurationRequest:](v76, "setConfigurationRequest:", v19);
            }
          }
        }

        id v20 = (void *)objc_claimAutoreleasedReturnValue(-[NEIKEv2SessionConfiguration customIKEAuthPrivateNotifies](v76, "customIKEAuthPrivateNotifies"));
        BOOL v21 = v20 == 0LL;

        if (v21)
        {
          v75 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        }

        else
        {
          id v22 = (void *)objc_claimAutoreleasedReturnValue( -[NEIKEv2SessionConfiguration customIKEAuthPrivateNotifies]( v76,  "customIKEAuthPrivateNotifies"));
          v75 = (NSMutableArray *)[v22 mutableCopy];
        }

        if (-[NSMutableArray count](v75, "count")) {
          -[NEIKEv2SessionConfiguration setCustomIKEAuthPrivateNotifies:](v76, "setCustomIKEAuthPrivateNotifies:", v75);
        }
        v74 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"terminusIKE-NRPairing-%@",  String);
        uint64_t v24 = *(id *)(a1 + 40);
        if (!v24 || (BOOL v25 = v24[9] == 0, v24, v25)) {
          id v73 = 0LL;
        }
        else {
          id v73 = (id)a1;
        }
        id v26 = sub_10010C0B8();
        sub_10010BDB0(*(void **)(a1 + 112), v26);
        [v26 setRequestChildlessSA:1];
        v82[0] = 0LL;
        v82[1] = v82;
        int v83 = 0;
        v82[2] = 0x2020000000LL;
        uint64_t v27 = *(id *)(a1 + 40);
        if (!v27 || (BOOL v28 = v27[11] == 0, v27, v28))
        {
          uint64_t v30 = *(void **)(a1 + 40);
          if (v30) {
            uint64_t v30 = (void *)v30[2];
          }
          id v31 = v30;
          [v26 setOutgoingInterfaceName:v31];

          uint64_t v32 = *(void **)(a1 + 40);
          if (v32) {
            uint64_t v32 = (void *)v32[3];
          }
          id v33 = v32;
          [v26 setRemoteEndpoint:v33];

          [v26 setRandomizeLocalPort:1];
          id v29 = sub_10010C340();
          -[NEIKEv2ChildSAConfiguration setMode:](v29, "setMode:", 2LL);
          -[NEIKEv2ChildSAConfiguration setReplayWindowSize:](v29, "setReplayWindowSize:", 4LL);
          v81[0] = _NSConcreteStackBlock;
          v81[1] = 3221225472LL;
          v81[2] = sub_100006C7C;
          v81[3] = &unk_1001AE618;
          v81[4] = v82;
          v72 = objc_retainBlock(v81);
        }

        else
        {
          id v29 = sub_10010C340();
          -[NEIKEv2ChildSAConfiguration setSequencePerTrafficClass:](v29, "setSequencePerTrafficClass:", 1LL);
          -[NEIKEv2ChildSAConfiguration setReplayWindowSize:](v29, "setReplayWindowSize:", 16LL);
          v72 = 0LL;
        }

        id v34 = v26;
        if (qword_1001DC9B8 != -1) {
          dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
        }
        if (byte_1001DC9B0)
        {
          [v34 setForceUDPEncapsulation:1];
          [v34 setRandomizeLocalPort:1];
        }

        char v35 = objc_alloc(&OBJC_CLASS___NEIKEv2Session);
        uint64_t v36 = *(void *)(a1 + 40);
        if (v36) {
          uint64_t v37 = *(void *)(v36 + 40);
        }
        else {
          uint64_t v37 = 0LL;
        }
        char v38 = -[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName:packetDelegate:]( v35,  "initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionNa me:packetDelegate:",  v34,  v29,  v76,  *(void *)(a1 + 32),  v37,  v72,  v74,  v73);
        id v39 = *v6;
        *uint64_t v6 = v38;

        if (*v6)
        {
          switch((_DWORD)a2)
          {
            case 4:
              uint64_t v45 = 17LL;
              break;
            case 3:
              uint64_t v45 = 18LL;
              break;
            case 1:
              uint64_t v45 = 19LL;
              break;
            default:
LABEL_55:
              sub_100003B50((void *)a1, 3015, @"%@ %@", v40, v41, v42, v43, v44, (uint64_t)String);
              sub_100004D7C(a1, a2);
              if (qword_1001DC630 != -1) {
                dispatch_once(&qword_1001DC630, &stru_1001ADE00);
              }
              id v46 = (id)qword_1001DC628;
              int v47 = _NRLogIsLevelEnabled(v46, 0LL);

              if (v47)
              {
                if (qword_1001DC630 != -1) {
                  dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                }
                id v48 = (id)qword_1001DC628;
                _NRLogWithArgs( v48,  0LL,  "%s%.30s:%-4d %@: Connecting initiator %@ session %@",  "",  "-[NRPairingClient setupIPsecInitiatorIfNecessary:]",  637LL,  a1,  String,  *v6);
              }

              [*v6 connect];
              goto LABEL_62;
          }

          *(_BYTE *)(a1 + v45) = 0;
          goto LABEL_55;
        }

        switch((_DWORD)a2)
        {
          case 3:
            unsigned int v56 = ++*(_BYTE *)(a1 + 18);
            id v57 = sub_100003B10();
            v58 = v57;
            if (v56 >= 3)
            {
              int v59 = _NRLogIsLevelEnabled(v57, 17LL);

              if (v59) {
                goto LABEL_79;
              }
              goto LABEL_80;
            }

            int v67 = _NRLogIsLevelEnabled(v57, 16LL);

            if (v67)
            {
              id v66 = sub_100003B10();
              _NRLogWithArgs( v66,  16LL,  "%s%.30s:%-4d %@: Failed to create initiator %@ IKE session",  "",  "-[NRPairingClient setupIPsecInitiatorIfNecessary:]",  588LL,  a1,  String);
              goto LABEL_87;
            }

            break;
          case 4:
            unsigned int v52 = ++*(_BYTE *)(a1 + 17);
            id v53 = sub_100003B10();
            id v54 = v53;
            if (v52 >= 3)
            {
              int v55 = _NRLogIsLevelEnabled(v53, 17LL);

              if (v55) {
                goto LABEL_79;
              }
              goto LABEL_80;
            }

            int v65 = _NRLogIsLevelEnabled(v53, 16LL);

            if (v65)
            {
              id v66 = sub_100003B10();
              _NRLogWithArgs( v66,  16LL,  "%s%.30s:%-4d %@: Failed to create initiator %@ IKE session",  "",  "-[NRPairingClient setupIPsecInitiatorIfNecessary:]",  587LL,  a1,  String);
LABEL_87:
            }

            break;
          case 1:
            unsigned int v60 = ++*(_BYTE *)(a1 + 19);
            id v61 = sub_100003B10();
            v62 = v61;
            if (v60 >= 3)
            {
              int v63 = _NRLogIsLevelEnabled(v61, 17LL);

              if (v63)
              {
LABEL_79:
                id v64 = sub_100003B10();
                _NRLogWithArgs(v64, 17LL, "%@: Failed to create initiator %@ IKE session", a1, String);
              }

LABEL_80:
              sub_100005794(a1, 7, 6);
LABEL_62:
              _Block_object_dispose(v82, 8);

LABEL_63:
              return;
            }

            int v68 = _NRLogIsLevelEnabled(v61, 16LL);

            if (v68)
            {
              id v66 = sub_100003B10();
              _NRLogWithArgs( v66,  16LL,  "%s%.30s:%-4d %@: Failed to create initiator %@ IKE session",  "",  "-[NRPairingClient setupIPsecInitiatorIfNecessary:]",  589LL,  a1,  String);
              goto LABEL_87;
            }

            break;
        }

        objc_initWeak(&location, (id)a1);
        dispatch_time_t v69 = dispatch_time(0x8000000000000000LL, 3000000000LL);
        v70 = *(void **)(a1 + 32);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472LL;
        block[2] = sub_100006CCC;
        block[3] = &unk_1001AF3C8;
        v71 = v70;
        objc_copyWeak(&v78, &location);
        char v79 = a2;
        dispatch_after(v69, v71, block);

        objc_destroyWeak(&v78);
        objc_destroyWeak(&location);
        goto LABEL_62;
      }
    }
  }

    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v3 + 16));
    if (*(_BYTE *)(v3 + 10))
    {
      *(_BYTE *)(v3 + 10) = 0;
      objc_opt_self(&OBJC_CLASS___NRDKeyManager);
      if (qword_1001DCC18 != -1) {
        dispatch_once(&qword_1001DCC18, &stru_1001B0910);
      }
      unsigned int v52 = (id)qword_1001DCC10;
      id v53 = v52;
      if (v52)
      {
        dispatch_assert_queue_V2(*((dispatch_queue_t *)v52 + 2));
        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
        {
          if (qword_1001DCC28 != -1) {
            dispatch_once(&qword_1001DCC28, &stru_1001B0980);
          }
          _NRLogWithArgs( qword_1001DCC20,  0LL,  "%s%.30s:%-4d Unregistering for IDS key manager data protection class updates",  "",  "-[NRDKeyManager unregisterForIDSKeyManagerUpdates]",  107);
        }

        id v54 = (void *)v53[3];
        v53[3] = 0LL;

        if (!v53[3] && !v53[5] && !v53[6]) {
          sub_1001442B0((uint64_t)v53);
        }
      }
    }
  }

void sub_100006C60(_Unwind_Exception *a1)
{
}

uint64_t sub_100006C7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = getpid();
  return NEHelperGetIKESocketWithResult(a3, a4, a5, v9, *(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

void sub_100006CCC(uint64_t a1)
{
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && (WeakRetained[8] & 0xFE) != 6)
  {
    int v3 = *(unsigned __int8 *)(a1 + 40);
    if (v3 == 4)
    {
      if ((WeakRetained[48] & 2) != 0 || *((void *)WeakRetained + 11)) {
        goto LABEL_3;
      }
      uint64_t v4 = WeakRetained;
      sub_1000055CC(WeakRetained, 4LL);
      WeakRetained = v4;
      int v3 = *(unsigned __int8 *)(a1 + 40);
    }

    if (v3 == 3)
    {
      if ((WeakRetained[48] & 4) != 0 || *((void *)WeakRetained + 12)) {
        goto LABEL_3;
      }
      uint64_t v5 = WeakRetained;
      sub_1000055CC(WeakRetained, 3LL);
      WeakRetained = v5;
      int v3 = *(unsigned __int8 *)(a1 + 40);
    }

    if (v3 == 1 && (WeakRetained[48] & 8) == 0 && !*((void *)WeakRetained + 13))
    {
      uint64_t v6 = WeakRetained;
      sub_1000055CC(WeakRetained, 1LL);
      WeakRetained = v6;
    }
  }

LABEL_3:
}

  int v3 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue(objc_msgSend((id)a1, "queue", v68));
  dispatch_assert_queue_V2(v3);

  if (!*(_BYTE *)(a1 + 214) || *(void *)(a1 + 255)) {
    goto LABEL_9;
  }
  uint64_t v4 = objc_alloc(&OBJC_CLASS___NEIKEv2Listener);
  uint64_t v5 = sub_10010C0B8();
  uint64_t v6 = -[NEIKEv2Listener initWithListenerIKEConfig:kernelSASessionName:packetDelegate:listenerQueue:delegate:delegateQueue:]( v4,  "initWithListenerIKEConfig:kernelSASessionName:packetDelegate:listenerQueue:delegate:delegateQueue:",  v5,  @"terminusIKE-QuickRelay-Listener",  a1,  *(void *)(a1 + 8),  a1,  *(void *)(a1 + 8));
  id v7 = *(void **)(a1 + 255);
  *(void *)(a1 + 255) = v6;

  id v8 = *(void *)(a1 + 255);
  id v10 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v9);
  id v11 = (void *)v10;
  if (v8)
  {
    id v12 = _NRLogIsLevelEnabled(v10, 0LL);

    if (!v12) {
      goto LABEL_9;
    }
    id v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v13);
    id v15 = [(id)a1 copyDescription];
    _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d %@: Created IKE listener",  "",  "-[NRLinkQuickRelay setupIKEListener]",  1428LL,  v15);
    goto LABEL_8;
  }

  v58 = _NRLogIsLevelEnabled(v10, 17LL);

  if (v58)
  {
    id v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v59);
    id v15 = [(id)a1 copyDescription];
    _NRLogWithArgs(v14, 17LL, "%@: Failed to create IKE listener", v15);
LABEL_8:
  }
}

  id v11 = 0;
LABEL_4:

  return v11;
}
}

void sub_100006D94(uint64_t a1)
{
  WeakRetained = (void **)objc_loadWeakRetained((id *)(a1 + 40));
  int v3 = WeakRetained;
  if (WeakRetained && ((_BYTE)WeakRetained[1] & 0xFE) != 6)
  {
    *((_BYTE *)WeakRetained + 12) = 0;
    id v15 = WeakRetained;
    uint64_t v4 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, WeakRetained[3]);
    if (!v4)
    {
      id v7 = sub_100003B10();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 16LL);

      if (IsLevelEnabled)
      {
        id v9 = sub_100003B10();
        _NRLogWithArgs( v9,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice2) != ((void *)0)",  "",  "-[NRPairingClient scheduleIKESessionClassADueToConnectFailure]_block_invoke",  675);
      }

      uint64_t v10 = _os_log_pack_size(12LL);
      id v11 = (char *)&v15 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v12 = __error();
      uint64_t v13 = _os_log_pack_fill( v11,  v10,  *v12,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice2) != ((void *)0)");
      *(_DWORD *)uint64_t v13 = 136446210;
      *(void *)(v13 + 4) = "-[NRPairingClient scheduleIKESessionClassADueToConnectFailure]_block_invoke";
      id v14 = sub_100003B10();
      _NRLogAbortWithPack(v14, v11);
    }

    uint64_t v5 = v4;
    if (!v4[14])
    {
      uint64_t v6 = *(void *)(a1 + 32);
    }

    int v3 = v15;
  }
}

void sub_100006F18(id *a1, int a2, void *a3)
{
  if (a1)
  {
    id v6 = a1[3];
    id v7 = a3;
    id v8 = (id)objc_claimAutoreleasedReturnValue([a1 description]);
    sub_10011BB18(v6, a2, v8, v7);
  }

void sub_100006F98(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v7 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    if (v5)
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
      {
        if (qword_1001DC630 != -1) {
          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
        }
        uint64_t v8 = *(void *)(a1 + 32);
        id v9 = (id)qword_1001DC628;
        SessionStateid String = (void *)NEIKEv2CreateSessionStateString(a2);
        _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: pairing session %@ got IKE error %@ with state %@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke",  946LL,  v7,  v8,  v5,  SessionStateString);
      }

      if ((*(_BYTE *)(v7 + 48) & 0x10) == 0 && (*(_BYTE *)(v7 + 8) & 0xFE) != 6)
      {
        sub_100003C00(v7, (id *)(v7 + 88));
        sub_100003C00(v7, (id *)(v7 + 96));
        sub_100003C00(v7, (id *)(v7 + 104));
        unsigned int v11 = ++*(_BYTE *)(v7 + 9);
        if (v11 < 2)
        {
          uint64_t v22 = *(void *)(v7 + 40);
          if (!v22 || !*(_BYTE *)(v22 + 8))
          {
            sub_100003C00(v7, (id *)(v7 + 80));
            id v23 = *(void **)(v7 + 24);
            location[0] = _NSConcreteStackBlock;
            location[1] = (id)3221225472LL;
            id location[2] = sub_10000A458;
            location[3] = &unk_1001ADDB8;
            location[4] = (id)v7;
            sub_1001320DC((uint64_t)&OBJC_CLASS___NRDLocalDevice, v23, 4, location);
          }
        }

        else
        {
          sub_100005794(v7, 7, 4);
        }
      }
    }

    else
    {
      switch(a2)
      {
        case 3LL:
          if (qword_1001DC630 != -1) {
            dispatch_once(&qword_1001DC630, &stru_1001ADE00);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
          {
            if (qword_1001DC630 != -1) {
              dispatch_once(&qword_1001DC630, &stru_1001ADE00);
            }
            _NRLogWithArgs( qword_1001DC628,  0LL,  "%s%.30s:%-4d %@: pairing session IKE disconnected %@ ",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke",  1026LL,  v7,  *(void *)(a1 + 32));
          }

          break;
        case 2LL:
          WeakRetained[6] |= 1uLL;
          sub_100005794((uint64_t)WeakRetained, 3, 0);
          uint64_t v12 = *(void *)(v7 + 40);
          if (!v12 || !*(_BYTE *)(v12 + 8))
          {
            uint64_t v13 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
            if (*(void *)(v7 + 120))
            {
              sub_100006F18((id *)v7, 3400, @"ClassD");
              id v14 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50411 notifyData:*(void *)(v7 + 120)];
              -[NSMutableArray addObject:](v13, "addObject:", v14);
              sub_10000A280(v7);
            }

            if (*(void *)(v7 + 128))
            {
              sub_100006F18((id *)v7, 3400, @"ClassC");
              id v15 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50412 notifyData:*(void *)(v7 + 128)];
              -[NSMutableArray addObject:](v13, "addObject:", v15);
              sub_10000A28C(v7);
            }

            if (*(void *)(v7 + 136))
            {
              sub_100006F18((id *)v7, 3400, @"ClassA");
              id v16 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50413 notifyData:*(void *)(v7 + 136)];
              -[NSMutableArray addObject:](v13, "addObject:", v16);
              sub_10000A298(v7);
            }

            if (-[NSMutableArray count](v13, "count"))
            {
              if (_os_feature_enabled_impl("terminus", "EncryptedIdentity"))
              {
                id v17 = sub_100132028((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(v7 + 24));
                if (v17)
                {
                  sub_100006F18((id *)v7, 3400, @"Identity");
                  id v18 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50351 notifyData:v17];
                  -[NSMutableArray addObject:](v13, "addObject:", v18);
                }
              }

              id v19 = sub_100004570(v7, 0);
              -[NSMutableArray addObjectsFromArray:](v13, "addObjectsFromArray:", v19);

              objc_initWeak(location, (id)v7);
              id v20 = *(void **)(v7 + 80);
              uint64_t v21 = *(void *)(v7 + 32);
              v24[0] = _NSConcreteStackBlock;
              v24[1] = 3221225472LL;
              v24[2] = sub_10000A2A4;
              v24[3] = &unk_1001AF950;
              objc_copyWeak(&v25, location);
              [v20 sendPrivateNotifies:v13 maxRetries:10 retryIntervalInMilliseconds:3000 callbackQueue:v21 callback:v24];
              objc_destroyWeak(&v25);
              objc_destroyWeak(location);
            }
          }

          break;
        case 1LL:
          sub_100005794((uint64_t)WeakRetained, 2, 0);
          break;
      }
    }
  }
}

void sub_10000748C(_Unwind_Exception *a1)
{
}

void sub_1000074A8(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v10 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    if (v10)
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
      {
        if (qword_1001DC630 != -1) {
          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
        }
        id v7 = (id)qword_1001DC628;
        SessionStateid String = (void *)NEIKEv2CreateSessionStateString(a3);
        id v9 = "%s%.30s:%-4d %@: pairing session %@ got child %u state update %@ error %@";
LABEL_15:
        _NRLogWithArgs(v7, 0LL, v9);
      }
    }

    else
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
      {
        if (qword_1001DC630 != -1) {
          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
        }
        id v7 = (id)qword_1001DC628;
        SessionStateid String = (void *)NEIKEv2CreateSessionStateString(a3);
        id v9 = "%s%.30s:%-4d %@: pairing session %@ got child %u state update %@";
        goto LABEL_15;
      }
    }
  }
}

void sub_100007670(uint64_t a1, void *a2)
{
  id v4 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      _NRLogWithArgs( qword_1001DC628,  0LL,  "%s%.30s:%-4d %@: pairing session %@ got config update %@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_4",  1052LL,  WeakRetained,  *(void *)(a1 + 32),  v4);
    }
  }
}

void sub_100007758(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v9 = a3;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      _NRLogWithArgs( qword_1001DC628,  0LL,  "%s%.30s:%-4d %@: pairing session %@ got child %u traffic selector update local %@ remote %@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_5",  1063LL,  WeakRetained,  *(void *)(a1 + 32),  a2,  v9,  v7);
    }
  }
}

void sub_100007864(uint64_t a1, void *a2)
{
  id v4 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      _NRLogWithArgs( qword_1001DC628,  0LL,  "%s%.30s:%-4d %@: pairing session %@ got additional addresses %@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_6",  1072LL,  WeakRetained,  *(void *)(a1 + 32),  v4);
    }
  }
}

void sub_10000794C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  int v3 = WeakRetained;
  if (WeakRetained)
  {
    id v5 = WeakRetained;
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    int IsLevelEnabled = _NRLogIsLevelEnabled(qword_1001DC628, 0LL);
    int v3 = v5;
    if (IsLevelEnabled)
    {
      if (qword_1001DC630 != -1)
      {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
        int v3 = v5;
      }

      _NRLogWithArgs( qword_1001DC628,  0LL,  "%s%.30s:%-4d %@: pairing session %@ got short DPD",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_7",  1080LL,  v3,  *(void *)(a1 + 32));
      int v3 = v5;
    }
  }
}

void sub_100007A30(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v3 sortedArrayUsingComparator:&stru_1001AFCC8]);
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    id v112 = v3;
    if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      _NRLogWithArgs( qword_1001DC628,  0LL,  "%s%.30s:%-4d %@: pairing session %@ got private notifies %@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_8",  1090LL,  WeakRetained,  *(void *)(a1 + 32),  v5);
    }

    __int128 v123 = 0u;
    __int128 v124 = 0u;
    __int128 v121 = 0u;
    __int128 v122 = 0u;
    id v6 = v5;
    id v7 = [v6 countByEnumeratingWithState:&v121 objects:v127 count:16];
    if (v7)
    {
      id v8 = v7;
      uint64_t v9 = *(void *)v122;
      do
      {
        for (i = 0LL; i != v8; i = (char *)i + 1)
        {
          if (*(void *)v122 != v9) {
            objc_enumerationMutation(v6);
          }
          id v16 = *(void **)(*((void *)&v121 + 1) + 8LL * (void)i);
          if ([v16 notifyStatus] == 50351)
          {
            id v11 = WeakRetained[3];
            uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained description]);
            sub_10011BB18(v11, 3401, v12, @"Identity");

            uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v16 notifyData]);
            id v14 = WeakRetained[3];
            v119[0] = _NSConcreteStackBlock;
            v119[1] = 3221225472LL;
            v119[2] = sub_1000094CC;
            v119[3] = &unk_1001AEBB8;
            v120 = WeakRetained;
            sub_100133320((uint64_t)&OBJC_CLASS___NRDLocalDevice, v13, v14, v119);

            id v15 = v120;
            goto LABEL_13;
          }

          if ([v16 notifyStatus] == 50411)
          {
            id v17 = WeakRetained[3];
            id v18 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained description]);
            sub_10011BB18(v17, 3401, v18, @"ClassD");

            id v19 = (void *)objc_claimAutoreleasedReturnValue([v16 notifyData]);
            id v20 = WeakRetained[3];
            v117[0] = _NSConcreteStackBlock;
            v117[1] = 3221225472LL;
            v117[2] = sub_10000978C;
            v117[3] = &unk_1001AEBB8;
            v118 = WeakRetained;
            sub_100133664((uint64_t)&OBJC_CLASS___NRDLocalDevice, v19, v20, v117);

            id v15 = v118;
            goto LABEL_13;
          }

          if ([v16 notifyStatus] == 50412)
          {
            id v21 = WeakRetained[3];
            uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained description]);
            sub_10011BB18(v21, 3401, v22, @"ClassC");

            id v23 = (void *)objc_claimAutoreleasedReturnValue([v16 notifyData]);
            id v24 = WeakRetained[3];
            v115[0] = _NSConcreteStackBlock;
            v115[1] = 3221225472LL;
            v115[2] = sub_100009B34;
            v115[3] = &unk_1001AEBB8;
            v116 = WeakRetained;
            sub_1001339F8((uint64_t)&OBJC_CLASS___NRDLocalDevice, v23, v24, v115);

            id v15 = v116;
            goto LABEL_13;
          }

          if ([v16 notifyStatus] == 50413)
          {
            id v25 = WeakRetained[3];
            id v26 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained description]);
            sub_10011BB18(v25, 3401, v26, @"ClassA");

            uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v16 notifyData]);
            id v28 = WeakRetained[3];
            v113[0] = _NSConcreteStackBlock;
            v113[1] = 3221225472LL;
            v113[2] = sub_100009EDC;
            v113[3] = &unk_1001AEBB8;
            v114 = WeakRetained;
            sub_100133E78((uint64_t)&OBJC_CLASS___NRDLocalDevice, v27, v28, v113);

            id v15 = v114;
            goto LABEL_13;
          }

          id v29 = [v16 notifyStatus];
          id v15 = (id *)(id)objc_claimAutoreleasedReturnValue([v16 notifyData]);
          if (((_BYTE)WeakRetained[1] & 0xFE) != 6)
          {
            if (qword_1001DC630 != -1) {
              dispatch_once(&qword_1001DC630, &stru_1001ADE00);
            }
            if ((_NRLogIsLevelEnabled(qword_1001DC628, 0LL) & 1) != 0)
            {
              if (qword_1001DC630 != -1) {
                dispatch_once(&qword_1001DC630, &stru_1001ADE00);
              }
              id v30 = (id)qword_1001DC628;
              _NRLogWithArgs( v30,  0,  "%s%.30s:%-4d %@: Received notify code %u len %llu",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1336,  WeakRetained,  v29,  [v15 length]);
            }

            if ((int)v29 <= 50500)
            {
              if ((int)v29 <= 50350)
              {
                switch((int)v29)
                {
                  case 48601:
                  case 48607:
                    goto LABEL_79;
                  case 48602:
                    LOWORD(v125) = 0;
                    if ((unint64_t)[v15 length] >= 2)
                    {
                      [v15 getBytes:&v125 length:2];
                      unsigned int v31 = (unsigned __int16)v125;
                      if (qword_1001DC630 != -1) {
                        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                      }
                      uint64_t v32 = bswap32(v31) >> 16;
                      id v33 = (id)qword_1001DC628;
                      int IsLevelEnabled = _NRLogIsLevelEnabled(v33, 0LL);

                      if (IsLevelEnabled)
                      {
                        if (qword_1001DC630 != -1) {
                          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                        }
                        id v35 = (id)qword_1001DC628;
                        _NRLogWithArgs( v35,  0LL,  "%s%.30s:%-4d %@: Received remote terminus version %u",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1349LL,  WeakRetained,  v32);
                      }

                      sub_1001356B8((uint64_t)&OBJC_CLASS___NRDLocalDevice, v32, WeakRetained[3]);
                    }

                    goto LABEL_85;
                  case 48603:
                    v58 = -[NSString initWithData:encoding:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithData:encoding:",  v15,  4LL);
                    if (qword_1001DC630 != -1) {
                      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                    }
                    id v59 = (id)qword_1001DC628;
                    int v60 = _NRLogIsLevelEnabled(v59, 0LL);

                    if (v60)
                    {
                      if (qword_1001DC630 != -1) {
                        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                      }
                      id v61 = (id)qword_1001DC628;
                      _NRLogWithArgs( v61,  0LL,  "%s%.30s:%-4d %@: Received remote device name %@",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1355LL,  WeakRetained,  v58);
                    }

                    sub_100135A50((uint64_t)&OBJC_CLASS___NRDLocalDevice, v58, WeakRetained[3]);

                    goto LABEL_85;
                  case 48604:
                    v62 = -[NSString initWithData:encoding:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithData:encoding:",  v15,  4LL);
                    if (qword_1001DC630 != -1) {
                      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                    }
                    id v63 = (id)qword_1001DC628;
                    int v64 = _NRLogIsLevelEnabled(v63, 0LL);

                    if (v64)
                    {
                      if (qword_1001DC630 != -1) {
                        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                      }
                      id v65 = (id)qword_1001DC628;
                      _NRLogWithArgs( v65,  0LL,  "%s%.30s:%-4d %@: Received remote build version %@",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1361LL,  WeakRetained,  v62);
                    }

                    sub_100135C80((uint64_t)&OBJC_CLASS___NRDLocalDevice, v62, WeakRetained[3]);

                    goto LABEL_85;
                  case 48605:
                    if ([v15 length] == (id)8)
                    {
                      [v15 getBytes:&v125 length:8];
                      if (qword_1001DC630 != -1) {
                        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                      }
                      id v66 = (id)qword_1001DC628;
                      int v67 = _NRLogIsLevelEnabled(v66, 0LL);

                      if (v67)
                      {
                        if (qword_1001DC630 != -1) {
                          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                        }
                        id v68 = (id)qword_1001DC628;
                        _NRLogWithArgs( v68,  0LL,  "%s%.30s:%-4d %@: Received remote device flags %llu",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1380LL,  WeakRetained,  v125);
                      }

                      sub_100136708((uint64_t)&OBJC_CLASS___NRDLocalDevice, v125, WeakRetained[3]);
                      goto LABEL_132;
                    }

                    if (qword_1001DC630 != -1) {
                      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                    }
                    id v79 = (id)qword_1001DC628;
                    int v80 = _NRLogIsLevelEnabled(v79, 16LL);

                    if (!v80) {
                      goto LABEL_85;
                    }
                    if (qword_1001DC630 != -1) {
                      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                    }
                    id v40 = (id)qword_1001DC628;
                    _NRLogWithArgs( v40,  16,  "%s%.30s:%-4d %@: Invalid NRLinkIKEPrivateNotifyCodeDeviceFlags payload length %zu",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1376,  WeakRetained,  [v15 length]);
                    break;
                  case 48606:
                    LOBYTE(v125) = 0;
                    if ([v15 length] == (id)1)
                    {
                      [v15 getBytes:&v125 length:1];
                      v71 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[3], v70);
                      int v72 = _NRLogIsLevelEnabled(v71, 0LL);

                      if (v72)
                      {
                        v74 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[3], v73);
                        v75 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained description]);
                        _NRLogWithArgs( v74,  0LL,  "%s%.30s:%-4d %@: Received remote device type %u",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1369LL,  v75,  v125);
                      }

                      sub_100135884((uint64_t)&OBJC_CLASS___NRDLocalDevice, v125, WeakRetained[3]);
                    }

                    goto LABEL_85;
                  default:
                    if (!(_DWORD)v29) {
                      goto LABEL_79;
                    }
                    if ((_DWORD)v29 != 48701) {
                      goto LABEL_132;
                    }
                    LOBYTE(v125) = 0;
                    if ([v15 length]) {
                      [v15 getBytes:&v125 length:1];
                    }
                    goto LABEL_85;
                }

LABEL_184:
                goto LABEL_85;
              }

              if (((_DWORD)v29 - 50351) > 0x3E
                || ((1LL << (v29 + 81)) & 0x701C000000000003LL) == 0)
              {
                goto LABEL_132;
              }

              goto LABEL_79;
            }

            if ((int)v29 > 50800)
            {
              if ((int)v29 <= 51300)
              {
                switch((int)v29)
                {
                  case 50801:
                    uint64_t v36 = (unsigned __int8 *)WeakRetained[5];
                    if (v36 && (int v37 = v36[8], v36, v37))
                    {
                      if (qword_1001DC630 != -1) {
                        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                      }
                      id v38 = (id)qword_1001DC628;
                      int v39 = _NRLogIsLevelEnabled(v38, 16LL);

                      if (v39)
                      {
                        if (qword_1001DC630 != -1) {
                          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                        }
                        id v40 = (id)qword_1001DC628;
                        _NRLogWithArgs( v40,  16LL,  "%s%.30s:%-4d %@: Did not expect InnerAddressInitiatorClassD as responder",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1416LL,  WeakRetained,  v111);
                        goto LABEL_184;
                      }
                    }

                    else
                    {
                      uint64_t v125 = 0LL;
                      uint64_t v126 = 0LL;
                      if ((unint64_t)[v15 length] > 0xF)
                      {
                        [v15 getBytes:&v125 length:16];
                        int v89 = sub_100137184((uint64_t)&OBJC_CLASS___NRDLocalDevice, (uint64_t)&v125, WeakRetained[3]);
                        if (qword_1001DC630 != -1) {
                          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                        }
                        id v90 = (id)qword_1001DC628;
                        int v91 = _NRLogIsLevelEnabled(v90, 0LL);

                        if (v89)
                        {
                          if (!v91) {
                            goto LABEL_85;
                          }
                          id v92 = sub_100003B10();
                          v94 = (void *)createIPv6AddrString(&v125, v93);
                          _NRLogWithArgs( v92,  0LL,  "%s%.30s:%-4d %@: updated local device with local addresses %@ (classD)",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1426LL,  WeakRetained,  v94);
                        }

                        else
                        {
                          if (!v91) {
                            goto LABEL_85;
                          }
                          id v92 = sub_100003B10();
                          v94 = (void *)createIPv6AddrString(&v125, v107);
                          _NRLogWithArgs( v92,  0LL,  "%s%.30s:%-4d %@: received local classD address %@",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1428LL,  WeakRetained,  v94);
                        }

                        goto LABEL_213;
                      }

                      if (qword_1001DC630 != -1) {
                        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                      }
                      id v81 = (id)qword_1001DC628;
                      int v82 = _NRLogIsLevelEnabled(v81, 16LL);

                      if (v82)
                      {
                        if (qword_1001DC630 != -1) {
                          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                        }
                        id v40 = (id)qword_1001DC628;
                        _NRLogWithArgs( v40,  16LL,  "%s%.30s:%-4d %@: InnerAddressInitiatorClassD payload too short %@",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1421LL,  WeakRetained,  v15);
                        goto LABEL_184;
                      }
                    }

                    goto LABEL_85;
                  case 50802:
                    id v46 = (unsigned __int8 *)WeakRetained[5];
                    if (v46 && (int v47 = v46[8], v46, v47))
                    {
                      if (qword_1001DC630 != -1) {
                        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                      }
                      id v48 = (id)qword_1001DC628;
                      int v49 = _NRLogIsLevelEnabled(v48, 16LL);

                      if (v49)
                      {
                        if (qword_1001DC630 != -1) {
                          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                        }
                        id v40 = (id)qword_1001DC628;
                        _NRLogWithArgs( v40,  16LL,  "%s%.30s:%-4d %@: Did not expect InnerAddressResponderClassD as responder",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1452LL,  WeakRetained,  v111);
                        goto LABEL_184;
                      }
                    }

                    else
                    {
                      uint64_t v125 = 0LL;
                      uint64_t v126 = 0LL;
                      if ((unint64_t)[v15 length] > 0xF)
                      {
                        [v15 getBytes:&v125 length:16];
                        int v95 = sub_1001379CC((uint64_t)&OBJC_CLASS___NRDLocalDevice, (uint64_t)&v125, WeakRetained[3]);
                        if (qword_1001DC630 != -1) {
                          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                        }
                        id v96 = (id)qword_1001DC628;
                        int v97 = _NRLogIsLevelEnabled(v96, 0LL);

                        if (v95)
                        {
                          if (!v97) {
                            goto LABEL_85;
                          }
                          id v92 = sub_100003B10();
                          v94 = (void *)createIPv6AddrString(&v125, v98);
                          _NRLogWithArgs( v92,  0LL,  "%s%.30s:%-4d %@: updated local device with remote addresses %@ (classD)",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1462LL,  WeakRetained,  v94);
                        }

                        else
                        {
                          if (!v97) {
                            goto LABEL_85;
                          }
                          id v92 = sub_100003B10();
                          v94 = (void *)createIPv6AddrString(&v125, v108);
                          _NRLogWithArgs( v92,  0LL,  "%s%.30s:%-4d %@: received remote classD address %@",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1464LL,  WeakRetained,  v94);
                        }

                        goto LABEL_213;
                      }

                      if (qword_1001DC630 != -1) {
                        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                      }
                      id v83 = (id)qword_1001DC628;
                      int v84 = _NRLogIsLevelEnabled(v83, 16LL);

                      if (v84)
                      {
                        if (qword_1001DC630 != -1) {
                          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                        }
                        id v40 = (id)qword_1001DC628;
                        _NRLogWithArgs( v40,  16LL,  "%s%.30s:%-4d %@: InnerAddressResponderClassD payload too short %@",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1457LL,  WeakRetained,  v15);
                        goto LABEL_184;
                      }
                    }

                    goto LABEL_85;
                  case 50803:
                  case 50804:
                  case 50805:
                  case 50806:
                  case 50807:
                  case 50808:
                  case 50809:
                  case 50810:
                    goto LABEL_132;
                  case 50811:
                    uint64_t v50 = (unsigned __int8 *)WeakRetained[5];
                    if (v50 && (int v51 = v50[8], v50, v51))
                    {
                      if (qword_1001DC630 != -1) {
                        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                      }
                      id v52 = (id)qword_1001DC628;
                      int v53 = _NRLogIsLevelEnabled(v52, 16LL);

                      if (v53)
                      {
                        if (qword_1001DC630 != -1) {
                          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                        }
                        id v40 = (id)qword_1001DC628;
                        _NRLogWithArgs( v40,  16LL,  "%s%.30s:%-4d %@: Did not expect InnerAddressInitiatorClassC as responder",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1434LL,  WeakRetained,  v111);
                        goto LABEL_184;
                      }
                    }

                    else
                    {
                      uint64_t v125 = 0LL;
                      uint64_t v126 = 0LL;
                      if ((unint64_t)[v15 length] > 0xF)
                      {
                        [v15 getBytes:&v125 length:16];
                        int v99 = sub_1001375A8((uint64_t)&OBJC_CLASS___NRDLocalDevice, (uint64_t)&v125, WeakRetained[3]);
                        if (qword_1001DC630 != -1) {
                          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                        }
                        id v100 = (id)qword_1001DC628;
                        int v101 = _NRLogIsLevelEnabled(v100, 0LL);

                        if (v99)
                        {
                          if (!v101) {
                            goto LABEL_85;
                          }
                          id v92 = sub_100003B10();
                          v94 = (void *)createIPv6AddrString(&v125, v102);
                          _NRLogWithArgs( v92,  0LL,  "%s%.30s:%-4d %@: updated local device with local addresses %@ (classC)",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1444LL,  WeakRetained,  v94);
                        }

                        else
                        {
                          if (!v101) {
                            goto LABEL_85;
                          }
                          id v92 = sub_100003B10();
                          v94 = (void *)createIPv6AddrString(&v125, v109);
                          _NRLogWithArgs( v92,  0LL,  "%s%.30s:%-4d %@: received local classC address %@",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1446LL,  WeakRetained,  v94);
                        }

                        goto LABEL_213;
                      }

                      if (qword_1001DC630 != -1) {
                        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                      }
                      id v85 = (id)qword_1001DC628;
                      int v86 = _NRLogIsLevelEnabled(v85, 16LL);

                      if (v86)
                      {
                        if (qword_1001DC630 != -1) {
                          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                        }
                        id v40 = (id)qword_1001DC628;
                        _NRLogWithArgs( v40,  16LL,  "%s%.30s:%-4d %@: InnerAddressInitiatorClassC payload too short %@",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1439LL,  WeakRetained,  v15);
                        goto LABEL_184;
                      }
                    }

                    goto LABEL_85;
                  case 50812:
                    id v54 = (unsigned __int8 *)WeakRetained[5];
                    if (v54 && (int v55 = v54[8], v54, v55))
                    {
                      if (qword_1001DC630 != -1) {
                        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                      }
                      id v56 = (id)qword_1001DC628;
                      int v57 = _NRLogIsLevelEnabled(v56, 16LL);

                      if (v57)
                      {
                        if (qword_1001DC630 != -1) {
                          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                        }
                        id v40 = (id)qword_1001DC628;
                        _NRLogWithArgs( v40,  16LL,  "%s%.30s:%-4d %@: Did not expect InnerAddressResponderClassC as responder",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1470LL,  WeakRetained,  v111);
                        goto LABEL_184;
                      }
                    }

                    else
                    {
                      uint64_t v125 = 0LL;
                      uint64_t v126 = 0LL;
                      if ((unint64_t)[v15 length] > 0xF)
                      {
                        [v15 getBytes:&v125 length:16];
                        int v103 = sub_100137DF0((uint64_t)&OBJC_CLASS___NRDLocalDevice, (uint64_t)&v125, WeakRetained[3]);
                        if (qword_1001DC630 != -1) {
                          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                        }
                        id v104 = (id)qword_1001DC628;
                        int v105 = _NRLogIsLevelEnabled(v104, 0LL);

                        if (v103)
                        {
                          if (!v105) {
                            goto LABEL_85;
                          }
                          id v92 = sub_100003B10();
                          v94 = (void *)createIPv6AddrString(&v125, v106);
                          _NRLogWithArgs( v92,  0LL,  "%s%.30s:%-4d %@: updated local device with remote addresses %@ (classC)",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1480LL,  WeakRetained,  v94);
                        }

                        else
                        {
                          if (!v105) {
                            goto LABEL_85;
                          }
                          id v92 = sub_100003B10();
                          v94 = (void *)createIPv6AddrString(&v125, v110);
                          _NRLogWithArgs( v92,  0LL,  "%s%.30s:%-4d %@: received remote classC address %@",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1482LL,  WeakRetained,  v94);
                        }

LABEL_213:
                      }

                      else
                      {
                        if (qword_1001DC630 != -1) {
                          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                        }
                        id v87 = (id)qword_1001DC628;
                        int v88 = _NRLogIsLevelEnabled(v87, 16LL);

                        if (v88)
                        {
                          if (qword_1001DC630 != -1) {
                            dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                          }
                          id v40 = (id)qword_1001DC628;
                          _NRLogWithArgs( v40,  16LL,  "%s%.30s:%-4d %@: InnerAddressResponderClassC payload too short %@",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1475LL,  WeakRetained,  v15);
                          goto LABEL_184;
                        }
                      }
                    }

                    break;
                  default:
                    if ((_DWORD)v29 == 50901) {
                      goto LABEL_79;
                    }
                    goto LABEL_132;
                }

                goto LABEL_85;
              }

              if ((int)v29 > 51500)
              {
                if ((_DWORD)v29 == 51501)
                {
                  LOBYTE(v125) = 0;
                  [v15 getBytes:&v125 length:1];
                  if (qword_1001DC630 != -1) {
                    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                  }
                  id v76 = (id)qword_1001DC628;
                  int v77 = _NRLogIsLevelEnabled(v76, 0LL);

                  if (v77)
                  {
                    if (qword_1001DC630 != -1) {
                      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
                    }
                    id v78 = (id)qword_1001DC628;
                    _NRLogWithArgs( v78,  0LL,  "%s%.30s:%-4d %@: Received IsAltAccount: %u",  "",  "-[NRPairingClient handleNotifyCode:payload:]",  1397LL,  WeakRetained,  v125);
                  }

                  sub_100136370((uint64_t)&OBJC_CLASS___NRDLocalDevice, v125 == 1, WeakRetained[3]);
                  goto LABEL_85;
                }

                if ((_DWORD)v29 == 51601)
                {
                  uint64_t v44 = (unsigned __int8 *)WeakRetained[5];
                  if (v44)
                  {
                    int v45 = v44[8];

                    if (v45) {
                      sub_100005FF4((uint64_t)WeakRetained);
                    }
                  }

                  goto LABEL_85;
                }

                if (v215) {
                  *((_BYTE *)v215 + _Block_object_dispose((const void *)(v1 - 144), 8) = 1;
                }
                v166 = -[NSMutableData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSMutableData),  "initWithBytes:length:",  v233,  9LL);
                v167 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
                v230 = 0u;
                v231 = 0u;
                v228 = 0u;
                v229 = 0u;
                v168 = v86;
                v169 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v168,  "countByEnumeratingWithState:objects:count:",  &v228,  v248,  16LL);
                if (v169)
                {
                  v170 = *(void *)v229;
                  do
                  {
                    for (j = 0LL; j != v169; j = (char *)j + 1)
                    {
                      if (*(void *)v229 != v170) {
                        objc_enumerationMutation(v168);
                      }
                      v172 = *(void **)(*((void *)&v228 + 1) + 8LL * (void)j);
                      v173 = -[NSMutableString length](v167, "length", v212) == 0LL;
                      ShortStringFromNRLinkSubtype = createShortStringFromNRLinkSubtype([v172 unsignedCharValue]);
                      v175 = (void *)ShortStringFromNRLinkSubtype;
                      if (v173) {
                        -[NSMutableString appendString:](v167, "appendString:", ShortStringFromNRLinkSubtype);
                      }
                      else {
                        -[NSMutableString appendFormat:]( v167,  "appendFormat:",  @"/%@",  ShortStringFromNRLinkSubtype);
                      }
                    }

                    v169 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v168,  "countByEnumeratingWithState:objects:count:",  &v228,  v248,  16LL);
                  }

                  while (v169);
                }

                sub_1000D4F78(v216, 1050, @"send req %d %@", v176, v177, v178, v179, v180, (_DWORD)v212 == 2);
                v226 = 0u;
                v227 = 0u;
                v224 = 0u;
                v225 = 0u;
                v181 = v168;
                v182 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v181,  "countByEnumeratingWithState:objects:count:",  &v224,  v247,  16LL);
                if (!v182) {
                  goto LABEL_239;
                }
                v183 = *(void *)v225;
LABEL_227:
                v184 = 0LL;
                while (1)
                {
                  if (*(void *)v225 != v183) {
                    objc_enumerationMutation(v181);
                  }
                  v185 = *(void **)(*((void *)&v224 + 1) + 8 * v184);
                  v186 = (objc_msgSend(v185, "unsignedCharValue", v212) - 101);
                  if (v186 >= 4) {
                    break;
                  }
                  v232 = 0x7060502u >> (8 * v186);
                  if (!v232) {
                    goto LABEL_235;
                  }
LABEL_229:
                  NRTLVAdd(v166, 1LL, 1LL, &v232);
LABEL_230:
                  if (v182 == (id)++v184)
                  {
                    v182 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v181,  "countByEnumeratingWithState:objects:count:",  &v224,  v247,  16LL);
                    if (!v182)
                    {
LABEL_239:

                      sub_1000222F4((uint64_t)v215, 13, v166);
                      goto LABEL_240;
                    }

                    goto LABEL_227;
                  }
                }

                v232 = 0;
LABEL_235:
                v187 = [v185 unsignedCharValue];
                if (v187 > 5) {
                  goto LABEL_230;
                }
                v232 = 0x40300020100uLL >> (8 * v187);
                if (!v232) {
                  goto LABEL_230;
                }
                goto LABEL_229;
              case 4:
              case 5:
              case 8:
                id v28 = 1;
                if (v214) {
                  *((_BYTE *)v217 + 12) = 1;
                }
                else {
                  v214 = 0LL;
                }
                id v29 = v216;
                goto LABEL_250;
              case 6:
              case 7:
                if (!v214) {
                  goto LABEL_125;
                }
                if (*((_BYTE *)v217 + 11)
                  && (id v26 = v217, sub_1000D4B98(v216, *((unsigned __int8 *)v217 + 11))))
                {

                  uint64_t v36 = v217[7];
                  int v37 = v36 == 0LL;

                  id v26 = v217;
                  if (!v37)
                  {
                    v214 = 0LL;
                    goto LABEL_261;
                  }

LABEL_85:
LABEL_13:
        }

        id v8 = [v6 countByEnumeratingWithState:&v121 objects:v127 count:16];
      }

      while (v8);
    }

    id v3 = v112;
  }
}

                v128 = sub_100070554();
                v129 = _NRLogIsLevelEnabled(v128, 16LL);

                if (v129)
                {
                  v130 = sub_100070554();
                  _NRLogWithArgs( v130,  16LL,  "%s%.30s:%-4d ABORTING: strict_malloc(%zu) failed",  "",  "strict_malloc",  79,  v16);
                }

                id v6 = (NRLinkBluetooth *)_os_log_pack_size(22LL);
                v131 = (char *)&v375 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL);
                v132 = __error();
                v133 = _os_log_pack_fill( v131,  v6,  *v132,  &_mh_execute_header,  "%{public}s strict_malloc(%zu) failed");
                *(_DWORD *)v133 = 136446466;
                *(void *)(v133 + 4) = "strict_malloc";
                *(_WORD *)(v133 + 12) = 2048;
                *(void *)(v133 + 14) = v16;
                v134 = sub_100070554();
                v120 = _NRLogAbortWithPack(v134, v131);
                goto LABEL_88;
              }
            }

            __int128 v123 = sub_100070554();
            __int128 v124 = _NRLogIsLevelEnabled(v123, 16LL);

            if (v124)
            {
              uint64_t v125 = sub_100070554();
              _NRLogWithArgs( v125,  16LL,  "%s%.30s:%-4d ABORTING: strict_malloc called with size 0",  "",  "strict_malloc",  74);
            }

            id v16 = _os_log_pack_size(12LL);
            id v6 = (NRLinkBluetooth *)((char *)&v375 - ((__chkstk_darwin(v16) + 15) & 0xFFFFFFFFFFFFFFF0LL));
            uint64_t v126 = __error();
            v127 = _os_log_pack_fill( v6,  v16,  *v126,  &_mh_execute_header,  "%{public}s strict_malloc called with size 0");
            *(_DWORD *)v127 = 136446210;
            *(void *)(v127 + 4) = "strict_malloc";
            goto LABEL_115;
          }

          v148 = sub_100070554();
          LODWORD(v6) = _NRLogIsLevelEnabled(v148, 17LL);

          if (!(_DWORD)v6) {
            return (char)v6;
          }
          v145 = sub_100070554();
          _NRLogWithArgs(v145, 17LL, "%s called with null self.remoteDeviceName");
        }

        else
        {
          v147 = sub_100070554();
          LODWORD(v6) = _NRLogIsLevelEnabled(v147, 17LL);

          if (!(_DWORD)v6) {
            return (char)v6;
          }
          v145 = sub_100070554();
          _NRLogWithArgs(v145, 17LL, "%s called with null self.bluetoothUUID");
        }
      }

      else
      {
        v146 = sub_100070554();
        LODWORD(v6) = _NRLogIsLevelEnabled(v146, 17LL);

        if (!(_DWORD)v6) {
          return (char)v6;
        }
        v145 = sub_100070554();
        _NRLogWithArgs(v145, 17LL, "%s called with null self.pipe");
      }
    }

    else
    {
      v144 = sub_100070554();
      LODWORD(v6) = _NRLogIsLevelEnabled(v144, 17LL);

      if (!(_DWORD)v6) {
        return (char)v6;
      }
      v145 = sub_100070554();
      _NRLogWithArgs(v145, 17LL, "%s called with null self.queue");
    }

    LOBYTE(v6) = 0;
    return (char)v6;
  }

  return -[NRLinkBluetooth resume](v6, "resume");
}

  objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
  sub_1000A49E8((char *)a1);
  id v54 = (__objc2_class *)&APSConnectionOverrideNamedDelegatePort_ptr;
  objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
  int v55 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v55);

  block = (objc_super)xmmword_100156950;
  id v56 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &block, 16LL);
  int v57 = sub_10012D958((uint64_t)&OBJC_CLASS___NRDLocalDevice, v56, @"0");
  v58 = (void *)objc_claimAutoreleasedReturnValue(v57);

  id v59 = (char *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:",  v58,  64LL));
  if (!v59)
  {
    int v72 = sub_1000A2100();
    uint64_t v73 = _NRLogIsLevelEnabled(v72, 16LL);

    if (v73)
    {
      v74 = sub_1000A2100();
      _NRLogWithArgs( v74,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (conditionPrefix) != ((void *)0)",  "",  "-[NRLinkDirector startDirector]",  317);
    }

    id v59 = (char *)_os_log_pack_size(12LL);
    v62 = (char *)&v93[-1] - ((__chkstk_darwin(v59) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    v75 = __error();
    id v76 = _os_log_pack_fill( v62,  v59,  *v75,  &_mh_execute_header,  "%{public}s Assertion Failed: (conditionPrefix) != ((void *)0)");
    *(_DWORD *)id v76 = 136446210;
    *(void *)(v76 + 4) = "-[NRLinkDirector startDirector]";
    int v77 = sub_1000A2100();
    _NRLogAbortWithPack(v77, v62);
    goto LABEL_104;
  }

  int v60 = objc_alloc(&OBJC_CLASS___NEPolicy);
  id v61 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult drop](&OBJC_CLASS___NEPolicyResult, "drop"));
  v99[0] = v59;
  id v54 = (__objc2_class *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
  v99[1] = v54;
  p_class_meths = (_UNKNOWN **)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v99,  2LL));
  v62 = (char *)[v60 initWithOrder:5000 result:v61 conditions:p_class_meths];

  if (!v62)
  {
    id v78 = sub_1000A2100();
    id v79 = _NRLogIsLevelEnabled(v78, 16LL);

    if (v79)
    {
      int v80 = sub_1000A2100();
      _NRLogWithArgs( v80,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (policyDropPrefix) != ((void *)0)",  "",  "-[NRLinkDirector startDirector]",  322);
    }

    v62 = (char *)_os_log_pack_size(12LL);
    id v59 = (char *)&v93[-1] - ((__chkstk_darwin(v62) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v81 = __error();
    int v82 = _os_log_pack_fill( v59,  v62,  *v81,  &_mh_execute_header,  "%{public}s Assertion Failed: (policyDropPrefix) != ((void *)0)");
    *(_DWORD *)int v82 = 136446210;
    *(void *)(v82 + 4) = "-[NRLinkDirector startDirector]";
    id v83 = sub_1000A2100();
    _NRLogAbortWithPack(v83, v59);
LABEL_104:
    __break(1u);
    goto LABEL_105;
  }

  id v54 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
  objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
  p_class_meths = (_UNKNOWN **)&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  if (qword_1001DCB60 != -1) {
LABEL_105:
  }
    dispatch_once(&qword_1001DCB60, &stru_1001B0538);
  id v63 = (id)qword_1001DCB58;
  int v64 = sub_100120E44((uint64_t)v63, @"NRLinkDirector-Drop", v62);

  objc_opt_self(&v54[63]);
  if (p_class_meths[364] != (_UNKNOWN *)-1LL) {
    dispatch_once(&qword_1001DCB60, &stru_1001B0538);
  }
  id v65 = (id)qword_1001DCB58;
  id v66 = (id *)v65;
  if (v65)
  {
    dispatch_assert_queue_V2(*((dispatch_queue_t *)v65 + 1));
    if (([v66[2] apply] & 1) == 0) {
      sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v67,  v68,  v69,  v92);
    }
  }

  sub_10011BB18(0LL, 1002, 0LL, 0LL);
}

void sub_1000094CC(uint64_t a1, void *a2)
{
  id v17 = a2;
  if (qword_1001DC630 != -1) {
    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    _NRLogWithArgs( qword_1001DC628,  0LL,  "%s%.30s:%-4d %@: Plumbed device identity %@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_9",  1097LL,  *(void *)(a1 + 32),  v17);
  }

  if (qword_1001DC630 != -1) {
    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    uint64_t v3 = *(void *)(a1 + 32);
    id v4 = (id)qword_1001DC628;
    if (v17)
    {
      id v5 = v17[8];
      id v6 = v5;
      if (v5) {
        id v7 = (void *)*((void *)v5 + 1);
      }
      else {
        id v7 = 0LL;
      }
    }

    else
    {
      id v6 = 0LL;
      id v7 = 0LL;
    }

    id v8 = v7;
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v8 UUIDString]);
    _NRLogWithArgs( v4,  0LL,  "%s%.30s:%-4d %@: deviceIdentityUUID=%@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_9",  1099LL,  v3,  v9);
  }

  if (qword_1001DC630 != -1) {
    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    uint64_t v10 = *(void *)(a1 + 32);
    id v11 = (id)qword_1001DC628;
    if (v17)
    {
      id v12 = v17[8];
      uint64_t v13 = v12;
      if (v12) {
        id v14 = (void *)*((void *)v12 + 2);
      }
      else {
        id v14 = 0LL;
      }
    }

    else
    {
      uint64_t v13 = 0LL;
      id v14 = 0LL;
    }

    id v15 = v14;
    Logid String = (void *)_NRKeyCreateLogString(v15);
    _NRLogWithArgs( v11,  0LL,  "%s%.30s:%-4d %@: deviceIdentityPublicKey=%@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_9",  1101LL,  v10,  LogString);
  }
}

void sub_10000978C(uint64_t a1, void *a2)
{
  id v24 = a2;
  if (qword_1001DC630 != -1) {
    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    _NRLogWithArgs( qword_1001DC628,  0LL,  "%s%.30s:%-4d %@: Plumbed classD keys with OOBK %@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_10",  1108LL,  *(void *)(a1 + 32),  v24);
  }

  if (v24) {
    uint64_t v3 = (void *)v24[9];
  }
  else {
    uint64_t v3 = 0LL;
  }
  id v4 = v3;
  if (qword_1001DC630 != -1) {
    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    uint64_t v5 = *(void *)(a1 + 32);
    id v6 = (id)qword_1001DC628;
    if (v4) {
      id v7 = (void *)*((void *)v4 + 1);
    }
    else {
      id v7 = 0LL;
    }
    id v8 = v7;
    uint64_t v9 = sub_100124E58(v8);
    Logid String = (void *)_NRKeyCreateLogString(v9);
    _NRLogWithArgs( v6,  0LL,  "%s%.30s:%-4d %@: classDRemotePublicKey=%@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_10",  1111LL,  v5,  LogString);
  }

  if (qword_1001DC630 != -1) {
    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    uint64_t v11 = *(void *)(a1 + 32);
    id v12 = (id)qword_1001DC628;
    if (v4) {
      uint64_t v13 = (void *)*((void *)v4 + 2);
    }
    else {
      uint64_t v13 = 0LL;
    }
    id v14 = v13;
    id v15 = sub_100124E58(v14);
    id v16 = (void *)_NRKeyCreateLogString(v15);
    _NRLogWithArgs( v12,  0LL,  "%s%.30s:%-4d %@: classDLocalPublicKey=%@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_10",  1113LL,  v11,  v16);
  }

  if (qword_1001DC630 != -1) {
    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    uint64_t v17 = *(void *)(a1 + 32);
    id v18 = (id)qword_1001DC628;
    if (v4)
    {
      id v19 = *((id *)v4 + 3);
      id v20 = v19;
      if (v19)
      {
        id v21 = (void *)*((void *)v19 + 2);
LABEL_33:
        id v22 = v21;
        id v23 = (void *)_NRKeyCreateLogString(v22);
        _NRLogWithArgs( v18,  0LL,  "%s%.30s:%-4d %@: classDSharedSecret=%@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_10",  1115LL,  v17,  v23);

        goto LABEL_34;
      }
    }

    else
    {
      id v20 = 0LL;
    }

    id v21 = 0LL;
    goto LABEL_33;
  }

LABEL_34:
  sub_100005BE0(*(void *)(a1 + 32), 4);
}

  sub_100005BE0(*(void *)(a1 + 32), 3);
}

  sub_100005BE0(*(void *)(a1 + 32), 1);
}

  return v18;
}

    int v37 = 0LL;
    goto LABEL_39;
  }

  id v6 = *(void *)((char *)v3 + 295);
  if (!v6)
  {
    id v38 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v4);
    int v39 = _NRLogIsLevelEnabled(v38, 17LL);

    if (v39)
    {
      id v35 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v40);
      uint64_t v36 = [v5 copyDescription];
      _NRLogWithArgs(v35, 17LL, "%@: No nexus channel", v36);
      goto LABEL_33;
    }

    goto LABEL_34;
  }

  id v7 = os_channel_ring_id(v6, 2LL);
  id v8 = os_channel_rx_ring(*(void *)((char *)v5 + 295), v7);
  uint64_t v9 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  v58 = v8;
  next_slot = os_channel_get_next_slot(v8, 0LL, v62);
  if (next_slot)
  {
    id v12 = next_slot;
    int v57 = a2;
    while (2)
    {
      uint64_t v13 = v9;
      id v14 = v12;
      id v15 = v64;
      id v16 = v63;
      *(void *)((char *)v5 + 431) += v63;
      uint64_t v17 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
      LODWORD(v12) = 2048;
      id v18 = v65;
      bzero(v65, 0x800uLL);
      if (v16 >= 0x7FC)
      {
        id v12 = v16 + 5;
        id v19 = calloc(1uLL, v16 + 5);
        if (!v19)
        {
          int v47 = sub_10003B584();
          id v48 = _NRLogIsLevelEnabled(v47, 16LL);

          if (v48)
          {
            int v49 = sub_10003B584();
            _NRLogWithArgs( v49,  16LL,  "%s%.30s:%-4d ABORTING: strict_calloc(%zu, %zu) failed",  "",  "strict_calloc",  108,  1uLL,  v16 + 5);
          }

          uint64_t v50 = _os_log_pack_size(32LL);
          int v51 = (char *)&v55 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          id v52 = __error();
          int v53 = _os_log_pack_fill( v51,  v50,  *v52,  &_mh_execute_header,  "%{public}s strict_calloc(%zu, %zu) failed");
          *(_DWORD *)int v53 = 136446722;
          *(void *)(v53 + 4) = "strict_calloc";
          *(_WORD *)(v53 + 12) = 2048;
          *(void *)(v53 + 14) = 1LL;
          *(_WORD *)(v53 + 22) = 2048;
          *(void *)(v53 + 24) = v12;
          id v54 = sub_10003B584();
          _NRLogAbortWithPack(v54, v51);
        }

        id v18 = v19;
      }

      id v59 = v18;
      id v61 = 0;
      int v60 = v12;
      id v20 = nrPacketToTLV(v15, v16, &v59, 1LL, (char *)v5 + 655, (char *)v5 + 671);
      id v21 = v20;
      int v60 = v20;
      id v22 = v59;
      id v23 = *v59;
      switch(*v59)
      {
        case 'd':
          id v24 = &OBJC_IVAR___NRLinkQuickRelay__sentKnownIPv6Hdr_ESP;
          goto LABEL_20;
        case 'e':
          id v24 = &OBJC_IVAR___NRLinkQuickRelay__sentKnownIPv6Hdr_ESP_ECT0;
          goto LABEL_20;
        case 'f':
          id v24 = &OBJC_IVAR___NRLinkQuickRelay__sentKnownIPv6Hdr_TCP;
          goto LABEL_20;
        case 'g':
          id v24 = &OBJC_IVAR___NRLinkQuickRelay__sentKnownIPv6Hdr_TCP_ECT0;
          goto LABEL_20;
        case 'h':
          id v24 = &OBJC_IVAR___NRLinkQuickRelay__sentKnownIPv6Hdr_ESP_ClassC;
          goto LABEL_20;
        case 'i':
          id v24 = &OBJC_IVAR___NRLinkQuickRelay__sentKnownIPv6Hdr_ESP_ClassC_ECT0;
          goto LABEL_20;
        default:
          if ((_DWORD)v23 == 2)
          {
            id v24 = &OBJC_IVAR___NRLinkQuickRelay__sentUncompressedIP;
          }

          else
          {
            if ((_DWORD)v23 != 3) {
              goto LABEL_21;
            }
            id v24 = &OBJC_IVAR___NRLinkQuickRelay__sentEncapsulated6LoWPAN;
          }

  -[NSMutableArray addObject:](v3, "addObject:", @"RdFair");
  if ((a1 & 0x100000) == 0)
  {
LABEL_9:
    if ((a1 & 0x200000) == 0) {
      goto LABEL_10;
    }
    goto LABEL_36;
  }
              }

              id v14 = [v12 countByEnumeratingWithState:&v29 objects:v33 count:16];
            }

            while (v14);
          }

          uint64_t v10 = v26;
          id v8 = v27;
LABEL_41:

          if (-[NSMutableArray count](v11, "count")) {
            -[NSMutableArray addObjectsFromArray:](v28, "addObjectsFromArray:", v11);
          }

          goto LABEL_44;
        }
      }

      else
      {
        uint64_t v10 = 0LL;
      }

      uint64_t v11 = 0LL;
      goto LABEL_41;
    }
  }

  id v63 = [0 copy];
  [v8 setBluetoothUUID:v63];

  idsDeviceID = 0LL;
LABEL_5:
  uint64_t v11 = -[NSString copy](idsDeviceID, "copy");
  [v8 setIdsDeviceID:v11];

  id v12 = (void *)objc_claimAutoreleasedReturnValue(-[NRDLocalDevice dateCreated](self, "dateCreated"));
  uint64_t v13 = [v12 copy];
  [v8 setDateCreated:v13];

  objc_msgSend(v8, "setIsEmptyPairing:", -[NRDLocalDevice isEmptyPairing](self, "isEmptyPairing"));
  if (self)
  {
    v8[24] = self->_isEphemeral;
    if ([v8 isEmptyPairing])
    {
      isChanged = self->_isChanged;
LABEL_8:
      v8[21] = isChanged;
      goto LABEL_29;
    }

    [v8 setIsRegistered:self->_isRegistered];
    isEnabled = self->_isEnabled;
  }

  else
  {
    v8[24] = 0;
    int v64 = [v8 isEmptyPairing];
    isChanged = 0;
    if ((v64 & 1) != 0) {
      goto LABEL_8;
    }
    [v8 setIsRegistered:0];
    isEnabled = 0LL;
  }

  [v8 setIsEnabled:isEnabled];
  objc_msgSend( v8,  "setPairingProtocolVersion:",  -[NRDLocalDevice pairingProtocolVersion](self, "pairingProtocolVersion"));
  if (self)
  {
    [v8 setLastSeenInnerLinkVersionHBO:self->_lastSeenInnerLinkVersionHBO];
    lastSeenName = self->_lastSeenName;
  }

  else
  {
    [v8 setLastSeenInnerLinkVersionHBO:0];
    lastSeenName = 0LL;
  }

  uint64_t v17 = -[NSString copy](lastSeenName, "copy");
  [v8 setLastSeenName:v17];

  if (self)
  {
    id v18 = -[NSString copy](self->_lastSeenBuildVersion, "copy");
    [v8 setLastSeenBuildVersion:v18];

    [v8 setWasInitiallySetupUsingIDSPairing:self->_wasInitiallySetupUsingIDSPairing];
    [v8 setIsAltAccountDevice:self->_isAltAccountDevice];
    lastSeenAlwaysOnWiFiSupported = self->_lastSeenAlwaysOnWiFiSupported;
  }

  else
  {
    id v65 = [0 copy];
    [v8 setLastSeenBuildVersion:v65];

    [v8 setWasInitiallySetupUsingIDSPairing:0];
    [v8 setIsAltAccountDevice:0];
    lastSeenAlwaysOnWiFiSupported = 0LL;
  }

  [v8 setLastSeenAlwaysOnWiFiSupported:lastSeenAlwaysOnWiFiSupported];
  id v20 = (void *)objc_claimAutoreleasedReturnValue(-[NRDLocalDevice dateRegistered](self, "dateRegistered"));
  id v21 = [v20 copy];
  [v8 setDateRegistered:v21];

  id v22 = (void *)objc_claimAutoreleasedReturnValue(-[NRDLocalDevice dateEnabled](self, "dateEnabled"));
  id v23 = [v22 copy];
  [v8 setDateEnabled:v23];

  if (self)
  {
    id v24 = -[NSUUID copy](self->_localIdentity, "copy");
    [v8 setLocalIdentity:v24];

    remoteIdentity = self->_remoteIdentity;
  }

  else
  {
    id v66 = [0 copy];
    [v8 setLocalIdentity:v66];

    remoteIdentity = 0LL;
  }

  id v26 = -[NRDDeviceIdentity copy](remoteIdentity, "copy");
  [v8 setRemoteIdentity:v26];

  if (self)
  {
    [v8 setHasAuthenticatedWithIdentity:self->_hasAuthenticatedWithIdentity];
    classDKeychainItems = self->_classDKeychainItems;
  }

  else
  {
    [v8 setHasAuthenticatedWithIdentity:0];
    classDKeychainItems = 0LL;
  }

  id v28 = classDKeychainItems;
  id v29 = -[NRDLDDataClassKeychainItems copy](v28, "copy");
  id v30 = (void *)*((void *)v8 + 9);
  *((void *)v8 + 9) = v29;

  if (self)
  {
    unsigned int v31 = self->_classCKeychainItems;
    uint64_t v32 = -[NRDLDDataClassKeychainItems copy](v31, "copy");
    id v33 = (void *)*((void *)v8 + 10);
    *((void *)v8 + 10) = v32;

    classAKeychainItemsLegacyOnly = self->_classAKeychainItemsLegacyOnly;
  }

  else
  {
    int v67 = [0 copy];
    id v68 = (void *)*((void *)v8 + 10);
    *((void *)v8 + 10) = v67;

    classAKeychainItemsLegacyOnly = 0LL;
  }

  id v35 = classAKeychainItemsLegacyOnly;
  uint64_t v36 = -[NRDLDDataClassKeychainItems copy](v35, "copy");
  int v37 = (void *)*((void *)v8 + 11);
  *((void *)v8 + 11) = v36;

  if (self)
  {
    id v38 = self->_outOfBandKeychainItem;
    int v39 = -[NRDLDKeychainItemData copy](v38, "copy");
    id v40 = (void *)*((void *)v8 + 19);
    *((void *)v8 + 19) = v39;

    [v8 setHasConfirmedClassDKeys:self->_hasConfirmedClassDKeys];
    [v8 setHasConfirmedClassCKeys:self->_hasConfirmedClassCKeys];
    hasConfirmedClassAKeys = self->_hasConfirmedClassAKeys;
  }

  else
  {
    id v69 = [0 copy];
    uint64_t v70 = (void *)*((void *)v8 + 19);
    *((void *)v8 + 19) = v69;

    [v8 setHasConfirmedClassDKeys:0];
    [v8 setHasConfirmedClassCKeys:0];
    hasConfirmedClassAKeys = 0LL;
  }

  [v8 setHasConfirmedClassAKeys:hasConfirmedClassAKeys];
  objc_msgSend( v8,  "setHasSavedClassCKeysInKeychain:",  -[NRDLocalDevice hasSavedClassCKeysInKeychain](self, "hasSavedClassCKeysInKeychain"));
  if (self)
  {
    [v8 setDeviceType:self->_deviceType];
    operationalProp = self->_operationalProp;
  }

  else
  {
    [v8 setDeviceType:0];
    operationalProp = 0LL;
  }

  id v43 = -[NRDeviceOperationalProperties copy](operationalProp, "copy");
  [v8 setOperationalProp:v43];

  if (self)
  {
    [v8 setLocalFlags:self->_localFlags];
    [v8 setRemoteFlags:self->_remoteFlags];
    bluetoothMACAddress = self->_bluetoothMACAddress;
  }

  else
  {
    [v8 setLocalFlags:0];
    [v8 setRemoteFlags:0];
    bluetoothMACAddress = 0LL;
  }

  int v45 = -[NSData copy](bluetoothMACAddress, "copy");
  [v8 setBluetoothMACAddress:v45];

  id v46 = (void *)objc_claimAutoreleasedReturnValue(-[NRDLocalDevice localInnerIPv6AddressBytesClassD](self, "localInnerIPv6AddressBytesClassD"));
  int v47 = [v46 copy];
  [v8 setLocalInnerIPv6AddressBytesClassD:v47];

  id v48 = (void *)objc_claimAutoreleasedReturnValue(-[NRDLocalDevice remoteInnerIPv6AddressBytesClassD](self, "remoteInnerIPv6AddressBytesClassD"));
  int v49 = [v48 copy];
  [v8 setRemoteInnerIPv6AddressBytesClassD:v49];

  uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue(-[NRDLocalDevice localInnerIPv6AddressBytesClassC](self, "localInnerIPv6AddressBytesClassC"));
  int v51 = [v50 copy];
  [v8 setLocalInnerIPv6AddressBytesClassC:v51];

  id v52 = (void *)objc_claimAutoreleasedReturnValue(-[NRDLocalDevice remoteInnerIPv6AddressBytesClassC](self, "remoteInnerIPv6AddressBytesClassC"));
  int v53 = [v52 copy];
  [v8 setRemoteInnerIPv6AddressBytesClassC:v53];

  if (self)
  {
    id v54 = -[NSData copy](self->_receivedProxyNotifyPayload, "copy");
    [v8 setReceivedProxyNotifyPayload:v54];

    int v55 = self->_isChanged;
  }

  else
  {
    v71 = [0 copy];
    [v8 setReceivedProxyNotifyPayload:v71];

    int v55 = 0;
  }

  v8[21] = v55;
  sub_100124478(v8);
LABEL_29:
  objc_autoreleasePoolPop(v5);
  return v8;
}

  return v27;
}

    id v15 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", "ForcedWoW");
    if (-[NSMutableString length](v11, "length")) {
      -[NSMutableString appendString:](v11, "appendString:", @", ");
    }
    -[NSMutableString appendString:](v11, "appendString:", v15);

    if ((v7 & 0x20) == 0)
    {
LABEL_22:
      if ((v7 & 0x40) == 0) {
        goto LABEL_23;
      }
      goto LABEL_40;
    }

void sub_100009B34(uint64_t a1, void *a2)
{
  id v24 = a2;
  if (qword_1001DC630 != -1) {
    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    _NRLogWithArgs( qword_1001DC628,  0LL,  "%s%.30s:%-4d %@: Plumbed classC keys with OOBK %@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_11",  1123LL,  *(void *)(a1 + 32),  v24);
  }

  if (v24) {
    uint64_t v3 = (void *)v24[10];
  }
  else {
    uint64_t v3 = 0LL;
  }
  id v4 = v3;
  if (qword_1001DC630 != -1) {
    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    uint64_t v5 = *(void *)(a1 + 32);
    id v6 = (id)qword_1001DC628;
    if (v4) {
      id v7 = (void *)*((void *)v4 + 1);
    }
    else {
      id v7 = 0LL;
    }
    id v8 = v7;
    uint64_t v9 = sub_100124E58(v8);
    Logid String = (void *)_NRKeyCreateLogString(v9);
    _NRLogWithArgs( v6,  0LL,  "%s%.30s:%-4d %@: classCRemotePublicKey=%@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_11",  1126LL,  v5,  LogString);
  }

  if (qword_1001DC630 != -1) {
    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    uint64_t v11 = *(void *)(a1 + 32);
    id v12 = (id)qword_1001DC628;
    if (v4) {
      uint64_t v13 = (void *)*((void *)v4 + 2);
    }
    else {
      uint64_t v13 = 0LL;
    }
    id v14 = v13;
    id v15 = sub_100124E58(v14);
    id v16 = (void *)_NRKeyCreateLogString(v15);
    _NRLogWithArgs( v12,  0LL,  "%s%.30s:%-4d %@: classCLocalPublicKey=%@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_11",  1128LL,  v11,  v16);
  }

  if (qword_1001DC630 != -1) {
    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    uint64_t v17 = *(void *)(a1 + 32);
    id v18 = (id)qword_1001DC628;
    if (v4)
    {
      id v19 = *((id *)v4 + 3);
      id v20 = v19;
      if (v19)
      {
        id v21 = (void *)*((void *)v19 + 2);
LABEL_33:
        id v22 = v21;
        id v23 = (void *)_NRKeyCreateLogString(v22);
        _NRLogWithArgs( v18,  0LL,  "%s%.30s:%-4d %@: classCSharedSecret=%@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_11",  1130LL,  v17,  v23);

        goto LABEL_34;
      }
    }

    else
    {
      id v20 = 0LL;
    }

    id v21 = 0LL;
    goto LABEL_33;
  }

void sub_100009EDC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v25 = v3;
  if (v3) {
    id v4 = (void *)*((void *)v3 + 11);
  }
  else {
    id v4 = 0LL;
  }
  id v5 = v4;
  if (qword_1001DC630 != -1) {
    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    _NRLogWithArgs( qword_1001DC628,  0LL,  "%s%.30s:%-4d %@: Plumbed classA keys with OOBK %@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_12",  1139LL,  *(void *)(a1 + 32),  v25);
  }

  if (qword_1001DC630 != -1) {
    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    uint64_t v6 = *(void *)(a1 + 32);
    id v7 = (id)qword_1001DC628;
    if (v5) {
      id v8 = (void *)*((void *)v5 + 1);
    }
    else {
      id v8 = 0LL;
    }
    uint64_t v9 = v8;
    uint64_t v10 = sub_100124E58(v9);
    Logid String = (void *)_NRKeyCreateLogString(v10);
    _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d %@: classARemotePublicKey=%@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_12",  1141LL,  v6,  LogString);
  }

  if (qword_1001DC630 != -1) {
    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    uint64_t v12 = *(void *)(a1 + 32);
    id v13 = (id)qword_1001DC628;
    if (v5) {
      id v14 = (void *)*((void *)v5 + 2);
    }
    else {
      id v14 = 0LL;
    }
    id v15 = v14;
    id v16 = sub_100124E58(v15);
    uint64_t v17 = (void *)_NRKeyCreateLogString(v16);
    _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d %@: classALocalPublicKey=%@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_12",  1143LL,  v12,  v17);
  }

  if (qword_1001DC630 != -1) {
    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    uint64_t v18 = *(void *)(a1 + 32);
    id v19 = (id)qword_1001DC628;
    if (v5)
    {
      id v20 = *((id *)v5 + 3);
      id v21 = v20;
      if (v20)
      {
        id v22 = (void *)*((void *)v20 + 2);
LABEL_33:
        id v23 = v22;
        id v24 = (void *)_NRKeyCreateLogString(v23);
        _NRLogWithArgs( v19,  0LL,  "%s%.30s:%-4d %@: classASharedSecret=%@",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_12",  1145LL,  v18,  v24);

        goto LABEL_34;
      }
    }

    else
    {
      id v21 = 0LL;
    }

    id v22 = 0LL;
    goto LABEL_33;
  }

void sub_10000A280(uint64_t a1)
{
}

void sub_10000A28C(uint64_t a1)
{
}

void sub_10000A298(uint64_t a1)
{
}

void sub_10000A2A4(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && (WeakRetained[8] & 0xFE) != 6)
  {
    uint64_t v4 = (uint64_t)WeakRetained;
    if (a2)
    {
      WeakRetained[14] = 1;
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
      {
        if (qword_1001DC630 != -1) {
          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
        }
        _NRLogWithArgs( qword_1001DC628,  0LL,  "%s%.30s:%-4d %@: initiatorLocalPublicKeys were received",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_2",  1013LL,  v4);
      }

      sub_100005BE0(v4, 4);
      sub_100005BE0(v4, 3);
      sub_100005BE0(v4, 1);
    }

    else
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC628, 16LL))
      {
        if (qword_1001DC630 != -1) {
          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
        }
        _NRLogWithArgs( qword_1001DC628,  16LL,  "%s%.30s:%-4d %@: initiatorLocalPublicKeys were not received",  "",  "-[NRPairingClient setupIKECallbacksPairing]_block_invoke_2",  1019LL,  v4);
      }

      sub_100005794(v4, 7, 7);
    }

    id WeakRetained = (_BYTE *)v4;
  }
}

void sub_10000A458(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  if (qword_1001DC630 != -1) {
    dispatch_once(&qword_1001DC630, &stru_1001ADE00);
  }
  uint64_t v77 = a1;
  if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
  {
    v75 = a4;
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    uint64_t v11 = *(void *)(a1 + 32);
    id v12 = (id)qword_1001DC628;
    Logid String = (void *)_NRKeyCreateLogString(v8);
    uint64_t v14 = _NRKeyCreateLogString(v9);
    id v15 = v9;
    id v16 = v8;
    uint64_t v17 = (void *)v14;
    uint64_t v18 = (void *)_NRKeyCreateLogString(v10);
    _NRLogWithArgs( v12,  0LL,  "%s%.30s:%-4d %@: Queryied for pairing keys for OOBK pairing D %@ C %@ A %@",  "",  "-[NRPairingClient setupInitiator]_block_invoke",  385LL,  v11,  LogString,  v17,  v18);

    id v8 = v16;
    id v9 = v15;

    a4 = v75;
    a1 = v77;
  }

  uint64_t v19 = *(void *)(a1 + 32);
  if ((*(_BYTE *)(v19 + 8) & 0xFE) != 6)
  {
    objc_storeStrong((id *)(v19 + 120), a2);
    uint64_t v20 = *(void *)(a1 + 32);
    if (v20)
    {
      objc_storeStrong((id *)(v20 + 128), a3);
      uint64_t v21 = *(void *)(a1 + 32);
      if (v21) {
        objc_storeStrong((id *)(v21 + 136), a4);
      }
    }

    id v22 = [[NEIKEv2AuthenticationProtocol alloc] initWithMethod:2];
    id v74 = v10;
    if (qword_1001DCAA8 != -1) {
      dispatch_once(&qword_1001DCAA8, &stru_1001AFDB0);
    }
    id v23 = (id)qword_1001DCAA0;
    id v24 = sub_10010C5AC(1, v23, v22);

    uint64_t v25 = *(void *)(*(void *)(a1 + 32) + 112LL);
    if (v25)
    {
      id v26 = *(void **)(v25 + 152);
      if (v26) {
        id v26 = (void *)v26[2];
      }
      uint64_t v27 = v26;
    }

    else
    {
      uint64_t v27 = 0LL;
    }

    -[NEIKEv2SessionConfiguration setSharedSecret:](v24, "setSharedSecret:", v27);

    id v28 = (void *)objc_claimAutoreleasedReturnValue(-[NEIKEv2SessionConfiguration sharedSecret](v24, "sharedSecret"));
    if (v28)
    {
      uint64_t v29 = *(void *)(a1 + 32);
      if (v29
        && (id v30 = (unsigned __int8 *)*(id *)(v29 + 40)) != 0LL
        && (int v31 = v30[9], v30, v31))
      {
        id v32 = v8;
        id v76 = *(id *)(a1 + 32);
      }

      else
      {
        id v32 = v8;
        id v76 = 0LL;
      }

      id v33 = sub_10010C0B8();
      sub_10010BDB0(*(void **)(*(void *)(a1 + 32) + 112LL), v33);
      [v33 setRequestChildlessSA:1];
      v82[0] = 0LL;
      v82[1] = v82;
      int v83 = 0;
      v82[2] = 0x2020000000LL;
      uint64_t v34 = *(void *)(a1 + 32);
      if (v34
        && (id v35 = (unsigned __int8 *)*(id *)(v34 + 40)) != 0LL
        && (int v36 = v35[11], v35, v36))
      {
        int v37 = sub_10010C340();
        -[NEIKEv2ChildSAConfiguration setSequencePerTrafficClass:](v37, "setSequencePerTrafficClass:", 1LL);
        -[NEIKEv2ChildSAConfiguration setReplayWindowSize:](v37, "setReplayWindowSize:", 16LL);
        id v38 = 0LL;
      }

      else
      {
        int v39 = *(void **)(*(void *)(a1 + 32) + 40LL);
        if (v39) {
          int v39 = (void *)v39[2];
        }
        id v40 = v39;
        [v33 setOutgoingInterfaceName:v40];

        id v41 = *(void **)(*(void *)(v77 + 32) + 40LL);
        if (v41) {
          id v41 = (void *)v41[3];
        }
        int v42 = v41;
        [v33 setRemoteEndpoint:v42];

        [v33 setRandomizeLocalPort:1];
        int v37 = sub_10010C340();
        -[NEIKEv2ChildSAConfiguration setMode:](v37, "setMode:", 2LL);
        -[NEIKEv2ChildSAConfiguration setReplayWindowSize:](v37, "setReplayWindowSize:", 4LL);
        v81[0] = _NSConcreteStackBlock;
        v81[1] = 3221225472LL;
        v81[2] = sub_10000ACE0;
        v81[3] = &unk_1001AE618;
        v81[4] = v82;
        id v38 = objc_retainBlock(v81);
      }

      uint64_t v43 = *(void *)(v77 + 32);
      id v44 = v33;
      if (v43)
      {
        if (qword_1001DC9B8 != -1) {
          dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
        }
        if (byte_1001DC9B0)
        {
          [v44 setForceUDPEncapsulation:1];
          [v44 setRandomizeLocalPort:1];
        }
      }

      int v45 = objc_alloc(&OBJC_CLASS___NEIKEv2Session);
      uint64_t v46 = *(void *)(v77 + 32);
      uint64_t v47 = *(void *)(v46 + 32);
      uint64_t v48 = *(void *)(v46 + 40);
      if (v48) {
        uint64_t v49 = *(void *)(v48 + 40);
      }
      else {
        uint64_t v49 = 0LL;
      }
      uint64_t v50 = -[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName:packetDelegate:]( v45,  "initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName :packetDelegate:",  v44,  v37,  v24,  v47,  v49,  v38,  @"terminusIKEForPairingWithOOBKey",  v76);
      uint64_t v51 = *(void *)(v77 + 32);
      id v52 = *(void **)(v51 + 80);
      *(void *)(v51 + 80) = v50;

      uint64_t v53 = *(void *)(v77 + 32);
      if (*(void *)(v53 + 80))
      {
        *(_BYTE *)(v53 + 16) = 0;
        if (qword_1001DC630 != -1) {
          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
        }
        id v54 = (id)qword_1001DC628;
        int IsLevelEnabled = _NRLogIsLevelEnabled(v54, 0LL);

        if (IsLevelEnabled)
        {
          if (qword_1001DC630 != -1) {
            dispatch_once(&qword_1001DC630, &stru_1001ADE00);
          }
          id v56 = (id)qword_1001DC628;
          _NRLogWithArgs( v56,  0LL,  "%s%.30s:%-4d %@: Created initiator OOBK pairing IKE session",  "",  "-[NRPairingClient setupInitiator]_block_invoke",  468LL,  *(void *)(v77 + 32));
        }

        sub_100003D60(*(void *)(v77 + 32));
        if (qword_1001DC630 != -1) {
          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
        }
        id v57 = (id)qword_1001DC628;
        int v58 = _NRLogIsLevelEnabled(v57, 0LL);

        if (v58)
        {
          if (qword_1001DC630 != -1) {
            dispatch_once(&qword_1001DC630, &stru_1001ADE00);
          }
          id v59 = (id)qword_1001DC628;
          _NRLogWithArgs( v59,  0LL,  "%s%.30s:%-4d %@: Connecting initiator OOBK pairing session",  "",  "-[NRPairingClient setupInitiator]_block_invoke",  470LL,  *(void *)(v77 + 32));
        }

        [*(id *)(*(void *)(v77 + 32) + 80) connect];
        uint64_t v60 = *(void *)(v77 + 32);
        if (v60) {
          *(_BYTE *)(v60 + 14) = 0;
        }
      }

      else
      {
        ++*(_BYTE *)(v53 + 16);
        uint64_t v64 = *(void *)(v77 + 32);
        if (v64 && *(unsigned __int8 *)(v64 + 16) >= 3u)
        {
          id v65 = sub_100003B10();
          int v66 = _NRLogIsLevelEnabled(v65, 17LL);

          if (v66)
          {
            id v67 = sub_100003B10();
            _NRLogWithArgs(v67, 17LL, "%@: Failed to create initiator OOBK pairing IKE session", *(void *)(v77 + 32));
          }

          sub_100005794(*(void *)(v77 + 32), 7, 4);
        }

        else
        {
          id v68 = sub_100003B10();
          int v69 = _NRLogIsLevelEnabled(v68, 16LL);

          if (v69)
          {
            id v70 = sub_100003B10();
            _NRLogWithArgs( v70,  16LL,  "%s%.30s:%-4d %@: Failed to create initiator OOBK pairing IKE session",  "",  "-[NRPairingClient setupInitiator]_block_invoke",  446LL,  *(void *)(v77 + 32));
          }

          objc_initWeak(&location, *(id *)(v77 + 32));
          dispatch_time_t v71 = dispatch_time(0x8000000000000000LL, 3000000000LL);
          int v72 = *(void **)(v77 + 32);
          if (v72) {
            int v72 = (void *)v72[4];
          }
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472LL;
          block[2] = sub_10000AD30;
          block[3] = &unk_1001AFED0;
          uint64_t v73 = v72;
          objc_copyWeak(&v79, &location);
          dispatch_after(v71, v73, block);

          objc_destroyWeak(&v79);
          objc_destroyWeak(&location);
        }
      }

      _Block_object_dispose(v82, 8);

      id v8 = v32;
    }

    else
    {
      id v61 = sub_100003B10();
      int v62 = _NRLogIsLevelEnabled(v61, 17LL);

      if (v62)
      {
        id v63 = sub_100003B10();
        _NRLogWithArgs(v63, 17LL, "%@: Missing out of band key", *(void *)(a1 + 32));
      }

      sub_100005794(*(void *)(a1 + 32), 7, 8);
    }

    id v10 = v74;
  }
}

void sub_10000ACC8(_Unwind_Exception *a1)
{
}

uint64_t sub_10000ACE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = getpid();
  return NEHelperGetIKESocketWithResult(a3, a4, a5, v9, *(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

void sub_10000AD30(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = WeakRetained;
  if (WeakRetained
    && (*((_BYTE *)WeakRetained + 8) & 0xFE) != 6
    && (*((_BYTE *)WeakRetained + 48) & 0x10) == 0
    && !*((void *)WeakRetained + 10))
  {
    sub_100003C00((uint64_t)WeakRetained, (id *)WeakRetained + 10);
    id v3 = (void *)v2[3];
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472LL;
    v4[2] = sub_10000A458;
    v4[3] = &unk_1001ADDB8;
    v4[4] = v2;
    sub_1001320DC((uint64_t)&OBJC_CLASS___NRDLocalDevice, v3, 4, v4);
  }
}

void sub_10000ADD8(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC628;
  qword_1001DC628 = (uint64_t)v1;
}

id *sub_10000AE08(id *a1, void *a2, void *a3, __objc2_meth_list **p_class_meths)
{
  id v8 = a2;
  uint64_t v9 = a3;
  id v10 = p_class_meths;
  uint64_t v11 = v10;
  if (!a1) {
    goto LABEL_22;
  }
  if (!v8)
  {
    id v18 = sub_100003B10();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 17LL);

    if (!IsLevelEnabled) {
      goto LABEL_22;
    }
    id v20 = sub_100003B10();
    _NRLogWithArgs(v20, 17LL, "%s called with null queue");
LABEL_21:

    id v16 = 0LL;
    goto LABEL_14;
  }

  if (!v9)
  {
    id v21 = sub_100003B10();
    int v22 = _NRLogIsLevelEnabled(v21, 17LL);

    if (!v22) {
      goto LABEL_22;
    }
    id v20 = sub_100003B10();
    _NRLogWithArgs(v20, 17LL, "%s called with null nrUUID");
    goto LABEL_21;
  }

  if (!v10)
  {
    id v23 = sub_100003B10();
    int v24 = _NRLogIsLevelEnabled(v23, 17LL);

    if (v24)
    {
      id v20 = sub_100003B10();
      _NRLogWithArgs(v20, 17LL, "%s called with null parameters");
      goto LABEL_21;
    }

LABEL_22:
    id v16 = 0LL;
    goto LABEL_14;
  }

  v32.receiver = a1;
  v32.super_class = (Class)&OBJC_CLASS___NRPairingClient;
  id v12 = (id *)objc_msgSendSuper2(&v32, "init");
  if (v12)
  {
    a1 = v12;
    do
      unint64_t v13 = __ldxr(&qword_1001DBA50);
    while (__stxr(v13 + 1, &qword_1001DBA50));
    v12[7] = (id)v13;
    objc_storeStrong(v12 + 4, a2);
    objc_storeStrong(a1 + 3, a3);
    objc_storeStrong(a1 + 5, p_class_meths);
    uint64_t v14 = objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
    id v15 = a1[8];
    a1[8] = (id)v14;

    p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    if (qword_1001DC630 == -1) {
      goto LABEL_9;
    }
  }

  else
  {
    id v25 = sub_100003B10();
    int v26 = _NRLogIsLevelEnabled(v25, 16LL);

    if (v26)
    {
      id v27 = sub_100003B10();
      _NRLogWithArgs( v27,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRPairingClient initWithQueue:nrUUID:parameters:]",  123);
    }

    id v8 = (id)_os_log_pack_size(12LL);
    uint64_t v9 = (char *)&v31 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v28 = __error();
    uint64_t v29 = _os_log_pack_fill(v9, v8, *v28, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)uint64_t v29 = 136446210;
    *(void *)(v29 + 4) = "-[NRPairingClient initWithQueue:nrUUID:parameters:]";
    id v30 = sub_100003B10();
    _NRLogAbortWithPack(v30, v9);
  }

  dispatch_once(&qword_1001DC630, &stru_1001ADE00);
LABEL_9:
  if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
  {
    if (p_class_meths[198] != (__objc2_meth_list *)-1LL) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    _NRLogWithArgs( qword_1001DC628,  0LL,  "%s%.30s:%-4d %@: Created",  "",  "-[NRPairingClient initWithQueue:nrUUID:parameters:]",  131LL,  a1);
  }

  a1 = a1;
  id v16 = a1;
LABEL_14:

  return v16;
}

  return v36;
}

      uint64_t v34 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      isa_high = HIWORD(v6[1].super.super.isa);
      if (LODWORD(v6[2].super.super.isa) == WORD2(v6[1].super.super.isa) + (_DWORD)isa_high)
      {
        int v36 = BYTE2(v6[1].super.super.isa);
        __int128 v124 = a2;
        if (v36 == 1)
        {
          int v37 = 8LL;
          if (!(_DWORD)isa_high) {
            goto LABEL_44;
          }
        }

        else
        {
          if (v36 != 2)
          {
            v114 = sub_100020F30();
            v115 = _NRLogIsLevelEnabled(v114, 16LL);

            id v65 = "-[NRLinkDirectorMessage copyAllDataForType:]";
            if (v115)
            {
              v116 = sub_100020F30();
              _NRLogWithArgs( v116,  16LL,  "%s%.30s:%-4d ABORTING: Unsupported message version: %u",  "",  "-[NRLinkDirectorMessage copyAllDataForType:]",  903,  BYTE2(v6[1].super.super.isa));
            }

            uint64_t v64 = _os_log_pack_size(18LL);
            v117 = (char *)&v122 - ((__chkstk_darwin(v64) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            v118 = __error();
            v119 = _os_log_pack_fill( v117,  v64,  *v118,  &_mh_execute_header,  "%{public}s Unsupported message version: %u");
            v120 = BYTE2(v6[1].super.super.isa);
            *(_DWORD *)v119 = 136446466;
            *(void *)(v119 + 4) = "-[NRLinkDirectorMessage copyAllDataForType:]";
            *(_WORD *)(v119 + 12) = 1024;
            *(_DWORD *)(v119 + 14) = v120;
            __int128 v121 = sub_100020F30();
            _NRLogAbortWithPack(v121, v117);
            goto LABEL_88;
          }

          int v37 = 16LL;
          if (!(_DWORD)isa_high)
          {
LABEL_44:
            if (!-[NSMutableArray count](v34, "count"))
            {
LABEL_82:
              uint64_t v6 = v34;
              id v28 = v6;
              goto LABEL_83;
            }

            objc_opt_self(&OBJC_CLASS___NRLinkDirectorMessageManager);
            if (qword_1001DC708 != -1) {
              dispatch_once(&qword_1001DC708, &stru_1001AE488);
            }
            uint64_t v64 = qword_1001DC700;
            id v65 = v6;
            if (!v64)
            {
LABEL_81:

              goto LABEL_82;
            }

            dispatch_assert_queue_V2(*(dispatch_queue_t *)(v64 + 8));
            int v66 = v6[4].super.super.isa;
            id v67 = *(id *)(v64 + 16);
            isa_high = objc_claimAutoreleasedReturnValue([v67 objectForKeyedSubscript:v66]);

            if (!isa_high)
            {
              id v92 = (void *)_NRCopyLogObjectForNRUUID(v6[4].super.super.isa, v68);
              uint64_t v93 = _NRLogIsLevelEnabled(v92, 17LL);

              if (!v93)
              {
LABEL_80:

                goto LABEL_81;
              }

              unint64_t v13 = (id *)_NRCopyLogObjectForNRUUID(v6[4].super.super.isa, v94);
              _NRLogWithArgs(v13, 17LL, "no registered uuid for incoming message");
LABEL_79:

              goto LABEL_80;
            }

            unint64_t v13 = (id *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v124));
            int v69 = +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  sub_100020CF0((uint64_t)v65));
            id v70 = (void *)objc_claimAutoreleasedReturnValue(v69);
            uint64_t v2 = (NRLinkDirectorMessageState *)objc_claimAutoreleasedReturnValue([(id)isa_high objectForKeyedSubscript:v13]);
            __int128 v122 = v34;
            if (v2)
            {
              dispatch_time_t v71 = objc_opt_class(&OBJC_CLASS___NRLinkDirectorMessageState);
              if ((objc_opt_isKindOfClass(v2, v71) & 1) == 0)
              {
                uint64_t v110 = (void *)_NRCopyLogObjectForNRUUID(v6[4].super.super.isa, v72);
                uint64_t v111 = _NRLogIsLevelEnabled(v110, 17LL);

                if (!v111)
                {
                  uint64_t v106 = v70;
LABEL_78:

                  uint64_t v34 = v122;
                  goto LABEL_79;
                }

                id v96 = (NSNumber *)_NRCopyLogObjectForNRUUID(v6[4].super.super.isa, v112);
                _NRLogWithArgs(v96, 17LL, "refusing to update message type %u, for invalid object %@", v124, v2);
                uint64_t v106 = v70;
LABEL_77:

                goto LABEL_78;
              }

              __int128 v123 = v70;
              goto LABEL_64;
            }

            __int128 v123 = v70;
            uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NRLinkDirectorMessageState);
            if (v2)
            {
LABEL_64:
              int v95 = v2->_sequenceNum;
              id v96 = v95;
              if (v95)
              {
                int v97 = -[NSNumber unsignedLongLongValue](v95, "unsignedLongLongValue");
                if (v97 > sub_100020CF0((uint64_t)v65))
                {
                  int v99 = (void *)_NRCopyLogObjectForNRUUID(v6[4].super.super.isa, v98);
                  id v100 = _NRLogIsLevelEnabled(v99, 17LL);

                  if (!v100)
                  {
                    uint64_t v106 = v123;
                    goto LABEL_77;
                  }

                  int v101 = v6[4].super.super.isa;
                  int v103 = (id)_NRCopyLogObjectForNRUUID(v101, v102);
                  id v104 = -[NSNumber unsignedLongLongValue](v96, "unsignedLongLongValue");

                  int v105 = sub_100020CF0((uint64_t)v65);
                  _NRLogWithArgs( v103,  17LL,  "refusing to update message type %u, as it is stale (%llu > %llu)",  v124,  v104,  v105);
                  uint64_t v106 = v123;
                  goto LABEL_72;
                }
              }

              uint64_t v106 = v123;
              objc_storeStrong((id *)&v2->_sequenceNum, v123);
              uint64_t v107 = 0;
LABEL_69:
              uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  *((void *)v65 + 7),  v122));
              if ((v107 & 1) == 0) {
                objc_storeStrong((id *)&v2->_localReceiveID, v108);
              }

              [(id)isa_high setObject:v2 forKeyedSubscript:v13];
              uint64_t v109 = v6[4].super.super.isa;
              int v103 = *(id *)(v64 + 16);
              [v103 setObject:isa_high forKeyedSubscript:v109];
LABEL_72:

              goto LABEL_77;
            }

  id v20 = &v5[*v17];
  id v7 = *(void *)&v5[*v19];
  id v21 = &v5[*v16];
  v336 = &v5[*v18];
  v337 = v21;
  v335 = v20;
  v333 = *(void *)v20;
  v332 = *(void *)v336;
LABEL_23:
  v339 = 0;
  v334 = (char *)&v368 + 8;
  int v22 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
  v354 = v7;
  while (2)
  {
    id v23 = 0LL;
    v347 = 0LL;
    ESPSequenceNumberFromPacket = 0LL;
    int v24 = 0LL;
    v355 = 0LL;
    v356 = 0LL;
    id v25 = 0LL;
    v352 = 0LL;
    int v26 = 0LL;
    v384 = 0LL;
    v385 = 0LL;
    id v27 = *(void *)(v5 + 951);
    v357 = 0LL;
    v358 = v27;
LABEL_27:
    id v28 = v354;
    while (1)
    {
      uint64_t v29 = v23;
      v360 = 1919LL;
      *(void *)(v5 + 1919) = 2LL;
      v370 = 0u;
      v371 = 0u;
      v368 = 0u;
      v369 = 0u;
      if (v28)
      {
        id v30 = v24;
        next_slot = os_channel_get_next_slot(v28, v352, &v368);
        if (next_slot && v349 == v350)
        {
          LODWORD(v24) = v30;
          if (v5[225])
          {
            objc_super v32 = (void *)next_slot;
            v351 = v25;
            id v33 = v26;
            uint64_t v34 = 0LL;
            if ((void)v369)
            {
              uint64_t v4 = WORD1(v368);
              id v35 = 0;
              if (WORD1(v368))
              {
                if (isPacketValidIPv6())
                {
                  DSCPFromPacket = getDSCPFromPacket(v369, WORD1(v368));
                  int v37 = DSCPFromPacket == 46;
                  id v38 = WORD1(v368) < 0x2A4u;
                  id v35 = v37 && v38;
                  if (v37 && v38) {
                    uint64_t v34 = 46LL;
                  }
                  else {
                    uint64_t v34 = DSCPFromPacket;
                  }
                }

                else
                {
                  uint64_t v34 = 0LL;
                  id v35 = 0;
                }

                LODWORD(v24) = v30;
              }
            }

            else
            {
              id v35 = 0;
            }

            if (gNRPacketLoggingEnabled)
            {
              ESPSequenceNumberFromPacket = getESPSequenceNumberFromPacket(v369, WORD1(v368));
              if (gNRPacketLoggingEnabled) {
                getESPSPIFromPacket(v369, WORD1(v368));
              }
              LODWORD(v24) = v30;
              if (v35)
              {
LABEL_74:
                id v63 = os_channel_get_next_slot(*(void *)(v5 + 1055), v347, v364);
                if (!v63)
                {
                  int v26 = v33;
                  id v25 = v351;
                  uint64_t v6 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                  if (v5[224] && *(void *)(v5 + 1071))
                  {
                    v5[224] = 0;
                    ++*(void *)(v5 + 1087);
                    if (gNRPacketLoggingEnabled)
                    {
                      v155 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v64);
                      v156 = _NRLogIsLevelEnabled(v155, 1LL);

                      int v22 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                      if (v156)
                      {
                        v158 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v157);
                        v159 = [v5 copyDescription];
                        _NRLogWithArgs( v158,  1LL,  "%s%.30s:%-4d %@: source-resume: DatagramLinkOutput",  "",  "NRLinkResumeDatagramLinkOutputSource",  825LL,  v159);

                        int v22 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                      }
                    }

                    dispatch_resume(*(dispatch_object_t *)(v5 + 1071));
                  }

                  ((void (*)(char *))v343)(v5);
                  *(void *)&v5[v360] |= 4uLL;
                  LODWORD(v75) = 31;
                  id v76 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                  int v24 = v30;
                  id v23 = v29;
                  goto LABEL_154;
                }

                id v65 = v63;
                int v26 = v33;
                if (!v5[224] && *(void *)(v5 + 1071))
                {
                  int v66 = v63;
                  v5[224] = 1;
                  ++*(void *)(v5 + 1087);
                  if (gNRPacketLoggingEnabled)
                  {
                    v150 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v64);
                    v151 = _NRLogIsLevelEnabled(v150, 1LL);

                    if (v151)
                    {
                      v153 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v152);
                      v154 = [v5 copyDescription];
                      _NRLogWithArgs( v153,  1LL,  "%s%.30s:%-4d %@: source-suspend: DatagramLinkOutput",  "",  "NRLinkSuspendDatagramLinkOutputSource",  817LL,  v154);
                    }
                  }

                  dispatch_suspend(*(dispatch_object_t *)(v5 + 1071));
                  id v65 = v66;
                }

                id v67 = *(void *)(v5 + 1055);
                v359 = v65;
                packet = os_channel_slot_get_packet(v67, v65);
                next_buflet = os_packet_get_next_buflet(packet, 0LL);
                object_address = os_buflet_get_object_address();
                data_limit = os_buflet_get_data_limit(next_buflet);
                if (data_limit >= 0x10000)
                {
                  v272 = sub_100070554();
                  v273 = _NRLogIsLevelEnabled(v272, 16LL);

                  if (v273)
                  {
                    v274 = sub_100070554();
                    _NRLogWithArgs( v274,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: datagramBufferLength <= 65535",  "",  "NRLinkNexusToLinkLoop",  3763);
                  }

                  v275 = _os_log_pack_size(12LL);
                  v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                  v276 = *__error();
                  for (i = _os_log_pack_fill( v235,  v275,  v276,  &_mh_execute_header,  "%{public}s Assertion Failed: datagramBufferLength <= 65535");
                        ;
                        i = _os_log_pack_fill( v235,  v257,  v258,  &_mh_execute_header,  "%{public}s Assertion Failed: curLinkOutputSlot == highestLinkOutputSlotWrittenTo"))
                  {
LABEL_305:
                    *(_DWORD *)i = 136446210;
                    *(void *)(i + 4) = "NRLinkNexusToLinkLoop";
LABEL_306:
                    v253 = sub_100070554();
                    _NRLogAbortWithPack(v253, v235);
LABEL_307:
                    v254 = sub_100070554();
                    v255 = _NRLogIsLevelEnabled(v254, 16LL);

                    if (v255)
                    {
                      v256 = sub_100070554();
                      _NRLogWithArgs( v256,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: curLinkOutputSlot == highestLinkOutputSlotWrittenTo",  "",  "NRLinkNexusToLinkLoop",  4080);
                    }

                    v257 = _os_log_pack_size(12LL);
                    v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                    v258 = *__error();
                  }
                }

                v361 = object_address;
                v363 = 0;
                v362 = data_limit;
                int v72 = nrPacketToTLV(v369, WORD1(v368), &v361, 1LL, v5 + 1951, v5 + 1967);
                *(void *)(v5 + 1399) += v72;
                *(void *)v335 += WORD1(v368);
                ++*(void *)v336;
                *(void *)&v5[v360] |= 0x10uLL;
                if (gNRPacketLoggingEnabled)
                {
                  v360 = v72;
                  v147 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v73);
                  LODWORD(v352) = _NRLogIsLevelEnabled(v147, 1LL);

                  LOWORD(v72) = v360;
                  if ((_DWORD)v352)
                  {
                    v352 = (id)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v148);
                    v149 = [v5 copyDescription];
                    _NRLogWithArgs( v352,  1LL,  "%s%.30s:%-4d %@: wrote payload of length: %u, dscp: %u, uncompressedLen = %u",  "",  "NRLinkNexusToLinkLoop",  3782LL,  v149,  v360,  v34,  WORD1(v368));

                    LOWORD(v72) = v360;
                  }
                }

                os_buflet_set_data_length(next_buflet, (unsigned __int16)v72);
                v385 = ++v358;
                os_packet_set_flow_uuid(packet, &v384);
                id v74 = os_packet_finalize(packet);
                if (!v74)
                {
                  LODWORD(v75) = 30;
                  v347 = v359;
                  v352 = v32;
                  int v22 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                  id v76 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                  id v25 = v351;
                  int v24 = v30;
                  uint64_t v6 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                  id v23 = v29;
                  goto LABEL_154;
                }

                v277 = v74;
                v328 = sub_100070554();
                v329 = _NRLogIsLevelEnabled(v328, 16LL);

                if (v329)
                {
                  v330 = sub_100070554();
                  _NRLogWithArgs( v330,  16LL,  "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d",  "",  "NRLinkNexusToLinkLoop",  3786,  v277);
                }

      id v27 = 0u;
      id v28 = 0u;
      id v25 = 0u;
      int v26 = 0u;
      conductors = self->_conductors;
      goto LABEL_23;
    }
  }

  else if (self)
  {
    id v10 = self->_bluetoothManager;
    if (v10)
    {
      uint64_t v11 = v10->super._queue;
      dispatch_assert_queue_V2(v11);

      if (v10->_pipeManager)
      {
        id v12 = v10->_pipeRegistrations;
        unint64_t v13 = (_BYTE *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v12,  "objectForKeyedSubscript:",  &off_1001BC580));
        if (v13) {
          v13[9] &= ~4u;
        }

        uint64_t v14 = v10->_p2pPipeRegistrations;
        id v15 = (_BYTE *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v14,  "objectForKeyedSubscript:",  &off_1001BC580));
        if (v15) {
          v15[9] &= ~4u;
        }

        sub_10002C5F0((uint64_t)v10, 3LL, 0);
        sub_10002C5F0((uint64_t)v10, 3LL, 1);
      }
    }

    goto LABEL_22;
  }

  conductors = 0LL;
  id v27 = 0u;
  id v28 = 0u;
  id v25 = 0u;
  int v26 = 0u;
LABEL_23:
  uint64_t v17 = conductors;
  id v18 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v17,  "countByEnumeratingWithState:objects:count:",  &v25,  v29,  16LL);
  if (v18)
  {
    uint64_t v19 = v18;
    id v20 = *(void *)v26;
    if (self)
    {
      do
      {
        id v21 = 0LL;
        do
        {
          if (*(void *)v26 != v20) {
            objc_enumerationMutation(v17);
          }
          int v22 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( self->_conductors,  "objectForKeyedSubscript:",  *(void *)(*((void *)&v25 + 1) + 8LL * (void)v21),  (void)v25));
          [v22 deviceHasPhoneCallRelayRequest:v3];

          id v21 = (char *)v21 + 1;
        }

        while (v19 != v21);
        uint64_t v19 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v17,  "countByEnumeratingWithState:objects:count:",  &v25,  v29,  16LL);
      }

      while (v19);
    }

    else
    {
      do
      {
        id v23 = 0LL;
        do
        {
          if (*(void *)v26 != v20) {
            objc_enumerationMutation(v17);
          }
          int v24 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( 0,  "objectForKeyedSubscript:",  *(void *)(*((void *)&v25 + 1) + 8 * (void)v23),  (void)v25));
          [v24 deviceHasPhoneCallRelayRequest:v3];

          id v23 = (char *)v23 + 1;
        }

        while (v19 != v23);
        uint64_t v19 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v17,  "countByEnumeratingWithState:objects:count:",  &v25,  v29,  16LL);
      }

      while (v19);
    }
  }
}

          id v12 = 0LL;
          goto LABEL_23;
        }

        uint64_t v17 = sub_1000F4464();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v17, 17LL);

        if (IsLevelEnabled)
        {
          id v16 = sub_1000F4464();
          _NRLogWithArgs( v16,  17LL,  "%s called with null asName",  "-[NRApplicationServiceManager copyListenerPublicKeyForASName:]");
          goto LABEL_22;
        }

        id v12 = 0LL;
      }

  id v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v9);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v15, 1LL);

  if (IsLevelEnabled)
  {
    id v18 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v17);
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v21 peerToken]);
    id v20 = (void *)objc_claimAutoreleasedReturnValue([v21 localToken]);
    _NRLogWithArgs( v18,  1LL,  "%s%.30s:%-4d updated peer token %@ local token %@",  "",  "-[NRDDeviceConductor updateLinkWithDiscoveredEndpoint:]",  7767LL,  v19,  v20);
  }

    id v18 = 0LL;
    goto LABEL_11;
  }

  v36.receiver = self;
  v36.super_class = (Class)&OBJC_CLASS___NRLink;
  id v12 = -[NRLink init](&v36, "init");
  if (v12)
  {
    self = v12;
    objc_storeStrong((id *)&v12->_queue, a3);
    objc_storeWeak((id *)&self->_linkDelegate, v10);
    objc_storeStrong((id *)&self->_nrUUID, a5);
    *(_WORD *)&self->_state = 1;
    self->_subtype = 0;
    self->_linkMTU = 1500;
    unint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(-[NRLink nrUUID](self, "nrUUID"));
    a5 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v13);

    if (a5)
    {
      uint64_t v14 = (void *)*((void *)a5 + 16);
      goto LABEL_8;
    }
  }

  else
  {
    uint64_t v29 = sub_100107F78();
    id v30 = _NRLogIsLevelEnabled(v29, 16LL);

    uint64_t v11 = "-[NRLink initLinkWithQueue:linkDelegate:nrUUID:]";
    if (v30)
    {
      uint64_t v31 = sub_100107F78();
      _NRLogWithArgs( v31,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRLink initLinkWithQueue:linkDelegate:nrUUID:]",  227);
    }

    uint64_t v9 = (dispatch_queue_s *)_os_log_pack_size(12LL);
    id v10 = (char *)&v35 - (((unint64_t)v9 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    objc_super v32 = __error();
    id v33 = _os_log_pack_fill(v10, v9, *v32, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)id v33 = 136446210;
    *(void *)(v33 + 4) = "-[NRLink initLinkWithQueue:linkDelegate:nrUUID:]";
    uint64_t v34 = sub_100107F78();
    _NRLogAbortWithPack(v34, v10);
  }

  uint64_t v14 = 0LL;
LABEL_8:
  id v15 = v14;
  self->_hasCompanionDatapath = [v15 hasCompanionDatapath];

  id v16 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  -[NRLink setPolicyIDs:](self, "setPolicyIDs:", v16);

  do
    uint64_t v17 = __ldxr(&qword_1001DC240);
  while (__stxr(v17 + 1, &qword_1001DC240));
  self->_identifier = v17;
  self = self;

  id v18 = self;
LABEL_11:

  return v18;
}

  uint64_t v11 = *(id *)(a1 + 80);
  if (v11 && (id v12 = *(void *)(a1 + 88), v11, !v12))
  {
    uint64_t v14 = *(id *)(a1 + 80);
    id v15 = [v14 copy];
    id v16 = *(void **)(a1 + 88);
    *(void *)(a1 + 8_Block_object_dispose((const void *)(v1 - 120), 8) = v15;

    uint64_t v17 = *(void *)(a1 + 88);
    if (v17)
    {
      id v18 = *(void **)(v17 + 8);
      *(void *)(v17 + _Block_object_dispose((const void *)(v1 - 120), 8) = 0LL;

      uint64_t v19 = *(void *)(a1 + 88);
      if (v19)
      {
        id v20 = *(void **)(v19 + 24);
        *(void *)(v19 + 24) = 0LL;
      }
    }

    id v21 = *(id *)(a1 + 32);
    int v22 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 description]);
    sub_10011BB18(v21, 5005, v22, @"ClassA");

    if (v3) {
      goto LABEL_25;
    }
  }

  else if (v3)
  {
LABEL_25:
    unint64_t v13 = objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
    sub_100128908(v13);
  }

void sub_10000B180(uint64_t a1)
{
  if (!a1 || (*(_BYTE *)(a1 + 8) & 0xFE) == 6) {
    return;
  }
  *(_BYTE *)(a1 + 10) = 1;
  uint64_t v2 = sub_100129C28((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 24), 0);
  id v3 = *(void **)(a1 + 112);
  *(void *)(a1 + 112) = v2;

  uint64_t v4 = *(void *)(a1 + 112);
  if (!v4)
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC628, 16LL))
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      _NRLogWithArgs( qword_1001DC628,  16LL,  "%s%.30s:%-4d %@: %@ no local device found",  "",  "-[NRPairingClient start]",  232LL,  a1,  *(void *)(a1 + 24));
    }

    sub_100005794(a1, 7, 3);
    return;
  }

  if (!*(_BYTE *)(v4 + 15))
  {
    if (*(_BYTE *)(v4 + 14)) {
      BOOL v6 = 1;
    }
    else {
      BOOL v6 = *(unsigned __int16 *)(v4 + 28) > 0x12u;
    }
    int v5 = v6;
    if (!*(_BYTE *)(v4 + 12)) {
      goto LABEL_33;
    }
LABEL_22:
    if (*(_BYTE *)(v4 + 13)) {
      int v7 = v5;
    }
    else {
      int v7 = 0;
    }
    if (v7 == 1)
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC628, 16LL))
      {
        if (qword_1001DC630 != -1) {
          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
        }
        _NRLogWithArgs( qword_1001DC628,  16LL,  "%s%.30s:%-4d %@: already paired",  "",  "-[NRPairingClient start]",  238LL,  a1);
      }

      sub_100005794(a1, 5, 0);
      return;
    }

    goto LABEL_33;
  }

  int v5 = 1;
  if (*(_BYTE *)(v4 + 12)) {
    goto LABEL_22;
  }
LABEL_33:
  *(_BYTE *)(a1 + 11) = 0;
  uint64_t v8 = *(void *)(a1 + 40);
  if (v8 && *(_BYTE *)(v8 + 8)) {
    goto LABEL_35;
  }
  objc_opt_self(&OBJC_CLASS___NRPairingClientManager);
  if (qword_1001DC660 != -1) {
    dispatch_once(&qword_1001DC660, &stru_1001ADF28);
  }
  id v21 = (id *)(id)qword_1001DC658;
  if (v21
    && (int v22 = v21,
        id v23 = (void *)objc_claimAutoreleasedReturnValue([v21[2] objectForKeyedSubscript:*(void *)(a1 + 24)]),
        v23,
        v22,
        !v23))
  {
LABEL_35:
    objc_opt_self(&OBJC_CLASS___NRPairingClientManager);
    if (qword_1001DC660 != -1) {
      dispatch_once(&qword_1001DC660, &stru_1001ADF28);
    }
    uint64_t v9 = (id *)(id)qword_1001DC658;
    id v10 = v9;
    if (v9) {
      [v9[2] setObject:&__kCFBooleanTrue forKeyedSubscript:*(void *)(a1 + 24)];
    }

    uint64_t v11 = *(void *)(a1 + 40);
    if (!v11) {
      goto LABEL_72;
    }
    id v12 = *(void **)(v11 + 16);
    if (v12)
    {
      id v13 = v12;
      uint64_t v14 = (nw_interface *)nw_interface_create_with_name([v13 UTF8String]);
      nw_interface_type_t type = nw_interface_get_type(v14);
      subnw_interface_type_t type = nw_interface_get_subtype(v14);
      if (type == nw_interface_type_wifi || subtype == 1001)
      {
        objc_opt_self(&OBJC_CLASS___NRLinkDirector);
        if (qword_1001DC878 != -1) {
          dispatch_once(&qword_1001DC878, &stru_1001AEED0);
        }
        id v17 = (id)qword_1001DC870;
        id v18 = v17;
        if (v17) {
          uint64_t v19 = (void *)*((void *)v17 + 6);
        }
        else {
          uint64_t v19 = 0LL;
        }
        id v20 = v19;
        sub_100140F48((uint64_t)v20, 1, *(void **)(a1 + 64));
      }

      uint64_t v11 = *(void *)(a1 + 40);
      if (!v11) {
        goto LABEL_72;
      }
    }

    if (*(_BYTE *)(v11 + 8))
    {
      if ((sub_10000B960(a1) & 1) == 0)
      {
        sub_100005794(a1, 7, 6);
        return;
      }
    }

    else
    {
LABEL_72:
      sub_100003C00(a1, (id *)(a1 + 80));
      int v37 = *(void **)(a1 + 24);
      location[0] = _NSConcreteStackBlock;
      location[1] = (id)3221225472LL;
      id location[2] = sub_10000A458;
      location[3] = &unk_1001ADDB8;
      location[4] = (id)a1;
      sub_1001320DC((uint64_t)&OBJC_CLASS___NRDLocalDevice, v37, 4, location);
    }

    sub_100005794(a1, 1, 0);
  }

  else
  {
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC628, 1LL))
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      _NRLogWithArgs( qword_1001DC628,  1LL,  "%s%.30s:%-4d %@: skipping as pairing is ongoing",  "",  "-[NRPairingClient start]",  246LL,  a1);
    }

    *(_BYTE *)(a1 + 11) = 1;
    objc_initWeak(location, (id)a1);
    objc_opt_self(&OBJC_CLASS___NRPairingClientManager);
    if (qword_1001DC660 != -1) {
      dispatch_once(&qword_1001DC660, &stru_1001ADF28);
    }
    int v24 = (id *)(id)qword_1001DC658;
    id v25 = *(void **)(a1 + 24);
    int v26 = *(void **)(a1 + 32);
    v38[0] = _NSConcreteStackBlock;
    v38[1] = 3221225472LL;
    v38[2] = sub_10000B818;
    v38[3] = &unk_1001ADD90;
    objc_copyWeak(&v39, location);
    id v27 = v25;
    id v28 = v26;
    uint64_t v29 = v38;
    if (v24)
    {
      id v30 = (void *)objc_claimAutoreleasedReturnValue([v24[2] objectForKeyedSubscript:v27]);

      if (v30)
      {
        uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v24[3] objectForKeyedSubscript:v27]);
        objc_super v32 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        if ([v31 count])
        {
          id v33 = -[NSMutableArray initWithArray:](objc_alloc(&OBJC_CLASS___NSMutableArray), "initWithArray:", v31);

          objc_super v32 = v33;
        }

        uint64_t v34 = objc_alloc_init(&OBJC_CLASS___NRPendingClientForPairing);
        id v35 = v34;
        if (v34)
        {
          objc_storeStrong((id *)&v34->_queue, v26);
          objc_setProperty_nonatomic_copy(v35, v36, v29, 16LL);
        }

        -[NSMutableArray addObject:](v32, "addObject:", v35);
        [v24[3] setObject:v32 forKeyedSubscript:v27];
      }
    }

    objc_destroyWeak(&v39);
    objc_destroyWeak(location);
  }

void sub_10000B7F4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
}

void sub_10000B818(uint64_t a1, int a2, char a3)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && (WeakRetained[8] & 0xFE) != 6)
  {
    int v7 = WeakRetained;
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC628, 1LL))
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      else {
        BOOL v6 = *(&off_1001ADE60 + (a2 - 1));
      }
      _NRLogWithArgs( qword_1001DC628,  1LL,  "%s%.30s:%-4d %@: received update for pending client %@",  "",  "-[NRPairingClient start]_block_invoke",  257LL,  v7,  v6);
    }

    if ((a2 & 0xFE) == 6)
    {
      sub_10000B180(v7);
LABEL_16:
      id WeakRetained = v7;
      goto LABEL_17;
    }

    id WeakRetained = v7;
    if (a2 == 5)
    {
      sub_100005794((uint64_t)v7, 5, a3);
      goto LABEL_16;
    }
  }

LABEL_17:
}

      -[NSMutableString appendFormat:](v13, "appendFormat:", @"PairingCompleted | ");
      if (a3) {
        goto LABEL_11;
      }
      goto LABEL_18;
    }
  }
}

      -[NSMutableString appendFormat:](v15, "appendFormat:", @"ClassCVerified | ");
      if ((v13 & 8) == 0)
      {
LABEL_11:
        if ((v13 & 0x10) == 0) {
          goto LABEL_12;
        }
        goto LABEL_19;
      }
}
}

      uint64_t v2 = *(void **)(a1 + 24);
      return v2;
    }

    id v15 = sub_1000F4464();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v15, 17LL);

    if (IsLevelEnabled)
    {
      id v17 = sub_1000F4464();
      _NRLogWithArgs(v17, 17LL, "%s called with null self.client", "-[NRASMRequest copyApplicationServiceName]");
    }
  }

  return 0LL;
}

    if (self->_complete) {
      uint64_t v11 = "C";
    }
    else {
      uint64_t v11 = "Inc";
    }
    -[NSMutableString appendFormat:](v8, "appendFormat:", @" %somplete", v11);
    if (self->_attemptImmediately) {
      -[NSMutableString appendString:](v8, "appendString:", @" Immediate");
    }
    if (self->_allowsSuspendedLink) {
      -[NSMutableString appendString:](v8, "appendString:", @" AllowsSuspendedLink");
    }
    if (self->_type == 6)
    {
      -[NSMutableString appendFormat:](v8, "appendFormat:", @" Timeout %llus", self->_timeout);
      if (self->_timerDescription) {
        -[NSMutableString appendFormat:](v8, "appendFormat:", @" %@", self->_timerDescription);
      }
    }
  }

  else
  {
    -[NSMutableString appendFormat:](v8, "appendFormat:", @" %somplete", "Inc");
  }

  -[NSMutableString appendString:](v8, "appendString:", @"]");
  return v8;
}

uint64_t sub_10000B960(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 72);
  if (v2)
  {
    [v2 cancel];
    id v3 = *(void **)(a1 + 72);
    *(void *)(a1 + 72) = 0LL;
  }

  uint64_t v4 = objc_alloc(&OBJC_CLASS___NSString);
  uint64_t v5 = *(void *)(a1 + 40);
  BOOL v6 = "Tunnel";
  if (v5 && *(_BYTE *)(v5 + 11)) {
    BOOL v6 = "Transport";
  }
  int v7 = -[NSString initWithFormat:](v4, "initWithFormat:", @"NRPairingResponder-%sMode", v6);
  id v8 = sub_10010C0B8();
  [v8 setRequestChildlessSA:1];
  uint64_t v9 = *(void *)(a1 + 40);
  if (!v9)
  {
    uint64_t v12 = 0LL;
    goto LABEL_16;
  }

  if (!*(_BYTE *)(v9 + 11))
  {
    uint64_t v12 = *(void *)(v9 + 16);
LABEL_16:
    [v8 setOutgoingInterfaceName:v12];
    id v13 = (void *)objc_claimAutoreleasedReturnValue([v8 outgoingInterfaceName]);

    if (!v13)
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC628, 17LL))
      {
        if (qword_1001DC630 != -1) {
          dispatch_once(&qword_1001DC630, &stru_1001ADE00);
        }
        _NRLogWithArgs(qword_1001DC628, 17LL, "%@: missing outgoing interface", a1);
      }

      uint64_t v36 = 0LL;
      goto LABEL_63;
    }

    objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
    if (qword_1001DC640 != -1) {
      dispatch_once(&qword_1001DC640, &stru_1001ADE98);
    }
    uint64_t v14 = (id *)(id)qword_1001DC638;
    uint64_t v15 = *(void *)(a1 + 40);
    if (v15)
    {
      id v16 = *(void **)(v15 + 16);
      id v17 = *(void **)(v15 + 32);
    }

    else
    {
      id v16 = 0LL;
      id v17 = 0LL;
    }

    id v18 = v16;
    uint64_t v19 = (id *)(id)a1;
    id v20 = v18;
    id v21 = v17;
    int v22 = v21;
    if (!v14) {
      goto LABEL_61;
    }
    if (!v20)
    {
      id v50 = sub_10000D3A0();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v50, 17LL);

      if (!IsLevelEnabled) {
        goto LABEL_61;
      }
      int v24 = sub_10000D3A0();
      _NRLogWithArgs(v24, 17LL, "%s called with null interfaceName");
      goto LABEL_60;
    }

    if (!v21)
    {
      id v52 = sub_10000D3A0();
      int v53 = _NRLogIsLevelEnabled(v52, 17LL);

      if (!v53) {
        goto LABEL_61;
      }
      int v24 = sub_10000D3A0();
      _NRLogWithArgs(v24, 17LL, "%s called with null localEndpoint");
      goto LABEL_60;
    }

    if (*((_BYTE *)v19 + 8) == 6)
    {
LABEL_61:

LABEL_62:
      uint64_t v36 = 1LL;
      goto LABEL_63;
    }

    id obj = v17;
    id v58 = v16;
    id v23 = v19[3];
    int v24 = sub_10000D498((uint64_t)v14, v20, v22, v23);

    id v25 = v14[4];
    if (!v25)
    {
      int v26 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      id v27 = v14[4];
      v14[4] = v26;

      id v25 = v14[4];
    }

    uint64_t v28 = objc_claimAutoreleasedReturnValue([v25 objectForKeyedSubscript:v24]);
    uint64_t v29 = (void *)v28;
    id v59 = (id *)v28;
    if (!v28) {
      goto LABEL_43;
    }
    id v30 = *(id *)(v28 + 32);
    uint64_t v31 = v30;
    int v55 = v24;
    id v56 = v22;
    if (v30) {
      objc_super v32 = (void *)*((void *)v30 + 3);
    }
    else {
      objc_super v32 = 0LL;
    }
    id v33 = v32;
    id v34 = v19[3];
    if ([v33 isEqual:v34])
    {
      id v35 = v59[1];
      if ([v35 isEqualToString:v20])
      {
        unsigned __int8 v54 = [v59[2] isEqual:v56];

        int v22 = v56;
        int v24 = v55;
        uint64_t v29 = v59;
        if ((v54 & 1) != 0)
        {
LABEL_59:

LABEL_60:
          goto LABEL_61;
        }

LABEL_43:
        if ((sub_10000E1E4((uint64_t)v14) & 1) != 0)
        {
          if (qword_1001DC650 != -1) {
            dispatch_once(&qword_1001DC650, &stru_1001ADF08);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC648, 0LL))
          {
            if (qword_1001DC650 != -1) {
              dispatch_once(&qword_1001DC650, &stru_1001ADF08);
            }
            _NRLogWithArgs( qword_1001DC648,  0LL,  "%s%.30s:%-4d Successfully registered pairing client %@",  "",  "-[NRIKEv2Listener registerPairingClient:localInterfaceName:localEndpoint:]",  317LL,  v19);
          }

          int v37 = objc_alloc_init(&OBJC_CLASS___NRIKEv2ListenerRegistration);
          p_isa = (id *)&v37->super.isa;
          if (v37)
          {
            objc_storeStrong((id *)&v37->_pairingClient, (id)a1);
            objc_storeStrong(p_isa + 2, obj);
            objc_storeStrong(p_isa + 1, v58);
          }

          [v14[4] setObject:p_isa forKeyedSubscript:v24];
          sub_10000E3B8((uint64_t)v14);
          sub_10000ED54((uint64_t)v14, v24);

          uint64_t v29 = v59;
        }

        else
        {
          if (qword_1001DC650 != -1) {
            dispatch_once(&qword_1001DC650, &stru_1001ADF08);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC648, 17LL))
          {
            if (qword_1001DC650 != -1) {
              dispatch_once(&qword_1001DC650, &stru_1001ADF08);
            }
            _NRLogWithArgs(qword_1001DC648, 17LL, "Failed to register pairing client %@", v19);
          }
        }

        goto LABEL_59;
      }
    }

    int v24 = v55;
    int v22 = v56;
    uint64_t v29 = v59;
    goto LABEL_43;
  }

  id v10 = -[NEIKEv2Listener initWithListenerIKEConfig:kernelSASessionName:packetDelegate:listenerQueue:delegate:delegateQueue:]( objc_alloc(&OBJC_CLASS___NEIKEv2Listener),  "initWithListenerIKEConfig:kernelSASessionName:packetDelegate:listenerQueue:delegate:delegateQueue:",  v8,  v7,  a1,  *(void *)(a1 + 32),  a1,  *(void *)(a1 + 32));
  uint64_t v11 = *(void **)(a1 + 72);
  *(void *)(a1 + 72) = v10;

  if (*(void *)(a1 + 72))
  {
    *(_BYTE *)(a1 + 15) = 0;
    if (qword_1001DC630 != -1) {
      dispatch_once(&qword_1001DC630, &stru_1001ADE00);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC628, 0LL))
    {
      if (qword_1001DC630 != -1) {
        dispatch_once(&qword_1001DC630, &stru_1001ADE00);
      }
      _NRLogWithArgs( qword_1001DC628,  0LL,  "%s%.30s:%-4d %@: Created IKE listener",  "",  "-[NRPairingClient setupResponder]",  356LL,  a1);
    }

    goto LABEL_62;
  }

  unsigned int v40 = ++*(_BYTE *)(a1 + 15);
  id v41 = sub_100003B10();
  int v42 = v41;
  if (v40 < 3)
  {
    int v45 = _NRLogIsLevelEnabled(v41, 16LL);

    if (v45)
    {
      id v46 = sub_100003B10();
      _NRLogWithArgs( v46,  16LL,  "%s%.30s:%-4d %@: Failed to create IKE listener",  "",  "-[NRPairingClient setupResponder]",  332LL,  a1);
    }

    objc_initWeak(&location, (id)a1);
    dispatch_time_t v47 = dispatch_time(0x8000000000000000LL, 3000000000LL);
    uint64_t v48 = *(void **)(a1 + 32);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_10000C0BC;
    block[3] = &unk_1001AFED0;
    uint64_t v49 = v48;
    objc_copyWeak(&v61, &location);
    dispatch_after(v47, v49, block);

    objc_destroyWeak(&v61);
    objc_destroyWeak(&location);
    goto LABEL_62;
  }

  int v43 = _NRLogIsLevelEnabled(v41, 17LL);

  if (v43)
  {
    id v44 = sub_100003B10();
    _NRLogWithArgs(v44, 17LL, "%@: Failed to create IKE listener", a1);
  }

  sub_100005794(a1, 7, 6);
  uint64_t v36 = 0LL;
LABEL_63:

  return v36;
}

      v21[2](v21, 0LL, 0LL, 0LL);
      goto LABEL_44;
    }

    id v61 = sub_1000627F8();
    int v62 = _NRLogIsLevelEnabled(v61, 16LL);

    if (v62)
    {
      id v63 = sub_1000627F8();
      _NRLogWithArgs( v63,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRLinkFixedInterface requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  561);
    }

    uint64_t v64 = _os_log_pack_size(12LL);
    uint64_t v14 = (char *)&v68 - ((__chkstk_darwin(v64) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v65 = __error();
    int v66 = _os_log_pack_fill( v14,  v64,  *v65,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    *(_DWORD *)int v66 = 136446210;
    *(void *)(v66 + 4) = "-[NRLinkFixedInterface requestConfigurationForListener:session:sessionConfig:childConfig:vali"
                           "dateAuthBlock:responseBlock:]";
    id v67 = sub_1000627F8();
    _NRLogAbortWithPack(v67, v14);
    goto LABEL_41;
  }

  id v59 = sub_1000627F8();
  uint64_t v60 = _NRLogIsLevelEnabled(v59, 17LL);

  if (v60)
  {
    id v52 = sub_1000627F8();
    _NRLogWithArgs(v52, 17LL, "%s called with null responseBlock");
    goto LABEL_37;
  }

  -[NSMutableArray addObject:](v8, "addObject:", @"RadioConditionBest");
  if ((reason & 0x400000) == 0)
  {
LABEL_18:
    if ((reason & 0x800000) == 0) {
      goto LABEL_19;
    }
    goto LABEL_45;
  }

  -[NSMutableArray addObject:](v3, "addObject:", @"BtryGood");
  if ((a1 & 0x20000000) == 0)
  {
LABEL_18:
    if ((a1 & 0x100000000000000LL) == 0) {
      goto LABEL_19;
    }
    goto LABEL_45;
  }

        goto LABEL_44;
      }

      int v24 = sub_10010C6B8(1, v10, a2);
      id v70 = v24;
      if ((_DWORD)a2 != 1)
      {
        id v25 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  @"::",  @"0"));
        int v26 = objc_alloc(&OBJC_CLASS___NEIKEv2ConfigurationMessage);
        id v27 = [[NEIKEv2InitiatorTransportIPv6Address alloc] initWithAddress:v25];
        v71[0] = v27;
        uint64_t v28 = [[NEIKEv2ResponderTransportIPv6Address alloc] initWithAddress:v25];
        v71[1] = v28;
        uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v71, 2LL));
        id v30 = [v26 initWithWithAttributes:v29];
        -[NEIKEv2SessionConfiguration setConfigurationRequest:](v70, "setConfigurationRequest:", v30);

        int v24 = v70;
      }

      uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(-[NEIKEv2SessionConfiguration customIKEAuthPrivateNotifies](v24, "customIKEAuthPrivateNotifies"));

      if (v31)
      {
        objc_super v32 = (void *)objc_claimAutoreleasedReturnValue(-[NEIKEv2SessionConfiguration customIKEAuthPrivateNotifies](v24, "customIKEAuthPrivateNotifies"));
        id v33 = (NSMutableArray *)[v32 mutableCopy];
      }

      else
      {
        id v33 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      }

      int v37 = [(id)a1 suspendWhenReady];
      if ((_DWORD)a2 == 4 && v37)
      {
        id v38 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50901 notifyData:0];
        -[NSMutableArray addObject:](v33, "addObject:", v38);
      }

      if (-[NSMutableArray count](v33, "count")) {
        -[NEIKEv2SessionConfiguration setCustomIKEAuthPrivateNotifies:](v24, "setCustomIKEAuthPrivateNotifies:", v33);
      }
      id v39 = v24;
      unsigned int v40 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"terminusIKE-Bluetooth-%@",  String);
      id v41 = sub_10010C0B8();
      sub_10010BDB0(v10, v41);
      int v42 = sub_10010C340();
      -[NEIKEv2ChildSAConfiguration setSequencePerTrafficClass:](v42, "setSequencePerTrafficClass:", 1LL);
      -[NEIKEv2ChildSAConfiguration setReplayWindowSize:](v42, "setReplayWindowSize:", 16LL);
      sub_10010BF54(v10, v42);
      int v43 = -[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName:packetDelegate:]( objc_alloc(&OBJC_CLASS___NEIKEv2Session),  "initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName :packetDelegate:",  v41,  v42,  v39,  *(void *)(a1 + 8),  *(void *)(a1 + 56),  0LL,  v40,  a1);
      id v44 = *v5;
      *uint64_t v5 = v43;

      if (!*v5)
      {
        id v61 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v45);
        int v62 = _NRLogIsLevelEnabled(v61, 17LL);

        if (v62)
        {
          uint64_t v64 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v63);
          id v65 = [(id)a1 copyDescription];
          _NRLogWithArgs(v64, 17LL, "%@: Failed to create initiator %@ IKE session", v65, String);
        }

        goto LABEL_42;
      }

      [(id)a1 reportEvent:3015, @"%@ %@", String, *v5 detailsFormat];
      sub_100077840((void *)a1, a2);
      if ((_DWORD)a2 == 4)
      {
        dispatch_time_t v47 = mach_absolute_time();
        uint64_t v48 = *(void *)(a1 + 1863);
        if (v48)
        {
          *(void *)(v48 + 4_Block_object_dispose((const void *)(v1 - 120), 8) = v47;
          uint64_t v49 = (char *)*(id *)(a1 + 1863);
          if (v49)
          {
            id v50 = &OBJC_IVAR___NRAnalyticsCmpnLink__ikeClassDAttempts;
LABEL_37:
            ++*(void *)&v49[*v50];
            goto LABEL_38;
          }

          goto LABEL_38;
        }
      }

      else
      {
        if ((_DWORD)a2 != 3)
        {
LABEL_39:
          int v53 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v46);
          unsigned __int8 v54 = _NRLogIsLevelEnabled(v53, 0LL);

          if (v54)
          {
            id v56 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v55);
            id v57 = [(id)a1 copyDescription];
            _NRLogWithArgs( v56,  0LL,  "%s%.30s:%-4d %@: Connecting initiator %@ session %@",  "",  "-[NRLinkBluetooth setupIPsecInitiatorIfNecessary:]",  8948LL,  v57,  String,  *v5);
          }

          [*v5 connect];
LABEL_42:

          goto LABEL_43;
        }

        uint64_t v51 = mach_absolute_time();
        id v52 = *(void *)(a1 + 1863);
        if (v52)
        {
          *(void *)(v52 + 32) = v51;
          uint64_t v49 = (char *)*(id *)(a1 + 1863);
          if (v49)
          {
            id v50 = &OBJC_IVAR___NRAnalyticsCmpnLink__ikeClassCAttempts;
            goto LABEL_37;
          }

            goto LABEL_59;
          case 3u:
            id v27 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v15);
            uint64_t v28 = _NRLogIsLevelEnabled(v27, 17LL);

            if (!v28) {
              goto LABEL_59;
            }
            uint64_t v29 = self->_nrUUID;
            uint64_t v31 = (void *)_NRCopyLogObjectForNRUUID(v29, v30);
            objc_super v32 = [v4 type];

            StringFromNRLinkType = (NSUUID *)createStringFromNRLinkType(v32);
            _NRLogWithArgs(v31, 17LL, "%@ link not supported yet", StringFromNRLinkType);
            goto LABEL_27;
          case 4u:
            sub_1000DAC60((uint64_t)self);
            goto LABEL_59;
          case 5u:
            goto LABEL_58;
          default:
            goto LABEL_59;
        }
      }

      id v23 = _NRLogIsLevelEnabled(v8, 16LL);

      if (v23)
      {
        int v24 = self->_nrUUID;
        int v26 = (void *)_NRCopyLogObjectForNRUUID(v24, v25);
        _NRLogWithArgs( v26,  16LL,  "%s%.30s:%-4d Ignoring link availability event as link was cancelled %@",  "",  "-[NRDDeviceConductor linkIsAvailable:]",  5443LL,  v4);
      }
    }

    else
    {
      uint64_t v19 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v5);
      id v20 = _NRLogIsLevelEnabled(v19, 1LL);

      if (v20)
      {
        int v22 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v21);
        _NRLogWithArgs( v22,  1LL,  "%s%.30s:%-4d Ignoring link availability event as conductor is disabled",  "",  "-[NRDDeviceConductor linkIsAvailable:]",  5438);
      }
    }
  }

  else
  {
    id v61 = sub_1000D54AC();
    int v62 = _NRLogIsLevelEnabled(v61, 17LL);

    if (v62)
    {
      id v63 = sub_1000D54AC();
      _NRLogWithArgs(v63, 17LL, "%s called with null link", "-[NRDDeviceConductor linkIsAvailable:]");
    }
  }
}

      id v18 = -[NSString initWithUTF8String:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithUTF8String:",  "AutoLinkUpgrade");
      if (-[NSMutableString length](v11, "length")) {
        -[NSMutableString appendString:](v11, "appendString:", @", ");
      }
      -[NSMutableString appendString:](v11, "appendString:", v18);

      goto LABEL_46;
    }

void sub_10000C0BC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained
    && (*((_BYTE *)WeakRetained + 8) & 0xFE) != 6
    && (*((_BYTE *)WeakRetained + 48) & 0x10) == 0
    && !*((void *)WeakRetained + 9))
  {
    id v2 = WeakRetained;
    sub_10000B960();
    id WeakRetained = v2;
  }
}

LABEL_9:
}
}

  if ([(id)a1 ikeClassDEstablished])
  {
    id v17 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v16);
    id v18 = _NRLogIsLevelEnabled(v17, 0LL);

    if (v18)
    {
      id v20 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v19);
      id v21 = [(id)a1 copyDescription];
      _NRLogWithArgs( v20,  0LL,  "%s%.30s:%-4d %@: IKE classD already established",  "",  "-[NRLinkQuickRelay setupIPsecClassD]",  1434LL,  v21);
    }
  }

  else
  {
    sub_10003CE18(a1, 4LL);
  }

  if (![(id)a1 ikeClassCEstablished])
  {
    sub_10003CE18(a1, 3LL);
    return;
  }

  int v43 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v42);
  id v44 = _NRLogIsLevelEnabled(v43, 0LL);

  if (v44)
  {
    id v68 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v45);
    id v46 = [(id)a1 copyDescription];
    _NRLogWithArgs( v68,  0LL,  "%s%.30s:%-4d %@: IKE classC already established",  "",  "-[NRLinkQuickRelay setupIPsecClassC]",  1444LL,  v46);

LABEL_30:
  }
}

  if ((_DWORD)v10)
  {
    if (*(_BYTE *)(v4 + 229))
    {
      uint64_t v11 = *(unsigned __int8 *)(v4 + 16);
LABEL_16:
      if ((v11 - 4) <= 5)
      {
        id v18 = *(_DWORD *)(v4 + 311);
        uint64_t v19 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
        id v20 = (unsigned int *)(v4 + 315);
        id v21 = *(_DWORD *)(v4 + 315);
        int v22 = v21 + 1;
        if (v18 < v21 + 1)
        {
LABEL_18:
          sub_100090348(v4, 1LL);
          return;
        }

        v282 = v4;
        while (1)
        {
          uint64_t v36 = (unsigned __int8 *)(*(void *)(v4 + 1311) + v21);
          int v37 = *v36;
          if (*v36)
          {
            if (v18 < v21 + 3)
            {
              sub_100090348(v4, 3LL);
              return;
            }

            id v38 = bswap32(*(unsigned __int16 *)(v36 + 1)) >> 16;
            if (v18 < v21 + v38 + 5)
            {
              if (*v3)
              {
                v221 = v38;
                v222 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), a2);
                v223 = _NRLogIsLevelEnabled(v222, 1LL);

                LODWORD(v3_Block_object_dispose((const void *)(v1 - 120), 8) = v221;
                if (v223)
                {
                  v225 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v224);
                  v226 = [(id)v4 copyDescription];
                  StringFromNRTLVType = (void *)createStringFromNRTLVType(v37);
                  _NRLogWithArgs( v225,  1LL,  "%s%.30s:%-4d %@: Got %@ len %u but only have %u",  "",  "-[NRLinkBluetooth handleReadData:]",  6728LL,  v226,  StringFromNRTLVType,  v221,  (*(_DWORD *)(v4 + 311) - *(_DWORD *)(v4 + v19[186])));

                  LODWORD(v3_Block_object_dispose((const void *)(v1 - 120), 8) = v221;
                }
              }

              sub_100090348(v4, (v38 + 5));
              return;
            }

            if (*v3)
            {
              int v69 = v38;
              id v70 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), a2);
              dispatch_time_t v71 = _NRLogIsLevelEnabled(v70, 1LL);

              id v38 = v69;
              if (v71)
              {
                v281 = (NSData *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), a2);
                int v72 = (char *)[(id)v4 copyDescription];
                v280 = v72;
                uint64_t v73 = (void *)createStringFromNRTLVType(v37);
                v268 = (unsigned __int16 *)v72;
                id v74 = v281;
                _NRLogWithArgs( v281,  1LL,  "%s%.30s:%-4d %@: Handling %@ len %u since we have %u",  "",  "-[NRLinkBluetooth handleReadData:]",  6733LL,  v268,  v73,  v69,  (*(_DWORD *)(v4 + 311) - *(_DWORD *)(v4 + v19[186])));

                id v38 = v69;
              }
            }

            id v39 = v19[186];
            unsigned int v40 = *(unsigned int *)(v4 + v39);
            id v41 = (unsigned __int8 *)(*(void *)(v4 + 1311) + v40);
            int v42 = v41 + 3;
            if ((char)v37 < 100)
            {
              id v50 = v19;
              int v43 = v41 + 3;
              uint64_t v51 = *(unsigned __int16 *)&v42[v38];
              id v52 = v38;
              int v53 = os_inet_checksum(v41, (v38 + 3), 0LL);
              unsigned __int8 v54 = ~v53;
              if (v51 != (unsigned __int16)~(_WORD)v53)
              {
                if (qword_1001DC840 != -1) {
                  dispatch_once(&qword_1001DC840, &stru_1001AEE08);
                }
                if (_NRLogIsLevelEnabled(qword_1001DC838, 16LL))
                {
                  if (qword_1001DC840 != -1) {
                    dispatch_once(&qword_1001DC840, &stru_1001AEE08);
                  }
                  _NRLogWithArgs( qword_1001DC838,  16LL,  "%s%.30s:%-4d checksum failed computed 0x%04x != observed 0x%04x",  "",  "nrChecksumVerify",  133,  bswap32(v54) >> 16,  __rev16(v51));
                }

                uint64_t v98 = v50[186];
                uint64_t v4 = v282;
                *(_DWORD *)(v282 + v98) += v52 + 5;
LABEL_98:
                int v99 = *(void *)(v4 + 1863);
                if (v99) {
                  *(_BYTE *)(v99 + 9_Block_object_dispose((const void *)(v1 - 120), 8) = 1;
                }
                v281 = (NSData *)createStringFromNRTLVType(v37);
                sub_1000749CC( (void *)v4,  @"Invalid checksum detected in buffer on read type %@ len %u filledIn=%u handled=%u",  v100,  v101,  v102,  v103,  v104,  v105,  (uint64_t)v281);
                goto LABEL_25;
              }

              uint64_t v19 = v50;
              int v55 = v50[186];
              uint64_t v4 = v282;
              *(_DWORD *)(v282 + v55) += v52 + 5;
              id v38 = v52;
            }

            else
            {
              int v43 = v41 + 3;
              id v44 = *(unsigned __int16 *)&v42[v38];
              int v45 = (*v41 << 12) ^ (v41[2] << 8) | v41[1] ^ (*v41 >> 4);
              *(_DWORD *)(v4 + v39) = v38 + v40 + 5;
            }

            switch((int)v37)
            {
              case 1:
                id v56 = v38;
                id v57 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), a2);
                id v58 = _NRLogIsLevelEnabled(v57, 1LL);

                if (v58)
                {
                  id v59 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), a2);
                  uint64_t v60 = [(id)v4 copyDescription];
                  _NRLogWithArgs( v59,  1LL,  "%s%.30s:%-4d %@: Handling PadN %u",  "",  "-[NRLinkBluetooth handleReadData:]",  6757LL,  v60,  v56);
                }

                break;
              case 2:
                id v61 = v38;
                ++*(void *)(v4 + 1591);
                int v62 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), a2);
                id v63 = _NRLogIsLevelEnabled(v62, 1LL);

                if (v63)
                {
                  id v65 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v64);
                  int v66 = [(id)v4 copyDescription];
                  _NRLogWithArgs( v65,  1LL,  "%s%.30s:%-4d %@: Reinjecting uncompressed packet len %u",  "",  "-[NRLinkBluetooth handleReadData:]",  6761LL,  v66,  v61);
                }

                id v67 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  v43,  v61);
                sub_100090540(v4, v67);

                break;
              case 3:
              case 100:
              case 101:
              case 102:
              case 103:
              case 104:
              case 105:
                sub_100090624((char *)v4, (uint64_t)v41, (unsigned __int16)(v38 + 5), v38, v37);
                break;
              case 4:
                id v68 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  v43,  v38);
                sub_10008BC7C(v4, v68);

                break;
              case 5:
                sub_10008BFD0((void *)v4, v43, v38);
                break;
              default:
                break;
            }
          }

          else
          {
            *id v20 = v22;
            id v46 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), a2);
            dispatch_time_t v47 = _NRLogIsLevelEnabled(v46, 1LL);

            if (v47)
            {
              uint64_t v48 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), a2);
              uint64_t v49 = [(id)v4 copyDescription];
              _NRLogWithArgs( v48,  1LL,  "%s%.30s:%-4d %@: Handling Pad0",  "",  "-[NRLinkBluetooth handleReadData:]",  6718LL,  v49);
            }
          }

          id v18 = *(_DWORD *)(v4 + 311);
          id v20 = (unsigned int *)(v4 + v19[186]);
          id v21 = *v20;
          int v22 = *v20 + 1;
          if (v18 < v22) {
            goto LABEL_18;
          }
        }
      }

      id v23 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), a2);
      int v24 = _NRLogIsLevelEnabled(v23, 1LL);

      if (!v24) {
        return;
      }
      v281 = (NSData *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v25);
      int v26 = [(id)v4 copyDescription];
      _NRLogWithArgs( v281,  1LL,  "%s%.30s:%-4d %@: Ignoring bytes due to unknown state",  "",  "-[NRLinkBluetooth handleReadData:]",  6791LL,  v26);

LABEL_25:
      return;
    }
  }

  else
  {
    uint64_t v11 = *(unsigned __int8 *)(v4 + 16);
  }

  uint64_t v12 = *(unsigned int *)(v4 + v8);
  if ((*(_DWORD *)((char *)v9 + v4) - v12) <= 0xB)
  {
    id v13 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), a2);
    uint64_t v14 = _NRLogIsLevelEnabled(v13, 1LL);

    if (!v14) {
      return;
    }
    v281 = (NSData *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v15);
    id v16 = [(id)v4 copyDescription];
    id v17 = sub_1001080C0(*(unsigned __int8 *)(v4 + 16));
    _NRLogWithArgs( v281,  1LL,  "%s%.30s:%-4d %@: State %@ not enough prelude bytes %u - %u < %zu",  "",  "-[NRLinkBluetooth handleReadData:]",  6466LL,  v16,  v17,  *(unsigned int *)((char *)v9 + v4),  *(unsigned int *)(v4 + v8),  12LL);

    goto LABEL_25;
  }

  id v27 = &v2[v12];
  if (*(void *)&v2[v12] != 0x53554E494D524554LL)
  {
    v281 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", v27, 8LL);
    uint64_t v28 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  &unk_1001568AC,  8LL);
    uint64_t v29 = v28;
    id v30 = "";
    if ((_DWORD)v10) {
      id v30 = "urgent ";
    }
    [(id)v4 cancelWithReason:@"invalid %sprelude: received %@, expected %@, filledIn=%u, handled=%u", v30, v281, v28, *(unsigned int *)((char *)v9 + v4), *(unsigned int *)(v4 + v8)];

    goto LABEL_25;
  }

  uint64_t v31 = (bswap32(*((unsigned __int16 *)v27 + 5)) >> 16) + 14;
  if (!(_DWORD)v10)
  {
    v75 = v27[8];
    if ((_DWORD)v75 == 1)
    {
      if (qword_1001DC840 != -1) {
        dispatch_once(&qword_1001DC840, &stru_1001AEE08);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC838, 0LL))
      {
        id v76 = sub_100070554();
        _NRLogWithArgs( v76,  0LL,  "%s%.30s:%-4d We both speak terminus version %u",  "",  "-[NRLinkBluetooth handleReadData:]",  6534,  1);
      }

      uint64_t v77 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"version %u",  1LL,  v271);
    }

    else
    {
      if (qword_1001DC840 != -1) {
        dispatch_once(&qword_1001DC840, &stru_1001AEE08);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC838, 0LL))
      {
        int v83 = sub_100070554();
        _NRLogWithArgs( v83,  0LL,  "%s%.30s:%-4d Remote device speaks terminus version %u while we speak %u",  "",  "-[NRLinkBluetooth handleReadData:]",  6529,  v75,  1);
      }

      uint64_t v77 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"localVersion %u remoteVersion %u",  1LL,  v75);
    }

    v281 = (NSData *)v77;
    *(_BYTE *)(v4 + 209) = v27[9];
    if (*(unsigned __int8 *)(v4 + 208) == *(unsigned __int8 *)(v4 + 209))
    {
      if (qword_1001DC840 != -1) {
        dispatch_once(&qword_1001DC840, &stru_1001AEE08);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC838, 0LL))
      {
        int v84 = sub_100070554();
        id v85 = (__CFString *)sub_10008F5F8(*(unsigned __int8 *)(v4 + 209));
        _NRLogWithArgs( v84,  0LL,  "%s%.30s:%-4d We are both in prelude state %@",  "",  "-[NRLinkBluetooth handleReadData:]",  6547LL,  v85);
      }

      int v86 = objc_alloc(&OBJC_CLASS___NSString);
      id v87 = @"Invalid";
      switch(*(_BYTE *)(v4 + 209))
      {
        case 0:
          break;
        case 0xA:
          id v87 = @"PairWithOOBKey";
          break;
        case 0xB:
          id v87 = @"PairWithIDSKeys";
          break;
        case 0xC:
          id v87 = @"PairWithOOBKeyOrIDSKeys";
          break;
        case 0x14:
          id v87 = @"HasCompletedPairing";
          break;
        default:
          id v87 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown(%lld)",  *(unsigned __int8 *)(v4 + 209));
          break;
      }

      uint64_t v9 = -[NSString initWithFormat:](v86, "initWithFormat:", @"state %@", v87);
    }

    else
    {
      if (qword_1001DC840 != -1) {
        dispatch_once(&qword_1001DC840, &stru_1001AEE08);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC838, 0LL))
      {
        int v88 = sub_100070554();
        int v89 = (__CFString *)sub_10008F5F8(*(unsigned __int8 *)(v4 + 209));
        id v90 = (__CFString *)sub_10008F5F8(*(unsigned __int8 *)(v4 + 208));
        _NRLogWithArgs( v88,  0LL,  "%s%.30s:%-4d Received remote prelude state %@ while we are %@",  "",  "-[NRLinkBluetooth handleReadData:]",  6542LL,  v89,  v90);
      }

      int v91 = objc_alloc(&OBJC_CLASS___NSString);
      id v87 = @"Invalid";
      switch(*(_BYTE *)(v4 + 208))
      {
        case 0:
          break;
        case 0xA:
          id v87 = @"PairWithOOBKey";
          break;
        case 0xB:
          id v87 = @"PairWithIDSKeys";
          break;
        case 0xC:
          id v87 = @"PairWithOOBKeyOrIDSKeys";
          break;
        case 0x14:
          id v87 = @"HasCompletedPairing";
          break;
        default:
          id v87 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown(%lld)",  *(unsigned __int8 *)(v4 + 208));
          break;
      }

      uint64_t v106 = @"Invalid";
      switch(*(_BYTE *)(v4 + 209))
      {
        case 0:
          break;
        case 0xA:
          uint64_t v106 = @"PairWithOOBKey";
          break;
        case 0xB:
          uint64_t v106 = @"PairWithIDSKeys";
          break;
        case 0xC:
          uint64_t v106 = @"PairWithOOBKeyOrIDSKeys";
          break;
        case 0x14:
          uint64_t v106 = @"HasCompletedPairing";
          break;
        default:
          uint64_t v106 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown(%lld)",  *(unsigned __int8 *)(v4 + 209));
          break;
      }

      uint64_t v9 = -[NSString initWithFormat:](v91, "initWithFormat:", @"localState %@ remoteState %@", v87, v106);

      id v3 = &gNRPacketLoggingEnabled;
    }

    uint64_t v107 = *(unsigned __int8 *)(v4 + 209);
    uint64_t v108 = *(unsigned __int8 *)(v4 + 208);
    uint64_t v109 = v281;
    if (v107 != v108)
    {
      if (v107 == 10 && v108 != 12 || v107 != 12 && (!*(_BYTE *)(v4 + 209) || v108 == 10))
      {
        [(id)v4 cancelWithReason:@"Incompatible pairing prelude states %@, %@", v9, v281];
        goto LABEL_247;
      }

      if (v108 < v107) {
        LOBYTE(v107) = *(_BYTE *)(v4 + 208);
      }
    }

    *(_BYTE *)(v4 + 210) = v107;
    uint64_t v110 = @"Invalid";
    switch(*(_BYTE *)(v4 + 210))
    {
      case 0:
        break;
      case 0xA:
        uint64_t v110 = @"PairWithOOBKey";
        break;
      case 0xB:
        uint64_t v110 = @"PairWithIDSKeys";
        break;
      case 0xC:
        uint64_t v110 = @"PairWithOOBKeyOrIDSKeys";
        break;
      case 0x14:
        uint64_t v110 = @"HasCompletedPairing";
        break;
      default:
        uint64_t v110 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown(%lld)",  *(unsigned __int8 *)(v4 + 210));
        break;
    }

    [(id)v4 reportEvent:3010, @"%@, %@, using %@", v109, v9, v110 detailsFormat];

    id v112 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
    v113 = (unsigned __int16)v31;
    if (*(_DWORD *)(v4 + 311) - *(_DWORD *)(v4 + 315) < (unsigned __int16)v31)
    {
      v114 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v111);
      v115 = _NRLogIsLevelEnabled(v114, 1LL);

      if (v115)
      {
        v117 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v116);
        v118 = [(id)v4 copyDescription];
        v119 = sub_1001080C0(*(unsigned __int8 *)(v4 + 16));
        _NRLogWithArgs( v117,  1LL,  "%s%.30s:%-4d %@: State %@ not enough prelude and TLVs bytes %u - %u < %u",  "",  "-[NRLinkBluetooth handleReadData:]",  6575LL,  v118,  v119,  *(unsigned int *)(v4 + 311),  *(unsigned int *)(v4 + 315),  (unsigned __int16)v31);
      }

      goto LABEL_247;
    }

    v279 = v9;
    v120 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  v27,  (unsigned __int16)v31);
    sub_10008F690(v4, v120);

    id v8 = (unsigned __int16)v31 - 2;
    if ((unsigned __int16)v31 == 2)
    {
      v245 = sub_100070554();
      v246 = _NRLogIsLevelEnabled(v245, 16LL);

      if (v246)
      {
        v247 = sub_100070554();
        _NRLogWithArgs(v247, 16LL, "%s%.30s:%-4d ABORTING: Assertion Failed: dataLen > 0", "", "nrChecksumVerify", 126);
      }

      v248 = _os_log_pack_size(12LL);
      id v34 = (uint64_t)&v273 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      v249 = __error();
      v250 = _os_log_pack_fill( v34,  v248,  *v249,  &_mh_execute_header,  "%{public}s Assertion Failed: dataLen > 0");
      *(_DWORD *)v250 = 136446210;
      *(void *)(v250 + 4) = "nrChecksumVerify";
      v251 = sub_100070554();
      _NRLogAbortWithPack(v251, v34);
      goto LABEL_267;
    }

    v277 = (char *)((unsigned __int16)v31 - 2LL);
    v278 = (unsigned __int16)v31;
    v280 = &v277[(void)v27];
    __int128 v121 = *(unsigned __int16 *)&v277[(void)v27];
    __int128 v122 = os_inet_checksum(v27, (unsigned __int16)v31 - 2, 0LL);
    __int128 v124 = ~v122;
    if (v121 != (unsigned __int16)~(_WORD)v122)
    {
      v172 = sub_100070554();
      v173 = _NRLogIsLevelEnabled(v172, 16LL);

      if (v173)
      {
        v174 = sub_100070554();
        _NRLogWithArgs( v174,  16LL,  "%s%.30s:%-4d checksum failed computed 0x%04x != observed 0x%04x",  "",  "nrChecksumVerify",  133,  bswap32(v124) >> 16,  __rev16(v121));
      }

      v175 = os_inet_checksum(v27, v8, 0LL);
      v177 = *(unsigned __int16 *)v280;
      v178 = *(void *)(v4 + 1863);
      if (v178) {
        *(_BYTE *)(v178 + 99) = 1;
      }
      v179 = ~v175;
      v180 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v176);
      v181 = _NRLogIsLevelEnabled(v180, 16LL);

      v183 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      if ((v181 & 1) != 0)
      {
        v280 = (char *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v182);
        v278 = (unint64_t)[(id)v4 copyDescription];
        v184 = *(id *)(v4 + 359);
        v277 = (char *)[v184 length];
        v185 = *(id *)(v4 + 359);
        v186 = (void *)((uint64_t (*)(void))_NRCreateDataString)();
        v187 = *(unsigned int *)(v4 + 311);
        v188 = *(unsigned int *)(v4 + 315);

        v189 = v179;
        v272 = v179;
        v269 = v187;
        v270 = v188;
        v183 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
        v190 = (void *)v278;
        v191 = v280;
        _NRLogWithArgs( v280,  16LL,  "%s%.30s:%-4d %@: Prelude checksum failed: received %llu bytes %@, filledIn=%u, handled=%u, receivedChecksum=0x %04x expectedChecksum=0x%04x",  "",  "-[NRLinkBluetooth handleReadData:]",  6591LL,  v278,  v277,  v186,  v269,  v270,  v177,  v272);
      }

      else
      {
        v189 = v179;
      }

      uint64_t v109 = v281;
      v192 = *(id *)(v4 + v183[349]);
      objc_msgSend( (id)v4,  "cancelWithReason:",  @"prelude checksum failed: received %llu bytes, filledIn=%u, handled=%u, receivedChecksum=0x%04x expectedChecksum=0x%04x",  objc_msgSend(v192, "length"),  *(unsigned int *)(v4 + 311),  *(unsigned int *)(v4 + 315),  v177,  v189);

      uint64_t v9 = v279;
      goto LABEL_247;
    }

    uint64_t v125 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v123);
    uint64_t v126 = _NRLogIsLevelEnabled(v125, 1LL);

    if (v126)
    {
      v128 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v127);
      v129 = [(id)v4 copyDescription];
      v130 = *(id *)(v4 + 359);
      v131 = [v130 length];
      v132 = (void *)_NRCreateDataString(*(void *)(v4 + 359));
      _NRLogWithArgs( v128,  1LL,  "%s%.30s:%-4d %@: Received prelude %llu bytes %@",  "",  "-[NRLinkBluetooth handleReadData:]",  6599LL,  v129,  v131,  v132);

      v113 = (unsigned __int16)v31;
    }

    v133 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
    id v8 = (unint64_t)v280;
    v134 = (unint64_t)(v27 + 12);
    v276 = v113;
    while (1)
    {
      if (!*(_BYTE *)v134) {
        goto LABEL_143;
      }
      if (v134 + 2 > v8)
      {
        v193 = v113;
        v194 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v127);
        id v8 = _NRLogIsLevelEnabled(v194, 16LL);

        v113 = v193;
        if (!(_DWORD)v8) {
          goto LABEL_230;
        }
        id v8 = _NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v127);
        v195 = [(id)v4 copyDescription];
        _NRLogWithArgs( v8,  16LL,  "%s%.30s:%-4d %@: TLV len is off the edge %lld > %lld",  "",  "-[NRLinkBluetooth handleReadData:]",  6610LL,  v195,  v134 + 2 - (void)v27,  v277);
        goto LABEL_229;
      }

      v135 = *(unsigned __int16 *)(v134 + 1);
      v136 = __rev16(v135);
      v137 = v134 + 3 + v136;
      if (v137 > v8)
      {
        v196 = v113;
        v197 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v127);
        id v8 = _NRLogIsLevelEnabled(v197, 16LL);

        v113 = v196;
        if (!(_DWORD)v8) {
          goto LABEL_230;
        }
        id v8 = _NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v127);
        v195 = [(id)v4 copyDescription];
        _NRLogWithArgs( v8,  16LL,  "%s%.30s:%-4d %@: TLV is off the edge %lld + 3 + %u = %lld > %lld",  "",  "-[NRLinkBluetooth handleReadData:]",  6621LL,  v195,  v134 - (void)v27,  v136,  v137 - (void)v27,  v277);
LABEL_229:

LABEL_230:
        v198 = *(_DWORD *)(v4 + 311) - *(_DWORD *)(v4 + v133[186]);
        if (v198 > v113)
        {
          uint64_t v9 = v279;
          v199 = &v27[v278];
          if (*v3)
          {
            v252 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v127);
            v253 = _NRLogIsLevelEnabled(v252, 1LL);

            if (v253)
            {
              v255 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v254);
              v256 = [(id)v4 copyDescription];
              _NRLogWithArgs( v255,  1LL,  "%s%.30s:%-4d %@: memmoving the linkReadBuffer by preludeLenFull=%u filledIn=%u handled=%u",  "",  "-[NRLinkBluetooth handleReadData:]",  6660LL,  v256,  v113,  *(unsigned int *)(v4 + 311),  *(unsigned int *)(v4 + v133[186]));
            }
          }

          memmove( *(void **)(v4 + 1311),  v199,  (*(_DWORD *)(v4 + 311) - (*(_DWORD *)(v4 + v133[186]) + v113)));
          *(_DWORD *)(v4 + 311) -= *(_DWORD *)(v4 + v133[186]) + v113;
          uint64_t v109 = v281;
          goto LABEL_237;
        }

        uint64_t v9 = v279;
        if (v198 != (_DWORD)v113)
        {
          id v2 = (char *)v113;
          v257 = sub_100070554();
          v258 = _NRLogIsLevelEnabled(v257, 16LL);

          if (v258)
          {
            v259 = sub_100070554();
            _NRLogWithArgs( v259,  16LL,  "%s%.30s:%-4d ABORTING: Bad prelude post-processing preludeLenFull=%u filledIn=%u handled=%u",  "",  "-[NRLinkBluetooth handleReadData:]",  6668,  v113,  *(_DWORD *)(v4 + 311),  *(_DWORD *)(v4 + 315));
          }

          id v10 = _os_log_pack_size(30LL);
          v211 = (char *)&v273 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          v260 = __error();
          v261 = _os_log_pack_fill( v211,  v10,  *v260,  &_mh_execute_header,  "%{public}s Bad prelude post-processing preludeLenFull=%u filledIn=%u handled=%u");
          sub_10008BB5C( v261,  (uint64_t)"-[NRLinkBluetooth handleReadData:]",  v113,  *(_DWORD *)(v4 + 311),  *(_DWORD *)(v4 + 315));
          goto LABEL_252;
        }

        uint64_t v109 = v281;
        if (*v3)
        {
          v262 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v127);
          v263 = _NRLogIsLevelEnabled(v262, 1LL);

          if (v263)
          {
            v265 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v264);
            v266 = [(id)v4 copyDescription];
            _NRLogWithArgs( v265,  1LL,  "%s%.30s:%-4d %@: not memmoving the linkReadBuffer by preludeLenFull=%u filledIn=%u handled=%u",  "",  "-[NRLinkBluetooth handleReadData:]",  6671LL,  v266,  v113,  *(unsigned int *)(v4 + 311),  *(unsigned int *)(v4 + v133[186]));
          }
        }

        *(_DWORD *)(v4 + 311) = 0;
LABEL_237:
        *(_DWORD *)(v4 + v133[186]) = 0;
        if (*(_BYTE *)(v4 + 16) == 1)
        {
          [(id)v4 changeStateTo:3];
LABEL_240:
          if (*(_BYTE *)(v4 + 246))
          {
            if (*(_BYTE *)(v4 + 16) == 4) {
              sub_10008F364((void *)v4, v113, &off_1001BC628);
            }
          }

          else
          {
            v202 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v200);
            v203 = _NRLogIsLevelEnabled(v202, 1LL);

            if (v203)
            {
              v205 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v204);
              v206 = [(id)v4 copyDescription];
              _NRLogWithArgs( v205,  1LL,  "%s%.30s:%-4d %@: Starting LtN since received prelude, about to async",  "",  "-[NRLinkBluetooth handleReadData:]",  6692LL,  v206);
            }

            v207 = *(dispatch_queue_s **)(v4 + 8);
            v283[0] = _NSConcreteStackBlock;
            v283[1] = 3221225472LL;
            v283[2] = sub_1000902A0;
            v283[3] = &unk_1001B0A88;
            v283[4] = v4;
            dispatch_async(v207, v283);
          }
        }

        else
        {
          [(id)v4 changeStateTo:4];
          [(id)v4 cancelWithReason:@"failed to setup nexus"];
        }
}
}

    sub_1000FE6B8((uint64_t)&OBJC_CLASS___NRDevicePairingDirector, -2005LL, v6, v7[1]);
    goto LABEL_17;
  }

  id v10 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v9);
  if (!v10)
  {
    id v27 = sub_1000FBEC0();
    uint64_t v28 = _NRLogIsLevelEnabled(v27, 16LL);

    id v13 = "-[NRDevicePairingDirector handleUnpairRequest:forConnection:]";
    if (v28)
    {
      uint64_t v29 = sub_1000FBEC0();
      _NRLogWithArgs( v29,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "-[NRDevicePairingDirector handleUnpairRequest:forConnection:]",  2978);
    }

    BOOL v6 = (id)_os_log_pack_size(12LL);
    int v7 = (void **)((char *)v33 - ((__chkstk_darwin(v6) + 15) & 0xFFFFFFFFFFFFFFF0LL));
    id v30 = __error();
    uint64_t v31 = _os_log_pack_fill( v7,  v6,  *v30,  &_mh_execute_header,  "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    *(_DWORD *)uint64_t v31 = 136446210;
    *(void *)(v31 + 4) = "-[NRDevicePairingDirector handleUnpairRequest:forConnection:]";
    objc_super v32 = sub_1000FBEC0();
    _NRLogAbortWithPack(v32, v7);
    goto LABEL_23;
  }

  uint64_t v11 = v10;
  id v3 = _NSConcreteStackBlock;
  v33[0] = _NSConcreteStackBlock;
  uint64_t v4 = 3221225472LL;
  v33[1] = 3221225472LL;
  id v34 = sub_1000FEF60;
  id v35 = &unk_1001AF9F0;
  uint64_t v36 = v10;
  int v37 = v6;
  id v38 = v7;
  uint64_t v12 = v11;
  id v2 = v33;
  id v13 = v12;
  objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
LABEL_23:
  }
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  uint64_t v14 = (id)qword_1001DC870;
  uint64_t v15 = v13;
  id v16 = v2;
  id v17 = v16;
  if (v14)
  {
    id v18 = v14[5];
    if (v18)
    {
      v39[0] = v3;
      v39[1] = v4;
      v39[2] = sub_1000AED0C;
      v39[3] = &unk_1001AEF48;
      uint64_t v19 = v15;
      unsigned int v40 = v19;
      id v41 = v17;
      id v20 = v39;
      id v21 = v19;
      int v22 = -[NRBluetoothPairer initWithNRUUID:](objc_alloc(&OBJC_CLASS___NRBluetoothPairer), "initWithNRUUID:", v21);

      id v23 = *(id *)(v18 + 24);
      -[NRBluetoothPairer unpairWithCompletionQueue:completionBlock:]( v22,  "unpairWithCompletionQueue:completionBlock:",  v23,  v20);
    }

    else
    {
      v34((void **)v16, 22LL, @"Already unpaired or bluetooth device not found");
    }
  }

LABEL_17:
}
        }

        id v39 = [obj countByEnumeratingWithState:&v44 objects:v49 count:16];
      }

      while (v39);
    }

    id v3 = v36;
  }
}
}

LABEL_110:
              sub_10000D61C((id *)&v136->super.isa, v21, v131, v133, v132, v134, v84);
LABEL_111:

              id v16 = v131;
              id v18 = v132;
              id v17 = v133;
              goto LABEL_12;
            }
          }

          else
          {
            uint64_t v98 = sub_10000D3A0();
            int v99 = _NRLogIsLevelEnabled(v98, 1LL);

            if (v99)
            {
              id v100 = sub_10000D3A0();
              _NRLogWithArgs( v100,  1LL,  "%s%.30s:%-4d %@: Device not enabled, rejecting %@",  "",  "-[NRIKEv2Listener requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  711LL,  v136,  v81);
            }
          }
        }

        else
        {
          sub_10000D3E0((uint64_t)v136, 3022, v70, v71, v72, v73, v74, v75, (uint64_t)v21);
        }

        id v16 = v131;
        id v18 = v132;
        id v17 = v133;
LABEL_11:
        (*((void (**)(id, void, void, void))v20 + 2))(v20, 0LL, 0LL, 0LL);
        goto LABEL_12;
      }

      uint64_t v125 = sub_10000D3A0();
      uint64_t v126 = _NRLogIsLevelEnabled(v125, 16LL);

      if (v126)
      {
        __int128 v124 = sub_10000D3A0();
        v127 = v63->_identity;
        _NRLogWithArgs( v124,  16LL,  "%s%.30s:%-4d %@: No device found for identity %@",  "",  "-[NRIKEv2Listener requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  685LL,  v136,  v127);

        goto LABEL_130;
      }
    }

    else
    {
      v117 = _NRLogIsLevelEnabled(v64, 16LL);

      if (v117)
      {
        __int128 v124 = sub_10000D3A0();
        _NRLogWithArgs( v124,  16LL,  "%s%.30s:%-4d %@: Failed to decrypt device identity",  "",  "-[NRIKEv2Listener requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  677LL,  v136);
LABEL_130:
      }
    }

    sub_10000D3E0((uint64_t)v136, 3023, v118, v119, v120, v121, v122, v123, (uint64_t)v21);

    goto LABEL_113;
  }

  v130 = v16;
  uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v15 localEndpoint]);
  v146 = 0u;
  v147 = 0u;
  v148 = 0u;
  v149 = 0u;
  objc_super v32 = v136;
  id v33 = v136->_pairingClients;
  id v34 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v33,  "countByEnumeratingWithState:objects:count:",  &v146,  v151,  16LL);
  if (!v34)
  {

LABEL_113:
    id v18 = v132;
    id v17 = v133;
    id v20 = v134;
    goto LABEL_11;
  }

  id v35 = v34;
  v135 = v31;
  v129 = v14;
  v128 = 0;
  uint64_t v36 = *(void *)v147;
  int v37 = v33;
  do
  {
    id v38 = 0LL;
    v137 = v35;
    do
    {
      if (*(void *)v147 != v36) {
        objc_enumerationMutation(v37);
      }
      id v39 = objc_claimAutoreleasedReturnValue( -[NSMutableDictionary objectForKeyedSubscript:]( v32->_pairingClients,  "objectForKeyedSubscript:",  *(void *)(*((void *)&v146 + 1) + 8LL * (void)v38)));
      unsigned int v40 = (id *)v39;
      if (v39 && *(void *)(v39 + 32))
      {
        id v41 = *(id *)(v39 + 8);
        int v42 = (void *)objc_claimAutoreleasedReturnValue([v21 ikeInterfaceName]);
        if ([v41 isEqualToString:v42])
        {
          int v43 = v36;
          id v44 = v37;
          int v45 = (void *)objc_claimAutoreleasedReturnValue([v40[2] hostname]);
          id v46 = v21;
          dispatch_time_t v47 = (void *)objc_claimAutoreleasedReturnValue([v135 hostname]);
          uint64_t v48 = [v45 isEqualToString:v47];

          id v21 = v46;
          objc_super v32 = v136;

          int v37 = v44;
          uint64_t v36 = v43;
          id v35 = v137;

          if (v48)
          {
            [v40[4] requestConfigurationForListener:v129 session:v21 sessionConfig:v130 childConfig:v133 validateAuthBlock:v132 responseBlock:v134];
            v128 = 1;
          }
        }

        else
        {
        }
      }

      id v38 = (char *)v38 + 1;
    }

    while (v35 != v38);
    id v35 = -[NSMutableDictionary countByEnumeratingWithState:objects:count:]( v37,  "countByEnumeratingWithState:objects:count:",  &v146,  v151,  16LL);
  }

  while (v35);

  uint64_t v14 = v129;
  id v16 = v130;
  id v18 = v132;
  id v17 = v133;
  id v20 = v134;
  if ((v128 & 1) == 0) {
    goto LABEL_11;
  }
LABEL_12:
}

            -[NRAnalyticsDataStall submit](v42, "submit");
            goto LABEL_111;
          }
        }
      }

      int v55 = *(void *)(v41 + 1855) + 1LL;
      *(void *)(v41 + 1855) = v55;
      if ((unint64_t)(15 * v55) < 0xB4)
      {
        id v46 = 0;
        if ((v45 & 1) != 0) {
          goto LABEL_110;
        }
        goto LABEL_109;
      }

      if (sub_100097734(v41))
      {
        id v46 = 1;
        if (v42) {
          v42->_remediatedDataStall = 1;
        }
        goto LABEL_105;
      }
}

id sub_10000D3A0()
{
  if (qword_1001DC650 != -1) {
    dispatch_once(&qword_1001DC650, &stru_1001ADF08);
  }
  return (id)qword_1001DC648;
}

void sub_10000D3E0( uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1)
  {
    id v10 = @"%@";
    uint64_t v11 = -[NSString initWithFormat:arguments:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:arguments:",  @"%@",  &a9);

    uint64_t v12 = v11;
    id v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"NRIKEv2Listener[%@]",  @"62743");
    sub_10011BB18(0LL, a2, v13, v12);
  }

NSString *sub_10000D498(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = v9;
  if (!a1) {
    goto LABEL_16;
  }
  if (v7)
  {
    if (v8)
    {
      if (v9)
      {
        uint64_t v11 = (nw_endpoint *)[v8 copyCEndpoint];
        uint64_t v12 = nw_endpoint_copy_address_string(v11);
        id v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s/%@/%@",  v12,  v7,  v10);
        if (v12) {
          free(v12);
        }
        goto LABEL_7;
      }

      id v19 = sub_10000D3A0();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v19, 17LL);

      if (IsLevelEnabled)
      {
        uint64_t v11 = (nw_endpoint *)sub_10000D3A0();
        _NRLogWithArgs(v11, 17LL, "%s called with null nrUUID");
        goto LABEL_15;
      }

LABEL_16:
      id v13 = 0LL;
      goto LABEL_8;
    }

    id v17 = sub_10000D3A0();
    int v18 = _NRLogIsLevelEnabled(v17, 17LL);

    if (!v18) {
      goto LABEL_16;
    }
    uint64_t v11 = (nw_endpoint *)sub_10000D3A0();
    _NRLogWithArgs(v11, 17LL, "%s called with null localEndpoint");
  }

  else
  {
    id v15 = sub_10000D3A0();
    int v16 = _NRLogIsLevelEnabled(v15, 17LL);

    if (!v16) {
      goto LABEL_16;
    }
    uint64_t v11 = (nw_endpoint *)sub_10000D3A0();
    _NRLogWithArgs(v11, 17LL, "%s called with null interfaceName");
  }
}

      -[NSMutableString appendFormat:](v13, "appendFormat:", @"ClassAVerified | ");
      if ((v10 & 0x10) == 0)
      {
LABEL_10:
        if (a3)
        {
LABEL_11:
          if (a3 > 8) {
            uint64_t v14 = @"None";
          }
          else {
            uint64_t v14 = *(&off_1001ADE20 + (a3 - 1));
          }
          [v20 cancelWithReason:@"pairing client error: %@ mask: %@", v14, v13];
LABEL_27:

LABEL_28:
          id v7 = v20;
          goto LABEL_29;
        }

    int v16 = 0LL;
    goto LABEL_6;
  }

  v32.receiver = a1;
  v32.super_class = (Class)&OBJC_CLASS___TXSContext;
  id v8 = objc_msgSendSuper2(&v32, "init");
  if (!v8)
  {
    id v21 = sub_10004579C();
    int v22 = _NRLogIsLevelEnabled(v21, 16LL);

    a1 = "-[TXSContext initWithRequest:onConnection:]";
    if (v22)
    {
      id v23 = sub_10004579C();
      _NRLogWithArgs( v23,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[TXSContext initWithRequest:onConnection:]",  127);
    }

    uint64_t v5 = (id)_os_log_pack_size(12LL);
    id v7 = (char *)&v31 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v24 = *__error();
    id v25 = _os_log_pack_fill(v7, v5, v24, &_mh_execute_header, "%{public}s [super init] failed");
    goto LABEL_15;
  }

  id v10 = v8;
  objc_setProperty_atomic(v8, v9, v7, 8LL);
  objc_setProperty_atomic(v10, v11, v5, 16LL);
  uint64_t v12 = v5;
  reply = xpc_dictionary_create_reply(v12);
  if (!reply)
  {
    int v26 = sub_10004579C();
    id v27 = _NRLogIsLevelEnabled(v26, 16LL);

    a1 = "nr_xpc_dictionary_create_reply";
    if (v27)
    {
      uint64_t v28 = sub_10004579C();
      _NRLogWithArgs( v28,  16LL,  "%s%.30s:%-4d ABORTING: xpc_dictionary_create_reply failed",  "",  "nr_xpc_dictionary_create_reply",  92);
    }

    uint64_t v5 = (id)_os_log_pack_size(12LL);
    id v7 = (char *)&v31 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v29 = *__error();
    id v25 = _os_log_pack_fill(v7, v5, v29, &_mh_execute_header, "%{public}s xpc_dictionary_create_reply failed");
LABEL_15:
    *(_DWORD *)id v25 = 136446210;
    *(void *)(v25 + 4) = a1;
    id v30 = sub_10004579C();
    _NRLogAbortWithPack(v30, v7);
    goto LABEL_16;
  }

  uint64_t v14 = reply;

  objc_setProperty_atomic(v10, v15, v14, 24LL);
  a1 = v10;
  int v16 = a1;
LABEL_6:

  return v16;
}

    -[NSMutableArray removeObject:](v0, "removeObject:", v6);
    goto LABEL_17;
  }

    -[NRPendingOutgoingSeqnoReq cancelWithDelay:](self, "cancelWithDelay:", 0LL);
    uint64_t v5 = 1;
    goto LABEL_17;
  }

  uint64_t v5 = 0;
LABEL_17:

  return v5;
}

    int v24 = 0LL;
    goto LABEL_7;
  }

  dispatch_assert_queue_V2(v6);
  if (!v7)
  {
    uint64_t v29 = sub_1000C58FC();
    id v30 = _NRLogIsLevelEnabled(v29, 17LL);

    if (v30)
    {
      uint64_t v28 = sub_1000C58FC();
      _NRLogWithArgs(v28, 17LL, "%s called with null managerDelegate");
      goto LABEL_12;
    }

    goto LABEL_16;
  }

  v34.receiver = self;
  v34.super_class = (Class)&OBJC_CLASS___NRLinkManagerWired;
  id v8 = -[NRLinkManager initManagerWithQueue:managerDelegate:](&v34, "initManagerWithQueue:managerDelegate:", v6, v7);
  if (!v8)
  {
    uint64_t v31 = sub_1000C58FC();
    objc_super v32 = _NRLogIsLevelEnabled(v31, 17LL);

    if (v32)
    {
      id v33 = sub_1000C58FC();
      _NRLogWithArgs(v33, 17LL, "[NRLinkManager initManagerWithQueue:] failed");
    }

    self = 0LL;
    goto LABEL_16;
  }

  id v9 = (uint64_t)v8;
  v8[8] = 5;
  id v10 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
  uint64_t v11 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v10;

  uint64_t v12 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
  id v13 = *(void **)(v9 + 48);
  *(void *)(v9 + 4_Block_object_dispose((const void *)(v1 - 120), 8) = v12;

  uint64_t v14 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v15 = *(void **)(v9 + 80);
  *(void *)(v9 + 80) = v14;

  int v16 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v17 = *(void **)(v9 + 88);
  *(void *)(v9 + 8_Block_object_dispose((const void *)(v1 - 120), 8) = v16;

  int v18 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v19 = *(void **)(v9 + 64);
  *(void *)(v9 + 64) = v18;

  id v20 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v21 = *(void **)(v9 + 72);
  *(void *)(v9 + 72) = v20;

  [(id)v9 reportEvent:2001];
  int v22 = (dispatch_queue_s *)*(id *)(v9 + 24);
  dispatch_assert_queue_V2(v22);

  if (*(_DWORD *)(v9 + 12) != 1003)
  {
    id v23 = (dispatch_queue_s *)*(id *)(v9 + 24);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_1000C8214;
    block[3] = &unk_1001B0A88;
    void block[4] = v9;
    dispatch_async(v23, block);

    sub_1000C829C(v9);
  }

  *(_DWORD *)(v9 + 12) = 1003;
  [(id)v9 reportEvent:2002];
  self = (NRLinkManagerWired *)(id)v9;
  int v24 = self;
LABEL_7:

  return v24;
}

    uint64_t v11 = 1;
    goto LABEL_4;
  }
}
}

    uint64_t v11 = 0LL;
    goto LABEL_17;
  }

  if (![v5 length])
  {
    id v19 = sub_100100C84();
    id v20 = _NRLogIsLevelEnabled(v19, 17LL);

    if (v20)
    {
      int v18 = sub_100100C84();
      _NRLogWithArgs(v18, 17LL, "%s called with null filePath.length");
      goto LABEL_32;
    }

    goto LABEL_16;
  }

  if (([v5 containsString:@".."] & 1) != 0
    || ([v5 hasPrefix:@"/"] & 1) == 0)
  {
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      _NRLogWithArgs(qword_1001DCA50, 17LL, "Refusing to write to %@", v5);
    }

    goto LABEL_16;
  }

  id v7 = (const char *)[v5 UTF8String];
  if (a3) {
    id v8 = 1793;
  }
  else {
    id v8 = 2817;
  }
  id v9 = open_dprotected_np(v7, v8, 4, 0, 384LL);
  if (v9 < 0)
  {
    id v13 = __error();
    uint64_t v14 = *v13;
    if (strerror_r(*v13, __strerrbuf, 0x80uLL)) {
      __strerrbuf[0] = 0;
    }
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      id v15 = "create";
      if (a3) {
        id v15 = "trunc";
      }
      _NRLogWithArgs(qword_1001DCA50, 17LL, "Failed to open %s %@: [%d] %s", v15, v5, v14, __strerrbuf);
    }

    goto LABEL_16;
  }

  id v10 = v9;
  uint64_t v11 = sub_100100CC4(v9, v5, v6);
  close(v10);
LABEL_17:

  return v11;
}

    id v15 = 0LL;
    goto LABEL_17;
  }

  uint64_t v4 = *(void **)(a1 + 192);
  if (!v4)
  {
    id v19 = sub_10010F4BC();
    id v20 = _NRLogIsLevelEnabled(v19, 17LL);

    if (v20)
    {
      int v18 = sub_10010F4BC();
      _NRLogWithArgs(v18, 17LL, "%s called with null self.rpSelfIdentity");
      goto LABEL_15;
    }

    goto LABEL_16;
  }

  uint64_t v5 = *(void **)(a1 + 192);
  int v22 = 0LL;
  BOOL v6 = v5;
  id v7 = (void *)objc_claimAutoreleasedReturnValue([v6 signData:v3 error:&v22]);
  id v8 = v22;

  if (v8)
  {
    id v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v9);
    uint64_t v11 = _NRLogIsLevelEnabled(v10, 17LL);

    if (v11)
    {
      uint64_t v12 = *(id *)(a1 + 24);
      uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(v12, v13);
      _NRLogWithArgs(v14, 17LL, "signing failed with error %@", v8);
    }

    id v15 = 0LL;
  }

  else
  {
    id v15 = v7;
  }

LABEL_17:
  return v15;
}

    id v13 = 0LL;
    goto LABEL_9;
  }

  v25.receiver = a1;
  v25.super_class = (Class)&OBJC_CLASS___NRDLDKeychainItemData;
  id v9 = (id *)objc_msgSendSuper2(&v25, "init");
  if (!v9)
  {
    int v18 = sub_100121F34();
    id v19 = _NRLogIsLevelEnabled(v18, 16LL);

    id v8 = "-[NRDLDKeychainItemData initFromKeychainWithName:nrUUID:dataProtectionClass:]";
    if (v19)
    {
      id v20 = sub_100121F34();
      _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDLDKeychainItemData initFromKeychainWithName:nrUUID:dataProtectionClass:]",  159);
    }

    id v7 = (id)_os_log_pack_size(12LL);
    a1 = (id *)((char *)&v24 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL));
    id v21 = __error();
    int v22 = _os_log_pack_fill(a1, v7, *v21, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)int v22 = 136446210;
    *(void *)(v22 + 4) = "-[NRDLDKeychainItemData initFromKeychainWithName:nrUUID:dataProtectionClass:]";
    id v23 = sub_100121F34();
    _NRLogAbortWithPack(v23, a1);
    goto LABEL_15;
  }

  a1 = v9;
  objc_opt_self(&OBJC_CLASS___NRDKeyManager);
  if (qword_1001DCC18 != -1) {
LABEL_15:
  }
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  id v10 = (id)qword_1001DCC10;
  uint64_t v11 = sub_100145CF4((uint64_t)v10, v7, v8, a4);
  uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(v11);

  if (v12)
  {
    objc_storeStrong(a1 + 2, v12);
    id v13 = a1;
  }

  else
  {
    id v13 = 0LL;
  }

LABEL_9:
  return v13;
}

LABEL_15:
  id v13 = 0LL;
LABEL_7:

LABEL_8:
  return v13;
}

      BOOL v6 = self;
      id v7 = 4;
      goto LABEL_16;
    }

    if (!self->super._serverCertificateData)
    {
      if (qword_1001DC6C8 != -1) {
        dispatch_once(&qword_1001DC6C8, &stru_1001AE3E0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC6C0, 17LL))
      {
        if (qword_1001DC6C8 != -1) {
          dispatch_once(&qword_1001DC6C8, &stru_1001AE3E0);
        }
        _NRLogWithArgs(qword_1001DC6C0, 17LL, "no server certificate failed");
      }

      goto LABEL_15;
    }

    id v9 = (void *)mrc_discovery_proxy_parameters_create(v3);
    if (v9)
    {
      id v10 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v8);
      uint64_t v11 = _NRLogIsLevelEnabled(v10, 0LL);

      if (v11)
      {
        uint64_t v12 = self->super._nrUUID;
        uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(v12, v13);
        _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d setting discovery proxy address %@",  "",  "-[NRDNSProxyClient startDiscoveryProxyClient]",  197LL,  self->super._serverEndpoint);
      }

      id v15 = -[NWAddressEndpoint addressFamily](self->super._serverEndpoint, "addressFamily");
      serverEndpoint = self->super._serverEndpoint;
      if (v15 == (id)2)
      {
        id v17 = -[NWAddressEndpoint address](serverEndpoint, "address");
        mrc_discovery_proxy_parameters_add_server_ipv4_address( v9,  bswap32(v17[1]),  bswap32(*((unsigned __int16 *)v17 + 1)) >> 16);
      }

      else if (-[NWAddressEndpoint addressFamily](serverEndpoint, "addressFamily") == (id)30)
      {
        int v24 = (char *)-[NWAddressEndpoint address](self->super._serverEndpoint, "address");
        mrc_discovery_proxy_parameters_add_server_ipv6_address( v9,  v24 + 8,  bswap32(*((unsigned __int16 *)v24 + 1)) >> 16,  *((unsigned int *)v24 + 6));
      }

      mrc_discovery_proxy_parameters_add_match_domain(v9, "local");
      id v25 = self->super._serverCertificateData;
      mrc_discovery_proxy_parameters_add_server_certificate( v9,  -[NSData bytes](v25, "bytes"),  -[NSData length](v25, "length"));
      mrc_discovery_proxy_parameters_set_interface(v9, self->_discoveryProxyInterfaceIndex);
      id v27 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v26);
      uint64_t v28 = _NRLogIsLevelEnabled(v27, 0LL);

      if (v28)
      {
        id v30 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v29);
        _NRLogWithArgs( v30,  0LL,  "%s%.30s:%-4d setting interface index %u",  "",  "-[NRDNSProxyClient startDiscoveryProxyClient]",  211,  self->_discoveryProxyInterfaceIndex);
      }

      uint64_t v31 = mrc_discovery_proxy_create(v9);
      objc_super v32 = (void *)v31;
      if (v31)
      {
        mrc_discovery_proxy_set_queue(v31, self->super._queue);
        objc_initWeak(&location, self);
        uint64_t v48 = _NSConcreteStackBlock;
        uint64_t v49 = 3221225472LL;
        id v50 = sub_10001B698;
        uint64_t v51 = &unk_1001AE348;
        objc_copyWeak(&v53, &location);
        id v33 = v32;
        id v52 = v33;
        mrc_discovery_proxy_set_event_handler();
        mrc_discovery_proxy_activate(v33);
        id v34 = self->super._nrUUID;
        uint64_t v36 = (void *)_NRCopyLogObjectForNRUUID(v34, v35);
        int v37 = _NRLogIsLevelEnabled(v36, 0LL);

        if ((v37 & 1) != 0)
        {
          id v38 = self->super._nrUUID;
          unsigned int v40 = (void *)_NRCopyLogObjectForNRUUID(v38, v39);
          _NRLogWithArgs( v40,  0LL,  "%s%.30s:%-4d discovery proxy client activated",  "",  "-[NRDNSProxyClient startDiscoveryProxyClient]",  255);
        }

        objc_storeStrong((id *)&self->_discoveryProxyClient, v32);
        sub_10001B5C8(self, 1);

        objc_destroyWeak(&v53);
        objc_destroyWeak(&location);
      }

      else
      {
        id v44 = sub_10001AE98();
        int v45 = _NRLogIsLevelEnabled(v44, 17LL);

        if (v45)
        {
          id v46 = sub_10001AE98();
          _NRLogWithArgs(v46, 17LL, "mrc_discovery_proxy_create failed");
        }

        sub_10001B5C8(self, 4);
      }
    }

    else
    {
      id v41 = sub_10001AE98();
      int v42 = _NRLogIsLevelEnabled(v41, 17LL);

      if (v42)
      {
        int v43 = sub_10001AE98();
        _NRLogWithArgs(v43, 17LL, "mrc_discovery_proxy_parameters_create failed");
      }

      sub_10001B5C8(self, 4);
    }
  }
}

      sub_100033FFC((uint64_t)WeakRetained);
    }
  }

      -[NSMutableString appendFormat:](v13, "appendFormat:", @"ClassCVerified | ");
      if ((v10 & 8) == 0)
      {
LABEL_9:
        if ((v10 & 0x10) == 0) {
          goto LABEL_10;
        }
        goto LABEL_17;
      }
}
}
  }
}
}
}
}
}
}

                        id v19 = v132;
                      }

                      else
                      {
                        id v67 = sub_1000F4464();
                        int IsLevelEnabled = _NRLogIsLevelEnabled(v67, 17LL);

                        id v19 = v132;
                        if (IsLevelEnabled)
                        {
                          id v35 = sub_1000F4464();
                          _NRLogWithArgs( v35,  17LL,  "%s called with null endpoint",  "-[NRApplicationServiceManager reportBrowseResultAddedForASName:endpoint:]");
                          goto LABEL_15;
                        }
                      }
                    }

                    id v13 = v129;
                  }

                  id v15 = v134;
LABEL_18:

                  goto LABEL_19;
                }

                if (v31 && !*(_BYTE *)(v31 + 9))
                {
                  objc_opt_self(&OBJC_CLASS___NRApplicationServiceManager);
                  if (qword_1001DC930 != -1) {
                    dispatch_once(&qword_1001DC930, &stru_1001AF7E0);
                  }
                  id v46 = qword_1001DC928;
                  v133 = v19;
                  dispatch_time_t v47 = v19;
                  uint64_t v48 = v17;
                  uint64_t v49 = v48;
                  if (v46)
                  {
                    if (v48)
                    {
                      dispatch_assert_queue_V2(*(dispatch_queue_t *)(v46 + 8));
                      id v50 = (id)objc_claimAutoreleasedReturnValue([*(id *)(v46 + 32) objectForKeyedSubscript:v47]);
                      if ([v50 count])
                      {
                        v128 = v47;
                        v131 = v17;
                        v152 = 0u;
                        v153 = 0u;
                        v150 = 0u;
                        v151 = 0u;
                        id v50 = v50;
                        uint64_t v51 = [v50 countByEnumeratingWithState:&v150 objects:v158 count:16];
                        if (v51)
                        {
                          id v52 = v51;
                          int v53 = *(void *)v151;
                          do
                          {
                            for (j = 0LL; j != v52; j = (char *)j + 1)
                            {
                              if (*(void *)v151 != v53) {
                                objc_enumerationMutation(v50);
                              }
                              int v55 = *(void *)(*((void *)&v150 + 1) + 8LL * (void)j);
                              if (v55)
                              {
                                id v56 = *(void *)(v55 + 56);
                                if (v56)
                                {
                                  nw_array_remove_object(v56, v49);
                                  id v57 = (void (**)(id, void))*(id *)(v55 + 48);
                                  v57[2](v57, *(void *)(v55 + 56));
                                }
                              }
                            }

                            id v52 = [v50 countByEnumeratingWithState:&v150 objects:v158 count:16];
                          }

                          while (v52);
                        }

                        uint64_t v5 = v135;
                        id v17 = v131;
                        dispatch_time_t v47 = v128;
                      }

        id v13 = 0LL;
        goto LABEL_16;
      }

      id v7 = objc_opt_class(&OBJC_CLASS___NRASMResolveRequest);
      if ((objc_opt_isKindOfClass(a1, v7) & 1) != 0)
      {
        id v8 = nw_agent_client_copy_endpoint(*(void *)(a1 + 40));
        if (!v8) {
          goto LABEL_15;
        }
        uint64_t v5 = (void *)v8;
        application_service_name = (const char *)nw_endpoint_get_application_service_name(v8);
      }

      else
      {
        id v9 = objc_opt_class(&OBJC_CLASS___NRASMListenRequest);
        if ((objc_opt_isKindOfClass(a1, v9) & 1) == 0) {
          goto LABEL_17;
        }
        id v10 = (nw_advertise_descriptor *)nw_agent_client_copy_advertise_descriptor(*(void *)(a1 + 40));
        if (!v10) {
          goto LABEL_15;
        }
        uint64_t v5 = v10;
        application_service_name = nw_advertise_descriptor_get_application_service_name(v10);
      }

    id v3 = v12;
  }
}
}
}
}
}

    uint64_t v11 = 0LL;
    goto LABEL_79;
  }

  if (a2)
  {
    id v8 = *a2;
    *a2 = 0LL;
  }

  if (a3)
  {
    id v9 = *a3;
    *a3 = 0LL;
  }

  id v10 = v35;
  if (v35)
  {
    uint64_t v11 = 0LL;
    while (1)
    {
      if (v10->ifa_addr && v10->ifa_name && !strcmp((const char *)[v7 UTF8String], v10->ifa_name))
      {
        if (!a3 && !a2 && !v11) {
          uint64_t v11 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
        }
        ifa_addr = v10->ifa_addr;
        sa_family = ifa_addr->sa_family;
        if (sa_family != 30)
        {
          if (sa_family != 2) {
            goto LABEL_30;
          }
          id v23 = *(_DWORD *)&ifa_addr->sa_data[2];
          id v21 = &ifa_addr->sa_data[2];
          int v22 = v23;
          if (a4)
          {
            uint64_t v12 = bswap32(v22);
            id v13 = v12 & 0xFF000000;
            uint64_t v14 = HIWORD(v12) == 43518 || v13 == 0;
            id v15 = v14 || v13 == 2130706432;
            int v16 = v12 & 0xF0000000;
            id v17 = v15 || v22 == -1;
            if (v17 || v16 == -536870912) {
              goto LABEL_30;
            }
          }

          if (!inet_ntop(2, v21, v36, 0x10u))
          {
            if (qword_1001DCA58 != -1) {
              dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
            }
            if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
            {
              if (qword_1001DCA58 != -1) {
                dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
              }
              _NRLogWithArgs(qword_1001DCA50, 17LL, "inet_ntop(AF_INET, %s) failed");
            }

            goto LABEL_30;
          }

          int v24 = -[NSString initWithFormat:](objc_alloc(&OBJC_CLASS___NSString), "initWithFormat:", @"%s", v36);
          if (a2)
          {
            id v25 = *a2;
            if (!*a2)
            {
              int v26 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
              id v27 = *a2;
              *a2 = v26;

              id v25 = *a2;
            }

            goto LABEL_63;
          }

          goto LABEL_64;
        }

        if (!a4) {
          goto LABEL_59;
        }
        if (*(_DWORD *)&ifa_addr->sa_data[6])
        {
          if (*(_DWORD *)&ifa_addr->sa_data[6] != 255
            && (*(_DWORD *)&ifa_addr->sa_data[6] != 254
             || (*(_DWORD *)&ifa_addr->sa_data[6] & 0xC000) != 0x8000))
          {
            goto LABEL_59;
          }
        }

        else if (*(_DWORD *)&ifa_addr->sa_data[10] {
               || *(_DWORD *)&ifa_addr[1].sa_len
        }
               || (*(_DWORD *)&ifa_addr[1].sa_data[2] | 0x1000000) != 0x1000000)
        {
LABEL_59:
          if (!inet_ntop(30, &ifa_addr->sa_data[6], v36, 0x2Eu))
          {
            if (qword_1001DCA58 != -1) {
              dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
            }
            if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
            {
              if (qword_1001DCA58 != -1) {
                dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
              }
              _NRLogWithArgs(qword_1001DCA50, 17LL, "inet_ntop(AF_INET6, %s) failed");
            }

            goto LABEL_30;
          }

          int v24 = -[NSString initWithFormat:](objc_alloc(&OBJC_CLASS___NSString), "initWithFormat:", @"%s", v36);
          if (a3)
          {
            id v25 = *a3;
            if (!*a3)
            {
              uint64_t v28 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
              uint64_t v29 = *a3;
              *a3 = v28;

              id v25 = *a3;
            }

  return v9;
}
}

    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    id v19 = (id)qword_1001DCC20;
    id v20 = _NRLogIsLevelEnabled(v19, 17LL);

    if (v20)
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      id v21 = (id)qword_1001DCC20;
      _NRLogWithArgs(v21, 17LL, "Cannot save key %@ to keychain for %@", v11, String);
    }

    id v41 = 0;
LABEL_73:

    if (v41)
    {
      *(_BYTE *)(a1 + _Block_object_dispose((const void *)(v1 - 120), 8) = 0;
      goto LABEL_75;
    }

  return v9;
}

    if (qword_1001DCBF8 != -1) {
      dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCBF0, 17LL))
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      _NRLogWithArgs(qword_1001DCBF0, 17LL, "Could not get Wi-Fi endpoint");
    }

    uint64_t v14 = (dispatch_queue_s *)*(id *)(a1 + 24);
    dispatch_assert_queue_V2(v14);

    id v15 = *(void **)(a1 + 56);
    *(void *)(a1 + 56) = 0LL;

    int v16 = *(void **)(a1 + 80);
    *(void *)(a1 + 80) = 0LL;

    [(id)a1 reportEvent:11003 details:@"<nil>"];
    id v13 = 0LL;
    goto LABEL_44;
  }

void sub_10000D61C(id *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7)
{
  id v14 = a2;
  id v15 = a3;
  id v16 = a4;
  id v17 = a5;
  id v18 = a6;
  id v19 = a7;
  if (a1)
  {
    id v46 = v16;
    if (!a1[6])
    {
      id v20 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      id v21 = a1[6];
      a1[6] = v20;
    }

    int v22 = objc_alloc_init(&OBJC_CLASS___NRIKEv2PendingSession);
    id v23 = v22;
    if (v22)
    {
      objc_storeStrong((id *)&v22->_session, a2);
      objc_storeStrong((id *)&v23->_sessionConfig, a3);
      objc_storeStrong((id *)&v23->_childConfig, a4);
      objc_setProperty_nonatomic_copy(v23, v24, v17, 32LL);
      objc_setProperty_nonatomic_copy(v23, v25, v18, 40LL);
      v23->_sessionReceivedTimestamp = mach_continuous_time();
    }

    else
    {
      mach_continuous_time();
    }

    objc_initWeak(&location, v14);
    id v26 = a1[1];
    [v14 setClientQueue:v26];

    v47[0] = _NSConcreteStackBlock;
    v47[1] = 3221225472LL;
    v47[2] = sub_10000DB60;
    v47[3] = &unk_1001ADEC0;
    objc_copyWeak(&v49, &location);
    v47[4] = a1;
    id v45 = v19;
    id v27 = v19;
    id v48 = v27;
    [v14 setStateUpdateBlock:v47];
    id v44 = v15;
    id v28 = a1[6];
    uint64_t v29 = (id *)objc_claimAutoreleasedReturnValue([v28 objectForKeyedSubscript:v27]);

    if (v29)
    {
      id v30 = v29[5];
      (*((void (**)(id, void, void, void))v30 + 2))(v30, 0LL, 0LL, 0LL);
    }

    if (qword_1001DC650 != -1) {
      dispatch_once(&qword_1001DC650, &stru_1001ADF08);
    }
    id v31 = (id)qword_1001DC648;
    int IsLevelEnabled = _NRLogIsLevelEnabled(v31, 1LL);

    if (IsLevelEnabled)
    {
      if (qword_1001DC650 != -1) {
        dispatch_once(&qword_1001DC650, &stru_1001ADF08);
      }
      id v33 = (id)qword_1001DC648;
      if (v23) {
        session = v23->_session;
      }
      else {
        session = 0LL;
      }
      id v35 = session;
      _NRLogWithArgs( v33,  1LL,  "%s%.30s:%-4d adding pending session: %@",  "",  "-[NRIKEv2Listener addPendingSession:sessionConfig:childConfig:validateAuthBlock:responseBlock:key:]",  533LL,  v35);
    }

    id v36 = a1[6];
    [v36 setObject:v23 forKeyedSubscript:v27];

    int v37 = a1 + 7;
    if (!a1[7])
    {
      id v38 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  (dispatch_queue_t)a1[1]);
      dispatch_time_t v39 = dispatch_time(0x8000000000000000LL, 10000000000LL);
      dispatch_source_set_timer(v38, v39, 0x2540BE400uLL, 0x3A35294400uLL);
      objc_initWeak(from, a1);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 3221225472LL;
      handler[2] = sub_10000DCAC;
      handler[3] = &unk_1001AED98;
      objc_copyWeak(v53, from);
      unsigned int v40 = v38;
      id v52 = v40;
      v53[1] = (id)0x4024000000000000LL;
      dispatch_source_set_event_handler(v40, handler);
      dispatch_activate(v40);
      objc_storeStrong(v37, v38);
      if (qword_1001DC650 != -1) {
        dispatch_once(&qword_1001DC650, &stru_1001ADF08);
      }
      id v41 = (id)qword_1001DC648;
      char v42 = _NRLogIsLevelEnabled(v41, 0LL);

      if ((v42 & 1) != 0)
      {
        if (qword_1001DC650 != -1) {
          dispatch_once(&qword_1001DC650, &stru_1001ADF08);
        }
        id v43 = (id)qword_1001DC648;
        _NRLogWithArgs( v43,  0LL,  "%s%.30s:%-4d starting pending session monitoring source",  "",  "-[NRIKEv2Listener armPendingSessionCleanupTimer]",  582);
      }

      objc_destroyWeak(v53);
      objc_destroyWeak(from);
    }

    objc_destroyWeak(&v49);
    objc_destroyWeak(&location);

    id v15 = v44;
    id v19 = v45;
    id v16 = v46;
  }
}

void sub_10000DAD8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, id location)
{
}

void sub_10000DB18(uint64_t a1, uint64_t a2)
{
  if (a2) {
    sub_100136544((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 32));
  }
}

void sub_10000DB60(uint64_t a1, uint64_t a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (a2 == 3 && WeakRetained)
  {
    uint64_t v5 = *(void **)(a1 + 32);
    id v13 = WeakRetained;
    if (v5) {
      uint64_t v5 = (void *)v5[6];
    }
    uint64_t v6 = *(void *)(a1 + 40);
    id v7 = v5;
    uint64_t v8 = objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v6]);
    id v9 = (void *)v8;
    if (v8) {
      id v10 = *(id *)(v8 + 8);
    }
    else {
      id v10 = 0LL;
    }

    id WeakRetained = v13;
    if (v10 == v13)
    {
      if (qword_1001DC650 != -1) {
        dispatch_once(&qword_1001DC650, &stru_1001ADF08);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC648, 1LL))
      {
        if (qword_1001DC650 != -1) {
          dispatch_once(&qword_1001DC650, &stru_1001ADF08);
        }
        _NRLogWithArgs( qword_1001DC648,  1LL,  "%s%.30s:%-4d removing pending session %@",  "",  "-[NRIKEv2Listener addPendingSession:sessionConfig:childConfig:validateAuthBlock:responseBlock:key:]_block_invoke",  524LL,  v13);
      }

      uint64_t v11 = *(void *)(a1 + 32);
      if (v11) {
        uint64_t v12 = *(void **)(v11 + 48);
      }
      else {
        uint64_t v12 = 0LL;
      }
      [v12 setObject:0 forKeyedSubscript:*(void *)(a1 + 40)];
      id WeakRetained = v13;
    }
  }
}

void sub_10000DCAC(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v3 = (uint64_t)WeakRetained;
  if (WeakRetained)
  {
    id v4 = WeakRetained[6];
    if ([v4 count])
    {
      uint64_t v31 = a1;
      uint64_t v5 = *(void *)(v3 + 56);
      uint64_t v6 = *(void *)(v31 + 32);

      BOOL v7 = v5 == v6;
      uint64_t v8 = v31;
      if (v7)
      {
        uint64_t v9 = mach_continuous_time();
        __int128 v37 = 0u;
        __int128 v38 = 0u;
        __int128 v39 = 0u;
        __int128 v40 = 0u;
        id obj = *(id *)(v3 + 48);
        id v10 = [obj countByEnumeratingWithState:&v37 objects:v42 count:16];
        if (v10)
        {
          id v11 = v10;
          uint64_t v12 = 0LL;
          uint64_t v13 = *(void *)v38;
          do
          {
            for (i = 0LL; i != v11; i = (char *)i + 1)
            {
              if (*(void *)v38 != v13) {
                objc_enumerationMutation(obj);
              }
              uint64_t v15 = *(void *)(*((void *)&v37 + 1) + 8LL * (void)i);
              uint64_t v16 = objc_claimAutoreleasedReturnValue([*(id *)(v3 + 48) objectForKeyedSubscript:v15]);
              id v19 = (void *)v16;
              double v20 = 0.0;
              if (v16)
              {
                unint64_t v21 = *(void *)(v16 + 48);
                if (v21 && v9 > v21)
                {
                  if (qword_1001DC9F0 != -1) {
                    dispatch_once(&qword_1001DC9F0, &stru_1001AFB98);
                  }
                  LODWORD(v17) = dword_1001DC9F8;
                  LODWORD(v1_Block_object_dispose((const void *)(v1 - 120), 8) = *(_DWORD *)algn_1001DC9FC;
                  double v20 = (double)(v9 - v21) * (0.000000001 * (double)v17) / (double)v18;
                }
              }

              if (v20 > *(double *)(v8 + 48))
              {
                if (qword_1001DC650 != -1) {
                  dispatch_once(&qword_1001DC650, &stru_1001ADF08);
                }
                if (_NRLogIsLevelEnabled(qword_1001DC648, 1LL))
                {
                  if (qword_1001DC650 != -1) {
                    dispatch_once(&qword_1001DC650, &stru_1001ADF08);
                  }
                  if (v19) {
                    uint64_t v23 = v19[1];
                  }
                  else {
                    uint64_t v23 = 0LL;
                  }
                  id v24 = (id)qword_1001DC648;
                  _NRLogWithArgs( v24,  1LL,  "%s%.30s:%-4d cancelling pending session: %@",  "",  "-[NRIKEv2Listener armPendingSessionCleanupTimer]_block_invoke",  565LL,  v23);

                  uint64_t v8 = v31;
                }

                if (v19) {
                  uint64_t v25 = v19[5];
                }
                else {
                  uint64_t v25 = 0LL;
                }
                (*(void (**)(uint64_t, void, void, void))(v25 + 16))(v25, 0LL, 0LL, 0LL);
                if (!v12) {
                  uint64_t v12 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                }
                -[NSMutableArray addObject:](v12, "addObject:", v15);
              }
            }

            id v11 = [obj countByEnumeratingWithState:&v37 objects:v42 count:16];
          }

          while (v11);
        }

        else
        {
          uint64_t v12 = 0LL;
        }

        __int128 v35 = 0u;
        __int128 v36 = 0u;
        __int128 v33 = 0u;
        __int128 v34 = 0u;
        id v26 = v12;
        id v27 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v26,  "countByEnumeratingWithState:objects:count:",  &v33,  v41,  16LL);
        if (v27)
        {
          id v28 = v27;
          uint64_t v29 = *(void *)v34;
          do
          {
            for (j = 0LL; j != v28; j = (char *)j + 1)
            {
              if (*(void *)v34 != v29) {
                objc_enumerationMutation(v26);
              }
              [*(id *)(v3 + 48) setObject:0 forKeyedSubscript:*(void *)(*((void *)&v33 + 1) + 8 * (void)j)];
            }

            id v28 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v26,  "countByEnumeratingWithState:objects:count:",  &v33,  v41,  16LL);
          }

          while (v28);
        }

        sub_10000E054(v3);
      }
    }

    else
    {
    }
  }
}

void sub_10000E054(uint64_t a1)
{
  if (![*(id *)(a1 + 48) count] && *(void *)(a1 + 56))
  {
    if (qword_1001DC650 != -1) {
      dispatch_once(&qword_1001DC650, &stru_1001ADF08);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC648, 0LL))
    {
      if (qword_1001DC650 != -1) {
        dispatch_once(&qword_1001DC650, &stru_1001ADF08);
      }
      _NRLogWithArgs( qword_1001DC648,  0LL,  "%s%.30s:%-4d cancelling pending session monitoring source",  "",  "-[NRIKEv2Listener disarmPendingSessionCleanupTimer]",  592);
    }

    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 56));
    id v2 = *(void **)(a1 + 56);
    *(void *)(a1 + 56) = 0LL;
  }

void sub_10000E148(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  id v2 = (void *)qword_1001DC648;
  qword_1001DC648 = (uint64_t)v1;
}

id sub_10000E178()
{
  if (qword_1001DC640 != -1) {
    dispatch_once(&qword_1001DC640, &stru_1001ADE98);
  }
  return (id)qword_1001DC638;
}

void sub_10000E1BC(id a1)
{
  os_log_t v1 = objc_alloc_init(&OBJC_CLASS___NRIKEv2Listener);
  id v2 = (void *)qword_1001DC638;
  qword_1001DC638 = (uint64_t)v1;
}

uint64_t sub_10000E1E4(uint64_t a1)
{
  if (*(void *)(a1 + 16)) {
    return 1LL;
  }
  id v3 = sub_10010C0B8();
  [v3 setRequestChildlessSA:1];
  if (qword_1001DC9B8 != -1) {
    dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
  }
  if (byte_1001DC9B0) {
    [v3 setForceUDPEncapsulation:1];
  }
  id v4 = objc_alloc(&OBJC_CLASS___NEIKEv2Listener);
  id v5 = *(id *)(a1 + 8);
  LOBYTE(v13) = 1;
  uint64_t v6 = -[NEIKEv2Listener initWithListenerIKEConfig:kernelSASessionName:listenerUDPPort:listenerQueue:delegate:delegateQueue:includeP2P:]( v4,  "initWithListenerIKEConfig:kernelSASessionName:listenerUDPPort:listenerQueue:delegate:delegateQueue:includeP2P:",  v3,  @"terminusIKE-Shared-Listener",  @"62743",  v5,  a1,  v5,  v13);
  BOOL v7 = *(void **)(a1 + 16);
  *(void *)(a1 + 16) = v6;

  uint64_t v8 = *(void *)(a1 + 16);
  BOOL v1 = v8 != 0;
  if (v8)
  {
    if (qword_1001DC650 != -1) {
      dispatch_once(&qword_1001DC650, &stru_1001ADF08);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC648, 0LL))
    {
      if (qword_1001DC650 != -1) {
        dispatch_once(&qword_1001DC650, &stru_1001ADF08);
      }
      _NRLogWithArgs( qword_1001DC648,  0LL,  "%s%.30s:%-4d Created shared IKE listener",  "",  "-[NRIKEv2Listener resume]",  192);
    }
  }

  else
  {
    id v10 = sub_10000D3A0();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 17LL);

    if (IsLevelEnabled)
    {
      id v12 = sub_10000D3A0();
      _NRLogWithArgs(v12, 17LL, "Failed to create shared IKE listener");
    }
  }

  return v1;
}

void sub_10000E3B8(uint64_t a1)
{
  if (*(void *)(a1 + 40))
  {
    if (qword_1001DC650 != -1) {
      dispatch_once(&qword_1001DC650, &stru_1001ADF08);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC648, 1LL))
    {
      if (qword_1001DC650 != -1) {
        dispatch_once(&qword_1001DC650, &stru_1001ADF08);
      }
      _NRLogWithArgs( qword_1001DC648,  1LL,  "%s%.30s:%-4d Uninstalling route rules to allow all incoming IKE connections",  "",  "-[NRIKEv2Listener updateRouteRules]",  278);
    }

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v1 = (id)qword_1001DCB58;
    sub_10012114C((uint64_t)v1, @"NRIKEv2Listener");

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v62 = (id)qword_1001DCB58;
    if (v62)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v62 + 1));
      if (([*((id *)v62 + 2) apply] & 1) == 0) {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v2,  v3,  v4,  v58);
      }
    }
  }

  else
  {
    id v5 = (id *)a1;
    uint64_t v6 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  2LL,  0LL));
    -[NSMutableArray addObject:](v6, "addObject:");
    BOOL v7 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    uint64_t v8 = objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  @"::",  @"62743"));
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
    -[NSMutableArray addObject:](v7, "addObject:", v9);

    id v59 = (void *)v8;
    id v10 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition flowLocalAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "flowLocalAddress:prefix:",  v8,  0LL));
    -[NSMutableArray addObject:](v7, "addObject:", v10);

    id v11 = (void *)objc_claimAutoreleasedReturnValue([v5[3] allValues]);
    id v61 = v7;
    if ([v11 count])
    {
      id v63 = v5;
      id v12 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
      __int128 v77 = 0u;
      __int128 v78 = 0u;
      __int128 v79 = 0u;
      __int128 v80 = 0u;
      id v13 = v11;
      id v14 = [v13 countByEnumeratingWithState:&v77 objects:v84 count:16];
      if (v14)
      {
        id v15 = v14;
        uint64_t v16 = *(void *)v78;
        do
        {
          for (i = 0LL; i != v15; i = (char *)i + 1)
          {
            if (*(void *)v78 != v16) {
              objc_enumerationMutation(v13);
            }
            uint64_t v19 = *(void *)(*((void *)&v77 + 1) + 8LL * (void)i);
            if (v19 && (id v20 = *(id *)(v19 + 8)) != 0LL)
            {
              unint64_t v18 = v20;
              -[NSMutableSet addObject:](v12, "addObject:", v20);
            }

            else
            {
              if (qword_1001DC650 != -1) {
                dispatch_once(&qword_1001DC650, &stru_1001ADF08);
              }
              if (_NRLogIsLevelEnabled(qword_1001DC648, 17LL))
              {
                if (qword_1001DC650 != -1) {
                  dispatch_once(&qword_1001DC650, &stru_1001ADF08);
                }
                _NRLogWithArgs(qword_1001DC648, 17LL, "%@: invalid object at interface name index", v19);
              }
            }
          }

          id v15 = [v13 countByEnumeratingWithState:&v77 objects:v84 count:16];
        }

        while (v15);
      }

      __int128 v75 = 0u;
      __int128 v76 = 0u;
      __int128 v73 = 0u;
      __int128 v74 = 0u;
      unint64_t v21 = v12;
      id v22 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v21,  "countByEnumeratingWithState:objects:count:",  &v73,  v83,  16LL);
      BOOL v7 = v61;
      if (v22)
      {
        id v23 = v22;
        uint64_t v24 = *(void *)v74;
        do
        {
          for (j = 0LL; j != v23; j = (char *)j + 1)
          {
            if (*(void *)v74 != v24) {
              objc_enumerationMutation(v21);
            }
            id v26 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forInterfaceName:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forInterfaceName:",  1LL,  *(void *)(*((void *)&v73 + 1) + 8LL * (void)j)));
            -[NSMutableArray addObject:](v6, "addObject:", v26);
          }

          id v23 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v21,  "countByEnumeratingWithState:objects:count:",  &v73,  v83,  16LL);
        }

        while (v23);
      }

      id v5 = v63;
    }

    id v64 = (id)objc_claimAutoreleasedReturnValue([v5[4] allValues]);
    if ([v64 count])
    {
      id v27 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
      __int128 v69 = 0u;
      __int128 v70 = 0u;
      __int128 v71 = 0u;
      __int128 v72 = 0u;
      id v28 = v64;
      id v29 = [v28 countByEnumeratingWithState:&v69 objects:v82 count:16];
      if (v29)
      {
        id v30 = v29;
        uint64_t v31 = *(void *)v70;
        do
        {
          for (k = 0LL; k != v30; k = (char *)k + 1)
          {
            if (*(void *)v70 != v31) {
              objc_enumerationMutation(v28);
            }
            uint64_t v34 = *(void *)(*((void *)&v69 + 1) + 8LL * (void)k);
            if (v34 && (id v35 = *(id *)(v34 + 8)) != 0LL)
            {
              __int128 v33 = v35;
              -[NSMutableSet addObject:](v27, "addObject:", v35);
            }

            else
            {
              if (qword_1001DC650 != -1) {
                dispatch_once(&qword_1001DC650, &stru_1001ADF08);
              }
              if (_NRLogIsLevelEnabled(qword_1001DC648, 17LL))
              {
                if (qword_1001DC650 != -1) {
                  dispatch_once(&qword_1001DC650, &stru_1001ADF08);
                }
                _NRLogWithArgs(qword_1001DC648, 17LL, "%@: invalid object at interface name index", v34);
              }
            }
          }

          id v30 = [v28 countByEnumeratingWithState:&v69 objects:v82 count:16];
        }

        while (v30);
      }

      __int128 v67 = 0u;
      __int128 v68 = 0u;
      __int128 v65 = 0u;
      __int128 v66 = 0u;
      __int128 v36 = v27;
      id v37 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v36,  "countByEnumeratingWithState:objects:count:",  &v65,  v81,  16LL);
      BOOL v7 = v61;
      if (v37)
      {
        id v38 = v37;
        uint64_t v39 = *(void *)v66;
        do
        {
          for (m = 0LL; m != v38; m = (char *)m + 1)
          {
            if (*(void *)v66 != v39) {
              objc_enumerationMutation(v36);
            }
            id v41 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forInterfaceName:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forInterfaceName:",  1LL,  *(void *)(*((void *)&v65 + 1) + 8LL * (void)m)));
            -[NSMutableArray addObject:](v6, "addObject:", v41);
          }

          id v38 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v36,  "countByEnumeratingWithState:objects:count:",  &v65,  v81,  16LL);
        }

        while (v38);
      }
    }

    if (qword_1001DC650 != -1) {
      dispatch_once(&qword_1001DC650, &stru_1001ADF08);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC648, 1LL))
    {
      if (qword_1001DC650 != -1) {
        dispatch_once(&qword_1001DC650, &stru_1001ADF08);
      }
      _NRLogWithArgs( qword_1001DC648,  1LL,  "%s%.30s:%-4d adding route rules %@",  "",  "-[NRIKEv2Listener updateRouteRules]",  263LL,  v6);
    }

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v42 = (id)qword_1001DCB58;
    sub_10012114C((uint64_t)v42, @"NRIKEv2Listener");

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v43 = (id)qword_1001DCB58;
    id v44 = (id *)v43;
    if (v43)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v43 + 1));
      if (([v44[2] apply] & 1) == 0) {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v45,  v46,  v47,  v58);
      }
    }

    id v48 = objc_alloc(&OBJC_CLASS___NEPolicy);
    id v49 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v6));
    id v50 = [v48 initWithOrder:6 result:v49 conditions:v7];

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v51 = (id)qword_1001DCB58;
    id v52 = sub_100120E44((uint64_t)v51, @"NRIKEv2Listener", v50);

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v53 = (id)qword_1001DCB58;
    unsigned __int8 v54 = (id *)v53;
    if (v53)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v53 + 1));
      if (([v54[2] apply] & 1) == 0) {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v55,  v56,  v57,  v58);
      }
    }
  }

void sub_10000ED54(uint64_t a1, void *a2)
{
  id v21 = a2;
  id v3 = *(id *)(a1 + 48);
  if (v3)
  {
    uint64_t v4 = v3;
    id v5 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) objectForKeyedSubscript:v21]);

    if (v5)
    {
      uint64_t v6 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) objectForKeyedSubscript:v21]);
      [*(id *)(a1 + 48) setObject:0 forKeyedSubscript:v21];
      if (v6)
      {
        [*(id *)(v6 + 8) setStateUpdateBlock:0];
        [*(id *)(v6 + 8) setClientQueue:0];
        BOOL v7 = *(void **)(v6 + 8);
      }

      else
      {
        [0 setStateUpdateBlock:0];
        [0 setClientQueue:0];
        BOOL v7 = 0LL;
      }

      if ([v7 state] == (id)3)
      {
        if (qword_1001DC650 != -1) {
          dispatch_once(&qword_1001DC650, &stru_1001ADF08);
        }
        if (qword_1001DC650 == -1)
        {
          uint64_t v8 = (void *)qword_1001DC648;
          if (v6)
          {
LABEL_11:
            uint64_t v9 = *(void *)(v6 + 8);
LABEL_12:
            id v10 = v8;
            _NRLogWithArgs( v10,  1LL,  "%s%.30s:%-4d not processing disconnected pending session: %@",  "",  "-[NRIKEv2Listener processPendingSessionForKey:]",  484LL,  v9);

LABEL_23:
            goto LABEL_24;
          }
        }

        else
        {
          dispatch_once(&qword_1001DC650, &stru_1001ADF08);
          uint64_t v8 = (void *)qword_1001DC648;
          if (v6) {
            goto LABEL_11;
          }
        }

        uint64_t v9 = 0LL;
        goto LABEL_12;
      }

      if (qword_1001DC650 != -1) {
        dispatch_once(&qword_1001DC650, &stru_1001ADF08);
      }
      if (!_NRLogIsLevelEnabled(qword_1001DC648, 1LL))
      {
LABEL_20:
        id v14 = *(void **)(a1 + 16);
        if (v6)
        {
          id v15 = *(id *)(v6 + 8);
          id v16 = *(id *)(v6 + 16);
          id v17 = *(id *)(v6 + 24);
          id v18 = *(id *)(v6 + 32);
          uint64_t v19 = *(void *)(v6 + 40);
        }

        else
        {
          id v18 = 0LL;
          id v16 = 0LL;
          id v15 = 0LL;
          id v17 = 0LL;
          uint64_t v19 = 0LL;
        }

        id v20 = v14;
        [(id)a1 requestConfigurationForListener:v20 session:v15 sessionConfig:v16 childConfig:v17 validateAuthBlock:v18 responseBlock:v19];

        sub_10000E054(a1);
        goto LABEL_23;
      }

      if (qword_1001DC650 == -1)
      {
        id v11 = (void *)qword_1001DC648;
        if (v6)
        {
LABEL_18:
          uint64_t v12 = *(void *)(v6 + 8);
LABEL_19:
          id v13 = v11;
          _NRLogWithArgs( v13,  1LL,  "%s%.30s:%-4d processing pending session: %@",  "",  "-[NRIKEv2Listener processPendingSessionForKey:]",  487LL,  v12);

          goto LABEL_20;
        }
      }

      else
      {
        dispatch_once(&qword_1001DC650, &stru_1001ADF08);
        id v11 = (void *)qword_1001DC648;
        if (v6) {
          goto LABEL_18;
        }
      }

      uint64_t v12 = 0LL;
      goto LABEL_19;
    }
  }

void sub_10000F034(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v13 = 0u;
    __int128 v14 = 0u;
    id v4 = *(id *)(a1 + 32);
    id v5 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
    if (!v5)
    {
LABEL_19:
      id v12 = v4;
LABEL_20:

      goto LABEL_21;
    }

    id v6 = v5;
    uint64_t v7 = *(void *)v14;
LABEL_5:
    uint64_t v8 = 0LL;
    while (1)
    {
      if (*(void *)v14 != v7) {
        objc_enumerationMutation(v4);
      }
      uint64_t v9 = *(void **)(*((void *)&v13 + 1) + 8 * v8);
      id v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectForKeyedSubscript:v9]);
      id v11 = v10;
      if (v10)
      {
        if ((id)v10[4] == v3) {
          break;
        }
      }

      if (v6 == (id)++v8)
      {
        id v6 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
        if (!v6) {
          goto LABEL_19;
        }
        goto LABEL_5;
      }
    }

    id v12 = v9;

    if (v12)
    {
      [*(id *)(a1 + 32) setObject:0 forKeyedSubscript:v12];
      if (qword_1001DC650 != -1) {
        dispatch_once(&qword_1001DC650, &stru_1001ADF08);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC648, 0LL))
      {
        if (qword_1001DC650 != -1) {
          dispatch_once(&qword_1001DC650, &stru_1001ADF08);
        }
        _NRLogWithArgs( qword_1001DC648,  0LL,  "%s%.30s:%-4d Successfully un-registered pairing client %@",  "",  "-[NRIKEv2Listener unregisterPairingClient:]",  353LL,  v3,  (void)v13);
      }

      sub_10000E3B8(a1);
      goto LABEL_20;
    }
  }

LABEL_21:
}

      __int128 v36 = 0LL;
      goto LABEL_22;
    }

    [v5 getBytes:&v62 length:16];
    id v30 = WORD1(v62);
    uint64_t v31 = __rev16(WORD1(v62));
    __int128 v33 = _NRCopyLogObjectForNRUUID(v6, v32);
    uint64_t v34 = (void *)v33;
    if (v31 + 16 > v8)
    {
      id v35 = _NRLogIsLevelEnabled(v33, 16LL);

      if (!v35) {
        goto LABEL_21;
      }
      goto LABEL_19;
    }

    id v51 = _NRLogIsLevelEnabled(v33, 0LL);

    if (v51)
    {
      id v53 = (void *)_NRCopyLogObjectForNRUUID(v6, v52);
      _NRLogWithArgs( v53,  0LL,  "%s%.30s:%-4d Received message with version: %u, id: %u, length: %u",  "",  "+[NRLinkDirectorMessage createMessageWithData:nrUUID:]",  635,  v64,  bswap32((unsigned __int16)v63) >> 16,  v31);
    }

    unsigned __int8 v54 = objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage);
    uint64_t v55 = sub_100021138((unint64_t)v54, v6, v31 + 16, v64);
    __int128 v36 = v55;
    if (v55)
    {
      *(_WORD *)(v55 + 14) = v31;
      sub_1000218FC(v55, v30);
      [v5 getBytes:*(void *)(v36 + 48) length:v31 + 16];
      do
        uint64_t v57 = __ldxr(&qword_1001DBAD0);
      while (__stxr(v57 + 1, &qword_1001DBAD0));
      *(void *)(v36 + 56) = v57;
    }

    else
    {
      [v5 getBytes:0 length:v31 + 16];
      do
        id v61 = __ldxr(&qword_1001DBAD0);
      while (__stxr(v61 + 1, &qword_1001DBAD0));
    }

    uint64_t v58 = (void *)_NRCopyLogObjectForNRUUID(v6, v56);
    id v59 = _NRLogIsLevelEnabled(v58, 0LL);

    if (v59)
    {
      id v48 = _NRCopyLogObjectForNRUUID(v6, v60);
      id v49 = (void *)v48;
      id v50 = 646LL;
      goto LABEL_37;
    }
  }

  else
  {
    if (v64 != 1)
    {
      uint64_t v19 = (void *)_NRCopyLogObjectForNRUUID(v6, v9);
      id v20 = _NRLogIsLevelEnabled(v19, 0LL);

      if (v20)
      {
        id v22 = (void *)_NRCopyLogObjectForNRUUID(v6, v21);
        _NRLogWithArgs( v22,  0LL,  "%s%.30s:%-4d Unsupported message version %u",  "",  "+[NRLinkDirectorMessage createMessageWithData:nrUUID:]",  648,  v64);
      }

      goto LABEL_21;
    }

    id v62 = 0LL;
    if (v8 <= 7)
    {
      id v10 = (void *)_NRCopyLogObjectForNRUUID(v6, v9);
      id v11 = _NRLogIsLevelEnabled(v10, 16LL);

      if (v11) {
        goto LABEL_11;
      }
      goto LABEL_21;
    }

    [v5 getBytes:&v62 length:8];
    id v23 = HIWORD(v62);
    uint64_t v24 = __rev16(HIWORD(v62));
    id v26 = _NRCopyLogObjectForNRUUID(v6, v25);
    id v27 = (void *)v26;
    if (v24 + 8 > v8)
    {
      id v28 = _NRLogIsLevelEnabled(v26, 16LL);

      if (!v28) {
        goto LABEL_21;
      }
LABEL_19:
      __int128 v16 = (void *)_NRCopyLogObjectForNRUUID(v6, v29);
      _NRLogWithArgs(v16, 16LL, "%s%.30s:%-4d Received truncated message of total length %u with payloadLength %u");
      goto LABEL_20;
    }

    id v38 = _NRLogIsLevelEnabled(v26, 0LL);

    if (v38)
    {
      __int128 v40 = (void *)_NRCopyLogObjectForNRUUID(v6, v39);
      _NRLogWithArgs( v40,  0LL,  "%s%.30s:%-4d Received message with version: %u, id: %u, length: %u",  "",  "+[NRLinkDirectorMessage createMessageWithData:nrUUID:]",  604,  v64,  bswap32(WORD2(v62)) >> 16,  v24);
    }

    id v41 = objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage);
    id v42 = sub_100021138((unint64_t)v41, v6, v24 + 8, v64);
    __int128 v36 = v42;
    if (v42)
    {
      *(_WORD *)(v42 + 14) = v24;
      sub_1000218FC(v42, v23);
      id v43 = *(void *)(v36 + 48);
    }

    else
    {
      id v43 = 0LL;
    }

    [v5 getBytes:v43 length:v24 + 8];
    uint64_t v45 = (void *)_NRCopyLogObjectForNRUUID(v6, v44);
    uint64_t v46 = _NRLogIsLevelEnabled(v45, 0LL);

    if (v46)
    {
      id v48 = _NRCopyLogObjectForNRUUID(v6, v47);
      id v49 = (void *)v48;
      id v50 = 612LL;
LABEL_37:
      _NRLogWithArgs( v48,  0LL,  "%s%.30s:%-4d Received message: %@",  "",  "+[NRLinkDirectorMessage createMessageWithData:nrUUID:]",  v50,  v36);
    }
  }

      return;
    }
  }

  else
  {
    LOWORD(v7) = 0;
  }

  uint64_t v8 = *(unsigned __int16 *)(a1 + 14);
  uint64_t v9 = *(_DWORD *)(a1 + 16);
  if (v9 != *(unsigned __int16 *)(a1 + 12) + (_DWORD)v8)
  {
    __int128 v16 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v6);
    id v17 = _NRLogIsLevelEnabled(v16, 17LL);

    id v5 = v51;
    if (v17)
    {
      id v18 = *(id *)(a1 + 32);
      id v20 = (void *)_NRCopyLogObjectForNRUUID(v18, v19);
      id v21 = *(_DWORD *)(a1 + 16);

      _NRLogWithArgs(v20, 17LL, "Disconnect between messageLen %u and writtenPayloadLength %u", v21, v8);
LABEL_20:
      id v5 = v51;
      goto LABEL_21;
    }

    goto LABEL_21;
  }

  id v10 = (unsigned __int16)v7;
  id v11 = (unsigned __int16)v7 + 3;
  id v12 = v9 + (unsigned __int16)((_WORD)v7 + 3);
  *(_DWORD *)(a1 + 16) = v12;
  if (!(_DWORD)v12)
  {
    id v27 = sub_100020F30();
    id v28 = _NRLogIsLevelEnabled(v27, 16LL);

    if (v28)
    {
      id v29 = sub_100020F30();
      _NRLogWithArgs( v29,  16LL,  "%s%.30s:%-4d ABORTING: _strict_reallocf called with size 0",  "",  "_strict_reallocf",  134);
    }

    id v30 = _os_log_pack_size(12LL);
    uint64_t v31 = (char *)&v51 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    objc_super v32 = __error();
    __int128 v33 = _os_log_pack_fill( v31,  v30,  *v32,  &_mh_execute_header,  "%{public}s _strict_reallocf called with size 0");
    *(_DWORD *)__int128 v33 = 136446210;
    *(void *)(v33 + 4) = "_strict_reallocf";
LABEL_28:
    __int128 v40 = sub_100020F30();
    _NRLogAbortWithPack(v40, v31);
  }

  __int128 v13 = (char *)reallocf(*(void **)(a1 + 48), v12);
  if (!v13)
  {
    uint64_t v34 = sub_100020F30();
    id v35 = _NRLogIsLevelEnabled(v34, 16LL);

    if (v35)
    {
      __int128 v36 = sub_100020F30();
      _NRLogWithArgs(v36, 16LL, "%s%.30s:%-4d ABORTING: _strict_reallocf(%zu) failed", "", "_strict_reallocf", 139, v12);
    }

    id v37 = _os_log_pack_size(22LL);
    uint64_t v31 = (char *)&v51 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v38 = __error();
    uint64_t v39 = _os_log_pack_fill( v31,  v37,  *v38,  &_mh_execute_header,  "%{public}s _strict_reallocf(%zu) failed");
    *(_DWORD *)uint64_t v39 = 136446466;
    *(void *)(v39 + 4) = "_strict_reallocf";
    *(_WORD *)(v39 + 12) = 2048;
    *(void *)(v39 + 14) = v12;
    goto LABEL_28;
  }

  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 120), 8) = 0LL;
  *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 120), 8) = v13;
  __int128 v14 = *(unsigned __int8 *)(a1 + 10);
  if (v14 == 1)
  {
    __int128 v15 = 8LL;
    goto LABEL_17;
  }

  if (v14 == 2)
  {
    __int128 v15 = 16LL;
LABEL_17:
    id v26 = &v13[v15 + v8];
    *id v26 = a2;
    *(_WORD *)(v26 + 1) = __rev16(v10);
    if ((_DWORD)v10) {
      [v51 getBytes:v26 + 3 length:v10];
    }
    *(_WORD *)(a1 + 14) = v8 + v11;
    sub_1000218FC(a1, bswap32(v8 + v11) >> 16);
    goto LABEL_20;
  }

  id v41 = sub_100020F30();
  id v42 = _NRLogIsLevelEnabled(v41, 16LL);

  if (v42)
  {
    id v43 = sub_100020F30();
    _NRLogWithArgs( v43,  16LL,  "%s%.30s:%-4d ABORTING: Unsupported message version: %u",  "",  "-[NRLinkDirectorMessage addType:data:]",  692,  *(unsigned __int8 *)(a1 + 10));
  }

  id v44 = _os_log_pack_size(18LL);
  uint64_t v45 = (char *)&v51 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
  uint64_t v46 = __error();
  uint64_t v47 = _os_log_pack_fill( v45,  v44,  *v46,  &_mh_execute_header,  "%{public}s Unsupported message version: %u");
  id v48 = *(unsigned __int8 *)(a1 + 10);
  *(_DWORD *)uint64_t v47 = 136446466;
  *(void *)(v47 + 4) = "-[NRLinkDirectorMessage addType:data:]";
  *(_WORD *)(v47 + 12) = 1024;
  *(_DWORD *)(v47 + 14) = v48;
  id v49 = sub_100020F30();
  id v50 = _NRLogAbortWithPack(v49, v45);
  sub_100022774(v50);
}

  __int128 v40 = 0LL;
LABEL_22:
  v20[2](v20, 0LL, 0LL, 0LL);
LABEL_23:

  id v17 = v162;
LABEL_24:
}

        v24 += v164;
        uint64_t v25 = v162;
        if (v24 >= v162) {
          goto LABEL_86;
        }
      }

      id v85 = sub_10003B584();
      int v86 = _NRLogIsLevelEnabled(v85, 16LL);

      if (v86)
      {
        id v87 = sub_10003B584();
        _NRLogWithArgs( v87,  16LL,  "%s%.30s:%-4d checksum failed same IOVec received 0x%02x%02x != computed 0x%02x%02x",  "",  "nrChecksumIOVecInner",  179,  v161[(void)v163],  v161[(void)v163 + 1],  v36,  HIBYTE(v36));
      }
}

    id v28 = 0LL;
    goto LABEL_22;
  }

  id v42 = sub_1000C449C();
  id v43 = _NRLogIsLevelEnabled(v42, 17LL);

  if (!v43) {
    goto LABEL_31;
  }
  uint64_t v39 = sub_1000C449C();
  _NRLogWithArgs(v39, 17LL, "%s called with null listener");
LABEL_30:

LABEL_31:
}

      id v30 = v7;
      id v29 = (void *)objc_claimAutoreleasedReturnValue([v7 allObjects]);
      id v18 = (void *)objc_claimAutoreleasedReturnValue([v29 sortedArrayUsingComparator:&stru_1001AE4A8]);
      objc_super v32 = 0u;
      __int128 v33 = 0u;
      uint64_t v34 = 0u;
      id v35 = 0u;
      uint64_t v19 = [v18 countByEnumeratingWithState:&v32 objects:v41 count:16];
      if (v19)
      {
        id v20 = v19;
        id v21 = *(void *)v33;
        do
        {
          for (i = 0LL; i != v20; i = (char *)i + 1)
          {
            if (*(void *)v33 != v21) {
              objc_enumerationMutation(v18);
            }
            id v23 = *(void **)(*((void *)&v32 + 1) + 8LL * (void)i);
            if ([v23 state] == 8
              && ([v23 isPrimary] & 1) == 0)
            {
              __int128 v36 = 0;
              uint64_t v24 = [v23 type];
              uint64_t v25 = ([v23 subtype] - 101);
              id v26 = 0x40300020100uLL >> (8 * v24);
              if (v24 >= 6) {
                LOBYTE(v26) = 0;
              }
              if (v25 >= 4) {
                id v27 = v26;
              }
              else {
                id v27 = 0x7060502u >> (8 * v25);
              }
              __int128 v36 = v27;
              id v28 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  &v36,  1LL);
              sub_1000222F4((uint64_t)v5, 6, v28);
            }
          }

          id v20 = [v18 countByEnumeratingWithState:&v32 objects:v41 count:16];
        }

        while (v20);
      }
    }

    else
    {
    }

    sub_100023824((uint64_t)v5);
  }
}

    id v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v3);
    id v12 = _NRLogIsLevelEnabled(v11, 2LL);

    if (v12)
    {
      id v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v13);
      _NRLogWithArgs(v10, 2LL, "%s%.30s:%-4d ignoring ASClient registration as peer not paired");
      goto LABEL_23;
    }

    goto LABEL_24;
  }

  if (!v2[25]) {
    v2[25] = @"nr-default";
  }
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 3221225472LL;
  v19[2] = sub_100117A88;
  v19[3] = &unk_1001B0720;
  id v11 = v2;
  id v20 = v11;
  id v21 = v5;
  id v12 = v5;
  __int128 v13 = objc_retainBlock(v19);
  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  __int128 v14 = (id)qword_1001DC870;
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472LL;
  v16[2] = sub_100117FEC;
  v16[3] = &unk_1001AFEA8;
  id v17 = v11;
  id v18 = v13;
  __int128 v15 = v13;

LABEL_26:
}

    uint64_t v9 = 0LL;
    goto LABEL_15;
  }

  uint64_t v7 = v6;
  if ((_NRIsUUIDNonZero(v5) & 1) == 0)
  {
    id v18 = sub_100121F34();
    uint64_t v19 = _NRLogIsLevelEnabled(v18, 17LL);

    if (v19)
    {
      id v17 = sub_100121F34();
      _NRLogWithArgs(v17, 17LL, "called with all-zero nrUUID");
      goto LABEL_20;
    }

    goto LABEL_21;
  }

  uint64_t v8 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v8);

  sub_100127AFC(v7);
  uint64_t v9 = (char *)objc_claimAutoreleasedReturnValue([(id)qword_1001DCB78 objectForKeyedSubscript:v5]);
  if (!v9 && a3)
  {
    if (qword_1001DCBD8 != -1) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
    {
      if (qword_1001DCBD8 != -1) {
        dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
      }
      id v10 = (id)qword_1001DCBD0;
      id v11 = (void *)objc_claimAutoreleasedReturnValue([v5 UUIDString]);
      _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d Creating new local device for query %@",  "",  "+[NRDLocalDevice copyLocalDeviceForNRUUID:shouldCreate:]",  2119LL,  v11);
    }

    id v12 = objc_alloc(&OBJC_CLASS___NRDLocalDevice);
    if (v12)
    {
      uint64_t v9 = sub_100123CC0((char *)v12, v5);
      sub_100124478(v9);
      if (v9) {
        v9[21] = 1;
      }
    }

    else
    {
      uint64_t v9 = 0LL;
    }

    [(id)qword_1001DCB78 setObject:v9 forKeyedSubscript:v5];
    __int128 v13 = objc_opt_self(v7);
    sub_100128908(v13);
  }

uint64_t sub_10000F230(uint64_t IsLevelEnabled, void *a2, void *a3, void *a4)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  id v11 = v10;
  if (!IsLevelEnabled) {
    goto LABEL_32;
  }
  if (!v8)
  {
    id v32 = sub_10000D3A0();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v32, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_32;
    }
    __int128 v13 = sub_10000D3A0();
    _NRLogWithArgs(v13, 17LL, "%s called with null link");
    goto LABEL_39;
  }

  if (!v9)
  {
    id v33 = sub_10000D3A0();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v33, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_32;
    }
    __int128 v13 = sub_10000D3A0();
    _NRLogWithArgs(v13, 17LL, "%s called with null interfaceName");
    goto LABEL_39;
  }

  if (!v10)
  {
    id v34 = sub_10000D3A0();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v34, 17LL);

    if (!(_DWORD)IsLevelEnabled) {
      goto LABEL_32;
    }
    __int128 v13 = sub_10000D3A0();
    _NRLogWithArgs(v13, 17LL, "%s called with null localEndpoint");
LABEL_39:
    int IsLevelEnabled = 0LL;
LABEL_31:

    goto LABEL_32;
  }

  if ([v8 state] != 255)
  {
    id obj = a2;
    id v12 = (void *)objc_claimAutoreleasedReturnValue([v8 nrUUID]);
    __int128 v13 = sub_10000D498(IsLevelEnabled, v9, v11, v12);

    __int128 v14 = *(void **)(IsLevelEnabled + 24);
    if (!v14)
    {
      __int128 v15 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      __int128 v16 = *(void **)(IsLevelEnabled + 24);
      *(void *)(IsLevelEnabled + 24) = v15;

      __int128 v14 = *(void **)(IsLevelEnabled + 24);
    }

    uint64_t v17 = objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:v13]);
    id v18 = (void *)v17;
    if (!v17) {
      goto LABEL_12;
    }
    id v35 = v11;
    id v19 = v9;
    id v20 = *(id *)(v17 + 24);
    id v21 = a4;
    id v22 = a3;
    id v23 = v18;
    uint64_t v24 = v13;
    id v25 = [v20 identifier];
    id v26 = [v8 identifier];

    id v9 = v19;
    id v11 = v35;
    BOOL v27 = v25 == v26;
    __int128 v13 = v24;
    id v18 = v23;
    a3 = v22;
    a4 = v21;
    if (v27)
    {
      int IsLevelEnabled = 1LL;
    }

    else
    {
LABEL_12:
      if ((sub_10000E1E4(IsLevelEnabled) & 1) != 0)
      {
        if (qword_1001DC650 != -1) {
          dispatch_once(&qword_1001DC650, &stru_1001ADF08);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC648, 0LL))
        {
          if (qword_1001DC650 != -1) {
            dispatch_once(&qword_1001DC650, &stru_1001ADF08);
          }
          _NRLogWithArgs( qword_1001DC648,  0LL,  "%s%.30s:%-4d Successfully registered link %@",  "",  "-[NRIKEv2Listener registerLink:localInterfaceName:localEndpoint:]",  428LL,  v8);
        }

        id v28 = v9;
        id v29 = objc_alloc_init(&OBJC_CLASS___NRIKEv2ListenerRegistration);
        p_isa = (id *)&v29->super.isa;
        if (v29)
        {
          objc_storeStrong((id *)&v29->_link, obj);
          objc_storeStrong(p_isa + 2, a4);
          objc_storeStrong(p_isa + 1, a3);
        }

        [*(id *)(IsLevelEnabled + 24) setObject:p_isa forKeyedSubscript:v13];
        sub_10000E3B8(IsLevelEnabled);
        sub_10000ED54(IsLevelEnabled, v13);

        int IsLevelEnabled = 1LL;
        id v9 = v28;
      }

      else
      {
        if (qword_1001DC650 != -1) {
          dispatch_once(&qword_1001DC650, &stru_1001ADF08);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC648, 17LL))
        {
          if (qword_1001DC650 != -1) {
            dispatch_once(&qword_1001DC650, &stru_1001ADF08);
          }
          _NRLogWithArgs(qword_1001DC648, 17LL, "Failed to register link %@", v8);
        }

        int IsLevelEnabled = 0LL;
      }
    }

    goto LABEL_31;
  }

  int IsLevelEnabled = 0LL;
LABEL_32:

  return IsLevelEnabled;
}

void sub_10000F658(id a1)
{
  id v1 = objc_alloc(&OBJC_CLASS___NRPairingClientManager);
  id v4 = sub_100146AFC();
  uint64_t v2 = sub_10000F6B0(v1, v4);
  id v3 = (void *)qword_1001DC658;
  qword_1001DC658 = (uint64_t)v2;
}

void *sub_10000F6B0(void *a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    v20.receiver = a1;
    v20.super_class = (Class)&OBJC_CLASS___NRPairingClientManager;
    id v5 = objc_msgSendSuper2(&v20, "init");
    if (!v5)
    {
      id v11 = sub_10000F838();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 16LL);

      if (IsLevelEnabled)
      {
        id v13 = sub_10000F838();
        _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRPairingClientManager initWithQueue:]",  48);
      }

      uint64_t v14 = _os_log_pack_size(12LL);
      __int128 v15 = (char *)&v19 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      __int128 v16 = __error();
      uint64_t v17 = _os_log_pack_fill(v15, v14, *v16, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v17 = 136446210;
      *(void *)(v17 + 4) = "-[NRPairingClientManager initWithQueue:]";
      id v18 = sub_10000F838();
      _NRLogAbortWithPack(v18, v15);
    }

    a1 = v5;
    objc_storeStrong((id *)v5 + 1, a2);
    id v6 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    uint64_t v7 = (void *)a1[2];
    a1[2] = v6;

    id v8 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    id v9 = (void *)a1[3];
    a1[3] = v8;
  }

  return a1;
}

id sub_10000F838()
{
  if (qword_1001DC670 != -1) {
    dispatch_once(&qword_1001DC670, &stru_1001ADF48);
  }
  return (id)qword_1001DC668;
}

void sub_10000F878(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC668;
  qword_1001DC668 = (uint64_t)v1;
}

uint64_t sub_10000F8A8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    uint64_t v1 = *(void *)(v1 + 16);
  }
  return (*(uint64_t (**)(uint64_t, void, void))(v1 + 16))( v1,  *(unsigned __int8 *)(a1 + 40),  *(unsigned __int8 *)(a1 + 41));
}

void sub_10000FE20(_Unwind_Exception *a1)
{
}

void sub_10000FED4(uint64_t a1)
{
  id WeakRetained = (dispatch_source_s **)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && !*((_BYTE *)WeakRetained + 9) && !*((_BYTE *)WeakRetained + 11) && !*((_BYTE *)WeakRetained + 12))
  {
    id v10 = WeakRetained;
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    uint64_t v2 = (id *)(id)qword_1001DC870;
    id v3 = v2;
    if (v2)
    {
      uint64_t v4 = (id *)v2[6];
      id v5 = v4;
      if (v4) {
        [v4[33] removeObject:v10];
      }
    }

    else
    {
      id v5 = 0LL;
    }

    id v6 = (id *)v10;
    *((_BYTE *)v10 + 10) = 0;
    uint64_t v7 = v10[5];
    if (v7)
    {
      dispatch_source_cancel(v7);
      id v8 = v10[5];
      v10[5] = 0LL;

      id v6 = (id *)v10;
    }

    [v6[11] removeAllObjects];
    if (qword_1001DC680 != -1) {
      dispatch_once(&qword_1001DC680, &stru_1001AE190);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC678, 0LL))
    {
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      _NRLogWithArgs( qword_1001DC678,  0LL,  "%s%.30s:%-4d Disabling PHS peers created",  "",  "-[NROnDemandLinkSetupManager handlePHSStopped]",  796);
    }

    sub_1000125B4((uint64_t)v10);
    if (!*((_BYTE *)v10 + 11) && !*((_BYTE *)v10 + 12)) {
      sub_1000127B8((uint64_t)v10);
    }
    id v9 = sub_100146AFC();
    dispatch_async((dispatch_queue_t)v9, &stru_1001AEA60);

    id WeakRetained = v10;
  }
}

void sub_100010098(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 16))
  {
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 56) activeDevices]);

    if (v2)
    {
      __int128 v10 = 0u;
      __int128 v11 = 0u;
      __int128 v8 = 0u;
      __int128 v9 = 0u;
      id v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 56), "activeDevices", 0));
      id v4 = [v3 countByEnumeratingWithState:&v8 objects:v12 count:16];
      if (v4)
      {
        id v5 = v4;
        uint64_t v6 = *(void *)v9;
        do
        {
          for (i = 0LL; i != v5; i = (char *)i + 1)
          {
            if (*(void *)v9 != v6) {
              objc_enumerationMutation(v3);
            }
            sub_1000115C4(a1, *(void **)(*((void *)&v8 + 1) + 8LL * (void)i));
          }

          id v5 = [v3 countByEnumeratingWithState:&v8 objects:v12 count:16];
        }

        while (v5);
      }
    }
  }

void sub_1000101B8(uint64_t a1)
{
  uint64_t v1 = a1;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  id obj = [*(id *)(a1 + 72) copy];
  id v2 = [obj countByEnumeratingWithState:&v38 objects:v44 count:16];
  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  if (v2)
  {
    id v4 = v2;
    uint64_t v37 = *(void *)v39;
    uint64_t v35 = v1;
    do
    {
      for (i = 0LL; i != v4; i = (char *)i + 1)
      {
        if (*(void *)v39 != v37) {
          objc_enumerationMutation(obj);
        }
        uint64_t v7 = *(void *)(*((void *)&v38 + 1) + 8LL * (void)i);
        if (v7) {
          __int128 v8 = *(void **)(v7 + 8);
        }
        else {
          __int128 v8 = 0LL;
        }
        __int128 v9 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKeyedSubscript:@"relay-req"]);
        if ([v9 count])
        {
          __int128 v10 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v10,  "setObject:forKeyedSubscript:",  &off_1001BC460,  @"v");
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v10,  "setObject:forKeyedSubscript:",  &off_1001BC478,  @"nrv");
          __int128 v11 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:@"rid"]);
          -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v11, @"rid");

          id v12 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:@"id"]);
          id v13 = v12;
          if (v12)
          {
            id v14 = v12;
            if (nrSupportsPHSProxy() && *(_BYTE *)(v1 + 15) && *(_BYTE *)(v1 + 13))
            {
              __int128 v15 = sub_10012EA10((uint64_t)&OBJC_CLASS___NRDLocalDevice, v14, 0);
              __int128 v16 = v15;
              if (v15) {
                uint64_t v17 = (void *)*((void *)v15 + 16);
              }
              else {
                uint64_t v17 = 0LL;
              }
              id v18 = v17;
              id v19 = [v18 proxyCapability];

              BOOL v20 = v19 == (id)2;
              uint64_t v1 = v35;
              p_class_meths = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
              if (!v20)
              {
                -[NSMutableDictionary setObject:forKeyedSubscript:]( v10,  "setObject:forKeyedSubscript:",  &off_1001BC4A8,  @"rspc");
                if (qword_1001DCA28 != -1) {
                  dispatch_once(&qword_1001DCA28, &stru_1001AFC48);
                }
                id v21 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  byte_1001DCA20));
                -[NSMutableDictionary setObject:forKeyedSubscript:]( v10,  "setObject:forKeyedSubscript:",  v21,  @"t");

                -[NSMutableDictionary setObject:forKeyedSubscript:]( v10,  "setObject:forKeyedSubscript:",  &off_1001BC4C0,  @"fl");
                id v22 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:@"reg"]);
                id v23 = sub_10012EA10((uint64_t)&OBJC_CLASS___NRDLocalDevice, v14, 0);
                id v33 = v22;
                id v34 = v23;
                if ([v22 BOOLValue] && v23 && v23[8])
                {
                  -[NSMutableDictionary setObject:forKeyedSubscript:]( v10,  "setObject:forKeyedSubscript:",  &__kCFBooleanTrue,  @"reg");
                }

                else
                {
                  -[NSMutableDictionary setObject:forKeyedSubscript:]( v10,  "setObject:forKeyedSubscript:",  &__kCFBooleanFalse,  @"reg");
                  id v25 = v14;
                  id v26 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v35 + 80) objectForKeyedSubscript:v25]);

                  if (!v26)
                  {
                    memset(bytes, 0, sizeof(bytes));
                    while (SecRandomCopyBytes(kSecRandomDefault, 0x20uLL, bytes))
                      ;
                    id v27 = +[NSData _newZeroingDataWithBytes:length:]( &OBJC_CLASS___NSData,  "_newZeroingDataWithBytes:length:",  bytes,  32LL);
                    [*(id *)(v35 + 80) setObject:v27 forKeyedSubscript:v25];
                  }

                  id v28 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v35 + 80) objectForKeyedSubscript:v25]);

                  -[NSMutableDictionary setObject:forKeyedSubscript:]( v10,  "setObject:forKeyedSubscript:",  v28,  @"psk");
                  if (v34 && v34[8])
                  {
                    if (qword_1001DC680 != -1) {
                      dispatch_once(&qword_1001DC680, &stru_1001AE190);
                    }
                    if (_NRLogIsLevelEnabled(qword_1001DC678, 0LL))
                    {
                      if (qword_1001DC680 != -1) {
                        dispatch_once(&qword_1001DC680, &stru_1001AE190);
                      }
                      _NRLogWithArgs( qword_1001DC678,  0LL,  "%s%.30s:%-4d unregistering device %@ as peer does not have a matching registration",  "",  "-[NROnDemandLinkSetupManager sendReplyForInternetRelayRequest]",  568LL,  v34);
                    }

                    id v29 = *((id *)v34 + 4);
                    sub_100130BE8((uint64_t)&OBJC_CLASS___NRDLocalDevice, v29, &stru_1001AE0A0);
                  }
                }

                id v30 = objc_alloc(&OBJC_CLASS___NRValidPeer);
                uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:@"nrv"]);
                id v32 = sub_100010930((id *)&v30->super.isa, v31);
                uint64_t v1 = v35;
                [*(id *)(v35 + 88) setObject:v32 forKeyedSubscript:v14];

                p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
LABEL_34:
                id v42 = @"relay-res";
                id v43 = v10;
                uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v43,  &v42,  1LL));
                if (v7) {
                  uint64_t v6 = *(void *)(v7 + 24);
                }
                else {
                  uint64_t v6 = 0LL;
                }
                (*(void (**)(uint64_t, void *))(v6 + 16))(v6, v24);
                [*(id *)(v1 + 72) removeObject:v7];

                goto LABEL_7;
              }
            }

            else
            {
            }
          }

          if (qword_1001DC680 != -1) {
            dispatch_once(&qword_1001DC680, &stru_1001AE190);
          }
          if (_NRLogIsLevelEnabled(p_class_meths[207], 0LL))
          {
            if (qword_1001DC680 != -1) {
              dispatch_once(&qword_1001DC680, &stru_1001AE190);
            }
            _NRLogWithArgs( p_class_meths[207],  0LL,  "%s%.30s:%-4d cannot provide internet relay service to peer ids device ID %@",  "",  "-[NROnDemandLinkSetupManager sendReplyForInternetRelayRequest]",  553LL,  v13);
          }

          -[NSMutableDictionary setObject:forKeyedSubscript:]( v10,  "setObject:forKeyedSubscript:",  &off_1001BC490,  @"rspc");
          goto LABEL_34;
        }

LABEL_7:
      }

      id v4 = [obj countByEnumeratingWithState:&v38 objects:v44 count:16];
    }

    while (v4);
  }

  if ([*(id *)(v1 + 88) count])
  {
    if (qword_1001DC680 != -1) {
      dispatch_once(&qword_1001DC680, &stru_1001AE190);
    }
    if (_NRLogIsLevelEnabled(p_class_meths[207], 16LL))
    {
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      _NRLogWithArgs( p_class_meths[207],  16LL,  "%s%.30s:%-4d sent response to peer(s)",  "",  "-[NROnDemandLinkSetupManager sendReplyForInternetRelayRequest]",  583);
    }

    sub_100010A8C(v1);
  }

  else
  {
    if (qword_1001DC680 != -1) {
      dispatch_once(&qword_1001DC680, &stru_1001AE190);
    }
    if (_NRLogIsLevelEnabled(p_class_meths[207], 16LL))
    {
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      _NRLogWithArgs( p_class_meths[207],  16LL,  "%s%.30s:%-4d no valid peers for internet relay",  "",  "-[NROnDemandLinkSetupManager sendReplyForInternetRelayRequest]",  586);
    }
  }
}

  return a1;
}

  return a1;
}

        [v5 cancelWithReason:@"peer went away"];
LABEL_8:
      }

      v142 = [obj countByEnumeratingWithState:&v172 objects:v184 count:16];
    }

    while (v142);
  }

  v166 = 0u;
  v167 = 0u;
  v164 = 0u;
  v165 = 0u;
  id v112 = v135;
  v114 = [v112 countByEnumeratingWithState:&v164 objects:v182 count:16];
  if (v114)
  {
    v113 = *(void *)v165;
    do
    {
      id v21 = 0LL;
      do
      {
        if (*(void *)v165 != v113)
        {
          id v23 = v21;
          objc_enumerationMutation(v112);
          id v21 = v23;
        }

        v116 = v21;
        uint64_t v24 = *(void **)(*((void *)&v164 + 1) + 8 * v21);
        id v25 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v24);
        v117 = v25;
        if (!v25 || (id v26 = *((id *)v25 + 16), v26, v27 = (id *)v117, !v26))
        {
          if (qword_1001DC8D0 != -1) {
            dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC8C8, 0LL))
          {
            if (qword_1001DC8D0 != -1) {
              dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
            }
            _NRLogWithArgs( qword_1001DC8C8,  0LL,  "%s%.30s:%-4d Deferring creating link for invalid local device for %@",  "",  "-[NRLinkManagerWired createLinkForNRUUIDs:]",  199LL,  v24);
          }

          goto LABEL_35;
        }

        if (!v117[9])
        {
          if (qword_1001DC8D0 != -1) {
            dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC8C8, 0LL))
          {
            if (qword_1001DC8D0 != -1) {
              dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
            }
            _NRLogWithArgs( qword_1001DC8C8,  0LL,  "%s%.30s:%-4d Deferring creating link for disabled local device for %@",  "",  "-[NRLinkManagerWired createLinkForNRUUIDs:]",  204LL,  v24);
          }

          goto LABEL_35;
        }

        if (!*((_BYTE *)a1 + 32))
        {
          if (qword_1001DC9B8 != -1)
          {
            dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
            id v27 = (id *)v117;
          }

          if (!byte_1001DC9B0)
          {
            id v44 = v27[16];
            id v27 = (id *)v117;
            if (v44)
            {
              uint64_t v45 = v44;
              uint64_t v46 = *((id *)v117 + 16);
              uint64_t v47 = (void *)objc_claimAutoreleasedReturnValue([v46 allowedLinkTypes]);
              id v48 = [v47 containsObject:&off_1001BC6B8];

              a1 = v133;
              id v27 = (id *)v117;
              if ((v48 & 1) == 0)
              {
                if (qword_1001DC8D0 != -1) {
                  dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
                }
                if (_NRLogIsLevelEnabled(qword_1001DC8C8, 0LL))
                {
                  if (qword_1001DC8D0 != -1) {
                    dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
                  }
                  _NRLogWithArgs( qword_1001DC8C8,  0LL,  "%s%.30s:%-4d Deferring creating link for %@ as Wired is unsupported",  "",  "-[NRLinkManagerWired createLinkForNRUUIDs:]",  219LL,  v117);
                }

                goto LABEL_35;
              }
            }
          }
        }

        id v28 = v27;
        if (sub_100107E48(v27) == 1)
        {
          if (*((_BYTE *)v28 + 15))
          {
            id v29 = 1;
            if (*((_BYTE *)v28 + 12)) {
              goto LABEL_48;
            }
          }

          else
          {
            if (*((_BYTE *)v28 + 14)) {
              uint64_t v31 = 1;
            }
            else {
              uint64_t v31 = *((unsigned __int16 *)v28 + 14) > 0x12u;
            }
            id v29 = v31;
            if (*((_BYTE *)v28 + 12))
            {
LABEL_48:
              if (*((_BYTE *)v28 + 13)) {
                id v30 = v29;
              }
              else {
                id v30 = 0;
              }
              goto LABEL_71;
            }
          }
        }

        id v30 = 0;
LABEL_71:
        id v32 = sub_1001319A0((BOOL)v28);
        v120 = (void *)objc_claimAutoreleasedReturnValue([(id)a1[11] objectForKeyedSubscript:v24]);
        if (v120)
        {
          id v33 = v30 & ~v32;
          if ((v33 & 1) != 0)
          {
            id v34 = 0;
          }

          else
          {
            v162 = 0u;
            v163 = 0u;
            v160 = 0u;
            v161 = 0u;
            uint64_t v35 = (id)a1[5];
            __int128 v36 = [v35 countByEnumeratingWithState:&v160 objects:v181 count:16];
            if (v36)
            {
              uint64_t v37 = v36;
              __int128 v38 = v33;
              __int128 v39 = *(void *)v161;
              do
              {
                for (j = 0LL; j != v37; j = (char *)j + 1)
                {
                  if (*(void *)v161 != v39) {
                    objc_enumerationMutation(v35);
                  }
                  __int128 v41 = *(void **)(*((void *)&v160 + 1) + 8LL * (void)j);
                  id v42 = (void *)objc_claimAutoreleasedReturnValue([v41 nrUUID]);
                  id v43 = [v42 isEqual:v24];

                  if (v43 && [v41 state] != 255)
                  {
                    id v34 = 1;
                    goto LABEL_89;
                  }
                }

                uint64_t v37 = [v35 countByEnumeratingWithState:&v160 objects:v181 count:16];
              }

              while (v37);
              id v34 = 0;
LABEL_89:
              a1 = v133;
              id v33 = v38;
            }

            else
            {
              id v34 = 0;
            }
          }

          v158 = 0u;
          v159 = 0u;
          v156 = 0u;
          v157 = 0u;
          v115 = (char *)objc_claimAutoreleasedReturnValue([v120 interfaceToPeerAddressDictionary]);
          v119 = [v115 countByEnumeratingWithState:&v156 objects:v180 count:16];
          if (!v119) {
            goto LABEL_33;
          }
          v118 = *(void *)v157;
          v136 = v24;
          v127 = v33;
LABEL_102:
          id v49 = 0LL;
          while (1)
          {
            if (*(void *)v157 != v118)
            {
              id v50 = v49;
              objc_enumerationMutation(v115);
              id v49 = v50;
            }

            if (!(v33 & 1 | ((v34 & 1) == 0))) {
              goto LABEL_33;
            }
            __int128 v121 = v49;
            id v51 = *(void **)(*((void *)&v156 + 1) + 8 * v49);
            id v52 = (void *)objc_claimAutoreleasedReturnValue([(id)a1[10] objectForKeyedSubscript:v51]);
            id v53 = (void *)objc_claimAutoreleasedReturnValue([v120 interfaceToPeerAddressDictionary]);
            v143 = v51;
            uint64_t v125 = (void *)objc_claimAutoreleasedReturnValue([v53 objectForKeyedSubscript:v51]);

            v154 = 0u;
            v155 = 0u;
            v152 = 0u;
            v153 = 0u;
            __int128 v122 = v52;
            __int128 v124 = [v122 countByEnumeratingWithState:&v152 objects:v179 count:16];
            if (v124)
            {
              __int128 v123 = *(void *)v153;
LABEL_109:
              unsigned __int8 v54 = 0LL;
LABEL_111:
              if (*(void *)v153 != v123)
              {
                uint64_t v55 = v54;
                objc_enumerationMutation(v122);
                unsigned __int8 v54 = v55;
              }

              if (v33 & 1 | ((v34 & 1) == 0)) {
                break;
              }
            }

        sub_100067C8C(v6);
        uint64_t v7 = a1[48];
        a1[48] = 0LL;

        goto LABEL_8;
      }

      id v5 = v4[14];

      if (!v5)
      {
LABEL_6:
        uint64_t v6 = (uint64_t)a1[48];
        if (!v6) {
          goto LABEL_8;
        }
        goto LABEL_7;
      }
    }
}
}
}

  if ((v2 | 2) == 3)
  {
    uint64_t v7 = *(void **)(a1 + 40);
    if (v7)
    {
      __int128 v8 = [v7 count];
      sub_100143FC8((uint64_t)v8, 5401, @"(%llu clients)", v9, v10, v11, v12, v13, (uint64_t)v8);
      id v28 = 0u;
      id v29 = 0u;
      id v26 = 0u;
      id v27 = 0u;
      id v14 = *(id *)(a1 + 40);
      __int128 v15 = [v14 countByEnumeratingWithState:&v26 objects:v30 count:16];
      if (v15)
      {
        __int128 v16 = v15;
        uint64_t v17 = *(void *)v27;
        do
        {
          for (i = 0LL; i != v16; i = (char *)i + 1)
          {
            if (*(void *)v27 != v17) {
              objc_enumerationMutation(v14);
            }
            (*(void (**)(void))(*(void *)(*((void *)&v26 + 1) + 8LL * (void)i) + 16LL))();
          }

          __int128 v16 = [v14 countByEnumeratingWithState:&v26 objects:v30 count:16];
        }

        while (v16);
      }

      [*(id *)(a1 + 40) removeAllObjects];
      id v19 = *(void **)(a1 + 40);
      *(void *)(a1 + 40) = 0LL;

      LODWORD(v2) = *(unsigned __int8 *)(a1 + 8);
      id v5 = 1;
    }

    if ((_DWORD)v2 == 1 && (BOOL v20 = *(void **)(a1 + 48)) != 0LL)
    {
      id v21 = 0LL;
      if ([v20 count])
      {
        do
        {
          id v22 = (void (**)(void))objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) objectAtIndexedSubscript:v21]);
          v22[2]();

          ++v21;
        }

        while (v21 < (unint64_t)[*(id *)(a1 + 48) count]);
      }

      id v23 = [*(id *)(a1 + 48) count];
      uint64_t v24 = *(void **)(a1 + 48);
      if ((id)v21 == v23)
      {
        [v24 removeAllObjects];
        id v25 = *(void **)(a1 + 48);
        *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 - 120), 8) = 0LL;
      }

      else
      {
        objc_msgSend(v24, "removeObjectsInRange:", 0, v21);
        if ((v5 & 1) == 0) {
          return;
        }
      }
    }

    else if (!v5)
    {
      return;
    }
  }

  else if ((v5 & 1) == 0)
  {
    return;
  }

  if (!*(void *)(a1 + 24) && !*(void *)(a1 + 40) && !*(void *)(a1 + 48)) {
    sub_1001442B0(a1);
  }
}

id *sub_100010930(id *a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    v16.receiver = a1;
    v16.super_class = (Class)&OBJC_CLASS___NRValidPeer;
    id v5 = (id *)objc_msgSendSuper2(&v16, "init");
    if (!v5)
    {
      id v7 = sub_100011580();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 16LL);

      if (IsLevelEnabled)
      {
        id v9 = sub_100011580();
        _NRLogWithArgs( v9,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRValidPeer initWithInnerLinkVersion:]",  110);
      }

      uint64_t v10 = _os_log_pack_size(12LL);
      __int128 v11 = (char *)&v15 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v12 = __error();
      uint64_t v13 = _os_log_pack_fill(v11, v10, *v12, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v13 = 136446210;
      *(void *)(v13 + 4) = "-[NRValidPeer initWithInnerLinkVersion:]";
      id v14 = sub_100011580();
      _NRLogAbortWithPack(v14, v11);
    }

    a1 = v5;
    objc_storeStrong(v5 + 1, a2);
  }

  return a1;
}

void sub_100010A8C(uint64_t a1)
{
  uint64_t v1 = (_BYTE *)a1;
  if ([*(id *)(a1 + 88) count])
  {
    id v2 = (dispatch_source_s *)*((void *)v1 + 5);
    if (v2)
    {
      dispatch_source_cancel(v2);
      id v3 = (void *)*((void *)v1 + 5);
      *((void *)v1 + 5) = 0LL;
    }
  }

  __int128 v59 = 0u;
  __int128 v60 = 0u;
  __int128 v57 = 0u;
  __int128 v58 = 0u;
  id obj = *((id *)v1 + 11);
  id v49 = [obj countByEnumeratingWithState:&v57 objects:v62 count:16];
  if (v49)
  {
    uint64_t v4 = 0x1001DB000LL;
    uint64_t v48 = *(void *)v58;
    id v50 = v1;
    do
    {
      for (i = 0LL; i != v49; i = (char *)i + 1)
      {
        if (*(void *)v58 != v48) {
          objc_enumerationMutation(obj);
        }
        uint64_t v6 = *(void **)(*((void *)&v57 + 1) + 8LL * (void)i);
        id v7 = *((id *)v1 + 11);
        uint64_t v8 = objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v6]);
        id v9 = (void *)v8;
        if (v8) {
          uint64_t v10 = *(void **)(v8 + 8);
        }
        else {
          uint64_t v10 = 0LL;
        }
        id v11 = v10;

        if (v11) {
          unsigned int v12 = [v11 unsignedShortValue];
        }
        else {
          unsigned int v12 = 0;
        }
        unsigned int v52 = v12;
        uint64_t v13 = sub_10012EA10(v4 + 2560, v6, 0);
        id v51 = v11;
        if (v13)
        {
          id v14 = v13;
          if (qword_1001DC680 != -1) {
            dispatch_once(&qword_1001DC680, &stru_1001AE190);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC678, 0LL))
          {
            if (qword_1001DC680 != -1) {
              dispatch_once(&qword_1001DC680, &stru_1001AE190);
            }
            _NRLogWithArgs( qword_1001DC678,  0LL,  "%s%.30s:%-4d PHS peer is an existing device %@",  "",  "-[NROnDemandLinkSetupManager activateValidPHSPeers]",  816LL,  v14);
          }
        }

        else
        {
          id v15 = v6;
          uint64_t v16 = objc_opt_self(v4 + 2560);
          id v14 = sub_10012EA10(v16, v15, 1);

          if (qword_1001DC680 != -1) {
            dispatch_once(&qword_1001DC680, &stru_1001AE190);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC678, 0LL))
          {
            if (qword_1001DC680 != -1) {
              dispatch_once(&qword_1001DC680, &stru_1001AE190);
            }
            _NRLogWithArgs( qword_1001DC678,  0LL,  "%s%.30s:%-4d PHS peer created %@",  "",  "-[NROnDemandLinkSetupManager activateValidPHSPeers]",  819LL,  v14);
          }
        }

        uint64_t v17 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        id v18 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        if (v1[13]) {
          -[NSMutableArray addObject:](v17, "addObject:", &off_1001BC4F0);
        }
        if (v1[14])
        {
          -[NSMutableArray addObject:](v17, "addObject:", &off_1001BC508);
          -[NSMutableArray addObject:](v18, "addObject:", &off_1001BC520);
          -[NSMutableArray addObject:](v18, "addObject:", &off_1001BC538);
        }

        if (!v14)
        {
          id v28 = 0LL;
          id v30 = 0LL;
LABEL_71:
          id v34 = v28;
          id v28 = objc_alloc_init(&OBJC_CLASS___NRDeviceOperationalProperties);

          id v35 = *((id *)v1 + 10);
          if (v14) {
            __int128 v36 = (void *)*((void *)v14 + 6);
          }
          else {
            __int128 v36 = 0LL;
          }
          id v37 = v36;
          uint64_t v38 = objc_claimAutoreleasedReturnValue([v35 objectForKeyedSubscript:v37]);

          if (v1[13])
          {
            uint64_t v39 = 1LL;
            uint64_t v31 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
            goto LABEL_77;
          }

          int v40 = v1[14];
          uint64_t v31 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
          if (v40)
          {
            uint64_t v39 = 2LL;
LABEL_77:
            -[NRDeviceOperationalProperties setProxyCapability:](v28, "setProxyCapability:", v39);
          }

          -[NRDeviceOperationalProperties setAllowedLinkTypes:](v28, "setAllowedLinkTypes:", v17);
          -[NRDeviceOperationalProperties setAllowedLinkSubtypes:](v28, "setAllowedLinkSubtypes:", v18);
          -[NRDeviceOperationalProperties setUsesTLS:](v28, "setUsesTLS:", 1LL);
          id v30 = (void *)v38;
          if (!v38)
          {
LABEL_79:
            uint64_t v4 = (uint64_t)v31;
            if (qword_1001DC680 != -1) {
              dispatch_once(&qword_1001DC680, &stru_1001AE190);
            }
            uint64_t v1 = v50;
            if (_NRLogIsLevelEnabled(qword_1001DC678, 16LL))
            {
              if (qword_1001DC680 != -1) {
                dispatch_once(&qword_1001DC680, &stru_1001AE190);
              }
              _NRLogWithArgs( qword_1001DC678,  16LL,  "%s%.30s:%-4d no PSK to complete registration",  "",  "-[NROnDemandLinkSetupManager activateValidPHSPeers]",  884);
            }

            goto LABEL_9;
          }

LABEL_67:
          uint64_t v4 = (uint64_t)v31;
          uint64_t v1 = v50;
          if (-[NRDeviceOperationalProperties proxyCapability](v28, "proxyCapability") == (id)1)
          {
            if (v50[15]) {
              id v33 = +[NRDeviceProxyProviderCriteria copyCriteriaForCellularSlicing]( &OBJC_CLASS___NRDeviceProxyProviderCriteria,  "copyCriteriaForCellularSlicing");
            }
            else {
              id v33 = objc_alloc_init(&OBJC_CLASS___NRDeviceProxyProviderCriteria);
            }
            __int128 v41 = v33;
            -[NRDeviceOperationalProperties setProxyProviderCriteria:](v28, "setProxyProviderCriteria:", v33);
          }

          if (_os_feature_enabled_impl("terminus", "PHSProxyForceEnable"))
          {
            if (qword_1001DC680 != -1) {
              dispatch_once(&qword_1001DC680, &stru_1001AE190);
            }
            if (_NRLogIsLevelEnabled(qword_1001DC678, 1LL))
            {
              if (qword_1001DC680 != -1) {
                dispatch_once(&qword_1001DC680, &stru_1001AE190);
              }
              _NRLogWithArgs( qword_1001DC678,  1LL,  "%s%.30s:%-4d discovering all supported devices",  "",  "-[NROnDemandLinkSetupManager activateValidPHSPeers]",  898);
              uint64_t v42 = 255LL;
            }

            else
            {
              uint64_t v42 = 255LL;
            }

                              pid = xpc_connection_get_pid(v51);
                              __int128 v65 = sub_10010393C(pid, 0);
                            }

                            sub_10010EB74(v48, v65);
                            free(v54);
                            xpc_connection_set_context(v51, 0LL);
                            __int128 v68 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v48 + 16), v67);
                            __int128 v69 = _NRLogIsLevelEnabled(v68, 0LL);

                            if (v69)
                            {
                              __int128 v71 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v48 + 16), v70);
                              _NRLogWithArgs( v71,  0LL,  "%s%.30s:%-4d Removing preferences for %@ : %@",  "",  "-[NRDevicePreferencesManager removeLinkPreferencesForConnection:]",  210LL,  v57,  v56);
                            }

                            sub_10010ED44(v48, v57);

                            __int128 v55 = v144;
                            uint64_t v47 = v145;
                          }
                        }
                      }

                      __int128 v72 = v51;
                      __int128 v73 = *(dispatch_queue_s **)(v48 + 24);
                      if (v73) {
                        dispatch_assert_queue_V2(v73);
                      }
                      if ([*(id *)(v48 + 40) count])
                      {
                        __int128 v74 = xpc_connection_get_context(v72);
                        if (v74)
                        {
                          __int128 v75 = v74;
                          __int128 v76 = v47;
                          __int128 v77 = -[NSString initWithUTF8String:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithUTF8String:",  v74);
                          __int128 v78 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v48 + 40) objectForKeyedSubscript:v77]);
                          if (v78)
                          {
                            free(v75);
                            xpc_connection_set_context(v72, 0LL);
                            __int128 v80 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v48 + 16), v79);
                            id v81 = _NRLogIsLevelEnabled(v80, 0LL);

                            if (v81)
                            {
                              int v83 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v48 + 16), v82);
                              int v84 = (void *)_NRCopyPolicyTrafficClassifiersDescription(v78);
                              _NRLogWithArgs( v83,  0LL,  "%s%.30s:%-4d Removing policy traffic classifiers for %@ : %@",  "",  "-[NRDevicePreferencesManager removePolicyTrafficClassifiersForConnection:]",  296LL,  v77,  v84);
                            }

                            [*(id *)(v48 + 40) setObject:0 forKeyedSubscript:v77];
                            sub_10010E880(v48);
                          }

                          uint64_t v47 = v76;
                        }
                      }

                      id v43 = v147;
                    }

                    id v85 = *(void *)(v46 + 184);
                    if (!v85 || !*(_BYTE *)(v85 + 8)) {
                      sub_1000D90D8(v46, *(void **)(v46 + 616));
                    }
                  }
                }

                v149 = [obj countByEnumeratingWithState:&v155 objects:buffer count:16];
              }

              while (v149);
            }

            int v89 = [v150[29] copy];
            v151 = 0u;
            v152 = 0u;
            v153 = 0u;
            v154 = 0u;
            id v90 = v89;
            int v91 = [v90 countByEnumeratingWithState:&v151 objects:&v160 count:16];
            id WeakRetained = v140;
            if (v91)
            {
              id v92 = v91;
              uint64_t v93 = *(void *)v152;
              do
              {
                for (m = 0LL; m != v92; m = (char *)m + 1)
                {
                  if (*(void *)v152 != v93) {
                    objc_enumerationMutation(v90);
                  }
                  int v95 = *(void **)(*((void *)&v151 + 1) + 8LL * (void)m);
                  if (v95 && (id)v95[2] == v43)
                  {
                    [v150[29] removeObject:*(void *)(*((void *)&v151 + 1) + 8 * (void)m)];
                    id v96 = (void *)objc_claimAutoreleasedReturnValue([v95 description]);
                    sub_10011BB18(0LL, 1024, 0LL, v96);
                  }
                }

                id v92 = [v90 countByEnumeratingWithState:&v151 objects:&v160 count:16];
              }

              while (v92);
            }

            a1 = v141;
          }

          else
          {
            v137 = sub_1000A2100();
            v138 = _NRLogIsLevelEnabled(v137, 17LL);

            if (v138)
            {
              v139 = sub_1000A2100();
              _NRLogWithArgs( v139,  17LL,  "%s called with null connection",  "-[NRLinkDirector removeDevicePreferencesManagerConnection:]");
            }
          }
        }

        sub_1000AF38C((uint64_t)v150, *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL));
        int v97 = *(id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
        if (v150)
        {
          v162 = 0u;
          v163 = 0u;
          v160 = 0u;
          v161 = 0u;
          uint64_t v98 = v150[27];
          int v99 = [v98 countByEnumeratingWithState:&v160 objects:buffer count:16];
          if (v99)
          {
            id v100 = v99;
            int v101 = *(void *)v161;
            do
            {
              for (n = 0LL; n != v100; n = (char *)n + 1)
              {
                if (*(void *)v161 != v101) {
                  objc_enumerationMutation(v98);
                }
                int v103 = objc_claimAutoreleasedReturnValue( [v150[27] objectForKeyedSubscript:*(void *)(*((void *)&v160 + 1) + 8 * (void)n)]);
                id v104 = (void *)v103;
                if (v103) {
                  [*(id *)(v103 + 152) removeObject:v97];
                }
              }

              id v100 = [v98 countByEnumeratingWithState:&v160 objects:buffer count:16];
            }

            while (v100);
          }
        }

        sub_1000AF9A4((uint64_t)v150, 0LL, *(void **)(*(void *)(*(void *)(v141 + 40) + 8LL) + 40LL));
        if (object == &_xpc_error_connection_interrupted)
        {
          if (qword_1001DC778 != -1) {
            dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC770, 2LL))
          {
            if (qword_1001DC778 != -1) {
              dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
            }
            _NRLogWithArgs( qword_1001DC770,  2LL,  "%s%.30s:%-4d received XPC_ERROR_CONNECTION_INTERRUPTED, removing connection",  "",  "-[TerminusdXPCServer startXPCListener]_block_invoke_2",  1662);
          }
        }

        else if (object != &_xpc_error_connection_invalid)
        {
          if (object == &_xpc_error_termination_imminent)
          {
            if (qword_1001DC778 != -1) {
              dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
            }
            if (_NRLogIsLevelEnabled(qword_1001DC770, 2LL))
            {
              v127 = sub_10004579C();
              _NRLogWithArgs( v127,  2LL,  "%s%.30s:%-4d received XPC_ERROR_TERMINATION_IMMINENT, removing connection",  "",  "-[TerminusdXPCServer startXPCListener]_block_invoke_2",  1667);
            }
          }

          else
          {
            int v105 = xpc_copy_description(object);
            if (qword_1001DC778 != -1) {
              dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
            }
            if (_NRLogIsLevelEnabled(qword_1001DC770, 2LL))
            {
              uint64_t v106 = sub_10004579C();
              _NRLogWithArgs( v106,  2LL,  "%s%.30s:%-4d received unknown XPC error %s, removing connection",  "",  "-[TerminusdXPCServer startXPCListener]_block_invoke_2",  1670,  v105);
            }

            if (v105) {
              free(v105);
            }
          }
        }

        v128 = *(void *)(*(void *)(v141 + 40) + 8LL);
        v129 = *(void **)(v128 + 40);
        *(void *)(v128 + 40) = 0LL;

        goto LABEL_164;
      }

      uint64_t v8 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
      id v9 = object;
      uint64_t v10 = v8;
      unsigned int v12 = (dispatch_queue_s *)objc_getProperty(WeakRetained, v11, 8LL, 1);
      dispatch_assert_queue_V2(v12);
      uint64_t v13 = sub_1000454C4((char *)objc_alloc(&OBJC_CLASS___TXSContext), v9, v10);
      if (!v13) {
        goto LABEL_158;
      }
      uint64 = xpc_dictionary_get_uint64(v9, nrXPCKeyType);
      uint64_t v16 = objc_getProperty(WeakRetained, v15, 32LL, 1);
      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedLongLong:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedLongLong:",  uint64));
      id v18 = (uint64_t (**)(void))objc_claimAutoreleasedReturnValue([v16 objectForKeyedSubscript:v17]);

      if (v18)
      {
        id v20 = objc_getProperty(v18, v19, 8LL, 1);
        if ((sub_100047B94(v10, v20) & 1) != 0)
        {
          id v21 = WeakRetained;
          id v23 = ((uint64_t (**)(char *))v18)[2](v13);
          if (v23 == -2000) {
            goto LABEL_157;
          }
          goto LABEL_156;
        }

        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        if (!_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
        {
          id v21 = WeakRetained;
          id v23 = -2002LL;
          goto LABEL_156;
        }

        id v21 = WeakRetained;
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        uint64_t v108 = (id)qword_1001DC770;
        v118 = (void *)*((void *)v13 + 4);
        if (!v118)
        {
          v119 = (_xpc_connection_s *)objc_getProperty(v13, v117, 8LL, 1);
          v120 = xpc_connection_get_pid(v119);
          __int128 v121 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v120);
          bzero(buffer, 0x400uLL);
          if ((int)v120 >= 1 && proc_pidpath(v120, buffer, 0x400u) >= 1 && buffer[0])
          {
            __int128 v122 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  v120);

            __int128 v121 = v122;
          }

          __int128 v123 = (void *)*((void *)v13 + 4);
          *((void *)v13 + 4) = v121;

          v118 = (void *)*((void *)v13 + 4);
        }

        v115 = v118;
        StringFromNRXPCType = (void *)createStringFromNRXPCType(uint64);
        _NRLogWithArgs( v108,  16LL,  "%s%.30s:%-4d Client %@ missing entitlements for type %@",  "",  "-[TerminusdXPCServer handleRequest:onConnection:]",  1711LL,  v115,  StringFromNRXPCType);
        id v23 = -2002LL;
      }

      else
      {
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        if (!_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
        {
          id v21 = WeakRetained;
          id v23 = -2003LL;
          goto LABEL_156;
        }

        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        id v21 = WeakRetained;
        uint64_t v108 = (id)qword_1001DC770;
        uint64_t v109 = (void *)*((void *)v13 + 4);
        if (!v109)
        {
          uint64_t v110 = (_xpc_connection_s *)objc_getProperty(v13, v107, 8LL, 1);
          uint64_t v111 = xpc_connection_get_pid(v110);
          id v112 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v111);
          bzero(buffer, 0x400uLL);
          if ((int)v111 >= 1 && proc_pidpath(v111, buffer, 0x400u) >= 1 && buffer[0])
          {
            v113 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  v111);

            id v112 = v113;
          }

          v114 = (void *)*((void *)v13 + 4);
          *((void *)v13 + 4) = v112;

          uint64_t v109 = (void *)*((void *)v13 + 4);
        }

        v115 = v109;
        StringFromNRXPCType = (void *)createStringFromNRXPCType(uint64);
        _NRLogWithArgs( v108,  16LL,  "%s%.30s:%-4d Client %@ sent invalid type %@",  "",  "-[TerminusdXPCServer handleRequest:onConnection:]",  1715LL,  v115,  StringFromNRXPCType);
        id v23 = -2003LL;
      }

LABEL_156:
      __int128 v124 = objc_getProperty(v13, v22, 24LL, 1);
      xpc_dictionary_set_int64(v124, nrXPCKeyResult, v23);
      uint64_t v126 = objc_getProperty(v13, v125, 24LL, 1);
      xpc_connection_send_message((xpc_connection_t)v10, v126);
LABEL_157:

      id WeakRetained = v21;
LABEL_158:
    }
  }

  else
  {
    v130 = sub_10004579C();
    v131 = _NRLogIsLevelEnabled(v130, 2LL);

    if (!v131) {
      goto LABEL_165;
    }
    id WeakRetained = sub_10004579C();
    _NRLogWithArgs( WeakRetained,  2LL,  "%s%.30s:%-4d received request on removed connection, ignoring",  "",  "-[TerminusdXPCServer startXPCListener]_block_invoke_2",  1641);
  }

      unsigned int v12 = 0LL;
LABEL_68:

LABEL_69:
      goto LABEL_70;
    }

    uint64_t v17 = sub_10004579C();
    id v18 = _NRLogIsLevelEnabled(v17, 17LL);

    if (v18)
    {
      uint64_t v16 = sub_10004579C();
      _NRLogWithArgs(v16, 17LL, "%s called with null directoryPath.length");
      goto LABEL_53;
    }
  }

  else
  {
    id v14 = sub_10004579C();
    id v15 = _NRLogIsLevelEnabled(v14, 17LL);

    if (v15)
    {
      uint64_t v16 = sub_10004579C();
      _NRLogWithArgs(v16, 17LL, "%s called with null directoryPath");
LABEL_53:
    }
  }

  unsigned int v12 = 0LL;
LABEL_70:

  return v12;
}
                    }

                    else
                    {
                      __int128 v69 = sub_1000F4464();
                      __int128 v70 = _NRLogIsLevelEnabled(v69, 17LL);

                      if (v70)
                      {
                        id v50 = sub_1000F4464();
                        _NRLogWithArgs( v50,  17LL,  "%s called with null endpoint",  "-[NRApplicationServiceManager reportBrowseResultRemovedForASName:endpoint:]");
                        goto LABEL_67;
                      }
                    }
                  }

                  uint64_t v13 = v129;
                  id v19 = v133;
                }

                __int128 v59 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 96), v58);
                __int128 v60 = _NRLogIsLevelEnabled(v59, 0LL);

                id v15 = v134;
                if (v60)
                {
                  id v61 = v17;
                  id v62 = *(id *)(v5 + 96);
                  id v64 = (void *)_NRCopyLogObjectForNRUUID(v62, v63);
                  __int128 v65 = *(void **)(v5 + 632);
                  if (v65) {
                    __int128 v65 = (void *)v65[2];
                  }
                  __int128 v66 = v65;
                  _NRLogWithArgs( v64,  0LL,  "%s%.30s:%-4d starting QR link for ongoing AS browse operations %@",  "",  "-[NRDDeviceConductor handleASEndpointChanged:handleASResolving:]",  8421LL,  v66);

                  uint64_t v17 = v61;
                }

                if (!*(_BYTE *)(v5 + 69))
                {
                  *(_BYTE *)(v5 + 69) = 1;
                  [*(id *)(v5 + 192) assertAgentWithOptions:0];
                }

                goto LABEL_18;
              }

              id v25 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 96), v22);
              uint64_t v26 = _NRLogIsLevelEnabled(v25, 0LL);

              if (v26)
              {
                id v27 = *(id *)(v5 + 96);
                uint64_t v17 = (id)_NRCopyLogObjectForNRUUID(v27, v28);
                _NRLogWithArgs( v17,  0LL,  "%s%.30s:%-4d not using QR link for ASName %@",  "",  "-[NRDDeviceConductor handleASEndpointChanged:handleASResolving:]",  8411LL,  v20);

                goto LABEL_18;
              }
            }
}
}

LABEL_98:
            -[NRDeviceOperationalProperties setAllowedPeerDeviceType:](v28, "setAllowedPeerDeviceType:", v42);
          }

          else
          {
            if (v50[13])
            {
              uint64_t v42 = 6LL;
              goto LABEL_98;
            }

            if (v50[14])
            {
              uint64_t v42 = 1LL;
              goto LABEL_98;
            }
          }

          -[NRDeviceOperationalProperties setAllowsDeviceDiscovery:](v28, "setAllowsDeviceDiscovery:", 1LL);
          -[NRDeviceOperationalProperties setAllowsDeadPeerDetection:](v28, "setAllowsDeadPeerDetection:", 1LL);
          if (v14) {
            id v43 = (void *)*((void *)v14 + 16);
          }
          else {
            id v43 = 0LL;
          }
          id v44 = v43;
          -[NRDeviceOperationalProperties setOperationalScope:]( v28,  "setOperationalScope:",  (unint64_t)[v44 operationalScope] | (unint64_t)-[NRDeviceOperationalProperties operationalScope]( v28,  "operationalScope") | 1);

          -[NRDeviceOperationalProperties setActiveOperationalScope:]( v28,  "setActiveOperationalScope:",  (unint64_t)-[NRDeviceOperationalProperties activeOperationalScope](v28, "activeOperationalScope") | 1);
          sub_100105340(v28);
          if (qword_1001DC680 != -1) {
            dispatch_once(&qword_1001DC680, &stru_1001AE190);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC678, 0LL))
          {
            if (qword_1001DC680 != -1) {
              dispatch_once(&qword_1001DC680, &stru_1001AE190);
            }
            _NRLogWithArgs( qword_1001DC678,  0LL,  "%s%.30s:%-4d peer version %u, op prop %@",  "",  "-[NROnDemandLinkSetupManager activateValidPHSPeers]",  915LL,  v52,  v28);
          }

          if (v14) {
            uint64_t v45 = (void *)*((void *)v14 + 4);
          }
          else {
            uint64_t v45 = 0LL;
          }
          id v46 = v45;
          sub_10012ED8C(v4 + 2560, v46, 0LL, v52, 0, v30, 0LL, 0, 0LL, v28, 0LL, @"relay-req", &stru_1001AE130);

LABEL_9:
          goto LABEL_10;
        }

        if (!v14[8] || (id v19 = *((id *)v14 + 16), v19, !v19))
        {
LABEL_61:
          id v28 = (NRDeviceOperationalProperties *)*((id *)v14 + 16);
          id v29 = (void *)*((void *)v14 + 19);
          if (v29) {
            id v29 = (void *)v29[2];
          }
          id v30 = v29;
          if (!v14[8])
          {
            uint64_t v1 = v50;
            goto LABEL_71;
          }

          uint64_t v31 = (__objc2_class *)v4;
          if (v52)
          {
            id v32 = *((id *)v14 + 4);
            sub_1001356B8(v4 + 2560, v52, v32);
          }

          if (!v30) {
            goto LABEL_79;
          }
          goto LABEL_67;
        }

        if (v1[14]
          && (id v20 = *((id *)v14 + 16),
              id v21 = [v20 proxyCapability],
              v20,
              v21 == (id)1))
        {
          if (qword_1001DC680 != -1) {
            dispatch_once(&qword_1001DC680, &stru_1001AE190);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC678, 16LL))
          {
            if (qword_1001DC680 != -1) {
              dispatch_once(&qword_1001DC680, &stru_1001AE190);
            }
            _NRLogWithArgs( qword_1001DC678,  16LL,  "%s%.30s:%-4d PHS peer incompatible with existing registration due to mismatching proxy role. Ignoring",  "",  "-[NROnDemandLinkSetupManager activateValidPHSPeers]",  840);
          }
        }

        else
        {
          __int128 v55 = 0u;
          __int128 v56 = 0u;
          __int128 v53 = 0u;
          __int128 v54 = 0u;
          id v22 = *((id *)v14 + 16);
          id v23 = (void *)objc_claimAutoreleasedReturnValue([v22 allowedLinkTypes]);

          id v24 = [v23 countByEnumeratingWithState:&v53 objects:v61 count:16];
          if (v24)
          {
            id v25 = v24;
            uint64_t v26 = *(void *)v54;
            while (2)
            {
              for (j = 0LL; j != v25; j = (char *)j + 1)
              {
                if (*(void *)v54 != v26) {
                  objc_enumerationMutation(v23);
                }
                if ((-[NSMutableArray containsObject:]( v17,  "containsObject:",  *(void *)(*((void *)&v53 + 1) + 8LL * (void)j)) & 1) != 0)
                {

                  goto LABEL_61;
                }
              }

              id v25 = [v23 countByEnumeratingWithState:&v53 objects:v61 count:16];
              if (v25) {
                continue;
              }
              break;
            }
          }

          if (qword_1001DC680 != -1) {
            dispatch_once(&qword_1001DC680, &stru_1001AE190);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC678, 16LL))
          {
            if (qword_1001DC680 != -1) {
              dispatch_once(&qword_1001DC680, &stru_1001AE190);
            }
            _NRLogWithArgs( qword_1001DC678,  16LL,  "%s%.30s:%-4d PHS peer incompatible with existing registration due to mismatching links. Ignoring",  "",  "-[NROnDemandLinkSetupManager activateValidPHSPeers]",  852);
          }
        }

LABEL_10:
      }

      id v49 = [obj countByEnumeratingWithState:&v57 objects:v62 count:16];
    }

    while (v49);
  }
}
}
}
}

              [*(id *)(a1 + 1207) removeObject:v13];
              continue;
            }
          }

          else if (!a2)
          {
            goto LABEL_10;
          }
        }

        uint64_t v8 = [v6 countByEnumeratingWithState:&v16 objects:v20 count:16];
      }

      while (v8);
    }

    if (![*(id *)(a1 + 1207) count])
    {
      id v15 = *(void **)(a1 + 1207);
      *(void *)(a1 + 1207) = 0LL;
    }
  }

  id v19 = (const void *)sub_1000F07B0(*(void *)(a1 + 32), v16);
  id v20 = (const void *)sub_1000F06E4(*(void *)(a1 + 32), v13);
  id v21 = *(void *)(a1 + 40);
  id v90 = 0LL;
  id v85 = v13;
  id v22 = (void *)objc_claimAutoreleasedReturnValue([v16 signAndProtectData:v21 withSigner:v13 error:&v90]);
  id v23 = v90;
  int v83 = v16;
  if (v23 || !v22)
  {
    if (qword_1001DC910 != -1) {
      dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC908, 17LL))
    {
      if (qword_1001DC910 != -1) {
        dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
      }
      _NRLogWithArgs( qword_1001DC908,  17LL,  "Failed to encrypt and sign classD TLV for %@: %@",  *(void *)(a1 + 48),  v23);
    }

    uint64_t v31 = *(void *)(a1 + 32);
    id v25 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) UUIDString]);
    sub_1000F1ABC(v31, 5504, @"ClassD BT<%@>: %@", v32, v33, v34, v35, v36, (uint64_t)v25);
  }

  else
  {
    id v24 = *(void *)(a1 + 32);
    id v25 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) UUIDString]);
    sub_1000F1ABC(v24, 5503, @"ClassD BT<%@>", v26, v27, v28, v29, v30, (uint64_t)v25);
  }

  id v37 = 0LL;
  int v84 = v14;
  if (v14 && v87)
  {
    uint64_t v38 = *(void *)(a1 + 56);
    if (v38)
    {
      int v89 = 0LL;
      id v37 = (void *)objc_claimAutoreleasedReturnValue([v87 signAndProtectData:v38 withSigner:v14 error:&v89]);
      uint64_t v39 = v89;
      if (v39 || !v37)
      {
        if (qword_1001DC910 != -1) {
          dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC908, 17LL))
        {
          if (qword_1001DC910 != -1) {
            dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
          }
          _NRLogWithArgs( qword_1001DC908,  17LL,  "Failed to encrypt and sign classC TLV for %@: %@",  *(void *)(a1 + 48),  v39);
        }

        uint64_t v47 = *(void *)(a1 + 32);
        __int128 v41 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) UUIDString]);
        sub_1000F1ABC(v47, 5504, @"ClassC BT<%@>: %@", v48, v49, v50, v51, v52, (uint64_t)v41);
      }

      else
      {
        int v40 = *(void *)(a1 + 32);
        __int128 v41 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) UUIDString]);
        sub_1000F1ABC(v40, 5503, @"ClassC BT<%@>", v42, v43, v44, v45, v46, (uint64_t)v41);
      }
    }

    else
    {
      id v37 = 0LL;
    }
  }

  __int128 v53 = 0LL;
  if (v15 && v86)
  {
    __int128 v54 = *(void *)(a1 + 64);
    if (v54)
    {
      int v88 = 0LL;
      __int128 v53 = (void *)objc_claimAutoreleasedReturnValue([v86 signAndProtectData:v54 withSigner:v15 error:&v88]);
      __int128 v55 = v88;
      int v82 = v15;
      if (v55 || !v53)
      {
        if (qword_1001DC910 != -1) {
          dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC908, 17LL))
        {
          if (qword_1001DC910 != -1) {
            dispatch_once(&qword_1001DC910, &stru_1001AF7A0);
          }
          _NRLogWithArgs( qword_1001DC908,  17LL,  "Failed to encrypt and sign classA TLV for %@: %@",  *(void *)(a1 + 48),  v55);
        }

        id v63 = *(void *)(a1 + 32);
        __int128 v57 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) UUIDString]);
        sub_1000F1ABC(v63, 5504, @"ClassA BT<%@>: %@", v64, v65, v66, v67, v68, (uint64_t)v57);
      }

      else
      {
        __int128 v56 = *(void *)(a1 + 32);
        __int128 v57 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 48) UUIDString]);
        sub_1000F1ABC(v56, 5503, @"ClassA BT<%@>", v58, v59, v60, v61, v62, (uint64_t)v57);
      }

      id v15 = v82;
    }

    else
    {
      __int128 v53 = 0LL;
    }
  }

  (*(void (**)(void))(*(void *)(a1 + 72) + 16LL))();
  if (v19) {
    CFRelease(v19);
  }
  if (v20) {
    CFRelease(v20);
  }

  id v14 = v84;
  uint64_t v13 = v85;
  uint64_t v16 = v83;
LABEL_55:
}

    uint64_t v8 = 0LL;
    goto LABEL_9;
  }

  id v5 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 24) objectForKeyedSubscript:v3]);
  uint64_t v6 = (id)v5;
  if (!v5)
  {
LABEL_7:
    uint64_t v8 = 0LL;
    goto LABEL_8;
  }

  id v7 = (nw_path *)nw_agent_client_copy_path(*(void *)(v5 + 40));
  uint64_t v8 = nw_path_copy_effective_local_endpoint(v7);

LABEL_8:
LABEL_9:

  return v8;
}

LABEL_11:
}

    id v5 = 0LL;
    goto LABEL_4;
  }

  if (!v3)
  {
    uint64_t v10 = sub_10010F4BC();
    id v11 = _NRLogIsLevelEnabled(v10, 17LL);

    if (v11)
    {
      id v9 = sub_10010F4BC();
      _NRLogWithArgs(v9, 17LL, "%s called with null record");
      goto LABEL_9;
    }

    goto LABEL_10;
  }

  uint64_t v13 = 0LL;
  id v14 = &v13;
  id v15 = 0x3032000000LL;
  uint64_t v16 = sub_1001125C8;
  uint64_t v17 = sub_1001125D8;
  id v18 = 0LL;
  access_value[0] = _NSConcreteStackBlock;
  access_value[1] = 3221225472LL;
  access_value[2] = sub_100116D54;
  access_value[3] = &unk_1001AFFC0;
  access_value[4] = &v13;
  nw_txt_record_access_key(v3, a2, access_value);
  id v5 = (id)v14[5];
  _Block_object_dispose(&v13, 8);

LABEL_4:
  return v5;
}

    id v7 = 0LL;
    goto LABEL_4;
  }

  id v5 = v4;
  if ((_NRIsUUIDNonZero(v3) & 1) == 0)
  {
    unsigned int v12 = sub_100121F34();
    uint64_t v13 = _NRLogIsLevelEnabled(v12, 17LL);

    if (v13)
    {
      id v11 = sub_100121F34();
      _NRLogWithArgs(v11, 17LL, "called with all-zero nrUUID");
      goto LABEL_9;
    }

    goto LABEL_10;
  }

  uint64_t v6 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v6);

  id v7 = sub_100129C28(v5, v3, 1);
LABEL_4:

  return v7;
}

    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
    goto LABEL_5;
  }

  (*((void (**)(id, uint64_t))v3 + 2))(v3, 1LL);
LABEL_6:
}

void sub_1000114B0(id a1, int64_t a2, NSString *a3)
{
  uint64_t v4 = a3;
  if (qword_1001DC680 != -1) {
    dispatch_once(&qword_1001DC680, &stru_1001AE190);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC678, 0LL))
  {
    if (qword_1001DC680 != -1) {
      dispatch_once(&qword_1001DC680, &stru_1001AE190);
    }
    _NRLogWithArgs( qword_1001DC678,  0LL,  "%s%.30s:%-4d PHS peer registered with res %lld %@",  "",  "-[NROnDemandLinkSetupManager activateValidPHSPeers]_block_invoke",  929LL,  a2,  v4);
  }
}

id sub_100011580()
{
  if (qword_1001DC680 != -1) {
    dispatch_once(&qword_1001DC680, &stru_1001AE190);
  }
  return (id)qword_1001DC678;
}

void sub_1000115C4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1 && (*(_BYTE *)(a1 + 11) || *(_BYTE *)(a1 + 12)))
  {
    if (*(_BYTE *)(a1 + 14))
    {
      id v31 = v3;
      uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([v3 model]);
      id v3 = v31;
      if (!v4
        || (id v5 = (void *)objc_claimAutoreleasedReturnValue([v31 model]),
            unsigned int v6 = [v5 localizedCaseInsensitiveContainsString:@"phone"],
            v5,
            v4,
            id v3 = v31,
            v6))
      {
        id v7 = v3;
        ++*(_DWORD *)(a1 + 24);
        uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](&OBJC_CLASS___NSNumber, "numberWithUnsignedInt:"));
        id v9 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  &off_1001BC460,  @"v");
        -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  &off_1001BC478,  @"nrv");
        objc_opt_self(&OBJC_CLASS___NRLinkDirector);
        if (qword_1001DC878 != -1) {
          dispatch_once(&qword_1001DC878, &stru_1001AEED0);
        }
        uint64_t v10 = (id)qword_1001DC870;
        id v11 = sub_1000AFCFC(v10, 0LL);
        -[NSMutableDictionary setObject:forKeyedSubscript:](v9, "setObject:forKeyedSubscript:", v11, @"id");

        unsigned int v12 = (void *)objc_claimAutoreleasedReturnValue([v7 idsDeviceIdentifier]);
        if (v12)
        {
          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v7 idsDeviceIdentifier]);
          id v14 = sub_10012EA10((uint64_t)&OBJC_CLASS___NRDLocalDevice, v13, 0);

          if (v14) {
            BOOL v15 = v14[8] != 0;
          }
          else {
            BOOL v15 = 0LL;
          }
          uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v15));
          -[NSMutableDictionary setObject:forKeyedSubscript:](v9, "setObject:forKeyedSubscript:", v16, @"reg");
        }

        -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  &off_1001BC4D8,  @"r");
        -[NSMutableDictionary setObject:forKeyedSubscript:](v9, "setObject:forKeyedSubscript:", v8, @"rid");
        if (qword_1001DCA28 != -1) {
          dispatch_once(&qword_1001DCA28, &stru_1001AFC48);
        }
        uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  byte_1001DCA20));
        -[NSMutableDictionary setObject:forKeyedSubscript:](v9, "setObject:forKeyedSubscript:", v17, @"t");

        -[NSMutableDictionary setObject:forKeyedSubscript:]( v9,  "setObject:forKeyedSubscript:",  &off_1001BC4C0,  @"fl");
        int v40 = @"relay-req";
        __int128 v41 = v9;
        id v18 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v41,  &v40,  1LL));
        id v19 = objc_alloc_init(&OBJC_CLASS___RPCompanionLinkClient);
        -[RPCompanionLinkClient setDispatchQueue:](v19, "setDispatchQueue:", *(void *)(a1 + 32));
        -[RPCompanionLinkClient setServiceType:]( v19,  "setServiceType:",  @"com.apple.networkrelay.on-demand-setup");
        -[RPCompanionLinkClient setControlFlags:](v19, "setControlFlags:", 4LL);
        -[RPCompanionLinkClient setDestinationDevice:](v19, "setDestinationDevice:", v7);
        objc_initWeak(&location, (id)a1);
        id v20 = *(id *)(a1 + 56);
        v32[0] = _NSConcreteStackBlock;
        v32[1] = 3221225472LL;
        v32[2] = sub_100011A58;
        v32[3] = &unk_1001AE0F0;
        objc_copyWeak(&v38, &location);
        id v21 = v20;
        id v33 = v21;
        id v22 = v7;
        id v34 = v22;
        id v23 = v8;
        id v35 = v23;
        id v24 = v19;
        __int128 v36 = v24;
        id v25 = v18;
        id v37 = v25;
        -[RPCompanionLinkClient activateWithCompletion:](v24, "activateWithCompletion:", v32);
        uint64_t v26 = *(NSMutableDictionary **)(a1 + 64);
        if (!v26)
        {
          id v27 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
          id v29 = *(void **)(a1 + 64);
          id v28 = (NSMutableDictionary **)(a1 + 64);
          *id v28 = v27;

          uint64_t v26 = *v28;
        }

        id v30 = v26;
        -[NSMutableDictionary setObject:forKeyedSubscript:](v30, "setObject:forKeyedSubscript:", v24, v23);

        objc_destroyWeak(&v38);
        objc_destroyWeak(&location);

        id v3 = v31;
      }
    }
  }
}

void sub_100011A30( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, id location)
{
}

void sub_100011A58(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 72));
  id v5 = WeakRetained;
  if (WeakRetained
    && !*((_BYTE *)WeakRetained + 9)
    && WeakRetained[7] == *(id *)(a1 + 32)
    && *((_BYTE *)WeakRetained + 16))
  {
    if (v3)
    {
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC678, 1LL))
      {
        if (qword_1001DC680 != -1) {
          dispatch_once(&qword_1001DC680, &stru_1001AE190);
        }
        _NRLogWithArgs( qword_1001DC678,  1LL,  "%s%.30s:%-4d message client activation failed with error %@ for device %@",  "",  "-[NROnDemandLinkSetupManager requestInternetRelayFromPeer:]_block_invoke",  657LL,  v3,  *(void *)(a1 + 40));
      }

      unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue([v5[8] objectForKeyedSubscript:*(void *)(a1 + 48)]);
      [v6 invalidate];

      [v5[8] setObject:0 forKeyedSubscript:*(void *)(a1 + 48)];
    }

    else
    {
      id v7 = *(void **)(a1 + 56);
      uint64_t v8 = *(void *)(a1 + 64);
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 3221225472LL;
      v9[2] = sub_100011C78;
      v9[3] = &unk_1001AE0C8;
      objc_copyWeak(&v15, (id *)(a1 + 72));
      id v10 = *(id *)(a1 + 32);
      id v11 = 0LL;
      id v12 = *(id *)(a1 + 40);
      uint64_t v13 = v5;
      id v14 = *(id *)(a1 + 48);
      [v7 sendRequestID:@"com.apple.networkrelay.on-demand-setup" request:v8 options:0 responseHandler:v9];

      objc_destroyWeak(&v15);
    }
  }
}

void sub_100011C64(_Unwind_Exception *a1)
{
}

void sub_100011C78(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v45 = a2;
  id v7 = a3;
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 72));
  id v9 = WeakRetained;
  if (!WeakRetained
    || *((_BYTE *)WeakRetained + 9)
    || WeakRetained[7] != *(id *)(a1 + 32)
    || !*((_BYTE *)WeakRetained + 16))
  {
    goto LABEL_4;
  }

  if (!a4)
  {
    id v15 = *(id *)(a1 + 48);
    id v16 = v45;
    id v17 = v7;
    if (qword_1001DC680 != -1) {
      dispatch_once(&qword_1001DC680, &stru_1001AE190);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC678, 0LL))
    {
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      id v18 = (id)qword_1001DC678;
      id v19 = (void *)objc_claimAutoreleasedReturnValue([v16 allKeys]);
      _NRLogWithArgs( v18,  0LL,  "%s%.30s:%-4d received response %@ from device %@",  "",  "-[NROnDemandLinkSetupManager processInternetRelayResponseFromPeer:response:options:]",  690LL,  v19,  v15);
    }

    id v20 = (void *)objc_claimAutoreleasedReturnValue([v16 objectForKeyedSubscript:@"relay-res"]);
    if (![v20 count]) {
      goto LABEL_54;
    }
    id v21 = (void *)objc_claimAutoreleasedReturnValue([v20 objectForKeyedSubscript:@"rspc"]);
    unsigned __int8 v22 = [v21 unsignedShortValue];
    int v23 = v22;
    if (v22 != 1)
    {
      unsigned __int8 v27 = v22;
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC678, 16LL))
      {
        if (qword_1001DC680 != -1) {
          dispatch_once(&qword_1001DC680, &stru_1001AE190);
        }
        if ((v27 & 0xFC) != 0) {
          id v28 = @"unknown";
        }
        else {
          id v28 = off_1001AE1B0[v23];
        }
        _NRLogWithArgs( qword_1001DC678,  16LL,  "%s%.30s:%-4d received internet relay response code %@ from device %@",  "",  "-[NROnDemandLinkSetupManager processInternetRelayResponseFromPeer:response:options:]",  700LL,  v28,  v15);
      }

      goto LABEL_53;
    }

    id v43 = v17;
    id v44 = v21;
    id v24 = (void *)objc_claimAutoreleasedReturnValue([v20 objectForKeyedSubscript:@"reg"]);
    id v25 = (void *)objc_claimAutoreleasedReturnValue([v15 idsDeviceIdentifier]);
    uint64_t v26 = sub_10012EA10((uint64_t)&OBJC_CLASS___NRDLocalDevice, v25, 0);

    uint64_t v42 = v24;
    if ([v24 BOOLValue])
    {
      if (!v26) {
        goto LABEL_41;
      }
      if (v26[8]) {
        goto LABEL_43;
      }
    }

    else
    {
      if (!v26) {
        goto LABEL_41;
      }
      if (v26[8])
      {
LABEL_40:
        id v29 = *((id *)v26 + 4);
        sub_100130BE8((uint64_t)&OBJC_CLASS___NRDLocalDevice, v29, &stru_1001AE110);

        goto LABEL_41;
      }
    }

    if (v26[9]) {
      goto LABEL_40;
    }
LABEL_41:
    uint64_t v30 = objc_claimAutoreleasedReturnValue([v20 objectForKeyedSubscript:@"psk"]);
    if (!v30)
    {
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      __int128 v41 = v42;
      id v17 = v43;
      if (_NRLogIsLevelEnabled(qword_1001DC678, 16LL))
      {
        if (qword_1001DC680 != -1) {
          dispatch_once(&qword_1001DC680, &stru_1001AE190);
        }
        _NRLogWithArgs( qword_1001DC678,  16LL,  "%s%.30s:%-4d no device registration psk from device %@",  "",  "-[NROnDemandLinkSetupManager processInternetRelayResponseFromPeer:response:options:]",  715LL,  v15);
      }

      goto LABEL_44;
    }

    id v31 = (void *)v30;
    id v32 = v9[10];
    id v33 = (void *)objc_claimAutoreleasedReturnValue([v15 idsDeviceIdentifier]);
    [v32 setObject:v31 forKeyedSubscript:v33];

LABEL_43:
    id v34 = (void *)objc_claimAutoreleasedReturnValue([v20 objectForKeyedSubscript:@"rid"]);
    id v35 = (void *)objc_claimAutoreleasedReturnValue([v9[8] objectForKeyedSubscript:v34]);
    [v35 invalidate];

    [v9[8] setObject:0 forKeyedSubscript:v34];
    __int128 v36 = objc_alloc(&OBJC_CLASS___NRValidPeer);
    id v37 = (void *)objc_claimAutoreleasedReturnValue([v20 objectForKeyedSubscript:@"nrv"]);
    id v38 = sub_100010930((id *)&v36->super.isa, v37);

    id v39 = v9[11];
    int v40 = (void *)objc_claimAutoreleasedReturnValue([v15 idsDeviceIdentifier]);
    [v39 setObject:v38 forKeyedSubscript:v40];

    sub_100010A8C((uint64_t)v9);
    __int128 v41 = v42;
    id v17 = v43;
LABEL_44:

    id v21 = v44;
LABEL_53:

LABEL_54:
    goto LABEL_4;
  }

  if (qword_1001DC680 != -1) {
    dispatch_once(&qword_1001DC680, &stru_1001AE190);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC678, 1LL))
  {
    if (qword_1001DC680 != -1) {
      dispatch_once(&qword_1001DC680, &stru_1001AE190);
    }
    _NRLogWithArgs( qword_1001DC678,  1LL,  "%s%.30s:%-4d message received response with error %@ for device %@",  "",  "-[NROnDemandLinkSetupManager requestInternetRelayFromPeer:]_block_invoke_2",  674LL,  *(void *)(a1 + 40),  *(void *)(a1 + 48));
  }

  uint64_t v10 = *(void *)(a1 + 56);
  if (v10) {
    id v11 = *(void **)(v10 + 64);
  }
  else {
    id v11 = 0LL;
  }
  id v12 = (void *)objc_claimAutoreleasedReturnValue([v11 objectForKeyedSubscript:*(void *)(a1 + 64)]);
  [v12 invalidate];

  uint64_t v13 = *(void *)(a1 + 56);
  if (v13) {
    id v14 = *(void **)(v13 + 64);
  }
  else {
    id v14 = 0LL;
  }
  [v14 setObject:0 forKeyedSubscript:*(void *)(a1 + 64)];
LABEL_4:
}

void sub_100012258(uint64_t a1, void *a2)
{
  id v5 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v4 = WeakRetained;
  if (WeakRetained && *((void *)WeakRetained + 7) == *(void *)(a1 + 32))
  {
    if (qword_1001DC680 != -1) {
      dispatch_once(&qword_1001DC680, &stru_1001AE190);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC678, 0LL))
    {
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      _NRLogWithArgs( qword_1001DC678,  0LL,  "%s%.30s:%-4d [Browser] device found: %@",  "",  "-[NROnDemandLinkSetupManager startBrowser]_block_invoke",  346LL,  v5);
    }

    sub_1000115C4(*(void *)(a1 + 40), v5);
  }
}

void sub_100012354(uint64_t a1, void *a2)
{
  id v5 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v4 = WeakRetained;
  if (WeakRetained && *((void *)WeakRetained + 7) == *(void *)(a1 + 32))
  {
    if (qword_1001DC680 != -1) {
      dispatch_once(&qword_1001DC680, &stru_1001AE190);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC678, 1LL))
    {
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      _NRLogWithArgs( qword_1001DC678,  1LL,  "%s%.30s:%-4d [Browser] device lost: %@",  "",  "-[NROnDemandLinkSetupManager startBrowser]_block_invoke_2",  354LL,  v5);
    }
  }
}

void sub_100012444(uint64_t a1, void *a2)
{
  id v5 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v4 = (uint64_t)WeakRetained;
  if (WeakRetained && WeakRetained[7] == *(void *)(a1 + 32))
  {
    if (qword_1001DC680 != -1) {
      dispatch_once(&qword_1001DC680, &stru_1001AE190);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC678, 0LL))
    {
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      _NRLogWithArgs( qword_1001DC678,  0LL,  "%s%.30s:%-4d [Browser] activated with error %@",  "",  "-[NROnDemandLinkSetupManager startBrowser]_block_invoke_3",  361LL,  v5);
    }

    if (v5)
    {
      [*(id *)(v4 + 56) invalidate];
    }

    else
    {
      *(_BYTE *)(v4 + 16) = 1;
      sub_100010098(v4);
    }
  }
}

void sub_100012558(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained && !*((_BYTE *)WeakRetained + 9) && *((void *)WeakRetained + 5) == *(void *)(a1 + 32))
  {
    id v3 = WeakRetained;
    [WeakRetained didUpdatePHSState:0 llphsActive:0];
    id WeakRetained = v3;
  }
}

void sub_1000125B4(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = sub_1000128DC(a1);
    if (qword_1001DC680 != -1) {
      dispatch_once(&qword_1001DC680, &stru_1001AE190);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC678, 0LL))
    {
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      _NRLogWithArgs( qword_1001DC678,  0LL,  "%s%.30s:%-4d Ineligible peers: %@",  "",  "-[NROnDemandLinkSetupManager updateRegistrationForInEligibleNRUUIDsInner]",  992LL,  v1);
    }

    __int128 v13 = 0u;
    __int128 v14 = 0u;
    __int128 v11 = 0u;
    __int128 v12 = 0u;
    id v2 = v1;
    id v3 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v2,  "countByEnumeratingWithState:objects:count:",  &v11,  v15,  16LL);
    if (v3)
    {
      id v4 = v3;
      uint64_t v5 = *(void *)v12;
      do
      {
        for (i = 0LL; i != v4; i = (char *)i + 1)
        {
          if (*(void *)v12 != v5) {
            objc_enumerationMutation(v2);
          }
          uint64_t v8 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(*((void *)&v11 + 1) + 8LL * (void)i));
          id v9 = v8;
          if (!v8)
          {
            id v7 = 0LL;
LABEL_13:
            sub_100130BE8((uint64_t)&OBJC_CLASS___NRDLocalDevice, v7, &stru_1001AE170);
            goto LABEL_14;
          }

          int v10 = v8[8];
          id v7 = *((id *)v8 + 4);
          if (!v10) {
            goto LABEL_13;
          }
          sub_100131034((uint64_t)&OBJC_CLASS___NRDLocalDevice, v7, &stru_1001AE150);
LABEL_14:
        }

        id v4 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v2,  "countByEnumeratingWithState:objects:count:",  &v11,  v15,  16LL);
      }

      while (v4);
    }
  }

void sub_1000127B8(uint64_t a1)
{
  id v2 = *(void **)(a1 + 56);
  if (v2)
  {
    [v2 invalidate];
    id v3 = *(void **)(a1 + 56);
    *(void *)(a1 + 56) = 0LL;

    *(_BYTE *)(a1 + 16) = 0;
  }

  __int128 v12 = 0u;
  __int128 v13 = 0u;
  __int128 v10 = 0u;
  __int128 v11 = 0u;
  id v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 64), "allValues", 0));
  id v5 = [v4 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v11;
    do
    {
      uint64_t v8 = 0LL;
      do
      {
        if (*(void *)v11 != v7) {
          objc_enumerationMutation(v4);
        }
        [*(id *)(*((void *)&v10 + 1) + 8 * (void)v8) invalidate];
        uint64_t v8 = (char *)v8 + 1;
      }

      while (v6 != v8);
      id v6 = [v4 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }

    while (v6);
  }

  id v9 = *(void **)(a1 + 64);
  *(void *)(a1 + 64) = 0LL;
}

NSMutableArray *sub_1000128DC(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  unsigned __int8 v22 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  id v2 = sub_1001314D4((uint64_t)&OBJC_CLASS___NRDLocalDevice);
  id v3 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v2,  "countByEnumeratingWithState:objects:count:",  &v23,  v27,  16LL);
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v24;
    do
    {
      for (i = 0LL; i != v4; i = (char *)i + 1)
      {
        if (*(void *)v24 != v5) {
          objc_enumerationMutation(v2);
        }
        __int128 v10 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(*((void *)&v23 + 1) + 8LL * (void)i));
        __int128 v11 = (id *)v10;
        if (v10)
        {
          id v12 = *((id *)v10 + 16);
          if (v12)
          {
            __int128 v13 = v12;
            id v14 = v11[16];
            id v15 = [v14 operationalScope];

            if (v15)
            {
              id v16 = v11[16];
              unint64_t v17 = (unint64_t)[v16 activeOperationalScope];

              id v18 = v11[16];
              unsigned __int8 v19 = [v18 operationalScope];

              if ((v19 & 1) != 0 && !*(_BYTE *)(a1 + 11) && !*(_BYTE *)(a1 + 12)) {
                v17 &= ~1uLL;
              }
              id v7 = v11[16];
              [v7 setActiveOperationalScope:v17];

              id v8 = v11[16];
              id v9 = [v8 activeOperationalScope];

              if (!v9)
              {
                id v20 = v11[4];
                -[NSMutableArray addObject:](v22, "addObject:", v20);
              }
            }
          }
        }
      }

      id v4 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v2,  "countByEnumeratingWithState:objects:count:",  &v23,  v27,  16LL);
    }

    while (v4);
  }

  return v22;
}

void sub_100012AF0(id a1, int64_t a2, NSString *a3)
{
  id v4 = a3;
  if (qword_1001DC680 != -1) {
    dispatch_once(&qword_1001DC680, &stru_1001AE190);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC678, 0LL))
  {
    if (qword_1001DC680 != -1) {
      dispatch_once(&qword_1001DC680, &stru_1001AE190);
    }
    _NRLogWithArgs( qword_1001DC678,  0LL,  "%s%.30s:%-4d PHS peer unregistered with res %lld %@",  "",  "-[NROnDemandLinkSetupManager updateRegistrationForInEligibleNRUUIDsInner]_block_invoke_2",  1003LL,  a2,  v4);
  }
}

void sub_100012BC0(id a1, int64_t a2, NSString *a3)
{
  id v4 = a3;
  if (qword_1001DC680 != -1) {
    dispatch_once(&qword_1001DC680, &stru_1001AE190);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC678, 0LL))
  {
    if (qword_1001DC680 != -1) {
      dispatch_once(&qword_1001DC680, &stru_1001AE190);
    }
    _NRLogWithArgs( qword_1001DC678,  0LL,  "%s%.30s:%-4d PHS peer disabled with res %lld %@",  "",  "-[NROnDemandLinkSetupManager updateRegistrationForInEligibleNRUUIDsInner]_block_invoke",  998LL,  a2,  v4);
  }
}

void sub_100012C90(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  id v2 = (void *)qword_1001DC678;
  qword_1001DC678 = (uint64_t)v1;
}

id *sub_100012CC0(id *a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    v22.receiver = a1;
    v22.super_class = (Class)&OBJC_CLASS___NROnDemandLinkSetupManager;
    uint64_t v5 = (id *)objc_msgSendSuper2(&v22, "init");
    if (!v5)
    {
      id v13 = sub_100011580();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v13, 16LL);

      if (IsLevelEnabled)
      {
        id v15 = sub_100011580();
        _NRLogWithArgs( v15,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NROnDemandLinkSetupManager initWithQueue:]",  148);
      }

      uint64_t v16 = _os_log_pack_size(12LL);
      unint64_t v17 = (char *)&v21 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v18 = __error();
      uint64_t v19 = _os_log_pack_fill(v17, v16, *v18, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v19 = 136446210;
      *(void *)(v19 + 4) = "-[NROnDemandLinkSetupManager initWithQueue:]";
      id v20 = sub_100011580();
      _NRLogAbortWithPack(v20, v17);
    }

    a1 = v5;
    objc_storeStrong(v5 + 4, a2);
    id v6 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    id v7 = a1[9];
    a1[9] = v6;

    id v8 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    id v9 = a1[10];
    a1[10] = v8;

    __int128 v10 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    id v11 = a1[11];
    a1[11] = v10;

    *((_DWORD *)a1 + 5) = -1;
  }

  return a1;
}

void sub_100012E68(uint64_t a1)
{
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v2 = (id)qword_1001DC870;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472LL;
  v3[2] = sub_100012F48;
  v3[3] = &unk_1001ADF90;
  objc_copyWeak(&v4, (id *)(a1 + 32));

  objc_destroyWeak(&v4);
}

void sub_100012F34(_Unwind_Exception *a1)
{
}

void sub_100012F48(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_self(&OBJC_CLASS___NRDKeyManager);
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  id v4 = (id)qword_1001DCC10;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100013030;
  v5[3] = &unk_1001AFED0;
  objc_copyWeak(&v6, (id *)(a1 + 32));
  sub_100144478((uint64_t)v4, v5);

  objc_destroyWeak(&v6);
}

void sub_10001301C(_Unwind_Exception *a1)
{
}

void sub_100013030(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v2 = WeakRetained;
  if (WeakRetained && !*((_BYTE *)WeakRetained + 9))
  {
    id val = WeakRetained;
    if (!*((void *)WeakRetained + 6))
    {
      id v3 = objc_alloc_init(&OBJC_CLASS___RPCompanionLinkClient);
      -[RPCompanionLinkClient setDispatchQueue:](v3, "setDispatchQueue:", *((void *)val + 4));
      objc_initWeak(&location, val);
      handler = _NSConcreteStackBlock;
      uint64_t v27 = 3221225472LL;
      id v28 = sub_100013DAC;
      id v29 = &unk_1001ADFE0;
      objc_copyWeak(&v31, &location);
      id v4 = v3;
      uint64_t v30 = v4;
      -[RPCompanionLinkClient registerRequestID:options:handler:]( v4,  "registerRequestID:options:handler:",  @"com.apple.networkrelay.on-demand-setup",  0LL,  &handler);
      id v20 = _NSConcreteStackBlock;
      uint64_t v21 = 3221225472LL;
      objc_super v22 = sub_10001421C;
      __int128 v23 = &unk_1001B0798;
      objc_copyWeak(&v25, &location);
      uint64_t v5 = v4;
      __int128 v24 = v5;
      -[RPCompanionLinkClient setInterruptionHandler:](v5, "setInterruptionHandler:", &v20);
      from[0] = _NSConcreteStackBlock;
      from[1] = (id)3221225472LL;
      id from[2] = sub_1000142FC;
      from[3] = &unk_1001B0798;
      objc_copyWeak(&v19, &location);
      id v6 = v5;
      id v18 = v6;
      -[RPCompanionLinkClient setInvalidationHandler:](v6, "setInvalidationHandler:", from);
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 3221225472LL;
      v14[2] = sub_1000143DC;
      v14[3] = &unk_1001AE008;
      objc_copyWeak(&v16, &location);
      id v7 = v6;
      id v15 = v7;
      -[RPCompanionLinkClient activateWithCompletion:](v7, "activateWithCompletion:", v14);
      id v8 = (void *)*((void *)val + 6);
      *((void *)val + 6) = v7;
      id v9 = v7;

      objc_destroyWeak(&v16);
      objc_destroyWeak(&v19);

      objc_destroyWeak(&v25);
      objc_destroyWeak(&v31);
      objc_destroyWeak(&location);
      id v2 = val;
    }

    objc_initWeak(from, v2);
    __int128 v10 = (dispatch_queue_s *)*((id *)val + 4);
    handler = _NSConcreteStackBlock;
    uint64_t v27 = 3221225472LL;
    id v28 = sub_1000133C8;
    id v29 = &unk_1001AE080;
    objc_copyWeak((id *)&v30, from);
    xpc_set_event_stream_handler("com.apple.notifyd.matching", v10, &handler);

    id v11 = (dispatch_queue_s *)*((id *)val + 4);
    id v20 = _NSConcreteStackBlock;
    uint64_t v21 = 3221225472LL;
    objc_super v22 = sub_100013458;
    __int128 v23 = &unk_1001AE080;
    objc_copyWeak((id *)&v24, from);
    xpc_set_event_stream_handler("com.apple.rapport.matching", v11, &v20);

    objc_destroyWeak((id *)&v24);
    objc_destroyWeak((id *)&v30);
    objc_destroyWeak(from);
    dispatch_time_t v12 = dispatch_time(0LL, 1000000000LL);
    dispatch_after(v12, *((dispatch_queue_t *)val + 4), &stru_1001ADF68);
    id v2 = val;
  }
}

void sub_100013348( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  uint64_t v21 = v19;
  objc_destroyWeak(v21);
  objc_destroyWeak(v18);
  objc_destroyWeak(v17);
  objc_destroyWeak(v16);
  objc_destroyWeak((id *)(v20 - 104));
  _Unwind_Resume(a1);
}

void sub_1000133BC(id a1)
{
}

void sub_1000133C8(uint64_t a1, void *a2)
{
  xpc_object_t xdict = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v4 = WeakRetained;
  if (WeakRetained)
  {
    if (!WeakRetained[9])
    {
      string = xpc_dictionary_get_string(xdict, _xpc_event_key_name);
      sub_1000136E0((uint64_t)string, v6, @"notify(%s)", v7, v8, v9, v10, v11, (uint64_t)string);
      if (!strcmp(string, "com.apple.networkrelay.launch.phs")) {
        sub_100013750(v4);
      }
    }
  }
}

void sub_100013458(uint64_t a1, void *a2)
{
  id v30 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v4 = WeakRetained;
  if (WeakRetained)
  {
    if (!*((_BYTE *)WeakRetained + 9))
    {
      string = xpc_dictionary_get_string(v30, _xpc_event_key_name);
      sub_1000136E0((uint64_t)string, v6, @"rapport(%s)", v7, v8, v9, v10, v11, (uint64_t)string);
      if (xpc_dictionary_get_BOOL(v30, "replyRequired"))
      {
        id v12 = v30;
        if (v12)
        {
          id v13 = v12;
          xpc_object_t reply = xpc_dictionary_create_reply(v12);
          if (reply)
          {
            id v15 = reply;

            xpc_dictionary_send_reply(v15);
            goto LABEL_7;
          }

          id v23 = sub_100011580();
          int IsLevelEnabled = _NRLogIsLevelEnabled(v23, 16LL);

          if (IsLevelEnabled)
          {
            id v25 = sub_100011580();
            _NRLogWithArgs( v25,  16LL,  "%s%.30s:%-4d ABORTING: xpc_dictionary_create_reply failed",  "",  "nr_xpc_dictionary_create_reply",  92);
          }

          uint64_t v26 = _os_log_pack_size(12LL);
          uint64_t v20 = (char *)&v30 - ((__chkstk_darwin(v26) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v27 = __error();
          uint64_t v28 = _os_log_pack_fill( v20,  v26,  *v27,  &_mh_execute_header,  "%{public}s xpc_dictionary_create_reply failed");
          *(_DWORD *)uint64_t v28 = 136446210;
          *(void *)(v28 + 4) = "nr_xpc_dictionary_create_reply";
        }

        else
        {
          id v16 = sub_100011580();
          int v17 = _NRLogIsLevelEnabled(v16, 16LL);

          if (v17)
          {
            id v18 = sub_100011580();
            _NRLogWithArgs( v18,  16LL,  "%s%.30s:%-4d ABORTING: nr_xpc_dictionary_create_reply called with NULL original",  "",  "nr_xpc_dictionary_create_reply",  88);
          }

          uint64_t v19 = _os_log_pack_size(12LL);
          uint64_t v20 = (char *)&v30 - ((__chkstk_darwin(v19) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v21 = __error();
          uint64_t v22 = _os_log_pack_fill( v20,  v19,  *v21,  &_mh_execute_header,  "%{public}s nr_xpc_dictionary_create_reply called with NULL original");
          *(_DWORD *)uint64_t v22 = 136446210;
          *(void *)(v22 + 4) = "nr_xpc_dictionary_create_reply";
        }

        id v29 = sub_100011580();
        _NRLogAbortWithPack(v29, v20);
      }
    }
  }

void sub_1000136E0( uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v9 = a3;
  uint64_t v10 = -[NSString initWithFormat:arguments:](objc_alloc(&OBJC_CLASS___NSString), "initWithFormat:arguments:", v9, &a9);

  sub_10011BB18(0LL, 30101, &stru_1001B1528, v10);
}

void sub_100013750(_BYTE *a1)
{
  if (a1)
  {
    if ((nrSupportsPHSProxy() & 1) != 0)
    {
      objc_opt_self(&OBJC_CLASS___NRDKeyManager);
      if (qword_1001DCC18 != -1) {
        dispatch_once(&qword_1001DCC18, &stru_1001B0910);
      }
      id v2 = (id)qword_1001DCC10;
      if (!v2) {
        goto LABEL_53;
      }
      id v3 = v2;
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v2 + 2));
      if (!v3[10])
      {
        v3[10] = 1;
        if (v3[8] == 4)
        {
          sub_100143DD4((uint64_t)v3);
          if (v3[9])
          {
            v3[8] = 3;
            sub_100144044((uint64_t)v3);
          }
        }
      }

      int v4 = v3[8] & 0xFD;

      if (v4 == 1)
      {
        if (!a1[10])
        {
          if (qword_1001DC680 != -1) {
            dispatch_once(&qword_1001DC680, &stru_1001AE190);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC678, 0LL))
          {
            if (qword_1001DC680 != -1) {
              dispatch_once(&qword_1001DC680, &stru_1001AE190);
            }
            _NRLogWithArgs( qword_1001DC678,  0LL,  "%s%.30s:%-4d subscribing for PHS updates",  "",  "-[NROnDemandLinkSetupManager handleLaunchEventForPHS]",  426);
          }

          objc_opt_self(&OBJC_CLASS___NRLinkDirector);
          if (qword_1001DC878 != -1) {
            dispatch_once(&qword_1001DC878, &stru_1001AEED0);
          }
          id v5 = (id)qword_1001DC870;
          uint64_t v6 = v5;
          if (v5) {
            uint64_t v7 = (void *)*((void *)v5 + 6);
          }
          else {
            uint64_t v7 = 0LL;
          }
          id v8 = v7;
          id v9 = a1;
          if (v8)
          {
            uint64_t v10 = (void *)*((void *)v8 + 33);
            if (!v10)
            {
              uint64_t v11 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
              id v12 = (void *)*((void *)v8 + 33);
              *((void *)v8 + 33) = v11;

              uint64_t v10 = (void *)*((void *)v8 + 33);
            }

            [v10 addObject:v9];
            id v13 = sub_100146AFC();
            block = _NSConcreteStackBlock;
            uint64_t v31 = 3221225472LL;
            id v32 = sub_100142C8C;
            id v33 = &unk_1001B0720;
            id v34 = v9;
            id v35 = v8;
            dispatch_async((dispatch_queue_t)v13, &block);

            uint64_t v39 = 0LL;
            int v40 = &v39;
            uint64_t v41 = 0x3032000000LL;
            uint64_t v42 = sub_10013D160;
            id v43 = sub_10013D170;
            id v44 = 0LL;
            id v14 = *((id *)v8 + 22);
            v36[0] = _NSConcreteStackBlock;
            v36[1] = 3221225472LL;
            v36[2] = sub_100142CD4;
            v36[3] = &unk_1001B07E8;
            id v15 = v14;
            id v37 = v15;
            id v38 = &v39;
            if (sub_10013D090((uint64_t)&OBJC_CLASS___NRLinkManagerWiFi, v36))
            {
              if (qword_1001DCBF8 != -1) {
                dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
              }
              id v27 = (id)qword_1001DCBF0;
              char IsLevelEnabled = _NRLogIsLevelEnabled(v27, 17LL);

              if ((IsLevelEnabled & 1) != 0)
              {
                if (qword_1001DCBF8 != -1) {
                  dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                }
                id v29 = (id)qword_1001DCBF0;
                _NRLogWithArgs(v29, 17LL, "timed out fetching IR interface name");
              }
            }

            else
            {
              if (!v40[5])
              {
                v40[5] = (uint64_t)@"ir0";
                if (qword_1001DCBF8 != -1) {
                  dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                }
                id v16 = (id)qword_1001DCBF0;
                int v17 = _NRLogIsLevelEnabled(v16, 1LL);

                if (v17)
                {
                  if (qword_1001DCBF8 != -1) {
                    dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                  }
                  id v18 = (id)qword_1001DCBF0;
                  _NRLogWithArgs( v18,  1LL,  "%s%.30s:%-4d Failed to fetch IR interface name. Falling back to %@",  "",  "-[NRLinkManagerWiFi setupIRInterfaceConfigIfNeeded]",  2061LL,  v40[5],  block,  v31,  v32,  v33);
                }
              }

              id v19 = *((id *)v8 + 16);
              if (!v19) {
                goto LABEL_37;
              }
              uint64_t v20 = v19;
              uint64_t v21 = (void *)*((void *)v8 + 16);
              if (v21) {
                uint64_t v21 = (void *)v21[3];
              }
              uint64_t v22 = v21;
              unsigned __int8 v23 = [v22 isEqualToString:v40[5]];

              if ((v23 & 1) == 0)
              {
LABEL_37:
                __int128 v24 = objc_alloc(&OBJC_CLASS___NRSCDInterfaceConfig);
                id v25 = sub_10001DAD4((id *)&v24->super.isa, (void *)v40[5], 0);
                uint64_t v26 = (void *)*((void *)v8 + 16);
                *((void *)v8 + 16) = v25;

                if (*((void *)v8 + 16)) {
                  sub_10013D34C((uint64_t)v8);
                }
              }
            }

            _Block_object_dispose(&v39, 8);
          }

          a1[10] = 1;
        }
      }

      else
      {
LABEL_53:
        if (qword_1001DC680 != -1) {
          dispatch_once(&qword_1001DC680, &stru_1001AE190);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC678, 0LL))
        {
          if (qword_1001DC680 != -1) {
            dispatch_once(&qword_1001DC680, &stru_1001AE190);
          }
          _NRLogWithArgs( qword_1001DC678,  0LL,  "%s%.30s:%-4d ignoring processing launch event as device not classC unlocked");
        }
      }
    }

    else
    {
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC678, 0LL))
      {
        if (qword_1001DC680 != -1) {
          dispatch_once(&qword_1001DC680, &stru_1001AE190);
        }
        _NRLogWithArgs(qword_1001DC678, 0LL, "%s%.30s:%-4d PHS proxy not supported");
      }
    }
  }

void sub_100013D94( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
}

void sub_100013DAC(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v12 = (uint64_t)WeakRetained;
  if (WeakRetained && WeakRetained[6] == *(void *)(a1 + 32))
  {
    if (qword_1001DC680 != -1) {
      dispatch_once(&qword_1001DC680, &stru_1001AE190);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC678, 0LL))
    {
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      _NRLogWithArgs( qword_1001DC678,  0LL,  "%s%.30s:%-4d [Receiver] received request %@ with options %@",  "",  "-[NROnDemandLinkSetupManager startReceiver]_block_invoke",  285LL,  v8,  v9);
    }

    v30[0] = _NSConcreteStackBlock;
    v30[1] = 3221225472LL;
    v30[2] = sub_1000144DC;
    v30[3] = &unk_1001ADFB8;
    id v31 = v10;
    id v13 = objc_retainBlock(v30);
    id v14 = v8;
    id v29 = v9;
    id v15 = v13;
    id v16 = (void *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:@"relay-req"]);
    if (![v16 count]) {
      goto LABEL_35;
    }
    id v25 = (void *)objc_claimAutoreleasedReturnValue([v16 objectForKeyedSubscript:@"r"]);
    unsigned __int8 v27 = [v25 unsignedLongValue];
    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue([v16 objectForKeyedSubscript:@"reg"]);
    if (qword_1001DC680 != -1) {
      dispatch_once(&qword_1001DC680, &stru_1001AE190);
    }
    id v26 = v14;
    if (_NRLogIsLevelEnabled(qword_1001DC678, 0LL))
    {
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      id v17 = (id)qword_1001DC678;
      id v18 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
      id v19 = v18;
      if ((v27 & 1) != 0) {
        -[NSMutableString appendString:](v18, "appendString:", @"PHS,");
      }
      _NRLogWithArgs( v17,  0,  "%s%.30s:%-4d received request for internet relay (reason: %@ registered: %d)",  "",  "-[NROnDemandLinkSetupManager processIncomingRequest:options:response:]",  600,  v19,  [v28 BOOLValue]);
    }

    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v16 objectForKeyedSubscript:@"t"]);
    if ([v20 unsignedCharValue] == 6
      || (_os_feature_enabled_impl("terminus", "PHSProxyForceEnable") & 1) != 0)
    {
      if ((v27 & 1) == 0)
      {
LABEL_34:

        id v14 = v26;
LABEL_35:

        goto LABEL_36;
      }

      uint64_t v21 = objc_alloc_init(&OBJC_CLASS___NRPendingIncomingRequest);
      p_isa = (id *)&v21->super.isa;
      if (v21)
      {
        objc_storeStrong((id *)&v21->_request, a2);
        objc_storeStrong(p_isa + 2, a3);
        objc_setProperty_nonatomic_copy(p_isa, v23, v15, 24LL);
      }

      [*(id *)(v12 + 72) addObject:p_isa];
      sub_100013750((_BYTE *)v12);
      if (*(_BYTE *)(v12 + 11) || *(_BYTE *)(v12 + 12))
      {
        if (*(_BYTE *)(v12 + 13)) {
          sub_1000101B8(v12);
        }
      }
    }

    else
    {
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      id v24 = (id)qword_1001DC678;
      p_isa = (id *)createStringFromNRDeviceEndpointType([v20 unsignedCharValue]);
      _NRLogWithArgs( v24,  0LL,  "%s%.30s:%-4d ignoring internet relay request from unsupported device type %@",  "",  "-[NROnDemandLinkSetupManager processIncomingRequest:options:response:]",  605LL,  p_isa);
    }

    goto LABEL_34;
  }

void sub_10001421C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v3 = WeakRetained;
  if (WeakRetained && *((void *)WeakRetained + 6) == *(void *)(a1 + 32))
  {
    id v5 = WeakRetained;
    if (qword_1001DC680 != -1) {
      dispatch_once(&qword_1001DC680, &stru_1001AE190);
    }
    int IsLevelEnabled = _NRLogIsLevelEnabled(qword_1001DC678, 0LL);
    id v3 = v5;
    if (IsLevelEnabled)
    {
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      _NRLogWithArgs( qword_1001DC678,  0LL,  "%s%.30s:%-4d [Receiver] interrupted",  "",  "-[NROnDemandLinkSetupManager startReceiver]_block_invoke_3",  296);
      id v3 = v5;
    }
  }
}

void sub_1000142FC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v3 = WeakRetained;
  if (WeakRetained && *((void *)WeakRetained + 6) == *(void *)(a1 + 32))
  {
    id v5 = WeakRetained;
    if (qword_1001DC680 != -1) {
      dispatch_once(&qword_1001DC680, &stru_1001AE190);
    }
    int IsLevelEnabled = _NRLogIsLevelEnabled(qword_1001DC678, 0LL);
    id v3 = v5;
    if (IsLevelEnabled)
    {
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      _NRLogWithArgs( qword_1001DC678,  0LL,  "%s%.30s:%-4d [Receiver] invalidated",  "",  "-[NROnDemandLinkSetupManager startReceiver]_block_invoke_4",  303);
      id v3 = v5;
    }
  }
}

void sub_1000143DC(uint64_t a1, void *a2)
{
  id v5 = a2;
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  int v4 = WeakRetained;
  if (WeakRetained && WeakRetained[6] == *(id *)(a1 + 32))
  {
    if (qword_1001DC680 != -1) {
      dispatch_once(&qword_1001DC680, &stru_1001AE190);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC678, 0LL))
    {
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      _NRLogWithArgs( qword_1001DC678,  0LL,  "%s%.30s:%-4d [Receiver] activated with error %@",  "",  "-[NROnDemandLinkSetupManager startReceiver]_block_invoke_5",  310LL,  v5);
    }

    if (v5) {
      [v4[6] invalidate];
    }
  }
}

uint64_t sub_1000144DC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void sub_1000144F0(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  int v4 = WeakRetained;
  if (WeakRetained && *((_DWORD *)WeakRetained + 5) == a2)
  {
    uint64_t state64 = 0LL;
    uint32_t state = notify_get_state(a2, &state64);
    if (state)
    {
      uint32_t v10 = state;
      id v7 = sub_100011580();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 17LL);

      if (IsLevelEnabled)
      {
        id v9 = sub_100011580();
        _NRLogWithArgs( v9,  17LL,  "notify_get_state(%s, %d) failed: %u",  "com.apple.CoreTelephony.Slicing.LLPHS.State",  a2,  v10);
      }

      v4[15] = 0;
    }

    else
    {
      v4[15] = state64 == 2;
      if (qword_1001DC680 != -1) {
        dispatch_once(&qword_1001DC680, &stru_1001AE190);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC678, 0LL))
      {
        if (qword_1001DC680 != -1) {
          dispatch_once(&qword_1001DC680, &stru_1001AE190);
        }
        if (v4[15]) {
          uint64_t v6 = "en";
        }
        else {
          uint64_t v6 = "dis";
        }
        _NRLogWithArgs( qword_1001DC678,  0LL,  "%s%.30s:%-4d cellular slicing is %sabled",  "",  "-[NROnDemandLinkSetupManager monitorState]_block_invoke",  248,  v6);
      }

      if (!v4[15] && v4[13]) {
        [v4 didUpdatePHSState:0 llphsActive:0];
      }
    }
  }
}

void sub_100014684(uint64_t a1)
{
  id v2 = sub_1000128DC(*(void *)(a1 + 32));
  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  id v3 = v2;
  id v4 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v3,  "countByEnumeratingWithState:objects:count:",  &v25,  v29,  16LL);
  if (v4)
  {
    uint64_t v5 = *(void *)v26;
    do
    {
      uint64_t v6 = 0LL;
      do
      {
        if (*(void *)v26 != v5) {
          objc_enumerationMutation(v3);
        }
        id v7 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(*((void *)&v25 + 1) + 8LL * (void)v6));
        id v8 = v7;
        if (v7)
        {
          id v9 = *((id *)v7 + 16);
          if (v9)
          {
            uint32_t v10 = v9;
            id v11 = *((id *)v8 + 16);
            BOOL v12 = objc_msgSend(v11, "operationalScope", (void)v25) == 0;

            if (!v12)
            {
              if (v8[8])
              {
                if (v8[9])
                {
                  id v13 = *((id *)v8 + 16);
                  BOOL v14 = ((unint64_t)[v13 operationalScope] & 1) == 0;

                  if (!v14)
                  {
                    id v15 = *(_BYTE **)(a1 + 32);
                    if (v15)
                    {
                      if (v15[11] || v15[12]) {
                        goto LABEL_20;
                      }
                      sub_100013750(v15);
                    }

                    id v16 = *((id *)v8 + 6);
                    BOOL v17 = v16 == 0LL;

                    if (!v17)
                    {
                      id v18 = objc_alloc(&OBJC_CLASS___NRValidPeer);
                      id v19 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  *((unsigned __int16 *)v8 + 14)));
                      uint64_t v20 = sub_100010930((id *)&v18->super.isa, v19);

                      uint64_t v21 = *(void **)(a1 + 32);
                      if (v21) {
                        uint64_t v21 = (void *)v21[11];
                      }
                      uint64_t v22 = v21;
                      id v23 = *((id *)v8 + 6);
                      [v22 setObject:v20 forKeyedSubscript:v23];
                    }
                  }
                }
              }
            }
          }
        }

LABEL_20:
        uint64_t v6 = (char *)v6 + 1;
      }

      while (v4 != v6);
      id v24 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v3,  "countByEnumeratingWithState:objects:count:",  &v25,  v29,  16LL);
      id v4 = v24;
    }

    while (v24);
  }

  sub_1000125B4(*(void *)(a1 + 32));
}

    id v15 = 0LL;
    goto LABEL_11;
  }

  v35.receiver = (id)a1;
  v35.super_class = (Class)&OBJC_CLASS___NRLinkDirectorMessage;
  uint32_t v10 = (id *)objc_msgSendSuper2(&v35, "init");
  if (!v10)
  {
    uint64_t v20 = sub_100020F30();
    uint64_t v21 = _NRLogIsLevelEnabled(v20, 16LL);

    if (v21)
    {
      uint64_t v22 = sub_100020F30();
      _NRLogWithArgs( v22,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRLinkDirectorMessage initDirectorMessageWithNRUUID:messageLen:messageVersion:]",  400);
    }

    id v23 = _os_log_pack_size(12LL);
    a1 = (unint64_t)&v34 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v24 = __error();
    __int128 v25 = _os_log_pack_fill(a1, v23, *v24, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)__int128 v25 = 136446210;
    *(void *)(v25 + 4) = "-[NRLinkDirectorMessage initDirectorMessageWithNRUUID:messageLen:messageVersion:]";
    __int128 v26 = sub_100020F30();
    _NRLogAbortWithPack(v26, a1);
    goto LABEL_17;
  }

  id v11 = v10;
  objc_storeStrong(v10 + 4, a2);
  *((_DWORD *)v11 + 4) = a3;
  *((_BYTE *)v11 + 10) = a4;
  a1 = a3;
  BOOL v12 = calloc(1uLL, a3);
  if (!v12)
  {
LABEL_17:
    __int128 v27 = sub_100020F30();
    __int128 v28 = _NRLogIsLevelEnabled(v27, 16LL);

    if (v28)
    {
      id v29 = sub_100020F30();
      _NRLogWithArgs( v29,  16LL,  "%s%.30s:%-4d ABORTING: strict_calloc(%zu, %zu) failed",  "",  "strict_calloc",  108,  1uLL,  a1);
    }

    id v9 = (void *)_os_log_pack_size(32LL);
    id v30 = (char *)&v34 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v31 = __error();
    id v32 = _os_log_pack_fill( v30,  v9,  *v31,  &_mh_execute_header,  "%{public}s strict_calloc(%zu, %zu) failed");
    *(_DWORD *)id v32 = 136446722;
    *(void *)(v32 + 4) = "strict_calloc";
    *(_WORD *)(v32 + 12) = 2048;
    *(void *)(v32 + 14) = 1LL;
    *(_WORD *)(v32 + 22) = 2048;
    *(void *)(v32 + 24) = a1;
    id v33 = sub_100020F30();
    _NRLogAbortWithPack(v33, v30);
    goto LABEL_20;
  }

  v11[6] = v12;
  id v13 = *((unsigned __int8 *)v11 + 10);
  if (v13 == 1)
  {
    BOOL v14 = 8;
    goto LABEL_9;
  }

  if (v13 == 2)
  {
    BOOL v14 = 16;
LABEL_9:
    *((_WORD *)v11 + 6) = v14;
  }

  a1 = v11;
  id v15 = a1;
LABEL_11:

  return v15;
}

LABEL_21:
}

          ++*(void *)((char *)v5 + *v24);
LABEL_21:
          __int128 v25 = *(unsigned __int16 *)(v22 + 1);
          -[NSMutableData appendBytes:length:](v17, "appendBytes:length:");
          if (v18 != v65) {
            free(v18);
          }
          if (gNRPacketLoggingEnabled)
          {
            __int128 v27 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v26);
            LODWORD(v56) = _NRLogIsLevelEnabled(v27, 1LL);

            if ((_DWORD)v56)
            {
              __int128 v56 = bswap32(v25) >> 16;
              id v29 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v28);
              id v30 = [v5 copyDescription];
              StringFromNRTLVType = (void *)createStringFromNRTLVType(v23);
              _NRLogWithArgs( v29,  1LL,  "%s%.30s:%-4d %@: Sending packet [%@(%u/%u), %llu]",  "",  "NRLinkLoopInterfaceToQRInner",  1870LL,  v30,  StringFromNRTLVType,  v56,  v16,  -[NSMutableData length](v17, "length"));
            }
          }

          id v9 = v13;
          -[NSMutableArray addObject:](v13, "addObject:", v17);
          BOOL v12 = os_channel_get_next_slot(v58, v14, v62);
          if (v57) {
            *v57 += v21;
          }

          if (v12) {
            continue;
          }
          os_channel_advance_slot(v58, v14);
          os_channel_sync(*(void *)((char *)v5 + 295), 1LL);
          id v37 = v13;
          break;
      }

      break;
    }
  }

  else
  {
    uint64_t v41 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v11);
    uint64_t v42 = _NRLogIsLevelEnabled(v41, 16LL);

    if (v42)
    {
      id v44 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v43);
      id v45 = [v5 copyDescription];
      _NRLogWithArgs( v44,  16LL,  "%s%.30s:%-4d %@: Could not read any slot, when input available",  "",  "NRLinkLoopInterfaceToQRInner",  1881LL,  v45);
    }

    id v37 = 0LL;
  }

LABEL_39:
  return v37;
}

  if (*(_BYTE *)(v2 + 15)) {
    return 1LL;
  }
  id v30 = *(void **)(v2 + 48);
  if (v30)
  {
    [v30 unregisterNetworkAgent];
    id v31 = *(void **)(v2 + 48);
    *(void *)(v2 + 4_Block_object_dispose(va, 8) = 0LL;
  }

  id v32 = *(void **)(v2 + 72);
  if (v32) {
    [v32 unregisterNetworkAgent];
  }
  id v33 = *(void **)(v2 + 64);
  *(void *)(v2 + 64) = 0LL;

  id v34 = *(void **)(v2 + 72);
  *(void *)(v2 + 72) = 0LL;

  return *(_BYTE *)(v2 + 15) != 0;
}

  uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
  if (p_class_meths[333] != (__objc2_meth_list *)-1LL) {
    dispatch_once(&qword_1001DCA68, &stru_1001AFD30);
  }
  BOOL v17 = v157;
  id v43 = v36[332];
  id v44 = [v42 isEqual:v43];

  if (v44)
  {
    id v18 = v156;
    if (v157)
    {
      id v45 = mach_absolute_time();
      id v46 = *(unint64_t *)((char *)&self->_counterForDataStallRemediation + 7);
      if (v46)
      {
        *(void *)(v46 + 4_Block_object_dispose(va, 8) = v45;
        uint64_t v47 = *(id *)((char *)&self->_counterForDataStallRemediation + 7);
        if (v47) {
          ++v47[9];
        }
      }

      else
      {
        uint64_t v47 = 0LL;
      }

      uint64_t v48 = self;
      id v49 = v15;
      id v50 = v16;
      id v51 = 4LL;
      goto LABEL_58;
    }

    -[NRLink reportEvent:detailsFormat:](self, "reportEvent:detailsFormat:", 3024LL, @"ClassD %@", v15);
LABEL_112:
    id v61 = 0LL;
    goto LABEL_34;
  }

  id v62 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
  if (qword_1001DCA78 != -1) {
    dispatch_once(&qword_1001DCA78, &stru_1001AFD50);
  }
  id v63 = (id)qword_1001DCA70;
  id v64 = [v62 isEqual:v63];

  if (!v64)
  {
    __int128 v72 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
    if (qword_1001DCA88 != -1) {
      dispatch_once(&qword_1001DCA88, &stru_1001AFD70);
    }
    __int128 v73 = (id)qword_1001DCA80;
    __int128 v74 = [v72 isEqual:v73];

    if (!v74)
    {
      int v101 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
      uint64_t v102 = sub_10010BA18();
      int v103 = [v101 isEqual:v102];

      if (v103)
      {
        id v104 = mach_absolute_time();
        int v105 = *(unint64_t *)((char *)&self->_counterForDataStallRemediation + 7);
        if (v105)
        {
          *(void *)(v105 + 112) = v104;
          uint64_t v106 = *(id *)((char *)&self->_counterForDataStallRemediation + 7);
          if (v106) {
            ++v106[13];
          }
        }

        else
        {
          uint64_t v106 = 0LL;
        }

        objc_storeStrong((id *)((char *)&self->_ikeSessionClassA + 7), a4);
        sub_1000751DC((uint64_t)self);
        uint64_t v107 = [[NEIKEv2AuthenticationProtocol alloc] initWithMethod:2];
        uint64_t v108 = sub_10010BA18();
        id v61 = sub_10010C5AC(0, v108, v107);

        uint64_t v109 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, self->super._nrUUID);
        uint64_t v110 = sub_10012B0E8(v109);
        uint64_t v111 = (void *)objc_claimAutoreleasedReturnValue(v110);
        -[NEIKEv2SessionConfiguration setSharedSecret:](v61, "setSharedSecret:", v111);

        id v112 = (void *)objc_claimAutoreleasedReturnValue(-[NEIKEv2SessionConfiguration sharedSecret](v61, "sharedSecret"));
        v113 = sub_100070554();
        v114 = v113;
        if (!v112)
        {
          v151 = _NRLogIsLevelEnabled(v113, 17LL);

          if (v151)
          {
            v152 = sub_100070554();
            _NRLogWithArgs(v152, 17LL, "Missing out of band key for %@, %@", v109, self);
          }

          goto LABEL_72;
        }

        v115 = _NRLogIsLevelEnabled(v113, 0LL);

        if (v115)
        {
          v116 = sub_100070554();
          _NRLogWithArgs( v116,  0LL,  "%s%.30s:%-4d Receiving session for pairing with OOBK",  "",  "-[NRLinkBluetooth requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  9322);
        }

        __int128 v78 = 0;
        __int128 v76 = 1;
        __int128 v77 = 1;
      }

      else
      {
        v117 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
        v118 = sub_10010B9A4();
        v119 = [v117 isEqual:v118];

        if (!v119)
        {
          v134 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v120);
          v135 = _NRLogIsLevelEnabled(v134, 16LL);

          if (v135)
          {
            v137 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v136);
            v138 = -[NRLink copyDescription](self, "copyDescription");
            v139 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
            _NRLogWithArgs( v137,  16LL,  "%s%.30s:%-4d %@: Unrecognized IKEv2 identifier %@",  "",  "-[NRLinkBluetooth requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  9337LL,  v138,  v139);
          }

          id v61 = 0LL;
          id v18 = v156;
          goto LABEL_34;
        }

        __int128 v121 = mach_absolute_time();
        __int128 v122 = *(unint64_t *)((char *)&self->_counterForDataStallRemediation + 7);
        if (v122)
        {
          *(void *)(v122 + 112) = v121;
          __int128 v123 = *(id *)((char *)&self->_counterForDataStallRemediation + 7);
          if (v123) {
            ++v123[13];
          }
        }

        else
        {
          __int128 v123 = 0LL;
        }

        objc_storeStrong((id *)((char *)&self->_ikeSessionClassA + 7), a4);
        sub_1000751DC((uint64_t)self);
        __int128 v124 = [[NEIKEv2AuthenticationProtocol alloc] initWithNonStandardDigitalSignature:2];
        uint64_t v125 = sub_10010B9A4();
        id v61 = sub_10010C5AC(0, v125, v124);

        uint64_t v126 = sub_100070554();
        v127 = _NRLogIsLevelEnabled(v126, 0LL);

        if (v127)
        {
          v128 = sub_100070554();
          _NRLogWithArgs( v128,  0LL,  "%s%.30s:%-4d Receiving session for pairing from IDS",  "",  "-[NRLinkBluetooth requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  9335);
        }

        __int128 v77 = 0;
        __int128 v76 = 1;
        __int128 v78 = 1;
      }

      id v18 = v156;
      if (self->super._virtualInterface) {
        goto LABEL_60;
      }
      goto LABEL_94;
    }

    if (v157)
    {
      uint64_t v48 = self;
      id v49 = v15;
      id v50 = v16;
      id v51 = 1LL;
      id v18 = v156;
LABEL_58:
      __int128 v75 = sub_100074A48((NSMutableArray *)v48, v49, v50, v51, v18);
      id v61 = (NEIKEv2SessionConfiguration *)objc_claimAutoreleasedReturnValue(v75);
      goto LABEL_59;
    }

    -[NRLink reportEvent:detailsFormat:](self, "reportEvent:detailsFormat:", 3024LL, @"ClassA %@", v15);
LABEL_71:
    id v61 = 0LL;
LABEL_72:
    id v18 = v156;
    BOOL v17 = v157;
    goto LABEL_34;
  }

  id v18 = v156;
  if (!v157)
  {
    -[NRLink reportEvent:detailsFormat:](self, "reportEvent:detailsFormat:", 3024LL, @"ClassC %@", v15);
    goto LABEL_112;
  }

  objc_opt_self(&OBJC_CLASS___NRDKeyManager);
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  __int128 v65 = (id)qword_1001DCC10;
  __int128 v66 = v65;
  if (!v65) {
    goto LABEL_83;
  }
  dispatch_assert_queue_V2(*((dispatch_queue_t *)v65 + 2));
  if (!v66[10])
  {
    v66[10] = 1;
    if (v66[8] == 4)
    {
      sub_100143DD4((uint64_t)v66);
      if (v66[9])
      {
        v66[8] = 3;
        sub_100144044((uint64_t)v66);
      }
    }
  }

  if ((v66[8] & 0xFD) != 1)
  {
LABEL_83:
    -[NRLink reportEvent:detailsFormat:](self, "reportEvent:detailsFormat:", 3020LL, @"ClassC %@", v15);

    id v61 = 0LL;
    goto LABEL_34;
  }

  __int128 v67 = mach_absolute_time();
  __int128 v68 = *(unint64_t *)((char *)&self->_counterForDataStallRemediation + 7);
  if (v68)
  {
    *(void *)(v68 + 32) = v67;
    __int128 v69 = *(id *)((char *)&self->_counterForDataStallRemediation + 7);
    if (v69) {
      ++v69[8];
    }
  }

  else
  {
    __int128 v69 = 0LL;
  }

  __int128 v70 = sub_100074A48((NSMutableArray *)self, v15, v16, 3LL, v156);
  id v61 = (NEIKEv2SessionConfiguration *)objc_claimAutoreleasedReturnValue(v70);

LABEL_59:
  __int128 v76 = 0;
  __int128 v77 = 0;
  __int128 v78 = 0;
  if (!self->super._virtualInterface)
  {
LABEL_94:
    v129 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v71);
    v130 = _NRLogIsLevelEnabled(v129, 17LL);

    if (v130)
    {
      v132 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v131);
      v133 = -[NRLink copyDescription](self, "copyDescription");
      _NRLogWithArgs(v132, 17LL, "%@: virtualInterface is NULL", v133);
    }

    goto LABEL_72;
  }

    __int128 v25 = 0LL;
    goto LABEL_21;
  }

  if (v2 != 4)
  {
    if (qword_1001DC840 != -1) {
      dispatch_once(&qword_1001DC840, &stru_1001AEE08);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC838, 17LL))
    {
      if (qword_1001DC840 != -1) {
        dispatch_once(&qword_1001DC840, &stru_1001AEE08);
      }
      _NRLogWithArgs(qword_1001DC838, 17LL, "Cannot setup IKE callbacks for %@", String);
    }

    goto LABEL_20;
  }

  uint64_t v5 = *(void **)((char *)a1 + 1223);
  if (!v5)
  {
    uint64_t v6 = sub_100070554();
    id v7 = _NRLogIsLevelEnabled(v6, 17LL);

    if (v7)
    {
      id v8 = sub_100070554();
      _NRLogWithArgs(v8, 17LL, "%s called with null _ikeSessionClassD");
LABEL_24:

      __int128 v25 = 0LL;
      goto LABEL_21;
    }

    goto LABEL_20;
  }
}

  return v1;
}

        else {
          BOOL v17 = *(&off_1001ADE60 + (a2 - 1));
        }
        id v18 = (void *)_NRCopyLogObjectForNRUUID(v23[4], v16);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 0LL);

        if (IsLevelEnabled)
        {
          uint64_t v21 = (void *)_NRCopyLogObjectForNRUUID(v23[4], v20);
          uint64_t v22 = [v23 copyDescription];
          _NRLogWithArgs( v21,  0LL,  "%s%.30s:%-4d %@: pairing client state: %@ mask: %@",  "",  "-[NRLinkWired initiatePairing]_block_invoke",  236LL,  v22,  v17,  v15);
        }

        if (a2 == 5) {
          [v23 initiateConnection];
        }
        goto LABEL_29;
      }

    uint32_t v10 = 0LL;
    goto LABEL_14;
  }

  if (!v4) {
    goto LABEL_20;
  }
LABEL_13:
  uint32_t v10 = (void *)*((void *)v4 + 6);
LABEL_14:
  id v11 = v10;

  if (v11)
  {
    if (v4) {
      BOOL v12 = (void *)*((void *)v4 + 6);
    }
    else {
      BOOL v12 = 0LL;
    }
    id v13 = v12;
    nw_endpoint_set_device_id(endpoint, [v13 UTF8String]);
  }

  id v3 = endpoint;
LABEL_19:
}

    uint32_t v10 = 0LL;
LABEL_25:
    if (!v3) {
      goto LABEL_31;
    }
    if (v3[13])
    {
      sub_1000D3428(a1, v3);
      if (!v3[12])
      {
        uint64_t v22 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v15);
        id v23 = _NRLogIsLevelEnabled(v22, 1LL);

        if (v23)
        {
          id v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v15);
          _NRLogWithArgs( v24,  1LL,  "%s%.30s:%-4d Could not immediately complete request %@",  "",  "-[NRDDeviceConductor addRequest:]",  2700LL,  v3);
        }
      }
    }

    if (!v3[12])
    {
LABEL_31:
      __int128 v25 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v15);
      __int128 v26 = _NRLogIsLevelEnabled(v25, 1LL);

      if (v26)
      {
        __int128 v28 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v27);
        _NRLogWithArgs( v28,  1LL,  "%s%.30s:%-4d Adding new request: %@",  "",  "-[NRDDeviceConductor addRequest:]",  2705LL,  v3);
      }

      [*(id *)(a1 + 120) addObject:v3];
    }
  }
}
}

      id v34 = 0u;
      id v35 = 0u;
      id v32 = 0u;
      id v33 = 0u;
      id v23 = v18;
      id v24 = [v23 countByEnumeratingWithState:&v32 objects:v40 count:16];
      if (v24)
      {
        __int128 v25 = v24;
        __int128 v26 = *(void *)v33;
LABEL_23:
        __int128 v27 = 0LL;
        while (1)
        {
          if (*(void *)v33 != v26) {
            objc_enumerationMutation(v23);
          }
          __int128 v28 = *(void **)(*((void *)&v32 + 1) + 8 * v27);
          if ([v28 type] != 1)
          {
            (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
            if (*(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL)) {
              break;
            }
          }

          if (v25 == (id)++v27)
          {
            __int128 v25 = [v23 countByEnumeratingWithState:&v32 objects:v40 count:16];
            if (!v25) {
              goto LABEL_30;
            }
            goto LABEL_23;
          }
        }

        id v29 = objc_claimAutoreleasedReturnValue([v28 idsDeviceID]);
        id v30 = *(void *)(*(void *)(a1 + 48) + 8LL);
        id v31 = *(void **)(v30 + 40);
        *(void *)(v30 + 40) = v29;
      }

  __int128 v74 = 0u;
  __int128 v75 = 0u;
  __int128 v72 = 0u;
  __int128 v73 = 0u;
  id obj = v18;
  id v23 = [obj countByEnumeratingWithState:&v72 objects:v89 count:16];
  if (!v23) {
    goto LABEL_60;
  }
  id v24 = v23;
  __int128 v25 = *(void *)v73;
  while (2)
  {
    for (j = 0LL; j != v24; j = (char *)j + 1)
    {
      if (*(void *)v73 != v25) {
        objc_enumerationMutation(obj);
      }
      __int128 v27 = *(void **)(*((void *)&v72 + 1) + 8LL * (void)j);
      __int128 v28 = (void *)objc_claimAutoreleasedReturnValue([v27 authTagForData:*(void *)(a1 + 32) type:3 error:0]);
      if (sub_100105828(v28, *(void **)(a1 + 40)))
      {
        id v30 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v9 + 3), v29);
        id v31 = _NRLogIsLevelEnabled(v30, 1LL);

        if (v31)
        {
          id v32 = *((id *)v9 + 3);
          id v34 = (void *)_NRCopyLogObjectForNRUUID(v32, v33);
          _NRLogWithArgs( v34,  1LL,  "%s%.30s:%-4d found a matching identity %@",  "",  "-[NRDiscoveryClient verifyBLEAdvertisements:identifier:]_block_invoke",  1856LL,  v27);
        }

        id v35 = -[NSUUID initWithUUIDString:]( objc_alloc(&OBJC_CLASS___NSUUID),  "initWithUUIDString:",  *(void *)(a1 + 48));
        __int128 v36 = (void *)objc_claimAutoreleasedReturnValue([v27 idsDeviceID]);
        id v37 = v35;
        id v63 = v36;
        id v38 = v36;
        uint64_t v39 = v27;
        __int128 v70 = v19;
        if (v38)
        {
          __int128 v65 = v35;
          __int128 v67 = v39;
          __int128 v68 = v37;
          __int128 v69 = v19;
          if (v37)
          {
            id v87 = 0u;
            int v88 = 0u;
            id v85 = 0u;
            int v86 = 0u;
            int v40 = *((id *)v9 + 12);
            uint64_t v41 = [v40 countByEnumeratingWithState:&v85 objects:v91 count:16];
            if (v41)
            {
              uint64_t v42 = v41;
              id v43 = *(void *)v86;
              while (2)
              {
                id v44 = 0LL;
                do
                {
                  if (*(void *)v86 != v43) {
                    objc_enumerationMutation(v40);
                  }
                  id v45 = *(void **)(*((void *)&v85 + 1) + 8LL * (void)v44);
                  if (v45) {
                    id v46 = (void *)v45[8];
                  }
                  else {
                    id v46 = 0LL;
                  }
                  if ([v46 isEqualToString:v38])
                  {
                    uint64_t v48 = v45;

                    if (!v45) {
                      goto LABEL_48;
                    }
                    id v19 = v69;
                    goto LABEL_54;
                  }

                  id v44 = (char *)v44 + 1;
                }

                while (v42 != v44);
                uint64_t v47 = [v40 countByEnumeratingWithState:&v85 objects:v91 count:16];
                uint64_t v42 = v47;
                if (v47) {
                  continue;
                }
                break;
              }
            }

LABEL_48:
            id v49 = objc_alloc_init(&OBJC_CLASS___NRDeviceEndpoint);
            uint64_t v48 = v49;
            if (v49)
            {
              v49->_nw_interface_type_t type = *((_BYTE *)v9 + 18);
              objc_storeStrong((id *)&v49->_remoteIDSDeviceID, v63);
            }

            objc_opt_self(&OBJC_CLASS___NRLinkDirector);
            if (qword_1001DC878 != -1) {
              dispatch_once(&qword_1001DC878, &stru_1001AEED0);
            }
            id v50 = (id)qword_1001DC870;
            id v51 = (NSString *)sub_1000AFCFC(v50, 0LL);
            id v19 = v69;
            if (v48)
            {
              localIDSDeviceID = v48->_localIDSDeviceID;
              v48->_localIDSDeviceID = v51;

LABEL_54:
              objc_storeStrong((id *)&v48->_cbUUID, v65);
              __int128 v66 = 0;
              issuedFirstCallback = v48->_issuedFirstCallback;
            }

            else
            {

              issuedFirstCallback = 0;
              __int128 v66 = 1;
            }

            __int128 v53 = *((id *)v9 + 11);
            __int128 v54 = *((id *)v9 + 9);
            __int128 v55 = (dispatch_queue_s *)*((void *)v9 + 5);
            block[0] = _NSConcreteStackBlock;
            block[1] = 3221225472LL;
            block[2] = sub_100119140;
            block[3] = &unk_1001B0078;
            int v84 = issuedFirstCallback;
            __int128 v56 = v53;
            int v82 = v56;
            __int128 v57 = v48;
            id v81 = v57;
            __int128 v58 = v54;
            int v83 = v58;
            dispatch_async(v55, block);
            if ((v66 & 1) == 0) {
              v57->_issuedFirstCallback = 1;
            }

            uint64_t v39 = v67;
            id v37 = v68;
          }

          else
          {
            id v61 = sub_10010F4BC();
            id v62 = _NRLogIsLevelEnabled(v61, 17LL);

            id v37 = 0LL;
            if (!v62) {
              goto LABEL_59;
            }
            __int128 v57 = (NRDeviceEndpoint *)sub_10010F4BC();
            _NRLogWithArgs(v57, 17LL, "%s called with null cbUUID");
          }
        }

        else
        {
          __int128 v59 = sub_10010F4BC();
          __int128 v60 = _NRLogIsLevelEnabled(v59, 17LL);

          if (!v60) {
            goto LABEL_59;
          }
          __int128 v57 = (NRDeviceEndpoint *)sub_10010F4BC();
          _NRLogWithArgs(v57, 17LL, "%s called with null idsDeviceID");
        }

LABEL_59:
        goto LABEL_60;
      }
    }

    id v24 = [obj countByEnumeratingWithState:&v72 objects:v89 count:16];
    if (v24) {
      continue;
    }
    break;
  }

    uint32_t v10 = 0LL;
    goto LABEL_9;
  }

  v25.receiver = a1;
  v25.super_class = (Class)&OBJC_CLASS___NRDLDKeychainItemSecKey;
  uint64_t v5 = (char *)objc_msgSendSuper2(&v25, "init");
  if (!v5)
  {
    id v15 = sub_100121F34();
    id v16 = _NRLogIsLevelEnabled(v15, 16LL);

    uint64_t v6 = (const __CFDictionary *)"-[NRDLDKeychainItemSecKey initWithPublicSigningKeyData:]";
    if (v16)
    {
      BOOL v17 = sub_100121F34();
      _NRLogWithArgs( v17,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDLDKeychainItemSecKey initWithPublicSigningKeyData:]",  295);
    }

    id v4 = (const __CFData *)_os_log_pack_size(12LL);
    a1 = (char *)&error - (((unint64_t)v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v18 = __error();
    id v19 = _os_log_pack_fill(a1, v4, *v18, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)id v19 = 136446210;
    *(void *)(v19 + 4) = "-[NRDLDKeychainItemSecKey initWithPublicSigningKeyData:]";
    uint64_t v20 = sub_100121F34();
    _NRLogAbortWithPack(v20, a1);
    goto LABEL_15;
  }

  a1 = v5;
  v26[0] = kSecAttrKeyType;
  v26[1] = kSecAttrKeyClass;
  v27[0] = kSecAttrKeyTypeEd25519;
  v27[1] = kSecAttrKeyClassPublic;
  uint64_t v6 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v27,  v26,  2LL));
  error = 0LL;
  id v7 = SecKeyCreateWithData(v4, v6, &error);
  if (!v7)
  {
LABEL_15:
    uint64_t v21 = sub_100121F34();
    uint64_t v22 = _NRLogIsLevelEnabled(v21, 17LL);

    if (v22)
    {
      id v23 = sub_100121F34();
      _NRLogWithArgs(v23, 17LL, "Failed to ingest public signing key: %@", error);
    }

    if (error) {
      CFRelease(error);
    }
    uint32_t v10 = 0LL;
    goto LABEL_8;
  }

  id v9 = v7;
  if (error)
  {
    CFRelease(error);
    error = 0LL;
  }

  objc_setProperty_nonatomic(a1, v8, v9, 16LL);
  CFRelease(v9);
  a1[8] = 1;
  uint32_t v10 = a1;
LABEL_8:

LABEL_9:
  return v10;
}

    uint32_t v10 = 0LL;
    goto LABEL_9;
  }

  v25.receiver = a1;
  v25.super_class = (Class)&OBJC_CLASS___NRDLDKeychainItemSecKey;
  uint64_t v5 = (char *)objc_msgSendSuper2(&v25, "init");
  if (!v5)
  {
    id v15 = sub_100121F34();
    id v16 = _NRLogIsLevelEnabled(v15, 16LL);

    uint64_t v6 = (const __CFDictionary *)"-[NRDLDKeychainItemSecKey initWithPrivateSigningKeyData:]";
    if (v16)
    {
      BOOL v17 = sub_100121F34();
      _NRLogWithArgs( v17,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDLDKeychainItemSecKey initWithPrivateSigningKeyData:]",  235);
    }

    id v4 = (const __CFData *)_os_log_pack_size(12LL);
    a1 = (char *)&error - (((unint64_t)v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v18 = __error();
    id v19 = _os_log_pack_fill(a1, v4, *v18, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)id v19 = 136446210;
    *(void *)(v19 + 4) = "-[NRDLDKeychainItemSecKey initWithPrivateSigningKeyData:]";
    uint64_t v20 = sub_100121F34();
    _NRLogAbortWithPack(v20, a1);
    goto LABEL_15;
  }

  a1 = v5;
  v26[0] = kSecAttrKeyType;
  v26[1] = kSecAttrKeyClass;
  v27[0] = kSecAttrKeyTypeEd25519;
  v27[1] = kSecAttrKeyClassPrivate;
  uint64_t v6 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v27,  v26,  2LL));
  error = 0LL;
  id v7 = SecKeyCreateWithData(v4, v6, &error);
  if (!v7)
  {
LABEL_15:
    uint64_t v21 = sub_100121F34();
    uint64_t v22 = _NRLogIsLevelEnabled(v21, 17LL);

    if (v22)
    {
      id v23 = sub_100121F34();
      _NRLogWithArgs(v23, 17LL, "Failed to ingest private signing key: %@", error);
    }

    if (error) {
      CFRelease(error);
    }
    uint32_t v10 = 0LL;
    goto LABEL_8;
  }

  id v9 = v7;
  if (error)
  {
    CFRelease(error);
    error = 0LL;
  }

  objc_setProperty_nonatomic(a1, v8, v9, 16LL);
  CFRelease(v9);
  a1[8] = 1;
  uint32_t v10 = a1;
LABEL_8:

LABEL_9:
  return v10;
}

    uint32_t v10 = 0LL;
    goto LABEL_9;
  }

  v25.receiver = a1;
  v25.super_class = (Class)&OBJC_CLASS___NRDLDKeychainItemSecKey;
  uint64_t v5 = (char *)objc_msgSendSuper2(&v25, "init");
  if (!v5)
  {
    id v15 = sub_100121F34();
    id v16 = _NRLogIsLevelEnabled(v15, 16LL);

    uint64_t v6 = (const __CFDictionary *)"-[NRDLDKeychainItemSecKey initWithPrivateDHKeyData:]";
    if (v16)
    {
      BOOL v17 = sub_100121F34();
      _NRLogWithArgs( v17,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDLDKeychainItemSecKey initWithPrivateDHKeyData:]",  265);
    }

    id v4 = (const __CFData *)_os_log_pack_size(12LL);
    a1 = (char *)&error - (((unint64_t)v4 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v18 = __error();
    id v19 = _os_log_pack_fill(a1, v4, *v18, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)id v19 = 136446210;
    *(void *)(v19 + 4) = "-[NRDLDKeychainItemSecKey initWithPrivateDHKeyData:]";
    uint64_t v20 = sub_100121F34();
    _NRLogAbortWithPack(v20, a1);
    goto LABEL_15;
  }

  a1 = v5;
  v26[0] = kSecAttrKeyType;
  v26[1] = kSecAttrKeyClass;
  v27[0] = kSecAttrKeyTypeX25519;
  v27[1] = kSecAttrKeyClassPrivate;
  uint64_t v6 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v27,  v26,  2LL));
  error = 0LL;
  id v7 = SecKeyCreateWithData(v4, v6, &error);
  if (!v7)
  {
LABEL_15:
    uint64_t v21 = sub_100121F34();
    uint64_t v22 = _NRLogIsLevelEnabled(v21, 17LL);

    if (v22)
    {
      id v23 = sub_100121F34();
      _NRLogWithArgs(v23, 17LL, "Failed to ingest private DH key: %@", error);
    }

    if (error) {
      CFRelease(error);
    }
    uint32_t v10 = 0LL;
    goto LABEL_8;
  }

  id v9 = v7;
  if (error)
  {
    CFRelease(error);
    error = 0LL;
  }

  objc_setProperty_nonatomic(a1, v8, v9, 16LL);
  CFRelease(v9);
  a1[8] = 1;
  uint32_t v10 = a1;
LABEL_8:

LABEL_9:
  return v10;
}
}

    goto LABEL_9;
  }

LABEL_46:
    -[NSMutableString appendString:](v10, "appendString:", @"ipv6, ");
    pathFlags = self->_pathFlags;
    if ((pathFlags & 8) == 0)
    {
LABEL_22:
      if ((pathFlags & 0x10) == 0) {
        goto LABEL_23;
      }
      goto LABEL_48;
    }

LABEL_94:
      id v7 = v85;
LABEL_95:

LABEL_96:
      goto LABEL_97;
    }

    if (v12 == (id)2)
    {
      int v88 = 0u;
      int v89 = 0u;
      int v86 = 0u;
      id v87 = 0u;
      BOOL v17 = v5[5];
      __int128 v26 = [v17 countByEnumeratingWithState:&v86 objects:v90 count:16];
      if (v26)
      {
        __int128 v27 = v26;
        __int128 v28 = *(void *)v87;
LABEL_35:
        id v29 = 0LL;
        while (1)
        {
          if (*(void *)v87 != v28) {
            objc_enumerationMutation(v17);
          }
          id v30 = *(void *)(*((void *)&v86 + 1) + 8 * v29);
          if (v30) {
            id v31 = *(void **)(v30 + 327);
          }
          else {
            id v31 = 0LL;
          }
          id v32 = v31;
          if ([v32 isEqual:v13])
          {
            id v33 = [(id)v30 state];

            if (v33 != 255)
            {
              id v7 = v85;
              sub_100080D40((char *)v30, (char *)v85);

              goto LABEL_95;
            }
          }

          else
          {
          }

          if (v27 == (id)++v29)
          {
            __int128 v27 = [v17 countByEnumeratingWithState:&v86 objects:v90 count:16];
            if (!v27) {
              goto LABEL_46;
            }
            goto LABEL_35;
          }
        }
      }

      goto LABEL_46;
    }

    id v34 = v5[8];
    if (v34)
    {
      int v84 = v14;
      id v35 = v5[9];

      if (v35)
      {
        int v88 = 0u;
        int v89 = 0u;
        int v86 = 0u;
        id v87 = 0u;
        __int128 v36 = v5[9];
        id v37 = [v36 countByEnumeratingWithState:&v86 objects:v90 count:16];
        if (v37)
        {
          id v38 = v37;
          uint64_t v39 = 0LL;
          int v40 = *(void *)v87;
LABEL_52:
          uint64_t v42 = 0LL;
          while (1)
          {
            if (*(void *)v87 != v40) {
              objc_enumerationMutation(v36);
            }
            id v43 = *(void **)(*((void *)&v86 + 1) + 8 * v42);
            id v44 = (void *)objc_claimAutoreleasedReturnValue([v43 identifier]);
            id v45 = [v13 isEqual:v44];

            if (v45)
            {
              uint64_t v41 = (NSString *)objc_claimAutoreleasedReturnValue([v43 name]);

              uint64_t v39 = v41;
              if (-[NSString length](v41, "length")) {
                break;
              }
            }

            if (v38 == (id)++v42)
            {
              id v38 = [v36 countByEnumeratingWithState:&v86 objects:v90 count:16];
              uint64_t v41 = v39;
              if (!v38) {
                break;
              }
              goto LABEL_52;
            }
          }
        }

        else
        {
          uint64_t v41 = 0LL;
        }

        id v7 = v85;
      }

      else
      {
        uint64_t v41 = 0LL;
      }

      BOOL v14 = v84;
    }

    else
    {
      uint64_t v41 = 0LL;
    }

    if (!-[NSString length](v41, "length"))
    {
      id v46 = objc_alloc(&OBJC_CLASS___NSString);
      [v13 getUUIDBytes:&v91];
      id v92 = v91;
      uint64_t v47 = veor_s8(*(int8x8_t *)v91.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v91, v91, 8uLL));
      v92.i32[0] = v47.i32[0] ^ v47.i32[1];
      uint64_t v48 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v92, 16LL);
      id v49 = (void *)objc_claimAutoreleasedReturnValue(-[NSData base64EncodedStringWithOptions:](v48, "base64EncodedStringWithOptions:", 0LL));
      id v50 = (void *)objc_claimAutoreleasedReturnValue([v49 substringToIndex:6]);

      id v51 = -[NSString initWithFormat:](v46, "initWithFormat:", @"?%@", v50);
      uint64_t v41 = v51;
    }

    unsigned int v52 = objc_loadWeakRetained(v5 + 15);
    __int128 v53 = *((id *)v14 + 4);
    [v52 pipeDidConnectForNRUUID:1 nrUUID:v53];

    __int128 v54 = objc_alloc(&OBJC_CLASS___NRLinkBluetooth);
    __int128 v55 = v5[3];
    __int128 v56 = *((id *)v14 + 4);
    __int128 v57 = sub_10009E564((char *)v54, v55, v5, v56, v7, v41);

    if (!v57)
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      id v81 = (id)qword_1001DC720;
      int v82 = _NRLogIsLevelEnabled(v81, 16LL);

      if (v82)
      {
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        int v83 = (id)qword_1001DC720;
        _NRLogWithArgs( v83,  16LL,  "%s%.30s:%-4d Failed to create link for device %@ with pipe %@",  "",  "-[NRLinkManagerBluetooth pipeisAvailable:]",  969LL,  v14,  v85);
      }

      id v63 = (NRCBScalablePipeConnectionState *)objc_claimAutoreleasedReturnValue([v85 description]);
      [v5 reportEvent:3101 details:v63];
      goto LABEL_93;
    }

    __int128 v58 = v5[17];
    if (!v58)
    {
      __int128 v59 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      __int128 v60 = v5[17];
      v5[17] = v59;

      __int128 v58 = v5[17];
    }

    id v61 = v58;
    id v62 = *((id *)v14 + 4);
    id v63 = (NRCBScalablePipeConnectionState *)objc_claimAutoreleasedReturnValue([v61 objectForKeyedSubscript:v62]);

    if (v63)
    {
      id v64 = v14;
      if (v63->_state == 2)
      {
        timeOfDisconnect = v63->_timeOfDisconnect;
        __int128 v66 = mach_continuous_time();
        __int128 v69 = 0LL;
        if (timeOfDisconnect)
        {
          __int128 v70 = v66 >= timeOfDisconnect;
          __int128 v71 = v66 - timeOfDisconnect;
          if (v71 != 0 && v70)
          {
            if (qword_1001DC9F0 != -1) {
              dispatch_once(&qword_1001DC9F0, &stru_1001AFB98);
            }
            LODWORD(v67) = dword_1001DC9F8;
            LODWORD(v6_Block_object_dispose(va, 8) = *(_DWORD *)algn_1001DC9FC;
            __int128 v69 = (unint64_t)((double)v71 * (0.000000001 * (double)v67) / (double)v68);
          }
        }

        __int128 v72 = objc_alloc_init(&OBJC_CLASS___NRAnalyticsLinkManagerBluetooth);
        __int128 v73 = v72;
        if (v72) {
          v72->_pipeDisconnectedDuration = v69;
        }
        -[NRAnalyticsLinkManagerBluetooth submit](v72, "submit");
      }

      else
      {
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        __int128 v73 = (NRAnalyticsLinkManagerBluetooth *)(id)qword_1001DC720;
        _NRLogWithArgs(v73, 17LL, "invalid pipe state %@", v63);
      }

      BOOL v14 = v64;
    }

    else
    {
      id v63 = objc_alloc_init(&OBJC_CLASS___NRCBScalablePipeConnectionState);
      if (!v63)
      {
        mach_continuous_time();
LABEL_92:
        __int128 v74 = v5[17];
        __int128 v75 = *((id *)v14 + 4);
        [v74 setObject:v63 forKeyedSubscript:v75];

LABEL_93:
        goto LABEL_94;
      }
    }

  id v37 = -2005LL;
LABEL_62:

  return v37;
}

    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v33 = (id)qword_1001DC870;
    if (string)
    {
      id v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", string));
      if (v11) {
        goto LABEL_50;
      }
    }

    else
    {
      id v34 = 0LL;
      if (v11)
      {
LABEL_50:
        id v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v11));
        if (v14) {
          goto LABEL_51;
        }
        goto LABEL_58;
      }
    }

    id v35 = 0LL;
    if (v14)
    {
LABEL_51:
      __int128 v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v14));
      sub_1000AF07C((uint64_t)v33, v5, v34, v35, v36);

      if (!v11)
      {
LABEL_53:
        if (string) {

        }
        id v37 = 0LL;
        goto LABEL_67;
      }

                unsigned int v52 = 0LL;
LABEL_47:

                if (v52)
                {
                  id v62 = objc_alloc(&OBJC_CLASS___NEPathControllerNetworkAgent);
                  id v63 = [[NWInterface alloc] initWithInterfaceName:v52];
                  id v64 = -[NEPathControllerNetworkAgent initWithAdvisoryInterface:advisoryMode:]( v62,  "initWithAdvisoryInterface:advisoryMode:",  v63,  2LL);
                  __int128 v65 = *(void **)(v2 + 64);
                  *(void *)(v2 + 64) = v64;

                  __int128 v66 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
                  [*(id *)(v2 + 64) setAgentUUID:v66];

                  [*(id *)(v2 + 64) setAgentDescription:@"Fallback from any interface to CompanionProxy"];
                  [*(id *)(v2 + 64) setActive:1];
                  [*(id *)(v2 + 64) setVoluntary:0];
                  [*(id *)(v2 + 64) setUserActivated:0];
                  [*(id *)(v2 + 64) setKernelActivated:0];
                  __int128 v67 = -[NWNetworkAgentRegistration initWithNetworkAgentClass:]( objc_alloc(&OBJC_CLASS___NWNetworkAgentRegistration),  "initWithNetworkAgentClass:",  objc_opt_class(*(void *)(v2 + 64)));
                  __int128 v68 = *(void **)(v2 + 72);
                  *(void *)(v2 + 72) = v67;

                  if ([*(id *)(v2 + 72) registerNetworkAgent:*(void *)(v2 + 64)])
                  {
                    __int128 v70 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  5LL,  0LL));
                    __int128 v71 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v2 + 64) agentUUID]);
                    [v70 setNetworkAgentUUID:v71];

                    __int128 v72 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  6LL,  6LL));
                    __int128 v73 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v2 + 64) agentUUID]);
                    [v72 setNetworkAgentUUID:v73];

                    uint64_t v108 = v70;
                    v110[0] = v70;
                    v110[1] = v72;
                    __int128 v74 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v110,  2LL));
                    __int128 v75 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v74));

                    __int128 v76 = objc_alloc(&OBJC_CLASS___NEPolicy);
                    __int128 v77 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
                    uint64_t v109 = v77;
                    __int128 v78 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v109,  1LL));
                    __int128 v79 = [v76 initWithOrder:10 result:v75 conditions:v78];

                    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                    if (qword_1001DCB60 != -1) {
                      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                    }
                    __int128 v80 = (id)qword_1001DCB58;
                    id v81 = sub_100120E44((uint64_t)v80, *(void **)(v2 + 88), v79);

                    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                    if (qword_1001DCB60 != -1) {
                      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                    }
                    int v82 = v108;
                    int v83 = (id)qword_1001DCB58;
                    int v84 = (id *)v83;
                    if (v83)
                    {
                      dispatch_assert_queue_V2(*((dispatch_queue_t *)v83 + 1));
                      if (([v84[2] apply] & 1) == 0) {
                        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v85,  v86,  v87,  v107);
                      }
                    }

                    LOBYTE(v82) = 1;
                  }

                  else
                  {
                    int v91 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v2 + 32), v69);
                    id v92 = _NRLogIsLevelEnabled(v91, 16LL);

                    if (v92)
                    {
                      v94 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v2 + 32), v93);
                      _NRLogWithArgs( v94,  16LL,  "%s%.30s:%-4d unable to register path controller agent",  "",  "-[NRCompanionProxyAgent registerPathControllerFallback]",  157);
                    }

                    LOBYTE(v82) = 0;
                  }

  -[NSMutableArray addObject:](v8, "addObject:", @"PluggedIn");
  if ((reason & 0x2000000) == 0)
  {
LABEL_21:
    if ((reason & 0x4000000) == 0) {
      goto LABEL_22;
    }
    goto LABEL_48;
  }

  -[NSMutableArray addObject:](v3, "addObject:", @"Rst");
  if ((a1 & 0x400000000000000LL) == 0)
  {
LABEL_21:
    if ((a1 & 0x800000000000000LL) == 0) {
      goto LABEL_22;
    }
    goto LABEL_48;
  }

          break;
        default:
          goto LABEL_41;
      }
    }
  }

  id v31 = 1;
LABEL_54:

LABEL_55:
  uint64_t v22 = v31;
LABEL_56:

  return v22;
}

LABEL_47:
    -[NSMutableString appendString:](v10, "appendString:", @"expensive, ");
    if ((self->_pathFlags & 0x10) == 0)
    {
LABEL_23:
      if (!self->_isImmediate)
      {
LABEL_25:
        if ((self->_pathFlags & 0x20) != 0) {
          -[NSMutableString appendString:](v10, "appendString:", @"roaming, ");
        }
        if (*(_OWORD *)&self->_estimatedUploadThroughput != 0LL) {
          -[NSMutableString appendFormat:]( v10,  "appendFormat:",  @"%llu/%llu, ",  self->_estimatedUploadThroughput,  self->_estimatedDownloadThroughput);
        }
        -[NSMutableString appendString:](v10, "appendString:", @"[");
        id v23 = 0u;
        id v24 = 0u;
        uint64_t v21 = 0u;
        uint64_t v22 = 0u;
        resolverConfigs = self->_resolverConfigs;
        goto LABEL_30;
      }

    goto LABEL_48;
  }

  id v30 = sub_10004579C();
  id v31 = _NRLogIsLevelEnabled(v30, 17LL);

  if (v31)
  {
    id v32 = sub_10004579C();
    _NRLogWithArgs( v32,  17LL,  "%s called with null handlerFunction",  "-[TerminusdXPCServer registerHandlerFunction:type:allowedEntitlementGroup:]");
  }

  -[NSMutableArray addObject:](v8, "addObject:", @"NotPluggedIn");
  if ((reason & 0x4000000) == 0)
  {
LABEL_22:
    if ((reason & 0x8000000) == 0) {
      goto LABEL_23;
    }
    goto LABEL_49;
  }

  -[NSMutableArray addObject:](v3, "addObject:", @"UnexpLnkSwtch");
  if ((a1 & 0x800000000000000LL) == 0)
  {
LABEL_22:
    if ((a1 & 0x1000000000000000LL) == 0) {
      goto LABEL_23;
    }
    goto LABEL_49;
  }

LABEL_48:
    -[NSMutableString appendString:](v10, "appendString:", @"constrained, ");
    if (!self->_isImmediate) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }

  -[NSMutableString appendString:](v10, "appendString:", @"[");
  resolverConfigs = 0LL;
  id v23 = 0u;
  id v24 = 0u;
  uint64_t v21 = 0u;
  uint64_t v22 = 0u;
LABEL_30:
  id v13 = resolverConfigs;
  BOOL v14 = -[NSArray countByEnumeratingWithState:objects:count:]( v13,  "countByEnumeratingWithState:objects:count:",  &v21,  v25,  16LL);
  if (v14)
  {
    id v15 = v14;
    id v16 = *(void *)v22;
    do
    {
      for (i = 0LL; i != v15; i = (char *)i + 1)
      {
        if (*(void *)v22 != v16) {
          objc_enumerationMutation(v13);
        }
        -[NSMutableString appendFormat:]( v10,  "appendFormat:",  @"%@, ",  *(void *)(*((void *)&v21 + 1) + 8LL * (void)i));
      }

      id v15 = -[NSArray countByEnumeratingWithState:objects:count:]( v13,  "countByEnumeratingWithState:objects:count:",  &v21,  v25,  16LL);
    }

    while (v15);
  }

  -[NSMutableString appendString:](v10, "appendString:", @"]");
  if (self && self->_wifiSSIDData)
  {
    id v18 = -[NSString initWithData:encoding:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithData:encoding:",  self->_wifiSSIDData,  4LL);
    id v19 = v18;
    uint64_t v20 = @"<unavailable>";
    if (v18) {
      uint64_t v20 = (const __CFString *)v18;
    }
    -[NSMutableString appendFormat:](v10, "appendFormat:", @", wifi %@", v20);
  }

  -[NSMutableString appendString:](v10, "appendString:", @"]");

  return v10;
}

        id v43 = *(id *)(v8 + 327);
        if (v53)
        {
          id v44 = v53->_requestedLinkRequirements;
          id v45 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](v44, "objectForKeyedSubscript:", v43));
          sub_10002D2D0((id *)&v53->super.super.isa, v45, v43);

          id v46 = v53->super._queue;
        }

        else
        {
          id v51 = (void *)objc_claimAutoreleasedReturnValue([0 objectForKeyedSubscript:v43]);
          sub_10002D2D0(0LL, v51, v43);

          id v46 = 0LL;
        }

        uint64_t v47 = v46;
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472LL;
        block[2] = sub_10002DDD0;
        block[3] = &unk_1001B0720;
        __int128 v55 = v8;
        __int128 v56 = v53;
        dispatch_async(v47, block);

        id v4 = v52;
      }

      else
      {
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC720, 17LL))
        {
          if (qword_1001DC728 != -1) {
            dispatch_once(&qword_1001DC728, &stru_1001AE510);
          }
          _NRLogWithArgs(qword_1001DC720, 17LL, "Got bad link %@", v8);
        }
      }
    }
  }

  else
  {
    uint64_t v48 = sub_100024E28();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v48, 17LL);

    if (IsLevelEnabled)
    {
      id v50 = sub_100024E28();
      _NRLogWithArgs(v50, 17LL, "%s called with null link", "-[NRLinkManagerBluetooth linkIsReady:]");
    }
  }
}

  if (!*(void *)(v1 + 48))
  {
    if (qword_1001DC728 != -1) {
      dispatch_once(&qword_1001DC728, &stru_1001AE510);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC720, 0LL))
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      _NRLogWithArgs( qword_1001DC720,  0LL,  "%s%.30s:%-4d initializing CBScalablePipeManager",  "",  "-[NRLinkManagerBluetooth setup]",  521);
    }

    id v43 = objc_alloc(&OBJC_CLASS___CBScalablePipeManager);
    id v44 = *(id *)(v1 + 24);
    id v45 = -[CBScalablePipeManager initWithDelegate:queue:](v43, "initWithDelegate:queue:", v1, v44);
    id v46 = *(void **)(v1 + 48);
    *(void *)(v1 + 4_Block_object_dispose(va, 8) = v45;
  }

    id v16 = -2005LL;
    goto LABEL_49;
  }

  uint64_t v6 = uuid;
  if (uuid_is_null(uuid))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      id v8 = (id)qword_1001DC770;
      if (v4)
      {
        id v9 = (void *)v4[4];
        if (!v9)
        {
          uint32_t v10 = (_xpc_connection_s *)objc_getProperty(v4, v7, 8LL, 1);
          pid = xpc_connection_get_pid(v10);
          BOOL v12 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
          bzero(v52, 0x400uLL);
          if ((int)pid >= 1 && proc_pidpath(pid, v52, 0x400u) >= 1 && v52[0])
          {
            id v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v52,  pid);

            BOOL v12 = v13;
          }

          BOOL v14 = (void *)v4[4];
          v4[4] = v12;

          id v9 = (void *)v4[4];
        }

        id v15 = v9;
      }

      else
      {
        id v15 = 0LL;
      }

      _NRLogWithArgs(v8, 16LL, "%s%.30s:%-4d All-zero NRUUID from %@", "", "handleMeasureBTLatency", 1300LL, v15);
      goto LABEL_19;
    }

    goto LABEL_48;
  }

  BOOL v17 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v6);
  if (!v17)
  {
    int v40 = sub_10004579C();
    uint64_t v41 = _NRLogIsLevelEnabled(v40, 16LL);

    if (v41)
    {
      uint64_t v42 = sub_10004579C();
      _NRLogWithArgs( v42,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "handleMeasureBTLatency",  1304);
    }

    id v4 = (void *)_os_log_pack_size(12LL);
    id v18 = (NSUUID *)((char *)&v47[-1] - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL));
    id v43 = __error();
    id v44 = _os_log_pack_fill( v18,  v4,  *v43,  &_mh_execute_header,  "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    *(_DWORD *)id v44 = 136446210;
    *(void *)(v44 + 4) = "handleMeasureBTLatency";
    id v45 = sub_10004579C();
    _NRLogAbortWithPack(v45, v18);
    goto LABEL_53;
  }

  id v18 = v17;
  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  if (qword_1001DC778 != -1) {
LABEL_53:
  }
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (p_class_meths[239] != (__objc2_meth_list *)-1LL) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    uint64_t v20 = (id)qword_1001DC770;
    if (v4)
    {
      uint64_t v21 = (void *)v4[4];
      if (!v21)
      {
        uint64_t v22 = (_xpc_connection_s *)objc_getProperty(v4, v19, 8LL, 1);
        id v23 = xpc_connection_get_pid(v22);
        id v24 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v23);
        bzero(v52, 0x400uLL);
        if ((int)v23 >= 1 && proc_pidpath(v23, v52, 0x400u) >= 1 && v52[0])
        {
          __int128 v25 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v52,  v23);

          id v24 = v25;
        }

        __int128 v26 = (void *)v4[4];
        v4[4] = v24;

        uint64_t v21 = (void *)v4[4];
      }

      __int128 v27 = v21;
    }

    else
    {
      __int128 v27 = 0LL;
    }

    _NRLogWithArgs( v20,  0LL,  "%s%.30s:%-4d Received MeasureBTLatency %@ from %@",  "",  "handleMeasureBTLatency",  1305LL,  v18,  v27);
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  __int128 v28 = (id *)(id)qword_1001DC870;
  v47[0] = _NSConcreteStackBlock;
  v47[1] = 3221225472LL;
  uint64_t v48 = sub_1000588C8;
  id v49 = &unk_1001AE830;
  id v50 = v18;
  id v51 = v4;
  id v29 = v18;
  id v30 = v47;
  if (v28)
  {
    id v31 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v31);

    id v32 = (dispatch_queue_t *)objc_claimAutoreleasedReturnValue([v28[27] objectForKeyedSubscript:v29]);
    if (v32)
    {
      id v33 = v30;
      dispatch_assert_queue_V2(v32[13]);
      dispatch_assert_queue_V2(v32[13]);
      id v34 = sub_1000D8B90((uint64_t)v32, 1, 0);
      if (v34 && (id v35 = objc_opt_class(&OBJC_CLASS___NRLinkBluetooth), (objc_opt_isKindOfClass(v34, v35) & 1) != 0)) {
        sub_10009EC60((uint64_t)v34, v33);
      }
      else {
        v48((uint64_t)v33, 0LL);
      }
    }

    else
    {
      v48((uint64_t)v30, 0LL);
    }
  }

  id v16 = -2000LL;
LABEL_49:

  return v16;
}

  -[NSMutableArray addObject:](v8, "addObject:", @"BatteryPercentagePoor");
  if ((reason & 0x8000000) == 0)
  {
LABEL_23:
    if ((reason & 0x10000000) == 0) {
      goto LABEL_24;
    }
    goto LABEL_50;
  }

  -[NSMutableArray addObject:](v3, "addObject:", @"Inactv");
  if ((a1 & 0x1000000000000000LL) == 0)
  {
LABEL_23:
    if ((a1 & 0x2000000000000000LL) == 0) {
      goto LABEL_24;
    }
    goto LABEL_50;
  }

  -[NRBabelNeighbor sendTLVs:](v28, "sendTLVs:", v91);
  if ((v20 & 1) != 0) {
    -[NRBabelNeighbor enqueueNextIHU](v28, "enqueueNextIHU");
  }
  if ((v19 & 1) != 0) {
    -[NRBabelNeighbor enqueueNextUpdate](v28, "enqueueNextUpdate");
  }

LABEL_71:
  if (-[NSMutableArray count](v28->_pendingOutgoingPackets, "count"))
  {
    id v51 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableArray objectAtIndexedSubscript:]( v28->_pendingOutgoingPackets,  "objectAtIndexedSubscript:",  0LL));
    [v51 maxTime];
    __int128 v53 = v52;

    __int128 v54 = (void *)objc_claimAutoreleasedReturnValue( -[NSMutableArray objectAtIndexedSubscript:]( v28->_pendingOutgoingPackets,  "objectAtIndexedSubscript:",  0LL));
    [v54 minTime];
    __int128 v56 = v55;

    int v99 = 0u;
    id v100 = 0u;
    int v97 = 0u;
    uint64_t v98 = 0u;
    __int128 v57 = v28->_pendingOutgoingPackets;
    __int128 v58 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v57,  "countByEnumeratingWithState:objects:count:",  &v97,  v115,  16LL);
    if (v58)
    {
      __int128 v59 = v58;
      __int128 v60 = *(void *)v98;
      do
      {
        for (m = 0LL; m != v59; m = (char *)m + 1)
        {
          if (*(void *)v98 != v60) {
            objc_enumerationMutation(v57);
          }
          id v62 = *(void **)(*((void *)&v97 + 1) + 8LL * (void)m);
          [v62 maxTime];
          if (v63 < v53)
          {
            [v62 maxTime];
            __int128 v53 = v64;
            [v62 minTime];
            __int128 v56 = v65;
          }
        }

        __int128 v59 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v57,  "countByEnumeratingWithState:objects:count:",  &v97,  v115,  16LL);
      }

      while (v59);
    }

    int v95 = 0u;
    id v96 = 0u;
    uint64_t v93 = 0u;
    v94 = 0u;
    __int128 v66 = v92->_pendingOutgoingPackets;
    __int128 v67 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v66,  "countByEnumeratingWithState:objects:count:",  &v93,  v114,  16LL);
    if (v67)
    {
      __int128 v68 = v67;
      __int128 v69 = *(void *)v94;
      do
      {
        for (n = 0LL; n != v68; n = (char *)n + 1)
        {
          if (*(void *)v94 != v69) {
            objc_enumerationMutation(v66);
          }
          __int128 v71 = *(void **)(*((void *)&v93 + 1) + 8LL * (void)n);
          [v71 minTime];
          if (v56 < v72)
          {
            [v71 minTime];
            if (v73 < v53)
            {
              [v71 minTime];
              __int128 v56 = v74;
            }
          }
        }

        __int128 v68 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v66,  "countByEnumeratingWithState:objects:count:",  &v93,  v114,  16LL);
      }

      while (v68);
    }

    __int128 v75 = v92->_pendingOutgoingTimer;
    if (v56 >= v53)
    {
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      if (_NRLogIsLevelEnabled(p_class_meths[277], 17LL))
      {
        if (qword_1001DC8B0 != -1) {
          dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
        }
        __int128 v76 = p_class_meths[277];
        __int128 v77 = (void *)objc_claimAutoreleasedReturnValue( +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  v56));
        __int128 v78 = (void *)objc_claimAutoreleasedReturnValue( +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  v53));
        _NRLogWithArgs(v76, 17LL, "minTime %@ >= maxTime %@", v77, v78);
      }

      __int128 v53 = v56 + 0.001;
    }

    __int128 v79 = (v53 - v56) * 2.32830644e-10 * (double)arc4random();
    __int128 v80 = v79 + v56;
    when.tv_sec = vcvtmd_s64_f64(v80) + 978307200;
    when.tv_nsec = (uint64_t)((v80 - floor(v80)) * 1000000000.0);
    id v81 = dispatch_walltime(&when, 0LL);
    int v82 = (unint64_t)(fmin(v79, v53 - v80) * 1000000000.0);
    if (qword_1001DC8B0 != -1) {
      dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
    }
    if (_NRLogIsLevelEnabled(p_class_meths[277], 2LL))
    {
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      int v83 = p_class_meths[277];
      int v84 = (void *)objc_claimAutoreleasedReturnValue( +[NSDate dateWithTimeIntervalSinceReferenceDate:]( &OBJC_CLASS___NSDate,  "dateWithTimeIntervalSinceReferenceDate:",  v80));
      +[NSDate timeIntervalSinceReferenceDate](&OBJC_CLASS___NSDate, "timeIntervalSinceReferenceDate");
      _NRLogWithArgs( v83,  2LL,  "%s%.30s:%-4d rescheduling timer %@ for %@, which is in %fs leeway %llums",  "",  "rescheduleTimer",  1290LL,  v75,  v84,  v80 - v85,  v82 / 0xF4240);
    }

    dispatch_source_set_timer(v75, v81, 0xFFFFFFFFFFFFFFFFLL, v82);
  }

LABEL_107:
}

  sub_100141BD4((id)a1);
}

void sub_100014E5C(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  id v2 = (void *)qword_1001DC688;
  qword_1001DC688 = (uint64_t)v1;
}

_BYTE *sub_100014E8C(_BYTE *a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    v16.receiver = a1;
    v16.super_class = (Class)&OBJC_CLASS___NRNetInfo;
    id v5 = objc_msgSendSuper2(&v16, "init");
    if (!v5)
    {
      id v7 = sub_100014FF0();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 16LL);

      if (IsLevelEnabled)
      {
        id v9 = sub_100014FF0();
        _NRLogWithArgs(v9, 16LL, "%s%.30s:%-4d ABORTING: [super init] failed", "", "-[NRNetInfo initWithQueue:]", 95);
      }

      uint64_t v10 = _os_log_pack_size(12LL);
      id v11 = (char *)&v15 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      BOOL v12 = __error();
      uint64_t v13 = _os_log_pack_fill(v11, v10, *v12, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v13 = 136446210;
      *(void *)(v13 + 4) = "-[NRNetInfo initWithQueue:]";
      id v14 = sub_100014FF0();
      _NRLogAbortWithPack(v14, v11);
    }

    a1 = v5;
    objc_storeStrong((id *)v5 + 6, a2);
    a1[14] = 1;
  }

  return a1;
}

id sub_100014FF0()
{
  if (qword_1001DC690 != -1) {
    dispatch_once(&qword_1001DC690, &stru_1001AE298);
  }
  return (id)qword_1001DC688;
}

char *sub_100015030(char *a1, void *a2)
{
  id v5 = a2;
  if (!a1) {
    goto LABEL_24;
  }
  v22.receiver = a1;
  v22.super_class = (Class)&OBJC_CLASS___NRNetInfo;
  uint64_t v6 = (char *)objc_msgSendSuper2(&v22, "init");
  a1 = v6;
  if (!v6)
  {
    id v16 = sub_100014FF0();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v16, 16LL);

    if (IsLevelEnabled)
    {
      id v18 = sub_100014FF0();
      _NRLogWithArgs( v18,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRNetInfo initWithIncomingData:]",  103);
    }

    a1 = (char *)_os_log_pack_size(12LL);
    id v5 = (char *)&v22 - ((__chkstk_darwin(a1) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v19 = __error();
    uint64_t v20 = _os_log_pack_fill(v5, a1, *v19, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)uint64_t v20 = 136446210;
    *(void *)(v20 + 4) = "-[NRNetInfo initWithIncomingData:]";
    id v21 = sub_100014FF0();
    _NRLogAbortWithPack(v21, v5);
    __break(1u);
LABEL_39:
    dispatch_once(&qword_1001DC690, &stru_1001AE298);
LABEL_7:
    if (_NRLogIsLevelEnabled(qword_1001DC688, 16LL))
    {
      if (p_class_meths[210] != (__objc2_meth_list *)-1LL) {
        dispatch_once(&qword_1001DC690, &stru_1001AE298);
      }
      id v8 = (id)qword_1001DC688;
      _NRLogWithArgs( v8,  16,  "%s%.30s:%-4d received insufficient bytes for net-info %u",  "",  "-[NRNetInfo processIncomingData:]",  591,  [v2 length]);
    }

    goto LABEL_23;
  }

  v6[11] = 1;
  id v7 = v5;
  id v2 = v7;
  if (a1[10])
  {

    goto LABEL_24;
  }

  unsigned __int16 v32 = 0;
  uint64_t v31 = 0LL;
  if ((unint64_t)[v7 length] <= 9)
  {
    p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    if (qword_1001DC690 == -1) {
      goto LABEL_7;
    }
    goto LABEL_39;
  }

  unsigned __int8 v30 = 0;
  [v2 getBytes:&v30 length:1];
  int v9 = v30;
  if (v30 >= 2u)
  {
    if (qword_1001DC690 != -1) {
      dispatch_once(&qword_1001DC690, &stru_1001AE298);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC688, 16LL))
    {
      if (qword_1001DC690 != -1) {
        dispatch_once(&qword_1001DC690, &stru_1001AE298);
      }
      _NRLogWithArgs( qword_1001DC688,  16LL,  "%s%.30s:%-4d received unsupported net-info version %d",  "",  "-[NRNetInfo processIncomingData:]",  599,  v30);
    }

    goto LABEL_23;
  }

  a1[14] = v30;
  if (v9 != 1)
  {
LABEL_23:

    goto LABEL_24;
  }

  objc_msgSend(v2, "getBytes:range:", &v31, 0, 10);
  uint64_t v10 = bswap32(v32) >> 16;
  if ([v2 length] != (id)(v10 + 10))
  {
    if (qword_1001DC690 != -1) {
      dispatch_once(&qword_1001DC690, &stru_1001AE298);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC688, 16LL))
    {
      id v14 = sub_100014FF0();
      _NRLogWithArgs( v14,  16,  "%s%.30s:%-4d received insufficient tlv bytes for net-info %u != (%zu + %u)",  "",  "-[NRNetInfo processIncomingData:]",  610,  [v2 length],  0xAuLL,  v10);
    }

    goto LABEL_23;
  }

  else {
    id v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "subdataWithRange:", 10, v10));
  }
  *(_WORD *)(a1 + 15) = WORD1(v31);
  *((_DWORD *)a1 + 7) = bswap32(HIDWORD(v31));
  uint64_t v24 = 0LL;
  __int128 v25 = &v24;
  uint64_t v26 = 0x3032000000LL;
  __int128 v27 = sub_10001556C;
  __int128 v28 = sub_10001557C;
  id v29 = 0LL;
  uint64_t v15 = (void *)*((void *)a1 + 5);
  *((void *)a1 + 5) = 0LL;

  if (!v11
    || (v23[0] = _NSConcreteStackBlock,
        v23[1] = 3221225472LL,
        v23[2] = sub_100015584,
        v23[3] = &unk_1001AE278,
        v23[4] = a1,
        v23[5] = &v24,
        (NRTLVParse(v11, v23) & 1) != 0))
  {
    objc_storeStrong((id *)a1 + 16, (id)v25[5]);
    _Block_object_dispose(&v24, 8);

    a1 = a1;
    BOOL v12 = a1;
    goto LABEL_25;
  }

  _Block_object_dispose(&v24, 8);

LABEL_24:
  BOOL v12 = 0LL;
LABEL_25:

  return v12;
}

void sub_100015550(_Unwind_Exception *a1)
{
}

uint64_t sub_10001556C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10001557C(uint64_t a1)
{
}

uint64_t sub_100015584(uint64_t a1, unsigned __int8 *a2)
{
  unsigned int v4 = *(unsigned __int16 *)(a2 + 1);
  uint64_t v5 = __rev16(v4);
  unsigned int v6 = sub_100015A30(*(void *)(a1 + 32), *a2);
  if (v6) {
    BOOL v7 = v6 >= v5;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    uint64_t result = 1LL;
    switch(*a2)
    {
      case 1u:
        int v9 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  a2 + 3,  bswap32(*(unsigned __int16 *)(a2 + 1)) >> 16);
        id v10 = *(id *)(a1 + 32);
        id v11 = v9;
        BOOL v12 = v11;
        if (v10)
        {
          uint64_t v27 = 0LL;
          __int128 v28 = &v27;
          uint64_t v29 = 0x3032000000LL;
          unsigned __int8 v30 = sub_10001556C;
          uint64_t v31 = sub_10001557C;
          id v32 = 0LL;
          v26[0] = _NSConcreteStackBlock;
          v26[1] = 3221225472LL;
          v26[2] = sub_100015BEC;
          v26[3] = &unk_1001AE278;
          v26[4] = v10;
          v26[5] = &v27;
          else {
            uint64_t v13 = 0LL;
          }
          id v10 = v13;
          _Block_object_dispose(&v27, 8);

          if (v10)
          {
            objc_super v22 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
            if (!v22)
            {
              id v23 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
              uint64_t v24 = *(void *)(*(void *)(a1 + 40) + 8LL);
              __int128 v25 = *(void **)(v24 + 40);
              *(void *)(v24 + 40) = v23;

              objc_super v22 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
            }

            [v22 addObject:v10];
          }
        }

        else
        {
        }

        goto LABEL_54;
      case 2u:
        BOOL v12 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a2 + 3, v5);
        uint64_t v17 = *(void *)(a1 + 32);
        if (v17) {
          objc_storeStrong((id *)(v17 + 40), v12);
        }
LABEL_54:

        goto LABEL_55;
      case 3u:
        if (v4 == 2048)
        {
          *(void *)(*(void *)(a1 + 32) + 112LL) = *(void *)(a2 + 3);
          uint64_t v15 = *(void *)(a1 + 32);
          if (v15) {
            *(void *)(v15 + 112) = bswap64(*(void *)(v15 + 112));
          }
          return result;
        }

        if (qword_1001DC690 != -1) {
          dispatch_once(&qword_1001DC690, &stru_1001AE298);
        }
        if (qword_1001DC690 != -1) {
          dispatch_once(&qword_1001DC690, &stru_1001AE298);
        }
        uint64_t v20 = qword_1001DC688;
        int v21 = 649;
        goto LABEL_47;
      case 4u:
        if (v4 == 2048)
        {
          *(void *)(*(void *)(a1 + 32) + 120LL) = *(void *)(a2 + 3);
          uint64_t v18 = *(void *)(a1 + 32);
          if (v18) {
            *(void *)(v18 + 120) = bswap64(*(void *)(v18 + 120));
          }
          return result;
        }

        if (qword_1001DC690 != -1) {
          dispatch_once(&qword_1001DC690, &stru_1001AE298);
        }
        if (qword_1001DC690 != -1) {
          dispatch_once(&qword_1001DC690, &stru_1001AE298);
        }
        uint64_t v20 = qword_1001DC688;
        int v21 = 657;
        goto LABEL_47;
      case 5u:
        if (v4 == 1024)
        {
          uint64_t v19 = *(void *)(a1 + 32);
          if (v19) {
            *(_DWORD *)(v19 + 20) = bswap32(*(_DWORD *)(a2 + 3));
          }
        }

        else
        {
          if (qword_1001DC690 != -1) {
            dispatch_once(&qword_1001DC690, &stru_1001AE298);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC688, 16LL))
          {
            if (qword_1001DC690 != -1) {
              dispatch_once(&qword_1001DC690, &stru_1001AE298);
            }
            uint64_t v20 = qword_1001DC688;
            int v21 = 665;
LABEL_47:
            _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d invalid tlv data size",  "",  "-[NRNetInfo processIncomingData:]_block_invoke",  v21);
          }

LABEL_55:
          uint64_t result = 1LL;
        }

        break;
      case 7u:
        uint64_t v16 = *(void *)(a1 + 32);
        if (v16) {
          *(_BYTE *)(v16 + 9) = 1;
        }
        return result;
      default:
        return result;
    }
  }

  else
  {
    unsigned int v14 = v6;
    if (qword_1001DC690 != -1) {
      dispatch_once(&qword_1001DC690, &stru_1001AE298);
    }
    uint64_t result = _NRLogIsLevelEnabled(qword_1001DC688, 16LL);
    if ((_DWORD)result)
    {
      if (qword_1001DC690 != -1) {
        dispatch_once(&qword_1001DC690, &stru_1001AE298);
      }
      _NRLogWithArgs( qword_1001DC688,  16LL,  "%s%.30s:%-4d unexpected length %u > %u for tlv type %u",  "",  "-[NRNetInfo processIncomingData:]_block_invoke",  629,  v5,  v14,  *a2);
      return 0LL;
    }
  }

  return result;
}

  -[NSMutableArray addObject:](v8, "addObject:", @"CompanionLinkInactivity");
  if ((reason & 0x1000000000000000LL) == 0)
  {
LABEL_30:
    if ((reason & 0x2000000000000000LL) == 0) {
      goto LABEL_31;
    }
    goto LABEL_57;
  }

void sub_1000159FC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
}

uint64_t sub_100015A30(uint64_t result, int a2)
{
  if (result)
  {
    uint64_t result = 0x8000LL;
    switch(a2)
    {
      case 0:
        goto LABEL_13;
      case 1:
        return result;
      case 2:
        uint64_t result = 1024LL;
        break;
      case 3:
      case 4:
      case 6:
        uint64_t result = 8LL;
        break;
      case 5:
        uint64_t result = 4LL;
        break;
      case 41:
      case 42:
      case 43:
        uint64_t result = 0x2000LL;
        break;
      default:
        if (qword_1001DC690 != -1) {
          dispatch_once(&qword_1001DC690, &stru_1001AE298);
        }
        uint64_t result = _NRLogIsLevelEnabled(qword_1001DC688, 1LL);
        if ((_DWORD)result)
        {
          if (qword_1001DC690 != -1) {
            dispatch_once(&qword_1001DC690, &stru_1001AE298);
          }
          _NRLogWithArgs(qword_1001DC688, 1LL, "%s%.30s:%-4d unhandled type %u", "", "-[NRNetInfo maxTLVLen:]", 580, a2);
LABEL_13:
          uint64_t result = 0LL;
        }

        break;
    }
  }

  return result;
}

uint64_t sub_100015BEC(uint64_t a1, unsigned __int8 *a2)
{
  unsigned int v4 = *(unsigned __int16 *)(a2 + 1);
  uint64_t v5 = __rev16(v4);
  unsigned int v6 = sub_100015A30(*(void *)(a1 + 32), *a2);
  if (v6) {
    BOOL v7 = v6 >= v5;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    if (qword_1001DC690 != -1) {
      dispatch_once(&qword_1001DC690, &stru_1001AE298);
    }
    uint64_t result = _NRLogIsLevelEnabled(qword_1001DC688, 16LL);
    if ((_DWORD)result)
    {
      if (qword_1001DC690 != -1) {
        dispatch_once(&qword_1001DC690, &stru_1001AE298);
      }
      _NRLogWithArgs(qword_1001DC688, 16LL, "%s%.30s:%-4d unexpected length %u > %u for tlv type %u", "");
      return 0LL;
    }

    return result;
  }

  int v8 = *a2;
  if (v8 == 43)
  {
    uint64_t v15 = -[NSString initWithBytes:length:encoding:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithBytes:length:encoding:",  a2 + 3,  v5,  4LL);
    if (v15)
    {
      uint64_t v16 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
      if (!v16)
      {
        uint64_t v17 = nw_resolver_config_create();
        uint64_t v18 = *(void *)(*(void *)(a1 + 40) + 8LL);
        uint64_t v19 = *(void **)(v18 + 40);
        *(void *)(v18 + 40) = v17;

        uint64_t v16 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
      }

      nw_resolver_config_add_search_domain(v16, -[NSData UTF8String](v15, "UTF8String"));
    }

    goto LABEL_28;
  }

  if (v8 == 42)
  {
    uint64_t v15 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a2 + 3, v5);
    id v20 = sub_100104514(v15, 1, 0, 0);
    int v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
    if (v21)
    {
      if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL))
      {
        uint64_t v22 = nw_resolver_config_create();
        uint64_t v23 = *(void *)(*(void *)(a1 + 40) + 8LL);
        uint64_t v24 = *(void **)(v23 + 40);
        *(void *)(v23 + 40) = v22;
      }

      __int128 v25 = (void *)objc_claimAutoreleasedReturnValue([v21 hostname]);
      nw_resolver_config_add_name_server( *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40),  [v25 UTF8String]);
    }

LABEL_28:
    return 1LL;
  }

  if (v8 != 41) {
    return 1LL;
  }
  if (v4 == 512)
  {
    unsigned int v9 = *(unsigned __int16 *)(a2 + 3);
    uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
    if (!v10)
    {
      uint64_t v11 = nw_resolver_config_create();
      uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8LL);
      uint64_t v13 = *(void **)(v12 + 40);
      *(void *)(v12 + 40) = v11;

      uint64_t v10 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
    }

    nw_resolver_config_set_class(v10, __rev16(v9));
    return 1LL;
  }

  if (qword_1001DC690 != -1) {
    dispatch_once(&qword_1001DC690, &stru_1001AE298);
  }
  uint64_t result = _NRLogIsLevelEnabled(qword_1001DC688, 16LL);
  if ((_DWORD)result)
  {
    if (qword_1001DC690 != -1) {
      dispatch_once(&qword_1001DC690, &stru_1001AE298);
    }
    _NRLogWithArgs(qword_1001DC688, 16LL, "%s%.30s:%-4d invalid length for resolver class %d != %zu");
    return 0LL;
  }

  return result;
}

void sub_100015EF0(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (qword_1001DC690 != -1) {
    dispatch_once(&qword_1001DC690, &stru_1001AE298);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC688, 0LL))
  {
    if (qword_1001DC690 != -1) {
      dispatch_once(&qword_1001DC690, &stru_1001AE298);
    }
    _NRLogWithArgs( qword_1001DC688,  0LL,  "%s%.30s:%-4d received path update: %@",  "",  "-[NRNetInfo start]_block_invoke",  144LL,  v3);
  }

  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v5 = WeakRetained;
  if (WeakRetained && !*((_BYTE *)WeakRetained + 10) && WeakRetained[9] == *(id *)(a1 + 32))
  {
    id v6 = v3;
    BOOL v7 = v6;
    if (*((_BYTE *)v5 + 12)) {
      goto LABEL_54;
    }
    int v8 = (nw_interface *)nw_path_copy_interface(v6);
    unsigned int v9 = v8;
    if (v8)
    {
      nw_interface_type_t type = nw_interface_get_type(v8);
      if (type == *((unsigned __int8 *)v5 + 16))
      {
        id location = 0LL;
        id v34 = 0LL;
        uint64_t v11 = +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  nw_interface_get_name(v9));
        id v12 = (id)objc_claimAutoreleasedReturnValue(v11);

        id v13 = location;
        if (location)
        {
          int v14 = 0;
          goto LABEL_27;
        }

LABEL_25:
        id v12 = v5[12];
        id v13 = 0LL;
        if (!v12)
        {
          unsigned int v15 = 0;
LABEL_30:

LABEL_31:
          uint64_t v16 = v34;
          if (v34 || (id v12 = v5[13]) != 0LL)
          {
            unsigned int v17 = [v16 intersectsSet:v5[13]] ^ 1;
            if (v16)
            {
LABEL_37:
              if ((v15 | v17) == 1)
              {
                *((_BYTE *)v5 + 12) = 1;
                if (v15)
                {
                  unsigned int v30 = v17;
                  if (qword_1001DC690 != -1) {
                    dispatch_once(&qword_1001DC690, &stru_1001AE298);
                  }
                  int IsLevelEnabled = _NRLogIsLevelEnabled(qword_1001DC688, 1LL);
                  unsigned int v17 = v30;
                  if (IsLevelEnabled)
                  {
                    if (qword_1001DC690 != -1) {
                      dispatch_once(&qword_1001DC690, &stru_1001AE298);
                    }
                    uint64_t v20 = (uint64_t)v5[12];
                    id v21 = location;
                    id v22 = (id)qword_1001DC688;
                    _NRLogWithArgs( v22,  1LL,  "%s%.30s:%-4d local v4 addresses changed: %@ -> %@",  "",  "-[NRNetInfo checkPathForNetworkFlaps:]",  220LL,  v20,  v21);

                    unsigned int v17 = v30;
                  }
                }

                if (v17)
                {
                  if (qword_1001DC690 != -1) {
                    dispatch_once(&qword_1001DC690, &stru_1001AE298);
                  }
                  if (_NRLogIsLevelEnabled(qword_1001DC688, 1LL))
                  {
                    if (qword_1001DC690 != -1) {
                      dispatch_once(&qword_1001DC690, &stru_1001AE298);
                    }
                    uint64_t v23 = (uint64_t)v5[13];
                    uint64_t v24 = v34;
                    id v25 = (id)qword_1001DC688;
                    _NRLogWithArgs( v25,  1LL,  "%s%.30s:%-4d local v6 addresses changed: %@ -> %@",  "",  "-[NRNetInfo checkPathForNetworkFlaps:]",  223LL,  v23,  v24);
                  }
                }
              }

LABEL_53:
LABEL_54:

              if (!*((_BYTE *)v5 + 8))
              {
                objc_initWeak(&location, v5);
                *((_BYTE *)v5 + _Block_object_dispose(va, 8) = 1;
                if (*((_BYTE *)v5 + 17)) {
                  int64_t v26 = 500000000LL;
                }
                else {
                  int64_t v26 = 10000000000LL;
                }
                dispatch_time_t v27 = dispatch_time(0x8000000000000000LL, v26);
                __int128 v28 = *(void **)(a1 + 40);
                if (v28) {
                  __int128 v28 = (void *)v28[6];
                }
                block[0] = _NSConcreteStackBlock;
                block[1] = 3221225472LL;
                block[2] = sub_100016EC8;
                block[3] = &unk_1001B0798;
                uint64_t v29 = v28;
                objc_copyWeak(&v33, &location);
                id v32 = *(id *)(a1 + 32);
                dispatch_after(v27, v29, block);

                objc_destroyWeak(&v33);
                objc_destroyWeak(&location);
              }

              goto LABEL_61;
            }
          }

          else
          {
            unsigned int v17 = 0;
          }

          unsigned int v18 = v17;

          unsigned int v17 = v18;
          goto LABEL_37;
        }

        int v14 = 1;
LABEL_27:
        unsigned int v15 = [v13 intersectsSet:v5[12]] ^ 1;
        id v13 = v12;
        if (!v14) {
          goto LABEL_31;
        }
        goto LABEL_30;
      }
    }

    else
    {
      if (!*((_BYTE *)v5 + 16))
      {
        id location = 0LL;
        id v34 = 0LL;
        goto LABEL_25;
      }

      nw_interface_type_t type = nw_interface_type_other;
    }

    if (qword_1001DC690 != -1) {
      dispatch_once(&qword_1001DC690, &stru_1001AE298);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC688, 1LL))
    {
      if (qword_1001DC690 != -1) {
        dispatch_once(&qword_1001DC690, &stru_1001AE298);
      }
      _NRLogWithArgs( qword_1001DC688,  1LL,  "%s%.30s:%-4d interface type changed: %u -> %u",  "",  "-[NRNetInfo checkPathForNetworkFlaps:]",  201,  *((unsigned __int8 *)v5 + 16),  type);
    }

    *((_BYTE *)v5 + 12) = 1;
    goto LABEL_53;
  }
}

      WeakRetained[13] = 0;
      goto LABEL_26;
    }

    if (a2 == 3)
    {
      sub_1000A45F8((uint64_t)WeakRetained);
      if (!v5 || nw_error_get_error_domain(v5) != nw_error_domain_posix || nw_error_get_error_code(v5) != 48)
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC898, 17LL))
        {
          if (qword_1001DC8A0 != -1) {
            dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
          }
          _NRLogWithArgs(qword_1001DC898, 17LL, "failed to start proxy server with error %@", v5);
        }

        goto LABEL_25;
      }

      unsigned int v9 = WeakRetained[13];
      if (v9 > 4)
      {
        unsigned int v15 = sub_1000A2100();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v15, 17LL);

        if (IsLevelEnabled)
        {
          unsigned int v17 = sub_1000A2100();
          _NRLogWithArgs(v17, 17LL, "failed to start proxy server after %u address in use retries", WeakRetained[13]);
        }

        goto LABEL_25;
      }

      WeakRetained[13] = v9 + 1;
      uint64_t v10 = sub_1000A2100();
      uint64_t v11 = _NRLogIsLevelEnabled(v10, 16LL);

      if (v11)
      {
        id v12 = sub_1000A2100();
        _NRLogWithArgs( v12,  16LL,  "%s%.30s:%-4d scheduling address in use retry %u",  "",  "-[NRLinkDirector startMASQUEProxyServerIfNeeded]_block_invoke",  2142,  WeakRetained[13]);
      }

      id v13 = dispatch_time(0x8000000000000000LL, 200000000LL * WeakRetained[13]);
      int v14 = (dispatch_queue_s *)*((void *)WeakRetained + 17);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_1000AD590;
      block[3] = &unk_1001B0A88;
      uint64_t v19 = WeakRetained;
      dispatch_after(v13, v14, block);
    }
  }
}

    goto LABEL_26;
  }

LABEL_61:
}

      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      goto LABEL_9;
    }

  return a1;
}

void sub_100016400(uint64_t a1)
{
  *(_BYTE *)(a1 + _Block_object_dispose(va, 8) = 0;
  id v2 = *(id *)(a1 + 72);
  uint64_t v3 = nw_path_evaluator_copy_path();
  unsigned int v4 = *(void **)(a1 + 64);
  *(void *)(a1 + 64) = v3;

  unsigned __int8 status = nw_path_get_status(*(nw_path_t *)(a1 + 64));
  id v6 = (nw_interface *)nw_path_copy_interface(*(void *)(a1 + 64));
  id obj = 0LL;
  __int128 v70 = 0LL;
  __int128 v58 = v6;
  if (v6)
  {
    BOOL v7 = v6;
    int type = nw_interface_get_type(v6);
    int v8 = +[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", nw_interface_get_name(v7));
    unsigned int v9 = (void *)objc_claimAutoreleasedReturnValue(v8);

    uint64_t v10 = v70;
  }

  else
  {
    uint64_t v10 = 0LL;
    int type = 0;
  }

  objc_storeStrong((id *)(a1 + 96), v10);
  objc_storeStrong((id *)(a1 + 104), obj);
  if (nw_path_is_expensive(*(nw_path_t *)(a1 + 64))) {
    int v11 = 8;
  }
  else {
    int v11 = 0;
  }
  if (nw_path_is_constrained(*(nw_path_t *)(a1 + 64))) {
    v11 |= 0x10u;
  }
  int v12 = v11 | nw_path_has_dns(*(nw_path_t *)(a1 + 64));
  if (nw_path_has_ipv4(*(nw_path_t *)(a1 + 64))) {
    v12 |= 2u;
  }
  if (nw_path_has_ipv6(*(nw_path_t *)(a1 + 64))) {
    v12 |= 4u;
  }
  else {
    int v13 = v12;
  }
  if (*(_BYTE *)(a1 + 13))
  {
    uint64_t estimated_upload_throughput = nw_path_get_estimated_upload_throughput(*(void *)(a1 + 64));
    uint64_t estimated_download_throughput = nw_path_get_estimated_download_throughput(*(void *)(a1 + 64));
  }

  else
  {
    uint64_t estimated_upload_throughput = 0LL;
    uint64_t estimated_download_throughput = 0LL;
  }

  if (*(unsigned __int8 *)(a1 + 15) == status
    && *(unsigned __int8 *)(a1 + 16) == type
    && *(_DWORD *)(a1 + 28) == v13
    && *(void *)(a1 + 112) == estimated_upload_throughput
    && *(void *)(a1 + 120) == estimated_download_throughput)
  {
    char v59 = 0;
  }

  else
  {
    *(_BYTE *)(a1 + 15) = status;
    *(_BYTE *)(a1 + 16) = type;
    *(_DWORD *)(a1 + 2_Block_object_dispose(va, 8) = v13;
    char v59 = 1;
    *(void *)(a1 + 112) = estimated_upload_throughput;
    *(void *)(a1 + 120) = estimated_download_throughput;
  }

  uint64_t v63 = 0LL;
  id v64 = &v63;
  uint64_t v65 = 0x3032000000LL;
  __int128 v66 = sub_10001556C;
  __int128 v67 = sub_10001557C;
  id v68 = 0LL;
  id v16 = *(id *)(a1 + 64);
  block[5] = _NSConcreteStackBlock;
  block[6] = 3221225472LL;
  block[7] = sub_100016D0C;
  block[8] = &unk_1001AE200;
  block[9] = &v63;
  nw_path_enumerate_resolver_configs();

  unint64_t v17 = (unint64_t)(id)v64[5];
  unint64_t v18 = (unint64_t)*(id *)(a1 + 128);
  uint64_t v19 = (void *)v18;
  id v61 = (void *)v17;
  if (!(v17 | v18)) {
    goto LABEL_27;
  }
  id v20 = [(id)v18 count];
  if (v20 == [v61 count])
  {
    if (![v19 count])
    {
LABEL_27:

      goto LABEL_45;
    }

    uint64_t v21 = 0LL;
    int v22 = 0;
    while (1)
    {
      uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v19 objectAtIndex:v21]);
      uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v61 objectAtIndex:v21]);
      int v25 = nw_resolver_config_get_class(v23);
      int64_t v26 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      dispatch_time_t v27 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
      __int128 v75 = _NSConcreteStackBlock;
      uint64_t v76 = 3221225472LL;
      __int128 v77 = sub_100016DA8;
      __int128 v78 = &unk_1001AE228;
      __int128 v28 = v26;
      __int128 v79 = v28;
      nw_resolver_config_enumerate_name_servers(v23, &v75);
      int v82 = _NSConcreteStackBlock;
      uint64_t v83 = 3221225472LL;
      uint64_t v84 = (uint64_t)sub_100016DF0;
      id v85 = (uint64_t (*)(uint64_t, uint64_t))&unk_1001AE228;
      uint64_t v29 = v27;
      int v86 = (void (*)(uint64_t))v29;
      nw_resolver_config_enumerate_name_servers(v24, &v82);
      id v30 = -[NSMutableArray count](v28, "count");
      if (v30 == -[NSMutableArray count](v29, "count")
        && -[NSMutableArray isEqualToArray:](v28, "isEqualToArray:", v29))
      {
        uint64_t v31 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        id v32 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        v73[0] = _NSConcreteStackBlock;
        v73[1] = 3221225472LL;
        v73[2] = sub_100016E38;
        v73[3] = &unk_1001AE228;
        id v33 = v31;
        __int128 v74 = v33;
        nw_resolver_config_enumerate_search_domains(v23, v73);
        v71[0] = _NSConcreteStackBlock;
        v71[1] = 3221225472LL;
        v71[2] = sub_100016E80;
        v71[3] = &unk_1001AE228;
        id v34 = v32;
        __int128 v72 = v34;
        nw_resolver_config_enumerate_search_domains(v24, v71);
        id v35 = -[NSMutableArray count](v33, "count");
        BOOL v36 = v35 != -[NSMutableArray count](v34, "count")
           || (-[NSMutableArray isEqualToArray:](v33, "isEqualToArray:", v34) & 1) == 0;
      }

      else
      {
        BOOL v36 = 1;
      }

      if (v36) {
        goto LABEL_44;
      }
      uint64_t v21 = (unsigned __int16)++v22;
    }
  }

LABEL_44:
  objc_storeStrong((id *)(a1 + 128), (id)v64[5]);
  char v59 = 1;
LABEL_45:
  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v37 = (id *)(id)qword_1001DC870;
  id v38 = v37;
  if (v37 && (uint64_t v39 = (id *)v37[6]) != 0LL)
  {
    int v40 = v39;
    uint64_t v41 = (dispatch_queue_s *)v39[3];
    dispatch_assert_queue_V2(v41);

    int v82 = 0LL;
    uint64_t v83 = (uint64_t)&v82;
    uint64_t v84 = 0x3032000000LL;
    id v85 = sub_10013D160;
    int v86 = sub_10013D170;
    id v87 = 0LL;
    id v42 = v40[22];
    id v43 = v40[13];
    if (v43) {
      id v43 = (void *)v43[3];
    }
    id v44 = v43;
    __int128 v75 = _NSConcreteStackBlock;
    uint64_t v76 = 3221225472LL;
    __int128 v77 = sub_100142A88;
    __int128 v78 = &unk_1001B0810;
    id v45 = (NSMutableArray *)v42;
    __int128 v79 = v45;
    id v46 = v44;
    id v80 = v46;
    id v81 = &v82;
    if (sub_10013D090((uint64_t)&OBJC_CLASS___NRLinkManagerWiFi, &v75))
    {
      id v42 = sub_10013A600();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v42, 16LL);

      if (IsLevelEnabled)
      {
        id v42 = sub_10013A600();
        _NRLogWithArgs( v42,  16LL,  "%s%.30s:%-4d Timed out getting WiFi SSID",  "",  "-[NRLinkManagerWiFi copyWiFiSSIDData]",  1925);
      }

      id v47 = 0LL;
    }

    else
    {
      id v47 = *(id *)(v83 + 40);
    }

    _Block_object_dispose(&v82, 8);
    if (v47)
    {
      int v48 = 0;
      goto LABEL_61;
    }
  }

  else
  {
  }

  id v50 = *(id *)(a1 + 40);
  id v47 = 0LL;
  if (!v50) {
    goto LABEL_65;
  }
  id v42 = v50;
  int v48 = 1;
LABEL_61:
  id v51 = *(id *)(a1 + 40);
  unsigned __int8 v52 = [v47 isEqualToData:v51];

  if (v48) {
  if ((v52 & 1) == 0)
  }
  {
    objc_storeStrong((id *)(a1 + 40), v47);
    char v59 = 1;
  }

          if (v30[9] && v30[20] && !v30[10])
          {
            BOOL v36 = v15 + 64;
            id v37 = *((id *)v30 + 4);
            objc_opt_self(v36);
            dispatch_time_t v27 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1001DCBA8 objectForKeyedSubscript:v37]);

            id v38 = p_class_meths[229];
            if (v27)
            {
              if (v38 != (__objc2_meth_list *)-1LL) {
                dispatch_once(&qword_1001DC728, &stru_1001AE510);
              }
              if (_NRLogIsLevelEnabled(v14[228], 1LL))
              {
                if (p_class_meths[229] != (__objc2_meth_list *)-1LL) {
                  dispatch_once(&qword_1001DC728, &stru_1001AE510);
                }
                _NRLogWithArgs( v14[228],  1LL,  "%s%.30s:%-4d pairing bluetooth for device %@",  "",  "-[NRLinkManagerBluetooth checkBluetoothPairingState]",  2202LL,  v30);
              }

              id v20 = objc_alloc_init(&OBJC_CLASS___NRBluetoothPairerParameters);
              -[NRBluetoothPairerParameters setPairingType:](v20, "setPairingType:", 0LL);
              -[NRBluetoothPairerParameters setBluetoothUUID:](v20, "setBluetoothUUID:", v27);
              uint64_t v21 = objc_alloc(v17 + 284);
              int v22 = v27;
              uint64_t v23 = p_class_meths;
              uint64_t v24 = *((id *)v30 + 4);
              int v25 = [v21 initWithNRUUID:v24];

              int64_t v26 = *(id *)(a1 + 24);
              v41[0] = _NSConcreteStackBlock;
              v41[1] = 3221225472LL;
              v41[2] = sub_10002EFA8;
              v41[3] = &unk_1001AE4F0;
              v41[4] = v28;
              [v25 pairWithParameters:v20 completionQueue:v26 completionBlock:v41];

              p_class_meths = v23;
              dispatch_time_t v27 = v22;
              unint64_t v17 = (objc_class *)&OBJC_IVAR___NRAnalyticsALUAdviceStats__timeSinceLastAdvice;

              int v14 = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
              unsigned int v15 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
            }

            else
            {
              if (v38 != (__objc2_meth_list *)-1LL) {
                dispatch_once(&qword_1001DC728, &stru_1001AE510);
              }
              unsigned int v15 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
              if (_NRLogIsLevelEnabled(v14[228], 1LL))
              {
                if (p_class_meths[229] != (__objc2_meth_list *)-1LL) {
                  dispatch_once(&qword_1001DC728, &stru_1001AE510);
                }
                _NRLogWithArgs( v14[228],  1LL,  "%s%.30s:%-4d no pairing candidate BT UUID for device %@",  "",  "-[NRLinkManagerBluetooth checkBluetoothPairingState]",  2199LL,  v30);
              }
            }
          }

  return v16;
}

  -[NSMutableArray addObject:](v8, "addObject:", @"CongestionHigh");
  if ((reason & 0x800000) == 0)
  {
LABEL_19:
    if ((reason & 0x1000000) == 0) {
      goto LABEL_20;
    }
    goto LABEL_46;
  }

  -[NSMutableArray addObject:](v3, "addObject:", @"BtryBest");
  if ((a1 & 0x100000000000000LL) == 0)
  {
LABEL_19:
    if ((a1 & 0x200000000000000LL) == 0) {
      goto LABEL_20;
    }
    goto LABEL_46;
  }

  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  int v22 = (id)qword_1001DC870;
  uint64_t v23 = v22;
  if (v22) {
    uint64_t v24 = (void *)*((void *)v22 + 6);
  }
  else {
    uint64_t v24 = 0LL;
  }
  int v25 = v24;

  sub_1001424C8(v25, v5, *(void **)(a1 + 96), v28);
}

      return;
    }

LABEL_65:
  if (type != 1)
  {
    __int128 v53 = *(void **)(a1 + 40);
    *(void *)(a1 + 40) = 0LL;
  }

  if ((v59 & 1) != 0) {
    goto LABEL_68;
  }
  if (*(_BYTE *)(a1 + 15) != 2 && *(_BYTE *)(a1 + 12))
  {
    ++*(_DWORD *)(a1 + 20);
    if (qword_1001DC690 != -1) {
      dispatch_once(&qword_1001DC690, &stru_1001AE298);
    }
    id v55 = (id)qword_1001DC688;
    int v56 = _NRLogIsLevelEnabled(v55, 1LL);

    if (v56)
    {
      if (qword_1001DC690 != -1) {
        dispatch_once(&qword_1001DC690, &stru_1001AE298);
      }
      id v57 = (id)qword_1001DC688;
      _NRLogWithArgs( v57,  1LL,  "%s%.30s:%-4d forcing a net-info update due to a network flap (id: %u)",  "",  "-[NRNetInfo processPathUpdate]",  325,  *(_DWORD *)(a1 + 20));
    }

                id v47 = os_channel_get_next_slot(v24, v335, v346);
                if (!v47)
                {
                  ((void (*)(uint64_t))v324)(v5);
                  *(void *)(v5 + 1935) |= 0x800uLL;
                  LODWORD(v51) = 25;
                  v325 = 1;
                  goto LABEL_100;
                }

                int v48 = v47;
                ((void (*)(uint64_t))v329)(v5);
                v328 = v26;
                if (gNRPacketLoggingEnabled)
                {
                  ESPSequenceNumberFromPacket = getESPSequenceNumberFromPacket(v348, v347);
                  if (gNRPacketLoggingEnabled)
                  {
                    v327 = v48;
                    getESPSPIFromPacket(v348, v347);
                    if (gNRPacketLoggingEnabled)
                    {
                      v117 = v347;
                      v118 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v116);
                      v119 = _NRLogIsLevelEnabled(v118, 1LL);

                      if (v119)
                      {
                        __int128 v121 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v120);
                        __int128 v122 = [(id)v5 copyDescription];
                        _NRLogWithArgs( v121,  1LL,  "%s%.30s:%-4d %@: UrgentLink:Sending ESP sequence number - to be sent on urgent pipe: %u (%u bytes)",  "",  "NRLinkNexusToLinkLoopUrgent",  3309LL,  v122,  ESPSequenceNumberFromPacket,  v117);
                      }
                    }

                    int v48 = v327;
                    LOWORD(v26) = v328;
                  }

                  else
                  {
                    LOWORD(v26) = v328;
                  }
                }

                else
                {
                  ESPSequenceNumberFromPacket = 0LL;
                }

                v332 = nrMaxTLVLengthForPacket(v348, v347);
                v364 = 0u;
                v365 = 0u;
                v362 = 0u;
                v363 = 0u;
                v360 = 0u;
                v361 = 0u;
                v358 = 0u;
                v359 = 0u;
                v356 = 0u;
                v357 = 0u;
                v354 = 0u;
                v355 = 0u;
                v352 = 0u;
                v353 = 0u;
                v350 = 0u;
                v351 = 0u;
                if ((unsigned __int16)v27 <= (unsigned __int16)v26)
                {
                  id v49 = 0;
                  id v50 = 0;
                }

                else
                {
                  *(void *)&v350 = &object_address[(unsigned __int16)v26];
                  id v49 = (unsigned __int16)v27 - (unsigned __int16)v26;
                  DWORD2(v350) = v49;
                  id v50 = 1;
                }

                unsigned __int8 v52 = v340;
                if (v49 < v332)
                {
                  v327 = v48;
                  v326 = v27;
                  __int128 v53 = v50;
                  __int128 v54 = (uint64_t)v341;
                  id v55 = (unsigned int *)&v320[16 * v50];
                  do
                  {
                    int v56 = os_channel_get_next_slot(*(void *)(v5 + 1135), v54, &v343);
                    if (!v56) {
                      break;
                    }
                    __int128 v54 = v56;
                    id v57 = os_channel_slot_get_packet(*(void *)(v5 + 1135), v56);
                    __int128 v58 = os_packet_get_next_buflet(v57, 0LL);
                    char v59 = os_buflet_get_object_address();
                    __int128 v60 = os_buflet_get_data_limit(v58);
                    if (v60 >= 0x10000)
                    {
                      v240 = sub_100070554();
                      v241 = _NRLogIsLevelEnabled(v240, 16LL);

                      if (v241)
                      {
                        v242 = sub_100070554();
                        _NRLogWithArgs( v242,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: lookAheadLinkOutputBufferLength <= 65535",  "",  "NRLinkNexusToLinkLoopUrgent",  3338);
                      }

                      v243 = _os_log_pack_size(12LL);
                      v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                      v244 = *__error();
                      v226 = _os_log_pack_fill( v224,  v243,  v244,  &_mh_execute_header,  "%{public}s Assertion Failed: lookAheadLinkOutputBufferLength <= 65535",  v318,  v319);
                      goto LABEL_276;
                    }

                    *((void *)v55 - 1) = v59;
                    if (!v60)
                    {
                      v245 = sub_100070554();
                      v246 = _NRLogIsLevelEnabled(v245, 16LL);

                      if (v246)
                      {
                        v247 = sub_100070554();
                        _NRLogWithArgs( v247,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: lookAheadLinkOutputBufferLength > 0",  "",  "NRLinkNexusToLinkLoopUrgent",  3341);
                      }

                      v248 = _os_log_pack_size(12LL);
                      v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                      v249 = *__error();
                      v226 = _os_log_pack_fill( v224,  v248,  v249,  &_mh_execute_header,  "%{public}s Assertion Failed: lookAheadLinkOutputBufferLength > 0",  v318,  v319);
                      goto LABEL_276;
                    }

                    *id v55 = v60;
                    *(void *)(v5 + 1935) |= 0x1000uLL;
                    if (v53 == 15)
                    {
                      __int128 v78 = (void *)createIOVecString(&v350, 16LL);
                      sub_1000749CC( (void *)v5,  @"NtL-U not enough ioVecs %@ for %u",  v79,  v80,  v81,  v82,  v83,  v84,  (uint64_t)v78);

                      LODWORD(v51) = 1;
                      uint64_t v24 = v336;
                      int v25 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                      id v61 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                      __int128 v28 = v341;
                      dispatch_time_t v27 = v326;
                      int64_t v26 = v328;
                      goto LABEL_101;
                    }

                    ++v53;
                    v49 += v60;
                    v55 += 4;
                  }

                  while (v49 < v332);
                  LOWORD(v50) = v53;
                  uint64_t v24 = v336;
                  unsigned __int8 v52 = v340;
                  dispatch_time_t v27 = v326;
                  int v48 = v327;
                }

                v340 = v52;
                if (v49 < v332)
                {
                  *(void *)(v5 + 1935) |= 0x2000uLL;
                  int64_t v26 = v328;
                  if (*(_BYTE *)(v5 + 228))
                  {
                    id v61 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                    __int128 v28 = v341;
                    if (*(void *)(v5 + 1151))
                    {
                      *(_BYTE *)(v5 + 22_Block_object_dispose(va, 8) = 0;
                      ++*(void *)(v5 + 1167);
                      if (gNRPacketLoggingEnabled)
                      {
                        v128 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                        v129 = _NRLogIsLevelEnabled(v128, 1LL);

                        if (v129)
                        {
                          v131 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v130);
                          v132 = [(id)v5 copyDescription];
                          _NRLogWithArgs( v131,  1LL,  "%s%.30s:%-4d %@: source-resume: UrgentLinkOutput",  "",  "NRLinkResumeUrgentLinkOutputSource",  827LL,  v132);
                        }
                      }

                      dispatch_resume(*(dispatch_object_t *)(v5 + 1151));
                    }

                    LODWORD(v51) = 25;
                    int v25 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                    goto LABEL_101;
                  }

                  LODWORD(v51) = 25;
                  int v25 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
LABEL_100:
                  id v61 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                  __int128 v28 = v341;
                  goto LABEL_101;
                }

                id v62 = v328;
                if (!(void)v350)
                {
                  v256 = sub_100070554();
                  v257 = _NRLogIsLevelEnabled(v256, 16LL);

                  if (v257)
                  {
                    v258 = sub_100070554();
                    v259 = (void *)createIOVecString(&v350, (unsigned __int16)v50);
                    _NRLogWithArgs( v258,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[0].buf != ((void *)0); We have enough content but "
                      "first ioVec is NULL: %@",
                      "",
                      "NRLinkNexusToLinkLoopUrgent",
                      3370LL,
                      v259);
                  }

                  v260 = _os_log_pack_size(22LL);
                  v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                  v261 = __error();
                  v262 = _os_log_pack_fill( v224,  v260,  *v261,  &_mh_execute_header,  "%{public}s Assertion Failed: ioVecs[0].buf != ((void *)0); We have enough content but first i"
                           "oVec is NULL: %@");
                  v263 = createIOVecString(&v350, (unsigned __int16)v50);
                  *(_DWORD *)v262 = 136446466;
                  *(void *)(v262 + 4) = "NRLinkNexusToLinkLoopUrgent";
                  *(_WORD *)(v262 + 12) = 2112;
                  *(void *)(v262 + 14) = v263;
                  goto LABEL_277;
                }

                uint64_t v63 = nrPacketToTLV(v348, v347, &v350, (unsigned __int16)v50, v5 + 1951, v5 + 1967);
                id v64 = v63;
                uint64_t v65 = *(unsigned __int8 *)v350;
                switch(*(_BYTE *)v350)
                {
                  case 'd':
                    __int128 v66 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_ESP;
                    goto LABEL_118;
                  case 'e':
                    __int128 v66 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_ESP_ECT0;
                    goto LABEL_118;
                  case 'f':
                    __int128 v66 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_TCP;
                    goto LABEL_118;
                  case 'g':
                    __int128 v66 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_TCP_ECT0;
                    goto LABEL_118;
                  case 'h':
                    __int128 v66 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_ESP_ClassC;
                    goto LABEL_118;
                  case 'i':
                    __int128 v66 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_ESP_ClassC_ECT0;
                    goto LABEL_118;
                  default:
                    if (v65 == 2)
                    {
                      __int128 v66 = &OBJC_IVAR___NRLinkBluetooth__sentUncompressedIP;
                    }

                    else
                    {
                      if (v65 != 3) {
                        goto LABEL_119;
                      }
                      __int128 v66 = &OBJC_IVAR___NRLinkBluetooth__sentEncapsulated6LoWPAN;
                    }

LABEL_68:
    ++*(void *)(a1 + 32);
    __int128 v54 = *(dispatch_queue_s **)(a1 + 48);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100016D7C;
    block[3] = &unk_1001B0A88;
    void block[4] = a1;
    dispatch_async(v54, block);
  }

  *(_BYTE *)(a1 + 12) = 0;

  _Block_object_dispose(&v63, 8);
}

            __int128 v54 = 0LL;
            goto LABEL_69;
          }

          id v35 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v34);
          BOOL v36 = [v2 copyDescription];
          _NRLogWithArgs( v35,  0LL,  "%s%.30s:%-4d %@: Deferring nexus setup to the packet parser",  "",  "-[NRLinkBluetooth setupNexusChannel]",  1812LL,  v36);
LABEL_19:

          goto LABEL_20;
        }

        id v35 = (void *)objc_claimAutoreleasedReturnValue([v31 nexusInstances]);
        id v62 = _NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v61);
        uint64_t v63 = (void *)v62;
        if (v35)
        {
          id v64 = _NRLogIsLevelEnabled(v62, 1LL);

          if (v64)
          {
            __int128 v66 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v65);
            __int128 v67 = [v2 copyDescription];
            _NRLogWithArgs( v66,  1LL,  "%s%.30s:%-4d %@: Created nexus instances: %@",  "",  "-[NRLinkBluetooth setupNexusChannel]",  1823LL,  v67,  v35);
          }

          if ([v35 count] == 4)
          {
            BOOL v36 = (id)objc_claimAutoreleasedReturnValue([v35 objectAtIndexedSubscript:0]);
            if (sub_10009A014((uint64_t)v2, v36))
            {

              BOOL v36 = (id)objc_claimAutoreleasedReturnValue([v35 objectAtIndexedSubscript:1]);
              if (sub_10009A754((uint64_t)v2, v36))
              {

                BOOL v36 = (id)objc_claimAutoreleasedReturnValue([v35 objectAtIndexedSubscript:2]);
                if (sub_10009AE94((uint64_t)v2, v36))
                {

                  BOOL v36 = (id)objc_claimAutoreleasedReturnValue([v35 objectAtIndexedSubscript:3]);
                }
              }
            }

            goto LABEL_56;
          }

          id v81 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v68);
          int v82 = _NRLogIsLevelEnabled(v81, 17LL);

          if (!v82)
          {
LABEL_58:

            id v85 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v84);
            int v86 = _NRLogIsLevelEnabled(v85, 16LL);

            if (!v86) {
              goto LABEL_68;
            }
            unsigned __int8 v52 = (char *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v87);
            __int128 v53 = [v2 copyDescription];
            _NRLogWithArgs( v52,  16LL,  "%s%.30s:%-4d %@: failed to setup nexus channel",  "",  "-[NRLinkBluetooth setupNexus]",  5937LL,  v53);
            goto LABEL_32;
          }

          BOOL v36 = (id)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v83);
          id v80 = [v2 copyDescription];
          _NRLogWithArgs(v36, 17LL, "%@: Expected to receive only %d nexus instances: %@", v80, 4LL, v35);
        }

        else
        {
          __int128 v78 = _NRLogIsLevelEnabled(v62, 17LL);

          if (!v78)
          {
            id v35 = 0LL;
            goto LABEL_58;
          }

          BOOL v36 = (id)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v79);
          id v80 = [v2 copyDescription];
          _NRLogWithArgs(v36, 17LL, "%@: Failed to get nexus instances", v80);
          id v35 = 0LL;
        }

LABEL_56:
        goto LABEL_58;
      }

      __int128 v58 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v29);
      char v59 = _NRLogIsLevelEnabled(v58, 16LL);

      if (!v59) {
        goto LABEL_68;
      }
      unsigned __int8 v52 = (char *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v60);
      __int128 v53 = [v2 copyDescription];
      _NRLogWithArgs( v52,  16LL,  "%s%.30s:%-4d %@: failed to create packet nexus",  "",  "-[NRLinkBluetooth setupNexus]",  5932LL,  v53);
LABEL_32:
      __int128 v54 = 0LL;
      goto LABEL_50;
    }
  }

  id v49 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v29);
  id v50 = _NRLogIsLevelEnabled(v49, 17LL);

  if (!v50) {
    goto LABEL_68;
  }
  unsigned __int8 v52 = (char *)_NRCopyLogObjectForNRUUID(*((void *)v2 + 4), v51);
  __int128 v53 = [v2 copyDescription];
  _NRLogWithArgs(v52, 17LL, "%@: failed to setup interface sub family", v53);
  __int128 v54 = 0LL;
LABEL_50:

LABEL_69:
  return v54;
}
  }

  __int128 v53 = sub_1000229A0(v3, 17LL);
  __int128 v54 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v53, "firstObject"));

  if (v54
    || (id v55 = sub_1000229A0(v3, 19LL),
        int v56 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v55, "firstObject")),
        v55,
        v56,
        v56))
  {
    id v57 = sub_1000229A0(v3, 17LL);
    __int128 v58 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v57, "firstObject"));

    char v59 = sub_1000229A0(v3, 19LL);
    __int128 v60 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v59, "firstObject"));

    v128 = 0;
    v127 = 0;
    uint64_t v125 = 0LL;
    uint64_t v126 = 0LL;
    if (v58)
    {
      id v61 = sub_1000229A0(v3, 17LL);
      id v62 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v61, "firstObject"));

      sub_1000DFCE8(v1, v62, (_BYTE *)&v128 + 1, &v128, &v127, &v126, &v125);
      if (HIBYTE(v128))
      {
        if ((_BYTE)v128)
        {
          id v64 = v126;
          uint64_t v65 = *(id *)(v1 + 552);
          __int128 v66 = v65;
          __int128 v67 = v65 ? (void *)*((void *)v65 + 3) : 0LL;
          id v68 = v67;
          __int128 v69 = [v64 isEqual:v68];

          if ((v69 & 1) == 0)
          {
            [*(id *)(v1 + 552) cancel];
            __int128 v70 = objc_alloc(&OBJC_CLASS___NRDNSProxyClient);
            __int128 v72 = v125;
            __int128 v71 = v126;
            __int128 v73 = *(void **)(v1 + 104);
            __int128 v74 = v127;
            __int128 v75 = *(id *)(v1 + 96);
            uint64_t v76 = v73;
            __int128 v77 = sub_10001D84C((id *)&v70->super.super.isa, v71, v76, v75, (void *)v1, v72, v74, 0);
            __int128 v78 = *(void **)(v1 + 552);
            *(void *)(v1 + 552) = v77;

            [*(id *)(v1 + 552) start];
            *(_DWORD *)(v1 + 72) = 0;
          }
        }
      }

      else
      {
        __int128 v79 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 96), v63);
        id v80 = _NRLogIsLevelEnabled(v79, 1LL);

        if (v80)
        {
          int v82 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 96), v81);
          _NRLogWithArgs( v82,  1LL,  "%s%.30s:%-4d peer failed to setup dns proxy",  "",  "-[NRDDeviceConductor handleDNSProxyMessage:]",  4977);
        }

        __int128 v123 = 0u;
        __int128 v124 = 0u;
        __int128 v121 = 0u;
        __int128 v122 = 0u;
        uint64_t v83 = *(id *)(v1 + 112);
        uint64_t v84 = [v83 countByEnumeratingWithState:&v121 objects:&v133 count:16];
        if (v84)
        {
          id v85 = v84;
          int v86 = *(void *)v122;
          do
          {
            for (j = 0LL; j != v85; j = (char *)j + 1)
            {
              if (*(void *)v122 != v86) {
                objc_enumerationMutation(v83);
              }
              int v88 = *(void **)(*((void *)&v121 + 1) + 8LL * (void)j);
            }

            id v85 = [v83 countByEnumeratingWithState:&v121 objects:&v133 count:16];
          }

          while (v85);
        }

        [*(id *)(v1 + 552) cancel];
        int v89 = *(void **)(v1 + 552);
        *(void *)(v1 + 552) = 0LL;

        ++*(_DWORD *)(v1 + 72);
        sub_1000DFF48((unsigned int *)v1);
      }
    }

    if (!v60) {
      goto LABEL_110;
    }
    id v90 = sub_1000229A0(v3, 19LL);
    int v91 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v90, "firstObject"));

    sub_1000DFCE8(v1, v91, (_BYTE *)&v128 + 1, &v128, &v127, &v126, &v125);
    if (!HIBYTE(v128))
    {
      id v104 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 96), v92);
      int v105 = _NRLogIsLevelEnabled(v104, 1LL);

      if (v105)
      {
        uint64_t v107 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 96), v106);
        _NRLogWithArgs( v107,  1LL,  "%s%.30s:%-4d peer failed to setup discovery proxy",  "",  "-[NRDDeviceConductor handleDNSProxyMessage:]",  5010);
      }

      [*(id *)(v1 + 576) cancel];
      uint64_t v108 = *(void **)(v1 + 576);
      *(void *)(v1 + 576) = 0LL;

      ++*(_DWORD *)(v1 + 76);
      sub_1000DD494(v1, v109);
      goto LABEL_109;
    }

    if ((_BYTE)v128)
    {
      uint64_t v93 = v126;
      v94 = *(id *)(v1 + 576);
      int v95 = v94;
      if (v94) {
        id v96 = (void *)*((void *)v94 + 3);
      }
      else {
        id v96 = 0LL;
      }
      int v97 = v96;
      if ([v93 isEqual:v97])
      {
        uint64_t v98 = v125;
        int v99 = *(id *)(v1 + 576);
        id v100 = v99;
        if (v99) {
          int v101 = (void *)*((void *)v99 + 4);
        }
        else {
          int v101 = 0LL;
        }
        uint64_t v102 = v101;
        int v103 = [v98 isEqualToData:v102];

        if ((v103 & 1) != 0) {
          goto LABEL_109;
        }
      }

      else
      {
      }

      [*(id *)(v1 + 576) cancel];
      uint64_t v110 = objc_alloc(&OBJC_CLASS___NRDNSProxyClient);
      id v112 = v125;
      uint64_t v111 = v126;
      v113 = *(void **)(v1 + 104);
      v114 = v127;
      v115 = *(id *)(v1 + 96);
      v116 = v113;
      v117 = sub_10001D84C((id *)&v110->super.super.isa, v111, v116, v115, (void *)v1, v112, v114, 1);
      v118 = *(void **)(v1 + 576);
      *(void *)(v1 + 576) = v117;

      if ([*(id *)(v1 + 128) virtualInterface])
      {
        Index = NEVirtualInterfaceGetIndex([*(id *)(v1 + 128) virtualInterface]);
        v120 = *(void *)(v1 + 576);
        if (v120) {
          *(_DWORD *)(v120 + 72) = Index;
        }
      }

      [*(id *)(v1 + 576) start];
      *(_DWORD *)(v1 + 76) = 0;
    }

      return;
    }

void sub_100016CD8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
}

uint64_t sub_100016D0C(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  if (!v4)
  {
    uint64_t v5 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
    BOOL v7 = *(void **)(v6 + 40);
    *(void *)(v6 + 40) = v5;

    unsigned int v4 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL);
  }

  [v4 addObject:v3];

  return 1LL;
}

uint64_t sub_100016D7C(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (!v1) {
    return MEMORY[0x10]();
  }
  if (!*(_BYTE *)(v1 + 10)) {
    return (*(uint64_t (**)(void))(*(void *)(v1 + 56) + 16LL))();
  }
  return result;
}

uint64_t sub_100016DA8(uint64_t a1, uint64_t a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
  [v2 addObject:v3];

  return 1LL;
}

uint64_t sub_100016DF0(uint64_t a1, uint64_t a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
  [v2 addObject:v3];

  return 1LL;
}

uint64_t sub_100016E38(uint64_t a1, uint64_t a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
  [v2 addObject:v3];

  return 1LL;
}

uint64_t sub_100016E80(uint64_t a1, uint64_t a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
  [v2 addObject:v3];

  return 1LL;
}

void sub_100016EC8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained && !*((_BYTE *)WeakRetained + 10) && *((void *)WeakRetained + 9) == *(void *)(a1 + 32))
  {
    id v3 = WeakRetained;
    sub_100016400((uint64_t)WeakRetained);
    id WeakRetained = v3;
  }
}

uint64_t sub_100016F1C(uint64_t a1, uint64_t a2)
{
  id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
  unsigned int v4 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v3,  @"0"));

  uint64_t v5 = sub_1001040C8(v4, 0, 0);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  if (v6) {
    NRTLVAddData(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL), 42LL);
  }

  return 1LL;
}

uint64_t sub_100016FC0(uint64_t a1, uint64_t a2)
{
  id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", a2));
  unsigned int v4 = (void *)objc_claimAutoreleasedReturnValue([v3 dataUsingEncoding:4]);

  NRTLVAddData(*(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL), 43LL);
  return 1LL;
}

NSMutableData *sub_100017030(uint64_t a1)
{
  uint64_t v1 = (NSMutableData *)a1;
  if (!a1) {
    return v1;
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 48));
  if (BYTE2(v1[1].super.super.isa)) {
    return 0LL;
  }
  if (LOBYTE(v1[1].super.super.isa)) {
    sub_100016400((uint64_t)v1);
  }
  isa = v1[10].super.super.isa;
  if (!isa || isa != v1[4].super.super.isa || !v1[11].super.super.isa)
  {
    memset((char *)v27 + 1, 0, 9);
    LOBYTE(v27[0]) = BYTE6(v1[1].super.super.isa);
    v27[1] = *(_WORD *)((char *)&v1[1].super.super.isa + 7);
    *(_DWORD *)&v27[2] = bswap32(HIDWORD(v1[3].super.super.isa));
    int v22 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
    __int128 v23 = 0u;
    __int128 v24 = 0u;
    __int128 v25 = 0u;
    __int128 v26 = 0u;
    id v20 = v1;
    id obj = v1[16].super.super.isa;
    id v4 = -[objc_class countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v23,  v37,  16LL);
    if (v4)
    {
      uint64_t v5 = *(void *)v24;
      do
      {
        uint64_t v6 = 0LL;
        do
        {
          if (*(void *)v24 != v5) {
            objc_enumerationMutation(obj);
          }
          id v7 = *(id *)(*((void *)&v23 + 1) + 8LL * (void)v6);
          if (v7)
          {
            int v8 = v7;
            unint64_t v31 = 0LL;
            id v32 = &v31;
            uint64_t v33 = 0x3032000000LL;
            id v34 = sub_10001556C;
            id v35 = sub_10001557C;
            BOOL v36 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
            __int16 v30 = bswap32(nw_resolver_config_get_class(v8)) >> 16;
            NRTLVAdd(v32[5], 41LL, 2LL, &v30);
            v29[0] = _NSConcreteStackBlock;
            v29[1] = 3221225472LL;
            v29[2] = sub_100016F1C;
            v29[3] = &unk_1001AE250;
            v29[4] = &v31;
            nw_resolver_config_enumerate_name_servers(v8, v29);
            v28[0] = _NSConcreteStackBlock;
            v28[1] = 3221225472LL;
            v28[2] = sub_100016FC0;
            v28[3] = &unk_1001AE250;
            v28[4] = &v31;
            nw_resolver_config_enumerate_search_domains(v8, v28);
            id v9 = (id)v32[5];
            _Block_object_dispose(&v31, 8);

            if (v9) {
              NRTLVAddData(v22, 1LL);
            }
          }

          else
          {
            if (qword_1001DC690 != -1) {
              dispatch_once(&qword_1001DC690, &stru_1001AE298);
            }
            id v10 = (id)qword_1001DC688;
            int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 17LL);

            if (IsLevelEnabled)
            {
              if (qword_1001DC690 != -1) {
                dispatch_once(&qword_1001DC690, &stru_1001AE298);
              }
              id v12 = (id)qword_1001DC688;
              _NRLogWithArgs(v12, 17LL, "%s called with null config", "-[NRNetInfo copyResolverConfigData:]");
            }

            id v9 = 0LL;
          }

          uint64_t v6 = (char *)v6 + 1;
        }

        while (v4 != v6);
        id v13 = -[objc_class countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v23,  v37,  16LL);
        id v4 = v13;
      }

      while (v13);
    }

    int v14 = v1[5].super.super.isa;
    if (-[objc_class length](v14, "length"))
    {
      BOOL v15 = (unint64_t)-[objc_class length](v20[5].super.super.isa, "length") < 0xFF;

      if (v15) {
        NRTLVAddData(v22, 2LL);
      }
    }

    else
    {
    }

    id v16 = v20;
    unint64_t v17 = (unint64_t)v20[14].super.super.isa;
    if (v17)
    {
      unint64_t v31 = bswap64(v17);
      NRTLVAdd(v22, 3LL, 8LL, &v31);
      id v16 = v20;
    }

    unint64_t v18 = (unint64_t)v16[15].super.super.isa;
    if (v18)
    {
      unint64_t v31 = bswap64(v18);
      NRTLVAdd(v22, 4LL, 8LL, &v31);
      id v16 = v20;
    }

    unsigned int isa_high = HIDWORD(v16[2].super.super.isa);
    if (LODWORD(v16[3].super.super.isa) != isa_high)
    {
      LODWORD(v31) = bswap32(isa_high);
      NRTLVAdd(v22, 5LL, 4LL, &v31);
      id v16 = v20;
      LODWORD(v20[3].super.super.isa) = HIDWORD(v20[2].super.super.isa);
    }

    if (BYTE1(v16[2].super.super.isa)) {
      NRTLVAdd(v22, 7LL, 0LL, 0LL);
    }
    if (qword_1001DCA18 != -1) {
      dispatch_once(&qword_1001DCA18, &stru_1001AFC28);
    }
    unint64_t v31 = bswap64(qword_1001DCA10);
    NRTLVAdd(v22, 6LL, 8LL, &v31);
    void v27[4] = bswap32(-[NSMutableData length](v22, "length")) >> 16;
    uint64_t v1 = -[NSMutableData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSMutableData),  "initWithBytes:length:",  v27,  10LL);
    -[NSMutableData appendData:](v1, "appendData:", v22);
    v20[10].super.super.isa = v20[4].super.super.isa;
    objc_storeStrong((id *)&v20[11].super.super.isa, v1);

    return v1;
  }

  if (qword_1001DC690 != -1) {
    dispatch_once(&qword_1001DC690, &stru_1001AE298);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC688, 2LL))
  {
    if (qword_1001DC690 != -1) {
      dispatch_once(&qword_1001DC690, &stru_1001AE298);
    }
    _NRLogWithArgs( qword_1001DC688,  2LL,  "%s%.30s:%-4d using cached send data for generation %llu",  "",  "-[NRNetInfo copySendData]",  494,  v1[4].super.super.isa);
  }

  return (NSMutableData *)v1[11].super.super.isa;
}

void sub_1000175E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, char a39)
{
}

id sub_100017EDC()
{
  if (qword_1001DC6B0 != -1) {
    dispatch_once(&qword_1001DC6B0, &stru_1001AE320);
  }
  return (id)qword_1001DC6A8;
}

LABEL_14:
  }

  return (char)v8;
}

    id v16 = sub_100023718(v1, v4);
    if (!v16)
    {
      id v64 = 0;
LABEL_50:

LABEL_51:
      return v64;
    }

    unint64_t v17 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(v1 + 32));
    unint64_t v18 = v17;
    __int128 v58 = v5;
    __int128 v66 = v5;
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v66, 1LL));
    id v57 = v18;
    if (!*(_BYTE *)(v1 + 8))
    {
LABEL_31:
      char v59 = v2;
      id v62 = 0u;
      uint64_t v63 = 0u;
      __int128 v60 = 0u;
      id v61 = 0u;
      BOOL v36 = v19;
      id v37 = [v36 countByEnumeratingWithState:&v60 objects:v65 count:16];
      if (v37)
      {
        id v38 = v37;
        uint64_t v39 = 0;
        int v40 = *(void *)v61;
        while (1)
        {
          for (i = 0LL; i != v38; i = (char *)i + 1)
          {
            if (*(void *)v61 != v40) {
              objc_enumerationMutation(v36);
            }
            id v45 = *(void **)(*((void *)&v60 + 1) + 8LL * (void)i);
            if ([v45 ikeClassDEstablished]
              && (!*(_BYTE *)(v1 + 9) || [v45 type] != 4))
            {
              id v46 = [v45 sendControlData:v16];
              int v48 = _NRCopyLogObjectForNRUUID(*(void *)(v1 + 32), v47);
              id v49 = (void *)v48;
              if (v46)
              {
                id v50 = _NRLogIsLevelEnabled(v48, 0LL);

                if (v50)
                {
                  id v42 = *(id *)(v1 + 32);
                  id v44 = (void *)_NRCopyLogObjectForNRUUID(v42, v43);
                  _NRLogWithArgs( v44,  0LL,  "%s%.30s:%-4d Successfully sent %@ over %@",  "",  "-[NRLinkDirectorMessage send]",  1065LL,  v1,  v45);
                  uint64_t v39 = 1;
LABEL_36:

                  continue;
                }

                uint64_t v39 = 1;
              }

              else
              {
                id v51 = _NRLogIsLevelEnabled(v48, 16LL);

                if (v51)
                {
                  id v42 = *(id *)(v1 + 32);
                  id v44 = (void *)_NRCopyLogObjectForNRUUID(v42, v52);
                  _NRLogWithArgs( v44,  16LL,  "%s%.30s:%-4d Failed to send %@ over %@",  "",  "-[NRLinkDirectorMessage send]",  1067LL,  v1,  v45,  v57);
                  goto LABEL_36;
                }
              }
            }
          }

          id v38 = [v36 countByEnumeratingWithState:&v60 objects:v65 count:16];
          if (!v38) {
            goto LABEL_49;
          }
        }
      }

      uint64_t v39 = 0;
LABEL_49:

      id v64 = v39 & 1;
      uint64_t v5 = v58;
      id v2 = v59;
      goto LABEL_50;
    }

    id v20 = *(id *)(v1 + 32);
    uint64_t v21 = v20;
    if (v2)
    {
      if (v20)
      {
        int v22 = objc_claimAutoreleasedReturnValue([v2[27] objectForKeyedSubscript:v20]);
        if (v22)
        {
          __int128 v23 = (id *)v22;
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(v22 + 104));
          __int128 v24 = objc_claimAutoreleasedReturnValue([v23[14] allObjects]);
LABEL_29:

LABEL_30:
          uint64_t v19 = (void *)v24;
          goto LABEL_31;
        }

        __int16 v30 = (void *)objc_claimAutoreleasedReturnValue([v21 UUIDString]);
        sub_1000A2084((uint64_t)v2, 1014, @"copyPrimaryLink %@", v31, v32, v33, v34, v35, (uint64_t)v30);

        __int128 v23 = 0LL;
LABEL_28:
        __int128 v24 = 0LL;
        goto LABEL_29;
      }

      id v55 = sub_1000A2100();
      int v56 = _NRLogIsLevelEnabled(v55, 17LL);

      if (v56)
      {
        __int128 v23 = (id *)sub_1000A2100();
        _NRLogWithArgs(v23, 17LL, "%s called with null nrUUID", "-[NRLinkDirector copyAllLinksForNRUUID:]");
        goto LABEL_28;
      }
    }

    __int128 v24 = 0LL;
    goto LABEL_30;
  }

  return result;
}
}
}
}

    id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v11);
    id v13 = _NRLogIsLevelEnabled(v12, 1LL);

    if (v13)
    {
      BOOL v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v14);
      if (a2 > 0xB) {
        id v16 = @"Unknown";
      }
      else {
        id v16 = -[NSString initWithUTF8String:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithUTF8String:",  (&off_1001AFA78)[a2]);
      }
      _NRLogWithArgs( v15,  1LL,  "%s%.30s:%-4d Could not remove request of type %@",  "",  "-[NRDDeviceConductor removeRequestOfType:]",  2734LL,  v16,  (void)v22);
      unint64_t v17 = 0LL;
LABEL_25:
    }

    else
    {
      unint64_t v17 = 0LL;
    }

  if (v4) {
    id v20 = v5 == 0;
  }
  else {
    id v20 = 1;
  }
  uint64_t v21 = !v20;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
  int v22 = sub_1000D8B90(a1, 4, 0);

  if (v14)
  {
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v32 = v12;
    __int128 v23 = (id)qword_1001DC870;
    __int128 v24 = v23;
    if (v23 && v23[8])
    {
      __int128 v25 = v3;

LABEL_29:
      if (qword_1001DC9B8 != -1) {
        dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
      }
      id v3 = v25;
      if (byte_1001DC9B0)
      {
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 104));
        __int128 v26 = [*(id *)(a1 + 128) ikeClassCEstablished];
        uint64_t v21 = 0;
        uint64_t v27 = 0;
        __int128 v28 = 1;
        LOBYTE(v10) = 1;
      }

      else
      {
        uint64_t v21 = 0;
        uint64_t v27 = 101;
        LOBYTE(v10) = 2;
        __int128 v28 = 1;
        __int128 v26 = 1;
      }

      uint64_t v29 = v33;
      goto LABEL_43;
    }

    __int128 v25 = v3;
    if (qword_1001DC9B8 == -1)
    {
      if (byte_1001DC9B0) {
        goto LABEL_36;
      }
    }

    else
    {
      dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
      if (byte_1001DC9B0)
      {
LABEL_36:
        unint64_t v31 = *(unsigned __int8 *)(a1 + 47);

        if (v31) {
          goto LABEL_29;
        }
LABEL_42:
        uint64_t v29 = v33;
        __int128 v26 = v34;
        uint64_t v27 = v35;
        __int128 v28 = v36;
LABEL_43:
        id v12 = v32;
        goto LABEL_44;
      }
    }

    goto LABEL_42;
  }

  uint64_t v29 = 0;
  uint64_t v27 = v35;
  __int128 v28 = v36;
  __int128 v26 = v34;
LABEL_44:
  *(_DWORD *)(a1 + 8_Block_object_dispose((const void *)(v27 - 152), 8) = v29;
  *(_BYTE *)(a1 + 63) = v38;
  sub_1000DB570( (uint64_t)&OBJC_CLASS___NRDDeviceConductor,  *(void **)(a1 + 96),  v28,  v14,  v13,  v21,  v26,  v37 != 0,  v10,  v27,  v12,  v29,  v38 != 0,  v3);

  return v3;
}
}

    id v13 = 0LL;
    goto LABEL_5;
  }

  uint64_t v6 = v5;
  id v7 = [v4 decodeObjectOfClass:objc_opt_class(NSUUID) forKey:@"identity"];
  int v8 = objc_claimAutoreleasedReturnValue(v7);
  identity = v6->_identity;
  v6->_identity = (NSUUID *)v8;

  if (!v6->_identity) {
    goto LABEL_9;
  }
  id v10 = [v4 decodeObjectOfClass:objc_opt_class(NSData) forKey:@"publicKey"];
  int v11 = objc_claimAutoreleasedReturnValue(v10);
  publicKey = v6->_publicKey;
  v6->_publicKey = (NSData *)v11;

  if (!v6->_publicKey)
  {
    __int128 v24 = sub_100121F34();
    __int128 v25 = _NRLogIsLevelEnabled(v24, 17LL);

    if (v25)
    {
      __int128 v23 = sub_100121F34();
      _NRLogWithArgs(v23, 17LL, "%s called with null self.publicKey");
      goto LABEL_13;
    }

    goto LABEL_14;
  }

  id v13 = v6;
LABEL_5:

  return v13;
}

    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    unint64_t v18 = (id)qword_1001DCC20;
    uint64_t v19 = _NRLogIsLevelEnabled(v18, 17LL);

    if (!v19)
    {
      uint64_t v21 = 0LL;
LABEL_63:

      goto LABEL_64;
    }

    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    id v20 = (NSString *)(id)qword_1001DCC20;
    _NRLogWithArgs(v20, 17LL, "Cannot read key %@ from keychain for %@", v11, String);
    uint64_t v21 = 0LL;
LABEL_62:

    goto LABEL_63;
  }

  uint64_t v21 = 0LL;
LABEL_64:

  if (v21)
  {
    objc_setProperty_nonatomic(a1, v26, v21, 16LL);
    a1 = a1;
    uint64_t v21 = a1;
  }

    id v13 = sub_100121F34();
    int v14 = _NRLogIsLevelEnabled(v13, 17LL);

    if (v14)
    {
      BOOL v15 = sub_100121F34();
      id String = (void *)NRDataProtectionClassCreateString(a2);
      _NRLogWithArgs(v15, 17LL, "Cannot generate keys for %@", String);
    }

    goto LABEL_16;
  }

  uint64_t v27 = sub_100121F34();
  __int128 v28 = _NRLogIsLevelEnabled(v27, 16LL);

  if (v28)
  {
    uint64_t v29 = sub_100121F34();
    _NRLogWithArgs( v29,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDLDDataClassKeychainItems initWithNewKeysForDataProtectionClass:]",  549);
  }

  id v4 = (void *)_os_log_pack_size(12LL);
  __int16 v30 = (char *)&v40 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
  unint64_t v31 = __error();
  id v32 = _os_log_pack_fill(v30, v4, *v31, &_mh_execute_header, "%{public}s [super init] failed");
  *(_DWORD *)id v32 = 136446210;
  *(void *)(v32 + 4) = "-[NRDLDDataClassKeychainItems initWithNewKeysForDataProtectionClass:]";
  uint64_t v33 = sub_100121F34();
  _NRLogAbortWithPack(v33, v30);
LABEL_32:
  id v34 = sub_100121F34();
  id v35 = _NRLogIsLevelEnabled(v34, 17LL);

  if (v35)
  {
    BOOL v36 = sub_100121F34();
    _NRLogWithArgs(v36, 17LL, "Failed to generate key access control: %@", error);
  }

  if (error) {
    CFRelease(error);
  }
LABEL_16:
  unint64_t v17 = 0LL;
LABEL_27:

  return v17;
}
}
}
}
}

                continue;
              }

              if (qword_1001DCBF8 != -1) {
                dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
              }
              if (_NRLogIsLevelEnabled(qword_1001DCBF0, 17LL))
              {
                if (qword_1001DCBF8 != -1) {
                  dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                }
                _NRLogWithArgs(qword_1001DCBF0, 17LL, "Invalid link %@", v10);
              }
            }
          }

          uint64_t v6 = [v4 countByEnumeratingWithState:&v30 objects:v34 count:16];
        }

        while (v6);
      }

      sub_10013B098(v1);
    }
  }

uint64_t sub_10001A920(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(unsigned __int8 *)(a1 + 48),  *(void *)(a1 + 32));
}

void sub_10001A974(id a1)
{
  uint64_t v1 = objc_alloc_init(&OBJC_CLASS___NRBluetoothPairingManager);
  id v2 = (void *)qword_1001DC698;
  qword_1001DC698 = (uint64_t)v1;
}

void sub_10001A99C(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  id v2 = (void *)qword_1001DC6A8;
  qword_1001DC6A8 = (uint64_t)v1;
}

id sub_10001AE98()
{
  if (qword_1001DC6C8 != -1) {
    dispatch_once(&qword_1001DC6C8, &stru_1001AE3E0);
  }
  return (id)qword_1001DC6C0;
}

void sub_10001AED8(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  id v2 = (void *)qword_1001DC6C0;
  qword_1001DC6C0 = (uint64_t)v1;
}

void sub_10001B400(_Unwind_Exception *a1)
{
}

void sub_10001B5C8(_BYTE *val, int a2)
{
  if (val)
  {
    char v2 = a2;
    if (val[8] != a2)
    {
      val[8] = a2;
      val[9] = (a2 - 1) < 3;
      objc_initWeak(&location, val);
      id v4 = (void *)*((void *)val + 5);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_10001B8D8;
      block[3] = &unk_1001AF3C8;
      uint64_t v5 = v4;
      objc_copyWeak(&v7, &location);
      char v8 = v2;
      dispatch_async(v5, block);

      objc_destroyWeak(&v7);
      objc_destroyWeak(&location);
    }
  }

void sub_10001B698(uint64_t a1, int a2, int a3)
{
  id WeakRetained = (unsigned __int8 *)objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained && !WeakRetained[12] && *((void *)WeakRetained + 10) == *(void *)(a1 + 32))
  {
    id val = WeakRetained;
    if (a3)
    {
      char v8 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 6), v7);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 16LL);

      id WeakRetained = val;
      if (IsLevelEnabled)
      {
        id v10 = (void *)_NRCopyLogObjectForNRUUID(*((void *)val + 6), v7);
        _NRLogWithArgs( v10,  16LL,  "%s%.30s:%-4d discovery proxy client error: %d",  "",  "-[NRDNSProxyClient startDiscoveryProxyClient]_block_invoke",  227,  a3);

        id WeakRetained = val;
      }
    }

    switch(a2)
    {
      case -1:
        id v16 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 6), v7);
        int v17 = _NRLogIsLevelEnabled(v16, 0LL);

        if (v17)
        {
          uint64_t v19 = (void *)_NRCopyLogObjectForNRUUID(*((void *)val + 6), v18);
          _NRLogWithArgs( v19,  0LL,  "%s%.30s:%-4d discovery proxy client invalidated",  "",  "-[NRDNSProxyClient startDiscoveryProxyClient]_block_invoke",  241);
        }

        id WeakRetained = val;
        if (!val[12])
        {
          int v15 = 4;
LABEL_20:
          sub_10001B5C8(val, v15);
          id WeakRetained = val;
        }

        break;
      case 2:
        id v20 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 6), v7);
        int v21 = _NRLogIsLevelEnabled(v20, 0LL);

        if (v21)
        {
          __int128 v23 = (void *)_NRCopyLogObjectForNRUUID(*((void *)val + 6), v22);
          _NRLogWithArgs( v23,  0LL,  "%s%.30s:%-4d discovery proxy client interrupted",  "",  "-[NRDNSProxyClient startDiscoveryProxyClient]_block_invoke",  236);
        }

        id WeakRetained = val;
        int v15 = val[8];
        if (val[8]) {
          goto LABEL_20;
        }
        break;
      case 1:
        int v11 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 6), v7);
        int v12 = _NRLogIsLevelEnabled(v11, 0LL);

        if (v12)
        {
          int v14 = (void *)_NRCopyLogObjectForNRUUID(*((void *)val + 6), v13);
          _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d discovery proxy client started",  "",  "-[NRDNSProxyClient startDiscoveryProxyClient]_block_invoke",  232);
        }

        int v15 = 2;
        goto LABEL_20;
    }
  }
}

void sub_10001B8D8(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && *((unsigned __int8 *)WeakRetained + 8) == *(unsigned __int8 *)(a1 + 40))
  {
    id v4 = WeakRetained;
    id v3 = objc_loadWeakRetained(WeakRetained + 8);
    [v3 didUpdateDNSProxyState:v4 state:*(unsigned __int8 *)(a1 + 40)];

    id WeakRetained = v4;
  }
}

void sub_10001BBA8(uint64_t a1)
{
  if (a1)
  {
    int v28 = -1;
    char v2 = (void *)mrc_dns_proxy_parameters_create(&v28);
    if (v28)
    {
      if (qword_1001DC6C8 != -1) {
        dispatch_once(&qword_1001DC6C8, &stru_1001AE3E0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC6C0, 17LL))
      {
        if (qword_1001DC6C8 != -1) {
          dispatch_once(&qword_1001DC6C8, &stru_1001AE3E0);
        }
        _NRLogWithArgs(qword_1001DC6C0, 17LL, "mrc_dns_proxy_parameters_create failed");
      }

      sub_10001B5C8((_BYTE *)a1, 4);
    }

    else
    {
      id v3 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 48));
      id v4 = sub_10012CD2C(v3, @"53");
      __int128 v26 = 0u;
      __int128 v27 = 0u;
      __int128 v24 = 0u;
      __int128 v25 = 0u;
      id v5 = *(id *)(a1 + 72);
      id v6 = [v5 countByEnumeratingWithState:&v24 objects:v29 count:16];
      if (v6)
      {
        uint64_t v7 = *(void *)v25;
        do
        {
          for (i = 0LL; i != v6; i = (char *)i + 1)
          {
            if (*(void *)v25 != v7) {
              objc_enumerationMutation(v5);
            }
            mrc_dns_proxy_parameters_add_input_interface( v2,  [*(id *)(*((void *)&v24 + 1) + 8 * (void)i) unsignedIntValue]);
          }

          id v6 = [v5 countByEnumeratingWithState:&v24 objects:v29 count:16];
        }

        while (v6);
      }

      mrc_dns_proxy_parameters_set_output_interface(v2, 0LL);
      uint64_t v9 = mrc_dns_proxy_create(v2, &v28);
      id v10 = (void *)v9;
      if (v9)
      {
        mrc_dns_proxy_set_queue(v9, *(void *)(a1 + 40));
        objc_initWeak(&location, (id)a1);
        v19[0] = _NSConcreteStackBlock;
        v19[1] = 3221225472LL;
        v19[2] = sub_10001BF90;
        v19[3] = &unk_1001AE370;
        objc_copyWeak(&v22, &location);
        id v11 = v10;
        id v20 = v11;
        int v21 = v4;
        mrc_dns_proxy_set_event_handler(v11, v19);
        mrc_dns_proxy_activate(v11);
        id v12 = *(id *)(a1 + 48);
        int v14 = (void *)_NRCopyLogObjectForNRUUID(v12, v13);
        char IsLevelEnabled = _NRLogIsLevelEnabled(v14, 0LL);

        if ((IsLevelEnabled & 1) != 0)
        {
          id v16 = *(id *)(a1 + 48);
          uint64_t v18 = (void *)_NRCopyLogObjectForNRUUID(v16, v17);
          _NRLogWithArgs(v18, 0LL, "%s%.30s:%-4d dns proxy activated", "", "-[NRDNSProxyServer startDNS53Server]", 369);
        }

        objc_storeStrong((id *)(a1 + 80), v10);
        sub_10001B5C8((_BYTE *)a1, 1);

        objc_destroyWeak(&v22);
        objc_destroyWeak(&location);
      }

      else
      {
        if (qword_1001DC6C8 != -1) {
          dispatch_once(&qword_1001DC6C8, &stru_1001AE3E0);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC6C0, 17LL))
        {
          if (qword_1001DC6C8 != -1) {
            dispatch_once(&qword_1001DC6C8, &stru_1001AE3E0);
          }
          _NRLogWithArgs(qword_1001DC6C0, 17LL, "mrc_dns_proxy_create failed");
        }

        sub_10001B5C8((_BYTE *)a1, 4);
      }
    }
  }

void sub_10001BF68( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
}

void sub_10001BF90(uint64_t a1, int a2, int a3)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v7 = WeakRetained;
  if (WeakRetained && !*((_BYTE *)WeakRetained + 12) && WeakRetained[10] == *(void *)(a1 + 32))
  {
    id val = WeakRetained;
    if (a3)
    {
      char v8 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[6], WeakRetained);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 16LL);

      uint64_t v7 = val;
      if (IsLevelEnabled)
      {
        id v10 = (void *)_NRCopyLogObjectForNRUUID(val[6], val);
        _NRLogWithArgs( v10,  16LL,  "%s%.30s:%-4d dns proxy error: %d",  "",  "-[NRDNSProxyServer startDNS53Server]_block_invoke",  341,  a3);

        uint64_t v7 = val;
      }
    }

    switch(a2)
    {
      case -1:
        uint64_t v18 = (void *)_NRCopyLogObjectForNRUUID(v7[6], v7);
        int v19 = _NRLogIsLevelEnabled(v18, 0LL);

        if (v19)
        {
          int v21 = (void *)_NRCopyLogObjectForNRUUID(val[6], v20);
          _NRLogWithArgs( v21,  0LL,  "%s%.30s:%-4d dns proxy invalidated",  "",  "-[NRDNSProxyServer startDNS53Server]_block_invoke",  355);
        }

        uint64_t v7 = val;
        if (!*((_BYTE *)val + 12))
        {
          int v17 = 4;
LABEL_22:
          sub_10001B5C8(v7, v17);
          uint64_t v7 = val;
        }

        break;
      case 2:
        id v22 = (void *)_NRCopyLogObjectForNRUUID(v7[6], v7);
        int v23 = _NRLogIsLevelEnabled(v22, 0LL);

        if (!v23)
        {
          int v17 = 4;
          goto LABEL_21;
        }

        id v16 = (void *)_NRCopyLogObjectForNRUUID(val[6], v24);
        _NRLogWithArgs( v16,  0LL,  "%s%.30s:%-4d dns proxy interrupted",  "",  "-[NRDNSProxyServer startDNS53Server]_block_invoke",  351);
        int v17 = 4;
LABEL_19:

LABEL_21:
        uint64_t v7 = val;
        goto LABEL_22;
      case 1:
        id v11 = (void *)_NRCopyLogObjectForNRUUID(v7[6], v7);
        int v12 = _NRLogIsLevelEnabled(v11, 0LL);

        if (v12)
        {
          int v14 = (void *)_NRCopyLogObjectForNRUUID(val[6], v13);
          _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d dns proxy started",  "",  "-[NRDNSProxyServer startDNS53Server]_block_invoke",  346);
        }

        id v15 = *(id *)(a1 + 40);
        id v16 = (void *)val[3];
        val[3] = v15;
        int v17 = 2;
        goto LABEL_19;
    }
  }
}

void sub_10001C4AC(uint64_t a1)
{
  if (a1)
  {
    *(_DWORD *)(a1 + 16) = 1;
    sub_10001B5C8((_BYTE *)a1, 1);
    id v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0LL);

    if (IsLevelEnabled)
    {
      id v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v5);
      _NRLogWithArgs( v6,  0LL,  "%s%.30s:%-4d activating discovery proxy",  "",  "-[NRDiscoveryProxyServer startDiscoveryProxyServer]",  629);
    }

    unsigned __int8 v7 = [*(id *)(a1 + 96) count];
    if (!v7)
    {
      uint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v8);
      int v14 = _NRLogIsLevelEnabled(v13, 16LL);

      if (v14)
      {
        int v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v15);
        _NRLogWithArgs(v12, 16LL, "%s%.30s:%-4d no allowed interfaces for discovery proxy");
        goto LABEL_10;
      }

void sub_10001C9E8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    id v4 = (void *)qword_1001DC6B8;
    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLong:", a1));
    id val = (id)objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v5]);

    if (val)
    {
      if ((_DWORD)a3)
      {
        sub_10001CDA4((uint64_t)val, a3);
LABEL_5:

        return;
      }

      unsigned __int8 v7 = (void *)_NRCopyLogObjectForNRUUID(*((void *)val + 6), v6);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0LL);

      if (IsLevelEnabled)
      {
        int v10 = (void *)_NRCopyLogObjectForNRUUID(*((void *)val + 6), v9);
        _NRLogWithArgs(v10, 0LL, "%s%.30s:%-4d activated discovery proxy", "", "discoveryProxyCallback", 616);
      }

      sub_10001CE44((uint64_t)val);
      if (*((_DWORD *)val + 19) != -1)
      {

        return;
      }

      objc_initWeak(&location, val);
      uint64_t v11 = (dispatch_queue_s *)*((id *)val + 5);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 3221225472LL;
      handler[2] = sub_10001D084;
      handler[3] = &unk_1001B0938;
      objc_copyWeak(&v29, &location);
      uint32_t v12 = notify_register_dispatch("com.apple.srp-mdns-proxy.tls-key-update", (int *)val + 19, v11, handler);

      if (v12)
      {
        if (qword_1001DC6C8 != -1) {
          dispatch_once(&qword_1001DC6C8, &stru_1001AE3E0);
        }
        id v13 = (id)qword_1001DC6C0;
        char v14 = _NRLogIsLevelEnabled(v13, 17LL);

        if ((v14 & 1) == 0) {
          goto LABEL_20;
        }
        if (qword_1001DC6C8 != -1) {
          dispatch_once(&qword_1001DC6C8, &stru_1001AE3E0);
        }
        id v15 = (id)qword_1001DC6C0;
        _NRLogWithArgs( v15,  17LL,  "notify_register_dispatch(%s, %d) failed: %u",  "com.apple.srp-mdns-proxy.tls-key-update",  *((_DWORD *)val + 19),  v12);
      }

      else
      {
        id v16 = *((id *)val + 6);
        uint64_t v18 = (void *)_NRCopyLogObjectForNRUUID(v16, v17);
        int v19 = _NRLogIsLevelEnabled(v18, 0LL);

        if (!v19)
        {
LABEL_20:
          objc_destroyWeak(&v29);
          objc_destroyWeak(&location);
          goto LABEL_5;
        }

        id v15 = *((id *)val + 6);
        id v21 = (void *)_NRCopyLogObjectForNRUUID(v15, v20);
        _NRLogWithArgs( v21,  0LL,  "%s%.30s:%-4d monitoring server certificate changes (%d)",  "",  "-[NRDiscoveryProxyServer watchForServerCertificateChanges]",  603,  *((_DWORD *)val + 19));
      }

      goto LABEL_20;
    }

    id v24 = sub_10001AE98();
    int v25 = _NRLogIsLevelEnabled(v24, 17LL);

    if (v25)
    {
      id v26 = sub_10001AE98();
      _NRLogWithArgs(v26, 17LL, "%s called with null server", "discoveryProxyCallback");
    }
  }

  else
  {
    id v22 = sub_10001AE98();
    int v23 = _NRLogIsLevelEnabled(v22, 17LL);

    if (v23)
    {
      id val = sub_10001AE98();
      _NRLogWithArgs(val, 17LL, "%s called with null ref", "discoveryProxyCallback");
      goto LABEL_5;
    }
  }

void sub_10001CD84(_Unwind_Exception *a1)
{
}

void sub_10001CDA4(uint64_t a1, uint64_t a2)
{
  int v2 = a2;
  id v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16LL);

  if (IsLevelEnabled)
  {
    unsigned __int8 v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v6);
    _NRLogWithArgs( v7,  16LL,  "%s%.30s:%-4d SRP proxy failed (error:%d)",  "",  "-[NRDiscoveryProxyServer handleDiscoverProxyServerFailed:]",  551,  v2);
  }

  uint64_t v8 = *(void **)(a1 + 32);
  *(void *)(a1 + 32) = 0LL;

  sub_10001B5C8((_BYTE *)a1, 4);
}

void sub_10001CE44(uint64_t a1)
{
  int v2 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 48));
  id v3 = sub_10012CD2C(v2, @"853");
  id v4 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = v3;

  objc_initWeak(&location, (id)a1);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  int v10 = sub_10001D0F4;
  uint64_t v11 = &unk_1001AE3C0;
  objc_copyWeak(&v12, &location);
  uint64_t v5 = v9;
  uint64_t v19 = 0LL;
  uint64_t v20 = &v19;
  uint64_t v21 = 0x3032000000LL;
  id v22 = sub_10001D184;
  int v23 = sub_10001D194;
  CFDataRef v24 = sub_10001D19C(a1);
  if (v20[5])
  {
    ((void (*)(void *))v10)(v5);
  }

  else
  {
    objc_initWeak(&from, (id)a1);
    uint64_t v6 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_timer,  0LL,  0LL,  *(dispatch_queue_t *)(a1 + 40));
    dispatch_source_set_timer(v6, 0LL, 0x2540BE400uLL, 0x3B9ACA00uLL);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_10001D6E8;
    handler[3] = &unk_1001AE398;
    objc_copyWeak(&v17, &from);
    id v16 = &v19;
    id v15 = v5;
    dispatch_source_set_event_handler(v6, handler);
    dispatch_activate(v6);
    unsigned __int8 v7 = *(void **)(a1 + 88);
    *(void *)(a1 + 8_Block_object_dispose((const void *)(v27 - 152), 8) = v6;
    uint64_t v8 = v6;

    objc_destroyWeak(&v17);
    objc_destroyWeak(&from);
  }

  _Block_object_dispose(&v19, 8);

  objc_destroyWeak(&v12);
  objc_destroyWeak(&location);
}

void sub_10001D054( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, char a23)
{
}

void sub_10001D084(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained && !WeakRetained[12] && *((_DWORD *)WeakRetained + 19) == a2 && WeakRetained[8] == 2)
  {
    id v4 = WeakRetained;
    sub_10001B5C8(WeakRetained, 3);
    sub_10001CE44((uint64_t)v4);
    id WeakRetained = v4;
  }
}

void sub_10001D0F4(uint64_t a1, void *a2)
{
  id v6 = a2;
  id WeakRetained = (unsigned __int8 *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v5 = WeakRetained;
  if (WeakRetained && (WeakRetained[8] | 2) == 3 && !WeakRetained[12])
  {
    objc_storeStrong((id *)WeakRetained + 4, a2);
    if (v6) {
      sub_10001B5C8(v5, 2);
    }
    else {
      sub_10001CDA4((uint64_t)v5, 4294901759LL);
    }
  }
}

uint64_t sub_10001D184(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_10001D194(uint64_t a1)
{
}

CFDataRef sub_10001D19C(uint64_t a1)
{
  v70[0] = kSecClass;
  v70[1] = kSecMatchLimit;
  v71[0] = kSecClassCertificate;
  v71[1] = kSecMatchLimitAll;
  v70[2] = kSecAttrAccessGroup;
  v70[3] = kSecAttrSynchronizable;
  v71[2] = @"com.apple.srp-mdns-proxy";
  v71[3] = &__kCFBooleanTrue;
  v70[4] = kSecReturnAttributes;
  v70[5] = kSecReturnRef;
  void v71[4] = &__kCFBooleanTrue;
  v71[5] = &__kCFBooleanTrue;
  int v2 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v71,  v70,  6LL));
  CFTypeRef result = 0LL;
  id v4 = (const char *)SecItemCopyMatching(v2, &result);
  if ((_DWORD)v4 || !result)
  {
    if (result)
    {
      CFRelease(result);
      CFTypeRef result = 0LL;
    }

    if ((_DWORD)v4 == -25308)
    {
      BOOL v36 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v3);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v36, 16LL);

      if (IsLevelEnabled)
      {
        uint64_t v27 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v38);
        int v28 = (void *)v27;
        uint64_t v68 = 463LL;
        __int128 v66 = "";
        __int128 v67 = "-[NRDiscoveryProxyServer copyServerCertificateData]";
        id v29 = "%s%.30s:%-4d Failed to retrieve SRP Pk: keychain locked";
        goto LABEL_22;
      }
    }

    else if ((_DWORD)v4 == -25300)
    {
      CFDataRef v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v3);
      int v25 = _NRLogIsLevelEnabled(v24, 16LL);

      if (v25)
      {
        uint64_t v27 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v26);
        int v28 = (void *)v27;
        uint64_t v68 = 461LL;
        __int128 v66 = "";
        __int128 v67 = "-[NRDiscoveryProxyServer copyServerCertificateData]";
        id v29 = "%s%.30s:%-4d Failed to retrieve SRP Pk: not found";
LABEL_22:
        uint64_t v39 = 16LL;
LABEL_25:
        _NRLogWithArgs(v27, v39, v29, v66, v67, v68);

        CFDataRef v18 = 0LL;
        goto LABEL_34;
      }
    }

    else
    {
      int v40 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v3);
      int v41 = _NRLogIsLevelEnabled(v40, 17LL);

      if (v41)
      {
        uint64_t v27 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v42);
        int v28 = (void *)v27;
        __int128 v66 = v4;
        id v29 = "Failed to retrieve SRP Pk: %d";
        uint64_t v39 = 17LL;
        goto LABEL_25;
      }
    }

    CFDataRef v18 = 0LL;
    goto LABEL_34;
  }

  CFTypeID v5 = CFGetTypeID(result);
  if (v5 != CFArrayGetTypeID())
  {
    id v48 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v6);
    int v49 = _NRLogIsLevelEnabled(v48, 17LL);

    if (!v49) {
      goto LABEL_45;
    }
    id v50 = *(id *)(a1 + 48);
    int v23 = (void *)_NRCopyLogObjectForNRUUID(v50, v51);
    CFTypeID v52 = CFGetTypeID(result);

    CFTypeID v53 = v52;
LABEL_43:
    __int128 v58 = (__CFString *)CFCopyTypeIDDescription(v53);
    _NRLogWithArgs(v23, 17LL, "Read keychain for SRP Pk with bad class %@", v58);
    goto LABEL_44;
  }

  if (!CFArrayGetCount((CFArrayRef)result))
  {
    __int16 v30 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v7);
    int v31 = _NRLogIsLevelEnabled(v30, 16LL);

    if (!v31) {
      goto LABEL_45;
    }
    uint64_t v33 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v32);
    int v23 = (void *)v33;
    uint64_t v68 = 479LL;
    uint64_t v65 = "";
    __int128 v67 = "-[NRDiscoveryProxyServer copyServerCertificateData]";
    int v34 = "%s%.30s:%-4d No SRP Pk(s)";
    goto LABEL_19;
  }

  ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)result, 0LL);
  CFTypeID v9 = CFGetTypeID(ValueAtIndex);
  if (v9 != CFDictionaryGetTypeID())
  {
    __int128 v54 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v10);
    int v55 = _NRLogIsLevelEnabled(v54, 17LL);

    if (!v55) {
      goto LABEL_45;
    }
    int v23 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v56);
    CFTypeID v57 = CFGetTypeID(ValueAtIndex);
    __int128 v58 = (__CFString *)CFCopyTypeIDDescription(v57);
    _NRLogWithArgs(v23, 17LL, "Read keychain for SRP Pk attributes with bad class %@", v58);
LABEL_44:

    goto LABEL_30;
  }

  Value = (void *)CFDictionaryGetValue((CFDictionaryRef)ValueAtIndex, kSecValueRef);
  if (!Value)
  {
    char v59 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v12);
    int v60 = _NRLogIsLevelEnabled(v59, 16LL);

    if (!v60) {
      goto LABEL_45;
    }
    uint64_t v33 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v61);
    int v23 = (void *)v33;
    uint64_t v68 = 492LL;
    uint64_t v65 = "";
    __int128 v67 = "-[NRDiscoveryProxyServer copyServerCertificateData]";
    int v34 = "%s%.30s:%-4d No SRP certificate: not found";
LABEL_19:
    uint64_t v35 = 16LL;
LABEL_29:
    _NRLogWithArgs(v33, v35, v34, v65, v67, v68);
LABEL_30:
    CFDataRef v18 = 0LL;
    goto LABEL_31;
  }

  id v13 = Value;
  CFTypeID v14 = CFGetTypeID(Value);
  if (v14 != SecCertificateGetTypeID())
  {
    id v62 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v15);
    int v63 = _NRLogIsLevelEnabled(v62, 17LL);

    if (!v63) {
      goto LABEL_45;
    }
    int v23 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v64);
    CFTypeID v53 = CFGetTypeID(v13);
    goto LABEL_43;
  }

  double Current = CFAbsoluteTimeGetCurrent();
  if ((SecCertificateIsValid(v13, Current) & 1) == 0)
  {
    id v43 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v17);
    int v44 = _NRLogIsLevelEnabled(v43, 17LL);

    if (v44)
    {
      uint64_t v33 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v45);
      int v23 = (void *)v33;
      int v34 = "Read keychain for invalid SRP Pk";
      uint64_t v35 = 17LL;
      goto LABEL_29;
    }

LABEL_45:
    CFDataRef v18 = 0LL;
    CFTypeRef v46 = result;
    if (!result) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }

  CFDataRef v18 = SecCertificateCopyData((SecCertificateRef)v13);
  uint64_t v20 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v19);
  int v21 = _NRLogIsLevelEnabled(v20, 0LL);

  if (!v21) {
    goto LABEL_32;
  }
  int v23 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 48), v22);
  _NRLogWithArgs( v23,  0LL,  "%s%.30s:%-4d Fetched server certificate of size %u bytes",  "",  "-[NRDiscoveryProxyServer copyServerCertificateData]",  508,  -[__CFData length](v18, "length"));
LABEL_31:

LABEL_32:
  CFTypeRef v46 = result;
  if (result)
  {
LABEL_33:
    CFRelease(v46);
    CFTypeRef result = 0LL;
  }
}

  -[NSMutableArray addObject:](v8, "addObject:", @"CongestionNotHigh");
  if ((reason & 0x1000000) == 0)
  {
LABEL_20:
    if ((reason & 0x2000000) == 0) {
      goto LABEL_21;
    }
    goto LABEL_47;
  }

  -[NSMutableArray addObject:](v3, "addObject:", @"TxDone");
  if ((a1 & 0x200000000000000LL) == 0)
  {
LABEL_20:
    if ((a1 & 0x400000000000000LL) == 0) {
      goto LABEL_21;
    }
    goto LABEL_47;
  }

          CFDataRef v18 = v21;
          uint64_t v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          uint64_t v17 = v25;
          goto LABEL_54;
        }

        v145 = v41;
        if (gNRPacketLoggingEnabled)
        {
          ESPSequenceNumberFromPacket = getESPSequenceNumberFromPacket(v146, v41);
          if (gNRPacketLoggingEnabled)
          {
            getESPSPIFromPacket(v146, v145);
            __int128 v73 = gNRPacketLoggingEnabled;
            *(void *)&v3[v20] |= 0x8000000uLL;
            if (v73)
            {
              __int128 v74 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v72);
              __int128 v75 = _NRLogIsLevelEnabled(v74, 1LL);

              if (v75)
              {
                __int128 v77 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v76);
                __int128 v78 = [v3 copyDescription];
                _NRLogWithArgs( v77,  1LL,  "%s%.30s:%-4d %@: DatagramLink:Received ESP sequence number: %u",  "",  "NRLinkDatagramLinkToNexusLoop",  4295LL,  v78,  ESPSequenceNumberFromPacket);
              }
            }

            uint64_t v17 = v25;
            goto LABEL_38;
          }
        }

        else
        {
          ESPSequenceNumberFromPacket = 0LL;
        }

        uint64_t v17 = v25;
        *(void *)&v3[v20] |= 0x8000000uLL;
LABEL_38:
        id v43 = os_channel_slot_get_packet(*(void *)(v3 + 543), v18);
        if ((v147[0] & 0x10000LL) != 0 || v3[245])
        {
          v3[245] = 0;
          int v49 = v139;
          *(void *)(v139 + 7) = 0LL;
          *int v49 = 0LL;
          v152 = 1;
          if (v43)
          {
            os_packet_set_flow_uuid(v43, &v152);
            *(void *)&v3[v20] |= 0x10000000uLL;
            if (gNRPacketLoggingEnabled)
            {
              __int128 v79 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v50);
              id v80 = _NRLogIsLevelEnabled(v79, 1LL);

              if (v80)
              {
                int v82 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v81);
                uint64_t v83 = [v3 copyDescription];
                _NRLogWithArgs( v82,  1LL,  "%s%.30s:%-4d %@: DatagramLink:Set waking metadata for packet w/ ESP sequence number: %u",  "",  "NRLinkDatagramLinkToNexusLoop",  4307LL,  v83,  ESPSequenceNumberFromPacket);
              }
            }
          }

          uint64_t v51 = v146;
          CFTypeID v52 = v145;
          CFTypeID v53 = getESPSequenceNumberFromPacket(v146, v145);
          ESPSPIFromPacket = getESPSPIFromPacket(v51, v52);
          if (qword_1001DC9E8 != -1) {
            dispatch_once(&qword_1001DC9E8, &stru_1001AFB78);
          }
          int v55 = (dispatch_queue_s *)(id)qword_1001DC9E0;
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472LL;
          block[2] = sub_10008BBD0;
          block[3] = &unk_1001B0578;
          v150 = ESPSPIFromPacket;
          v151 = v53;
          dispatch_async(v55, block);

          uint64_t v17 = v25;
        }

        else if (v43)
        {
          os_packet_clear_flow_uuid();
        }

        os_channel_set_slot_properties(*(void *)(v3 + 543), v18, v144);
        *(void *)(v3 + 1391) += v38;
        *(void *)(v3 + 655) += v41;
        ++*(void *)(v3 + 639);
        uint64_t v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
LABEL_54:
        if (*(void *)&v3[v17[388]] && *(void *)(v3 + 1911))
        {
          v3[255] = v3[255] % v3[254];
          uint64_t v56 = *(void *)(v3 + 1911);
          CFTypeID v57 = (void *)(v56 + 8LL * v3[255]);
          if ((unint64_t)(v57 + 1) <= v56 + 8 * (unint64_t)v3[254])
          {
            if ((v57 & 7) == 0)
            {
              *CFTypeID v57 = *(void *)&v3[v17[388]];
              ++v3[255];
              *(void *)&v3[v17[388]] = 0LL;
            }
          }

          else
          {
            __int128 v58 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v34);
            char v59 = _NRLogIsLevelEnabled(v58, 17LL);

            if (v59)
            {
              uint64_t v61 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v60);
              id v62 = [v3 copyDescription];
              _NRLogWithArgs( v61,  17LL,  "%@: invalid index for link log list (curIdx: %u)",  v62,  v3[255]);
            }
          }
        }

        uint64_t v19 = v140;
      }

      uint64_t v84 = v18;
      if (!v3[223] && *(void *)(v3 + 1063))
      {
        id v85 = v19;
        v3[223] = 1;
        ++*(void *)(v3 + 1079);
        if (gNRPacketLoggingEnabled)
        {
          v120 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v23);
          __int128 v121 = _NRLogIsLevelEnabled(v120, 1LL);

          if (v121)
          {
            __int128 v123 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v122);
            __int128 v124 = [v3 copyDescription];
            _NRLogWithArgs( v123,  1LL,  "%s%.30s:%-4d %@: source-suspend: DatagramLinkInput",  "",  "NRLinkSuspendDatagramLinkInputSource",  816LL,  v124);
          }
        }

        dispatch_suspend(*(dispatch_object_t *)(v3 + 1063));
        uint64_t v19 = v85;
      }

      if (!v3[215] || !*(void *)(v3 + 559))
      {
        id v87 = 0x800000LL;
        goto LABEL_94;
      }

      int v86 = v19;
      v3[215] = 0;
      ++*(void *)(v3 + 575);
      if (gNRPacketLoggingEnabled)
      {
        uint64_t v110 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v23);
        uint64_t v111 = _NRLogIsLevelEnabled(v110, 1LL);

        if (v111)
        {
          v113 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v112);
          v114 = [v3 copyDescription];
          _NRLogWithArgs( v113,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusVOOutput",  "",  "NRLinkResumeNexusVOOutputSource",  845LL,  v114);
        }
      }

      dispatch_resume(*(dispatch_object_t *)(v3 + 559));
      id v87 = 0x800000LL;
LABEL_93:
      uint64_t v19 = v86;
LABEL_94:
      *(void *)&v3[v20] |= v87;
      if (v19)
      {
        *(void *)&v3[v17[388]] |= 0x800000000uLL;
        if (gNRPacketLoggingEnabled)
        {
          int v97 = v19;
          uint64_t v98 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v23);
          int v99 = _NRLogIsLevelEnabled(v98, 1LL);

          if (v99)
          {
            int v101 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v100);
            uint64_t v102 = [v3 copyDescription];
            _NRLogWithArgs( v101,  1LL,  "%s%.30s:%-4d %@: DatagramLink:advancing past datagramLinkInputSlot=%p and syncing link input",  "",  "NRLinkDatagramLinkToNexusLoop",  4338LL,  v102,  v97);
          }

          uint64_t v19 = v97;
          if (gNRPacketLoggingEnabled)
          {
            int v103 = objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
            id v104 = *(void **)(v3 + 1695);
            *(void *)(v3 + 1695) = v103;
          }
        }

        os_channel_advance_slot(*(void *)&v3[v10[125]], v19);
        os_channel_sync(*(void *)(v3 + 1039), 1LL);
        ++*(void *)(v3 + 1439);
      }

      int v89 = v19;
      if (v84)
      {
        *(void *)&v3[v17[388]] |= 0x1000000000uLL;
        if (gNRPacketLoggingEnabled)
        {
          int v105 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v23);
          uint64_t v106 = _NRLogIsLevelEnabled(v105, 1LL);

          if (v106)
          {
            uint64_t v108 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v107);
            uint64_t v109 = [v3 copyDescription];
            _NRLogWithArgs( v108,  1LL,  "%s%.30s:%-4d %@: DatagramLink:advancing past nexusOutputSlot=%p and syncing nexus output",  "",  "NRLinkDatagramLinkToNexusLoop",  4347LL,  v109,  v84);
          }
        }

        os_channel_advance_slot(*(void *)(v3 + 543), v84);
        os_channel_sync(*(void *)(v3 + 527), 0LL);
        ++*(void *)(v3 + 623);
      }

      if (*(void *)&v3[v17[388]] && *(void *)(v3 + 1911))
      {
        v3[255] = v3[255] % v3[254];
        id v90 = *(void *)(v3 + 1911);
        int v91 = (void *)(v90 + 8LL * v3[255]);
        if ((unint64_t)(v91 + 1) <= v90 + 8 * (unint64_t)v3[254])
        {
          if ((v91 & 7) == 0)
          {
            *int v91 = *(void *)&v3[v17[388]];
            ++v3[255];
            *(void *)&v3[v17[388]] = 0LL;
          }
        }

        else
        {
          id v92 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v23);
          uint64_t v93 = _NRLogIsLevelEnabled(v92, 17LL);

          if (v93)
          {
            int v95 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v94);
            id v96 = [v3 copyDescription];
            _NRLogWithArgs(v95, 17LL, "%@: invalid index for link log list (curIdx: %u)", v96, v3[255]);
          }
        }
      }

      if (!(v84 | v89)) {
        goto LABEL_12;
      }
    }
  }

  uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(v1[4], v2);
  uint64_t v12 = _NRLogIsLevelEnabled(v11, 17LL);

  if (v12)
  {
    uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v13);
    CFTypeID v9 = [v3 copyDescription];
    _NRLogWithArgs(v8, 17LL, "%@: Tried to linkToNexusLoop but bad state", v9);
    goto LABEL_11;
  }

  -[NRLink checkProxyAgentWithForceUpdate:](self, "checkProxyAgentWithForceUpdate:", 1LL);
  return -[NRLink state](self, "state") != 255;
}

void sub_10001D6E8(uint64_t a1)
{
  id WeakRetained = (dispatch_source_t *)objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained && !*((_BYTE *)WeakRetained + 12))
  {
    ++*((_BYTE *)WeakRetained + 72);
    uint64_t v12 = WeakRetained;
    CFDataRef v3 = sub_10001D19C((uint64_t)WeakRetained);
    uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8LL);
    CFTypeID v5 = *(void **)(v4 + 40);
    *(void *)(v4 + 40) = v3;

    if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL) || *((unsigned __int8 *)v12 + 72) >= 5u)
    {
      dispatch_source_cancel(v12[11]);
      dispatch_source_t v7 = v12[11];
      v12[11] = 0LL;

      if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL)) {
        *((_BYTE *)v12 + 72) = 0;
      }
      (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
    }

    else
    {
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(v12[6], v6);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 1LL);

      id WeakRetained = v12;
      if (!IsLevelEnabled) {
        goto LABEL_9;
      }
      uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(v12[6], v10);
      _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d failed to get SRP server certificate, retrying",  "",  "-[NRDiscoveryProxyServer fetchServerCertificateWithCompletion:]_block_invoke",  542);
    }

    id WeakRetained = v12;
  }

id *sub_10001D84C(id *a1, void *a2, void *a3, void *a4, void *a5, void *a6, int a7, char a8)
{
  id v16 = a2;
  id v17 = a3;
  id v18 = a4;
  id v19 = a5;
  id v20 = a6;
  if (a1)
  {
    v26.receiver = a1;
    v26.super_class = (Class)&OBJC_CLASS___NRDNSProxyClient;
    int v21 = (id *)objc_msgSendSuper2(&v26, "initWithQueue:nrUUID:delegate:", v17, v18, v19);
    if (v21)
    {
      a1 = v21;
      objc_storeStrong(v21 + 3, a2);
      objc_storeStrong(a1 + 4, a6);
      *((_DWORD *)a1 + 4) = a7;
      *((_BYTE *)a1 + 13) = a8;
    }

    else
    {
      id v23 = sub_10001AE98();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v23, 17LL);

      if (IsLevelEnabled)
      {
        id v25 = sub_10001AE98();
        _NRLogWithArgs( v25,  17LL,  "%s called with null self",  "-[NRDNSProxyClient initWithServerEndpoint:queue:nrUUID:delegate:serverCertificateData:resolverProtocol:isDiscoveryProxy:]");
      }

      a1 = 0LL;
    }
  }

  return a1;
}

id *sub_10001DAD4(id *a1, void *a2, char a3)
{
  id v7 = a2;
  uint64_t v8 = v7;
  if (!a1) {
    goto LABEL_26;
  }
  if (!v7)
  {
    id v25 = sub_10001DF04();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v25, 17LL);

    if (!IsLevelEnabled) {
      goto LABEL_26;
    }
    id v16 = (char *)sub_10001DF04();
    _NRLogWithArgs(v16, 17LL, "%s called with null interfaceName");
LABEL_25:

LABEL_26:
    id v23 = 0LL;
    goto LABEL_27;
  }

  v34.receiver = a1;
  v34.super_class = (Class)&OBJC_CLASS___NRSCDInterfaceConfig;
  CFTypeID v9 = (id *)objc_msgSendSuper2(&v34, "init");
  if (!v9)
  {
    id v27 = sub_10001DF04();
    int v28 = _NRLogIsLevelEnabled(v27, 16LL);

    id v16 = "-[NRSCDInterfaceConfig initWithInterfaceName:allowsLinkLocalAddresses:]";
    if (v28)
    {
      id v29 = sub_10001DF04();
      _NRLogWithArgs( v29,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRSCDInterfaceConfig initWithInterfaceName:allowsLinkLocalAddresses:]",  37);
    }

    uint64_t v8 = (void *)_os_log_pack_size(12LL);
    a1 = (id *)((char *)&v33 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL));
    __int16 v30 = __error();
    uint64_t v31 = _os_log_pack_fill(a1, v8, *v30, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)uint64_t v31 = 136446210;
    *(void *)(v31 + 4) = "-[NRSCDInterfaceConfig initWithInterfaceName:allowsLinkLocalAddresses:]";
    id v32 = sub_10001DF04();
    _NRLogAbortWithPack(v32, a1);
LABEL_33:
    dispatch_once(&qword_1001DC6D8, &stru_1001AE428);
LABEL_9:
    if (_NRLogIsLevelEnabled(qword_1001DC6D0, 17LL))
    {
      if (p_class_meths[219] != (__objc2_meth_list *)-1LL) {
        dispatch_once(&qword_1001DC6D8, &stru_1001AE428);
      }
      _NRLogWithArgs(qword_1001DC6D0, 17LL, "SCDynamicStoreKeyCreateNetworkInterfaceEntity(%s/IPv4) failed");
    }

    goto LABEL_25;
  }

  a1 = v9;
  objc_storeStrong(v9 + 3, a2);
  uint64_t v10 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  id v11 = a1[7];
  a1[7] = v10;

  uint64_t v12 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  id v13 = a1[8];
  a1[8] = v12;

  CFTypeID v14 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v15 = a1[9];
  a1[9] = v14;

  *((_BYTE *)a1 + _Block_object_dispose((const void *)(v27 - 152), 8) = a3;
  sub_10001DF44((uint64_t)a1);
  id v16 = (char *)a1[3];
  [v16 UTF8String];
  CFStringRef NetworkInterfaceEntity = SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainState,  (CFStringRef)a1[3],  kSCEntNetIPv4);
  id v18 = a1[4];
  a1[4] = (id)NetworkInterfaceEntity;

  if (!a1[4])
  {
    p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    if (qword_1001DC6D8 == -1) {
      goto LABEL_9;
    }
    goto LABEL_33;
  }

  CFStringRef v19 = SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainState,  (CFStringRef)a1[3],  kSCEntNetIPv6);
  id v20 = a1[5];
  a1[5] = (id)v19;

  if (!a1[5])
  {
    if (qword_1001DC6D8 != -1) {
      dispatch_once(&qword_1001DC6D8, &stru_1001AE428);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC6D0, 17LL))
    {
      if (qword_1001DC6D8 != -1) {
        dispatch_once(&qword_1001DC6D8, &stru_1001AE428);
      }
      _NRLogWithArgs(qword_1001DC6D0, 17LL, "SCDynamicStoreKeyCreateNetworkInterfaceEntity(%s/IPv6) failed");
    }

    goto LABEL_25;
  }

  CFStringRef v21 = SCDynamicStoreKeyCreateNetworkInterfaceEntity( 0LL,  kSCDynamicStoreDomainState,  (CFStringRef)a1[3],  kSCEntNetLink);
  id v22 = a1[6];
  a1[6] = (id)v21;

  if (!a1[6])
  {
    if (qword_1001DC6D8 != -1) {
      dispatch_once(&qword_1001DC6D8, &stru_1001AE428);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC6D0, 17LL))
    {
      if (qword_1001DC6D8 != -1) {
        dispatch_once(&qword_1001DC6D8, &stru_1001AE428);
      }
      _NRLogWithArgs(qword_1001DC6D0, 17LL, "SCDynamicStoreKeyCreateNetworkInterfaceEntity(%s/Link) failed");
    }

    goto LABEL_25;
  }

  a1 = a1;
  id v23 = a1;
LABEL_27:

  return v23;
}

id sub_10001DF04()
{
  if (qword_1001DC6D8 != -1) {
    dispatch_once(&qword_1001DC6D8, &stru_1001AE428);
  }
  return (id)qword_1001DC6D0;
}

void sub_10001DF44(uint64_t a1)
{
  id v3 = *(id *)(a1 + 24);
  unsigned int v2 = if_nametoindex((const char *)[v3 UTF8String]);
  *(_DWORD *)(a1 + 12) = v2;
  if (!v2)
  {
    if (qword_1001DC6D8 != -1) {
      dispatch_once(&qword_1001DC6D8, &stru_1001AE428);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC6D0, 0LL))
    {
      if (qword_1001DC6D8 != -1) {
        dispatch_once(&qword_1001DC6D8, &stru_1001AE428);
      }
      _NRLogWithArgs( qword_1001DC6D0,  0LL,  "%s%.30s:%-4d interface index unavailable for '%@'",  "",  "-[NRSCDInterfaceConfig updateIFIndex]",  90LL,  *(void *)(a1 + 24));
    }
  }
}

void sub_10001E024(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  unsigned int v2 = (void *)qword_1001DC6D0;
  qword_1001DC6D0 = (uint64_t)v1;
}

uint64_t sub_10001E054(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (!*(_DWORD *)(result + 12) || !*(_BYTE *)(result + 9)) {
      return 0LL;
    }
    id v2 = *(id *)(result + 56);
    if ([v2 count])
    {

      return 1LL;
    }

    id v3 = [*(id *)(v1 + 64) count];

    return v3 != 0;
  }

  return result;
}

void sub_10001FBD0(id a1)
{
  uint64_t v1 = (dispatch_queue_attr_s *)_NRCopySerialQueueAttr(a1);
  dispatch_queue_t v2 = dispatch_queue_create("terminusd_awdl_browse", v1);

  if (!v2)
  {
    id v4 = sub_10001FD38();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16LL);

    if (IsLevelEnabled)
    {
      id v6 = sub_10001FD38();
      _NRLogWithArgs( v6,  16LL,  "%s%.30s:%-4d ABORTING: dispatch_queue_create(%s) failed",  "",  "nr_dispatch_queue_create",  118,  "terminusd_awdl_browse");
    }

    uint64_t v7 = _os_log_pack_size(22LL);
    uint64_t v8 = (char *)&v12 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    CFTypeID v9 = __error();
    uint64_t v10 = _os_log_pack_fill( v8,  v7,  *v9,  &_mh_execute_header,  "%{public}s dispatch_queue_create(%s) failed");
    *(_DWORD *)uint64_t v10 = 136446466;
    *(void *)(v10 + 4) = "nr_dispatch_queue_create";
    *(_WORD *)(v10 + 12) = 2080;
    *(void *)(v10 + 14) = "terminusd_awdl_browse";
    id v11 = sub_10001FD38();
    _NRLogAbortWithPack(v11, v8);
  }

  id v3 = (void *)qword_1001DC6F0;
  qword_1001DC6F0 = (uint64_t)v2;
}

id sub_10001FD38()
{
  if (qword_1001DC6E8 != -1) {
    dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
  }
  return (id)qword_1001DC6E0;
}

void sub_10001FD78( uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8, uint64_t a9, void *a10)
{
  if (a4)
  {
    if (qword_1001DC6E8 != -1) {
      dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC6E0, 16LL))
    {
      if (qword_1001DC6E8 != -1) {
        dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
      }
      _NRLogWithArgs(qword_1001DC6E0, 16LL, "%s%.30s:%-4d received error %d");
    }
  }

  else if (a5)
  {
    if (a6)
    {
      if (a10)
      {
        id v19 = a10;
        uint64_t v15 = objc_opt_class(&OBJC_CLASS___BTPResolver);
        if ((objc_opt_isKindOfClass(v19, v15) & 1) != 0)
        {
          id v16 = 0LL;
          if (a8 && a9) {
            id v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](&OBJC_CLASS___NSData, "dataWithBytes:length:", a9, a8));
          }
          id v17 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", a5);
          id v18 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", a6);
          [v19 handleReplyFullName:v17 hostTarget:v18 port:a7 txtRecord:v16 ifIndex:a3];
        }

        else
        {
          if (qword_1001DC6E8 != -1) {
            dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC6E0, 16LL))
          {
            if (qword_1001DC6E8 != -1) {
              dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
            }
            _NRLogWithArgs( qword_1001DC6E0,  16LL,  "%s%.30s:%-4d received context of wrong class",  "",  "btpResolveReply",  469);
          }
        }
      }

      else
      {
        if (qword_1001DC6E8 != -1) {
          dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC6E0, 16LL))
        {
          if (qword_1001DC6E8 != -1) {
            dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
          }
          _NRLogWithArgs(qword_1001DC6E0, 16LL, "%s%.30s:%-4d received NULL context");
        }
      }
    }

    else
    {
      if (qword_1001DC6E8 != -1) {
        dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC6E0, 16LL))
      {
        if (qword_1001DC6E8 != -1) {
          dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
        }
        _NRLogWithArgs(qword_1001DC6E0, 16LL, "%s%.30s:%-4d received NULL hostTarget");
      }
    }
  }

  else
  {
    if (qword_1001DC6E8 != -1) {
      dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC6E0, 16LL))
    {
      if (qword_1001DC6E8 != -1) {
        dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
      }
      _NRLogWithArgs(qword_1001DC6E0, 16LL, "%s%.30s:%-4d received NULL fullName");
    }
  }

void sub_100020168(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  dispatch_queue_t v2 = (void *)qword_1001DC6E0;
  qword_1001DC6E0 = (uint64_t)v1;
}

void sub_100020198( uint64_t a1, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  if (a4)
  {
    if (qword_1001DC6E8 != -1) {
      dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC6E0, 16LL))
    {
      if (qword_1001DC6E8 != -1) {
        dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
      }
      _NRLogWithArgs(qword_1001DC6E0, 16LL, "%s%.30s:%-4d received error %d");
    }

    return;
  }

  if (a5)
  {
    if (a6)
    {
      if (a7)
      {
        if (a8)
        {
          id v17 = a8;
          uint64_t v13 = objc_opt_class(&OBJC_CLASS___BTPBrowser);
          if ((objc_opt_isKindOfClass(v17, v13) & 1) != 0)
          {
            CFTypeID v14 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", a5);
            uint64_t v15 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", a6);
            id v16 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", a7);
            [v17 handleReplyName:v14 type:v15 domain:v16 ifIndex:a3 add:(a2 >> 1) & 1];
          }

          else
          {
            if (qword_1001DC6E8 != -1) {
              dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
            }
            CFTypeID v14 = (NSString *)sub_10001FD38();
            _NRLogWithArgs(v14, 16LL, "%s%.30s:%-4d received context of wrong class", "", "btpBrowseReply", 517);
          }

LABEL_42:
          return;
        }

        if (qword_1001DC6E8 != -1) {
          dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC6E0, 16LL))
        {
          id v17 = sub_10001FD38();
          _NRLogWithArgs(v17, 16LL, "%s%.30s:%-4d received NULL context", "", "btpBrowseReply", 512);
          goto LABEL_42;
        }
      }

      else
      {
        if (qword_1001DC6E8 != -1) {
          dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC6E0, 16LL))
        {
          if (qword_1001DC6E8 != -1) {
            dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
          }
          _NRLogWithArgs(qword_1001DC6E0, 16LL, "%s%.30s:%-4d received NULL domain");
        }
      }
    }

    else
    {
      if (qword_1001DC6E8 != -1) {
        dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC6E0, 16LL))
      {
        if (qword_1001DC6E8 != -1) {
          dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
        }
        _NRLogWithArgs(qword_1001DC6E0, 16LL, "%s%.30s:%-4d received NULL type");
      }
    }
  }

  else
  {
    if (qword_1001DC6E8 != -1) {
      dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC6E0, 16LL))
    {
      if (qword_1001DC6E8 != -1) {
        dispatch_once(&qword_1001DC6E8, &stru_1001AE448);
      }
      _NRLogWithArgs(qword_1001DC6E0, 16LL, "%s%.30s:%-4d received NULL name");
    }
  }

NSString *sub_100020934(unsigned int a1)
{
  switch(a1)
  {
    case 0u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "Invalid";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 1u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "Hello";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 2u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "UpdateWiFiAddressIPv6";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 3u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "UpdateWiFiAddressIPv4";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 4u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "UpdateWiFiSignature";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 5u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "PreferWiFi";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 6u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "DeviceLinkState";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 7u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "PreferWiFiAck";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 8u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "ForceWoW";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 9u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "UpdateAWDLAddressIPv6";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 0xAu:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "AWDLReachable";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 0xBu:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "RequestFlags";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 0xCu:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "NetInfo";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 0xDu:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "LinkUpgrade";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 0xEu:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "DeviceThermalPressureLevel";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 0xFu:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "CountryCode";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 0x10u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "DNSProxy";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 0x11u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "DNSProxyUpdate";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 0x12u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "DiscoveryProxy";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 0x13u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "DiscoveryProxyUpdate";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 0x14u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "ApplicationServiceEndpointsRequest";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 0x15u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "ApplicationServiceEndpointsResponse";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 0x16u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "DevicePluggedIn";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    case 0x17u:
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "TLSIdentitySPKI";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
    default:
      if (a1 != 255) {
        return -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown(%lld)",  a1);
      }
      os_log_t v1 = objc_alloc(&OBJC_CLASS___NSString);
      dispatch_queue_t v2 = "Test";
      return -[NSString initWithUTF8String:](v1, "initWithUTF8String:", v2);
  }

unint64_t sub_100020CF0(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  unint64_t v1 = *(void *)(a1 + 40);
  if (!v1)
  {
    int v2 = *(unsigned __int8 *)(a1 + 10);
    if (*(_BYTE *)(a1 + 10))
    {
      uint64_t v3 = *(void *)(a1 + 48);
      if (v3)
      {
        if (v2 == 2)
        {
          unint64_t v1 = bswap64(*(void *)(v3 + 8));
          goto LABEL_10;
        }

        if (v2 == 1)
        {
          unint64_t v1 = bswap32(*(unsigned __int16 *)(v3 + 4)) >> 16;
LABEL_10:
          *(void *)(a1 + 40) = v1;
          return v1;
        }

        return 0LL;
      }

      id v12 = sub_100020F30();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 16LL);

      if (IsLevelEnabled)
      {
        id v14 = sub_100020F30();
        _NRLogWithArgs( v14,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (self.messageBufferPtr) != ((void *)0)",  "",  "-[NRLinkDirectorMessage identifier]",  555);
      }

      uint64_t v15 = _os_log_pack_size(12LL);
      CFTypeID v9 = (char *)&v19 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v16 = __error();
      uint64_t v17 = _os_log_pack_fill( v9,  v15,  *v16,  &_mh_execute_header,  "%{public}s Assertion Failed: (self.messageBufferPtr) != ((void *)0)");
      *(_DWORD *)uint64_t v17 = 136446210;
      *(void *)(v17 + 4) = "-[NRLinkDirectorMessage identifier]";
    }

    else
    {
      id v5 = sub_100020F30();
      int v6 = _NRLogIsLevelEnabled(v5, 16LL);

      if (v6)
      {
        id v7 = sub_100020F30();
        _NRLogWithArgs( v7,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: self.messageVersion != 0",  "",  "-[NRLinkDirectorMessage identifier]",  554);
      }

      uint64_t v8 = _os_log_pack_size(12LL);
      CFTypeID v9 = (char *)&v19 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v10 = __error();
      uint64_t v11 = _os_log_pack_fill( v9,  v8,  *v10,  &_mh_execute_header,  "%{public}s Assertion Failed: self.messageVersion != 0");
      *(_DWORD *)uint64_t v11 = 136446210;
      *(void *)(v11 + 4) = "-[NRLinkDirectorMessage identifier]";
    }

    id v18 = sub_100020F30();
    _NRLogAbortWithPack(v18, v9);
  }

  return v1;
}

id sub_100020F30()
{
  if (qword_1001DC718 != -1) {
    dispatch_once(&qword_1001DC718, &stru_1001AE4C8);
  }
  return (id)qword_1001DC710;
}

void sub_100020F70(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  int v2 = (void *)qword_1001DC710;
  qword_1001DC710 = (uint64_t)v1;
}

void sub_100020FA0(id a1)
{
  os_log_t v1 = sub_100020FCC(objc_alloc(&OBJC_CLASS___NRLinkDirectorMessageManager));
  int v2 = (void *)qword_1001DC700;
  qword_1001DC700 = (uint64_t)v1;
}

void *sub_100020FCC(void *a1)
{
  if (!a1) {
    return 0LL;
  }
  v17.receiver = a1;
  v17.super_class = (Class)&OBJC_CLASS___NRLinkDirectorMessageManager;
  os_log_t v1 = objc_msgSendSuper2(&v17, "init");
  if (!v1)
  {
    id v8 = sub_100020F30();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 16LL);

    if (IsLevelEnabled)
    {
      id v10 = sub_100020F30();
      _NRLogWithArgs( v10,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRLinkDirectorMessageManager initManager]",  255);
    }

    uint64_t v11 = _os_log_pack_size(12LL);
    id v12 = (char *)&v16 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v13 = __error();
    uint64_t v14 = _os_log_pack_fill(v12, v11, *v13, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)uint64_t v14 = 136446210;
    *(void *)(v14 + 4) = "-[NRLinkDirectorMessageManager initManager]";
    id v15 = sub_100020F30();
    _NRLogAbortWithPack(v15, v12);
    return 0LL;
  }

  int v2 = v1;
  uint64_t v3 = sub_100146AFC();
  id v4 = (void *)v2[1];
  v2[1] = v3;

  id v5 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  int v6 = (void *)v2[2];
  v2[2] = v5;

  return v2;
}

unint64_t sub_100021138(unint64_t a1, void *a2, unsigned int a3, char a4)
{
  id v8 = a2;
  CFTypeID v9 = v8;
  if (!a1) {
    goto LABEL_20;
  }
  if (!v8)
  {
    id v17 = sub_100020F30();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v17, 17LL);

    if (IsLevelEnabled)
    {
      id v19 = sub_100020F30();
      _NRLogWithArgs( v19,  17LL,  "%s called with null nrUUID",  "-[NRLinkDirectorMessage initDirectorMessageWithNRUUID:messageLen:messageVersion:]");

      unint64_t v15 = 0LL;
      goto LABEL_11;
    }

uint64_t sub_100021458(uint64_t result, char a2)
{
  if (result)
  {
    if (*(_BYTE *)(result + 10))
    {
      int v2 = *(_BYTE **)(result + 48);
      if (v2)
      {
        return result;
      }

      id v10 = sub_100020F30();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 16LL);

      if (IsLevelEnabled)
      {
        id v12 = sub_100020F30();
        _NRLogWithArgs( v12,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (self.messageBufferPtr) != ((void *)0)",  "",  "-[NRLinkDirectorMessage writeMessageVersionToSendBuffer:]",  416);
      }

      uint64_t v13 = _os_log_pack_size(12LL);
      id v7 = (char *)&v17 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      __int16 v14 = __error();
      uint64_t v15 = _os_log_pack_fill( v7,  v13,  *v14,  &_mh_execute_header,  "%{public}s Assertion Failed: (self.messageBufferPtr) != ((void *)0)");
      *(_DWORD *)uint64_t v15 = 136446210;
      *(void *)(v15 + 4) = "-[NRLinkDirectorMessage writeMessageVersionToSendBuffer:]";
    }

    else
    {
      id v3 = sub_100020F30();
      int v4 = _NRLogIsLevelEnabled(v3, 16LL);

      if (v4)
      {
        id v5 = sub_100020F30();
        _NRLogWithArgs( v5,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: self.messageVersion != 0",  "",  "-[NRLinkDirectorMessage writeMessageVersionToSendBuffer:]",  415);
      }

      uint64_t v6 = _os_log_pack_size(12LL);
      id v7 = (char *)&v17 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v8 = __error();
      uint64_t v9 = _os_log_pack_fill( v7,  v6,  *v8,  &_mh_execute_header,  "%{public}s Assertion Failed: self.messageVersion != 0");
      *(_DWORD *)uint64_t v9 = 136446210;
      *(void *)(v9 + 4) = "-[NRLinkDirectorMessage writeMessageVersionToSendBuffer:]";
    }

    id v16 = sub_100020F30();
    _NRLogAbortWithPack(v16, v7);
  }

  return result;
}

void sub_100021644(uint64_t a1, _WORD *a2, size_t __n)
{
  if (!a1) {
    return;
  }
  int v4 = *(unsigned __int8 *)(a1 + 10);
  if (!*(_BYTE *)(a1 + 10))
  {
    id v10 = sub_100020F30();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 16LL);

    if (IsLevelEnabled)
    {
      id v12 = sub_100020F30();
      _NRLogWithArgs( v12,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: self.messageVersion != 0",  "",  "-[NRLinkDirectorMessage writeMessageIdentifierNBOToSendBuffer:len:]",  439);
    }

    uint64_t v13 = _os_log_pack_size(12LL);
    __int16 v14 = (char *)&v24 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v15 = __error();
    uint64_t v16 = _os_log_pack_fill( v14,  v13,  *v15,  &_mh_execute_header,  "%{public}s Assertion Failed: self.messageVersion != 0");
    *(_DWORD *)uint64_t v16 = 136446210;
    *(void *)(v16 + 4) = "-[NRLinkDirectorMessage writeMessageIdentifierNBOToSendBuffer:len:]";
LABEL_18:
    id v23 = sub_100020F30();
    _NRLogAbortWithPack(v23, v14);
  }

  uint64_t v5 = *(void *)(a1 + 48);
  if (!v5)
  {
    id v17 = sub_100020F30();
    int v18 = _NRLogIsLevelEnabled(v17, 16LL);

    if (v18)
    {
      id v19 = sub_100020F30();
      _NRLogWithArgs( v19,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (self.messageBufferPtr) != ((void *)0)",  "",  "-[NRLinkDirectorMessage writeMessageIdentifierNBOToSendBuffer:len:]",  440);
    }

    uint64_t v20 = _os_log_pack_size(12LL);
    __int16 v14 = (char *)&v24 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v21 = __error();
    uint64_t v22 = _os_log_pack_fill( v14,  v20,  *v21,  &_mh_execute_header,  "%{public}s Assertion Failed: (self.messageBufferPtr) != ((void *)0)");
    *(_DWORD *)uint64_t v22 = 136446210;
    *(void *)(v22 + 4) = "-[NRLinkDirectorMessage writeMessageIdentifierNBOToSendBuffer:len:]";
    goto LABEL_18;
  }

  int v6 = __n;
  if (v4 == 2)
  {
    memcpy((void *)(v5 + 8), a2, __n);
  }

  else if (v4 == 1)
  {
    if (__n >= 3)
    {
      id v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      int v8 = _NRLogIsLevelEnabled(v7, 17LL);

      if (v8)
      {
        id v24 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v9);
        _NRLogWithArgs(v24, 17LL, "Invalid buffer length for message identifier (%u > %zu)", v6, 2uLL);
      }
    }

    else
    {
      *(_WORD *)(v5 + 4) = *a2;
    }
  }

uint64_t sub_1000218FC(uint64_t result, __int16 a2)
{
  int v2 = *(unsigned __int8 *)(result + 10);
  if (!*(_BYTE *)(result + 10))
  {
    id v5 = sub_100020F30();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16LL);

    if (IsLevelEnabled)
    {
      id v7 = sub_100020F30();
      _NRLogWithArgs( v7,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: self.messageVersion != 0",  "",  "-[NRLinkDirectorMessage writeMessagePayloadLengthNBOToSendBuffer:len:]",  465);
    }

    uint64_t v8 = _os_log_pack_size(12LL);
    uint64_t v9 = (char *)&v19 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v10 = __error();
    uint64_t v11 = _os_log_pack_fill( v9,  v8,  *v10,  &_mh_execute_header,  "%{public}s Assertion Failed: self.messageVersion != 0");
    *(_DWORD *)uint64_t v11 = 136446210;
    *(void *)(v11 + 4) = "-[NRLinkDirectorMessage writeMessagePayloadLengthNBOToSendBuffer:len:]";
LABEL_15:
    id v18 = sub_100020F30();
    _NRLogAbortWithPack(v18, v9);
  }

  uint64_t v3 = *(void *)(result + 48);
  if (!v3)
  {
    id v12 = sub_100020F30();
    int v13 = _NRLogIsLevelEnabled(v12, 16LL);

    if (v13)
    {
      id v14 = sub_100020F30();
      _NRLogWithArgs( v14,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (self.messageBufferPtr) != ((void *)0)",  "",  "-[NRLinkDirectorMessage writeMessagePayloadLengthNBOToSendBuffer:len:]",  466);
    }

    uint64_t v15 = _os_log_pack_size(12LL);
    uint64_t v9 = (char *)&v19 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v16 = __error();
    uint64_t v17 = _os_log_pack_fill( v9,  v15,  *v16,  &_mh_execute_header,  "%{public}s Assertion Failed: (self.messageBufferPtr) != ((void *)0)");
    *(_DWORD *)uint64_t v17 = 136446210;
    *(void *)(v17 + 4) = "-[NRLinkDirectorMessage writeMessagePayloadLengthNBOToSendBuffer:len:]";
    goto LABEL_15;
  }

  if (v2 == 1)
  {
    uint64_t v4 = 6LL;
  }

  else
  {
    if (v2 != 2) {
      return result;
    }
    uint64_t v4 = 2LL;
  }

  *(_WORD *)(v3 + v4) = a2;
  return result;
}

void *sub_100021AF8(void *a1, void *a2, int a3)
{
  id v5 = a2;
  id v7 = v5;
  if (!a1)
  {
LABEL_14:
    id v14 = 0LL;
    goto LABEL_15;
  }

  if (a3 == 1)
  {
    uint64_t v8 = (void *)sub_100021138((unint64_t)a1, v5, 8u, 1);
    sub_100021458((uint64_t)v8, 1);
    do
      unsigned int v13 = __ldxr(word_1001DBAC8);
    while (__stxr(v13 + 1, word_1001DBAC8));
    if (!v8) {
      goto LABEL_11;
    }
    v8[5] = v13;
    __int16 v20 = bswap32(sub_100020CF0((uint64_t)v8)) >> 16;
    id v10 = (unint64_t *)&v20;
    uint64_t v11 = (uint64_t)v8;
    size_t v12 = 2LL;
    goto LABEL_10;
  }

  if (a3 != 2)
  {
    uint64_t v15 = (void *)_NRCopyLogObjectForNRUUID(v5, v6);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v15, 17LL);

    if (IsLevelEnabled)
    {
      id v18 = (void *)_NRCopyLogObjectForNRUUID(v7, v17);
      _NRLogWithArgs(v18, 17LL, "Invalid message version %d", a3);
    }

    goto LABEL_14;
  }

  uint64_t v8 = (void *)sub_100021138((unint64_t)a1, v5, 0x10u, 2);
  sub_100021458((uint64_t)v8, 2);
  unint64_t v9 = sub_1001015B8();
  if (v8)
  {
    v8[5] = v9;
    unint64_t v21 = bswap64(sub_100020CF0((uint64_t)v8));
    id v10 = &v21;
    uint64_t v11 = (uint64_t)v8;
    size_t v12 = 8LL;
LABEL_10:
    sub_100021644(v11, v10, v12);
  }

void *sub_100021C64(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (!a1)
  {
LABEL_7:
    id v5 = 0LL;
    goto LABEL_4;
  }

  if (!v3)
  {
    id v7 = sub_100020F30();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 17LL);

    if (IsLevelEnabled)
    {
      id v9 = sub_100020F30();
      _NRLogWithArgs( v9,  17LL,  "%s called with null nrUUID",  "-[NRLinkDirectorMessage initOutgoingDirectorMessageWithNRUUID:]");
    }

    goto LABEL_7;
  }

  a1 = sub_100021AF8(a1, v3, 2);
  id v5 = a1;
LABEL_4:

  return v5;
}

void *sub_100021D14(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (!a1)
  {
LABEL_9:
    uint64_t v6 = 0LL;
    goto LABEL_6;
  }

  if (!v3)
  {
    id v8 = sub_100020F30();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 17LL);

    if (IsLevelEnabled)
    {
      id v10 = sub_100020F30();
      _NRLogWithArgs( v10,  17LL,  "%s called with null nrUUID",  "-[NRLinkDirectorMessage initBroadcastOutgoingDirectorMessageWithNRUUID:]");
    }

    goto LABEL_9;
  }

  id v5 = sub_100021AF8(a1, v3, 2);
  if (v5) {
    v5[8] = 1;
  }
  a1 = v5;
  uint64_t v6 = a1;
LABEL_6:

  return v6;
}

unint64_t sub_100021DD0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  objc_opt_self(a1);
  unsigned int v8 = [v5 length];
  unsigned __int8 v64 = 0;
  if (!v8)
  {
    unsigned int v13 = (void *)_NRCopyLogObjectForNRUUID(v6, v7);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v13, 16LL);

    if (IsLevelEnabled)
    {
      uint64_t v16 = (void *)_NRCopyLogObjectForNRUUID(v6, v15);
      _NRLogWithArgs(v16, 16LL, "%s%.30s:%-4d Received malformed message (%u < %zu)");
LABEL_20:

      goto LABEL_21;
    }

    goto LABEL_21;
  }

  [v5 getBytes:&v64 length:1];
  if (v64 == 2)
  {
    uint64_t v62 = 0LL;
    uint64_t v63 = 0LL;
    if (v8 <= 0xF)
    {
      uint64_t v17 = (void *)_NRCopyLogObjectForNRUUID(v6, v9);
      int v18 = _NRLogIsLevelEnabled(v17, 16LL);

      if (v18)
      {
LABEL_11:
        uint64_t v16 = (void *)_NRCopyLogObjectForNRUUID(v6, v12);
        _NRLogWithArgs(v16, 16LL, "%s%.30s:%-4d Received malformed message (%u < %u)");
        goto LABEL_20;
      }

void sub_1000222F4(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  if (!a1) {
    goto LABEL_21;
  }
  id v51 = v5;
  if (v5)
  {
    id v7 = [v5 length];
    if ((unint64_t)v7 >= 0x10000)
    {
      uint64_t v22 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v6);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v22, 17LL);

      id v5 = v51;
      if (IsLevelEnabled)
      {
        uint64_t v25 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v24);
        _NRLogWithArgs(v25, 17LL, "Tried to addType %u with dataLen %llu", a2, v7);

        goto LABEL_20;
      }

void sub_100022774(uint64_t a1, int a2, char a3)
{
  if (a1)
  {
    char v6 = a3;
    id v5 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v6, 1LL);
    sub_1000222F4(a1, a2, v5);
  }

void sub_1000227DC(uint64_t a1, void *a2, unsigned int a3, int a4)
{
  id v7 = a2;
  id v20 = v7;
  if (v7)
  {
    uint64_t v8 = sub_1001040C8(v7, a3, 1);
    uint64_t v9 = objc_claimAutoreleasedReturnValue(v8);
    if (!v9)
    {
      if (qword_1001DC718 != -1) {
        dispatch_once(&qword_1001DC718, &stru_1001AE4C8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC710, 17LL))
      {
        if (qword_1001DC718 != -1) {
          dispatch_once(&qword_1001DC718, &stru_1001AE4C8);
        }
        _NRLogWithArgs(qword_1001DC710, 17LL, "NRCreateAddressData(%@) failed", v20);
        id v10 = 0LL;
      }

      else
      {
        id v10 = 0LL;
      }

      goto LABEL_23;
    }

    id v10 = (id)v9;
    if ([v20 addressFamily] == (id)30)
    {
      if (a4) {
        int v11 = 9;
      }
      else {
        int v11 = 2;
      }
    }

    else
    {
      id v12 = [v20 addressFamily];
      if (v12 == (id)2 && a4)
      {
        int v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v13);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v14, 17LL);

        if (IsLevelEnabled)
        {
          int v17 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v16);
          _NRLogWithArgs(v17, 17LL, "unsupported address family for AWDL");
        }

        goto LABEL_23;
      }

      if (v12 != (id)2)
      {
LABEL_23:

        goto LABEL_24;
      }

      int v11 = 3;
    }

    sub_1000222F4(a1, v11, v10);
    goto LABEL_23;
  }

  id v18 = sub_100020F30();
  int v19 = _NRLogIsLevelEnabled(v18, 17LL);

  if (v19)
  {
    id v10 = sub_100020F30();
    _NRLogWithArgs( v10,  17LL,  "%s called with null addressEndpoint",  "-[NRLinkDirectorMessage addUpdateAddressEndpointInner:portHBO:isAWDL:]");
    goto LABEL_23;
  }

NSMutableArray *sub_1000229A0(void *a1, uint64_t a2)
{
  if (a1)
  {
    if (a1[6])
    {
      objc_opt_self(&OBJC_CLASS___NRLinkDirectorMessageManager);
      if (qword_1001DC708 != -1) {
        dispatch_once(&qword_1001DC708, &stru_1001AE488);
      }
      uint64_t v5 = qword_1001DC700;
      char v6 = a1;
      if (!v5) {
        goto LABEL_56;
      }
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(v5 + 8));
      id v7 = *(void **)(v5 + 16);
      Class isa = v6[4].super.super.isa;
      id v9 = v7;
      id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:isa]);

      if (!v10)
      {
        id v29 = (void *)_NRCopyLogObjectForNRUUID(v6[4].super.super.isa, v11);
        char IsLevelEnabled = _NRLogIsLevelEnabled(v29, 17LL);

        if ((IsLevelEnabled & 1) != 0)
        {
          uint64_t v32 = (void *)_NRCopyLogObjectForNRUUID(v6[4].super.super.isa, v31);
          _NRLogWithArgs(v32, 17LL, "no registered uuid for incoming message");

          int v28 = 0LL;
          goto LABEL_83;
        }

LABEL_56:
        int v28 = 0LL;
        goto LABEL_83;
      }

      id v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", a2));
      uint64_t v13 = (id *)objc_claimAutoreleasedReturnValue([v10 objectForKeyedSubscript:v12]);
      if (v13)
      {
        uint64_t v14 = objc_opt_class(&OBJC_CLASS___NRLinkDirectorMessageState);
        if ((objc_opt_isKindOfClass(v13, v14) & 1) == 0)
        {
LABEL_55:

          goto LABEL_56;
        }

        id v15 = v13[1];
        uint64_t v16 = v15;
        if (v15)
        {
          int v2 = (NRLinkDirectorMessageState *)[v15 unsignedLongLongValue];
          if ((unint64_t)v2 >= sub_100020CF0((uint64_t)v6))
          {
            id v17 = v13[2];
            id v18 = [v16 unsignedLongLongValue];
            if (v18 == (id)sub_100020CF0((uint64_t)v6)
              && [v17 unsignedLongLongValue] == v6[7].super.super.isa)
            {
              id v20 = v17;
              int v21 = (void *)_NRCopyLogObjectForNRUUID(v6[4].super.super.isa, v19);
              int v2 = (NRLinkDirectorMessageState *)_NRLogIsLevelEnabled(v21, 2LL);

              if ((_DWORD)v2)
              {
                __int16 v23 = (void *)_NRCopyLogObjectForNRUUID(v6[4].super.super.isa, v22);
                unint64_t v24 = sub_100020CF0((uint64_t)v6);
                _NRLogWithArgs( v23,  2LL,  "%s%.30s:%-4d allowing access to message type %u for same message %llu",  "",  "-[NRLinkDirectorMessageManager isMessageTypeValid:forMessage:]",  375,  a2,  v24);
              }

              goto LABEL_22;
            }

            __int128 v73 = (void *)_NRCopyLogObjectForNRUUID(v6[4].super.super.isa, v19);
            int v74 = _NRLogIsLevelEnabled(v73, 0LL);

            if (v74)
            {
              __int128 v75 = v6[4].super.super.isa;
              __int128 v77 = (void *)_NRCopyLogObjectForNRUUID(v75, v76);
              id v78 = [v16 unsignedLongLongValue];

              unint64_t v79 = sub_100020CF0((uint64_t)v6);
              _NRLogWithArgs( v77,  0LL,  "%s%.30s:%-4d Ignoring received message type %u, as it is stale (%llu >= %llu)",  "",  "-[NRLinkDirectorMessageManager isMessageTypeValid:forMessage:]",  378,  a2,  v78,  v79);
            }

            goto LABEL_55;
          }
        }
      }

      else
      {
        uint64_t v16 = 0LL;
      }
}

    uint64_t v16 = -2005LL;
    goto LABEL_57;
  }

  id v17 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v6);
  if (!v17)
  {
    int v48 = sub_10004579C();
    id v49 = _NRLogIsLevelEnabled(v48, 16LL);

    if (v49)
    {
      __int16 v50 = sub_10004579C();
      _NRLogWithArgs( v50,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "handleCompanionLinkCopyBluetoothUUIDForNRUUID",  550);
    }

    uint64_t v4 = (void *)_os_log_pack_size(12LL);
    id v51 = (char *)&v56[-1] - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v52 = __error();
    CFTypeID v53 = _os_log_pack_fill( v51,  v4,  *v52,  &_mh_execute_header,  "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    *(_DWORD *)CFTypeID v53 = 136446210;
    *(void *)(v53 + 4) = "handleCompanionLinkCopyBluetoothUUIDForNRUUID";
    __int128 v54 = sub_10004579C();
    _NRLogAbortWithPack(v54, v51);
    goto LABEL_61;
  }

  id v18 = v17;
  uint64_t v19 = sub_100129C28((uint64_t)&OBJC_CLASS___NRDLocalDevice, v17, 0);
  id v20 = v19;
  if (v19)
  {
    int v21 = *((id *)v19 + 5);
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      __int16 v23 = (id)qword_1001DC770;
      if (v4)
      {
        unint64_t v24 = (void *)v4[4];
        if (!v24)
        {
          uint64_t v25 = (_xpc_connection_s *)objc_getProperty(v4, v22, 8LL, 1);
          int v26 = xpc_connection_get_pid(v25);
          uint64_t v27 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v26);
          bzero(v56, 0x400uLL);
          if ((int)v26 >= 1 && proc_pidpath(v26, v56, 0x400u) >= 1 && LOBYTE(v56[0]))
          {
            int v28 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v56,  v26);

            uint64_t v27 = v28;
          }

          id v29 = (void *)v4[4];
          v4[4] = v27;

          unint64_t v24 = (void *)v4[4];
        }

        uint64_t v30 = v24;
      }

      else
      {
        uint64_t v30 = 0LL;
      }

      uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue(-[NSUUID UUIDString](v18, "UUIDString"));
      uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue([v21 UUIDString]);
      _NRLogWithArgs( v23,  0LL,  "%s%.30s:%-4d Informing %@ that NRUUID %@ maps to BTUUID %@",  "",  "handleCompanionLinkCopyBluetoothUUIDForNRUUID",  559LL,  v30,  v31,  v32);
    }

    v56[0] = 0LL;
    v56[1] = 0LL;
    [v21 getUUIDBytes:v56];
    if (v4) {
      id v34 = objc_getProperty(v4, v33, 24LL, 1);
    }
    else {
      id v34 = 0LL;
    }
    xpc_dictionary_set_uuid(v34, nrXPCKeyBluetoothUUID, (const unsigned __int8 *)v56);

    uint64_t v16 = 0LL;
  }

  else
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      int v36 = (id)qword_1001DC770;
      if (v4)
      {
        uint64_t v37 = (void *)v4[4];
        if (!v37)
        {
          int v38 = (_xpc_connection_s *)objc_getProperty(v4, v35, 8LL, 1);
          int v39 = xpc_connection_get_pid(v38);
          id v40 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v39);
          bzero(v56, 0x400uLL);
          if ((int)v39 >= 1 && proc_pidpath(v39, v56, 0x400u) >= 1 && LOBYTE(v56[0]))
          {
            uint64_t v41 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v56,  v39);

            id v40 = v41;
          }

          int v42 = (void *)v4[4];
          v4[4] = v40;

          uint64_t v37 = (void *)v4[4];
        }

        int v43 = v37;
      }

      else
      {
        int v43 = 0LL;
      }

      _NRLogWithArgs( v36,  16LL,  "%s%.30s:%-4d Unknown NRUUID %@ from %@",  "",  "handleCompanionLinkCopyBluetoothUUIDForNRUUID",  554LL,  v18,  v43);
    }

    uint64_t v16 = -2008LL;
  }

LABEL_57:
  return v16;
}

  -[NSMutableArray addObject:](v8, "addObject:", @"RadioConditionsDeteriorated");
  if ((reason & 0x2000000000000000LL) == 0)
  {
LABEL_31:
    if ((reason & 0x4000000000000000LL) == 0) {
      goto LABEL_33;
    }
    goto LABEL_32;
  }

    sub_1000A2170(v39);
    goto LABEL_57;
  }

  if (qword_1001DC8A0 != -1) {
    dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC898, 17LL))
  {
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    _NRLogWithArgs(qword_1001DC898, 17LL, "error loading NE configuration: %@", v6);
  }

LABEL_88:
            id v96 = 0LL;
            char v107 = 1;
            id v106 = v123;
            goto LABEL_69;
          }
        }

        unsigned int v44 = 0;
        unsigned __int16 v45 = 0;
        uint64_t v46 = a1[6] + v37;
        unint64_t v47 = v46 + isa_high;
        id v123 = (id)isa_high;
        while (1)
        {
          id v51 = (void *)_NRCopyLogObjectForNRUUID(v6[4].super.super.isa, v33);
          int v52 = _NRLogIsLevelEnabled(v51, 2LL);

          if (v52)
          {
            CFTypeID v53 = (void *)_NRCopyLogObjectForNRUUID(v6[4].super.super.isa, v33);
            _NRLogWithArgs( v53,  2LL,  "%s%.30s:%-4d Payload traversed: %u, payload length: %u",  "",  "-[NRLinkDirectorMessage copyAllDataForType:]",  908,  v44,  isa_high);
          }

          __int128 v54 = (unsigned __int8 *)(v46 + v45);
          unint64_t v55 = v54 + 3;
          unsigned int v56 = *(unsigned __int16 *)(v54 + 1);
          uint64_t v57 = __rev16(v56);
          if ((unint64_t)&v55[v57] > v47)
          {
            int v86 = (void *)_NRCopyLogObjectForNRUUID(v6[4].super.super.isa, v33);
            int v87 = _NRLogIsLevelEnabled(v86, 16LL);

            if (v87)
            {
              int v88 = v6[4].super.super.isa;
              id v90 = (void *)_NRCopyLogObjectForNRUUID(v88, v89);
              int v91 = *v54;

              _NRLogWithArgs( v90,  16LL,  "%s%.30s:%-4d Received malformed TLV of type: %u, length: %u",  "",  "-[NRLinkDirectorMessage copyAllDataForType:]",  921,  v91,  v57);
            }

            goto LABEL_29;
          }

          if (*v54 == v124)
          {
            uint64_t isa_high = v46;
            __int128 v58 = v34;
            int v59 = (void *)_NRCopyLogObjectForNRUUID(v6[4].super.super.isa, v33);
            int v60 = _NRLogIsLevelEnabled(v59, 1LL);

            if (v60)
            {
              uint64_t v62 = (void *)_NRCopyLogObjectForNRUUID(v6[4].super.super.isa, v61);
              uint64_t v63 = sub_100020934(v124);
              _NRLogWithArgs( v62,  1LL,  "%s%.30s:%-4d Found TLV type: %@",  "",  "-[NRLinkDirectorMessage copyAllDataForType:]",  926LL,  v63);
            }

            if (v56) {
              int v48 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", v55, v57);
            }
            else {
              int v48 = (NSData *)objc_claimAutoreleasedReturnValue(+[NSData data](&OBJC_CLASS___NSData, "data"));
            }
            id v49 = v48;
            id v34 = v58;
            -[NSMutableArray addObject:](v58, "addObject:", v48);

            uint64_t v46 = isa_high;
            LODWORD(isa_high) = (_DWORD)v123;
          }

          __int16 v50 = v45 + v57;
          v45 += v57 + 3;
          unsigned int v44 = (unsigned __int16)(v50 + 3);
        }

        id v80 = (void *)_NRCopyLogObjectForNRUUID(v6[4].super.super.isa, v33);
        int v81 = _NRLogIsLevelEnabled(v80, 16LL);

        if (v81)
        {
          int v82 = v6[4].super.super.isa;
          uint64_t v84 = (void *)_NRCopyLogObjectForNRUUID(v82, v83);
          int v85 = *v54;

          _NRLogWithArgs( v84,  16LL,  "%s%.30s:%-4d Received malformed TLV of type: %u",  "",  "-[NRLinkDirectorMessage copyAllDataForType:]",  913,  v85);
        }
      }

      else
      {
        int v38 = (void *)_NRCopyLogObjectForNRUUID(v6[4].super.super.isa, v33);
        int v39 = _NRLogIsLevelEnabled(v38, 17LL);

        if (v39)
        {
          id v40 = v6[4].super.super.isa;
          int v42 = (void *)_NRCopyLogObjectForNRUUID(v40, v41);
          int v43 = (int)v6[2].super.super.isa;

          _NRLogWithArgs(v42, 17LL, "Disconnect between messageLen %u and payloadLength %u", v43, isa_high);
        }
      }

                      v135 = _NRLogIsLevelEnabled(v120, 2LL);

                      if (v135)
                      {
                        v137 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v136);
                        v138 = -[NRLink copyDescription](v6, "copyDescription");
                        _NRLogWithArgs( v137,  2LL,  "%s%.30s:%-4d %@: Link Channel TX_SLOTS = %llu",  "",  "-[NRLinkBluetooth start]",  1217LL,  v138,  __memptr[0]);
                      }

                      __memptr[0] = 0LL;
                      v139 = os_channel_attr_get(v376, 3LL, __memptr);
                      v141 = _NRCopyLogObjectForNRUUID(v6->super._nrUUID, v140);
                      sentPreludeState = (int *)v141;
                      if (!(_DWORD)v139) {
                        goto LABEL_116;
                      }
                      v142 = _NRLogIsLevelEnabled(v141, 17LL);

                      if (!v142)
                      {
LABEL_200:
                        LOBYTE(v6) = 0;
LABEL_201:

                        return (char)v6;
                      }

                      int v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v143);
                      int v82 = -[NRLink copyDescription](v6, "copyDescription");
                      _NRLogWithArgs(v81, 17LL, "%@: os_channel_attr_get(RX_SLOTS) returned %d", v82, v139);
LABEL_199:

                      goto LABEL_200;
                    }

                    v160 = sub_100070554();
                    v161 = _NRLogIsLevelEnabled(v160, 16LL);

                    if (v161)
                    {
                      v162 = sub_100070554();
                      _NRLogWithArgs( v162,  16LL,  "%s%.30s:%-4d ABORTING: posix_memalign(..., %zu, %zu) failed",  "",  "strict_memalign",  183,  8uLL,  0x50uLL);
                    }
                  }

                  uint64_t v16 = _os_log_pack_size(32LL);
                  char v6 = (NRLinkBluetooth *)((char *)&v375 - ((__chkstk_darwin(v16) + 15) & 0xFFFFFFFFFFFFFFF0LL));
                  v163 = __error();
                  v164 = _os_log_pack_fill( v6,  v16,  *v163,  &_mh_execute_header,  "%{public}s posix_memalign(..., %zu, %zu) failed");
                  *(_DWORD *)v164 = 136446722;
                  *(void *)(v164 + 4) = "strict_memalign";
                  *(_WORD *)(v164 + 12) = 2048;
                  *(void *)(v164 + 14) = 8LL;
                  *(_WORD *)(v164 + 22) = 2048;
                  *(void *)(v164 + 24) = 80LL;
                  goto LABEL_115;
                }

LABEL_29:
      int v28 = 0LL;
      char v6 = v34;
LABEL_83:

      return v28;
    }

    uint64_t v25 = (void *)_NRCopyLogObjectForNRUUID(a1[4], a2);
    int v26 = _NRLogIsLevelEnabled(v25, 17LL);

    if (v26)
    {
      char v6 = (NSMutableArray *)_NRCopyLogObjectForNRUUID(a1[4], v27);
      _NRLogWithArgs(v6, 17LL, "No message");
      int v28 = 0LL;
      goto LABEL_83;
    }
  }

  return 0LL;
}

          unint64_t v24 = v27;
LABEL_30:

          return;
        }
      }

      uint64_t v19 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v4);
      id v20 = _NRLogIsLevelEnabled(v19, 17LL);

      if (v20)
      {
        uint64_t v22 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v21);
        __int16 v23 = [(id)a1 copyDescription];
        _NRLogWithArgs(v22, 17LL, "%@: failed to send stop symptoms, since no interface found", v23);
      }

      unint64_t v24 = 0LL;
      goto LABEL_30;
    }

    id v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
    uint64_t v16 = _NRLogIsLevelEnabled(v15, 16LL);

    if (v16)
    {
      uint64_t v27 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v17);
      id v18 = [(id)a1 copyDescription];
      _NRLogWithArgs( v27,  16LL,  "%s%.30s:%-4d %@: SymptomReporterFramework not present, skipping.",  "",  "-[NRLinkWiFi stopSymptomsMonitor]",  667LL,  v18);

      goto LABEL_29;
    }
  }
}

        -[NSMutableArray addObject:](v19, "addObject:", v9);
        int v26 = *(void *)(a1 + 32);
        if (v26) {
          uint64_t v27 = *(void **)(v26 + 40);
        }
        else {
          uint64_t v27 = 0LL;
        }
        [v27 setObject:v19 forKeyedSubscript:v12];
        id v17 = v18;
      }

      else
      {
        -[NSMutableArray addObject:](v17, "addObject:", v9);
        uint64_t v30 = *(void *)(a1 + 32);
        if (v30) {
          uint64_t v31 = *(void **)(v30 + 40);
        }
        else {
          uint64_t v31 = 0LL;
        }
        [v31 setObject:v17 forKeyedSubscript:v12];
      }

      uint64_t v46 = 0u;
      unint64_t v47 = 0u;
      unsigned int v44 = 0u;
      unsigned __int16 v45 = 0u;
      uint64_t v32 = *(void **)(a1 + 32);
      if (v32) {
        uint64_t v32 = (void *)v32[6];
      }
      uint64_t v33 = v32;
      id v34 = [v33 countByEnumeratingWithState:&v44 objects:v52 count:16];
      if (v34)
      {
        int v35 = v34;
        int v36 = *(void *)v45;
        do
        {
          for (i = 0LL; i != v35; i = (char *)i + 1)
          {
            if (*(void *)v45 != v36) {
              objc_enumerationMutation(v33);
            }
            int v38 = *(void *)(*((void *)&v44 + 1) + 8LL * (void)i);
            if (v38) {
              int v39 = *(dispatch_queue_s **)(v38 + 64);
            }
            else {
              int v39 = 0LL;
            }
            block[0] = _NSConcreteStackBlock;
            block[1] = 3221225472LL;
            block[2] = sub_1000F660C;
            block[3] = &unk_1001B0720;
            void block[4] = v38;
            int v43 = v12;
            dispatch_async(v39, block);
          }

          int v35 = [v33 countByEnumeratingWithState:&v44 objects:v52 count:16];
        }

        while (v35);
      }

      uint64_t v5 = v40;
      char v6 = v41;
      id v18 = v17;
LABEL_57:

      goto LABEL_66;
    }
  }

  else
  {
    uint64_t v11 = qword_1001DC940;
  }

  if (v11 != -1) {
    dispatch_once(&qword_1001DC940, &stru_1001AF878);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC938, 16LL))
  {
    if (qword_1001DC940 != -1) {
      dispatch_once(&qword_1001DC940, &stru_1001AF878);
    }
    _NRLogWithArgs( qword_1001DC938,  16LL,  "%s%.30s:%-4d received start resolve request without an appsvc name",  "",  "-[NRApplicationServiceManager setupResolverAgent]_block_invoke_5",  444);
  }

  id v12 = 0LL;
LABEL_66:
}

int64_t sub_100023460(id a1, id a2, id a3)
{
  id v4 = a3;
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( NSNumber,  "numberWithUnsignedShort:",  [a2 metric]));
  id v6 = [v4 metric];

  id v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](&OBJC_CLASS___NSNumber, "numberWithUnsignedShort:", v6));
  id v8 = [v5 compare:v7];

  return (int64_t)v8;
}

NSMutableArray *sub_1000234F4(void *a1, int a2, int a3)
{
  id v6 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  __int128 v27 = 0u;
  __int128 v28 = 0u;
  __int128 v29 = 0u;
  __int128 v30 = 0u;
  if (a3) {
    uint64_t v7 = 9LL;
  }
  else {
    uint64_t v7 = 2LL;
  }
  id v8 = sub_1000229A0(a1, v7);
  id v9 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v8,  "countByEnumeratingWithState:objects:count:",  &v27,  v32,  16LL);
  if (v9)
  {
    id v10 = v9;
    uint64_t v11 = *(void *)v28;
    do
    {
      id v12 = 0LL;
      do
      {
        if (*(void *)v28 != v11) {
          objc_enumerationMutation(v8);
        }
        id v13 = sub_100104514(*(void **)(*((void *)&v27 + 1) + 8LL * (void)v12), 0, 30, a2);
        uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
        if (v14) {
          -[NSMutableArray addObject:](v6, "addObject:", v14);
        }

        id v12 = (char *)v12 + 1;
      }

      while (v10 != v12);
      id v10 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v8,  "countByEnumeratingWithState:objects:count:",  &v27,  v32,  16LL);
    }

    while (v10);
  }

  __int128 v25 = 0u;
  __int128 v26 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  id v15 = sub_1000229A0(a1, 3LL);
  id v16 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v15,  "countByEnumeratingWithState:objects:count:",  &v23,  v31,  16LL);
  if (v16)
  {
    id v17 = v16;
    uint64_t v18 = *(void *)v24;
    do
    {
      uint64_t v19 = 0LL;
      do
      {
        if (*(void *)v24 != v18) {
          objc_enumerationMutation(v15);
        }
        id v20 = sub_100104514(*(void **)(*((void *)&v23 + 1) + 8LL * (void)v19), 0, 2, a2);
        int v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
        if (v21) {
          -[NSMutableArray addObject:](v6, "addObject:", v21, (void)v23);
        }

        uint64_t v19 = (char *)v19 + 1;
      }

      while (v17 != v19);
      id v17 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v15,  "countByEnumeratingWithState:objects:count:",  &v23,  v31,  16LL);
    }

    while (v17);
  }

  return v6;
}

NSData *sub_100023718(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (*(void *)(a1 + 48) && *(_WORD *)(a1 + 14))
    {
      int v3 = *(unsigned __int16 *)(a1 + 14) + *(unsigned __int16 *)(a1 + 12);
      if (*(_DWORD *)(a1 + 16) == v3) {
        return -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  *(void *)(a1 + 48),  *(unsigned int *)(a1 + 16));
      }
      id v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 17LL);

      if (IsLevelEnabled)
      {
        id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v11);
        _NRLogWithArgs(v12, 17LL, "Disconnect between messageLen %u and totalLength %u", *(_DWORD *)(a1 + 16), v3);
      }
    }

    else
    {
      uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      int v6 = _NRLogIsLevelEnabled(v5, 17LL);

      if (v6)
      {
        id v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v7);
        _NRLogWithArgs(v8, 17LL, "No message to send");
      }
    }
  }

  return 0LL;
}

uint64_t sub_100023824(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    int v2 = (id *)(id)qword_1001DC870;
    int v3 = *(void **)(v1 + 24);
    if (v3)
    {
      id v5 = v3;
      goto LABEL_14;
    }

    id v6 = *(id *)(v1 + 32);
    uint64_t v7 = v6;
    if (v2)
    {
      if (v6)
      {
        uint64_t v8 = objc_claimAutoreleasedReturnValue([v2[27] objectForKeyedSubscript:v6]);
        if (v8)
        {
          id v9 = (id *)v8;
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(v8 + 104));
          id v5 = v9[16];
LABEL_12:

          goto LABEL_13;
        }

        id v10 = (void *)objc_claimAutoreleasedReturnValue([v7 UUIDString]);
        sub_1000A2084((uint64_t)v2, 1014, @"copyPrimaryLink %@", v11, v12, v13, v14, v15, (uint64_t)v10);

        id v9 = 0LL;
LABEL_11:
        id v5 = 0LL;
        goto LABEL_12;
      }

      id v53 = sub_1000A2100();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v53, 17LL);

      if (IsLevelEnabled)
      {
        id v9 = (id *)sub_1000A2100();
        _NRLogWithArgs(v9, 17LL, "%s called with null nrUUID", "-[NRLinkDirector copyPrimaryLinkForNRUUID:]");
        goto LABEL_11;
      }
    }

    id v5 = 0LL;
LABEL_13:

    if ([v5 state] != 8)
    {
      __int128 v25 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 32), v4);
      int v26 = _NRLogIsLevelEnabled(v25, 16LL);

      if (v26)
      {
        id v27 = *(id *)(v1 + 32);
        __int128 v29 = (void *)_NRCopyLogObjectForNRUUID(v27, v28);
        _NRLogWithArgs( v29,  16LL,  "%s%.30s:%-4d No links to send the message %@",  "",  "-[NRLinkDirectorMessage send]",  1034LL,  v1);
      }

      unsigned __int8 v64 = 0;
      goto LABEL_51;
    }

NSData *sub_100023D50(uint64_t a1)
{
  uint32_t v1 = arc4random_uniform(0x1770u);
  size_t v2 = v1 + 3000;
  if (v1 == -3000)
  {
    id v7 = sub_100020F30();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 16LL);

    if (IsLevelEnabled)
    {
      id v9 = sub_100020F30();
      _NRLogWithArgs(v9, 16LL, "%s%.30s:%-4d ABORTING: strict_malloc called with size 0", "", "strict_malloc", 74);
    }

    size_t v2 = _os_log_pack_size(12LL);
    id v10 = (char *)&v22 - ((__chkstk_darwin(v2) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v11 = __error();
    uint64_t v12 = _os_log_pack_fill( v10,  v2,  *v11,  &_mh_execute_header,  "%{public}s strict_malloc called with size 0");
    *(_DWORD *)uint64_t v12 = 136446210;
    *(void *)(v12 + 4) = "strict_malloc";
    id v13 = sub_100020F30();
    _NRLogAbortWithPack(v13, v10);
LABEL_7:
    id v14 = sub_100020F30();
    int v15 = _NRLogIsLevelEnabled(v14, 16LL);

    if (v15)
    {
      id v16 = sub_100020F30();
      _NRLogWithArgs(v16, 16LL, "%s%.30s:%-4d ABORTING: strict_malloc(%zu) failed", "", "strict_malloc", 79, v2);
    }

    uint64_t v17 = _os_log_pack_size(22LL);
    uint64_t v18 = (char *)&v22 - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v19 = __error();
    uint64_t v20 = _os_log_pack_fill(v18, v17, *v19, &_mh_execute_header, "%{public}s strict_malloc(%zu) failed");
    *(_DWORD *)uint64_t v20 = 136446466;
    *(void *)(v20 + 4) = "strict_malloc";
    *(_WORD *)(v20 + 12) = 2048;
    *(void *)(v20 + 14) = v2;
    id v21 = sub_100020F30();
    _NRLogAbortWithPack(v21, v18);
  }

  int v3 = malloc(v1 + 3000);
  if (!v3) {
    goto LABEL_7;
  }
  uint64_t v4 = v3;
  arc4random_buf(v3, v2);
  id v5 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", v4, v2);
  free(v4);
  return v5;
}

uint64_t sub_100023FAC(uint64_t a1, void *a2)
{
  uint64_t v112 = a2;
  objc_opt_self(a1);
  int v3 = sub_100023D50((uint64_t)&OBJC_CLASS___NRLinkDirectorMessage);
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  objc_opt_self(&OBJC_CLASS___NRLinkDirectorMessage);
  LOBYTE(a1) = arc4random_uniform(0x100u);
  unsigned __int8 v5 = arc4random_uniform(0x100u);
  unsigned __int8 v6 = arc4random_uniform(0x100u);
  id v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%u.%u.%u.%u",  arc4random_uniform(0x100u),  v6,  v5,  a1);
  objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
  if (qword_1001DC640 != -1) {
    dispatch_once(&qword_1001DC640, &stru_1001ADE98);
  }
  id v8 = (id)qword_1001DC638;
  if (v8) {
    id v9 = @"62743";
  }
  else {
    id v9 = 0LL;
  }
  id v10 = v9;
  v117 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v7,  v10));

  objc_opt_self(&OBJC_CLASS___NRLinkDirectorMessage);
  unsigned __int8 v11 = arc4random_uniform(0x100u);
  unsigned __int8 v12 = arc4random_uniform(0x100u);
  unsigned __int8 v13 = arc4random_uniform(0x100u);
  id v14 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"fd74::%u.%u.%u.%u",  arc4random_uniform(0x100u),  v13,  v12,  v11);
  objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
  if (qword_1001DC640 != -1) {
    dispatch_once(&qword_1001DC640, &stru_1001ADE98);
  }
  id v15 = (id)qword_1001DC638;
  if (v15) {
    id v16 = @"62743";
  }
  else {
    id v16 = 0LL;
  }
  uint64_t v17 = v16;
  id v116 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v14,  v17));

  uint32_t v107 = arc4random() & 1;
  id v18 = v4;
  objc_opt_self(&OBJC_CLASS___NRLinkDirectorMessage);
  id v114 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  uint64_t v19 = (char *)[v18 bytes];
  v113 = v18;
  unsigned int v20 = [v18 length];
  unsigned int v21 = 0;
  do
  {
    do
      uint32_t v23 = arc4random() % 0x64;
    while (!v23);
    unsigned int v24 = v23 + v21;
    if (v23 + v21 <= v20) {
      uint64_t v25 = v23;
    }
    else {
      uint64_t v25 = v20 - v21;
    }
    if ((_DWORD)v25)
    {
      uint64_t v22 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", v19, v25);
      -[NSMutableArray addObject:](v114, "addObject:", v22);
    }

    else
    {
      uint64_t v25 = 0LL;
    }

    v19 += v25;
    unsigned int v21 = v24;
  }

  while (v24 <= v20);

  __int128 v124 = 0u;
  __int128 v125 = 0u;
  __int128 v122 = 0u;
  __int128 v123 = 0u;
  id v26 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v114,  "countByEnumeratingWithState:objects:count:",  &v122,  v131,  16LL);
  if (v26)
  {
    id v27 = v26;
    uint64_t v28 = *(void *)v123;
    do
    {
      for (i = 0LL; i != v27; i = (char *)i + 1)
      {
        if (*(void *)v123 != v28) {
          objc_enumerationMutation(v114);
        }
        sub_1000222F4((uint64_t)v112, 255, *(void **)(*((void *)&v122 + 1) + 8LL * (void)i));
      }

      id v27 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v114,  "countByEnumeratingWithState:objects:count:",  &v122,  v131,  16LL);
    }

    while (v27);
  }

  objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
  if (qword_1001DC640 != -1) {
    dispatch_once(&qword_1001DC640, &stru_1001ADE98);
  }
  id v30 = (id)qword_1001DC638;
  uint64_t v31 = v30;
  if (v112)
  {
    if (v30) {
      unsigned int v32 = 62743;
    }
    else {
      unsigned int v32 = 0;
    }
    sub_1000227DC((uint64_t)v112, v117, v32, 0);
  }

  objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
  if (qword_1001DC640 != -1) {
    dispatch_once(&qword_1001DC640, &stru_1001ADE98);
  }
  id v33 = (id)qword_1001DC638;
  uint64_t v34 = v33;
  if (v112)
  {
    if (v33) {
      unsigned int v35 = 62743;
    }
    else {
      unsigned int v35 = 0;
    }
    sub_1000227DC((uint64_t)v112, v116, v35, 0);

    v132[0] = v107 == 0;
    id v36 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", v132, 1LL);
    sub_1000222F4((uint64_t)v112, 5, v36);

    sub_1000222F4((uint64_t)v112, 1, 0LL);
    uint64_t v110 = *((unsigned __int8 *)v112 + 10);
    unint64_t v109 = sub_100020CF0((uint64_t)v112);
    id v38 = sub_100023718((uint64_t)v112, v37);
    char v39 = (void *)v112[4];
  }

  else
  {

    unint64_t v109 = 0LL;
    uint64_t v110 = 0LL;
    id v38 = 0LL;
    char v39 = 0LL;
  }

  uint64_t v40 = (void *)sub_100021DD0((uint64_t)&OBJC_CLASS___NRLinkDirectorMessage, v38, v39);
  uint64_t v41 = sub_1000229A0(v40, 255LL);
  objc_opt_self(&OBJC_CLASS___NRLinkDirectorMessage);
  id v42 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
  __int128 v126 = 0u;
  __int128 v127 = 0u;
  __int128 v128 = 0u;
  __int128 v129 = 0u;
  uint64_t v43 = v41;
  id v44 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v43,  "countByEnumeratingWithState:objects:count:",  &v126,  v132,  16LL);
  if (v44)
  {
    id v45 = v44;
    uint64_t v46 = *(void *)v127;
    do
    {
      for (j = 0LL; j != v45; j = (char *)j + 1)
      {
        if (*(void *)v127 != v46) {
          objc_enumerationMutation(v43);
        }
        -[NSMutableData appendData:](v42, "appendData:", *(void *)(*((void *)&v126 + 1) + 8LL * (void)j));
      }

      id v45 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v43,  "countByEnumeratingWithState:objects:count:",  &v126,  v132,  16LL);
    }

    while (v45);
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  uint64_t v48 = (id *)(id)qword_1001DC870;
  id v49 = v48;
  if (v48)
  {
    id v50 = v48[6];
    int v51 = v50;
    if (v50 && (uint64_t v52 = *((void *)v50 + 13)) != 0) {
      int v53 = *(_DWORD *)(v52 + 12);
    }
    else {
      int v53 = 0;
    }
  }

  else
  {
    int v51 = 0LL;
    int v53 = 0;
  }

  id v103 = v43;
  id v104 = v38;
  if (v40) {
    __int128 v54 = sub_1000234F4(v40, v53, 0);
  }
  else {
    __int128 v54 = 0LL;
  }
  uint64_t v111 = (uint64_t)v40;

  __int128 v120 = 0u;
  __int128 v121 = 0u;
  __int128 v118 = 0u;
  __int128 v119 = 0u;
  id v55 = v54;
  id v56 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v55,  "countByEnumeratingWithState:objects:count:",  &v118,  v130,  16LL);
  if (v56)
  {
    id v57 = v56;
    id v58 = 0LL;
    int v59 = 0LL;
    unsigned int v115 = 0;
    unsigned int v60 = 0;
    uint64_t v61 = *(void *)v119;
    while (1)
    {
      for (k = 0LL; k != v57; k = (char *)k + 1)
      {
        if (*(void *)v119 != v61) {
          objc_enumerationMutation(v55);
        }
        uint64_t v65 = *(void **)(*((void *)&v118 + 1) + 8LL * (void)k);
        if ([v65 addressFamily] == (id)2)
        {
          unsigned int v60 = [v65 isEqual:v117];
          __int128 v63 = v59;
          int v59 = v65;
LABEL_61:
          id v64 = v65;

          continue;
        }

        if ([v65 addressFamily] == (id)30)
        {
          unsigned int v115 = [v65 isEqual:v116];
          __int128 v63 = v58;
          id v58 = v65;
          goto LABEL_61;
        }
      }

      id v57 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v55,  "countByEnumeratingWithState:objects:count:",  &v118,  v130,  16LL);
      if (!v57) {
        goto LABEL_69;
      }
    }
  }

  id v58 = 0LL;
  int v59 = 0LL;
  unsigned int v115 = 0;
  unsigned int v60 = 0;
LABEL_69:

  BOOL v66 = v111;
  if (v111)
  {
    id v67 = sub_1000229A0((void *)v111, 5LL);
    uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v67, "firstObject"));

    if (v68 && [v68 length])
    {
      v132[0] = 0;
      [v68 getBytes:v132 length:1];
      if ((v132[0] & 1) != 0) {
        __int128 v69 = &__kCFBooleanTrue;
      }
      else {
        __int128 v69 = &__kCFBooleanFalse;
      }
    }

    else
    {
      __int128 v69 = 0LL;
    }
  }

  else
  {
    __int128 v69 = 0LL;
  }

  id v106 = [v69 BOOLValue];

  uint64_t v108 = v107 ^ 1;
  if (v111)
  {
    uint64_t v70 = *(unsigned __int8 *)(v111 + 10);
    unint64_t v71 = sub_100020CF0(v111);
    uint64_t v72 = sub_1000229A0((void *)v111, 1LL);
    __int128 v73 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v72, "firstObject"));

    BOOL v66 = v73 != 0LL;
  }

  else
  {
    unint64_t v71 = 0LL;
    uint64_t v70 = 0LL;
  }

  unsigned int v74 = -[NSMutableData isEqualToData:](v42, "isEqualToData:", v113);
  unsigned int v75 = v74;
  if ((_DWORD)v70 == (_DWORD)v110 && v71 == v109) {
    unsigned int v77 = v74;
  }
  else {
    unsigned int v77 = 0;
  }
  int v78 = v77 & v60 & v115 & v66;
  if ((_DWORD)v108 != (_DWORD)v106) {
    int v78 = 0;
  }
  unsigned int v105 = v78;
  if (qword_1001DC718 != -1) {
    dispatch_once(&qword_1001DC718, &stru_1001AE4C8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC710, 0LL))
  {
    if (qword_1001DC718 != -1) {
      dispatch_once(&qword_1001DC718, &stru_1001AE4C8);
    }
    unint64_t v79 = "FAILED to";
    if (v105) {
      unint64_t v79 = "Successfully";
    }
    uint64_t v102 = v79;
    if ((_DWORD)v70 == (_DWORD)v110) {
      id v80 = "Matched";
    }
    else {
      id v80 = "Not matched";
    }
    uint64_t v99 = v70;
    int v100 = v80;
    if (v71 == v109) {
      int v81 = "Matched";
    }
    else {
      int v81 = "Not matched";
    }
    if (v75) {
      int v82 = "Matched";
    }
    else {
      int v82 = "Not matched";
    }
    unint64_t v97 = v82;
    uint64_t v98 = v81;
    id v101 = (id)qword_1001DC710;
    id v96 = [v113 length];
    NSUInteger v83 = -[NSMutableData length](v42, "length");
    if ((v60 & 1) != 0) {
      uint64_t v84 = "Matched";
    }
    else {
      uint64_t v84 = "Not matched";
    }
    uint64_t v94 = v84;
    NSUInteger v95 = v83;
    int v93 = (void *)objc_claimAutoreleasedReturnValue([v117 hostname]);
    int v85 = (void *)objc_claimAutoreleasedReturnValue([v59 hostname]);
    if ((v115 & 1) != 0) {
      int v86 = "Matched";
    }
    else {
      int v86 = "Not matched";
    }
    int v87 = (void *)objc_claimAutoreleasedReturnValue([v116 hostname]);
    uint64_t v88 = objc_claimAutoreleasedReturnValue([v58 hostname]);
    uint64_t v89 = (void *)v88;
    if ((_DWORD)v108 == (_DWORD)v106) {
      id v90 = "Matched";
    }
    else {
      id v90 = "Not matched";
    }
    if (v66) {
      int v91 = "Matched";
    }
    else {
      int v91 = "Not matched";
    }
    _NRLogWithArgs( v101,  0LL,  "%s%.30s:%-4d %s verified NRLinkDirectorMessage: vers=%s(%u/%u), id=%s(%llu/%llu),data=%s(%zu/%zu), ipv4=%s(%@/%@), ipv6=%s(%@/%@), preferWiFi=%s(%u/%u), hello=%s",  "",  "+[NRLinkDirectorMessage testMessage:]",  1223LL,  v102,  v100,  v110,  v99,  v98,  v109,  v71,  v97,  v96,  v95,  v94,  v93,  v85,  v86,  v87,  v88,  v90,  v108,  v106,  v91);
  }

  return v105;
}

void sub_100024AD8(uint64_t a1, void *a2)
{
  id v5 = a2;
  objc_opt_self(a1);
  objc_opt_self(&OBJC_CLASS___NRLinkDirectorMessageManager);
  if (qword_1001DC708 != -1) {
    dispatch_once(&qword_1001DC708, &stru_1001AE488);
  }
  int v3 = v5;
  if (qword_1001DC700)
  {
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(qword_1001DC700 + 16) objectForKeyedSubscript:v5]);
    [v4 removeAllObjects];

    int v3 = v5;
  }
}

id sub_100024E28()
{
  if (qword_1001DC728 != -1) {
    dispatch_once(&qword_1001DC728, &stru_1001AE510);
  }
  return (id)qword_1001DC720;
}

void sub_100024E68(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  size_t v2 = (void *)qword_1001DC720;
  qword_1001DC720 = (uint64_t)v1;
}

LABEL_71:
  id v8 = v70;
LABEL_80:

LABEL_81:
}

          id v14 = v101;
          uint64_t v17 = obj;
          unsigned __int8 v6 = v89;
          uint64_t v19 = v93;
          id v15 = v94;
          unsigned int v20 = kSCEntNetIPv4;
        }

        if (++v18 >= (unint64_t)v17)
        {
          uint64_t v47 = -[__CFArray countByEnumeratingWithState:objects:count:]( v15,  "countByEnumeratingWithState:objects:count:",  &v124,  v140,  16LL);
          if (!v47) {
            break;
          }
          uint64_t v17 = v47;
          id v18 = 0LL;
        }

        unsigned int v21 = *(void *)v125;
      }
    }
  }

  if ((v9 & 1) != 0)
  {
    id v114 = 0u;
    unsigned int v115 = 0u;
    uint64_t v112 = 0u;
    v113 = 0u;
    uint64_t v48 = v6;
    id v49 = -[__CFArray countByEnumeratingWithState:objects:count:]( v48,  "countByEnumeratingWithState:objects:count:",  &v112,  v137,  16LL);
    if (v49)
    {
      id v50 = v49;
      int v51 = *(void *)v113;
      uint64_t v52 = kSCEntNetIPv6;
      id v90 = v48;
      NSUInteger v95 = *(void *)v113;
      do
      {
        int v53 = 0LL;
        int v91 = v50;
        do
        {
          if (*(void *)v113 != v51) {
            objc_enumerationMutation(v48);
          }
          id v55 = *(void **)(*((void *)&v112 + 1) + 8LL * (void)v53);
          if ([v55 containsString:v52])
          {
            uint64_t v110 = 0u;
            uint64_t v111 = 0u;
            uint64_t v108 = 0u;
            unint64_t v109 = 0u;
            id v56 = v14[6];
            id v57 = [v56 countByEnumeratingWithState:&v108 objects:v136 count:16];
            if (v57)
            {
              id v58 = v57;
              int v59 = *(void *)v109;
              while (2)
              {
                for (m = 0LL; m != v58; m = (char *)m + 1)
                {
                  if (*(void *)v109 != v59) {
                    objc_enumerationMutation(v56);
                  }
                  uint64_t v61 = *(void *)(*((void *)&v108 + 1) + 8LL * (void)m);
                  if ([v55 containsString:v61])
                  {
                    -[NSMutableSet addObject:](v96, "addObject:", v61);
                    [v101[9] setObject:0 forKeyedSubscript:v61];
                    __int128 v54 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKeyedSubscript:](v97, "objectForKeyedSubscript:", v55));
                    __int128 v62 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:kSCPropNetIPv6Addresses]);
                    __int128 v63 = (void *)objc_claimAutoreleasedReturnValue([v54 objectForKeyedSubscript:kSCPropNetIPv6Flags]);
                    id v64 = [v62 count];
                    if (v64 == [v63 count])
                    {
                      id v92 = v54;
                      uint64_t v65 = (char *)[v62 count];
                      uint64_t v99 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
                      if (v65)
                      {
                        for (n = 0LL; n != v65; ++n)
                        {
                          uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue([v63 objectAtIndexedSubscript:n]);
                          __int128 v69 = (void *)objc_claimAutoreleasedReturnValue([v62 objectAtIndexedSubscript:n]);
                          uint64_t v70 = [v68 unsignedIntValue];
                          if (((unsigned __int16)v70 & 0x101F) != 0)
                          {
                            unint64_t v71 = v70;
                            if (qword_1001DC8D0 != -1) {
                              dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
                            }
                            if (_NRLogIsLevelEnabled(qword_1001DC8C8, 1LL))
                            {
                              if (qword_1001DC8D0 != -1) {
                                dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
                              }
                              _NRLogWithArgs( qword_1001DC8C8,  1LL,  "%s%.30s:%-4d Ignoring ipv6 address: %@ (%#x)",  "",  "-[NRLinkManagerWired processSCDUpdate:]",  479LL,  v69,  v71);
                            }
                          }

                          else if (inet_pton(30, (const char *)[v69 UTF8String], v134) == 1)
                          {
                            uint64_t v72 = v134[0] | v134[1] | v134[2];
                            if (!v72 && !v135
                              || (v135 == 0x1000000 ? (__int128 v73 = v72 == 0) : (__int128 v73 = 0),
                                  v73 || LOBYTE(v134[0]) == 255 || (v134[0] & 0xC0FF) == 0x80FE))
                            {
                              if (qword_1001DC8D0 != -1) {
                                dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
                              }
                              if (_NRLogIsLevelEnabled(qword_1001DC8C8, 1LL))
                              {
                                if (qword_1001DC8D0 != -1) {
                                  dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
                                }
                                _NRLogWithArgs( qword_1001DC8C8,  1LL,  "%s%.30s:%-4d Ignoring ipv6 address: %@",  "",  "-[NRLinkManagerWired processSCDUpdate:]",  491LL,  v69);
                              }
                            }

                            else
                            {
                              id v67 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v69,  @"0"));
                              -[NSMutableArray addObject:](v99, "addObject:", v67);
                            }
                          }
                        }
                      }

                      if (-[NSMutableArray count](v99, "count")) {
                        [v101[9] setObject:v99 forKeyedSubscript:v61];
                      }

                      uint64_t v48 = v90;
                      id v50 = v91;
                      __int128 v54 = v92;
                    }

                    else
                    {
                      if (qword_1001DC8D0 != -1) {
                        dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
                      }
                      if (_NRLogIsLevelEnabled(qword_1001DC8C8, 17LL))
                      {
                        if (qword_1001DC8D0 != -1) {
                          dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
                        }
                        _NRLogWithArgs( qword_1001DC8C8,  17LL,  "Mismatch between ipv6 address and flags array: %@ %@",  v62,  v63);
                      }
                    }

                    int v51 = v95;
                    goto LABEL_83;
                  }
                }

                id v58 = [v56 countByEnumeratingWithState:&v108 objects:v136 count:16];
                if (v58) {
                  continue;
                }
                break;
              }
            }

LABEL_72:
LABEL_73:
  queue = self->_queue;
  id v58 = v4;
  dispatch_assert_queue_V2((dispatch_queue_t)queue);
  [v58 removePolicies];

  sub_1000E160C((uint64_t)self);
  sub_1000DAF94((uint64_t)self);
  if ([v58 subtype] != 102
    && [v58 subtype] != 103
    && [v58 subtype] != 104
    && [v58 type] != 4
    || [v58 startRequested])
  {
    sub_1000E1878((uint64_t)self, self->_primaryLink);
  }
}

LABEL_72:
}

LABEL_12:
}

  return v4;
}
}

  return v8;
}
}
}

  unsigned __int8 v13 = sub_1000AA684((uint64_t)&OBJC_CLASS___NRLinkDirector, v0);
  os_log_t v1 = (__CFString *)v13;
  if (v13)
  {
    id v14 = v13;

    v0 = v14;
  }

  else if ((-[NSMutableArray containsObject:](v0, "containsObject:", v5) & 1) != 0)
  {
    goto LABEL_32;
  }

  -[NSMutableArray addObject:](v0, "addObject:", v5);
LABEL_17:
  id v38 = 0LL;
  id v15 = (void *)objc_claimAutoreleasedReturnValue( +[NSPropertyListSerialization dataWithPropertyList:format:options:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "dataWithPropertyList:format:options:error:",  v0,  200LL,  0LL,  &v38));
  id v16 = v38;
  if (v16)
  {
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC898, 17LL))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      uint64_t v17 = (id)qword_1001DC898;
      id v18 = (void *)objc_claimAutoreleasedReturnValue([v16 localizedDescription]);
      _NRLogWithArgs( v17,  17LL,  "[NSPropertyListSerialization dataWithPropertyList: %@ format: options: error: %@]",  v0,  v18);
    }
  }

  else if ((sub_1001010F0(@"/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist", v15, 1) & 1) == 0)
  {
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC898, 16LL))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      _NRLogWithArgs( qword_1001DC898,  16LL,  "%s%.30s:%-4d failed to write file %@\n",  "",  "-[NRLinkDirector addTerminusPrefixDropPolicy]",  1710LL,  @"/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist");
    }
  }

LABEL_32:
  objc_opt_self(&OBJC_CLASS___NRDKeyManager);
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  uint64_t v19 = (id)qword_1001DCC10;
  sub_100144478((uint64_t)v19, &stru_1001AEF88);

  unsigned int v20 = ne_session_add_necp_drop_dest_from_path([@"/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist" UTF8String]);
  if ((_DWORD)v20)
  {
    size_t v2 = (__objc2_meth_list **)v20;
    if (qword_1001DC8A0 == -1)
    {
LABEL_36:
      if (_NRLogIsLevelEnabled(qword_1001DC898, 17LL))
      {
        if (p_class_meths[276] != (__objc2_meth_list *)-1LL) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        _NRLogWithArgs(qword_1001DC898, 17LL, "ne_session_add_necp_drop_dest_from_path failed %d\n", (_DWORD)v2);
      }

      unsigned int v21 = _CFXPCCreateXPCObjectFromCFObject(v0);
      uint64_t v22 = (void *)v21;
      if (!v21 || (size_t v2 = (__objc2_meth_list **)ne_session_add_necp_drop_dest_from_dest_list(v21), (_DWORD)v2))
      {
        if (p_class_meths[276] != (__objc2_meth_list *)-1LL) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC898, 17LL))
        {
          if (p_class_meths[276] != (__objc2_meth_list *)-1LL) {
            dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
          }
          _NRLogWithArgs(qword_1001DC898, 17LL, "ne_session_add_necp_drop_dest_from_dest_list failed %d\n", (_DWORD)v2);
        }

        uint32_t v23 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"ne_session_add_necp_drop_dest_* failed with error %d",  v2);
        sub_1001030D0(@"addTerminusPrefixDropPolicy", v23, 0LL, 0, 0LL, v24, v25, v26, v37);
      }

      else
      {
        if (p_class_meths[276] != (__objc2_meth_list *)-1LL) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC898, 0LL))
        {
          if (p_class_meths[276] != (__objc2_meth_list *)-1LL) {
            dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
          }
          _NRLogWithArgs( qword_1001DC898,  0LL,  "%s%.30s:%-4d ne_session_add_necp_drop_dest_from_dest_list: success",  "",  "-[NRLinkDirector addTerminusPrefixDropPolicy]",  1730);
        }
      }

      goto LABEL_62;
    }

  id v14 = sub_1000AA684((uint64_t)&OBJC_CLASS___NRLinkDirector, v0);
  os_log_t v1 = (__CFString *)v14;
  if (v14)
  {
    id v15 = v14;

    v0 = v15;
    if ((-[NSMutableArray containsObject:](v15, "containsObject:", v6) & 1) == 0)
    {
LABEL_17:
      id v30 = 0LL;
      size_t v2 = (_UNKNOWN **)objc_claimAutoreleasedReturnValue( +[NSPropertyListSerialization dataWithPropertyList:format:options:error:]( &OBJC_CLASS___NSPropertyListSerialization,  "dataWithPropertyList:format:options:error:",  v0,  200LL,  0LL,  &v30));
      p_class_meths = (__objc2_meth_list **)v30;
      if (!p_class_meths)
      {
        if ((sub_1001010F0(@"/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist", v2, 1) & 1) == 0)
        {
          if (qword_1001DC8A0 != -1) {
            dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC898, 17LL))
          {
            if (qword_1001DC8A0 != -1) {
              dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
            }
            _NRLogWithArgs( qword_1001DC898,  17LL,  "failed to write file %@\n",  @"/var/mobile/Library/terminus/com.apple.necp_drop_dest.plist");
          }
        }

        goto LABEL_30;
      }

      uint64_t v4 = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
      if (qword_1001DC8A0 == -1)
      {
LABEL_19:
        if (_NRLogIsLevelEnabled(qword_1001DC898, 17LL))
        {
          if (v4[276] != (__objc2_meth_list *)-1LL) {
            dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
          }
          id v16 = (id)qword_1001DC898;
          uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([p_class_meths localizedDescription]);
          _NRLogWithArgs( v16,  17LL,  "[NSPropertyListSerialization dataWithPropertyList: %@ format: options: error: %@] failed",  v0,  v17);
        }

  return (char)self;
}
  }
}

    id v15 = 0LL;
    goto LABEL_6;
  }

  if (!v7)
  {
    unsigned int v20 = sub_10010E060();
    unsigned int v21 = _NRLogIsLevelEnabled(v20, 17LL);

    if (v21)
    {
      uint64_t v19 = sub_10010E060();
      _NRLogWithArgs(v19, 17LL, "%s called with null nrUUID");
      goto LABEL_11;
    }

    goto LABEL_12;
  }

  v31.receiver = a1;
  v31.super_class = (Class)&OBJC_CLASS___NRDevicePreferencesManager;
  id v9 = (id *)objc_msgSendSuper2(&v31, "init");
  if (!v9)
  {
    uint64_t v22 = sub_10010E060();
    uint32_t v23 = _NRLogIsLevelEnabled(v22, 16LL);

    if (v23)
    {
      unsigned int v24 = sub_10010E060();
      _NRLogWithArgs( v24,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDevicePreferencesManager initPrefManagerWithQueue:nrUUID:]",  54);
    }

    uint64_t v25 = _os_log_pack_size(12LL);
    id v26 = (char *)&v30 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v27 = __error();
    uint64_t v28 = _os_log_pack_fill(v26, v25, *v27, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)uint64_t v28 = 136446210;
    *(void *)(v28 + 4) = "-[NRDevicePreferencesManager initPrefManagerWithQueue:nrUUID:]";
    __int128 v29 = sub_10010E060();
    _NRLogAbortWithPack(v29, v26);
  }

  id v10 = v9;
  objc_storeStrong(v9 + 3, a2);
  objc_storeStrong(v10 + 2, a3);
  unsigned __int8 v11 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  unsigned __int8 v12 = v10[4];
  v10[4] = v11;

  unsigned __int8 v13 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v14 = v10[5];
  v10[5] = v13;

  a1 = v10;
  id v15 = a1;
LABEL_6:

  return v15;
}

  if (v5[6])
  {
    uint64_t v17 = (char *)objc_alloc(v2 + 185);
    id v18 = v5[6];
    uint64_t v19 = sub_100124F00(v17, v18);
    unsigned int v20 = (void *)a1[4];
    a1[4] = v19;

    unsigned int v21 = (void *)a1[4];
    if (v21)
    {
      if (!v5[5])
      {
        uint64_t v41 = sub_100121F34();
        id v42 = _NRLogIsLevelEnabled(v41, 17LL);

        if (!v42) {
          goto LABEL_18;
        }
        id v16 = sub_100121F34();
        _NRLogWithArgs(v16, 17LL, "Legacy DH public key is missing when migrating DH private key!");
        goto LABEL_17;
      }

      id v16 = sub_100124E58(v21);
      if (!v16) {
        goto LABEL_36;
      }
      if ([v5[5] isEqualToData:v16])
      {
LABEL_17:

        goto LABEL_18;
      }

      uint64_t v43 = sub_100121F34();
      id v44 = _NRLogIsLevelEnabled(v43, 17LL);

      if (!v44) {
        goto LABEL_36;
      }
      uint64_t v40 = sub_100121F34();
      _NRLogWithArgs(v40, 17LL, "Migrated DH public key != legacy DH public key!");
      goto LABEL_35;
    }

  return a1;
}

  return v4;
}

void sub_100028C2C(id *a1)
{
  if (a1) {
    id v2 = a1[3];
  }
  else {
    id v2 = 0LL;
  }
  int v3 = (dispatch_queue_s *)v2;
  dispatch_assert_queue_V2(v3);

  if (a1[8])
  {
    uint64_t v4 = sub_100131C00((uint64_t)&OBJC_CLASS___NRDLocalDevice);
    if (-[NSMutableArray count](v4, "count"))
    {
      id v5 = sub_10011E67C(v4);
      [a1 reportEvent:4009 details:v5];

      id v6 = a1[8];
      id v7 = a1[3];
      if (qword_1001DCA30 != -1) {
        dispatch_once(&qword_1001DCA30, &stru_1001AFC68);
      }
      id v8 = (dispatch_queue_s *)(id)qword_1001DCA38;
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472LL;
      v11[2] = sub_100028DB4;
      v11[3] = &unk_1001AF908;
      id v12 = v6;
      unsigned __int8 v13 = v4;
      id v14 = v7;
      id v15 = a1;
      id v9 = v7;
      id v10 = v6;
      dispatch_async(v8, v11);
    }

    else
    {
      [a1 reportEvent:4011];
      sub_100028E3C((uint64_t)a1);
    }
  }

void sub_100028DB4(uint64_t a1)
{
  id v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) retrievePeripheralsWithIdentifiers:*(void *)(a1 + 40)]);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472LL;
  v5[2] = sub_100029070;
  v5[3] = &unk_1001B0720;
  int v3 = *(dispatch_queue_s **)(a1 + 48);
  void v5[4] = *(void *)(a1 + 56);
  id v6 = v2;
  id v4 = v2;
  dispatch_async(v3, v5);
}

void sub_100028E3C(uint64_t a1)
{
  if (a1) {
    id v2 = *(void **)(a1 + 24);
  }
  else {
    id v2 = 0LL;
  }
  int v3 = v2;
  dispatch_assert_queue_V2(v3);

  if (*(void *)(a1 + 64))
  {
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    __int128 v12 = 0u;
    __int128 v13 = 0u;
    id v4 = *(id *)(a1 + 72);
    id v5 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
    if (v5)
    {
      id v6 = v5;
      uint64_t v7 = *(void *)v13;
      do
      {
        for (i = 0LL; i != v6; i = (char *)i + 1)
        {
          if (*(void *)v13 != v7) {
            objc_enumerationMutation(v4);
          }
          id v9 = *(void **)(*((void *)&v12 + 1) + 8LL * (void)i);
          sub_100028FB0((id *)a1, v9);
          id v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "description", (void)v12));
          [(id)a1 reportEvent:4008 details:v10];
        }

        id v6 = [v4 countByEnumeratingWithState:&v12 objects:v16 count:16];
      }

      while (v6);
    }

    unsigned __int8 v11 = *(void **)(a1 + 72);
    *(void *)(a1 + 72) = 0LL;
  }

void sub_100028FB0(id *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v7 = v3;
    id v4 = (dispatch_queue_s *)a1[3];
    dispatch_assert_queue_V2(v4);

    id v3 = v7;
    if (v7)
    {
      if (a1[8])
      {
        if ([v7 state] == (id)1 || (v5 = objc_msgSend(v7, "state") == (id)2, id v3 = v7, v5))
        {
          id v6 = (void *)objc_claimAutoreleasedReturnValue([v7 description]);
          [a1 reportEvent:4003 details:v6];

          [a1[8] cancelPeripheralConnection:v7];
          id v3 = v7;
        }
      }
    }
  }
}

void sub_100029070(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  if (v2) {
    id v2 = (void *)v2[3];
  }
  id v3 = v2;
  dispatch_assert_queue_V2(v3);

  id v4 = sub_100131C00((uint64_t)&OBJC_CLASS___NRDLocalDevice);
  BOOL v5 = *(void **)(a1 + 32);
  id v6 = &selRef_sources;
  if (v5) {
    BOOL v5 = (void *)v5[9];
  }
  __int128 v45 = 0u;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  __int128 v48 = 0u;
  id obj = v5;
  id v7 = [obj countByEnumeratingWithState:&v45 objects:v50 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v46;
    do
    {
      for (i = 0LL; i != v8; i = (char *)i + 1)
      {
        if (*(void *)v46 != v9) {
          objc_enumerationMutation(obj);
        }
        unsigned __int8 v11 = *(void **)(*((void *)&v45 + 1) + 8LL * (void)i);
        __int128 v12 = (void *)objc_claimAutoreleasedReturnValue([v11 identifier]);
        unsigned __int8 v13 = -[NSMutableArray containsObject:](v4, "containsObject:", v12);

        if ((v13 & 1) == 0) {
          sub_100028FB0(*(id **)(a1 + 32), v11);
        }
      }

      id v8 = [obj countByEnumeratingWithState:&v45 objects:v50 count:16];
    }

    while (v8);
  }

  __int128 v14 = *(id **)(a1 + 32);
  if (v14)
  {
    objc_storeStrong(v14 + 9, *(id *)(a1 + 40));
    __int128 v15 = *(void **)(a1 + 32);
    if (v15) {
      __int128 v14 = (id *)v15[9];
    }
    else {
      __int128 v14 = 0LL;
    }
  }

  else
  {
    __int128 v15 = 0LL;
  }

  id v16 = v14;
  uint64_t v17 = sub_10011E67C(v16);
  [v15 reportEvent:4010 details:v17];

  __int128 v43 = 0u;
  __int128 v44 = 0u;
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  id v18 = *(void **)(a1 + 32);
  if (v18) {
    id v18 = (void *)v18[9];
  }
  uint64_t v19 = v18;
  id v20 = [v19 countByEnumeratingWithState:&v41 objects:v49 count:16];
  if (v20)
  {
    id v21 = v20;
    char v22 = 0;
    uint64_t v23 = *(void *)v42;
    while (1)
    {
      for (j = 0LL; j != v21; j = (char *)j + 1)
      {
        if (*(void *)v42 != v23) {
          objc_enumerationMutation(v19);
        }
        uint64_t v25 = *(void **)(*((void *)&v41 + 1) + 8LL * (void)j);
        id v26 = (void *)objc_claimAutoreleasedReturnValue([v25 identifier]);
        unsigned __int8 v27 = -[NSMutableArray containsObject:](v4, "containsObject:", v26);

        if ((v27 & 1) != 0)
        {
          if ([v25 state] == (id)1 || objc_msgSend(v25, "state") == (id)2)
          {
            char v22 = 1;
            continue;
          }

          uint64_t v28 = *(void **)(a1 + 32);
          __int128 v29 = (void *)objc_claimAutoreleasedReturnValue([v25 description]);
          [v28 reportEvent:4000 details:v29];

          uint64_t v30 = *(void *)(a1 + 32);
          if (v30) {
            uint64_t v31 = *(void **)(v30 + 64);
          }
          else {
            uint64_t v31 = 0LL;
          }
          [v31 connectPeripheral:v25 options:0];
          unsigned int v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
          uint64_t v33 = *(void *)(a1 + 32);
          if (v33) {
            objc_storeStrong((id *)(v33 + 144), v32);
          }
          char v22 = 1;
        }

        else
        {
          if (qword_1001DC728 != -1) {
            dispatch_once(&qword_1001DC728, &stru_1001AE510);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC720, 0LL))
          {
            if (qword_1001DC728 != -1) {
              dispatch_once(&qword_1001DC728, &stru_1001AE510);
            }
            id v34 = (id)qword_1001DC720;
            unsigned int v35 = (void *)objc_claimAutoreleasedReturnValue([v25 description]);
            _NRLogWithArgs( v34,  0LL,  "%s%.30s:%-4d Skipping over peripheral %@, as it is no longer enabled",  "",  "-[NRLinkManagerBluetooth connectToPeripherals]_block_invoke_2",  570LL,  v35);
          }

          id v36 = *(void **)(a1 + 32);
          unsigned int v32 = (void *)objc_claimAutoreleasedReturnValue([v25 description]);
          [v36 reportEvent:4006 details:v32];
        }
      }

      id v21 = [v19 countByEnumeratingWithState:&v41 objects:v49 count:16];
      if (!v21)
      {

        id v6 = &selRef_sources;
        if ((v22 & 1) != 0) {
          goto LABEL_49;
        }
        goto LABEL_47;
      }
    }
  }

LABEL_47:
  uint64_t v37 = *(void *)(a1 + 32);
  if (v37)
  {
    uint64_t v38 = *((int *)v6 + 846);
    char v39 = *(void **)(v37 + v38);
    *(void *)(v37 + v3_Block_object_dispose((const void *)(v27 - 152), 8) = 0LL;
  }

LABEL_49:
}
}

  -[NSMutableArray addObject:](v8, "addObject:", @"BatteryPercentageFair");
  if ((reason & 0x10000000) == 0)
  {
LABEL_24:
    if ((reason & 0x20000000) == 0) {
      goto LABEL_25;
    }
    goto LABEL_51;
  }

  -[NSMutableArray addObject:](v3, "addObject:", @"RdDtr");
  if ((a1 & 0x2000000000000000LL) == 0)
  {
LABEL_24:
    if ((a1 & 0x4000000000000000LL) == 0) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }

        __break(1u);
LABEL_50:
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
LABEL_23:
        __int128 v29 = (id)qword_1001DCB58;
        uint64_t v30 = sub_100120E44((uint64_t)v29, @"NRLinkDirector-skip-privacy-proxy", (void *)v1);

        objc_opt_self(&v28[63]);
        if (v2[364] != (__objc2_meth_list *)-1LL) {
          dispatch_once(&qword_1001DCB60, &stru_1001B0538);
        }
        uint64_t v31 = (id)qword_1001DCB58;
        unsigned int v32 = (id *)v31;
        if (v31)
        {
          dispatch_assert_queue_V2(*((dispatch_queue_t *)v31 + 1));
          if (([v32[2] apply] & 1) == 0) {
            sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v33,  v34,  v35,  v64);
          }
        }

        goto LABEL_31;
      }
    }

    else
    {
    }

    sub_1000A441C((uint64_t)v66);
LABEL_31:
  }

          goto LABEL_50;
        }

        __int128 v42 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v7);
        __int128 v43 = _NRLogIsLevelEnabled(v42, 17LL);

        if (v43)
        {
          id v36 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v44);
          uint64_t v37 = -[NRLink copyDescription](self, "copyDescription");
          _NRLogWithArgs(v36, 17LL, "%@: failed to set interface rank", v37);
          goto LABEL_25;
        }

          unsigned __int8 v27 = objc_opt_self(p_class_meths);
          sub_100128908(v27);
          goto LABEL_71;
        }

void sub_1000294D4(uint64_t a1)
{
  if (a1) {
    id v4 = *(void **)(a1 + 24);
  }
  else {
    id v4 = 0LL;
  }
  BOOL v5 = v4;
  dispatch_assert_queue_V2(v5);

  if (*(void *)(a1 + 64) && sub_100029694(a1))
  {
    id v14 = *(id *)(a1 + 80);
    uint64_t v6 = objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:&off_1001BC550]);
    id v7 = (void *)v6;
    if (v6 && *(_BYTE *)(v6 + 8) == 2)
    {
      int v8 = 0;
    }

    else
    {
      id v1 = *(id *)(a1 + 88);
      uint64_t v9 = (_BYTE *)objc_claimAutoreleasedReturnValue([v1 objectForKeyedSubscript:&off_1001BC550]);
      id v2 = v9;
      if (!v9 || v9[8] != 2)
      {

        return;
      }

      int v8 = 1;
    }

    id v10 = [*(id *)(a1 + 40) count];
    if (v8)
    {
    }

    if (!v10)
    {
      uint64_t v11 = *(void *)(a1 + 96) + 1LL;
      *(void *)(a1 + 96) = v11;
      dispatch_time_t v12 = dispatch_time(0x8000000000000000LL, 5000000000LL);
      unsigned __int8 v13 = (dispatch_queue_s *)*(id *)(a1 + 24);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_1000297BC;
      block[3] = &unk_1001AF588;
      void block[4] = a1;
      block[5] = v11;
      dispatch_after(v12, v13, block);
    }
  }

uint64_t sub_100029694(uint64_t a1)
{
  if (!a1) {
    return 0LL;
  }
  id v2 = (dispatch_queue_s *)*(id *)(a1 + 24);
  dispatch_assert_queue_V2(v2);

  __int128 v10 = 0u;
  __int128 v11 = 0u;
  __int128 v8 = 0u;
  __int128 v9 = 0u;
  id v3 = *(id *)(a1 + 72);
  uint64_t v4 = (uint64_t)[v3 countByEnumeratingWithState:&v8 objects:v12 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v9;
    while (2)
    {
      for (uint64_t i = 0LL; i != v4; ++i)
      {
        if (*(void *)v9 != v5) {
          objc_enumerationMutation(v3);
        }
        if (objc_msgSend(*(id *)(*((void *)&v8 + 1) + 8 * i), "state", (void)v8) == (id)2)
        {
          uint64_t v4 = 1LL;
          goto LABEL_12;
        }
      }

      uint64_t v4 = (uint64_t)[v3 countByEnumeratingWithState:&v8 objects:v12 count:16];
      if (v4) {
        continue;
      }
      break;
    }
  }

void sub_1000297BC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(v2 + 96);
  if (v3) {
    BOOL v4 = *(void *)(a1 + 40) == v3;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4 && sub_100029694(v2))
  {
    uint64_t v5 = *(void **)(a1 + 32);
    if (v5) {
      uint64_t v5 = (void *)v5[10];
    }
    uint64_t v17 = v5;
    uint64_t v6 = objc_claimAutoreleasedReturnValue(-[NRAnalyticsLinkManagerBluetooth objectForKeyedSubscript:](v17, "objectForKeyedSubscript:", &off_1001BC550));
    id v7 = (void *)v6;
    if (v6 && *(_BYTE *)(v6 + 8) == 2) {
      goto LABEL_16;
    }
    __int128 v8 = *(void **)(a1 + 32);
    if (v8) {
      __int128 v8 = (void *)v8[11];
    }
    __int128 v9 = v8;
    __int128 v10 = (_BYTE *)objc_claimAutoreleasedReturnValue([v9 objectForKeyedSubscript:&off_1001BC550]);
    __int128 v11 = v10;
    if (v10 && v10[8] == 2)
    {

LABEL_16:
LABEL_17:

      return;
    }

    uint64_t v12 = *(void *)(a1 + 32);
    if (v12) {
      unsigned __int8 v13 = *(void **)(v12 + 40);
    }
    else {
      unsigned __int8 v13 = 0LL;
    }
    id v14 = [v13 count];

    if (!v14)
    {
      *(void *)(*(void *)(a1 + 32) + 96LL) = 0LL;
      [*(id *)(a1 + 32) reportEvent:4900];
      uint64_t v15 = *(void *)(a1 + 32);
      if (!*(_BYTE *)(v15 + 35))
      {
        *(_BYTE *)(v15 + 35) = 1;
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC720, 17LL))
        {
          if (qword_1001DC728 != -1) {
            dispatch_once(&qword_1001DC728, &stru_1001AE510);
          }
          _NRLogWithArgs( qword_1001DC720,  17LL,  "no BT callback received for pipe connect even after %llus of pipe registration",  5LL);
        }

        id v16 = objc_alloc_init(&OBJC_CLASS___NRAnalyticsLinkManagerBluetooth);
        if (v16) {
          v16->_noBTPipeCallbacks = 1;
        }
        uint64_t v17 = v16;
        -[NRAnalyticsLinkManagerBluetooth submit](v16, "submit");
        goto LABEL_17;
      }

      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC720, 16LL))
      {
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        _NRLogWithArgs( qword_1001DC720,  16LL,  "%s%.30s:%-4d no BT callbacks received for pipe connect, sim crash already generated",  "",  "-[NRLinkManagerBluetooth startBluetoothWatchdog]_block_invoke",  705);
      }
    }
  }

void sub_100029A6C(void *a1, uint64_t a2)
{
  if (a1[8])
  {
    if ((unint64_t)a2 >= 6) {
      BOOL v4 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"UnknownState(%lld)",  a2);
    }
    else {
      BOOL v4 = (NSString *)*(&off_1001AE570 + a2);
    }
    [a1 reportEvent:4100 details:v4];

    if (a2 == 5)
    {
      sub_100028C2C((id *)a1);
    }

    else if (a2 <= 3)
    {
      sub_100028E3C((uint64_t)a1);
    }
  }

void sub_100029B38(char *a1, uint64_t a2, int a3)
{
  uint64_t v6 = &OBJC_IVAR___NRLinkManagerBluetooth__pipeRegistrations;
  if (a3) {
    uint64_t v6 = &OBJC_IVAR___NRLinkManagerBluetooth__p2pPipeRegistrations;
  }
  id v7 = *(id *)&a1[*v6];
  __int128 v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", a2));
  uint64_t v11 = objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v8]);

  __int128 v9 = (void *)v11;
  if (v11)
  {
    if ((*(_BYTE *)(v11 + 9) & 0xA) != 0 && !*(_BYTE *)(v11 + 8))
    {
      id v10 = [*(id *)(v11 + 16) count];
      __int128 v9 = (void *)v11;
      if (!v10)
      {
        if ((*(_BYTE *)(v11 + 9) & 8) != 0)
        {
          *(_BYTE *)(v11 + 9) &= ~8u;
          [a1 reportEvent:4215];
        }

        sub_10002A260((uint64_t)a1, a2, a3);
        __int128 v9 = (void *)v11;
      }
    }
  }
}

void sub_100029C38(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (!v3)
  {
    id v18 = 0LL;
    id v15 = sub_100024E28();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v15, 17LL);

    id v3 = 0LL;
    if (!IsLevelEnabled) {
      goto LABEL_27;
    }
    uint64_t v6 = (NRCBScalablePipeConnectionState *)sub_100024E28();
    _NRLogWithArgs( v6,  17LL,  "%s called with null nrUUID",  "-[NRLinkManagerBluetooth cleanupPipeStateIfNeededForNRUUID:]");
    goto LABEL_26;
  }

  BOOL v4 = *(void **)(a1 + 136);
  if (v4)
  {
    id v18 = v3;
    uint64_t v5 = objc_claimAutoreleasedReturnValue([v4 objectForKeyedSubscript:v3]);
    if (v5)
    {
      uint64_t v6 = (NRCBScalablePipeConnectionState *)v5;
      if (*(_BYTE *)(v5 + 8) == 1)
      {
        uint64_t v7 = *(void *)(v5 + 16);
        uint64_t v8 = mach_continuous_time();
        if (v7) {
          BOOL v11 = v8 > v7;
        }
        else {
          BOOL v11 = 0;
        }
        if (v11)
        {
          if (qword_1001DC9F0 != -1)
          {
            uint64_t v17 = v8;
            dispatch_once(&qword_1001DC9F0, &stru_1001AFB98);
            uint64_t v8 = v17;
          }

          LODWORD(v9) = dword_1001DC9F8;
          LODWORD(v10) = *(_DWORD *)algn_1001DC9FC;
          unint64_t v12 = (unint64_t)((double)(v8 - v7) * (0.000000001 * (double)v9) / (double)v10);
        }

        else
        {
          unint64_t v12 = 0LL;
        }

        unsigned __int8 v13 = objc_alloc_init(&OBJC_CLASS___NRAnalyticsLinkManagerBluetooth);
        id v14 = v13;
        if (v13) {
          v13->_pipeConnectedDuration = v12;
        }
        -[NRAnalyticsLinkManagerBluetooth submit](v13, "submit");
      }

      else
      {
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC720, 17LL))
        {
          if (qword_1001DC728 != -1) {
            dispatch_once(&qword_1001DC728, &stru_1001AE510);
          }
          _NRLogWithArgs(qword_1001DC720, 17LL, "invalid pipe state %@", v6);
        }
      }
    }

    else
    {
      uint64_t v6 = objc_alloc_init(&OBJC_CLASS___NRCBScalablePipeConnectionState);
      if (!v6)
      {
        mach_continuous_time();
LABEL_25:
        [*(id *)(a1 + 136) setObject:v6 forKeyedSubscript:v18];
LABEL_26:

        id v3 = v18;
        goto LABEL_27;
      }
    }

    v6->_uint32_t state = 2;
    v6->_timeOfDisconnect = mach_continuous_time();
    goto LABEL_25;
  }

LABEL_27:
}

          goto LABEL_28;
        }

        if (v7 == 1)
        {
          uint64_t v38 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v4 + 4), v6);
          char v39 = _NRLogIsLevelEnabled(v38, 17LL);

          if (!v39) {
            goto LABEL_27;
          }
          BOOL v11 = (id)_NRCopyLogObjectForNRUUID(*((void *)v4 + 4), v40);
          unint64_t v12 = [v4 copyDescription];
          __int128 v41 = v12;
          uint64_t v28 = "%@: Link not ready to accept packets";
        }

        else
        {
          if (*(void *)(v4 + 295))
          {
            id v16 = *(void **)(v4 + 647);
            if (v16 && [v16 connectionState] == (id)3)
            {
              if (!v4[209])
              {
                id v49 = 0LL;
                __int128 v29 = sub_100041474(v4, &v49);
                uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
                objc_initWeak(&location, v4);
                *(void *)(v4 + 383) += v49;
                uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([v4 connection]);
                v45[0] = _NSConcreteStackBlock;
                v45[1] = 3221225472LL;
                v45[2] = sub_100041A54;
                v45[3] = &unk_1001AE6F8;
                objc_copyWeak(v47, &location);
                unsigned int v32 = v30;
                __int128 v46 = v32;
                v47[1] = v49;
                [v31 writeDatagrams:v32 completionHandler:v45];

                dispatch_suspend(*(dispatch_object_t *)(v4 + 319));
                v4[209] = 1;

                objc_destroyWeak(v47);
                objc_destroyWeak(&location);

                goto LABEL_27;
              }

              if (!gNRPacketLoggingEnabled) {
                goto LABEL_27;
              }
              uint64_t v17 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v4 + 4), v6);
              id v18 = _NRLogIsLevelEnabled(v17, 1LL);

              if (!v18) {
                goto LABEL_27;
              }
              BOOL v11 = (id)_NRCopyLogObjectForNRUUID(*((void *)v4 + 4), v19);
              unint64_t v12 = [v4 copyDescription];
              _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d %@: Skipping writing to QR because source suspended",  "",  "NRLinkLoopInterfaceToQR",  1915LL,  v12);
            }

            else
            {
              if (!gNRPacketLoggingEnabled) {
                goto LABEL_27;
              }
              id v20 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v4 + 4), v6);
              id v21 = _NRLogIsLevelEnabled(v20, 1LL);

              if (!v21) {
                goto LABEL_27;
              }
              BOOL v11 = (id)_NRCopyLogObjectForNRUUID(*((void *)v4 + 4), v22);
              unint64_t v12 = [v4 copyDescription];
              uint64_t v23 = *(void **)(v4 + 647);
              unsigned int v24 = sub_10004141C((unint64_t)[v23 connectionState]);
              _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d %@: Skipping writing to QR because connection %@ state %@",  "",  "NRLinkLoopInterfaceToQR",  1910LL,  v12,  v23,  v24);
            }

            goto LABEL_25;
          }

          uint64_t v25 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v4 + 4), v6);
          id v26 = _NRLogIsLevelEnabled(v25, 17LL);

          if (!v26) {
            goto LABEL_27;
          }
          BOOL v11 = (id)_NRCopyLogObjectForNRUUID(*((void *)v4 + 4), v27);
          unint64_t v12 = [v4 copyDescription];
          __int128 v41 = v12;
          uint64_t v28 = "%@: No nexus channel";
        }

        _NRLogWithArgs(v11, 17LL, v28, v41, v42, v43, v44);
        goto LABEL_25;
      }

      v3[211] = 1;
      dispatch_suspend(*(dispatch_object_t *)(v3 + 319));
      v3[209] = 1;
    }
  }

      os_channel_sync(*(void *)(a1 + 959), 0LL);
      if ((id)v10 == v6)
      {
        if (!gNRPacketLoggingEnabled)
        {
          unint64_t v10 = (unint64_t)v6;
          goto LABEL_36;
        }

        uint64_t v31 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v17);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v31, 1LL);

        if (IsLevelEnabled)
        {
          uint64_t v33 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v17);
          id v34 = [(id)a1 copyDescription];
          _NRLogWithArgs( v33,  1LL,  "%s%.30s:%-4d %@: Wrote %zu bytes to the channel",  "",  "-[NRLinkBluetooth writeBytesToChannel:length:]",  7022LL,  v34,  v6);
        }

        unint64_t v10 = (unint64_t)v6;
        if (!gNRPacketLoggingEnabled) {
          goto LABEL_36;
        }
LABEL_59:
        unsigned int v35 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v17);
        id v36 = _NRLogIsLevelEnabled(v35, 1LL);

        if (v36)
        {
          uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v17);
          uint64_t v38 = [(id)a1 copyDescription];
          _NRLogWithArgs( v37,  1LL,  "%s%.30s:%-4d %@: wrote %lld",  "",  "-[NRLinkBluetooth sendDataWithCount:]",  7099LL,  v38,  v10);
        }

        goto LABEL_36;
      }

      if (!gNRPacketLoggingEnabled) {
        goto LABEL_36;
      }
      char v22 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v17);
      uint64_t v23 = _NRLogIsLevelEnabled(v22, 1LL);

      if (v23)
      {
        unsigned int v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v17);
        uint64_t v25 = [(id)a1 copyDescription];
        _NRLogWithArgs( v24,  1LL,  "%s%.30s:%-4d %@: Wrote %zu bytes (but asked for %zu) to the channel",  "",  "-[NRLinkBluetooth writeBytesToChannel:length:]",  7020LL,  v25,  v10,  v6);

        if (!gNRPacketLoggingEnabled) {
          goto LABEL_36;
        }
        goto LABEL_59;
      }

      if (v6 == (id)++v8)
      {
        uint64_t v6 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  location,  &block,  16LL);
        if (v6) {
          goto LABEL_17;
        }
        break;
      }
    }
  }

  sub_1000AD9C8((uint64_t)val);
LABEL_94:

  unsigned int v32 = val;
  uint64_t v33 = *((void *)val + 5);
  if (!v33) {
    goto LABEL_124;
  }
  id v34 = (dispatch_queue_s *)*(id *)(v33 + 24);
  dispatch_assert_queue_V2(v34);

  sub_10002DFF0(v33);
  unsigned int v35 = [*(id *)(v33 + 40) copy];
  *(_OWORD *)id location = 0u;
  v452 = 0u;
  v453 = 0u;
  v454 = 0u;
  v412 = v35;
  id v36 = (char *)[v412 countByEnumeratingWithState:location objects:&block count:16];
  uint64_t v37 = v33;
  if (!v36) {
    goto LABEL_111;
  }
  uint64_t v38 = *(void *)v452;
  do
  {
    char v39 = 0LL;
    do
    {
      if (*(void *)v452 != v38) {
        objc_enumerationMutation(v412);
      }
      uint64_t v40 = *((void *)location[1] + (void)v39);
      if (v40) {
        __int128 v41 = *(void **)(v40 + 327);
      }
      else {
        __int128 v41 = 0LL;
      }
      __int128 v42 = v41;
      objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
      __int128 v43 = sub_10012E648((uint64_t)&OBJC_CLASS___NRDLocalDevice, v42);

      id WeakRetained = objc_loadWeakRetained((id *)(v37 + 120));
      if (v43)
      {
        if (v43[9]) {
          goto LABEL_106;
        }
        v394 = v43;
        [(id)v40 cancelWithReason:@"Device has been disabled %@"];
        __int128 v45 = (void *)*((void *)v43 + 4);
      }

      else
      {
        v394 = 0LL;
        [(id)v40 cancelWithReason:@"Device has been disabled %@"];
        __int128 v45 = 0LL;
      }

      __int128 v46 = v45;
      [WeakRetained pipeDidConnectForNRUUID:0 nrUUID:v46];

LABEL_106:
      ++v39;
    }

    while (v36 != v39);
    __int128 v47 = (char *)[v412 countByEnumeratingWithState:location objects:&block count:16];
    id v36 = v47;
  }

  while (v47);
LABEL_111:

  __int128 v48 = *(void **)(v37 + 48);
  if (v48) {
    sub_10002CC88((id *)v37, (unint64_t)[v48 state]);
  }
  id v49 = *(void **)(v37 + 64);
  if (v49) {
    sub_100029A6C((void *)v37, (uint64_t)[v49 state]);
  }
  id v50 = *(void **)(v37 + 56);
  if (v50) {
    sub_10002D104((void *)v37, (unint64_t)[v50 state]);
  }
  int v51 = sub_10013163C((uint64_t)&OBJC_CLASS___NRDLocalDevice);
  if (!-[NSMutableArray count](v51, "count"))
  {
    if (*(void *)(v37 + 64))
    {
      sub_100028E3C(v37);
      [*(id *)(v37 + 64) setDelegate:0];
      uint64_t v52 = *(void **)(v37 + 64);
      *(void *)(v37 + 64) = 0LL;
    }

    int v53 = *(void **)(v37 + 72);
    *(void *)(v37 + 72) = 0LL;

    if (*(void *)(v37 + 56))
    {
      sub_10002C424((id *)v37);
      [*(id *)(v37 + 56) setDelegate:0];
      __int128 v54 = *(void **)(v37 + 56);
      *(void *)(v37 + 56) = 0LL;
    }

    *(_BYTE *)(v37 + 33) = 0;
    sub_10002DA14(v37);
    id v55 = *(void **)(v37 + 136);
    *(void *)(v37 + 136) = 0LL;
  }

  sub_10002E6C8(v37);

  unsigned int v32 = val;
LABEL_124:
  id v56 = (id *)*((void *)v32 + 6);
  if (v56) {
    sub_100143448(v56);
  }
  id v57 = *((void *)v32 + 7);
  if (v57) {
    sub_1000FA824(v57);
  }
  id v58 = *((void *)v32 + 8);
  if (v58)
  {
    int v59 = (dispatch_queue_s *)*(id *)(v58 + 24);
    dispatch_assert_queue_V2(v59);

    unsigned int v60 = v58;
    uint64_t v61 = [*(id *)(v58 + 40) copy];
    *(_OWORD *)id from = 0u;
    v460 = 0u;
    v461 = 0u;
    v462 = 0u;
    __int128 v62 = v61;
    __int128 v63 = (char *)[v62 countByEnumeratingWithState:from objects:&block count:16];
    if (v63)
    {
      id v64 = *(void *)v460;
      do
      {
        for (uint64_t i = 0LL; i != v63; ++i)
        {
          if (*(void *)v460 != v64) {
            objc_enumerationMutation(v62);
          }
          BOOL v66 = (void *)*((void *)from[1] + (void)i);
          id v67 = (void *)objc_claimAutoreleasedReturnValue([v66 nrUUID]);
          uint64_t v68 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v67);

          if (!v68 || !v68[9]) {
            [v66 cancelWithReason:@"Device has been disabled %@", v68];
          }
        }

        __int128 v63 = (char *)[v62 countByEnumeratingWithState:from objects:&block count:16];
      }

      while (v63);
    }

    __int128 v69 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v60 + 88) allKeys]);
    v458 = 0u;
    v457 = 0u;
    v456 = 0u;
    v455 = 0u;
    uint64_t v70 = v69;
    unint64_t v71 = [v70 countByEnumeratingWithState:&v455 objects:location count:16];
    if (v71)
    {
      uint64_t v72 = *(void *)v456;
      do
      {
        for (j = 0LL; j != v71; j = (char *)j + 1)
        {
          if (*(void *)v456 != v72) {
            objc_enumerationMutation(v70);
          }
          unsigned int v74 = *(void **)(*((void *)&v455 + 1) + 8LL * (void)j);
          unsigned int v75 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v74);
          uint64_t v76 = v75;
          if (!v75 || !v75[9]) {
            [*(id *)(v60 + 88) setObject:0 forKeyedSubscript:v74];
          }
        }

        unint64_t v71 = [v70 countByEnumeratingWithState:&v455 objects:location count:16];
      }

      while (v71);
    }

    if (qword_1001DC8D0 != -1) {
      dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC8C8, 1LL))
    {
      if (qword_1001DC8D0 != -1) {
        dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
      }
      _NRLogWithArgs( qword_1001DC8C8,  1LL,  "%s%.30s:%-4d Forcing interface availability event to check for new enabled devices",  "",  "-[NRLinkManagerWired checkEnabledDevices]",  728);
    }

    sub_1000C9C88(v60);

    unsigned int v32 = val;
  }

  if (*((_BYTE *)v32 + 16))
  {
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC898, 0LL))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      _NRLogWithArgs( qword_1001DC898,  0LL,  "%s%.30s:%-4d Not starting conductors as AOVPN is configured %@",  "",  "-[NRLinkDirector checkEnabledDevices]",  822LL,  obj);
    }

    unsigned int v77 = objc_alloc_init(&OBJC_CLASS___NSArray);

    id obj = (NSMutableArray *)v77;
    unsigned int v32 = val;
  }

  int v78 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  v438 = 0u;
  v439 = 0u;
  v440 = 0u;
  v441 = 0u;
  unint64_t v79 = *((id *)v32 + 27);
  id v80 = [v79 countByEnumeratingWithState:&v438 objects:v448 count:16];
  if (v80)
  {
    int v81 = *(void *)v439;
    do
    {
      for (k = 0LL; k != v80; k = (char *)k + 1)
      {
        if (*(void *)v439 != v81) {
          objc_enumerationMutation(v79);
        }
        NSUInteger v83 = *(void *)(*((void *)&v438 + 1) + 8LL * (void)k);
      }

      id v80 = [v79 countByEnumeratingWithState:&v438 objects:v448 count:16];
    }

    while (v80);
  }

  v436 = 0u;
  v437 = 0u;
  v434 = 0u;
  v435 = 0u;
  v413 = v78;
  uint64_t v84 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v413,  "countByEnumeratingWithState:objects:count:",  &v434,  v447,  16LL);
  if (v84)
  {
    int v85 = *(void *)v435;
    do
    {
      for (m = 0LL; m != v84; m = (char *)m + 1)
      {
        if (*(void *)v435 != v85) {
          objc_enumerationMutation(v413);
        }
        int v87 = *(void *)(*((void *)&v434 + 1) + 8LL * (void)m);
        uint64_t v88 = (void *)objc_claimAutoreleasedReturnValue([*((id *)val + 27) objectForKeyedSubscript:v87]);
        sub_1000EED00((uint64_t)v88);

        [*((id *)val + 27) setObject:0 forKeyedSubscript:v87];
      }

      uint64_t v84 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v413,  "countByEnumeratingWithState:objects:count:",  &v434,  v447,  16LL);
    }

    while (v84);
  }

  if (-[NSMutableArray count](obj, "count") && qword_1001DC880 != -1) {
    dispatch_once(&qword_1001DC880, &stru_1001AEF68);
  }
  v432 = 0u;
  v433 = 0u;
  v430 = 0u;
  v431 = 0u;
  v407 = obj;
  v410 = (char *)-[NSMutableArray countByEnumeratingWithState:objects:count:]( v407,  "countByEnumeratingWithState:objects:count:",  &v430,  v446,  16LL);
  if (v410)
  {
    v408 = *(void *)v431;
    do
    {
      uint64_t v89 = 0LL;
      do
      {
        if (*(void *)v431 != v408)
        {
          id v90 = v89;
          objc_enumerationMutation(v407);
          uint64_t v89 = v90;
        }

        obja = v89;
        int v91 = *(void **)(*((void *)&v430 + 1) + 8LL * (void)v89);
        id v92 = (void *)objc_claimAutoreleasedReturnValue([*((id *)val + 27) objectForKeyedSubscript:v91]);
        int v93 = v92 == 0LL;

        if (!v93)
        {
          uint64_t v94 = (char *)objc_claimAutoreleasedReturnValue([*((id *)val + 27) objectForKeyedSubscript:v91]);
          sub_1000DAF94((uint64_t)v94);
          goto LABEL_277;
        }

        uint64_t v94 = sub_1000EC900((char *)objc_alloc(&OBJC_CLASS___NRDDeviceConductor), v91, *((void **)val + 17));
        NSUInteger v95 = [*((id *)val + 28) copy];
        v428 = 0u;
        v429 = 0u;
        v426 = 0u;
        v427 = 0u;
        id v96 = v95;
        unint64_t v97 = [v96 countByEnumeratingWithState:&v426 objects:v445 count:16];
        if (!v97) {
          goto LABEL_203;
        }
        uint64_t v98 = *(void *)v427;
        do
        {
          for (n = 0LL; n != v97; n = (char *)n + 1)
          {
            if (*(void *)v427 != v98) {
              objc_enumerationMutation(v96);
            }
            int v100 = *(void *)(*((void *)&v426 + 1) + 8LL * (void)n);
            if (v100)
            {
              id v101 = *(void **)(v100 + 16);
              goto LABEL_199;
            }

            if ([0 isEqual:v91])
            {
              id v101 = 0LL;
LABEL_199:
              sub_1000EF930((uint64_t)v94, v101);
              [*((id *)val + 28) removeObject:v100];
              uint64_t v102 = (void *)objc_claimAutoreleasedReturnValue([(id)v100 description]);
              sub_10011BB18(0LL, 1016, 0LL, v102);

              continue;
            }
          }

          unint64_t v97 = [v96 countByEnumeratingWithState:&v426 objects:v445 count:16];
        }

        while (v97);
LABEL_203:

        id v103 = [*((id *)val + 29) copy];
        v424 = 0u;
        v425 = 0u;
        v422 = 0u;
        v423 = 0u;
        id v104 = v103;
        unsigned int v105 = [v104 countByEnumeratingWithState:&v422 objects:v444 count:16];
        if (v105)
        {
          id v106 = *(void *)v423;
          do
          {
            for (iuint64_t i = 0LL; ii != v105; iuint64_t i = (char *)ii + 1)
            {
              if (*(void *)v423 != v106) {
                objc_enumerationMutation(v104);
              }
              uint64_t v108 = *(void **)(*((void *)&v422 + 1) + 8LL * (void)ii);
              if (v108) {
                unint64_t v109 = (void *)v108[1];
              }
              else {
                unint64_t v109 = 0LL;
              }
              if ([v109 isEqual:v91])
              {
                [*((id *)val + 29) removeObject:v108];
                uint64_t v110 = (void *)objc_claimAutoreleasedReturnValue([v108 description]);
                sub_10011BB18(0LL, 1023, 0LL, v110);

                if (v108) {
                  uint64_t v111 = (_xpc_connection_s *)v108[2];
                }
                else {
                  uint64_t v111 = 0LL;
                }
                xpc_connection_cancel(v111);
              }
            }

            unsigned int v105 = [v104 countByEnumeratingWithState:&v422 objects:v444 count:16];
          }

          while (v105);
        }

        if (!v94) {
          goto LABEL_276;
        }
        dispatch_assert_queue_V2(*((dispatch_queue_t *)v94 + 13));
        if (v94[13])
        {
          v113 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v94 + 12), v112);
          id v114 = _NRLogIsLevelEnabled(v113, 1LL);

          if (v114)
          {
            id v116 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v94 + 12), v115);
            _NRLogWithArgs( v116,  1LL,  "%s%.30s:%-4d Skipping start as conductor is already enabled",  "",  "-[NRDDeviceConductor startConductor]",  533);
            goto LABEL_275;
          }

          goto LABEL_276;
        }

        v94[13] = 1;
        v117 = (void *)objc_claimAutoreleasedReturnValue([v94 description]);
        sub_10011BB18(*((void **)v94 + 12), 1501, 0LL, v117);

        sub_1000ED270((uint64_t)v94);
        sub_1000E387C((void **)v94);
        __int128 v118 = objc_alloc(&OBJC_CLASS___NRDevicePreferencesManager);
        __int128 v119 = (void *)*((void *)v94 + 13);
        __int128 v120 = *((id *)v94 + 12);
        __int128 v121 = v119;
        __int128 v122 = sub_10010DE08((id *)&v118->super.isa, v121, v120);
        __int128 v123 = (void *)*((void *)v94 + 23);
        *((void *)v94 + 23) = v122;

        sub_1000EC574(v94);
        __int128 v124 = sub_1000A019C(*((void **)v94 + 12), @"WiFiEndpointAddressData");
        id v116 = (void *)objc_claimAutoreleasedReturnValue(v124);
        __int128 v125 = objc_opt_class(&OBJC_CLASS___NSData);
        if ((objc_opt_isKindOfClass(v116, v125) & 1) != 0)
        {
          __int128 v126 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithAddress:]( NWAddressEndpoint,  "endpointWithAddress:",  [v116 bytes]));
          __int128 v127 = v126;
          if (v94[43])
          {
            objc_storeStrong((id *)v94 + 17, v126);
            __int128 v129 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v94 + 12), v128);
            v130 = _NRLogIsLevelEnabled(v129, 1LL);

            if (v130)
            {
              v131 = *((id *)v94 + 12);
              v133 = (void *)_NRCopyLogObjectForNRUUID(v131, v132);
              v394 = "";
              _NRLogWithArgs(v133, 1LL, "%s%.30s:%-4d Fetched last sent endpoint as %@");
            }
          }

          else
          {
            v134 = (dispatch_queue_s *)*((void *)v94 + 13);
            block = _NSConcreteStackBlock;
            v464 = 3221225472LL;
            v465 = sub_1000EDA50;
            v466 = &unk_1001B0720;
            v467 = v94;
            v468 = v126;
            dispatch_async(v134, &block);
          }
        }

        v135 = *((id *)v94 + 12);
        v136 = sub_1000A019C(v135, @"WiFiSignature");
        v405 = (id)objc_claimAutoreleasedReturnValue(v136);

        v137 = objc_opt_class(&OBJC_CLASS___NSData);
        isKindOfClass = objc_opt_isKindOfClass(v405, v137);
        if ((isKindOfClass & 1) != 0)
        {
          if (v94[43])
          {
            objc_storeStrong((id *)v94 + 18, v405);
          }

          else
          {
            v139 = (dispatch_queue_s *)*((void *)v94 + 13);
            location[0] = _NSConcreteStackBlock;
            location[1] = (id)3221225472LL;
            *(void *)&v452 = sub_1000EDB0C;
            *((void *)&v452 + 1) = &unk_1001B0720;
            *(void *)&v453 = v94;
            *((void *)&v453 + 1) = v405;
            dispatch_async(v139, location);
          }
        }

        if (_NRIsAppleInternal(isKindOfClass))
        {
          v140 = sub_1000A019C(*((void **)v94 + 12), @"DisableRangeExtension");
          v141 = (void *)objc_claimAutoreleasedReturnValue(v140);
          v142 = objc_opt_class(&OBJC_CLASS___NSNumber);
          v143 = sub_1000A019C(*((void **)v94 + 12), @"DisablePreferWiFi");
          v144 = (void *)objc_claimAutoreleasedReturnValue(v143);
          v145 = objc_opt_class(&OBJC_CLASS___NSNumber);
        }

        sub_1000EB164((uint64_t)v94);
        if (v94[54])
        {
          v146 = objc_alloc(&OBJC_CLASS___NRQuickRelayAgent);
          v147 = (void *)*((void *)v94 + 12);
          v148 = *((id *)v94 + 13);
          v149 = v147;
          v150 = sub_10002FA5C((id *)&v146->super.isa, v149, v148, v94);
          v151 = (void *)*((void *)v94 + 24);
          *((void *)v94 + 24) = v150;

          v152 = *((void *)v94 + 24);
          if (v152)
          {
            dispatch_assert_queue_V2(*(dispatch_queue_t *)(v152 + 48));
            if (!*(_BYTE *)(v152 + 14))
            {
              v153 = -[NWNetworkAgentRegistration initWithNetworkAgentClass:]( objc_alloc(&OBJC_CLASS___NWNetworkAgentRegistration),  "initWithNetworkAgentClass:",  objc_opt_class(v152));
              v154 = *(void **)(v152 + 56);
              *(void *)(v152 + 56) = v153;

              v155 = *(void **)(v152 + 56);
              if (v155)
              {
                if ([v155 registerNetworkAgent:v152])
                {
                  v157 = (void *)objc_claimAutoreleasedReturnValue([(id)v152 agentUUID]);
                  v158 = objc_claimAutoreleasedReturnValue(+[NEPolicyResult netAgentUUID:](&OBJC_CLASS___NEPolicyResult, "netAgentUUID:", v157));

                  v159 = *(id *)(v152 + 40);
                  v160 = (void *)nrCopyAccountIdentifierForNRUUID();
                  v402 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition accountIdentifier:]( &OBJC_CLASS___NEPolicyCondition,  "accountIdentifier:",  v160));

                  v161 = (void *)objc_claimAutoreleasedReturnValue(+[NRQuickRelayAgent agentDomain](&OBJC_CLASS___NRQuickRelayAgent, "agentDomain"));
                  v162 = (void *)objc_claimAutoreleasedReturnValue(+[NRQuickRelayAgent agentType](&OBJC_CLASS___NRQuickRelayAgent, "agentType"));
                  v399 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition requiredAgentDomain:agentType:]( &OBJC_CLASS___NEPolicyCondition,  "requiredAgentDomain:agentType:",  v161,  v162));

                  v163 = objc_alloc(&OBJC_CLASS___NEPolicy);
                  from[0] = v399;
                  from[1] = v402;
                  v164 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
                  *(void *)&v460 = v164;
                  v165 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  from,  3LL));
                  v398 = [v163 initWithOrder:10 result:v158 conditions:v165];

                  objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                  if (qword_1001DCB60 != -1) {
                    dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                  }
                  v166 = (id)qword_1001DCB58;
                  v167 = sub_100120E44((uint64_t)v166, *(void **)(v152 + 72), v398);

                  objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
                  if (qword_1001DCB60 != -1) {
                    dispatch_once(&qword_1001DCB60, &stru_1001B0538);
                  }
                  v168 = (id)qword_1001DCB58;
                  v169 = (id *)v168;
                  if (v168)
                  {
                    dispatch_assert_queue_V2(*((dispatch_queue_t *)v168 + 1));
                    if (([v169[2] apply] & 1) == 0) {
                      sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v170,  v171,  v172,  (uint64_t)v394);
                    }
                  }

                  *(_BYTE *)(v152 + 14) = 1;
                  v173 = (void *)v158;
                  v174 = *(void **)(v152 + 40);
                  v175 = *(id *)(v152 + 80);
                  v176 = v174;
                  v177 = v173;
                  v397 = v176;
                  v178 = (void *)objc_claimAutoreleasedReturnValue([(id)v152 agentUUID]);
                  v179 = (void *)objc_claimAutoreleasedReturnValue([v178 UUIDString]);
                  sub_10011BB18(v397, 17002, v175, v179);

                  sub_1000300A8(v152);
LABEL_255:
                }

                else
                {
                  v180 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v152 + 40), v156);
                  v181 = _NRLogIsLevelEnabled(v180, 17LL);

                  if (v181)
                  {
                    v177 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v152 + 40), v182);
                    _NRLogWithArgs(v177, 17LL, "Failed to register QuickRelay network agent");
                    goto LABEL_255;
                  }
                }
              }
            }
          }
        }

        if (v94[53])
        {
          v183 = objc_alloc(&OBJC_CLASS___NRBTLinkPreferencesAgent);
          v184 = (void *)*((void *)v94 + 12);
          v185 = *((id *)v94 + 13);
          v186 = v184;
          v187 = sub_1000653D0((id *)&v183->super.isa, v186, v185, v94);
          v188 = (void *)*((void *)v94 + 25);
          *((void *)v94 + 25) = v187;

          v189 = *((void *)v94 + 25);
          if (v189)
          {
            if (!*(_BYTE *)(v189 + 14))
            {
              v190 = -[NWNetworkAgentRegistration initWithNetworkAgentClass:]( objc_alloc(&OBJC_CLASS___NWNetworkAgentRegistration),  "initWithNetworkAgentClass:",  objc_opt_class(v189));
              v191 = *(void **)(v189 + 56);
              *(void *)(v189 + 56) = v190;

              v195 = *(void **)(v189 + 56);
              if (!v195)
              {
                sub_1001030D0( @"NRBTLinkPreferenceAgent",  @"RegisterAgent",  @"Create Failed",  1,  @"Failed to create BTLinkPreferences network agent",  v192,  v193,  v194,  (uint64_t)v394);
                v195 = *(void **)(v189 + 56);
              }

              if (([v195 registerNetworkAgent:v189] & 1) == 0) {
                sub_1001030D0( @"NRBTLinkPreferenceAgent",  @"RegisterAgent",  @"Register Failed",  1,  @"Failed to register BTLinkPreferences network agent",  v196,  v197,  v198,  (uint64_t)v394);
              }
              [(id)v189 setActive:1];
              [*(id *)(v189 + 56) updateNetworkAgent:v189];
              v199 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forType:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forType:",  5LL,  6LL));
              v200 = (void *)objc_claimAutoreleasedReturnValue([(id)v189 agentUUID]);
              [v199 setNetworkAgentUUID:v200];

              *(void *)&v455 = v199;
              v201 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v455,  1LL));
              v403 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v201));

              v202 = (void *)objc_claimAutoreleasedReturnValue( +[NRBTLinkPreferencesAgent agentDomain]( &OBJC_CLASS___NRBTLinkPreferencesAgent,  "agentDomain"));
              v203 = (void *)objc_claimAutoreleasedReturnValue( +[NRBTLinkPreferencesAgent agentType]( &OBJC_CLASS___NRBTLinkPreferencesAgent,  "agentType"));
              v400 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition requiredAgentDomain:agentType:]( &OBJC_CLASS___NEPolicyCondition,  "requiredAgentDomain:agentType:",  v202,  v203));

              v204 = objc_alloc(&OBJC_CLASS___NEPolicy);
              from[0] = v400;
              v205 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
              from[1] = v205;
              v206 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  from,  2LL));
              v207 = [v204 initWithOrder:10 result:v403 conditions:v206];

              objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
              if (qword_1001DCB60 != -1) {
                dispatch_once(&qword_1001DCB60, &stru_1001B0538);
              }
              v208 = (id)qword_1001DCB58;
              v209 = sub_100120E44((uint64_t)v208, *(void **)(v189 + 72), v207);

              objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
              if (qword_1001DCB60 != -1) {
                dispatch_once(&qword_1001DCB60, &stru_1001B0538);
              }
              v210 = (id)qword_1001DCB58;
              v211 = (id *)v210;
              if (v210)
              {
                dispatch_assert_queue_V2(*((dispatch_queue_t *)v210 + 1));
                if (([v211[2] apply] & 1) == 0) {
                  sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v212,  v213,  v214,  (uint64_t)v394);
                }
              }

              *(_BYTE *)(v189 + 14) = 1;
              v215 = *(id *)(v189 + 40);
              v216 = (void *)objc_claimAutoreleasedReturnValue([(id)v189 agentUUID]);
              v217 = (void *)objc_claimAutoreleasedReturnValue([v216 UUIDString]);
              sub_10011BB18(v215, 18002, 0LL, v217);
            }
          }
        }

        sub_1000E475C((void **)v94);
        if (v94[44] && sub_100103800()) {
          sub_10011BB18(*((void **)v94 + 12), 1036, 0LL, 0LL);
        }
        v218 = (dispatch_queue_s *)*((void *)v94 + 13);
        from[0] = _NSConcreteStackBlock;
        from[1] = (id)3221225472LL;
        *(void *)&v460 = sub_1000EDBC8;
        *((void *)&v460 + 1) = &unk_1001B0A88;
        *(void *)&v461 = v94;
        dispatch_async(v218, from);

LABEL_275:
LABEL_276:
        [*((id *)val + 27) setObject:v94 forKeyedSubscript:v91];

LABEL_277:
        uint64_t v89 = obja + 1;
      }

      while (obja + 1 != v410);
      v410 = (char *)-[NSMutableArray countByEnumeratingWithState:objects:count:]( v407,  "countByEnumeratingWithState:objects:count:",  &v430,  v446,  16LL);
    }

    while (v410);
  }

  if (!-[NSMutableArray count](v407, "count"))
  {
    sub_1000AA0FC();
    v284 = (uint64_t)val;
    v285 = *((void *)val + 26);
    if (v285)
    {
      sub_1001482DC(v285);
      v286 = (void *)*((void *)val + 26);
      *((void *)val + 26) = 0LL;

      v284 = (uint64_t)val;
    }

    v287 = *(void *)(v284 + 96);
    if (v287)
    {
      sub_100060F1C(v287);
      v288 = (void *)*((void *)val + 12);
      *((void *)val + 12) = 0LL;

      v284 = (uint64_t)val;
    }

    sub_1000A441C(v284);
    sub_1000A45F8((uint64_t)val);
    sub_1000A4910((uint64_t)val);
    v289 = val;
    if (*((void *)val + 36))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC898, 0LL))
      {
        if (qword_1001DC8A0 != -1) {
          dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
        }
        v291 = (id)qword_1001DC898;
        v394 = "";
        _NRLogWithArgs(v291, 0LL, "%s%.30s:%-4d removing path evaluator for appVPN %@");
      }

      nw_path_evaluator_cancel(*((void *)val + 36), v290);
      v292 = (void *)*((void *)val + 36);
      *((void *)val + 36) = 0LL;

      v289 = val;
    }

    v293 = v289[7];
    if (v293 != -1)
    {
      notify_cancel(v293);
      v289 = val;
      *((_DWORD *)val + 7) = -1;
    }

    v294 = (void *)*((void *)v289 + 38);
    *((void *)v289 + 3_Block_object_dispose((const void *)(v27 - 152), 8) = 0LL;

    v295 = (void *)*((void *)val + 39);
    *((void *)val + 39) = 0LL;

    *(_OWORD *)id location = 0u;
    v452 = 0u;
    v453 = 0u;
    v454 = 0u;
    v296 = *((id *)val + 27);
    v297 = (char *)[v296 countByEnumeratingWithState:location objects:&block count:16];
    if (v297)
    {
      v298 = *(void *)v452;
      do
      {
        for (jj = 0LL; jj != v297; ++jj)
        {
          if (*(void *)v452 != v298) {
            objc_enumerationMutation(v296);
          }
          v300 = (_BYTE *)objc_claimAutoreleasedReturnValue( [*((id *)val + 27) objectForKeyedSubscript:*((void *)location[1] + (void)jj)]);
          sub_1000F0258(v300, 0);
        }

        v297 = (char *)[v296 countByEnumeratingWithState:location objects:&block count:16];
      }

      while (v297);
    }

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    v301 = (id)qword_1001DCB58;
    sub_10012114C((uint64_t)v301, @"NRLinkDirector-AppVPN");

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    v302 = (id)qword_1001DCB58;
    v303 = (id *)v302;
    if (v302)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v302 + 1));
      if (([v303[2] apply] & 1) == 0) {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v304,  v305,  v306,  (uint64_t)v394);
      }
    }

    v307 = (void *)*((void *)val + 37);
    *((void *)val + 37) = 0LL;

    val[18] = 0;
    v308 = (dispatch_source_s *)*((void *)val + 35);
    if (v308)
    {
      dispatch_source_cancel(v308);
      v309 = (void *)*((void *)val + 35);
      *((void *)val + 35) = 0LL;
    }

    objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
    if (qword_1001DC640 != -1) {
      dispatch_once(&qword_1001DC640, &stru_1001ADE98);
    }
    v310 = (id)qword_1001DC638;
    v311 = (uint64_t)v310;
    if (v310)
    {
      v312 = (void *)v310[2];
      if (v312)
      {
        [v312 cancel];
        v313 = *(void **)(v311 + 16);
        *(void *)(v311 + 16) = 0LL;

        objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
        if (qword_1001DCB60 != -1) {
          dispatch_once(&qword_1001DCB60, &stru_1001B0538);
        }
        v314 = (id)qword_1001DCB58;
        sub_10012114C((uint64_t)v314, @"NRIKEv2Listener");

        objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
        if (qword_1001DCB60 != -1) {
          dispatch_once(&qword_1001DCB60, &stru_1001B0538);
        }
        v315 = (id)qword_1001DCB58;
        v316 = (id *)v315;
        if (v315)
        {
          dispatch_assert_queue_V2(*((dispatch_queue_t *)v315 + 1));
          if (([v316[2] apply] & 1) == 0) {
            sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v317,  v318,  v319,  (uint64_t)v394);
          }
        }
      }

      v320 = *(void **)(v311 + 24);
      *(void *)(v311 + 24) = 0LL;

      v321 = *(void **)(v311 + 32);
      *(void *)(v311 + 32) = 0LL;

      v454 = 0u;
      v453 = 0u;
      v452 = 0u;
      *(_OWORD *)id location = 0u;
      v322 = *(id *)(v311 + 48);
      v323 = (char *)[v322 countByEnumeratingWithState:location objects:&block count:16];
      if (v323)
      {
        v324 = *(void *)v452;
        do
        {
          v325 = 0LL;
          do
          {
            if (*(void *)v452 != v324) {
              objc_enumerationMutation(v322);
            }
            v326 = objc_claimAutoreleasedReturnValue( [*(id *)(v311 + 48) objectForKeyedSubscript:*((void *)location[1] + (void)v325)]);
            v327 = (void *)v326;
            if (v326) {
              v328 = *(void *)(v326 + 40);
            }
            else {
              v328 = 0LL;
            }
            (*(void (**)(uint64_t, void, void, void))(v328 + 16))(v328, 0LL, 0LL, 0LL);

            ++v325;
          }

          while (v323 != v325);
          v329 = (char *)[v322 countByEnumeratingWithState:location objects:&block count:16];
          v323 = v329;
        }

        while (v329);
      }

      v330 = *(void **)(v311 + 48);
      *(void *)(v311 + 4_Block_object_dispose((const void *)(v27 - 152), 8) = 0LL;

      sub_10000E054(v311);
    }

    goto LABEL_457;
  }

  sub_1000A8298((NSUUID *)val);
  sub_1000A8B9C(val);
  v420 = 0u;
  v421 = 0u;
  v418 = 0u;
  v419 = 0u;
  v219 = *((id *)val + 27);
  v220 = [v219 countByEnumeratingWithState:&v418 objects:v443 count:16];
  if (!v220)
  {

    v222 = 0;
    goto LABEL_370;
  }

  v221 = 0;
  v222 = 0;
  v223 = *(void *)v419;
  do
  {
    v224 = 0LL;
    do
    {
      if (*(void *)v419 != v223) {
        objc_enumerationMutation(v219);
      }
      v225 = *(void *)(*((void *)&v418 + 1) + 8LL * (void)v224);
      v226 = (_BYTE *)objc_claimAutoreleasedReturnValue([*((id *)val + 27) objectForKeyedSubscript:v225]);
      if (v226) {
        v227 = v226[9] != 0;
      }
      else {
        v227 = 0;
      }

      v228 = (_BYTE *)objc_claimAutoreleasedReturnValue([*((id *)val + 27) objectForKeyedSubscript:v225]);
      if (v228) {
        v229 = v228[8] != 0;
      }
      else {
        v229 = 0;
      }

      v221 |= v227;
      v222 |= v229;
      v224 = (char *)v224 + 1;
    }

    while (v220 != v224);
    v230 = [v219 countByEnumeratingWithState:&v418 objects:v443 count:16];
    v220 = v230;
  }

  while (v230);

  if ((v221 & 1) == 0)
  {
LABEL_370:
    v231 = val;
    v331 = *((void *)val + 26);
    if (v331)
    {
      sub_1001482DC(v331);
      v332 = (void *)*((void *)val + 26);
      *((void *)val + 26) = 0LL;

      goto LABEL_372;
    }

    goto LABEL_28;
  }

  objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
  if (qword_1001DC640 != -1) {
    dispatch_once(&qword_1001DC640, &stru_1001ADE98);
  }
  int v51 = (id)qword_1001DC638;
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(-[NRLink localInterfaceName](self, "localInterfaceName"));
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(-[NRLink localOuterEndpoint](self, "localOuterEndpoint"));
  sub_10000F230((uint64_t)v51, self, v5, v6);
}

void sub_100029E6C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2)
  {
    int v3 = *(unsigned __int8 *)(a1 + 32);
    if (v3 == 3)
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC720, 0LL))
      {
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        _NRLogWithArgs( qword_1001DC720,  0LL,  "%s%.30s:%-4d Ignoring start BT advertisement request, advertisement is restarting");
      }
    }

    else if (v3 == 4)
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC720, 0LL))
      {
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        _NRLogWithArgs( qword_1001DC720,  0LL,  "%s%.30s:%-4d Ignoring start BT advertisement request, device is already advertising");
      }
    }

    else if ([v2 state] == (id)5 && (sub_100131D60((uint64_t)NRDLocalDevice) & 1) != 0)
    {
      *(_BYTE *)(a1 + 33) = 0;
      uint64_t v4 = *(unsigned __int8 *)(a1 + 33);
      if (*(_BYTE *)(a1 + 33))
      {
        if ((_DWORD)v4 == 1) {
          uint64_t v5 = @"1 sec";
        }
        else {
          uint64_t v5 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"UnknownType(%lld)",  v4);
        }
      }

      else
      {
        uint64_t v5 = @"Default";
      }

      [(id)a1 reportEvent:3501 details:v5];

      id v11 = *(id *)(a1 + 56);
      if (*(_BYTE *)(a1 + 33) == 1)
      {
        uint64_t v14 = CBPeripheralManagerAdvertisingInterval;
        id v15 = &off_1001BC598;
        unint64_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v15,  &v14,  1LL));
      }

      else
      {
        unint64_t v12 = 0LL;
      }

      [v11 startAdvertising:v12];

      *(_BYTE *)(a1 + 32) = 1;
    }

    else
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC720, 0LL))
      {
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        uint64_t v6 = (void *)qword_1001DC720;
        id v7 = *(id *)(a1 + 56);
        id v13 = v6;
        id v8 = [v7 state];
        if ((unint64_t)v8 >= 6) {
          unint64_t v9 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"UnknownState(%lld)",  v8);
        }
        else {
          unint64_t v9 = (NSString *)*(&off_1001AE570 + (void)v8);
        }
        unsigned int v10 = sub_100131D60((uint64_t)&OBJC_CLASS___NRDLocalDevice);
        _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d Ignoring start BT advertisement request, device cannot start advertising (%@/%d)",  "",  "-[NRLinkManagerBluetooth startBTAdvertisement]",  1702LL,  v9,  v10);
      }
    }
  }

void sub_10002A260(uint64_t a1, uint64_t a2, int a3)
{
  if (!a1) {
    return;
  }
  uint64_t v5 = a1;
  uint64_t v6 = (dispatch_queue_s *)*(id *)(a1 + 24);
  dispatch_assert_queue_V2(v6);

  if (a2 == 3)
  {
    id v7 = &OBJC_IVAR___NRLinkManagerBluetooth__pipeRegistrations;
    if (a3) {
      id v7 = &OBJC_IVAR___NRLinkManagerBluetooth__p2pPipeRegistrations;
    }
    id v8 = *(id *)(v5 + *v7);
    unint64_t v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", 3LL));
    unsigned int v10 = (_BYTE *)objc_claimAutoreleasedReturnValue([v8 objectForKeyedSubscript:v9]);

    if (!v10) {
      return;
    }
    char v11 = v10[9];

    if ((v11 & 4) == 0) {
      return;
    }
  }

  if (a3)
  {
    if (!*(_BYTE *)(v5 + 38)) {
      return;
    }
    unint64_t v12 = @"PeerToPeer";
    uint64_t v13 = 2LL;
    if (a2 == 2) {
      goto LABEL_56;
    }
  }

  else
  {
    if (!*(_BYTE *)(v5 + 37)) {
      return;
    }
    __int128 v107 = 0u;
    __int128 v108 = 0u;
    __int128 v109 = 0u;
    __int128 v110 = 0u;
    uint64_t v17 = sub_10013163C((uint64_t)&OBJC_CLASS___NRDLocalDevice);
    id v18 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v17,  "countByEnumeratingWithState:objects:count:",  &v107,  v124,  16LL);
    if (v18)
    {
      id v19 = v18;
      uint64_t v102 = v5;
      uint64_t v20 = *(void *)v108;
LABEL_22:
      uint64_t v21 = 0LL;
      while (1)
      {
        if (*(void *)v108 != v20) {
          objc_enumerationMutation(v17);
        }
        char v22 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(*((void *)&v107 + 1) + 8 * v21));
        uint64_t v23 = v22;
        if (v22) {
          unsigned int v24 = (void *)*((void *)v22 + 16);
        }
        else {
          unsigned int v24 = 0LL;
        }
        id v25 = v24;
        id v26 = [v25 bluetoothEndpointType];

        if (v26 == (id)1)
        {

          uint64_t v5 = v102;
          goto LABEL_55;
        }

        unsigned __int8 v27 = v23 ? (void *)*((void *)v23 + 16) : 0LL;
        id v28 = v27;
        id v29 = [v28 bluetoothEndpointType];

        if (v29 == (id)2) {
          break;
        }
        if (v19 == (id)++v21)
        {
          id v30 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v17,  "countByEnumeratingWithState:objects:count:",  &v107,  v124,  16LL);
          id v19 = v30;
          if (!v30)
          {
            unint64_t v12 = @"Client";
            goto LABEL_72;
          }

          goto LABEL_22;
        }
      }

      unint64_t v12 = @"Server";
LABEL_72:
      uint64_t v13 = v29 == (id)2;

      uint64_t v5 = v102;
      if (a2 == 2)
      {
LABEL_56:
        if (a3)
        {
          uint64_t v37 = sub_10002B4A4(v5, 2LL, 1);
          id v15 = v37;
          if (!v37)
          {
            int state = 0;
            goto LABEL_127;
          }

          int state = v37->_state;
          if (state != 1)
          {
            if (state == 2)
            {
              if (qword_1001DC728 != -1) {
                dispatch_once(&qword_1001DC728, &stru_1001AE510);
              }
              goto LABEL_70;
            }

LABEL_127:
            if ([*(id *)(v5 + 48) state] != (id)5) {
              goto LABEL_167;
            }
            if (state == 3)
            {
              id v64 = sub_100024E28();
              int IsLevelEnabled = _NRLogIsLevelEnabled(v64, 0LL);

              if (IsLevelEnabled)
              {
LABEL_139:
                id v70 = sub_100024E28();
                unint64_t v71 = v70;
                goto LABEL_158;
              }

LABEL_165:
              if (v15) {
                v15->_flags |= 2u;
              }
              goto LABEL_167;
            }

            if (v15)
            {
              if (-[NSMutableSet count](v15->_connectedPipes, "count"))
              {
LABEL_133:
                id v66 = sub_100024E28();
                int v67 = _NRLogIsLevelEnabled(v66, 0LL);

                if (!v67) {
                  goto LABEL_165;
                }
                goto LABEL_143;
              }
            }

            else if ([0 count])
            {
              goto LABEL_133;
            }

            if (v15)
            {
              v15->_int state = 1;
              v15->_flags &= ~2u;
            }

            [(id)v5 reportEvent:4201, @"%s %s %@", "High", "p2pPipe", v12 detailsFormat];
            uint64_t v94 = *(void **)(v5 + 48);
            v118[0] = CBScalablePipeOptionTransport;
            id v84 = v94;
            NSUInteger v95 = +[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", sub_10002B54C());
            int v86 = (void *)objc_claimAutoreleasedReturnValue(v95);
            v118[1] = CBScalablePipeOptionStayConnectedWhenIdle;
            v119[0] = v86;
            v119[1] = &__kCFBooleanTrue;
            int v87 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v119,  v118,  2LL));
            uint64_t v88 = @"com.apple.terminusLink.urgent.p2p";
LABEL_187:
            int v91 = v84;
            uint64_t v92 = v13;
            uint64_t v93 = 2LL;
LABEL_197:
            [v91 registerEndpoint:v88 type:v92 priority:v93 options:v87];

            goto LABEL_167;
          }

          if (qword_1001DC728 != -1) {
            dispatch_once(&qword_1001DC728, &stru_1001AE510);
          }
LABEL_95:
          id v47 = sub_100024E28();
          __int128 v42 = v47;
LABEL_106:
          _NRLogWithArgs(v47, 1LL, "%s%.30s:%-4d %s %s already registering");
LABEL_107:

          goto LABEL_167;
        }

        char v39 = sub_10002B4A4(v5, 2LL, 0);
        id v15 = v39;
        if (v39)
        {
          int v40 = v39->_state;
          if (v40 == 1)
          {
            if (qword_1001DC728 != -1) {
              dispatch_once(&qword_1001DC728, &stru_1001AE510);
            }
            goto LABEL_95;
          }

          if (v40 == 2)
          {
            if (qword_1001DC728 != -1) {
              dispatch_once(&qword_1001DC728, &stru_1001AE510);
            }
LABEL_70:
            id v41 = sub_100024E28();
            __int128 v42 = v41;
LABEL_101:
            _NRLogWithArgs(v41, 1LL, "%s%.30s:%-4d %s %s already registered");
            goto LABEL_107;
          }
        }

        else
        {
          int v40 = 0;
        }

        if ([*(id *)(v5 + 48) state] != (id)5) {
          goto LABEL_167;
        }
        if (v40 == 3)
        {
          id v68 = sub_100024E28();
          int v69 = _NRLogIsLevelEnabled(v68, 0LL);

          if (v69) {
            goto LABEL_139;
          }
          goto LABEL_165;
        }

        if (v15)
        {
          if (-[NSMutableSet count](v15->_connectedPipes, "count")) {
            goto LABEL_142;
          }
LABEL_184:
          if (v15)
          {
            v15->_int state = 1;
            v15->_flags &= ~2u;
          }

          [(id)v5 reportEvent:4201, @"%s %s %@", "High", "pipe", v12 detailsFormat];
          id v96 = *(void **)(v5 + 48);
          v116[0] = CBScalablePipeOptionTransport;
          id v84 = v96;
          unint64_t v97 = +[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", sub_10002B54C());
          int v86 = (void *)objc_claimAutoreleasedReturnValue(v97);
          v116[1] = CBScalablePipeOptionStayConnectedWhenIdle;
          v117[0] = v86;
          v117[1] = &__kCFBooleanTrue;
          int v87 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v117,  v116,  2LL));
          uint64_t v88 = @"com.apple.terminusLink.urgent";
          goto LABEL_187;
        }

        if (![0 count]) {
          goto LABEL_184;
        }
LABEL_142:
        id v72 = sub_100024E28();
        int v73 = _NRLogIsLevelEnabled(v72, 0LL);

        if (!v73) {
          goto LABEL_165;
        }
LABEL_143:
        id v74 = sub_100024E28();
        unint64_t v71 = v74;
LABEL_163:
        _NRLogWithArgs(v74, 0LL, "%s%.30s:%-4d Deferring registering %s priority %s as its pipes are still connected");
LABEL_164:

        goto LABEL_165;
      }
    }

    else
    {
LABEL_55:

      uint64_t v13 = 0LL;
      unint64_t v12 = @"Client";
      if (a2 == 2) {
        goto LABEL_56;
      }
    }
  }

  if (a2 == 1)
  {
    if (a3)
    {
      uint64_t v14 = sub_10002B4A4(v5, 1LL, 1);
      id v15 = v14;
      if (v14)
      {
        int v16 = v14->_state;
        if (v16 == 1)
        {
          if (qword_1001DC728 != -1) {
            dispatch_once(&qword_1001DC728, &stru_1001AE510);
          }
          goto LABEL_95;
        }

        if (v16 == 2)
        {
          if (qword_1001DC728 != -1) {
            dispatch_once(&qword_1001DC728, &stru_1001AE510);
          }
          goto LABEL_70;
        }
      }

      else
      {
        int v16 = 0;
      }

      if ([*(id *)(v5 + 48) state] != (id)5) {
        goto LABEL_167;
      }
      if (v16 == 3)
      {
        id v56 = sub_100024E28();
        int v57 = _NRLogIsLevelEnabled(v56, 0LL);

        if (v57) {
          goto LABEL_139;
        }
        goto LABEL_165;
      }

      if (v15)
      {
        if (-[NSMutableSet count](v15->_connectedPipes, "count")) {
          goto LABEL_115;
        }
      }

      else if ([0 count])
      {
LABEL_115:
        id v58 = sub_100024E28();
        int v59 = _NRLogIsLevelEnabled(v58, 0LL);

        if (!v59) {
          goto LABEL_165;
        }
        goto LABEL_143;
      }

      if (v15)
      {
        v15->_int state = 1;
        v15->_flags &= ~2u;
      }

      [(id)v5 reportEvent:4201, @"%s %s %@", "Medium", "p2pPipe", v12 detailsFormat];
      NSUInteger v83 = *(void **)(v5 + 48);
      v122[0] = CBScalablePipeOptionTransport;
      id v84 = v83;
      int v85 = +[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", sub_10002B54C());
      int v86 = (void *)objc_claimAutoreleasedReturnValue(v85);
      v122[1] = CBScalablePipeOptionStayConnectedWhenIdle;
      v123[0] = v86;
      v123[1] = &__kCFBooleanTrue;
      int v87 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v123,  v122,  2LL));
      uint64_t v88 = @"com.apple.terminusLink.p2p";
LABEL_178:
      int v91 = v84;
      uint64_t v92 = v13;
      uint64_t v93 = 1LL;
      goto LABEL_197;
    }

    unsigned int v35 = sub_10002B4A4(v5, 1LL, 0);
    id v15 = v35;
    if (v35)
    {
      int v36 = v35->_state;
      if (v36 == 1)
      {
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        goto LABEL_95;
      }

      if (v36 == 2)
      {
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        goto LABEL_70;
      }
    }

    else
    {
      int v36 = 0;
    }

    if ([*(id *)(v5 + 48) state] != (id)5) {
      goto LABEL_167;
    }
    if (v36 == 3)
    {
      id v60 = sub_100024E28();
      int v61 = _NRLogIsLevelEnabled(v60, 0LL);

      if (v61) {
        goto LABEL_139;
      }
      goto LABEL_165;
    }

    if (v15)
    {
      if (-[NSMutableSet count](v15->_connectedPipes, "count")) {
        goto LABEL_124;
      }
    }

    else if ([0 count])
    {
LABEL_124:
      id v62 = sub_100024E28();
      int v63 = _NRLogIsLevelEnabled(v62, 0LL);

      if (!v63) {
        goto LABEL_165;
      }
      goto LABEL_143;
    }

    if (v15)
    {
      v15->_int state = 1;
      v15->_flags &= ~2u;
    }

    [(id)v5 reportEvent:4201, @"%s %s %@", "Medium", "pipe", v12 detailsFormat];
    uint64_t v89 = *(void **)(v5 + 48);
    v120[0] = CBScalablePipeOptionTransport;
    id v84 = v89;
    id v90 = +[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", sub_10002B54C());
    int v86 = (void *)objc_claimAutoreleasedReturnValue(v90);
    v120[1] = CBScalablePipeOptionStayConnectedWhenIdle;
    v121[0] = v86;
    v121[1] = &__kCFBooleanTrue;
    int v87 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v121,  v120,  2LL));
    uint64_t v88 = @"com.apple.terminusLink";
    goto LABEL_178;
  }

  if (a2 != 3) {
    goto LABEL_168;
  }
  __int128 v105 = 0u;
  __int128 v106 = 0u;
  __int128 v103 = 0u;
  __int128 v104 = 0u;
  id v15 = (NRCBScalablePipeRegistrationState *)*(id *)(v5 + 40);
  id v31 = -[NRCBScalablePipeRegistrationState countByEnumeratingWithState:objects:count:]( v15,  "countByEnumeratingWithState:objects:count:",  &v103,  v115,  16LL);
  if (!v31) {
    goto LABEL_167;
  }
  id v32 = v31;
  uint64_t v33 = *(void *)v104;
  while (2)
  {
    for (uint64_t i = 0LL; i != v32; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v104 != v33) {
        objc_enumerationMutation(v15);
      }
      if ([*(id *)(*((void *)&v103 + 1) + 8 * (void)i) state] == 8)
      {

        if (a3)
        {
          __int128 v43 = sub_10002B4A4(v5, 3LL, 1);
          id v15 = v43;
          if (!v43)
          {
            int v44 = 0;
LABEL_145:
            if ([*(id *)(v5 + 48) state] != (id)5) {
              goto LABEL_167;
            }
            if (v44 == 3)
            {
              id v75 = sub_100024E28();
              int v76 = _NRLogIsLevelEnabled(v75, 0LL);

              if (!v76) {
                goto LABEL_165;
              }
LABEL_157:
              id v70 = sub_100024E28();
              unint64_t v71 = v70;
LABEL_158:
              _NRLogWithArgs( v70,  0LL,  "%s%.30s:%-4d Deferring registering %s priority %s as the pipe is being unregistered");
              goto LABEL_164;
            }

            if (v15)
            {
              if (-[NSMutableSet count](v15->_connectedPipes, "count")) {
                goto LABEL_151;
              }
            }

            else if ([0 count])
            {
LABEL_151:
              id v77 = sub_100024E28();
              int v78 = _NRLogIsLevelEnabled(v77, 0LL);

              if (!v78) {
                goto LABEL_165;
              }
LABEL_162:
              id v74 = sub_100024E28();
              unint64_t v71 = v74;
              goto LABEL_163;
            }

            if (v15)
            {
              v15->_int state = 1;
              v15->_flags &= ~2u;
            }

            [(id)v5 reportEvent:4201, @"%s %s %@", "Isochronous", "p2pPipe", v12 detailsFormat];
            uint64_t v98 = *(void **)(v5 + 48);
            v113[0] = CBScalablePipeOptionTransport;
            id v84 = v98;
            uint64_t v99 = +[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", sub_10002B54C());
            int v86 = (void *)objc_claimAutoreleasedReturnValue(v99);
            v113[1] = CBScalablePipeOptionStayConnectedWhenIdle;
            v114[0] = v86;
            v114[1] = &__kCFBooleanTrue;
            int v87 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v114,  v113,  2LL));
            uint64_t v88 = @"com.apple.terminusLink.datagram.p2p";
LABEL_196:
            int v91 = v84;
            uint64_t v92 = v13;
            uint64_t v93 = 3LL;
            goto LABEL_197;
          }

          int v44 = v43->_state;
          if (v44 != 1)
          {
            if (v44 == 2)
            {
              id v45 = sub_100024E28();
              int v46 = _NRLogIsLevelEnabled(v45, 1LL);

              if (!v46) {
                goto LABEL_167;
              }
LABEL_100:
              id v41 = sub_100024E28();
              __int128 v42 = v41;
              goto LABEL_101;
            }

            goto LABEL_145;
          }

          id v52 = sub_100024E28();
          int v53 = _NRLogIsLevelEnabled(v52, 1LL);

          if (!v53) {
            goto LABEL_167;
          }
LABEL_105:
          id v47 = sub_100024E28();
          __int128 v42 = v47;
          goto LABEL_106;
        }

        __int128 v48 = sub_10002B4A4(v5, 3LL, 0);
        id v15 = v48;
        if (v48)
        {
          int v49 = v48->_state;
          if (v49 == 1)
          {
            id v54 = sub_100024E28();
            int v55 = _NRLogIsLevelEnabled(v54, 1LL);

            if (!v55) {
              goto LABEL_167;
            }
            goto LABEL_105;
          }

          if (v49 == 2)
          {
            id v50 = sub_100024E28();
            int v51 = _NRLogIsLevelEnabled(v50, 1LL);

            if (!v51) {
              goto LABEL_167;
            }
            goto LABEL_100;
          }
        }

        else
        {
          int v49 = 0;
        }

        if ([*(id *)(v5 + 48) state] != (id)5) {
          goto LABEL_167;
        }
        if (v49 == 3)
        {
          id v79 = sub_100024E28();
          int v80 = _NRLogIsLevelEnabled(v79, 0LL);

          if (!v80) {
            goto LABEL_165;
          }
          goto LABEL_157;
        }

        if (v15)
        {
          if (-[NSMutableSet count](v15->_connectedPipes, "count")) {
            goto LABEL_161;
          }
        }

        else if ([0 count])
        {
LABEL_161:
          id v81 = sub_100024E28();
          int v82 = _NRLogIsLevelEnabled(v81, 0LL);

          if (!v82) {
            goto LABEL_165;
          }
          goto LABEL_162;
        }

        if (v15)
        {
          v15->_int state = 1;
          v15->_flags &= ~2u;
        }

        [(id)v5 reportEvent:4201, @"%s %s %@", "Isochronous", "pipe", v12 detailsFormat];
        int v100 = *(void **)(v5 + 48);
        v111[0] = CBScalablePipeOptionTransport;
        id v84 = v100;
        id v101 = +[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", sub_10002B54C());
        int v86 = (void *)objc_claimAutoreleasedReturnValue(v101);
        v111[1] = CBScalablePipeOptionStayConnectedWhenIdle;
        v112[0] = v86;
        v112[1] = &__kCFBooleanTrue;
        int v87 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v112,  v111,  2LL));
        uint64_t v88 = @"com.apple.terminusLink.datagram";
        goto LABEL_196;
      }
    }

    id v32 = -[NRCBScalablePipeRegistrationState countByEnumeratingWithState:objects:count:]( v15,  "countByEnumeratingWithState:objects:count:",  &v103,  v115,  16LL);
    if (v32) {
      continue;
    }
    break;
  }

LABEL_167:
LABEL_168:
}

NRCBScalablePipeRegistrationState *sub_10002B4A4(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = &OBJC_IVAR___NRLinkManagerBluetooth__pipeRegistrations;
  if (a3) {
    uint64_t v4 = &OBJC_IVAR___NRLinkManagerBluetooth__p2pPipeRegistrations;
  }
  id v5 = *(id *)(a1 + *v4);
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", a2));
  id v7 = (NRCBScalablePipeRegistrationState *)objc_claimAutoreleasedReturnValue([v5 objectForKeyedSubscript:v6]);
  if (!v7)
  {
    id v7 = objc_alloc_init(&OBJC_CLASS___NRCBScalablePipeRegistrationState);
    [v5 setObject:v7 forKeyedSubscript:v6];
  }

  return v7;
}

uint64_t sub_10002B54C()
{
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  v0 = (id)qword_1001DC870;
  if (v0)
  {
    if (v0[10]) {
      uint64_t v1 = 2LL;
    }
    else {
      uint64_t v1 = 1LL;
    }
  }

  else
  {
    uint64_t v1 = 1LL;
  }

  return v1;
}

void sub_10002B5C8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  int v3 = WeakRetained;
  if (WeakRetained) {
    id WeakRetained = (void *)WeakRetained[2];
  }
  unsigned int v4 = [WeakRetained containsObject:*(void *)(a1 + 32)];

  if (v4)
  {
    id v5 = *(id **)(a1 + 40);
    id v6 = *(id *)(a1 + 32);
    id v7 = v6;
    if (!v5)
    {
LABEL_97:

      return;
    }

    if (!v6)
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      id v76 = (id)qword_1001DC720;
      int IsLevelEnabled = _NRLogIsLevelEnabled(v76, 17LL);

      if (!IsLevelEnabled) {
        goto LABEL_97;
      }
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      id v13 = (id)qword_1001DC720;
      _NRLogWithArgs(v13, 17LL, "%s called with null pipe", "-[NRLinkManagerBluetooth pipeisAvailable:]");
      goto LABEL_96;
    }

    id v8 = (dispatch_queue_s *)v5[3];
    dispatch_assert_queue_V2(v8);

    unint64_t v9 = (void *)objc_claimAutoreleasedReturnValue([v7 peer]);
    unsigned int v10 = (void *)objc_claimAutoreleasedReturnValue([v9 identifier]);

    id v11 = [v7 priority];
    id v12 = [v7 priority];
    id v13 = v10;
    objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
    uint64_t v14 = sub_10012E648((uint64_t)&OBJC_CLASS___NRDLocalDevice, v13);

    if (!v14 || !v14[9])
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      id v78 = (id)qword_1001DC720;
      int v79 = _NRLogIsLevelEnabled(v78, 16LL);

      if (v79)
      {
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        id v80 = (id)qword_1001DC720;
        _NRLogWithArgs( v80,  16LL,  "%s%.30s:%-4d Not creating link for disabled device %@ with pipe %@",  "",  "-[NRLinkManagerBluetooth pipeisAvailable:]",  911LL,  v14,  v7);
      }

      [v5 reportEvent:3101, @"%@ is disabled for pipe %@", v14, v7 detailsFormat];
      goto LABEL_95;
    }

    id v15 = *((id *)v14 + 4);
    unsigned __int8 v16 = [v5 shouldCreateLinkForNRUUID:v15];

    if ((v16 & 1) == 0)
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC720, 16LL))
      {
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        _NRLogWithArgs( qword_1001DC720,  16LL,  "%s%.30s:%-4d Not creating link for unsupported device %@ with pipe %@",  "",  "-[NRLinkManagerBluetooth pipeisAvailable:]",  916LL,  v14,  v7);
      }

      [v5 reportEvent:3101, @"%@ is unsupported for pipe %@", v14, v7 detailsFormat];
      goto LABEL_95;
    }

    int v85 = v7;
    if (v11 == (id)3)
    {
      __int128 v88 = 0u;
      __int128 v89 = 0u;
      __int128 v86 = 0u;
      __int128 v87 = 0u;
      id v17 = v5[5];
      id v18 = [v17 countByEnumeratingWithState:&v86 objects:v90 count:16];
      if (v18)
      {
        id v19 = v18;
        uint64_t v20 = *(void *)v87;
LABEL_20:
        uint64_t v21 = 0LL;
        while (1)
        {
          if (*(void *)v87 != v20) {
            objc_enumerationMutation(v17);
          }
          uint64_t v22 = *(void *)(*((void *)&v86 + 1) + 8 * v21);
          if (v22) {
            uint64_t v23 = *(void **)(v22 + 327);
          }
          else {
            uint64_t v23 = 0LL;
          }
          id v24 = v23;
          if ([v24 isEqual:v13])
          {
            unsigned int v25 = [(id)v22 state];

            if (v25 != 255)
            {
              id v7 = v85;
              sub_10007FCF8(v22, v85);

              goto LABEL_95;
            }
          }

          else
          {
          }

          if (v19 == (id)++v21)
          {
            id v19 = [v17 countByEnumeratingWithState:&v86 objects:v90 count:16];
            if (!v19) {
              break;
            }
            goto LABEL_20;
          }
        }
      }

LABEL_91:
    v63->_int state = 1;
    v63->_timeOfConnect = mach_continuous_time();
    goto LABEL_92;
  }

BOOL sub_10002C0D4(uint64_t a1)
{
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
  __int128 v42 = 0u;
  __int128 v43 = 0u;
  __int128 v44 = 0u;
  __int128 v45 = 0u;
  id v3 = *(id *)(a1 + 80);
  uint64_t v4 = objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:&off_1001BC550]);
  id v5 = (void *)v4;
  if (v4) {
    id v6 = *(void **)(v4 + 16);
  }
  else {
    id v6 = 0LL;
  }
  id v7 = v6;

  id v8 = [v7 countByEnumeratingWithState:&v42 objects:v48 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v43;
    do
    {
      for (uint64_t i = 0LL; i != v9; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v43 != v10) {
          objc_enumerationMutation(v7);
        }
        id v12 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v42 + 1) + 8 * (void)i) peer]);
        id v13 = (void *)objc_claimAutoreleasedReturnValue([v12 identifier]);
        -[NSMutableSet addObject:](v2, "addObject:", v13);
      }

      id v9 = [v7 countByEnumeratingWithState:&v42 objects:v48 count:16];
    }

    while (v9);
  }

  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  id v14 = *(id *)(a1 + 88);
  uint64_t v15 = objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:&off_1001BC550]);
  unsigned __int8 v16 = (void *)v15;
  if (v15) {
    id v17 = *(void **)(v15 + 16);
  }
  else {
    id v17 = 0LL;
  }
  id v18 = v17;

  id v19 = [v18 countByEnumeratingWithState:&v38 objects:v47 count:16];
  if (v19)
  {
    id v20 = v19;
    uint64_t v21 = *(void *)v39;
    do
    {
      for (j = 0LL; j != v20; j = (char *)j + 1)
      {
        if (*(void *)v39 != v21) {
          objc_enumerationMutation(v18);
        }
        uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v38 + 1) + 8 * (void)j) peer]);
        id v24 = (void *)objc_claimAutoreleasedReturnValue([v23 identifier]);
        -[NSMutableSet addObject:](v2, "addObject:", v24);
      }

      id v20 = [v18 countByEnumeratingWithState:&v38 objects:v47 count:16];
    }

    while (v20);
  }

  unsigned int v25 = sub_100131C00((uint64_t)&OBJC_CLASS___NRDLocalDevice);
  id v26 = -[NSMutableArray mutableCopy](v25, "mutableCopy");
  __int128 v34 = 0u;
  __int128 v35 = 0u;
  __int128 v36 = 0u;
  __int128 v37 = 0u;
  id v27 = v2;
  id v28 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v27,  "countByEnumeratingWithState:objects:count:",  &v34,  v46,  16LL);
  if (v28)
  {
    id v29 = v28;
    uint64_t v30 = *(void *)v35;
    do
    {
      for (k = 0LL; k != v29; k = (char *)k + 1)
      {
        if (*(void *)v35 != v30) {
          objc_enumerationMutation(v27);
        }
        objc_msgSend(v26, "removeObject:", *(void *)(*((void *)&v34 + 1) + 8 * (void)k), (void)v34);
      }

      id v29 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v27,  "countByEnumeratingWithState:objects:count:",  &v34,  v46,  16LL);
    }

    while (v29);
  }

  id v32 = [v26 count];
  return v32 != 0LL;
}

id *sub_10002C424(id *result)
{
  if (result[7])
  {
    uint64_t v1 = result;
    switch(*((_BYTE *)result + 32))
    {
      case 0:
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        CFTypeRef result = (id *)_NRLogIsLevelEnabled(qword_1001DC720, 0LL);
        if ((_DWORD)result)
        {
          if (qword_1001DC728 != -1) {
            dispatch_once(&qword_1001DC728, &stru_1001AE510);
          }
          CFTypeRef result = (id *)_NRLogWithArgs( qword_1001DC720,  0LL,  "%s%.30s:%-4d Ignoring stop BT advertisement request, device is NOT advertising");
        }

        break;
      case 1:
      case 4:
        [result reportEvent:3504];
        CFTypeRef result = (id *)[v1[7] stopAdvertising];
        goto LABEL_4;
      case 2:
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        CFTypeRef result = (id *)_NRLogIsLevelEnabled(qword_1001DC720, 0LL);
        if ((_DWORD)result)
        {
          if (qword_1001DC728 != -1) {
            dispatch_once(&qword_1001DC728, &stru_1001AE510);
          }
          CFTypeRef result = (id *)_NRLogWithArgs( qword_1001DC720,  0LL,  "%s%.30s:%-4d Ignoring stop BT advertisement request, already stopping");
        }

        break;
      default:
LABEL_4:
        *((_BYTE *)v1 + 32) = 2;
        *((_BYTE *)v1 + 33) = 0;
        break;
    }
  }

  return result;
}

void sub_10002C5F0(uint64_t a1, uint64_t a2, int a3)
{
  if (a1) {
    id v6 = *(void **)(a1 + 24);
  }
  else {
    id v6 = 0LL;
  }
  id v7 = v6;
  dispatch_assert_queue_V2(v7);

  switch(a2)
  {
    case 3LL:
      if (a3)
      {
        id v20 = *(id *)(a1 + 88);
        uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", 3LL));
        __int128 v34 = (unsigned __int8 *)objc_claimAutoreleasedReturnValue([v20 objectForKeyedSubscript:v21]);

        unsigned __int8 v16 = v34;
        if (!v34) {
          goto LABEL_39;
        }
        goto LABEL_21;
      }

      id v32 = *(id *)(a1 + 80);
      unsigned int v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", 3LL));
      __int128 v34 = (unsigned __int8 *)objc_claimAutoreleasedReturnValue([v32 objectForKeyedSubscript:v33]);

      unsigned __int8 v16 = v34;
      if (!v34) {
        goto LABEL_39;
      }
LABEL_36:
      v16[9] &= ~2u;
      if (v16[8] - 3 >= 0xFFFFFFFE)
      {
        objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4206, @"%s %s", "Isochronous", "pipe");
        id v19 = @"com.apple.terminusLink.datagram";
        goto LABEL_38;
      }

LABEL_39:
      return;
    case 2LL:
      if (a3)
      {
        id v17 = *(id *)(a1 + 88);
        id v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", 2LL));
        __int128 v34 = (unsigned __int8 *)objc_claimAutoreleasedReturnValue([v17 objectForKeyedSubscript:v18]);

        unsigned __int8 v16 = v34;
        if (!v34) {
          goto LABEL_39;
        }
        v34[9] &= ~2u;
        objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4206, @"%s %s", "High", "p2pPipe");
        id v19 = @"com.apple.terminusLink.urgent.p2p";
      }

      else
      {
        id v22 = *(id *)(a1 + 80);
        uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", 2LL));
        __int128 v34 = (unsigned __int8 *)objc_claimAutoreleasedReturnValue([v22 objectForKeyedSubscript:v23]);

        unsigned __int8 v16 = v34;
        if (!v34) {
          goto LABEL_39;
        }
        v34[9] &= ~2u;
        objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4206, @"%s %s", "High", "pipe");
        id v19 = @"com.apple.terminusLink.urgent";
      }

      goto LABEL_38;
    case 1LL:
      if (a3)
      {
        id v8 = *(id *)(a1 + 88);
        id v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", 1LL));
        uint64_t v10 = (_BYTE *)objc_claimAutoreleasedReturnValue([v8 objectForKeyedSubscript:v9]);

        if (v10)
        {
          v10[9] &= ~2u;
          if (v10[8] - 3 >= 0xFFFFFFFE)
          {
            objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4206, @"%s %s", "Medium", "p2pPipe");
            [*(id *)(a1 + 48) unregisterEndpoint:@"com.apple.terminusLink.p2p"];
            v10[8] = 3;
          }
        }

        id v11 = *(id *)(a1 + 88);
        id v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", 2LL));
        id v13 = (_BYTE *)objc_claimAutoreleasedReturnValue([v11 objectForKeyedSubscript:v12]);

        if (v13)
        {
          v13[9] &= ~2u;
          if (v13[8] - 3 >= 0xFFFFFFFE)
          {
            objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4206, @"%s %s", "High", "p2pPipe");
            [*(id *)(a1 + 48) unregisterEndpoint:@"com.apple.terminusLink.urgent.p2p"];
            v13[8] = 3;
          }
        }

        id v14 = *(id *)(a1 + 88);
        uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", 3LL));
        __int128 v34 = (unsigned __int8 *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:v15]);

        unsigned __int8 v16 = v34;
        if (!v34) {
          goto LABEL_39;
        }
LABEL_21:
        v16[9] &= ~2u;
        if (v16[8] - 3 >= 0xFFFFFFFE)
        {
          objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4206, @"%s %s", "Isochronous", "p2pPipe");
          id v19 = @"com.apple.terminusLink.datagram.p2p";
LABEL_38:
          [*(id *)(a1 + 48) unregisterEndpoint:v19];
          unsigned __int8 v16 = v34;
          v34[8] = 3;
          goto LABEL_39;
        }

        goto LABEL_39;
      }

      id v24 = *(id *)(a1 + 80);
      unsigned int v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", 1LL));
      id v26 = (_BYTE *)objc_claimAutoreleasedReturnValue([v24 objectForKeyedSubscript:v25]);

      if (v26)
      {
        v26[9] &= ~2u;
        if (v26[8] - 3 >= 0xFFFFFFFE)
        {
          objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4206, @"%s %s", "Medium", "pipe");
          [*(id *)(a1 + 48) unregisterEndpoint:@"com.apple.terminusLink"];
          v26[8] = 3;
        }
      }

      id v27 = *(id *)(a1 + 80);
      id v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", 2LL));
      id v29 = (_BYTE *)objc_claimAutoreleasedReturnValue([v27 objectForKeyedSubscript:v28]);

      if (v29)
      {
        v29[9] &= ~2u;
        if (v29[8] - 3 >= 0xFFFFFFFE)
        {
          objc_msgSend((id)a1, "reportEvent:detailsFormat:", 4206, @"%s %s", "High", "pipe");
          [*(id *)(a1 + 48) unregisterEndpoint:@"com.apple.terminusLink.urgent"];
          v29[8] = 3;
        }
      }

      id v30 = *(id *)(a1 + 80);
      id v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInteger:](&OBJC_CLASS___NSNumber, "numberWithInteger:", 3LL));
      __int128 v34 = (unsigned __int8 *)objc_claimAutoreleasedReturnValue([v30 objectForKeyedSubscript:v31]);

      unsigned __int8 v16 = v34;
      if (!v34) {
        goto LABEL_39;
      }
      goto LABEL_36;
  }

      goto LABEL_40;
    }

    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 17LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      _NRLogWithArgs(qword_1001DC770, 17LL, "Missing file name key failed");
    }
  }

  uint64_t v15 = -2005LL;
LABEL_49:
  close(v5);

  return v15;
}

  -[NSMutableArray addObject:](v8, "addObject:", @"ServiceClassVideo");
  if ((reason & 0x40000) == 0)
  {
LABEL_14:
    if ((reason & 0x80000) == 0) {
      goto LABEL_15;
    }
    goto LABEL_41;
  }

  -[NSMutableArray addObject:](v3, "addObject:", @"Plgd");
  if ((a1 & 0x2000000) == 0)
  {
LABEL_14:
    if ((a1 & 0x4000000) == 0) {
      goto LABEL_15;
    }
    goto LABEL_41;
  }

  return a1;
}

      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      goto LABEL_19;
    }
}

void sub_10002CC88(id *a1, unint64_t a2)
{
  if (a1)
  {
    uint64_t v4 = (dispatch_queue_s *)a1[3];
    dispatch_assert_queue_V2(v4);

    if (a2)
    {
      if (a2 == 5 && sub_100131D60((uint64_t)&OBJC_CLASS___NRDLocalDevice))
      {
        sub_10002A260((uint64_t)a1, 1LL, 0);
        sub_10002A260((uint64_t)a1, 1LL, 1);
      }

      else
      {
        sub_10002C5F0((uint64_t)a1, 1LL, 0);
        sub_10002C5F0((uint64_t)a1, 1LL, 1);
        id v5 = [a1[5] copy];
        __int128 v27 = 0u;
        __int128 v28 = 0u;
        __int128 v29 = 0u;
        __int128 v30 = 0u;
        id obj = v5;
        id v6 = [obj countByEnumeratingWithState:&v27 objects:v31 count:16];
        if (v6)
        {
          id v7 = v6;
          uint64_t v8 = *(void *)v28;
          do
          {
            for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v28 != v8) {
                objc_enumerationMutation(obj);
              }
              id v12 = *(void **)(*((void *)&v27 + 1) + 8LL * (void)i);
              [v12 setNoTransport:1];
              id v13 = (void *)objc_claimAutoreleasedReturnValue([v12 nrUUID]);
              if (a2 < 6) {
                uint64_t v10 = (NSString *)*(&off_1001AE570 + a2);
              }
              else {
                uint64_t v10 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"UnknownState(%lld)",  a2);
              }
              [v12 cancelWithReason:@"pipe manager state %@", v10];

              id WeakRetained = objc_loadWeakRetained(a1 + 15);
              [WeakRetained pipeDidConnectForNRUUID:0 nrUUID:v13];

              sub_100029C38((uint64_t)a1, v13);
            }

            id v7 = [obj countByEnumeratingWithState:&v27 objects:v31 count:16];
          }

          while (v7);
        }

        if (a2 == 5)
        {
          id v14 = a1[10];
          uint64_t v15 = (_BYTE *)objc_claimAutoreleasedReturnValue([v14 objectForKeyedSubscript:&off_1001BC550]);
          if (v15) {
            v15[9] &= ~8u;
          }

          id v16 = a1[10];
          id v17 = (_BYTE *)objc_claimAutoreleasedReturnValue([v16 objectForKeyedSubscript:&off_1001BC568]);
          if (v17) {
            v17[9] &= ~8u;
          }

          id v18 = a1[10];
          id v19 = (_BYTE *)objc_claimAutoreleasedReturnValue([v18 objectForKeyedSubscript:&off_1001BC580]);
          if (v19) {
            v19[9] &= ~8u;
          }

          id v20 = a1[11];
          uint64_t v21 = (_BYTE *)objc_claimAutoreleasedReturnValue([v20 objectForKeyedSubscript:&off_1001BC550]);
          if (v21) {
            v21[9] &= ~8u;
          }

          id v22 = a1[11];
          uint64_t v23 = (_BYTE *)objc_claimAutoreleasedReturnValue([v22 objectForKeyedSubscript:&off_1001BC568]);
          if (v23) {
            v23[9] &= ~8u;
          }

          id v24 = a1[11];
          unsigned int v25 = (_BYTE *)objc_claimAutoreleasedReturnValue([v24 objectForKeyedSubscript:&off_1001BC580]);
          if (v25) {
            v25[9] &= ~8u;
          }
        }

        else
        {
          if (qword_1001DC728 != -1) {
            dispatch_once(&qword_1001DC728, &stru_1001AE510);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC720, 0LL))
          {
            if (qword_1001DC728 != -1) {
              dispatch_once(&qword_1001DC728, &stru_1001AE510);
            }
            _NRLogWithArgs( qword_1001DC720,  0LL,  "%s%.30s:%-4d Resetting state",  "",  "-[NRLinkManagerBluetooth handleSPMStateChange:]",  1530);
          }

          [a1[10] removeAllObjects];
          [a1[11] removeAllObjects];
        }
      }
    }
  }

void sub_10002D104(void *a1, unint64_t a2)
{
  if (a1[7])
  {
    if (a2 >= 6) {
      id v3 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"UnknownState(%lld)",  a2);
    }
    else {
      id v3 = (NSString *)*(&off_1001AE570 + a2);
    }
    [a1 reportEvent:3500 details:v3];

    uint64_t v4 = (void *)a1[7];
    if (v4 && [v4 state] == (id)5 && sub_100131D60((uint64_t)NRDLocalDevice))
    {
      if (sub_10002C0D4((uint64_t)a1))
      {
        sub_100029E6C((uint64_t)a1);
        return;
      }

      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC720, 0LL))
      {
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        _NRLogWithArgs( qword_1001DC720,  0LL,  "%s%.30s:%-4d Not starting BT advertisements as all enabled devices are connected",  "",  "-[NRLinkManagerBluetooth handlePMStateChange:]",  1790);
      }
    }

    sub_10002C424((id *)a1);
  }

void sub_10002D284(void *a1)
{
  uint64_t v2 = a1[4];
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
  }
  else {
    id WeakRetained = 0LL;
  }
  id v4 = WeakRetained;
  [WeakRetained linkDidReceiveData:a1[5] data:a1[6]];
}

void sub_10002D2D0(id *a1, void *a2, void *a3)
{
  unint64_t v29 = a2;
  id v5 = a3;
  if (a1)
  {
    uint64_t v6 = objc_claimAutoreleasedReturnValue([a1[14] objectForKeyedSubscript:v5]);
    if (v29 | v6 && ![(id)v29 isEqual:v6])
    {
      [a1[14] setObject:v29 forKeyedSubscript:v5];
      id v7 = (void *)objc_claimAutoreleasedReturnValue([(id)v29 inputBytesPerSecond]);
      id v8 = [v7 unsignedIntValue];

      id v9 = (void *)objc_claimAutoreleasedReturnValue([(id)v29 outputBytesPerSecond]);
      id v10 = [v9 unsignedIntValue];

      id v11 = (void *)objc_claimAutoreleasedReturnValue([(id)v29 packetsPerSecond]);
      id v12 = [v11 unsignedIntValue];

      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC720, 0LL))
      {
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        _NRLogWithArgs( qword_1001DC720,  0LL,  "%s%.30s:%-4d Applying BT link requirements %@ - InputBPS: %u, OutputBPS: %u, Packets/sec: %u",  "",  "-[NRLinkManagerBluetooth applyLinkRequirements:forBTUUID:]",  800LL,  v5,  v8,  v10,  v12);
      }

      [a1[6] setLinkRequirementsForPeer:v5 withClientName:@"com.apple.terminusLink" packetsPerSecond:v12 inputBytesPerSecond:v8 outputBytesPerSecond:v10];
      unsigned int v13 = [(id)v29 isNotEmpty];
      unsigned int v14 = [(id)v6 isNotEmpty];
      if (v13)
      {
        if (v14)
        {
          objc_msgSend((id)v29, "setStartTime:", objc_msgSend((id)v6, "startTime"));
          objc_msgSend((id)v29, "setReportedToABC:", objc_msgSend((id)v6, "reportedToABC"));
        }

        else
        {
          [(id)v29 setStartTime:mach_continuous_time()];
        }
      }

      else if (v14)
      {
        uint64_t v15 = mach_continuous_time();
        id v16 = objc_alloc_init(&OBJC_CLASS___NRAnalyticsBluetoothAssertion);
        id v17 = [(id)v6 startTime];
        double v20 = 0.0;
        if (v17)
        {
          unint64_t v21 = v15 - (void)v17;
          if (v15 > (unint64_t)v17)
          {
            if (qword_1001DC9F0 != -1) {
              dispatch_once(&qword_1001DC9F0, &stru_1001AFB98);
            }
            LODWORD(v1_Block_object_dispose((const void *)(v27 - 152), 8) = dword_1001DC9F8;
            LODWORD(v19) = *(_DWORD *)algn_1001DC9FC;
            double v20 = (double)v21 * (0.000000001 * (double)v18) / (double)v19;
          }
        }

        if (v16) {
          v16->_durationInSec = v20;
        }
        id v22 = objc_msgSend(a1[14], "count", v20);
        if (v16) {
          v16->_multipleAssertions = v22 != 0LL;
        }
        -[NRAnalyticsBluetoothAssertion submit](v16, "submit");
        sub_10002D874((void *)v6, 1, v15);
      }

      if ([a1[14] count])
      {
        if (!a1[16])
        {
          uint64_t v23 = (dispatch_queue_s *)a1[3];
          id v24 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v23);

          dispatch_source_set_timer(v24, 0x8000000000000000LL, 0x8BB2C97000uLL, 0x12A05F200uLL);
          objc_initWeak(&location, a1);
          handler[0] = _NSConcreteStackBlock;
          handler[1] = 3221225472LL;
          handler[2] = sub_10002DB0C;
          handler[3] = &unk_1001B0798;
          objc_copyWeak(&v32, &location);
          unsigned int v25 = v24;
          id v31 = v25;
          dispatch_source_set_event_handler(v25, handler);
          dispatch_resume(v25);
          objc_storeStrong(a1 + 16, v24);
          if (qword_1001DC728 != -1) {
            dispatch_once(&qword_1001DC728, &stru_1001AE510);
          }
          id v26 = (id)qword_1001DC720;
          char IsLevelEnabled = _NRLogIsLevelEnabled(v26, 0LL);

          if ((IsLevelEnabled & 1) != 0)
          {
            if (qword_1001DC728 != -1) {
              dispatch_once(&qword_1001DC728, &stru_1001AE510);
            }
            id v28 = (id)qword_1001DC720;
            _NRLogWithArgs( v28,  0LL,  "%s%.30s:%-4d created timer source to monitor link requirements",  "",  "-[NRLinkManagerBluetooth armLinkRequirementsTimer]",  888);
          }

          objc_destroyWeak(&v32);
          objc_destroyWeak(&location);
        }
      }

      else
      {
        sub_10002DA14((uint64_t)a1);
      }
    }

    else
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC720, 1LL))
      {
        if (qword_1001DC728 != -1) {
          dispatch_once(&qword_1001DC728, &stru_1001AE510);
        }
        _NRLogWithArgs( qword_1001DC720,  1LL,  "%s%.30s:%-4d Not applying same BT link requirements",  "",  "-[NRLinkManagerBluetooth applyLinkRequirements:forBTUUID:]",  790);
      }
    }
  }
}

void sub_10002D80C(_Unwind_Exception *a1)
{
}

void sub_10002D828(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
  }
  else {
    id WeakRetained = 0LL;
  }
  id v4 = WeakRetained;
  [WeakRetained linkIsUnavailable:*(void *)(a1 + 40)];
}

void sub_10002D874(void *a1, int a2, unint64_t a3)
{
  id v17 = a1;
  unsigned __int8 v5 = [v17 reportedToABC];
  uint64_t v6 = v17;
  if ((v5 & 1) == 0)
  {
    id v7 = [v17 startTime];
    uint64_t v6 = v17;
    if (v7)
    {
      BOOL v10 = a3 > (unint64_t)v7;
      unint64_t v11 = a3 - (void)v7;
      if (v10)
      {
        if (qword_1001DC9F0 != -1) {
          dispatch_once(&qword_1001DC9F0, &stru_1001AFB98);
        }
        LODWORD(v_Block_object_dispose((const void *)(v27 - 152), 8) = dword_1001DC9F8;
        LODWORD(v9) = *(_DWORD *)algn_1001DC9FC;
        double v12 = (double)v11 * (0.000000001 * (double)v8) / (double)v9;
        uint64_t v6 = v17;
        if (v12 > 599.0)
        {
          if (qword_1001DC728 != -1) {
            dispatch_once(&qword_1001DC728, &stru_1001AE510);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC720, 0LL))
          {
            if (qword_1001DC728 != -1) {
              dispatch_once(&qword_1001DC728, &stru_1001AE510);
            }
            _NRLogWithArgs( qword_1001DC720,  0LL,  "%s%.30s:%-4d detected long magnet assertion %.2fs",  "",  "-[NRLinkManagerBluetooth triggerLinkRequirementsABCIfNeeded:shouldTrigger:now:]",  843,  v12);
          }

          [v17 setReportedToABC:1];
          uint64_t v6 = v17;
          if (a2)
          {
            sub_1001030D0( @"NRLinkManagerBluetooth",  @"Bluetooth Assertion",  @"exceeded threshold",  0,  0LL,  v13,  v14,  v15,  v16);
            uint64_t v6 = v17;
          }
        }
      }
    }
  }
}

void sub_10002DA14(uint64_t a1)
{
  if (*(void *)(a1 + 128))
  {
    if (qword_1001DC728 != -1) {
      dispatch_once(&qword_1001DC728, &stru_1001AE510);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC720, 0LL))
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      _NRLogWithArgs( qword_1001DC720,  0LL,  "%s%.30s:%-4d invalidating link requirements monitor source",  "",  "-[NRLinkManagerBluetooth invalidateLinkRequirementsTimer]",  894);
    }

    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 128));
    uint64_t v2 = *(void **)(a1 + 128);
    *(void *)(a1 + 12_Block_object_dispose((const void *)(v27 - 152), 8) = 0LL;
  }

void sub_10002DB0C(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  id v3 = WeakRetained;
  if (WeakRetained && WeakRetained[16] == *(id *)(a1 + 32))
  {
    uint64_t v4 = mach_continuous_time();
    __int128 v15 = 0u;
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    __int128 v18 = 0u;
    id v5 = v3[14];
    id v6 = [v5 countByEnumeratingWithState:&v15 objects:v19 count:16];
    if (v6)
    {
      id v7 = v6;
      int v8 = 0;
      uint64_t v9 = *(void *)v16;
      do
      {
        for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v16 != v9) {
            objc_enumerationMutation(v5);
          }
          unint64_t v11 = (void *)objc_claimAutoreleasedReturnValue( objc_msgSend( v3[14],  "objectForKeyedSubscript:",  *(void *)(*((void *)&v15 + 1) + 8 * (void)i),  (void)v15));
          if (([v11 reportedToABC] & 1) == 0)
          {
            sub_10002D874(v11, 0, v4);
            v8 |= [v11 reportedToABC];
          }
        }

        id v7 = [v5 countByEnumeratingWithState:&v15 objects:v19 count:16];
      }

      while (v7);

      if ((v8 & 1) != 0) {
        sub_1001030D0( @"NRLinkManagerBluetooth",  @"Bluetooth Assertion",  @"exceeded threshold",  0,  0LL,  v12,  v13,  v14,  v15);
      }
    }

    else
    {
    }
  }
}

void sub_10002DCC0(uint64_t a1)
{
  if ([*(id *)(a1 + 32) state] == 9)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2) {
      id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    }
    else {
      id WeakRetained = 0LL;
    }
    id v4 = WeakRetained;
    [WeakRetained linkIsSuspended:*(void *)(a1 + 32)];
  }

  else
  {
    if (qword_1001DC728 != -1) {
      dispatch_once(&qword_1001DC728, &stru_1001AE510);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC720, 16LL))
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      _NRLogWithArgs( qword_1001DC720,  16LL,  "%s%.30s:%-4d %@: link %@ is not in suspended state anymore",  "",  "-[NRLinkManagerBluetooth linkIsSuspended:]_block_invoke",  1186LL,  *(void *)(a1 + 40),  *(void *)(a1 + 32));
    }
  }

void sub_10002DDD0(uint64_t a1)
{
  if ([*(id *)(a1 + 32) state] == 8)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2) {
      id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    }
    else {
      id WeakRetained = 0LL;
    }
    id v4 = WeakRetained;
    [WeakRetained linkIsReady:*(void *)(a1 + 32)];
  }

  else
  {
    if (qword_1001DC728 != -1) {
      dispatch_once(&qword_1001DC728, &stru_1001AE510);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC720, 16LL))
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      _NRLogWithArgs( qword_1001DC720,  16LL,  "%s%.30s:%-4d %@: link %@ is not in ready state anymore",  "",  "-[NRLinkManagerBluetooth linkIsReady:]_block_invoke",  1155LL,  *(void *)(a1 + 40),  *(void *)(a1 + 32));
    }
  }

void sub_10002DEE0(uint64_t a1)
{
  if ([*(id *)(a1 + 32) state] == 1)
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (v2) {
      id WeakRetained = objc_loadWeakRetained((id *)(v2 + 16));
    }
    else {
      id WeakRetained = 0LL;
    }
    id v4 = WeakRetained;
    [WeakRetained linkIsAvailable:*(void *)(a1 + 32)];
  }

  else
  {
    if (qword_1001DC728 != -1) {
      dispatch_once(&qword_1001DC728, &stru_1001AE510);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC720, 16LL))
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      _NRLogWithArgs( qword_1001DC720,  16LL,  "%s%.30s:%-4d %@: link %@ is not in initial state anymore",  "",  "-[NRLinkManagerBluetooth linkIsAvailable:]_block_invoke",  1092LL,  *(void *)(a1 + 40),  *(void *)(a1 + 32));
    }
  }

void sub_10002DFF0(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = &selRef_sources;
  *(_BYTE *)(a1 + 3_Block_object_dispose((const void *)(v27 - 152), 8) = 0;
  id v3 = &selRef_sources;
  *(_BYTE *)(a1 + 37) = 0;
  id v4 = sub_10013163C((uint64_t)&OBJC_CLASS___NRDLocalDevice);
  if (!-[NSMutableArray count](v4, "count")) {
    goto LABEL_59;
  }
  __int128 v56 = 0u;
  __int128 v57 = 0u;
  __int128 v54 = 0u;
  __int128 v55 = 0u;
  id v5 = v4;
  id v6 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v5,  "countByEnumeratingWithState:objects:count:",  &v54,  v62,  16LL);
  id v7 = &selRef_sources;
  if (!v6)
  {

    char v34 = 0;
    goto LABEL_37;
  }

  id v8 = v6;
  id v52 = v4;
  uint64_t v53 = 0LL;
  uint64_t v9 = *(void *)v55;
  BOOL v10 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
  unint64_t v11 = v5;
  while (2)
  {
    for (uint64_t i = 0LL; i != v8; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v55 != v9) {
        objc_enumerationMutation(v11);
      }
      uint64_t v13 = sub_100129B30((uint64_t)&v10[64], *(void **)(*((void *)&v54 + 1) + 8LL * (void)i));
      uint64_t v14 = (id *)v13;
      if (!v13)
      {
        id v19 = 0LL;
        *(_BYTE *)(v1 + 37) = 1;
        goto LABEL_17;
      }

      id v15 = *((id *)v13 + 16);
      if (v15)
      {
        __int128 v16 = v15;
        id v17 = v14[16];
        if ([v17 bluetoothEndpointType] != (id)1)
        {
          uint64_t v26 = v1;
          id v27 = v14[16];
          id v28 = v11;
          id v29 = [v27 bluetoothEndpointType];

          uint64_t v1 = v26;
          BOOL v10 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;

          __int128 v18 = &OBJC_IVAR___NRLinkManagerBluetooth__hasEnabledDevicesUsingClientServer;
          BOOL v30 = v29 == (id)2;
          unint64_t v11 = v28;
          if (!v30)
          {
            id v31 = v14[16];
            id v32 = [v31 bluetoothEndpointType];

            __int128 v18 = &OBJC_IVAR___NRLinkManagerBluetooth__hasEnabledDevicesUsingP2P;
            if (v32 != (id)3) {
              goto LABEL_16;
            }
          }

          goto LABEL_15;
        }
      }

      __int128 v18 = &OBJC_IVAR___NRLinkManagerBluetooth__hasEnabledDevicesUsingClientServer;
LABEL_15:
      *(_BYTE *)(v1 + *v1_Block_object_dispose((const void *)(v27 - 152), 8) = 1;
LABEL_16:
      id v19 = v14[16];
LABEL_17:
      id v20 = v19;
      id v21 = [v20 bluetoothRole];

      if (v21 == (id)1) {
        goto LABEL_6;
      }
      if (v14) {
        id v22 = v14[16];
      }
      else {
        id v22 = 0LL;
      }
      id v23 = v22;
      id v24 = [v23 bluetoothRole];

      if (v24 == (id)2) {
        goto LABEL_23;
      }
      int v25 = sub_100107E48(v14);
      if (v25 == 1)
      {
LABEL_6:
        BYTE4(v53) = 1;
        goto LABEL_7;
      }

      if (v25 == 2) {
LABEL_23:
      }
        LOBYTE(v53) = 1;
LABEL_7:
    }

    id v8 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v11,  "countByEnumeratingWithState:objects:count:",  &v54,  v62,  16LL);
    if (v8) {
      continue;
    }
    break;
  }

  if ((v53 & 0x100000000LL) == 0)
  {
    id v4 = v52;
    id v3 = &selRef_sources;
    uint64_t v2 = &selRef_sources;
    char v34 = v53;
    id v7 = &selRef_sources;
LABEL_37:
    if (*(void *)(v1 + *((int *)v7 + 845)))
    {
      sub_100028E3C(v1);
      [*(id *)(v1 + *((int *)v7 + 845)) setDelegate:0];
      uint64_t v35 = *((int *)v7 + 845);
      __int128 v36 = *(void **)(v1 + v35);
      *(void *)(v1 + v35) = 0LL;
    }

    __int128 v37 = *(void **)(v1 + 72);
    *(void *)(v1 + 72) = 0LL;

    if ((v34 & 1) != 0) {
      goto LABEL_40;
    }
    goto LABEL_32;
  }

  if (!*(void *)(v1 + 64))
  {
    uint64_t v2 = &selRef_sources;
    if (qword_1001DC728 != -1) {
      dispatch_once(&qword_1001DC728, &stru_1001AE510);
    }
    id v4 = v52;
    id v3 = &selRef_sources;
    if (_NRLogIsLevelEnabled(qword_1001DC720, 0LL))
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      _NRLogWithArgs( qword_1001DC720,  0LL,  "%s%.30s:%-4d initializing CBCentralManager",  "",  "-[NRLinkManagerBluetooth setup]",  499);
    }

    int8x8_t v47 = objc_alloc(&OBJC_CLASS___CBCentralManager);
    id v48 = *(id *)(v1 + 24);
    id v60 = CBCentralManagerOptionShowPowerAlertKey;
    id v61 = &__kCFBooleanTrue;
    int v49 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v61,  &v60,  1LL));
    id v50 = -[CBCentralManager initWithDelegate:queue:options:](v47, "initWithDelegate:queue:options:", v1, v48, v49);
    int v51 = *(void **)(v1 + 64);
    *(void *)(v1 + 64) = v50;

    if ((v53 & 1) != 0) {
      goto LABEL_40;
    }
LABEL_32:
    if (*(void *)(v1 + 56))
    {
      sub_10002C424((id *)v1);
      [*(id *)(v1 + 56) setDelegate:0];
      unsigned int v33 = *(void **)(v1 + 56);
      *(void *)(v1 + 56) = 0LL;
    }

    *(_BYTE *)(v1 + 33) = 0;
    goto LABEL_48;
  }

  id v4 = v52;
  id v3 = &selRef_sources;
  uint64_t v2 = &selRef_sources;
  if ((v53 & 1) == 0) {
    goto LABEL_32;
  }
LABEL_40:
  if (!*(void *)(v1 + 56))
  {
    if (qword_1001DC728 != -1) {
      dispatch_once(&qword_1001DC728, &stru_1001AE510);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC720, 0LL))
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      _NRLogWithArgs( qword_1001DC720,  0LL,  "%s%.30s:%-4d initializing CBPeripheralManager",  "",  "-[NRLinkManagerBluetooth setup]",  510);
    }

    __int128 v38 = objc_alloc(&OBJC_CLASS___CBPeripheralManager);
    id v39 = *(id *)(v1 + 24);
    id v58 = CBPeripheralManagerOptionShowPowerAlertKey;
    int v59 = &__kCFBooleanTrue;
    __int128 v40 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  &v59,  &v58,  1LL));
    __int128 v41 = -[CBPeripheralManager initWithDelegate:queue:options:](v38, "initWithDelegate:queue:options:", v1, v39, v40);
    __int128 v42 = *(void **)(v1 + 56);
    *(void *)(v1 + 56) = v41;
  }

LABEL_59:
}
}

    if (qword_1001DC9B8 != -1) {
      dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
    }
    if (byte_1001DC9B0 && _NRIsAppleInternal(v77))
    {
      if (qword_1001DC9C8 != -1) {
        dispatch_once(&qword_1001DC9C8, &stru_1001AFB38);
      }
      id v78 = 3LL;
      if (!byte_1001DC9C0) {
        id v78 = 1LL;
      }
      if (!v69)
      {
LABEL_68:

        if (![0 length]) {
          goto LABEL_74;
        }
        goto LABEL_72;
      }
    }

    else
    {
      id v78 = 0LL;
      if (!v69) {
        goto LABEL_68;
      }
    }

    v69->_receivedFlags = v101;
    v69->_localFlags = v78;
    id v80 = (NSData *)sub_1001159B8(v18, "nrAD");
    advertisementData = v69->_advertisementData;
    v69->_advertisementData = v80;

    if (!-[NSData length](v69->_advertisementData, "length"))
    {
LABEL_74:
      enumerator[0] = _NSConcreteStackBlock;
      enumerator[1] = 3221225472LL;
      enumerator[2] = sub_1001166C0;
      enumerator[3] = &unk_1001AFFE8;
      enumerator[4] = a1;
      uint64_t v98 = v69;
      uint64_t v99 = v14;
      int v100 = v15;
      int8x8_t v47 = v69;
      nw_browse_result_enumerate_interfaces(v13, enumerator);

      goto LABEL_75;
    }

    id v22 = 0LL;
    goto LABEL_56;
  }

  if ((_DWORD)a4 == 3)
  {
    uint64_t v9 = &kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly;
  }

  else
  {
    if ((_DWORD)a4 != 4)
    {
      id String = (void *)NRDataProtectionClassCreateString(a4);
      goto LABEL_11;
    }

    uint64_t v9 = (const CFStringRef *)&kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate;
  }

  BOOL v10 = *v9;
  id String = (void *)NRDataProtectionClassCreateString(a4);
  if (!v10)
  {
LABEL_11:
    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    uint64_t v14 = (id)qword_1001DCC20;
    id v15 = _NRLogIsLevelEnabled(v14, 17LL);

    if (v15)
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      __int128 v16 = (id)qword_1001DCC20;
      _NRLogWithArgs(v16, 17LL, "Cannot delete key %@ from keychain for %@", v7, String);
    }

    id v31 = 0;
    goto LABEL_55;
  }

  uint64_t v12 = objc_alloc(&OBJC_CLASS___NSString);
  if (v8) {
    uint64_t v13 = -[NSString initWithFormat:]( v12,  "initWithFormat:",  @"%@/%@/%@/%@",  @"com.apple.terminusd",  v8,  String,  v7);
  }
  else {
    uint64_t v13 = -[NSString initWithFormat:]( v12,  "initWithFormat:",  @"%@/%@",  @"com.apple.terminusd",  v7,  v27,  v28);
  }
  id v17 = v13;
  if (qword_1001DCC28 != -1) {
    dispatch_once(&qword_1001DCC28, &stru_1001B0980);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
  {
    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    _NRLogWithArgs( qword_1001DCC20,  0LL,  "%s%.30s:%-4d Deleting %@ keychain key %@",  "",  "-[NRDKeyManager deleteKeyfromKeychainWithName:nrUUID:dataProtectionClass:]",  596LL,  String,  v17);
  }

  __int128 v18 = (void *)objc_claimAutoreleasedReturnValue(-[NSString dataUsingEncoding:](v17, "dataUsingEncoding:", 4LL));
  v32[0] = kSecClass;
  v32[1] = kSecAttrApplicationTag;
  v33[0] = kSecClassKey;
  v33[1] = v18;
  v32[2] = kSecAttrAccessGroup;
  v33[2] = @"com.apple.terminusd";
  id v19 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v33,  v32,  3LL));
  id v20 = SecItemDelete(v19);
  if ((_DWORD)v20 == -25308)
  {
    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCC20, 16LL))
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      _NRLogWithArgs( qword_1001DCC20,  16LL,  "%s%.30s:%-4d Failed to delete %@ keychain key %@: keychain locked",  "",  "-[NRDKeyManager deleteKeyfromKeychainWithName:nrUUID:dataProtectionClass:]",  616LL,  String,  v17);
    }

    goto LABEL_53;
  }

  id v21 = v20;
  if ((_DWORD)v20 == -25300)
  {
    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      _NRLogWithArgs( qword_1001DCC20,  0LL,  "%s%.30s:%-4d Failed to delete %@ keychain key %@: item not found (not an error)",  "",  "-[NRDKeyManager deleteKeyfromKeychainWithName:nrUUID:dataProtectionClass:]",  613LL,  String,  v17);
    }

    goto LABEL_46;
  }

  if ((_DWORD)v20)
  {
    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCC20, 17LL))
    {
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      _NRLogWithArgs(qword_1001DCC20, 17LL, "Failed to delete %@ keychain key %@: %d", String, v17, v21, v29, v30);
    }

void sub_10002E6C8(uint64_t a1)
{
  if (a1 && _NRIsAppleInternal())
  {
    p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    if (qword_1001DC728 != -1) {
      dispatch_once(&qword_1001DC728, &stru_1001AE510);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC720, 1LL))
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      _NRLogWithArgs( qword_1001DC720,  1LL,  "%s%.30s:%-4d checking bluetooth pairing state",  "",  "-[NRLinkManagerBluetooth checkBluetoothPairingState]",  2168);
    }

    uint64_t v2 = objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
    id v3 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v3);

    sub_100127AFC(v2);
    id v4 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    __int128 v47 = 0u;
    __int128 v48 = 0u;
    __int128 v49 = 0u;
    __int128 v50 = 0u;
    id v5 = (id)qword_1001DCB78;
    id v6 = [v5 countByEnumeratingWithState:&v47 objects:v52 count:16];
    if (v6)
    {
      id v7 = v6;
      uint64_t v8 = *(void *)v48;
      do
      {
        for (uint64_t i = 0LL; i != v7; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v48 != v8) {
            objc_enumerationMutation(v5);
          }
          uint64_t v10 = *(void *)(*((void *)&v47 + 1) + 8LL * (void)i);
          uint64_t v11 = objc_claimAutoreleasedReturnValue([(id)qword_1001DCB78 objectForKeyedSubscript:v10]);
          uint64_t v12 = (void *)v11;
          if (v11 && *(_BYTE *)(v11 + 20)) {
            -[NSMutableArray addObject:](v4, "addObject:", v10);
          }
        }

        id v7 = [v5 countByEnumeratingWithState:&v47 objects:v52 count:16];
      }

      while (v7);
    }

    __int128 v43 = 0u;
    __int128 v44 = 0u;
    __int128 v45 = 0u;
    __int128 v46 = 0u;
    id obj = v4;
    id v13 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v43,  v51,  16LL);
    uint64_t v14 = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
    id v15 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
    if (v13)
    {
      id v16 = v13;
      id v17 = (objc_class *)&OBJC_IVAR___NRAnalyticsALUAdviceStats__timeSinceLastAdvice;
      uint64_t v18 = *(void *)v44;
      do
      {
        for (j = 0LL; j != v16; j = (char *)j + 1)
        {
          if (*(void *)v44 != v18) {
            objc_enumerationMutation(obj);
          }
          id v28 = *(void **)(*((void *)&v43 + 1) + 8LL * (void)j);
          id v29 = sub_100129B30((uint64_t)&v15[64], v28);
          BOOL v30 = v29;
          if (!v29)
          {
            [&v17[284] removePairerForNRUUID:0];
LABEL_45:
            if (p_class_meths[229] != (__objc2_meth_list *)-1LL) {
              dispatch_once(&qword_1001DC728, &stru_1001AE510);
            }
            if (_NRLogIsLevelEnabled(v14[228], 1LL))
            {
              if (p_class_meths[229] != (__objc2_meth_list *)-1LL) {
                dispatch_once(&qword_1001DC728, &stru_1001AE510);
              }
              _NRLogWithArgs( v14[228],  1LL,  "%s%.30s:%-4d already has pairer for %@",  "",  "-[NRLinkManagerBluetooth checkBluetoothPairingState]",  2193LL,  v28);
            }

            goto LABEL_26;
          }

          if (v29[9])
          {
            if (!v29[20]) {
              goto LABEL_44;
            }
          }

          else
          {
            id v31 = *((id *)v29 + 4);
            [&v17[284] removePairerForNRUUID:v31];

            id v15 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
            if (!v30[20]) {
              goto LABEL_44;
            }
          }

          if (!v30[8] && !v30[9] && v30[10])
          {
            if (p_class_meths[229] != (__objc2_meth_list *)-1LL) {
              dispatch_once(&qword_1001DC728, &stru_1001AE510);
            }
            if (_NRLogIsLevelEnabled(v14[228], 1LL))
            {
              if (p_class_meths[229] != (__objc2_meth_list *)-1LL) {
                dispatch_once(&qword_1001DC728, &stru_1001AE510);
              }
              _NRLogWithArgs( v14[228],  1LL,  "%s%.30s:%-4d unpairing bluetooth for device %@",  "",  "-[NRLinkManagerBluetooth checkBluetoothPairingState]",  2180LL,  v30);
            }

            id v32 = objc_alloc(v17 + 284);
            id v33 = *((id *)v30 + 4);
            id v34 = [v32 initWithNRUUID:v33];

            id v35 = *(id *)(a1 + 24);
            v42[0] = _NSConcreteStackBlock;
            v42[1] = 3221225472LL;
            v42[2] = sub_10002EDEC;
            v42[3] = &unk_1001AE4F0;
            v42[4] = v28;
            [v34 unpairWithCompletionQueue:v35 completionBlock:v42];

            id v15 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
          }

LABEL_26:
        }

        id v16 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v43,  v51,  16LL);
      }

      while (v16);
    }
  }

    BOOL v30 = 0LL;
    goto LABEL_9;
  }

  v48.receiver = self;
  v48.super_class = (Class)&OBJC_CLASS___NRLinkWiFi;
  id v22 = -[NRLink initLinkWithQueue:linkDelegate:nrUUID:](&v48, "initLinkWithQueue:linkDelegate:nrUUID:", v15, v16, v17);
  if (!v22)
  {
    __int128 v45 = sub_10003295C();
    __int128 v46 = _NRLogIsLevelEnabled(v45, 17LL);

    if (v46)
    {
      __int128 v47 = sub_10003295C();
      _NRLogWithArgs(v47, 17LL, "[NRLink initLinkWithQueue:] failed");
    }

    self = 0LL;
    goto LABEL_26;
  }

  id v23 = v22;
  [v22 setType:2];
  [v23 setSubtype:101];
  [v23 setLocalInterfaceName:v18];
  [v23 setLocalOuterEndpoint:v19];
  [v23 setRemoteOuterEndpoint:v20];
  objc_storeStrong((id *)(v23 + 239), a9);
  *(_DWORD *)(v23 + 231) = -1;
  id v24 = objc_alloc_init(&OBJC_CLASS___NRAnalyticsCmpnLinkWiFi);
  id v25 = *(void **)(v23 + 271);
  *(void *)(v23 + 271) = v24;

  id v26 = objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
  id v27 = *(void **)(v23 + 279);
  *(void *)(v23 + 279) = v26;

  id v28 = (void *)objc_claimAutoreleasedReturnValue([v17 UUIDString]);
  [v23 reportEvent:3000 details:v28];

  id v29 = (void *)objc_claimAutoreleasedReturnValue([v23 linkDelegate]);
  [v29 linkIsAvailable:v23];

  self = v23;
  BOOL v30 = self;
LABEL_9:

  return v30;
}
  }

  return a1;
}

    __int128 v36 = _os_log_pack_size(22LL);
    id v37 = (char *)&v41 - ((__chkstk_darwin(v36) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    __int128 v38 = __error();
    id v39 = _os_log_pack_fill( v37,  v36,  *v38,  &_mh_execute_header,  "%{public}s _strict_reallocf(%zu) failed");
    *(_DWORD *)id v39 = 136446466;
    *(void *)(v39 + 4) = "_strict_reallocf";
    *(_WORD *)(v39 + 12) = 2048;
    *(void *)(v39 + 14) = v9;
    __int128 v40 = sub_100070554();
    _NRLogAbortWithPack(v40, v37);
  }

  sub_10008BC7C(a1, v5);
  id v6 = 319LL;
LABEL_12:
  *(_DWORD *)(a1 + v6) = 0;
LABEL_20:
}
}

  if (v10)
  {
    if (!*((void *)v10 + 8))
    {
      *((void *)v10 + _Block_object_dispose((const void *)(v27 - 152), 8) = mach_absolute_time();
      *((void *)v10 + 9) = 0LL;
    }

    uint64_t v18 = v10[4] | 1;
    v10[4] = v18;
    ++v10[6];
    if ((a3 & 1) != 0)
    {
      *((void *)v10 + 4) = *(void *)(a1 + 592);
      id v19 = *((void *)v10 + 6);
      *((void *)v10 + 5) |= *(void *)(a1 + 600);
      if (!v19)
      {
        *((void *)v10 + 6) = mach_absolute_time();
        *((void *)v10 + 7) = 0LL;
        uint64_t v18 = v10[4];
      }

      v10[4] = v18 | 2;
    }

    if ((~*(_DWORD *)(a1 + 592) & 6LL) == 0) {
      v10[4] |= 0x10u;
    }
  }

  else
  {
    mach_absolute_time();
    if ((a3 & 1) != 0) {
      mach_absolute_time();
    }
  }

  v20[2]();

  id v7 = v20;
LABEL_36:
}
  }

        -[NRLink invalidateVirtualInterface](self, "invalidateVirtualInterface");
        return 0;
      }

      id v39 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v6);
      __int128 v40 = _NRLogIsLevelEnabled(v39, 17LL);

      if (!v40) {
        goto LABEL_26;
      }
      __int128 v36 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v41);
      id v37 = -[NRLink copyDescription](self, "copyDescription");
      _NRLogWithArgs(v36, 17LL, "%@: failed to setup no ack prioritization", v37);
    }

    else
    {
      id v33 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v5);
      id v34 = _NRLogIsLevelEnabled(v33, 17LL);

      if (!v34) {
        goto LABEL_26;
      }
      __int128 v36 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v35);
      id v37 = -[NRLink copyDescription](self, "copyDescription");
      _NRLogWithArgs(v36, 17LL, "%@: failed to setup interface sub family", v37);
    }

  if (v5)
  {
    id v23 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
    id v24 = sub_1001040C8(v5, port, 0);
    id v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
    NRTLVAddData(v23, 3LL);
    -[NSMutableData appendData:](v9, "appendData:", v23);
  }

  id v26 = v3[16];
  id v27 = [v26 hasPoliciesForProxyCriteria];

  if (v27)
  {
    id v64 = v9;
    uint64_t v65 = v5;
    int v63 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
    unint64_t v67 = 0u;
    unint64_t v68 = 0u;
    unint64_t v69 = 0u;
    BOOL v70 = 0u;
    uint64_t v66 = v3;
    id v28 = v3[16];
    id v29 = (void *)objc_claimAutoreleasedReturnValue([v28 proxyProviderCriteria]);
    BOOL v30 = (void *)objc_claimAutoreleasedReturnValue([v29 proxyUsageRules]);

    id v31 = [v30 countByEnumeratingWithState:&v67 objects:v74 count:16];
    if (v31)
    {
      id v32 = v31;
      id v33 = *(void *)v68;
      do
      {
        for (uint64_t i = 0LL; i != v32; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v68 != v33) {
            objc_enumerationMutation(v30);
          }
          id v35 = *(void **)(*((void *)&v67 + 1) + 8LL * (void)i);
          __int128 v36 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
          id v37 = (void *)objc_claimAutoreleasedReturnValue([v35 matchResultAccountID]);
          __int128 v38 = [v37 length];

          if (v38)
          {
            id v39 = (void *)objc_claimAutoreleasedReturnValue([v35 matchResultAccountID]);
            __int128 v40 = (void *)objc_claimAutoreleasedReturnValue([v39 dataUsingEncoding:4]);

            __int128 v41 = sub_100002254((id *)objc_alloc(&OBJC_CLASS___NRToken), 1, 51, v40);
            __int128 v42 = sub_100002438((uint64_t)v41);
            NRTLVAddData(v36, 8LL);
          }

          __int128 v43 = (void *)objc_claimAutoreleasedReturnValue([v35 matchResultBundleID]);
          __int128 v44 = [v43 length];

          if (v44)
          {
            __int128 v45 = (void *)objc_claimAutoreleasedReturnValue([v35 matchResultBundleID]);
            __int128 v46 = (void *)objc_claimAutoreleasedReturnValue([v45 dataUsingEncoding:4]);

            __int128 v47 = sub_100002254((id *)objc_alloc(&OBJC_CLASS___NRToken), 1, 52, v46);
            __int128 v48 = sub_100002438((uint64_t)v47);
            NRTLVAddData(v36, 8LL);
          }

          if (-[NSMutableData length](v36, "length")) {
            [v35 addMatchToken:v36];
          }
        }

        id v32 = [v30 countByEnumeratingWithState:&v67 objects:v74 count:16];
      }

      while (v32);
    }

    id v3 = v66;
    __int128 v49 = v66[16];
    __int128 v50 = (void *)objc_claimAutoreleasedReturnValue([v49 proxyProviderCriteria]);
    int v51 = [v50 copySendData];

    id v52 = [v51 length];
    uint64_t v9 = v64;
    uint64_t v53 = v63;
    if (v52)
    {
      NRTLVAddData(v63, 4LL);
      -[NSMutableData appendData:](v9, "appendData:", v53);
    }

    id v5 = v65;
  }

  __int128 v54 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50701 notifyData:v9];

  return v54;
}

    id v13 = 0LL;
    goto LABEL_32;
  }
}

void sub_10002EDEC(uint64_t a1, int a2, void *a3)
{
  id v6 = a3;
  if (a2)
  {
    if (qword_1001DC728 != -1) {
      dispatch_once(&qword_1001DC728, &stru_1001AE510);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC720, 1LL))
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      _NRLogWithArgs( qword_1001DC720,  1LL,  "%s%.30s:%-4d unpaired BT device %@",  "",  "-[NRLinkManagerBluetooth checkBluetoothPairingState]_block_invoke",  2184LL,  v6);
    }

    sub_100138214((uint64_t)&OBJC_CLASS___NRDLocalDevice, 0LL, *(void **)(a1 + 32));
  }

  else
  {
    if (qword_1001DC728 != -1) {
      dispatch_once(&qword_1001DC728, &stru_1001AE510);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC720, 16LL))
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      _NRLogWithArgs( qword_1001DC720,  16LL,  "%s%.30s:%-4d failed to unpair BT device",  "",  "-[NRLinkManagerBluetooth checkBluetoothPairingState]_block_invoke",  2187);
    }
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v5 = (id)qword_1001DC870;
  sub_1000A49E8();
}

void sub_10002EFA8(uint64_t a1, int a2, void *a3)
{
  id v6 = a3;
  if (a2)
  {
    if (qword_1001DC728 != -1) {
      dispatch_once(&qword_1001DC728, &stru_1001AE510);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC720, 1LL))
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      _NRLogWithArgs( qword_1001DC720,  1LL,  "%s%.30s:%-4d paired BT device %@",  "",  "-[NRLinkManagerBluetooth checkBluetoothPairingState]_block_invoke_2",  2209LL,  v6);
    }

    sub_100138214((uint64_t)&OBJC_CLASS___NRDLocalDevice, v6, *(void **)(a1 + 32));
  }

  else
  {
    if (qword_1001DC728 != -1) {
      dispatch_once(&qword_1001DC728, &stru_1001AE510);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC720, 16LL))
    {
      if (qword_1001DC728 != -1) {
        dispatch_once(&qword_1001DC728, &stru_1001AE510);
      }
      _NRLogWithArgs( qword_1001DC720,  16LL,  "%s%.30s:%-4d failed to pair BT device",  "",  "-[NRLinkManagerBluetooth checkBluetoothPairingState]_block_invoke_2",  2212);
    }
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v5 = (id)qword_1001DC870;
  sub_1000A49E8();
}

void sub_10002F5F8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (!v3)
  {
    uint64_t v21 = 0LL;
LABEL_18:
    id v22 = (void *)_NRCopyLogObjectForNRUUID(v21, a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v22, 17LL);

    if (IsLevelEnabled)
    {
      uint64_t v25 = *(void *)(a1 + 32);
      if (v25) {
        uint64_t v26 = *(void *)(v25 + 40);
      }
      else {
        uint64_t v26 = 0LL;
      }
      id v35 = (void *)_NRCopyLogObjectForNRUUID(v26, v24);
      _NRLogWithArgs(v35, 17LL, "Received an unexpected unassertAgent call");
      goto LABEL_30;
    }

    return;
  }

  int v4 = *(_DWORD *)(v3 + 16);
  if (!v4)
  {
    uint64_t v21 = *(void *)(v3 + 40);
    goto LABEL_18;
  }

  *(_DWORD *)(v3 + 16) = v4 - 1;
  unsigned __int8 v5 = [*(id *)(a1 + 32) isActive];
  uint64_t v7 = *(void *)(a1 + 32);
  if ((v5 & 1) != 0)
  {
    if (v7) {
      uint64_t v8 = *(void *)(v7 + 40);
    }
    else {
      uint64_t v8 = 0LL;
    }
    uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(v8, v6);
    int v10 = _NRLogIsLevelEnabled(v9, 0LL);

    if (v10)
    {
      uint64_t v11 = *(void **)(a1 + 32);
      if (v11) {
        uint64_t v11 = (void *)v11[5];
      }
      uint64_t v12 = v11;
      uint64_t v14 = _NRCopyLogObjectForNRUUID(v12, v13);
      id v15 = (void *)v14;
      uint64_t v16 = *(void *)(a1 + 32);
      if (v16) {
        LODWORD(v16) = *(_DWORD *)(v16 + 16);
      }
      _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d Quick relay agent un-asserted (Total remaining assertions: %u)",  "",  "-[NRQuickRelayAgent unassertAgentWithOptions:]_block_invoke",  241,  v16);
    }

    uint64_t v17 = *(void *)(a1 + 32);
    if (!v17)
    {
      id WeakRetained = 0LL;
      uint64_t v20 = 0LL;
LABEL_16:
      id v35 = WeakRetained;
      [WeakRetained deviceHasQuickRelayRequest:v20 hasQuickRelayRequest:0];
LABEL_30:

      return;
    }

    if (!*(_DWORD *)(v17 + 16))
    {
      id WeakRetained = objc_loadWeakRetained((id *)(v17 + 64));
      uint64_t v19 = *(void *)(a1 + 32);
      if (v19) {
        uint64_t v20 = *(void *)(v19 + 40);
      }
      else {
        uint64_t v20 = 0LL;
      }
      goto LABEL_16;
    }
  }

  else
  {
    if (v7) {
      uint64_t v27 = *(void *)(v7 + 40);
    }
    else {
      uint64_t v27 = 0LL;
    }
    id v28 = (void *)_NRCopyLogObjectForNRUUID(v27, v6);
    int v29 = _NRLogIsLevelEnabled(v28, 0LL);

    if (v29)
    {
      BOOL v30 = *(void **)(a1 + 32);
      if (v30) {
        BOOL v30 = (void *)v30[5];
      }
      id v35 = v30;
      uint64_t v32 = _NRCopyLogObjectForNRUUID(v35, v31);
      id v33 = (void *)v32;
      uint64_t v34 = *(void *)(a1 + 32);
      if (v34) {
        LODWORD(v34) = *(_DWORD *)(v34 + 16);
      }
      _NRLogWithArgs( v32,  0LL,  "%s%.30s:%-4d Ignoring quick relay agent un-assert (Total remaining assertions: %u)",  "",  "-[NRQuickRelayAgent unassertAgentWithOptions:]_block_invoke",  237,  v34);

      goto LABEL_30;
    }
  }

void sub_10002F818(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    ++*(_DWORD *)(v2 + 16);
    uint64_t v3 = *(void **)(a1 + 32);
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  unsigned __int8 v4 = [v3 isActive];
  uint64_t v6 = *(void *)(a1 + 32);
  if ((v4 & 1) != 0)
  {
    if (v6) {
      uint64_t v7 = *(void *)(v6 + 40);
    }
    else {
      uint64_t v7 = 0LL;
    }
    uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(v7, v5);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 0LL);

    if (IsLevelEnabled)
    {
      int v10 = *(void **)(a1 + 32);
      if (v10) {
        int v10 = (void *)v10[5];
      }
      uint64_t v11 = v10;
      uint64_t v13 = _NRCopyLogObjectForNRUUID(v11, v12);
      uint64_t v14 = (void *)v13;
      uint64_t v15 = *(void *)(a1 + 32);
      if (v15) {
        LODWORD(v15) = *(_DWORD *)(v15 + 16);
      }
      _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d Quick relay agent asserted (Total active assertions: %u)",  "",  "-[NRQuickRelayAgent assertAgentWithOptions:]_block_invoke",  219,  v15);
    }

    uint64_t v16 = *(void *)(a1 + 32);
    if (v16)
    {
      id WeakRetained = objc_loadWeakRetained((id *)(v16 + 64));
      uint64_t v18 = *(void *)(a1 + 32);
      if (v18) {
        uint64_t v19 = *(void *)(v18 + 40);
      }
      else {
        uint64_t v19 = 0LL;
      }
    }

    else
    {
      id WeakRetained = 0LL;
      uint64_t v19 = 0LL;
    }

    id v28 = WeakRetained;
    [WeakRetained deviceHasQuickRelayRequest:v19 hasQuickRelayRequest:1];
LABEL_24:

    return;
  }

  if (v6) {
    uint64_t v20 = *(void *)(v6 + 40);
  }
  else {
    uint64_t v20 = 0LL;
  }
  uint64_t v21 = (void *)_NRCopyLogObjectForNRUUID(v20, v5);
  int v22 = _NRLogIsLevelEnabled(v21, 0LL);

  if (v22)
  {
    id v23 = *(void **)(a1 + 32);
    if (v23) {
      id v23 = (void *)v23[5];
    }
    id v28 = v23;
    uint64_t v25 = _NRCopyLogObjectForNRUUID(v28, v24);
    uint64_t v26 = (void *)v25;
    uint64_t v27 = *(void *)(a1 + 32);
    if (v27) {
      LODWORD(v27) = *(_DWORD *)(v27 + 16);
    }
    _NRLogWithArgs( v25,  0LL,  "%s%.30s:%-4d Ignoring quick relay agent assert (Total active assertions: %u)",  "",  "-[NRQuickRelayAgent assertAgentWithOptions:]_block_invoke",  215,  v27);

    goto LABEL_24;
  }

id *sub_10002FA5C(id *a1, void *a2, void *a3, void *a4)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  if (a1)
  {
    if (v8)
    {
      if (v9)
      {
        v54.receiver = a1;
        v54.super_class = (Class)&OBJC_CLASS___NRQuickRelayAgent;
        uint64_t v11 = (id *)objc_msgSendSuper2(&v54, "init");
        if (v11)
        {
          uint64_t v12 = v11;
          objc_storeStrong(v11 + 6, a3);
          objc_storeStrong(v12 + 5, a2);
          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
          [v12 setAgentUUID:v13];

          [v12 setUserActivated:1];
          [v12 setSpecificUseOnly:1];
          [v12 setAgentDescription:@"Quick relay netagent"];
          objc_storeWeak(v12 + 8, v10);
          uint64_t v14 = objc_alloc(&OBJC_CLASS___NSString);
          uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v12 agentUUID]);
          uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v15 UUIDString]);
          uint64_t v17 = -[NSString initWithFormat:](v14, "initWithFormat:", @"NRQuickRelayAgent-%@", v16);
          id v18 = v12[9];
          v12[9] = v17;

          uint64_t v19 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v12[5]);
          if (v19)
          {
            uint64_t v20 = v19;
            uint64_t v21 = -[NSString initWithFormat:](objc_alloc(&OBJC_CLASS___NSString), "initWithFormat:", @"%@", v19);
            id v22 = v12[10];
            v12[10] = v21;

            id v23 = v12[5];
            id v24 = v12[10];
            id v25 = v23;
            uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v12 agentUUID]);
            uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v26 UUIDString]);
            sub_10011BB18(v25, 17001, v24, v27);

            a1 = v12;
            goto LABEL_7;
          }

          id v46 = sub_10002FF48();
          int IsLevelEnabled = _NRLogIsLevelEnabled(v46, 16LL);

          if (IsLevelEnabled)
          {
            id v48 = sub_10002FF48();
            _NRLogWithArgs( v48,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRQuickRelayAgent initWithNRUUID:queue:delegate:]",  62);
          }

          uint64_t v49 = _os_log_pack_size(12LL);
          id v33 = (char *)&v53 - ((v49 + 15) & 0xFFFFFFFFFFFFFFF0LL);
          __int128 v50 = __error();
          uint64_t v51 = _os_log_pack_fill( v33,  v49,  *v50,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
          *(_DWORD *)uint64_t v51 = 136446210;
          *(void *)(v51 + 4) = "-[NRQuickRelayAgent initWithNRUUID:queue:delegate:]";
LABEL_21:
          id v52 = sub_10002FF48();
          _NRLogAbortWithPack(v52, v33);
        }

        id v41 = sub_10002FF48();
        int v42 = _NRLogIsLevelEnabled(v41, 16LL);

        if (v42)
        {
          id v43 = sub_10002FF48();
          _NRLogWithArgs( v43,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRQuickRelayAgent initWithNRUUID:queue:delegate:]",  49);
        }

        uint64_t v44 = _os_log_pack_size(12LL);
        id v33 = (char *)&v53 - ((v44 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v45 = *__error();
        uint64_t v35 = _os_log_pack_fill(v33, v44, v45, &_mh_execute_header, "%{public}s [super init] failed");
      }

      else
      {
        id v36 = sub_10002FF48();
        int v37 = _NRLogIsLevelEnabled(v36, 16LL);

        if (v37)
        {
          id v38 = sub_10002FF48();
          _NRLogWithArgs( v38,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (queue) != ((void *)0)",  "",  "-[NRQuickRelayAgent initWithNRUUID:queue:delegate:]",  47);
        }

        uint64_t v39 = _os_log_pack_size(12LL);
        id v33 = (char *)&v53 - ((v39 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v40 = *__error();
        uint64_t v35 = _os_log_pack_fill( v33,  v39,  v40,  &_mh_execute_header,  "%{public}s Assertion Failed: (queue) != ((void *)0)");
      }
    }

    else
    {
      id v29 = sub_10002FF48();
      int v30 = _NRLogIsLevelEnabled(v29, 16LL);

      if (v30)
      {
        id v31 = sub_10002FF48();
        _NRLogWithArgs( v31,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "-[NRQuickRelayAgent initWithNRUUID:queue:delegate:]",  46);
      }

      uint64_t v32 = _os_log_pack_size(12LL);
      id v33 = (char *)&v53 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v34 = *__error();
      uint64_t v35 = _os_log_pack_fill( v33,  v32,  v34,  &_mh_execute_header,  "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    }

    *(_DWORD *)uint64_t v35 = 136446210;
    *(void *)(v35 + 4) = "-[NRQuickRelayAgent initWithNRUUID:queue:delegate:]";
    goto LABEL_21;
  }

id sub_10002FF48()
{
  if (qword_1001DC738 != -1) {
    dispatch_once(&qword_1001DC738, &stru_1001AE5A0);
  }
  return (id)qword_1001DC730;
}

void sub_10002FF88(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC730;
  qword_1001DC730 = (uint64_t)v1;
}

void sub_10002FFB8(uint64_t a1)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 48));
    if ([(id)a1 isActive])
    {
      [(id)a1 setActive:0];
      [*(id *)(a1 + 56) updateNetworkAgent:a1];
      uint64_t v2 = *(void **)(a1 + 40);
      id v3 = *(id *)(a1 + 80);
      id v4 = v2;
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 agentUUID]);
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 UUIDString]);
      sub_10011BB18(v4, 17004, v3, v6);

      id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
      [WeakRetained deviceHasQuickRelayRequest:*(void *)(a1 + 40) hasQuickRelayRequest:0];
    }
  }

void sub_1000300A8(uint64_t a1)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 48));
    if (([(id)a1 isActive] & 1) == 0)
    {
      [(id)a1 setActive:1];
      [*(id *)(a1 + 56) updateNetworkAgent:a1];
      if (*(_DWORD *)(a1 + 16))
      {
        id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
        [WeakRetained deviceHasQuickRelayRequest:*(void *)(a1 + 40) hasQuickRelayRequest:1];
      }

      id v3 = *(void **)(a1 + 40);
      id v4 = *(id *)(a1 + 80);
      id v7 = v3;
      uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 agentUUID]);
      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 UUIDString]);
      sub_10011BB18(v7, 17005, v4, v6);
    }
  }

void sub_100031854( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
}

void sub_100031B30(_Unwind_Exception *a1)
{
}

LABEL_54:
      v21[2](v21, 0LL, 0LL, 0LL);
      goto LABEL_55;
    }

    id v75 = sub_10003295C();
    id v76 = _NRLogIsLevelEnabled(v75, 16LL);

    if (v76)
    {
      id v77 = sub_10003295C();
      _NRLogWithArgs( v77,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRLinkWiFi requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  1142);
    }

    id v78 = _os_log_pack_size(12LL);
    uint64_t v17 = (char *)&v82 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    int v79 = __error();
    id v80 = _os_log_pack_fill( v17,  v78,  *v79,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    *(_DWORD *)id v80 = 136446210;
    *(void *)(v80 + 4) = "-[NRLinkWiFi requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBl"
                           "ock:responseBlock:]";
    id v81 = sub_10003295C();
    _NRLogAbortWithPack(v81, v17);
    goto LABEL_52;
  }

  int v73 = sub_10003295C();
  id v74 = _NRLogIsLevelEnabled(v73, 17LL);

  if (v74)
  {
    uint64_t v66 = sub_10003295C();
    _NRLogWithArgs(v66, 17LL, "%s called with null responseBlock");
    goto LABEL_48;
  }

  -[NSMutableArray addObject:](v8, "addObject:", @"UnexpectedLinkSwitch");
  if ((reason & 0x800000000000000LL) == 0)
  {
LABEL_29:
    if ((reason & 0x1000000000000000LL) == 0) {
      goto LABEL_30;
    }
    goto LABEL_56;
  }

    id v9 = 0LL;
    goto LABEL_55;
  }

  id v9 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v36);
LABEL_55:

  return v9;
}
}

void sub_100032540( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

id sub_10003295C()
{
  if (qword_1001DC748 != -1) {
    dispatch_once(&qword_1001DC748, &stru_1001AE638);
  }
  return (id)qword_1001DC740;
}

void sub_10003299C(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v16 = WeakRetained;
    BOOL v4 = [WeakRetained state] == 255;
    id WeakRetained = v16;
    if (!v4)
    {
      uint64_t v6 = _NRCopyLogObjectForNRUUID(v16[4], v5);
      id v7 = (void *)v6;
      if (!a2)
      {
        int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 16LL);

        if (IsLevelEnabled)
        {
          uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(v16[4], v13);
          id v15 = [v16 copyDescription];
          _NRLogWithArgs( v14,  16LL,  "%s%.30s:%-4d %@: Did not receive response to control notify",  "",  "-[NRLinkWiFi sendControlData:]_block_invoke",  1207LL,  v15);
        }

        [v16 cancelWithReason:@"peer is NOT available (Did not receive response to control notify)"];
        goto LABEL_9;
      }

      int v8 = _NRLogIsLevelEnabled(v6, 0LL);

      id WeakRetained = v16;
      if (v8)
      {
        id v10 = (void *)_NRCopyLogObjectForNRUUID(v16[4], v9);
        id v11 = [v16 copyDescription];
        _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d %@: Received response to control notify",  "",  "-[NRLinkWiFi sendControlData:]_block_invoke",  1205LL,  v11);

LABEL_9:
        id WeakRetained = v16;
      }
    }
  }
}

void sub_100032ADC(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC740;
  qword_1001DC740 = (uint64_t)v1;
}

void sub_100032B0C(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void **)(a1 + 255);
    if (v2)
    {
      [v2 setClientQueue:*(void *)(a1 + 8)];
      objc_initWeak(location, (id)a1);
      id v3 = *(id *)(a1 + 255);
      v41[0] = _NSConcreteStackBlock;
      v41[1] = 3221225472LL;
      v41[2] = sub_100032F84;
      v41[3] = &unk_1001AEC80;
      id v18 = &v43;
      objc_copyWeak(&v43, location);
      id v4 = v3;
      id v42 = v4;
      [*(id *)(a1 + 255) setStateUpdateBlock:v41];
      v38[0] = _NSConcreteStackBlock;
      v38[1] = 3221225472LL;
      v38[2] = sub_100033744;
      v38[3] = &unk_1001AECA8;
      objc_copyWeak(&v40, location);
      id v5 = v4;
      id v39 = v5;
      [*(id *)(a1 + 255) setChildStateUpdateBlock:v38];
      v35[0] = _NSConcreteStackBlock;
      v35[1] = 3221225472LL;
      v35[2] = sub_100033900;
      v35[3] = &unk_1001AECD0;
      objc_copyWeak(&v37, location);
      id v6 = v5;
      id v36 = v6;
      [*(id *)(a1 + 255) setConfigurationUpdateBlock:v35];
      v32[0] = _NSConcreteStackBlock;
      v32[1] = 3221225472LL;
      v32[2] = sub_1000339C8;
      v32[3] = &unk_1001AECF8;
      objc_copyWeak(&v34, location);
      id v7 = v6;
      id v33 = v7;
      [*(id *)(a1 + 255) setTrafficSelectorUpdateBlock:v32];
      v29[0] = _NSConcreteStackBlock;
      v29[1] = 3221225472LL;
      v29[2] = sub_100033AB4;
      v29[3] = &unk_1001AED20;
      objc_copyWeak(&v31, location);
      id v8 = v7;
      id v30 = v8;
      [*(id *)(a1 + 255) setAdditionalAddressesUpdateBlock:v29];
      v26[0] = _NSConcreteStackBlock;
      v26[1] = 3221225472LL;
      v26[2] = sub_100033B7C;
      v26[3] = &unk_1001B0798;
      objc_copyWeak(&v28, location);
      id v9 = v8;
      id v27 = v9;
      [*(id *)(a1 + 255) setShortDPDEventBlock:v26];
      uint64_t v20 = _NSConcreteStackBlock;
      uint64_t v21 = 3221225472LL;
      id v22 = sub_100033C3C;
      id v23 = &unk_1001AED20;
      objc_copyWeak(&v25, location);
      id v10 = v9;
      id v24 = v10;
      [*(id *)(a1 + 255) setPrivateNotifyStatusEvent:&v20];
      uint64_t v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v11);
      LOBYTE(v3) = _NRLogIsLevelEnabled(v12, 0LL);

      if ((v3 & 1) != 0)
      {
        uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v13);
        id v15 = [(id)a1 copyDescription];
        _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d %@: Setup IKE classC callbacks %@",  "",  "-[NRLinkWiFi setupIKECallbacksClassC]",  984LL,  v15,  v10,  &v43,  v20,  v21,  v22,  v23);
      }

      objc_destroyWeak(&v25);
      objc_destroyWeak(&v28);

      objc_destroyWeak(&v31);
      objc_destroyWeak(&v34);

      objc_destroyWeak(&v37);
      objc_destroyWeak(&v40);

      objc_destroyWeak(v18);
      objc_destroyWeak(location);
    }

    else
    {
      id v16 = sub_10003295C();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v16, 17LL);

      if (IsLevelEnabled)
      {
        id v19 = sub_10003295C();
        _NRLogWithArgs(v19, 17LL, "%s called with null _ikeSessionClassC", "-[NRLinkWiFi setupIKECallbacksClassC]");
      }
    }
  }

void sub_100032F04( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id *location)
{
}

void sub_100032F84(uint64_t a1, uint64_t a2, void *a3)
{
  id v76 = a3;
  id WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 40));
  if (!WeakRetained) {
    goto LABEL_59;
  }
  if (v76)
  {
    if (([WeakRetained ikeClassCEstablished] & 1) == 0)
    {
      uint64_t v6 = mach_absolute_time();
      uint64_t v7 = *(void *)(WeakRetained + 271);
      if (v7) {
        *(void *)(v7 + 40) = v6;
      }
    }

    [WeakRetained setIkeClassDEstablished:0];
    [WeakRetained setIkeClassCEstablished:0];
    WeakRetained[83] = 0;
    uint64_t v8 = NEIKEv2ErrorDomain;
    id v9 = v76;
    if ([v9 code] == (id)4)
    {
      id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 domain]);
      unsigned int v11 = [v10 isEqualToString:v8];

      if (v11)
      {
        uint64_t v12 = *(void *)(a1 + 32);
        SessionStateid String = (void *)NEIKEv2CreateSessionStateString(a2);
        [WeakRetained cancelWithReason:@"ClassC session %@ got IKE error %@ with state %@", v12, v9, SessionStateString];
LABEL_58:

        goto LABEL_59;
      }
    }

    else
    {
    }

    uint64_t v22 = *(void *)(a1 + 32);
    id v23 = (void *)NEIKEv2CreateSessionStateString(a2);
    [WeakRetained reportEvent:3018, @"ClassC session %@ got IKE error %@ with state %@", v22, v9, v23 detailsFormat];

    [WeakRetained processIKEDisconnection:3 error:v9];
    id v24 = v9;
    if ([v24 code] == (id)24)
    {
      uint64_t v25 = NEIKEv2ProtocolErrorDomain;
      uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v24 domain]);
      LOBYTE(v25) = [v26 isEqualToString:v25];

      if ((v25 & 1) != 0) {
        goto LABEL_22;
      }
    }

    else
    {
    }

    id v27 = v24;
    if ([v27 code] == (id)8)
    {
      id v28 = (void *)objc_claimAutoreleasedReturnValue([v27 domain]);
      unsigned int v29 = [v28 isEqualToString:v8];

      if (v29)
      {
LABEL_22:
        sub_100033ED4(WeakRetained);
        goto LABEL_59;
      }
    }

    else
    {
    }

    sub_100033FFC((uint64_t)WeakRetained);
    goto LABEL_59;
  }

  uint64_t v14 = *(void *)(a1 + 32);
  id v15 = (void *)NEIKEv2CreateSessionStateString(a2);
  [WeakRetained reportEvent:3009, @"ClassC session %@ changed state to %@", v14, v15 detailsFormat];

  switch(a2)
  {
    case 1LL:
      if ([WeakRetained state] == 1)
      {
        uint64_t v17 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v16);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v17, 0LL);

        if (IsLevelEnabled)
        {
          uint64_t v20 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v19);
          id v21 = [WeakRetained copyDescription];
          _NRLogWithArgs( v20,  0LL,  "%s%.30s:%-4d %@: ClassC IKE %@ now connecting",  "",  "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke",  836LL,  v21,  *(void *)(a1 + 32));
        }

        [WeakRetained changeStateTo:5];
      }

      else
      {
        unsigned int v39 = [WeakRetained state];
        uint64_t v41 = _NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v40);
        id v42 = (void *)v41;
        if (v39 == 5)
        {
          int v43 = _NRLogIsLevelEnabled(v41, 0LL);

          if (!v43) {
            break;
          }
          uint64_t v45 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v44);
          id v46 = [WeakRetained copyDescription];
          _NRLogWithArgs( v45,  0LL,  "%s%.30s:%-4d %@: ClassC IKE %@ already connecting",  "",  "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke",  839LL,  v46,  *(void *)(a1 + 32));
        }

        else
        {
          int v67 = _NRLogIsLevelEnabled(v41, 16LL);

          if (!v67) {
            break;
          }
          uint64_t v45 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v68);
          id v46 = [WeakRetained copyDescription];
          _NRLogWithArgs( v45,  16LL,  "%s%.30s:%-4d %@: ClassC IKE %@ connecting but weird state",  "",  "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke",  841LL,  v46,  *(void *)(a1 + 32));
        }
      }

      break;
    case 2LL:
      [WeakRetained setIkeClassDEstablished:1];
      [WeakRetained setIkeClassCEstablished:1];
      unsigned int v30 = [WeakRetained state];
      uint64_t v32 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v31);
      int v33 = _NRLogIsLevelEnabled(v32, 0LL);

      if (v30 == 8)
      {
        if (v33)
        {
          uint64_t v35 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v34);
          id v36 = [WeakRetained copyDescription];
          _NRLogWithArgs( v35,  0LL,  "%s%.30s:%-4d %@: ClassC IKE %@ already ready",  "",  "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke",  847LL,  v36,  *(void *)(a1 + 32));
        }
      }

      else
      {
        if (v33)
        {
          __int128 v47 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v34);
          id v48 = [WeakRetained copyDescription];
          _NRLogWithArgs( v47,  0LL,  "%s%.30s:%-4d %@: ClassC IKE %@ now connected from started",  "",  "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke",  849LL,  v48,  *(void *)(a1 + 32));
        }

        [WeakRetained setPowerAssertionState:0];
        [WeakRetained changeStateTo:8, @"(ClassC IKE %@ connected after received first notify)", *(void *)(a1 + 32) detailsFormat];
        uint64_t v49 = mach_absolute_time();
        uint64_t v50 = *(void *)(WeakRetained + 271);
        if (v50) {
          *(void *)(v50 + 40) = v49;
        }
        *(_DWORD *)(WeakRetained + 223) = 0;
        sub_100034D58(WeakRetained);
        if ([WeakRetained shouldCreateCompanionProxyAgent])
        {
          uint64_t v51 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained companionProxyAgent]);

          if (!v51)
          {
            id v52 = (void *)NEVirtualInterfaceCopyName([WeakRetained virtualInterface]);
            uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained nrUUID]);
            objc_super v54 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v53);
            __int128 v55 = v54;
            if (v54) {
              __int128 v56 = (void *)*((void *)v54 + 14);
            }
            else {
              __int128 v56 = 0LL;
            }
            id v57 = v56;

            if (v52 && v57)
            {
              id v58 = objc_alloc(&OBJC_CLASS___NRCompanionProxyAgent);
              int v59 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained queue]);
              id v60 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained nrUUID]);
              id v61 = sub_10005E638((id *)&v58->super.isa, v59, v52, v57, v60);
              id v62 = (void *)*((void *)WeakRetained + 11);
              *((void *)WeakRetained + 11) = v61;

              [WeakRetained reportEvent:12001];
            }
          }

          int v63 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained companionProxyAgent]);
          char v65 = sub_10005E944((uint64_t)v63, v64);

          if ((v65 & 1) != 0)
          {
            [WeakRetained reportEvent:12002];
          }

          else
          {
            unint64_t v69 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v66);
            int v70 = _NRLogIsLevelEnabled(v69, 16LL);

            if (v70)
            {
              id v72 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v71);
              id v73 = [WeakRetained copyDescription];
              _NRLogWithArgs( v72,  16LL,  "%s%.30s:%-4d %@: failed to register companion agent",  "",  "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke",  873LL,  v73);
            }
          }
        }
      }

      SessionStateid String = (void *)objc_claimAutoreleasedReturnValue([WeakRetained linkDelegate]);
      [SessionStateString linkIsReady:WeakRetained];
      goto LABEL_58;
    case 3LL:
      if (([WeakRetained ikeClassCEstablished] & 1) == 0)
      {
        uint64_t v37 = mach_absolute_time();
        uint64_t v38 = *(void *)(WeakRetained + 271);
        if (v38) {
          *(void *)(v38 + 40) = v37;
        }
      }

      [WeakRetained setIkeClassDEstablished:0];
      [WeakRetained setIkeClassCEstablished:0];
      WeakRetained[83] = 0;
      [WeakRetained reportEvent:3018, @"ClassC session %@ cancelled by peer", *(void *)(a1 + 32) detailsFormat];
      [WeakRetained cancelWithReason:@"ClassC session %@ cancelled by peer"];
      break;
    case 4LL:
      [WeakRetained cancelWithReason:@"ClassC session %@ got unexpected MOBIKE state", *(void *)(a1 + 32)];
      break;
    default:
      SessionStateid String = (void *)NEIKEv2CreateSessionStateString(a2);
      [WeakRetained cancelWithReason:@"ClassC session %@ got bad IKE state %@", SessionStateString, v74, v75];
      goto LABEL_58;
  }

void sub_100033744(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v18 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    if (!v18)
    {
      uint64_t v13 = *(void *)(a1 + 32);
      if (a3 != 3)
      {
        SessionStateid String = (void *)NEIKEv2CreateSessionStateString(a3);
        [WeakRetained reportEvent:3009, @"ClassC session %@ child %u state update %@", v13, a2, SessionStateString detailsFormat];

        goto LABEL_16;
      }

      [WeakRetained reportEvent:3018, @"ClassC session %@ got child %u Disconnected state with no error", v13, a2 detailsFormat];
      goto LABEL_15;
    }

    uint64_t v8 = *(void *)(a1 + 32);
    id v9 = (void *)NEIKEv2CreateSessionStateString(a3);
    [WeakRetained reportEvent:3018, @"ClassC session %@ got child %u state update %@ error %@", v8, a2, v9, v18 detailsFormat];

    [WeakRetained processIKEDisconnection:3 error:v18];
    if ([WeakRetained state] != 255)
    {
      id v10 = v18;
      if ([v10 code] == (id)24)
      {
        uint64_t v11 = NEIKEv2ProtocolErrorDomain;
        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v10 domain]);
        LOBYTE(v11) = [v12 isEqualToString:v11];

        if ((v11 & 1) != 0) {
          goto LABEL_12;
        }
      }

      else
      {
      }

      id v14 = v10;
      if ([v14 code] == (id)8)
      {
        uint64_t v15 = NEIKEv2ErrorDomain;
        uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([v14 domain]);
        LODWORD(v15) = [v16 isEqualToString:v15];

        if ((_DWORD)v15)
        {
LABEL_12:
          sub_100033ED4((char *)WeakRetained);
          goto LABEL_16;
        }
      }

      else
      {
      }

void sub_100033900(uint64_t a1, void *a2)
{
  id v11 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v5 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

    if (IsLevelEnabled)
    {
      id v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      id v10 = [v5 copyDescription];
      _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: ClassC session %@ got config update %@",  "",  "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke_3",  943LL,  v10,  *(void *)(a1 + 32),  v11);
    }
  }
}

void sub_1000339C8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v16 = a3;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v10 = WeakRetained;
  if (WeakRetained)
  {
    id v11 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v9);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0LL);

    if (IsLevelEnabled)
    {
      id v14 = (void *)_NRCopyLogObjectForNRUUID(v10[4], v13);
      id v15 = [v10 copyDescription];
      _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d %@: ClassC session %@ got child %u traffic selector update local %@ remote %@",  "",  "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke_4",  954LL,  v15,  *(void *)(a1 + 32),  a2,  v16,  v7);
    }
  }
}

void sub_100033AB4(uint64_t a1, void *a2)
{
  id v11 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v5 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      id v10 = [v5 copyDescription];
      _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: ClassC session %@ got additional addresses %@",  "",  "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke_5",  962LL,  v10,  *(void *)(a1 + 32),  v11);
    }
  }
}

void sub_100033B7C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    uint64_t v9 = WeakRetained;
    uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v3);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

    id WeakRetained = v9;
    if (IsLevelEnabled)
    {
      id v7 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v6);
      id v8 = [v9 copyDescription];
      _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d %@: ClassC session %@ got short DPD",  "",  "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke_6",  970LL,  v8,  *(void *)(a1 + 32));

      id WeakRetained = v9;
    }
  }
}

void sub_100033C3C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = (void **)objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v6 = WeakRetained;
  if (WeakRetained)
  {
    id v7 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v5);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0LL);

    if (IsLevelEnabled)
    {
      id v10 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v9);
      id v11 = [v6 copyDescription];
      _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d %@: ClassC session %@ got private notifies %@",  "",  "-[NRLinkWiFi setupIKECallbacksClassC]_block_invoke_7",  978LL,  v11,  *(void *)(a1 + 32),  v3);
    }

    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    id v27 = v3;
    id v12 = v3;
    id v13 = [v12 countByEnumeratingWithState:&v28 objects:v32 count:16];
    if (v13)
    {
      id v14 = v13;
      uint64_t v15 = *(void *)v29;
      do
      {
        for (uint64_t i = 0LL; i != v14; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v29 != v15) {
            objc_enumerationMutation(v12);
          }
          uint64_t v17 = *(void **)(*((void *)&v28 + 1) + 8LL * (void)i);
          unsigned int v18 = [v17 notifyStatus];
          id v19 = (id)objc_claimAutoreleasedReturnValue([v17 notifyData]);
          id v21 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v20);
          int v22 = _NRLogIsLevelEnabled(v21, 1LL);

          if (v22)
          {
            id v24 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v23);
            id v25 = [v6 copyDescription];
            _NRLogWithArgs( v24,  1LL,  "%s%.30s:%-4d %@: Received notify code %u %@",  "",  "-[NRLinkWiFi handleNotifyCode:payload:]",  1218LL,  v25,  v18,  v19);
          }

          if (v18 == 50701)
          {
            sub_100136084((uint64_t)&OBJC_CLASS___NRDLocalDevice, v19, v6[4]);
            [v6 checkProxyAgentWithForceUpdate:0];
          }

          else if (v18 == 50702)
          {
            uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v6 linkDelegate]);
            [v26 linkDidReceiveData:v6 data:v19];
          }
        }

        id v14 = [v12 countByEnumeratingWithState:&v28 objects:v32 count:16];
      }

      while (v14);
    }

    id v3 = v27;
  }
}

void sub_100033ED4(char *val)
{
  if (!val[209])
  {
    val[209] = 1;
    int v2 = *(_DWORD *)(val + 223);
    if ((5 * v2) >= 0x1F)
    {
      *(_DWORD *)(val + 223) = 0;
      int v2 = *(_DWORD *)(val + 223);
    }

    *(_DWORD *)(val + 223) = v2 + 1;
    objc_initWeak(&location, val);
    dispatch_time_t v3 = dispatch_time(0x8000000000000000LL, 1000000000LL * (5 * *(_DWORD *)(val + 223)));
    uint64_t v4 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([val queue]);
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472LL;
    v5[2] = sub_100034D1C;
    v5[3] = &unk_1001AFED0;
    objc_copyWeak(&v6, &location);
    dispatch_after(v3, v4, v5);

    objc_destroyWeak(&v6);
    objc_destroyWeak(&location);
  }

void sub_100033FE8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_100033FFC(uint64_t a1)
{
  if ([(id)a1 state] == 255)
  {
    uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

    if (IsLevelEnabled)
    {
      id v14 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v7);
      id v8 = [(id)a1 copyDescription];
      _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d %@: Not restarting ClassC session for cancelled link",  "",  "-[NRLinkWiFi restartIKESessionClassC]",  540LL,  v8);
    }
  }

  else
  {
    if ([(id)a1 state] == 8)
    {
      uint64_t v4 = @"restarting IKE session while link is ready";
LABEL_10:
      [(id)a1 cancelWithReason:v4];
      return;
    }

    uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v3);
    int v10 = _NRLogIsLevelEnabled(v9, 0LL);

    if (v10)
    {
      id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v11);
      id v13 = [(id)a1 copyDescription];
      _NRLogWithArgs( v12,  0LL,  "%s%.30s:%-4d %@: Restarting ClassC session",  "",  "-[NRLinkWiFi restartIKESessionClassC]",  549LL,  v13);
    }

    if (++*(_DWORD *)(a1 + 211) >= 0xAu)
    {
      uint64_t v4 = @"ClassC session hit max retries";
      goto LABEL_10;
    }

    v15.receiver = (id)a1;
    v15.super_class = (Class)&OBJC_CLASS___NRLinkWiFi;
    objc_msgSendSuper2(&v15, "invalidateIKESessionForClass:", 3);
    [(id)a1 setIkeClassDEstablished:0];
    *(_BYTE *)(a1 + 83) = 0;
    [(id)a1 invalidateIKESession:a1 + 255];
    *(_DWORD *)(a1 + 219) = 0;
    sub_1000341E0(a1);
  }

void sub_1000341E0(_BYTE *a1)
{
  uint64_t v1 = (uint64_t)a1;
  if (!a1[208])
  {
    if (a1[112] == 2)
    {
      if (![a1 hasCompanionDatapath] || objc_msgSend((id)v1, "virtualInterface"))
      {
        if (*(void *)(v1 + 255)) {
          return;
        }
        uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([(id)v1 nrUUID]);
        uint64_t v5 = (id *)sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v4);

        if (v5)
        {
          id v7 = v5[10];

          if (v7)
          {
            id v9 = sub_10010C0B8();
            sub_10010BDB0(v5, v9);
            int v10 = (void *)objc_claimAutoreleasedReturnValue([(id)v1 localInterfaceName]);
            [v9 setOutgoingInterfaceName:v10];

            uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue([(id)v1 remoteOuterEndpoint]);
            [v9 setRemoteEndpoint:v11];

            objc_msgSend(v9, "setRequestChildlessSA:", objc_msgSend((id)v1, "hasCompanionDatapath") ^ 1);
            id v12 = sub_10010C340();
            -[NEIKEv2ChildSAConfiguration setMode:](v12, "setMode:", 2LL);
            -[NEIKEv2ChildSAConfiguration setReplayWindowSize:](v12, "setReplayWindowSize:", 4LL);
            sub_10010BF54(v5, v12);
            [v9 setRandomizeLocalPort:1];
            id v13 = sub_10010C6B8(1, v5, 3LL);
            v44.receiver = (id)v1;
            v44.super_class = (Class)&OBJC_CLASS___NRLinkWiFi;
            objc_msgSendSuper2(&v44, "invalidateIKESessionForClass:", 3);
            [(id)v1 setIkeClassDEstablished:0];
            *(_BYTE *)(v1 + 83) = 0;
            [(id)v1 invalidateIKESession:v1 + 255];
            v44.receiver = 0LL;
            v44.super_class = (Class)&v44;
            int v46 = 0;
            uint64_t v45 = 0x2020000000LL;
            id v14 = objc_alloc(&OBJC_CLASS___NEIKEv2Session);
            uint64_t v15 = *(void *)(v1 + 8);
            v43[0] = _NSConcreteStackBlock;
            v43[1] = 3221225472LL;
            v43[2] = sub_100034884;
            v43[3] = &unk_1001AE618;
            v43[4] = &v44;
            id v16 = -[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName:packetDelegate:]( v14,  "initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessi onName:packetDelegate:",  v9,  v12,  v13,  v15,  [(id)v1 virtualInterface],  v43,  @"terminusIKE-WiFi-ClassC",  0);
            uint64_t v17 = *(void **)(v1 + 255);
            *(void *)(v1 + 255) = v16;

            if (*(void *)(v1 + 255))
            {
              sub_100032B0C(v1);
              unsigned int v18 = *(id *)(v1 + 271);
              if (v18) {
                ++v18[8];
              }

              uint64_t v19 = mach_absolute_time();
              uint64_t v20 = *(id *)(v1 + 271);
              if (v20) {
                v20[4] = v19;
              }

              [(id)v1 reportEvent:3015, @"ClassC %@", *(void *)(v1 + 255) detailsFormat];
              [*(id *)(v1 + 255) connect];
            }

            else
            {
              sub_1000348D4(v1, LODWORD(v44.super_class[3].isa));
            }

            _Block_object_dispose(&v44, 8);

            goto LABEL_21;
          }

          id v21 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 32), v8);
          int IsLevelEnabled = _NRLogIsLevelEnabled(v21, 0LL);

          if (!IsLevelEnabled)
          {
LABEL_21:

            return;
          }

          id v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 32), v23);
          id v25 = [(id)v1 copyDescription];
          _NRLogWithArgs( v24,  0LL,  "%s%.30s:%-4d %@: Not starting classC IKE initiator session because we do not have keys %@",  "",  "-[NRLinkWiFi setupIPsec]",  1010LL,  v25,  v5);
LABEL_20:

          goto LABEL_21;
        }

LABEL_30:
        uint64_t v38 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 32), v6);
        int v39 = _NRLogIsLevelEnabled(v38, 17LL);

        if (!v39) {
          goto LABEL_21;
        }
        id v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 32), v40);
        id v25 = [(id)v1 copyDescription];
        _NRLogWithArgs(v24, 17LL, "%@: Not starting classC IKE initiator session because localDevice is missing", v25);
        goto LABEL_20;
      }

      id v32 = sub_10003295C();
      int v33 = _NRLogIsLevelEnabled(v32, 16LL);

      if (v33)
      {
        id v34 = sub_10003295C();
        _NRLogWithArgs( v34,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (self.virtualInterface) != ((void *)0)",  "",  "-[NRLinkWiFi setupIPsec]",  997);
      }

      uint64_t v1 = _os_log_pack_size(12LL);
      uint64_t v5 = (id *)((char *)&v41 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL));
      uint64_t v35 = __error();
      uint64_t v36 = _os_log_pack_fill( v5,  v1,  *v35,  &_mh_execute_header,  "%{public}s Assertion Failed: (self.virtualInterface) != ((void *)0)");
      *(_DWORD *)uint64_t v36 = 136446210;
      *(void *)(v36 + 4) = "-[NRLinkWiFi setupIPsec]";
      id v37 = sub_10003295C();
      _NRLogAbortWithPack(v37, v5);
    }

    else
    {
      id v26 = sub_10003295C();
      int v27 = _NRLogIsLevelEnabled(v26, 16LL);

      if (v27)
      {
        id v28 = sub_10003295C();
        _NRLogWithArgs( v28,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: _ikev2Role == NRIKEv2RoleInitiator",  "",  "-[NRLinkWiFi setupIPsec]",  995);
      }

      uint64_t v1 = _os_log_pack_size(12LL);
      uint64_t v5 = (id *)((char *)&v41 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL));
      __int128 v29 = __error();
      uint64_t v30 = _os_log_pack_fill( v5,  v1,  *v29,  &_mh_execute_header,  "%{public}s Assertion Failed: _ikev2Role == NRIKEv2RoleInitiator");
      *(_DWORD *)uint64_t v30 = 136446210;
      *(void *)(v30 + 4) = "-[NRLinkWiFi setupIPsec]";
      id v31 = sub_10003295C();
      _NRLogAbortWithPack(v31, v5);
    }

    __break(1u);
    goto LABEL_30;
  }

  objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
  if (qword_1001DC640 != -1) {
    dispatch_once(&qword_1001DC640, &stru_1001ADE98);
  }
  id v42 = (id)qword_1001DC638;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([(id)v1 localInterfaceName]);
  uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([(id)v1 localOuterEndpoint]);
  sub_10000F230((uint64_t)v42, (void *)v1, v2, v3);
}

  -[NSMutableArray addObject:](v3, "addObject:", @"TxLrg");
  if ((a1 & 0x4000) == 0)
  {
LABEL_5:
    if ((a1 & 0x8000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_32;
  }

      id v42 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v33);
      int v43 = _NRLogIsLevelEnabled(v42, 1LL);

      if (v43)
      {
        uint64_t v45 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v44);
        int v46 = [(id)a1 copyDescription];
        _NRLogWithArgs( v45,  1LL,  "%s%.30s:%-4d %@: Wrote IKE packet #%llu of length %u to linkWriteBuffer filledIn=%u handled=%u",  "",  "-[NRLinkBluetooth sendIKEData:]",  7236LL,  v46,  *(void *)(a1 + 1583),  v2,  *(unsigned int *)(a1 + IsLevelEnabled[167]),  *(unsigned int *)(a1 + 291));
      }

      goto LABEL_24;
    }

    id v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v13);
    id v25 = _NRLogIsLevelEnabled(v24, 16LL);

    if (!v25)
    {
LABEL_22:
      a1 = 0LL;
    }

    else
    {
      int v27 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v26);
      id v28 = [(id)a1 copyDescription];
      _NRLogWithArgs( v27,  16LL,  "%s%.30s:%-4d %@: no room for IKEv2 packet, dropping it NR_LINK_WRITE_BUFFER_LEN=%u handledLinkWriteBufferBytes=% udiff=%u totalDataLen=%u ",  "",  "-[NRLinkBluetooth sendIKEData:]",  7225LL,  v28,  *(unsigned int *)(a1 + 287),  *(unsigned int *)(a1 + 291),  (*(_DWORD *)(a1 + 279) - *(_DWORD *)(a1 + 291)),  ((_DWORD)v2 + 5));

      a1 = 0LL;
    }
  }

          goto LABEL_31;
        }

        id v12 = 56LL;
      }

      *(void *)(v11 + v12) = v10;
      goto LABEL_18;
    }

    id v13 = *(void *)(a1 + 32);
    id v14 = *(void *)(a1 + 40);
    uint64_t v15 = (void *)NEIKEv2CreateSessionStateString(a2);
    [v7 reportEvent:3009, @"%@ session %@ changed state to %@", v13, v14, v15 detailsFormat];

    switch(a2)
    {
      case 1LL:
        uint64_t v17 = v7[16];
        if (v17 == 5)
        {
          uint64_t v49 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v16);
          int IsLevelEnabled = _NRLogIsLevelEnabled(v49, 0LL);

          if (!IsLevelEnabled) {
            goto LABEL_30;
          }
          id v52 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v51);
          uint64_t v53 = [v7 copyDescription];
          _NRLogWithArgs( v52,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ already connecting",  "",  "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke",  8058LL,  v53,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
        }

        else
        {
          if (v17 == 4)
          {
            unsigned int v18 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v16);
            uint64_t v19 = _NRLogIsLevelEnabled(v18, 0LL);

            if (v19)
            {
              id v21 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v20);
              int v22 = [v7 copyDescription];
              _NRLogWithArgs( v21,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ now connecting",  "",  "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke",  8055LL,  v22,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
            }

            [v7 changeStateTo:5];
            goto LABEL_30;
          }

          objc_super v54 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v16);
          __int128 v55 = _NRLogIsLevelEnabled(v54, 16LL);

          if (!v55) {
            goto LABEL_30;
          }
          id v52 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v56);
          uint64_t v53 = [v7 copyDescription];
          _NRLogWithArgs( v52,  16LL,  "%s%.30s:%-4d %@: %@ IKE %@ connecting but weird state",  "",  "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke",  8060LL,  v53,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
        }

        goto LABEL_30;
      case 2LL:
        id v42 = *(unsigned __int8 *)(a1 + 64);
        if (v42 == 4)
        {
          [v7 setIkeClassDEstablished:1];
          id v57 = mach_absolute_time();
          int v59 = *(void *)(v7 + 1863);
          if (v59) {
            *(void *)(v59 + 56) = v57;
          }
          if (v7[238])
          {
            id v60 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v58);
            id v61 = _NRLogIsLevelEnabled(v60, 0LL);

            if (v61)
            {
              int v63 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v62);
              uint64_t v64 = [v7 copyDescription];
              _NRLogWithArgs( v63,  0LL,  "%s%.30s:%-4d %@: Stopping %@ reconnection timer",  "",  "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke",  8077LL,  v64,  *(void *)(a1 + 32));
            }

            v7[238] = 0;
            if (!v7[239]) {
              [v7 setPowerAssertionState:0];
            }
          }

          char v65 = sub_1001438EC((uint64_t)&OBJC_CLASS___NRDKeyManager);
          if (!sub_100144404((BOOL)v65) && !v7[237])
          {
            uint64_t v66 = *(void *)(a1 + 48);
            if (v66) {
              *(_BYTE *)(v66 + 237) = 1;
            }
            objc_initWeak(location, v7);
            v97[0] = _NSConcreteStackBlock;
            v97[1] = 3221225472LL;
            v97[2] = sub_10007C0D4;
            v97[3] = &unk_1001AFED0;
            objc_copyWeak(&v98, location);
            sub_100144478((uint64_t)v65, v97);
            objc_destroyWeak(&v98);
            objc_destroyWeak(location);
          }
        }

        else if (v42 == 3)
        {
          [v7 setIkeClassCEstablished:1];
          int v43 = mach_absolute_time();
          objc_super v44 = *(void *)(v7 + 1863);
          if (v44) {
            *(void *)(v44 + 40) = v43;
          }
          if (v7[239])
          {
            uint64_t v45 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v16);
            int v46 = _NRLogIsLevelEnabled(v45, 0LL);

            if (v46)
            {
              __int128 v47 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v16);
              id v48 = [v7 copyDescription];
              _NRLogWithArgs( v47,  0LL,  "%s%.30s:%-4d %@: Stopping %@ reconnection timer",  "",  "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke",  8067LL,  v48,  *(void *)(a1 + 32));
            }

            v7[239] = 0;
            if (!v7[238]) {
              [v7 setPowerAssertionState:0];
            }
          }
        }

        switch(v7[16])
        {
          case 5:
            int v67 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v16);
            uint64_t v68 = _NRLogIsLevelEnabled(v67, 0LL);

            if (v68)
            {
              int v70 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v69);
              uint64_t v71 = [v7 copyDescription];
              _NRLogWithArgs( v70,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ now connected from started",  "",  "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke",  8123LL,  v71,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
            }

            [v7 changeStateTo:6];
            break;
          case 6:
            id v72 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v16);
            id v73 = _NRLogIsLevelEnabled(v72, 0LL);

            if (v73)
            {
              uint64_t v75 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v74);
              id v76 = [v7 copyDescription];
              _NRLogWithArgs( v75,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ already connected",  "",  "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke",  8135LL,  v76,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
              goto LABEL_85;
            }

            break;
          case 7:
            id v77 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v16);
            id v78 = _NRLogIsLevelEnabled(v77, 0LL);

            if (v78)
            {
              id v80 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v79);
              id v81 = [v7 copyDescription];
              _NRLogWithArgs( v80,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ now connected and ready from first notify",  "",  "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke",  8127LL,  v81,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
            }

            [v7 changeStateTo:8, @"(%@ IKE %@ connected after received first notify)", *(void *)(a1 + 32), *(void *)(a1 + 40) detailsFormat];
            [v8 linkIsReady:v7];
            [v7 checkProxyAgentWithForceUpdate:0];
            break;
          case 8:
            int v82 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v16);
            id v83 = _NRLogIsLevelEnabled(v82, 0LL);

            if (v83)
            {
              int v85 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v84);
              __int128 v86 = [v7 copyDescription];
              _NRLogWithArgs( v85,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ already ready",  "",  "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke",  8137LL,  v86,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
            }

            [v8 linkIsReady:v7];
            break;
          default:
            __int128 v87 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v16);
            __int128 v88 = _NRLogIsLevelEnabled(v87, 0LL);

            if (v88)
            {
              uint64_t v75 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v7 + 4), v89);
              id v76 = [v7 copyDescription];
              _NRLogWithArgs( v75,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ connected but weird state",  "",  "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke",  8140LL,  v76,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
LABEL_85:
            }

            break;
        }

        if (!v7[242])
        {
          id v90 = sub_100075D34((NSMutableArray *)v7, 0);
          int8x16_t v91 = sub_10007C250(v7);
          int8x16_t v92 = (void *)objc_claimAutoreleasedReturnValue(v91);
          if (v92) {
            -[NSMutableArray addObject:](v90, "addObject:", v92);
          }
          objc_initWeak(&from, v7);
          uint64_t v93 = *(void **)(v7 + 1223);
          uint64_t v94 = (void *)objc_claimAutoreleasedReturnValue([v7 queue]);
          location[0] = _NSConcreteStackBlock;
          location[1] = (id)3221225472LL;
          id location[2] = sub_10007C404;
          location[3] = &unk_1001AF950;
          objc_copyWeak(&v100, &from);
          [v93 sendPrivateNotifies:v90 maxRetries:10 retryIntervalInMilliseconds:10000 callbackQueue:v94 callback:location];

          objc_destroyWeak(&v100);
          objc_destroyWeak(&from);
        }

        NSUInteger v95 = *(unsigned __int8 *)(a1 + 64);
        id v96 = (void *)objc_claimAutoreleasedReturnValue([v7 nrUUID]);
        sub_10012FFF8((uint64_t)&OBJC_CLASS___NRDLocalDevice, v95, v96);

        goto LABEL_30;
      case 3LL:
        uint64_t v35 = *(unsigned __int8 *)(a1 + 64);
        switch(v35)
        {
          case 1:
            sub_10007BE6C(v7);
            break;
          case 3:
            [v7 setIkeClassCEstablished:0];
            uint64_t v36 = mach_absolute_time();
            id v37 = *(void *)(v7 + 1863);
            if (v37)
            {
              uint64_t v38 = 40LL;
LABEL_73:
              *(void *)(v37 + v3_Block_object_dispose((const void *)(v27 - 152), 8) = v36;
            }

            break;
          case 4:
            [v7 setIkeClassDEstablished:0];
            uint64_t v36 = mach_absolute_time();
            id v37 = *(void *)(v7 + 1863);
            if (!v37) {
              break;
            }
            uint64_t v38 = 56LL;
            goto LABEL_73;
          default:
            break;
        }

        [v7 reportEvent:3018, @"%@ session %@ got IKE Disconnected state with no error", *(void *)(a1 + 32), *(void *)(a1 + 40) detailsFormat];
        int v33 = *(unsigned __int8 *)(a1 + 64);
        id v34 = (uint64_t)v7;
        id v32 = 0;
        goto LABEL_29;
      case 4LL:
        [v7 cancelWithReason:@"%@ session %@ got unexpected MOBIKE state", *(void *)(a1 + 32), *(void *)(a1 + 40)];
        goto LABEL_30;
      default:
        int v39 = *(void *)(a1 + 32);
        uint64_t v40 = *(void *)(a1 + 40);
        uint64_t v41 = (void *)NEIKEv2CreateSessionStateString(a2);
        [v7 cancelWithReason:@"%@ session %@ got bad IKE state %@", v39, v40, v41];

        goto LABEL_30;
    }
  }
}

        goto LABEL_31;
      }
}
}

    if (!*(void *)(a1 + 416))
    {
      if ((sub_1000D5FC0(a1) & 1) != 0)
      {
        id v24 = objc_alloc(&OBJC_CLASS___NRDiscoveryClient);
        id v25 = *(void **)(a1 + 104);
        id v26 = *(id *)(a1 + 96);
        int v27 = v25;
        id v28 = sub_100113C7C((id *)&v24->super.isa, v27, v26);
        __int128 v29 = *(void **)(a1 + 416);
        *(void *)(a1 + 416) = v28;

        uint64_t v30 = *(void *)(a1 + 416);
        if (v30)
        {
          *(_BYTE *)(v30 + 15) = 1;
          id v31 = *(void *)(a1 + 416);
          if (v31) {
            *(_BYTE *)(v31 + 16) = 1;
          }
        }

        if (v13) {
          id v32 = (void *)*((void *)v13 + 16);
        }
        else {
          id v32 = 0LL;
        }
        int v33 = v32;
        id v34 = [v33 allowedPeerDeviceType];

        if (v34 != 255)
        {
          if (v13) {
            uint64_t v35 = (void *)*((void *)v13 + 16);
          }
          else {
            uint64_t v35 = 0LL;
          }
          uint64_t v36 = v35;
          id v37 = [v36 allowedPeerDeviceType];
          uint64_t v38 = *(void *)(a1 + 416);
          if (v38) {
            *(_BYTE *)(v38 + 1_Block_object_dispose((const void *)(v27 - 152), 8) = v37;
          }
        }

        if (*(_BYTE *)(a1 + 47))
        {
          if (qword_1001DC9B8 != -1) {
            dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
          }
          if (byte_1001DC9B0 && v13)
          {
            if (v13[15])
            {
              int v39 = 1;
            }

            else
            {
              objc_super v44 = v13[14] || *((unsigned __int16 *)v13 + 14) > 0x12u;
              int v39 = v44;
            }

            if (v13[12])
            {
              if (!v13[13]) {
                int v39 = 0;
              }
              if (v39 == 1)
              {
                uint64_t v45 = *(void *)(a1 + 416);
                if (v45) {
                  *(_BYTE *)(v45 + 17) = 1;
                }
              }
            }
          }
        }

        objc_initWeak(&location, (id)a1);
        objc_initWeak(&from, *(id *)(a1 + 416));
        int v46 = *(id *)(a1 + 416);
        v91[0] = _NSConcreteStackBlock;
        v91[1] = 3221225472LL;
        v91[2] = sub_1000D6084;
        v91[3] = &unk_1001AF5D8;
        objc_copyWeak(&v92, &location);
        objc_copyWeak(&v93, &from);
        __int128 v47 = v91;
        id v48 = v47;
        if (v46 && !*((_BYTE *)v46 + 19))
        {
          uint64_t v49 = objc_retainBlock(v47);
          uint64_t v50 = (void *)v46[9];
          v46[9] = v49;
        }

        uint64_t v51 = *(id *)(a1 + 416);
        v88[0] = _NSConcreteStackBlock;
        v88[1] = 3221225472LL;
        v88[2] = sub_1000D60FC;
        v88[3] = &unk_1001AF5D8;
        objc_copyWeak(&v89, &location);
        objc_copyWeak(&v90, &from);
        id v52 = v88;
        uint64_t v53 = v52;
        if (v51 && !*((_BYTE *)v51 + 19))
        {
          objc_super v54 = objc_retainBlock(v52);
          __int128 v55 = (void *)v51[10];
          v51[10] = v54;
        }

        __int128 v56 = *(id *)(a1 + 416);
        v85[0] = _NSConcreteStackBlock;
        v85[1] = 3221225472LL;
        v85[2] = sub_1000D6588;
        v85[3] = &unk_1001AF5D8;
        objc_copyWeak(&v86, &location);
        objc_copyWeak(&v87, &from);
        id v57 = v85;
        id v58 = v57;
        if (v56 && !*((_BYTE *)v56 + 19))
        {
          int v59 = objc_retainBlock(v57);
          id v60 = (void *)v56[11];
          v56[11] = v59;
        }

        id v61 = *(id *)(a1 + 96);
        int v63 = (void *)_NRCopyLogObjectForNRUUID(v61, v62);
        uint64_t v64 = _NRLogIsLevelEnabled(v63, 0LL);

        if ((v64 & 1) != 0)
        {
          char v65 = *(id *)(a1 + 96);
          int v67 = (void *)_NRCopyLogObjectForNRUUID(v65, v66);
          uint64_t v68 = (unsigned __int8 *)*(id *)(a1 + 416);
          unint64_t v69 = v68;
          if (v68) {
            int v70 = v68[15];
          }
          else {
            int v70 = 0;
          }
          uint64_t v71 = (unsigned __int8 *)*(id *)(a1 + 416);
          id v72 = v71;
          if (v71) {
            id v73 = v71[16];
          }
          else {
            id v73 = 0;
          }
          _NRLogWithArgs( v67,  0LL,  "%s%.30s:%-4d initiating discovery for devices (a:%d/b:%d)",  "",  "-[NRDDeviceConductor startDiscoveryIfNeeded]",  7631,  v70,  v73);
        }

        uint64_t v74 = *(id *)(a1 + 416);
        uint64_t v75 = v74;
        if (v74)
        {
          v74[19] = 1;
          objc_initWeak(v98, v74);
          v96[0] = _NSConcreteStackBlock;
          v96[1] = 3221225472LL;
          v96[2] = sub_100117864;
          v96[3] = &unk_1001AFED0;
          objc_copyWeak(&v97, v98);
          id v76 = objc_retainBlock(v96);
          id v77 = v76;
          if (v75[17])
          {
            ((void (*)(void *))v76[2])(v76);
          }

          else
          {
            objc_opt_self(&OBJC_CLASS___NRDKeyManager);
            if (qword_1001DCC18 != -1) {
              dispatch_once(&qword_1001DCC18, &stru_1001B0910);
            }
            id v78 = (id)qword_1001DCC10;
            sub_100144478((uint64_t)v78, v77);
          }

          objc_destroyWeak(&v97);
          objc_destroyWeak(v98);
        }

        objc_destroyWeak(&v87);
        objc_destroyWeak(&v86);
        objc_destroyWeak(&v90);
        objc_destroyWeak(&v89);
        objc_destroyWeak(&v93);
        objc_destroyWeak(&v92);
        objc_destroyWeak(&from);
        objc_destroyWeak(&location);
      }

      else
      {
        uint64_t v40 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v23);
        uint64_t v41 = _NRLogIsLevelEnabled(v40, 1LL);

        if (v41)
        {
          int v43 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v42);
          _NRLogWithArgs( v43,  1LL,  "%s%.30s:%-4d not eligible to use device discovery",  "",  "-[NRDDeviceConductor startDiscoveryIfNeeded]",  7588);
        }
      }
    }

    int v79 = *(void *)(a1 + 416);
    if (v79)
    {
      id v80 = *(void **)(v79 + 104);
      if (!v80)
      {
        id v81 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
        int v82 = *(void **)(v79 + 104);
        *(void *)(v79 + 104) = v81;

        id v80 = *(void **)(v79 + 104);
      }

      id v83 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  v8));
      [v80 addObject:v83];

      if (*(_BYTE *)(v79 + 19))
      {
        if (*(_BYTE *)(v79 + 20))
        {
          sub_10011439C(v79, v8);
          sub_100114AF8(v79, v8);
        }
      }
    }

    return;
  }

  id v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v6);
  int v10 = _NRLogIsLevelEnabled(v9, 16LL);

  if (v10)
  {
    id v84 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v11);
    _NRLogWithArgs(v84, 16LL, "%s%.30s:%-4d cannot use device discovery %u/%u");
LABEL_17:
  }

      int v10 = v10->ifa_next;
      if (!v10)
      {
        uint64_t v30 = v35;
        goto LABEL_78;
      }
    }
  }

  uint64_t v30 = 0LL;
  uint64_t v11 = 0LL;
LABEL_78:
  freeifaddrs(v30);
LABEL_79:

  return v11;
}
    }
  }
}

      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      id v21 = (id)qword_1001DCC20;
      int IsLevelEnabled = _NRLogIsLevelEnabled(v21, 17LL);

      if (IsLevelEnabled)
      {
        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        uint64_t v23 = (id)qword_1001DCC20;
        _NRLogWithArgs(v23, 17LL, "Cannot delete item %@ from keychain for %@", v9, String);
      }

      uint64_t v30 = 0;
      goto LABEL_60;
    }

    id v25 = sub_10014387C();
    id v26 = _NRLogIsLevelEnabled(v25, 17LL);

    if (v26)
    {
      int v27 = sub_10014387C();
      _NRLogWithArgs( v27,  17LL,  "%s called with null itemName",  "-[NRDKeyManager deleteDataFromKeychainWithName:nrUUID:dataProtectionClass:keychainLocked:]");
    }

    a1 = 0LL;
  }

void sub_100034868(_Unwind_Exception *a1)
{
}

uint64_t sub_100034884(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = getpid();
  return NEHelperGetIKESocketWithResult(a3, a4, a5, v9, *(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

void sub_1000348D4(uint64_t a1, uint64_t a2)
{
  if ([(id)a1 subtype] == 103
    || [(id)a1 subtype] == 102
    || [(id)a1 subtype] == 104)
  {
    int64_t v4 = 1000000000LL;
  }

  else
  {
    int64_t v4 = 250000000LL;
  }

  if (*(_DWORD *)(a1 + 219) > 4u)
  {
    if (qword_1001DC748 != -1) {
      dispatch_once(&qword_1001DC748, &stru_1001AE638);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC740, 17LL))
    {
      if (qword_1001DC748 != -1) {
        dispatch_once(&qword_1001DC748, &stru_1001AE638);
      }
      id v7 = (id)qword_1001DC740;
      id v8 = [(id)a1 copyDescription];
      _NRLogWithArgs(v7, 17LL, "%@ IKE session creation hit max retries after error: [%d] %s", v8, a2, __strerrbuf);
    }

    [(id)a1 cancelWithReason:@"IKE session creation hit max retries"];
  }

  else
  {
    if ((_DWORD)a2 == 2 || (_DWORD)a2 == 51)
    {
      if (qword_1001DC748 != -1) {
        dispatch_once(&qword_1001DC748, &stru_1001AE638);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC740, 16LL))
      {
        if (qword_1001DC748 != -1) {
          dispatch_once(&qword_1001DC748, &stru_1001AE638);
        }
        id v5 = (id)qword_1001DC740;
        id v6 = [(id)a1 copyDescription];
        _NRLogWithArgs( v5,  16LL,  "%s%.30s:%-4d %@ IKE session creation retry %u after error: [%d] %s",  "",  "-[NRLinkWiFi retrySetupIPsec:]",  283LL,  v6,  *(unsigned int *)(a1 + 219),  a2,  __strerrbuf);
      }
    }

    else
    {
      if (qword_1001DC748 != -1) {
        dispatch_once(&qword_1001DC748, &stru_1001AE638);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC740, 17LL))
      {
        if (qword_1001DC748 != -1) {
          dispatch_once(&qword_1001DC748, &stru_1001AE638);
        }
        id v9 = (id)qword_1001DC740;
        id v10 = [(id)a1 copyDescription];
        _NRLogWithArgs( v9,  17LL,  "%@ IKE session creation retry %u after error: [%d] %s",  v10,  *(unsigned int *)(a1 + 219),  a2,  __strerrbuf);
      }
    }

    [(id)a1 reportEvent:3026];
    objc_initWeak(__strerrbuf, (id)a1);
    dispatch_time_t v11 = dispatch_time(0LL, v4);
    id v12 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([(id)a1 queue]);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100034CD8;
    block[3] = &unk_1001AFED0;
    objc_copyWeak(&v14, __strerrbuf);
    dispatch_after(v11, v12, block);

    objc_destroyWeak(&v14);
    objc_destroyWeak(__strerrbuf);
  }

void sub_100034CBC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, id location)
{
}

void sub_100034CD8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v3 = WeakRetained;
    BOOL v2 = [WeakRetained state] == 255;
    id WeakRetained = v3;
    if (!v2)
    {
      sub_1000341E0(v3);
      id WeakRetained = v3;
    }
  }
}

void sub_100034D1C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    WeakRetained[209] = 0;
    BOOL v2 = WeakRetained;
    sub_100033FFC((uint64_t)WeakRetained);
    id WeakRetained = v2;
  }
}

char *sub_100034D58(char *result)
{
  if (!result) {
    return result;
  }
  uint64_t v1 = result;
  if (!objc_opt_class(&OBJC_CLASS___NWNetworkOfInterestManager))
  {
    id v3 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v1 + 4), v2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0LL);

    if (IsLevelEnabled)
    {
      id v6 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v1 + 4), v5);
      id v7 = [v1 copyDescription];
      _NRLogWithArgs( v6,  0LL,  "%s%.30s:%-4d %@: SymptomPresentationFeed.framework not present, not starting NOI tracking.",  "",  "-[NRLinkWiFi startSymptomsNOIManagerTracking]",  565LL,  v7);
    }
  }

  if (*(void *)(v1 + 263)) {
    goto LABEL_8;
  }
  id v8 = objc_alloc_init(&OBJC_CLASS___NWNetworkOfInterestManager);
  id v9 = *(void **)(v1 + 263);
  *(void *)(v1 + 263) = v8;

  id v10 = *(void **)(v1 + 263);
  if (v10)
  {
    id v11 = v10;
    id v12 = (void *)objc_claimAutoreleasedReturnValue([v1 queue]);
    [v11 setQueue:v12];

    [*(id *)(v1 + 263) setDelegate:v1];
LABEL_8:
    uint64_t v13 = mach_absolute_time();
    uint64_t v14 = *(void *)(v1 + 271);
    if (v14)
    {
      *(void *)(v14 + 104) = v13;
      uint64_t v15 = *(id *)(v1 + 271);
      if (v15) {
        ++v15[12];
      }
    }

    else
    {
      uint64_t v15 = 0LL;
    }

    return (char *)[*(id *)(v1 + 263) trackNOIAnyForInterfaceType:1 options:0];
  }

  if (qword_1001DC748 != -1) {
    dispatch_once(&qword_1001DC748, &stru_1001AE638);
  }
  CFTypeRef result = (char *)_NRLogIsLevelEnabled(qword_1001DC740, 17LL);
  if ((_DWORD)result)
  {
    if (qword_1001DC748 != -1) {
      dispatch_once(&qword_1001DC748, &stru_1001AE638);
    }
    return (char *)_NRLogWithArgs(qword_1001DC740, 17LL, "[[NWNetworkOfInterestManager alloc] init] failed");
  }

  return result;
}

void sub_100034F7C(uint64_t a1, int a2)
{
  id WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    unsigned int v18 = WeakRetained;
    BOOL v4 = [WeakRetained state] == 255;
    id WeakRetained = v18;
    if (!v4)
    {
      v18[83] = 0;
      if (!a2)
      {
        uint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v18 + 4), v5);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v13, 0LL);

        if (IsLevelEnabled)
        {
          id v16 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v18 + 4), v15);
          id v17 = [v18 copyDescription];
          _NRLogWithArgs( v16,  0LL,  "%s%.30s:%-4d %@: peer is NOT available",  "",  "-[NRLinkWiFi checkPeerAvailabilityWithForceAggressive:]_block_invoke",  756LL,  v17);
        }

        [v18 cancelWithReason:@"Dead Peer Detection"];
        goto LABEL_11;
      }

      id v6 = *(id *)(v18 + 271);
      if (v6) {
        ++v6[15];
      }

      id v8 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v18 + 4), v7);
      int v9 = _NRLogIsLevelEnabled(v8, 0LL);

      id WeakRetained = v18;
      if (v9)
      {
        id v11 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v18 + 4), v10);
        id v12 = [v18 copyDescription];
        _NRLogWithArgs( v11,  0LL,  "%s%.30s:%-4d %@: peer is available",  "",  "-[NRLinkWiFi checkPeerAvailabilityWithForceAggressive:]_block_invoke",  754LL,  v12);

LABEL_11:
        id WeakRetained = v18;
      }
    }
  }
}

void sub_1000350FC(uint64_t a1, uint64_t a2)
{
  if (a1 && *(_DWORD *)(a1 + 231) != -1)
  {
    if (&_symptom_new)
    {
      if ([(id)a1 hasCompanionDatapath])
      {
        uint64_t v3 = NEVirtualInterfaceCopyName([(id)a1 virtualInterface]);
        if (v3) {
          goto LABEL_6;
        }
      }

      else
      {
        uint64_t v3 = objc_claimAutoreleasedReturnValue([(id)a1 localInterfaceName]);
        if (v3)
        {
LABEL_6:
          id v27 = (id)v3;
          if (qword_1001DCA08 != -1) {
            dispatch_once(&qword_1001DCA08, &stru_1001AFC08);
          }
          uint64_t v5 = symptom_new(qword_1001DCA00, 438274LL);
          if (!v5)
          {
            if (qword_1001DC748 != -1) {
              dispatch_once(&qword_1001DC748, &stru_1001AE638);
            }
            if (_NRLogIsLevelEnabled(qword_1001DC740, 17LL))
            {
              if (qword_1001DC748 != -1) {
                dispatch_once(&qword_1001DC748, &stru_1001AE638);
              }
              _NRLogWithArgs(qword_1001DC740, 17LL, "symptom_new failed");
            }

            goto LABEL_29;
          }

          uint64_t v6 = v5;
          symptom_set_additional_qualifier(v5, 0, [v27 length], objc_msgSend(v27, "UTF8String"));
          int v7 = symptom_send(v6);
          notify_cancel(*(_DWORD *)(a1 + 231));
          *(_DWORD *)(a1 + 231) = -1;
          uint64_t v9 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v8);
          uint64_t v10 = (void *)v9;
          if (v7)
          {
            int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 17LL);

            if (IsLevelEnabled)
            {
              uint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v12);
              id v14 = [(id)a1 copyDescription];
              _NRLogWithArgs(v13, 17LL, "%@: failed to send symptom to stop link monitoring", v14);
LABEL_28:
            }
          }

          else
          {
            int v25 = _NRLogIsLevelEnabled(v9, 0LL);

            if (v25)
            {
              uint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v26);
              id v14 = [(id)a1 copyDescription];
              _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d %@: successfully sent symptom to stop link monitoring on interface: %@",  "",  "-[NRLinkWiFi stopSymptomsMonitor]",  699LL,  v14,  v27);
              goto LABEL_28;
            }
          }

void sub_100035434(uint64_t a1, uint64_t a2)
{
  id WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v15 = WeakRetained;
    if ([WeakRetained state] == 255)
    {
      uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v15 + 4), v4);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

      id WeakRetained = v15;
      if (IsLevelEnabled)
      {
        uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v15 + 4), v7);
        id v9 = [v15 copyDescription];
        _NRLogWithArgs( v8,  0LL,  "%s%.30s:%-4d %@: Ignoring notify update as link is cancelled",  "",  "-[NRLinkWiFi startSymptomsMonitor]_block_invoke",  635LL,  v9);

        goto LABEL_9;
      }
    }

    else
    {
      if (*(_DWORD *)(v15 + 231) == (_DWORD)a2)
      {
        objc_msgSend(v15, "reportEvent:detailsFormat:", 11004, @"#%u", ++*(_DWORD *)(v15 + 227));
        [v15 checkPeerAvailabilityWithForceAggressive:0];
LABEL_9:
        id WeakRetained = v15;
        goto LABEL_10;
      }

      uint64_t v10 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v15 + 4), v4);
      int v11 = _NRLogIsLevelEnabled(v10, 0LL);

      id WeakRetained = v15;
      if (v11)
      {
        uint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v15 + 4), v12);
        id v14 = [v15 copyDescription];
        _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d %@: Ignoring notify update (%d != %d)",  "",  "-[NRLinkWiFi startSymptomsMonitor]_block_invoke",  641LL,  v14,  *(unsigned int *)(v15 + 231),  a2);

        goto LABEL_9;
      }
    }
  }

void sub_1000355E8(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 32));
    uint64_t v3 = objc_alloc_init(&OBJC_CLASS___NRPairingParameters);
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 localInterfaceName]);
    if (v3) {
      objc_storeStrong((id *)&v3->_localInterfaceName, v4);
    }

    uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 localOuterEndpoint]);
    if (v3) {
      objc_storeStrong((id *)&v3->_localEndpoint, v5);
    }

    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 remoteOuterEndpoint]);
    uint64_t v7 = v6;
    if (v3)
    {
      objc_storeStrong((id *)&v3->_remoteEndpoint, v6);

      v3->_isResponder = *(_BYTE *)(a1 + 208);
      v3->_serializeIKESessions = 1;
      v3->_deferIKESessionInvalidation = *(_BYTE *)(a1 + 208);
    }

    else
    {
    }

    objc_initWeak(&location, (id)a1);
    uint64_t v8 = sub_10000AE08( (id *)objc_alloc(&OBJC_CLASS___NRPairingClient),  *(void **)(a1 + 8),  *(void **)(a1 + 32),  (__objc2_meth_list **)v3);
    objc_initWeak(&from, v8);
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472LL;
    v19[2] = sub_100035FB0;
    v19[3] = &unk_1001AF2B0;
    objc_copyWeak(&v20, &location);
    objc_copyWeak(&v21, &from);
    id v9 = v19;
    uint64_t v10 = v9;
    if (v8 && !*((_BYTE *)v8 + 10))
    {
      int v11 = objc_retainBlock(v9);
      id v12 = v8[18];
      v8[18] = v11;
    }

    sub_10000B180((uint64_t)v8);
    objc_storeStrong((id *)(a1 + 287), v8);
    id v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v13);
    char IsLevelEnabled = _NRLogIsLevelEnabled(v14, 0LL);

    if ((IsLevelEnabled & 1) != 0)
    {
      uint64_t v17 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v16);
      id v18 = [(id)a1 copyDescription];
      _NRLogWithArgs( v17,  0LL,  "%s%.30s:%-4d %@: initiated pairing with %@",  "",  "-[NRLinkWiFi initiatePairing]",  450LL,  v18,  v2);
    }

    objc_destroyWeak(&v21);
    objc_destroyWeak(&v20);
    objc_destroyWeak(&from);

    objc_destroyWeak(&location);
  }

void sub_100035850(_Unwind_Exception *a1)
{
}

void sub_100035884(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
      id v7 = [(id)a1 copyDescription];
      _NRLogWithArgs( v6,  0LL,  "%s%.30s:%-4d %@: initiating connection with peer",  "",  "-[NRLinkWiFi initiateConnection]",  455LL,  v7);
    }

    if (*(_BYTE *)(a1 + 208)) {
      goto LABEL_5;
    }
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 remoteOuterEndpoint]);

    if (v8)
    {
      if ([(id)a1 setupVirtualInterface])
      {
        [(id)a1 setPowerAssertionState:1];
LABEL_5:
        [(id)a1 reportEvent:3001];
        sub_1000341E0((_BYTE *)a1);
        return;
      }

      if ([(id)a1 state] != 255)
      {
        uint64_t v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v9);
        int v11 = _NRLogIsLevelEnabled(v10, 0LL);

        if (v11)
        {
          uint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v12);
          id v14 = [(id)a1 copyDescription];
          _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d %@: Retrying IPsec interface creation",  "",  "-[NRLinkWiFi retrySetupVirtualInterface]",  238LL,  v14);
        }

        if (++*(_DWORD *)(a1 + 215) > 9u)
        {
          uint64_t v17 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v12);
          int v18 = _NRLogIsLevelEnabled(v17, 17LL);

          if (v18)
          {
            id v20 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v19);
            id v21 = [(id)a1 copyDescription];
            _NRLogWithArgs(v20, 17LL, "%@: IPsec interface setup hit max retries", v21);
          }

          [(id)a1 cancelWithReason:@"IPsec interface setup hit max retries"];
        }

        else
        {
          [(id)a1 reportEvent:3025];
          objc_initWeak(&location, (id)a1);
          dispatch_time_t v15 = dispatch_time(0LL, 250000000LL);
          uint64_t v16 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([(id)a1 queue]);
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472LL;
          block[2] = sub_100035F60;
          block[3] = &unk_1001AFED0;
          objc_copyWeak(&v23, &location);
          dispatch_after(v15, v16, block);

          objc_destroyWeak(&v23);
          objc_destroyWeak(&location);
        }
      }
    }

    else
    {
      [(id)a1 cancelWithReason:@"No remote outer endpoint present"];
    }
  }

void sub_100035B5C(_Unwind_Exception *a1)
{
}

void sub_100035B70(uint64_t a1)
{
  if (a1 && !*(void *)(a1 + 295))
  {
    bonjour_service = nw_browse_descriptor_create_bonjour_service("_nr._tcp", "local");
    uint64_t v3 = nw_parameters_create();
    nw_parameters_set_use_awdl(v3, 1LL);
    uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 localInterfaceName]);
    uint64_t v5 = (nw_interface *)nw_interface_create_with_name([v4 UTF8String]);
    nw_parameters_require_interface(v3, v5);
    uint64_t v6 = nw_browser_create(bonjour_service, v3);
    objc_initWeak(&location, (id)a1);
    state_changed_handler[0] = _NSConcreteStackBlock;
    state_changed_handler[1] = 3221225472LL;
    state_changed_handler[2] = sub_100035DC8;
    state_changed_handler[3] = &unk_1001AE5C8;
    objc_copyWeak(&v17, &location);
    nw_browser_set_state_changed_handler(v6, state_changed_handler);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472LL;
    handler[2] = sub_100035EA0;
    handler[3] = &unk_1001AE5F0;
    objc_copyWeak(&v15, &location);
    nw_browser_set_browse_results_changed_handler(v6, handler);
    id v7 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([(id)a1 queue]);
    nw_browser_set_queue(v6, v7);

    nw_browser_start(v6);
    objc_storeStrong((id *)(a1 + 295), v6);
    uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v8);
    char IsLevelEnabled = _NRLogIsLevelEnabled(v9, 0LL);

    if ((IsLevelEnabled & 1) != 0)
    {
      uint64_t v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v11);
      id v13 = [(id)a1 copyDescription];
      _NRLogWithArgs( v12,  0LL,  "%s%.30s:%-4d %@: started AWDL browser",  "",  "-[NRLinkWiFi startAWDLBrowser]",  534LL,  v13);
    }

    objc_destroyWeak(&v15);
    objc_destroyWeak(&v17);
    objc_destroyWeak(&location);
  }

void sub_100035D98(_Unwind_Exception *a1)
{
}

void sub_100035DC8(uint64_t a1, uint64_t a2, void *a3)
{
  id v13 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v6 = WeakRetained;
  if (WeakRetained)
  {
    if ([WeakRetained state] != 255)
    {
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v7);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 0LL);

      if (IsLevelEnabled)
      {
        uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v10);
        id v12 = [v6 copyDescription];
        _NRLogWithArgs( v11,  0LL,  "%s%.30s:%-4d %@: browser entered state: %u (%@)",  "",  "-[NRLinkWiFi startAWDLBrowser]_block_invoke",  520LL,  v12,  a2,  v13);
      }
    }
  }
}

void sub_100035EA0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v9 = WeakRetained;
    BOOL v2 = [WeakRetained state] == 255;
    id WeakRetained = v9;
    if (!v2)
    {
      uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v3);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

      id WeakRetained = v9;
      if (IsLevelEnabled)
      {
        uint64_t v7 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v6);
        id v8 = [v9 copyDescription];
        _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d %@: browser results changed",  "",  "-[NRLinkWiFi startAWDLBrowser]_block_invoke_2",  529LL,  v8);

        id WeakRetained = v9;
      }
    }
  }
}

void sub_100035F60(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v3 = WeakRetained;
    BOOL v2 = [WeakRetained state] == 255;
    id WeakRetained = v3;
    if (!v2)
    {
      [v3 setStartRequested:0];
      [v3 start];
      id WeakRetained = v3;
    }
  }
}

void sub_100035FB0(uint64_t a1, int a2, unsigned int a3)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v7 = WeakRetained;
  if (WeakRetained)
  {
    id v20 = WeakRetained;
    unsigned int v8 = [WeakRetained state];
    uint64_t v7 = v20;
    if (v8 != 255)
    {
      uint64_t v9 = objc_loadWeakRetained((id *)(a1 + 40));
      uint64_t v10 = v9[6];
      uint64_t v11 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
      id v13 = v11;
      if ((v10 & 1) != 0)
      {
        -[NSMutableString appendFormat:](v11, "appendFormat:", @"PairingSessionConnected | ");
        if ((v10 & 2) == 0)
        {
LABEL_7:
          if ((v10 & 4) == 0) {
            goto LABEL_8;
          }
          goto LABEL_15;
        }
      }

      else if ((v10 & 2) == 0)
      {
        goto LABEL_7;
      }

      -[NSMutableString appendFormat:](v13, "appendFormat:", @"ClassDVerified | ");
      if ((v10 & 4) == 0)
      {
LABEL_8:
        if ((v10 & 8) == 0) {
          goto LABEL_9;
        }
        goto LABEL_16;
      }

LABEL_18:
        else {
          id v14 = *(&off_1001ADE60 + (a2 - 1));
        }
        id v15 = (void *)_NRCopyLogObjectForNRUUID(v20[4], v12);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v15, 0LL);

        if (IsLevelEnabled)
        {
          int v18 = (void *)_NRCopyLogObjectForNRUUID(v20[4], v17);
          id v19 = [v20 copyDescription];
          _NRLogWithArgs( v18,  0LL,  "%s%.30s:%-4d %@: pairing client state: %@ mask: %@",  "",  "-[NRLinkWiFi initiatePairing]_block_invoke",  443LL,  v19,  v14,  v13);
        }

        if (a2 == 5) {
          sub_100035884((uint64_t)v20, v17);
        }
        goto LABEL_27;
      }

    *(_BYTE *)(a1 + 212) = 0;
    *(_BYTE *)(a1 + 20_Block_object_dispose((const void *)(v1 - 104), 8) = 0;
    *(_BYTE *)(a1 + 213) = 0;
LABEL_19:
    sub_10003B930(a1);
    uint64_t v16 = *(dispatch_source_s **)(a1 + 607);
    if (v16)
    {
      dispatch_source_cancel(v16);
      uint64_t v17 = *(void **)(a1 + 607);
      *(void *)(a1 + 607) = 0LL;
    }
  }
}

  uint64_t v40 = *(void *)(a1 + 32);
  if (v40) {
    sub_100076BD8(v40, 4LL, 0, 0);
  }
}

  uint64_t v40 = *(void *)(a1 + 32);
  if (v40) {
    sub_100076BD8(v40, 3LL, 0, 0);
  }
}

  uint64_t v40 = *(void *)(a1 + 32);
  if (v40) {
    sub_100076BD8(v40, 1LL, 0, 0);
  }
}

  uint64_t v40 = *(void *)(a1 + 32);
  if (v40) {
    sub_100076BD8(v40, 4LL, 0, 0);
  }
}

  uint64_t v40 = *(void *)(a1 + 32);
  if (v40) {
    sub_100076BD8(v40, 3LL, 0, 0);
  }
}

  uint64_t v40 = *(void *)(a1 + 32);
  if (v40)
  {
    *(_BYTE *)(v40 + 235) = 0;
    uint64_t v41 = *(void *)(a1 + 32);
    if (v41) {
      sub_100076BD8(v41, 1LL, 0, 0);
    }
  }
}

          -[NSMutableArray addObject:](v31, "addObject:", v32);
        }

        id v28 = [obj countByEnumeratingWithState:&v84 objects:v89 count:16];
      }

      while (v28);
    }

    if (-[NSMutableArray count](v25, "count"))
    {
      id v42 = v73;
      if (p_class_meths[278] != (__objc2_meth_list *)-1LL) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      id v15 = v72;
      uint64_t v16 = v70;
      id v24 = v71;
      if (_NRLogIsLevelEnabled(qword_1001DC8A8, 1LL))
      {
        if (qword_1001DC8B0 != -1) {
          dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
        }
        int v43 = (id)qword_1001DC8A8;
        if (-[NSMutableArray count](v25, "count") == (id)1)
        {
          objc_super v44 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray objectAtIndexedSubscript:](v25, "objectAtIndexedSubscript:", 0LL));
          _NRLogWithArgs( v43,  1LL,  "%s%.30s:%-4d responding to seqno req with existing routes %@",  "",  "-[NRBabelInstance handleSeqnoReqFromAddr:babelInterface:ForPrefix:plen:routerID:seqno:hopCount:]",  3162LL,  v44);
        }

        else
        {
          _NRLogWithArgs( v43,  1LL,  "%s%.30s:%-4d responding to seqno req with existing routes %@",  "",  "-[NRBabelInstance handleSeqnoReqFromAddr:babelInterface:ForPrefix:plen:routerID:seqno:hopCount:]",  3162LL,  v25);
        }
      }

      uint64_t v49 = v75;
      uint64_t v50 = v25;
    }

    else
    {
      id v42 = v73;
      if (!-[NSMutableArray count](v73, "count"))
      {
        int v82 = 0u;
        id v83 = 0u;
        id v80 = 0u;
        id v81 = 0u;
        uint64_t v51 = v74;
        id v52 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v51,  "countByEnumeratingWithState:objects:count:",  &v80,  v88,  16LL);
        if (v52)
        {
          uint64_t v53 = v52;
          obja = 0LL;
          objc_super v54 = *(void *)v81;
          __int128 v55 = -1;
          do
          {
            for (j = 0LL; j != v53; j = (char *)j + 1)
            {
              if (*(void *)v81 != v54) {
                objc_enumerationMutation(v51);
              }
              id v57 = *(void **)(*((void *)&v80 + 1) + 8LL * (void)j);
              id v58 = (void *)objc_claimAutoreleasedReturnValue([v57 neighbor]);
              int v59 = [v76 isEqual:v58];

              if ((v59 & 1) == 0 && [v57 metric] < v55)
              {
                __int128 v55 = (unsigned __int16)[v57 metric];
                id v60 = v57;

                obja = v60;
              }

              int v25 = v79;
              p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
            }

            uint64_t v53 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v51,  "countByEnumeratingWithState:objects:count:",  &v80,  v88,  16LL);
          }

          while (v53);

          id v42 = v73;
          id v61 = obja;
          if (obja)
          {
            uint64_t v16 = v70;
            id v24 = v71;
            id v15 = v72;
            if (a9 > 1u)
            {
              if (qword_1001DC8B0 != -1) {
                dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
              }
              if (_NRLogIsLevelEnabled(qword_1001DC8A8, 1LL))
              {
                char v65 = sub_1000B07C8();
                uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue([obja neighbor]);
                _NRLogWithArgs( v65,  1LL,  "%s%.30s:%-4d responding to seqno req by maybe sending to %@",  "",  "-[NRBabelInstance handleSeqnoReqFromAddr:babelInterface:ForPrefix:plen:routerID:seqno:hopCount:]",  3201LL,  v66);

                id v61 = obja;
              }

              -[NRBabelInstance sendSeqnoReqIfNecessaryTo:forPrefix:routerID:seqno:hopCount:originator:]( v75,  "sendSeqnoReqIfNecessaryTo:forPrefix:routerID:seqno:hopCount:originator:",  v61,  v70,  a7,  v9,  (a9 - 1),  v76);
            }

            else
            {
              if (qword_1001DC8B0 != -1) {
                dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
              }
              if (_NRLogIsLevelEnabled(qword_1001DC8A8, 16LL))
              {
                id v62 = sub_1000B07C8();
                _NRLogWithArgs( v62,  16LL,  "%s%.30s:%-4d received seqno req with dead hop count %u",  "",  "-[NRBabelInstance handleSeqnoReqFromAddr:babelInterface:ForPrefix:plen:routerID:seqno:hopCount:]",  3197,  a9);
              }
            }

            goto LABEL_96;
          }
        }

        else
        {
        }

        int v63 = p_class_meths[278];
        id v24 = v71;
        id v15 = v72;
        uint64_t v16 = v70;
        if (v63 != (__objc2_meth_list *)-1LL) {
          dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC8A8, 1LL))
        {
          if (qword_1001DC8B0 != -1) {
            dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
          }
          uint64_t v64 = (id)qword_1001DC8A8;
          _NRLogWithArgs( v64,  1LL,  "%s%.30s:%-4d not responding to seqno req since selected routes come from originator",  "",  "-[NRBabelInstance handleSeqnoReqFromAddr:babelInterface:ForPrefix:plen:routerID:seqno:hopCount:]",  3190);
        }

        id v61 = 0LL;
        goto LABEL_96;
      }

      ++v75->_nodeSeqno;
      uint64_t v45 = p_class_meths[278];
      id v15 = v72;
      if (v45 != (__objc2_meth_list *)-1LL) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      uint64_t v16 = v70;
      id v24 = v71;
      if (_NRLogIsLevelEnabled(qword_1001DC8A8, 1LL))
      {
        if (qword_1001DC8B0 != -1) {
          dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
        }
        int v46 = (id)qword_1001DC8A8;
        nodeSeqno = v75->_nodeSeqno;
        if (-[NSMutableArray count](v73, "count") == (id)1)
        {
          id v48 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray objectAtIndexedSubscript:](v73, "objectAtIndexedSubscript:", 0LL));
          _NRLogWithArgs( v46,  1LL,  "%s%.30s:%-4d responding to seqno req for %u by increasing seqno to %u and sending %@",  "",  "-[NRBabelInstance handleSeqnoReqFromAddr:babelInterface:ForPrefix:plen:routerID:seqno:hopCount:]",  3170LL,  v9,  nodeSeqno,  v48);
        }

        else
        {
          _NRLogWithArgs( v46,  1LL,  "%s%.30s:%-4d responding to seqno req for %u by increasing seqno to %u and sending %@",  "",  "-[NRBabelInstance handleSeqnoReqFromAddr:babelInterface:ForPrefix:plen:routerID:seqno:hopCount:]",  3170LL,  v9,  nodeSeqno,  v73);
        }
      }

      uint64_t v49 = v75;
      uint64_t v50 = v73;
    }

    id v61 = (void *)objc_claimAutoreleasedReturnValue(-[NRBabelInstance createUpdateTLVsForRoutes:](v49, "createUpdateTLVsForRoutes:", v50));
    [v76 sendTLVs:v61];
LABEL_96:

    goto LABEL_97;
  }

  if (qword_1001DC8B0 != -1) {
    dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC8A8, 1LL))
  {
    if (qword_1001DC8B0 != -1) {
      dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
    }
    _NRLogWithArgs( qword_1001DC8A8,  1LL,  "%s%.30s:%-4d not responding to seqno req since we have no selected routes",  "",  "-[NRBabelInstance handleSeqnoReqFromAddr:babelInterface:ForPrefix:plen:routerID:seqno:hopCount:]",  3143);
  }

      -[NSMutableString appendFormat:](v15, "appendFormat:", @"ClassAVerified | ");
      if ((v13 & 0x10) == 0)
      {
LABEL_12:

        if (a3)
        {
LABEL_13:
          if (a3 > 8) {
            uint64_t v17 = @"None";
          }
          else {
            uint64_t v17 = *(&off_1001ADE20 + (a3 - 1));
          }
          [v23 cancelWithReason:@"pairing client error: %@ mask: %@", v17, v15];
LABEL_29:

LABEL_30:
          uint64_t v7 = v23;
          goto LABEL_31;
        }
}
  }
}

    id v21 = 0LL;
    goto LABEL_12;
  }

  a1 = v10;
  if (!v8) {
    goto LABEL_16;
  }
  do
    uint64_t v11 = __ldxr(&qword_1001DC3D0);
  while (__stxr(v11 + 1, &qword_1001DC3D0));
  v10[7] = (id)v11;
  objc_storeStrong(v10 + 6, a2);
  *((_BYTE *)a1 + _Block_object_dispose((const void *)(v1 - 104), 8) = a3;
  objc_storeWeak(a1 + 8, v9);
  *((_WORD *)a1 + 7) = sub_100120214();
  *((_WORD *)a1 + _Block_object_dispose((const void *)(v1 - 104), 8) = sub_100120214();
  id v37 = 0;
  *(_DWORD *)__str = 0;
  snprintf(__str, 6uLL, "%u", *((unsigned __int16 *)a1 + 7));
  uint64_t v35 = 0;
  *(_DWORD *)port = 0;
  snprintf(port, 6uLL, "%u", *((unsigned __int16 *)a1 + 8));
  if (qword_1001DCB48 != -1) {
    dispatch_once(&qword_1001DCB48, &stru_1001B0518);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCB40, 1LL))
  {
    if (qword_1001DCB48 != -1) {
      dispatch_once(&qword_1001DCB48, &stru_1001B0518);
    }
    _NRLogWithArgs( qword_1001DCB40,  1LL,  "%s%.30s:%-4d %@ using ports local %s remote %s",  "",  "-[NRDDTLSStack initDTLSWithQueue:server:delegate:]",  341LL,  a1,  __str,  port);
  }

  host = nw_endpoint_create_host("::", port);
  secure_udp = nw_parameters_create_secure_udp( _nw_parameters_configure_protocol_disable,  _nw_parameters_configure_protocol_default_configuration);
  nw_parameters_set_local_address(secure_udp, host);
  id v14 = nw_endpoint_create_host("localhost", __str);
  id v15 = nw_connection_create(v14, secure_udp);
  uint64_t v16 = a1[5];
  a1[5] = v15;

  uint64_t v17 = (nw_connection *)a1[5];
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_100120448;
  handler[3] = &unk_1001B04F8;
  int v18 = a1;
  int v33 = v18;
  nw_connection_set_state_changed_handler(v17, handler);
  id v19 = (dispatch_queue_s *)a1[6];
  id v20 = (nw_connection *)a1[5];
  nw_connection_set_queue(v20, v19);

  nw_connection_start((nw_connection_t)a1[5]);
  a1 = v18;

  id v21 = a1;
LABEL_12:

  return v21;
}

  if (v5[4])
  {
    int v22 = objc_alloc(&OBJC_CLASS___NRDLDKeychainItemData);
    id v23 = v5[4];
    id v24 = sub_1001242A0((char *)v22, v23);
    int v25 = (void *)a1[3];
    a1[3] = v24;

    if (!a1[3]) {
      goto LABEL_37;
    }
  }

  a1 = a1;
  uint64_t v26 = a1;
LABEL_21:

  return v26;
}

void sub_100037F3C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
}

LABEL_38:
        uint64_t v36 = (char *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
        if (qword_1001DCA68 == -1) {
          goto LABEL_39;
        }
        goto LABEL_81;
      }

      uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
      if (qword_1001DCA68 != -1) {
        dispatch_once(&qword_1001DCA68, &stru_1001AFD30);
      }
      uint64_t v51 = (id)qword_1001DCA60;
      if ([v50 isEqual:v51])
      {
      }

      else
      {
        id v52 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
        if (qword_1001DCA78 != -1) {
          dispatch_once(&qword_1001DCA78, &stru_1001AFD50);
        }
        uint64_t v53 = (id)qword_1001DCA70;
        objc_super v54 = [v52 isEqual:v53];

        if ((v54 & 1) == 0)
        {
          v113 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v55);
          id v114 = _NRLogIsLevelEnabled(v113, 16LL);

          if (v114)
          {
            id v116 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v115);
            v117 = -[NRLink copyDescription](self, "copyDescription");
            __int128 v118 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
            __int128 v119 = (void *)objc_claimAutoreleasedReturnValue([v16 remoteIdentifier]);
            _NRLogWithArgs( v116,  16LL,  "%s%.30s:%-4d %@: Local identifier %@ does not match remote identifier %@",  "",  "-[NRLinkQuickRelay requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  2143LL,  v117,  v118,  v119);
          }

          goto LABEL_62;
        }
      }

      __int128 v56 = (void *)objc_claimAutoreleasedReturnValue([v16 remoteIdentifier]);
      id v57 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
      id v58 = sub_10012A74C((uint64_t)&OBJC_CLASS___NRDLocalDevice, v56, v57, v15);

      id v60 = _NRCopyLogObjectForNRUUID(self->super._nrUUID, v59);
      id v61 = (void *)v60;
      if (v58)
      {
        id v62 = _NRLogIsLevelEnabled(v60, 1LL);

        if (v62)
        {
          uint64_t v64 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v63);
          char v65 = -[NRLink copyDescription](self, "copyDescription");
          uint64_t v66 = v58->_identity;
          _NRLogWithArgs( v64,  1LL,  "%s%.30s:%-4d %@: Decrypted device identity %@",  "",  "-[NRLinkQuickRelay requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  2155LL,  v65,  v66);
        }

        int v67 = v58->_nrUUID;

        if (v67)
        {
          unint64_t v69 = v58->_nrUUID;
          int v70 = (void *)objc_claimAutoreleasedReturnValue(-[NRLink nrUUID](self, "nrUUID"));
          uint64_t v71 = -[NSUUID isEqual:](v69, "isEqual:", v70);

          if ((v71 & 1) != 0)
          {

            goto LABEL_38;
          }

          v151 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v72);
          v152 = _NRLogIsLevelEnabled(v151, 16LL);

          if (v152)
          {
            v145 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v153);
            v146 = -[NRLink copyDescription](self, "copyDescription");
            v150 = v58->_identity;
            v154 = v58->_nrUUID;
            v155 = (void *)objc_claimAutoreleasedReturnValue(-[NRLink nrUUID](self, "nrUUID"));
            _NRLogWithArgs( v145,  16LL,  "%s%.30s:%-4d %@: Different device found for identity %@ (%@ != %@)",  "",  "-[NRLinkQuickRelay requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  2166LL,  v146,  v150,  v154,  v155);

            goto LABEL_90;
          }
        }

        else
        {
          v147 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v68);
          v148 = _NRLogIsLevelEnabled(v147, 16LL);

          if (v148)
          {
            v145 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v149);
            v146 = -[NRLink copyDescription](self, "copyDescription");
            v150 = v58->_identity;
            _NRLogWithArgs( v145,  16LL,  "%s%.30s:%-4d %@: No device found for identity %@",  "",  "-[NRLinkQuickRelay requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  2159LL,  v146,  v150);
LABEL_90:

            goto LABEL_91;
          }
        }
      }

      else
      {
        v143 = _NRLogIsLevelEnabled(v60, 16LL);

        if (v143)
        {
          v145 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v144);
          v146 = -[NRLink copyDescription](self, "copyDescription");
          _NRLogWithArgs( v145,  16LL,  "%s%.30s:%-4d %@: Failed to decrypt device identity",  "",  "-[NRLinkQuickRelay requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  2151LL,  v146);
LABEL_91:
        }
      }

      -[NRLink reportEvent:detailsFormat:](self, "reportEvent:detailsFormat:", 3023LL, @"%@ %@", v15, v161);

      goto LABEL_62;
    }

    __int128 v47 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v34);
    id v48 = _NRLogIsLevelEnabled(v47, 16LL);

    if (v48)
    {
      objc_super v44 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v49);
      uint64_t v45 = -[NRLink copyDescription](self, "copyDescription");
      int v46 = (void *)objc_claimAutoreleasedReturnValue([v16 remoteIdentifier]);
      _NRLogWithArgs( v44,  16,  "%s%.30s:%-4d %@: Remote identifier has wrong type %zu",  "",  "-[NRLinkQuickRelay requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  2130,  v45,  [v46 identifierType]);
      goto LABEL_20;
    }
  }

  else
  {
    uint64_t v41 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v31);
    id v42 = _NRLogIsLevelEnabled(v41, 16LL);

    if (v42)
    {
      objc_super v44 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v43);
      uint64_t v45 = -[NRLink copyDescription](self, "copyDescription");
      int v46 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
      _NRLogWithArgs( v44,  16,  "%s%.30s:%-4d %@: Local identifier has wrong type %zu",  "",  "-[NRLinkQuickRelay requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  2126,  v45,  [v46 identifierType]);
LABEL_20:
    }
  }

  -[NSMutableArray addObject:](v8, "addObject:", @"ServiceClassVoice");
  if ((reason & 0x8000) == 0)
  {
LABEL_13:
    if ((reason & 0x40000) == 0) {
      goto LABEL_14;
    }
    goto LABEL_40;
  }

  -[NSMutableArray addObject:](v3, "addObject:", @"NotCngHi");
  if ((a1 & 0x1000000) == 0)
  {
LABEL_13:
    if ((a1 & 0x2000000) == 0) {
      goto LABEL_14;
    }
    goto LABEL_40;
  }

          goto LABEL_39;
        }
      }

      uint64_t v49 = 0LL;
      goto LABEL_38;
    }
  }

    LOBYTE(v24) = 0;
    return v24;
  }

  uint64_t v6 = v32;
  if (!v32)
  {
    id v23 = 0LL;
LABEL_37:
    freeifaddrs(v23);
    goto LABEL_38;
  }

  uint64_t v7 = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  while (1)
  {
    ifa_addr = v6->ifa_addr;
    if (ifa_addr->sa_family != 30) {
      goto LABEL_13;
    }
    uint64_t v10 = self;
    if (v7[278] != (__objc2_meth_list *)-1LL) {
      dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
    }
    if (_NRLogIsLevelEnabled(p_class_meths[277], 2LL))
    {
      if (v7[278] != (__objc2_meth_list *)-1LL) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      uint64_t v11 = p_class_meths[277];
      id v13 = p_class_meths;
      IPv6Addrid String = (void *)createIPv6AddrString(a3, v12);
      uint64_t v16 = (void *)createIPv6AddrString(&ifa_addr->sa_data[6], v15);
      uint64_t v17 = -[NRBabelInterface localAddress](v10, "localAddress");
      id v19 = (void *)createIPv6AddrString(v17, v18);
      _NRLogWithArgs( v11,  2LL,  "%s%.30s:%-4d %@ checking destination address %@ vs one of local %@, current local %@",  "",  "-[NRBabelInterfaceSocket setupLocalAddressCheckAgainst:]",  990LL,  v10,  IPv6AddrString,  v16,  v19);

      p_class_meths = v13;
      uint64_t v7 = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    }

    id v20 = (void *)objc_claimAutoreleasedReturnValue(-[NRBabelInterfaceSocket ifName](v10, "ifName"));
    id v21 = [v20 hasPrefix:@"ipsec"];

    if ((v21 & 1) == 0) {
      break;
    }
LABEL_12:

LABEL_13:
    uint64_t v6 = v6->ifa_next;
    if (!v6)
    {
      id v23 = v32;
      goto LABEL_37;
    }
  }

  if (*(_DWORD *)&ifa_addr[1].sa_data[6] != v10->_ifIndex
    || ifa_addr->sa_data[6] != 254
    || (ifa_addr->sa_data[7] & 0xC0) != 0x80)
  {
    goto LABEL_12;
  }

    id v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", v27));
    [v26 addObject:v13];
    goto LABEL_39;
  }

  if (!(_BYTE)v4)
  {
    if (v3 > 7) {
      return 1LL;
    }
    id v28 = 0x202020504020100uLL >> (8 * v3);
    if (!(_BYTE)v28) {
      return 1LL;
    }
    uint64_t v26 = *(void **)(a1 + 40);
    id v27 = v28;
    goto LABEL_38;
  }

  if (v4 == 101)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5)
    {
      dispatch_assert_queue_V2(*(dispatch_queue_t *)(v5 + 104));
      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      uint64_t v6 = (id)qword_1001DC870;
      uint64_t v7 = v6;
      if (v6) {
        unsigned int v8 = (void *)*((void *)v6 + 6);
      }
      else {
        unsigned int v8 = 0LL;
      }
      uint64_t v9 = v8;

      uint64_t v10 = *(void *)(a1 + 32);
      if (v10) {
        uint64_t v11 = *(void **)(v10 + 96);
      }
      else {
        uint64_t v11 = 0LL;
      }
    }

    else
    {
      uint64_t v9 = 0LL;
      uint64_t v11 = 0LL;
    }

    uint64_t v12 = sub_100140B30((uint64_t)v9, v11);
    id v13 = (void *)objc_claimAutoreleasedReturnValue(v12);

    if (v13) {
      goto LABEL_18;
    }
    id v15 = *(void *)(a1 + 32);
    if (v15)
    {
      if (*(_BYTE *)(v15 + 43))
      {
LABEL_18:
        uint64_t v16 = *(void **)(a1 + 40);
        uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](&OBJC_CLASS___NSNumber, "numberWithUnsignedChar:", 101LL));
        [v16 addObject:v17];

LABEL_39:
        return 1LL;
      }

      id v31 = *(void *)(v15 + 96);
    }

    else
    {
      id v31 = 0LL;
    }

    id v32 = (void *)_NRCopyLogObjectForNRUUID(v31, v14);
    int v33 = _NRLogIsLevelEnabled(v32, 16LL);

    if (!v33) {
      return 1LL;
    }
    uint64_t v35 = *(void *)(a1 + 32);
    if (v35) {
      uint64_t v36 = *(void *)(v35 + 96);
    }
    else {
      uint64_t v36 = 0LL;
    }
    id v13 = (void *)_NRCopyLogObjectForNRUUID(v36, v34);
    _NRLogWithArgs(v13, 16LL, "%s%.30s:%-4d Could not enable prefer Wi-Fi request as no peer address found");
    goto LABEL_39;
  }

  return 1LL;
}

LABEL_37:
}

  -[NSMutableArray addObject:](v8, "addObject:", @"TransferSizeLarge");
  if ((reason & 0x4000) == 0)
  {
LABEL_12:
    if ((reason & 0x8000) == 0) {
      goto LABEL_13;
    }
    goto LABEL_39;
  }

  -[NSMutableArray addObject:](v3, "addObject:", @"CngHi");
  if ((a1 & 0x800000) == 0)
  {
LABEL_12:
    if ((a1 & 0x1000000) == 0) {
      goto LABEL_13;
    }
    goto LABEL_39;
  }

LABEL_38:
          goto LABEL_39;
        }

        id v42 = sub_1000FBEC0();
        int v43 = _NRLogIsLevelEnabled(v42, 17LL);

        if (!v43) {
          goto LABEL_37;
        }
        int v39 = sub_1000FBEC0();
        _NRLogWithArgs(v39, 17LL, "Pipe has no output ring %@", v13);
      }

      else
      {
        uint64_t v40 = sub_1000FBEC0();
        uint64_t v41 = _NRLogIsLevelEnabled(v40, 17LL);

        if (!v41) {
          goto LABEL_37;
        }
        int v39 = sub_1000FBEC0();
        _NRLogWithArgs(v39, 17LL, "Pipe has no input ring %@", v13);
      }
    }

    else
    {
      id v37 = sub_1000FBEC0();
      uint64_t v38 = _NRLogIsLevelEnabled(v37, 17LL);

      if (!v38) {
        goto LABEL_37;
      }
      int v39 = sub_1000FBEC0();
      _NRLogWithArgs(v39, 17LL, "Pipe has no channel %@", v13);
    }

            int v39 = v5[16];
            goto LABEL_38;
          }
        }

        else if (!v12)
        {
          goto LABEL_37;
        }

        int v39 = 0LL;
LABEL_38:
        uint64_t v40 = v39;
        if (([v40 allowsDeadPeerDetection] & 1) == 0)
        {
          objc_opt_self(&OBJC_CLASS___NRLinkDirector);
          if (qword_1001DC878 != -1) {
            dispatch_once(&qword_1001DC878, &stru_1001AEED0);
          }
          uint64_t v41 = (id)qword_1001DC870;
          id v42 = v41;
          if (!v41 || !v41[8])
          {
            if (qword_1001DC9B8 != -1) {
              dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
            }
            int v46 = byte_1001DC9B0;

            if (!v46) {
              goto LABEL_48;
            }
            goto LABEL_45;
          }
        }

LABEL_45:
        int v43 = v14;
        objc_super v44 = v43;
        if (v43)
        {
          -[NEIKEv2SessionConfiguration setDeadPeerDetectionEnabled:](v43, "setDeadPeerDetectionEnabled:", 1LL);
          -[NEIKEv2SessionConfiguration setDeadPeerDetectionInterval:](v44, "setDeadPeerDetectionInterval:", 30LL);
          -[NEIKEv2SessionConfiguration setDeadPeerDetectionRetryIntervalMilliseconds:]( v44,  "setDeadPeerDetectionRetryIntervalMilliseconds:",  3000LL);
          -[NEIKEv2SessionConfiguration setDeadPeerDetectionMaxRetryCount:]( v44,  "setDeadPeerDetectionMaxRetryCount:",  3LL);
        }

        else
        {
          __int128 v47 = sub_100107F78();
          id v48 = _NRLogIsLevelEnabled(v47, 17LL);

          if (v48)
          {
            uint64_t v49 = sub_100107F78();
            _NRLogWithArgs(v49, 17LL, "%s called with null sessionConfig", "NRLinkIKESessionConfigSetDPD");
          }
        }

LABEL_48:
        goto LABEL_49;
      }

      goto LABEL_76;
  }

  if (qword_1001DCAC8 != -1) {
    dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
  }
  if (!_NRLogIsLevelEnabled(qword_1001DCAC0, 17LL))
  {
    id v14 = 0LL;
    goto LABEL_50;
  }

  if (qword_1001DCAC8 != -1) {
    dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
  }
  unsigned int v8 = (id *)(id)qword_1001DCAC0;
  id String = (id)NRDataProtectionClassCreateString(a3);
  _NRLogWithArgs(v8, 17LL, "Cannot copy IKE session config for %@", String);
  id v14 = 0LL;
LABEL_49:

LABEL_50:
  return v14;
}

    uint64_t v26 = 0LL;
    goto LABEL_21;
  }

    uint64_t v16 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", "PrimaryLink");
    if (-[NSMutableString length](v11, "length")) {
      -[NSMutableString appendString:](v11, "appendString:", @", ");
    }
    -[NSMutableString appendString:](v11, "appendString:", v16);

    if ((v7 & 0x40) == 0)
    {
LABEL_23:
      if ((v7 & 0x80) == 0)
      {
LABEL_46:
        _NRLogWithArgs( v10,  1LL,  "%s%.30s:%-4d Reporting Wi-Fi assertion reason mask: %@",  "",  "-[NRLinkManagerWiFi reportToPowerlog]_block_invoke",  1505LL,  v11);

        goto LABEL_47;
      }

id sub_10003B584()
{
  if (qword_1001DC758 != -1) {
    dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
  }
  return (id)qword_1001DC750;
}

void sub_10003B5C4(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  BOOL v2 = (void *)qword_1001DC750;
  qword_1001DC750 = (uint64_t)v1;
}

id sub_10003B5F4(id result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t)result;
    BOOL v2 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([result queue]);
    dispatch_assert_queue_V2(v2);

    [(id)v1 reportEvent:10017];
    if (gNRPacketLoggingEnabled)
    {
      uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 32), v3);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 1LL);

      if (IsLevelEnabled)
      {
        uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 32), v3);
        id v7 = [(id)v1 copyDescription];
        _NRLogWithArgs( v6,  1LL,  "%s%.30s:%-4d %@: QR link has been idle. Invalidating IDSSession",  "",  "-[NRLinkQuickRelay handleLinkIdleTimeout]",  1008LL,  v7);
      }
    }

    sub_10003B700(v1, v3);
    if (*(_BYTE *)(v1 + 209))
    {
      dispatch_resume(*(dispatch_object_t *)(v1 + 319));
      *(_BYTE *)(v1 + 209) = 0;
    }

    return [(id)v1 suspend];
  }

  return result;
}

void sub_10003B700(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
      id v7 = [(id)a1 copyDescription];
      _NRLogWithArgs( v6,  0LL,  "%s%.30s:%-4d %@: Invalidating IDS session",  "",  "-[NRLinkQuickRelay invalidateIDSSession]",  720LL,  v7);
    }

    *(_BYTE *)(a1 + 216) = 0;
    [(id)a1 reportEvent:10014, @"%@", *(void *)(a1 + 231) detailsFormat];
    unsigned int v8 = *(void **)(a1 + 231);
    if (!v8) {
      goto LABEL_19;
    }
    id v9 = v8;
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 queue]);
    [v9 setDelegate:0 queue:v10];

    [*(id *)(a1 + 231) endSession];
    uint64_t v11 = *(void **)(a1 + 231);
    *(void *)(a1 + 231) = 0LL;

    uint64_t v12 = *(void **)(a1 + 639);
    if (*(_BYTE *)(a1 + 212))
    {
      if (!v12) {
        goto LABEL_18;
      }
      if (!v12[18]) {
        goto LABEL_18;
      }
      uint64_t v13 = mach_absolute_time();
      uint64_t v14 = *(void *)(a1 + 639);
      if (!v14) {
        goto LABEL_18;
      }
      id v15 = &OBJC_IVAR___NRAnalyticsCmpnLinkQuickRelay__idsSessionEnd;
      goto LABEL_17;
    }

    if (v12)
    {
      if (!v12[14])
      {
        if (!v12[16]) {
          goto LABEL_18;
        }
        uint64_t v13 = mach_absolute_time();
        uint64_t v14 = *(void *)(a1 + 639);
        if (!v14) {
          goto LABEL_18;
        }
        id v15 = &OBJC_IVAR___NRAnalyticsCmpnLinkQuickRelay__idsSessionReceiveInvitationEnd;
        goto LABEL_17;
      }

      uint64_t v13 = mach_absolute_time();
      uint64_t v14 = *(void *)(a1 + 639);
      if (v14)
      {
        id v15 = &OBJC_IVAR___NRAnalyticsCmpnLinkQuickRelay__idsSessionSendInvitationEnd;
LABEL_17:
        *(void *)(v14 + *v15) = v13;
      }
    }

void sub_10003B930(uint64_t a1)
{
  if (a1)
  {
    if (*(_BYTE *)(a1 + 215))
    {
      [(id)a1 removeObserver:a1 forKeyPath:@"_connection.connectionState" context:0];
      *(_BYTE *)(a1 + 215) = 0;
    }

    BOOL v2 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 connection]);

    if (v2)
    {
      uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v3);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 1LL);

      if (IsLevelEnabled)
      {
        id v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v6);
        id v8 = [(id)a1 copyDescription];
        id v9 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 connection]);
        _NRLogWithArgs( v7,  1LL,  "%s%.30s:%-4d %@: Cancelling %@",  "",  "-[NRLinkQuickRelay invalidateConnection]",  711LL,  v8,  v9);
      }

      uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 connection]);
      [v10 cancel];

      [(id)a1 setConnection:0];
    }
  }

void sub_10003BA64(uint64_t a1)
{
  BOOL v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) connection]);
  unint64_t v3 = (unint64_t)[v2 connectionState];

  uint64_t v4 = *(void **)(a1 + 32);
  uint64_t v5 = @"Invalid";
  uint64_t v6 = v4;
  switch(v3)
  {
    case 0uLL:
      break;
    case 1uLL:
      uint64_t v5 = @"Waiting";
      uint64_t v6 = *(void **)(a1 + 32);
      break;
    case 2uLL:
      uint64_t v5 = @"Preparing";
      uint64_t v6 = *(void **)(a1 + 32);
      break;
    case 3uLL:
      uint64_t v5 = @"Ready";
      uint64_t v6 = *(void **)(a1 + 32);
      break;
    case 4uLL:
      uint64_t v5 = @"Failed";
      uint64_t v6 = *(void **)(a1 + 32);
      break;
    case 5uLL:
      uint64_t v5 = @"Cancelled";
      uint64_t v6 = *(void **)(a1 + 32);
      break;
    default:
      uint64_t v5 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown[%lld]",  v3);
      uint64_t v6 = *(void **)(a1 + 32);
      break;
  }

  id v7 = (void *)objc_claimAutoreleasedReturnValue([v6 connection]);
  [v4 reportEvent:10020, @"%@ %@", v5, v7 detailsFormat];

  if (v3 == 3)
  {
    sub_10003C048(*(void *)(a1 + 32));
    unsigned int v9 = [*(id *)(a1 + 32) ikeClassDEstablished];
    uint64_t v10 = *(void *)(a1 + 32);
    if (v9 && v10 && *(void *)(v10 + 263))
    {
      objc_initWeak(location, (id)v10);
      uint64_t v11 = mach_absolute_time();
      uint64_t v12 = *(void *)(a1 + 32);
      if (v12)
      {
        uint64_t v13 = v11;
        uint64_t v14 = *(id *)(v12 + 639);
        if (v14) {
          v14[20] = v13;
        }
      }

      else
      {
        uint64_t v14 = 0LL;
      }

      uint64_t v15 = *(void *)(a1 + 32);
      if (v15) {
        uint64_t v15 = *(void *)(v15 + 263);
      }
      id v16 = (id)v15;
      uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) queue]);
      v49[0] = _NSConcreteStackBlock;
      v49[1] = 3221225472LL;
      v49[2] = sub_10003C300;
      v49[3] = &unk_1001AF950;
      objc_copyWeak(&v50, location);
      [v16 sendKeepaliveWithRetries:3 retryIntervalInMilliseconds:3000 callbackQueue:v17 callback:v49];

      objc_destroyWeak(&v50);
      objc_destroyWeak(location);
      uint64_t v10 = *(void *)(a1 + 32);
    }

    unsigned int v18 = [(id)v10 ikeClassCEstablished];
    uint64_t v19 = *(void *)(a1 + 32);
    if (v18 && v19 && *(void *)(v19 + 271))
    {
      objc_initWeak(location, (id)v19);
      uint64_t v20 = mach_absolute_time();
      uint64_t v21 = *(void *)(a1 + 32);
      if (v21)
      {
        uint64_t v22 = v20;
        id v23 = *(id *)(v21 + 639);
        if (v23) {
          v23[22] = v22;
        }
      }

      else
      {
        id v23 = 0LL;
      }

      uint64_t v24 = *(void *)(a1 + 32);
      if (v24) {
        uint64_t v24 = *(void *)(v24 + 271);
      }
      id v25 = (id)v24;
      uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) queue]);
      v47[0] = _NSConcreteStackBlock;
      v47[1] = 3221225472LL;
      v47[2] = sub_10003C404;
      v47[3] = &unk_1001AF950;
      objc_copyWeak(&v48, location);
      [v25 sendKeepaliveWithRetries:3 retryIntervalInMilliseconds:3000 callbackQueue:v26 callback:v47];

      objc_destroyWeak(&v48);
      objc_destroyWeak(location);
      uint64_t v19 = *(void *)(a1 + 32);
    }

    if (![(id)v19 ikeClassCEstablished]
      || ([*(id *)(a1 + 32) ikeClassDEstablished] & 1) == 0)
    {
      uint64_t v27 = *(void *)(a1 + 32);
      if (v27 && (*(_BYTE *)(v27 + 218) = 0, (uint64_t v28 = *(void *)(a1 + 32)) != 0))
      {
        *(_BYTE *)(v28 + 219) = 0;
        uint64_t v29 = *(void *)(a1 + 32);
      }

      else
      {
        uint64_t v29 = 0LL;
      }

      sub_10003C508(v29);
      uint64_t v30 = *(void *)(a1 + 32);
      if (!v30) {
        return;
      }
      if (*(_BYTE *)(v30 + 211))
      {
        *(_BYTE *)(v30 + 211) = 0;
        uint64_t v31 = *(void *)(a1 + 32);
        if (!v31) {
          return;
        }
        if (*(_BYTE *)(v31 + 209))
        {
          dispatch_resume(*(dispatch_object_t *)(v31 + 319));
          uint64_t v32 = *(void *)(a1 + 32);
          if (!v32) {
            return;
          }
          *(_BYTE *)(v32 + 209) = 0;
        }
      }
    }

    int v33 = *(void **)(a1 + 32);
    if (v33)
    {
      id v34 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([v33 queue]);
      dispatch_assert_queue_V2(v34);

      uint64_t v35 = *(dispatch_source_s **)((char *)v33 + 607);
      if (v35)
      {
        dispatch_source_cancel(v35);
        uint64_t v36 = *(void **)((char *)v33 + 607);
        *(void *)((char *)v33 + 607) = 0LL;
      }

      if ([v33 state] == 255)
      {
        id v42 = (void *)_NRCopyLogObjectForNRUUID(v33[4], v37);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v42, 0LL);

        if (IsLevelEnabled)
        {
          uint64_t v45 = (void *)_NRCopyLogObjectForNRUUID(v33[4], v44);
          id v46 = [v33 copyDescription];
          _NRLogWithArgs( v45,  0LL,  "%s%.30s:%-4d %@: not arming link idle timer as link is cancelled",  "",  "-[NRLinkQuickRelay armLinkIdleTimer]",  967LL,  v46);
        }
      }

      else if (!*(void *)((char *)v33 + 607))
      {
        uint64_t v38 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([v33 queue]);
        int v39 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v38);

        dispatch_time_t v40 = dispatch_time(0x8000000000000000LL, 10000000000LL);
        dispatch_source_set_timer(v39, v40, 0x2540BE400uLL, 0LL);
        objc_initWeak(&from, v33);
        location[0] = _NSConcreteStackBlock;
        location[1] = (id)3221225472LL;
        id location[2] = sub_10003CC34;
        location[3] = &unk_1001AFED0;
        objc_copyWeak(&v52, &from);
        dispatch_source_set_event_handler(v39, location);
        dispatch_resume(v39);
        uint64_t v41 = *(void **)((char *)v33 + 607);
        *(void *)((char *)v33 + 607) = v39;

        objc_destroyWeak(&v52);
        objc_destroyWeak(&from);
      }
    }
  }

  else if ((v3 & 0xFFFFFFFFFFFFFFFELL) == 4)
  {
    sub_10003B700(*(void *)(a1 + 32), v8);
  }

void sub_10003C01C(_Unwind_Exception *a1)
{
}

void sub_10003C048(uint64_t a1)
{
  if (!a1) {
    return;
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 8));
  if (*(unsigned __int8 *)(a1 + 16) == 255)
  {
    uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16LL);

    if (!IsLevelEnabled) {
      return;
    }
    id v20 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v7);
    id v8 = [(id)a1 copyDescription];
    _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d %@: Cannot read datagram as link is cancelled",  "",  "-[NRLinkQuickRelay readDatagramFromSession]",  1583LL,  v8);
LABEL_10:

LABEL_16:
    return;
  }

  unint64_t v3 = *(void **)(a1 + 647);
  if (!v3)
  {
    unsigned int v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v2);
    int v10 = _NRLogIsLevelEnabled(v9, 0LL);

    if (!v10) {
      return;
    }
    id v20 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v11);
    id v8 = [(id)a1 copyDescription];
    _NRLogWithArgs( v20,  0LL,  "%s%.30s:%-4d %@: Ignoring reading datagrams as connection does not exist",  "",  "-[NRLinkQuickRelay readDatagramFromSession]",  1590LL,  v8);
    goto LABEL_10;
  }

  if ([v3 connectionState] == (id)3)
  {
    objc_initWeak(&location, (id)a1);
    uint64_t v4 = *(void **)(a1 + 647);
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472LL;
    v21[2] = sub_100041D08;
    v21[3] = &unk_1001AE688;
    objc_copyWeak(&v22, &location);
    [v4 readDatagramsWithMinimumCount:1 maximumCount:0xFFFFFFFFLL completionHandler:v21];
    objc_destroyWeak(&v22);
    objc_destroyWeak(&location);
    return;
  }

  uint64_t v12 = *(void **)(a1 + 647);
  id v13 = [v12 connectionState];
  if ((unint64_t)v13 >= 6) {
    uint64_t v14 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown[%lld]",  v13);
  }
  else {
    uint64_t v14 = (NSString *)*(&off_1001AE718 + (void)v13);
  }
  [(id)a1 reportEvent:10021, @"cannot read from connection %@ state %@", v12, v14 detailsFormat];

  id v16 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v15);
  int v17 = _NRLogIsLevelEnabled(v16, 17LL);

  if (v17)
  {
    id v20 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v18);
    id v19 = [(id)a1 copyDescription];
    _NRLogWithArgs( v20,  17,  "%@: Cannot read from connection %@, state: %llu",  v19,  *(void *)(a1 + 647),  [*(id *)(a1 + 647) connectionState]);

    goto LABEL_16;
  }

void sub_10003C2E4(_Unwind_Exception *a1)
{
}

void sub_10003C300(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v14 = WeakRetained;
    uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

    if (IsLevelEnabled)
    {
      id v8 = (void *)_NRCopyLogObjectForNRUUID(v14[4], v7);
      id v9 = [v14 copyDescription];
      int v10 = v9;
      uint64_t v11 = "NO";
      if (a2) {
        uint64_t v11 = "YES";
      }
      _NRLogWithArgs( v8,  0LL,  "%s%.30s:%-4d %@: ClassD keepalive response received: %s",  "",  "-[NRLinkQuickRelay observeValueForKeyPath:ofObject:change:context:]_block_invoke_2",  2458LL,  v9,  v11);
    }

    id WeakRetained = v14;
    if (a2)
    {
      uint64_t v12 = mach_absolute_time();
      uint64_t v13 = *(void *)((char *)v14 + 639);
      if (v13) {
        *(void *)(v13 + 16_Block_object_dispose((const void *)(v1 - 104), 8) = v12;
      }
      sub_10003E800((uint64_t)v14);
      id WeakRetained = v14;
    }
  }
}

void sub_10003C404(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v14 = WeakRetained;
    uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

    if (IsLevelEnabled)
    {
      id v8 = (void *)_NRCopyLogObjectForNRUUID(v14[4], v7);
      id v9 = [v14 copyDescription];
      int v10 = v9;
      uint64_t v11 = "NO";
      if (a2) {
        uint64_t v11 = "YES";
      }
      _NRLogWithArgs( v8,  0LL,  "%s%.30s:%-4d %@: ClassC keepalive response received: %s",  "",  "-[NRLinkQuickRelay observeValueForKeyPath:ofObject:change:context:]_block_invoke_3",  2483LL,  v9,  v11);
    }

    id WeakRetained = v14;
    if (a2)
    {
      uint64_t v12 = mach_absolute_time();
      uint64_t v13 = *(void *)((char *)v14 + 639);
      if (v13) {
        *(void *)(v13 + 184) = v12;
      }
      sub_10003E800((uint64_t)v14);
      id WeakRetained = v14;
    }
  }
}

void sub_10003C508(uint64_t a1)
{
  if (!a1) {
    return;
  }
  uint64_t v2 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([(id)a1 queue]);
  dispatch_assert_queue_V2(v2);

  if (!*(void *)(a1 + 279))
  {
    id v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 231) sessionID]);
    uint64_t v68 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Terminus QuickRelay link <%@>",  v22));

    id v23 = sub_10010D5C4(v68, (void *)a1, 1LL, 0LL, 0LL, 0LL);
    uint64_t v24 = *(void **)(a1 + 279);
    *(void *)(a1 + 279) = v23;

    uint64_t v26 = *(void **)(a1 + 279);
    if (v26)
    {
      objc_msgSend((id)a1, "setVirtualInterface:", objc_msgSend(v26, "virtualInterface"));
      if ([(id)a1 setInterfaceSubfamily])
      {
        if ([(id)a1 setNoACKPrioritization])
        {
          uint64_t v29 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 32));
          if (!v29)
          {
            id v60 = sub_10003B584();
            int IsLevelEnabled = _NRLogIsLevelEnabled(v60, 16LL);

            if (IsLevelEnabled)
            {
              id v62 = sub_10003B584();
              _NRLogWithArgs( v62,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRLinkQuickRelay setupIPsec]",  1474);
            }

            uint64_t v63 = _os_log_pack_size(12LL);
            uint64_t v64 = (char *)&v68 - ((v63 + 15) & 0xFFFFFFFFFFFFFFF0LL);
            char v65 = __error();
            uint64_t v66 = _os_log_pack_fill( v64,  v63,  *v65,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
            *(_DWORD *)uint64_t v66 = 136446210;
            *(void *)(v66 + 4) = "-[NRLinkQuickRelay setupIPsec]";
            id v67 = sub_10003B584();
            _NRLogAbortWithPack(v67, v64);
          }

          uint64_t v30 = v29;
          uint64_t v31 = (void *)sub_100137060(v29);
          [*(id *)(a1 + 279) setLocalAddresses:v31];

          id v32 = [(id)a1 virtualInterface];
          int v33 = sub_100146AFC();
          dispatch_assert_queue_V2((dispatch_queue_t)v33);

          id v34 = sub_100146AFC();
          dispatch_assert_queue_V2((dispatch_queue_t)v34);

          uint64_t v35 = sub_10012D254(v30, @"0");
          uint64_t v36 = (void *)objc_claimAutoreleasedReturnValue([v35 hostname]);

          NEVirtualInterfaceAddIPv6Route(v32, v36, &off_1001BC5B0, 0LL, 0LL);
          id v37 = [(id)a1 virtualInterface];
          uint64_t v38 = sub_100146AFC();
          dispatch_assert_queue_V2((dispatch_queue_t)v38);

          int v39 = sub_100146AFC();
          dispatch_assert_queue_V2((dispatch_queue_t)v39);

          dispatch_time_t v40 = sub_10012D610(v30, @"0");
          uint64_t v41 = (void *)objc_claimAutoreleasedReturnValue([v40 hostname]);

          NEVirtualInterfaceAddIPv6Route(v37, v41, &off_1001BC5B0, 0LL, 0LL);
          NEVirtualInterfaceUpdateAdHocService([(id)a1 virtualInterface]);
          [*(id *)(a1 + 279) setAvailability:0];

          goto LABEL_3;
        }

        __int128 v55 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v28);
        int v56 = _NRLogIsLevelEnabled(v55, 17LL);

        if (!v56) {
          goto LABEL_30;
        }
        id v50 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v57);
        id v51 = [(id)a1 copyDescription];
        _NRLogWithArgs(v50, 17LL, "%@: failed to setup no ack prioritization", v51);
      }

      else
      {
        id v52 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v27);
        int v53 = _NRLogIsLevelEnabled(v52, 17LL);

        if (!v53) {
          goto LABEL_30;
        }
        id v50 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v54);
        id v51 = [(id)a1 copyDescription];
        _NRLogWithArgs(v50, 17LL, "%@: failed to setup interface sub family", v51);
      }
    }

    else
    {
      __int128 v47 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v25);
      int v48 = _NRLogIsLevelEnabled(v47, 16LL);

      if (!v48) {
        goto LABEL_30;
      }
      id v50 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v49);
      id v51 = [(id)a1 copyDescription];
      _NRLogWithArgs( v50,  16LL,  "%s%.30s:%-4d %@: failed to create packet nexus",  "",  "-[NRLinkQuickRelay setupIPsec]",  1458LL,  v51);
    }

    goto LABEL_30;
  }

void sub_10003CC34(uint64_t a1)
{
  id WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    if (*(void *)(WeakRetained + 415) == *(void *)(WeakRetained + 391)
      && *(void *)(WeakRetained + 423) == *(void *)(WeakRetained + 407)
      && *(void *)(WeakRetained + 375) == *(void *)(WeakRetained + 367))
    {
      uint64_t v10 = WeakRetained;
      unint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(WeakRetained + 231) sessionID]);
      uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v4,  "setObject:forKeyedSubscript:",  &off_1001BC610,  @"State");
      -[NSMutableDictionary setObject:forKeyedSubscript:](v4, "setObject:forKeyedSubscript:", v3, @"SessionID");
      sub_100101A04(@"IDS Session", v4);

      sub_10003B5F4(v10);
      id WeakRetained = v10;
    }

    else
    {
      if (gNRPacketLoggingEnabled)
      {
        uint64_t v11 = WeakRetained;
        id v5 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v2);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 1LL);

        id WeakRetained = v11;
        if (IsLevelEnabled)
        {
          uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v11 + 4), v7);
          id v9 = [v11 copyDescription];
          _NRLogWithArgs( v8,  1LL,  "%s%.30s:%-4d %@: QR link has been active",  "",  "-[NRLinkQuickRelay armLinkIdleTimer]_block_invoke",  990LL,  v9);

          id WeakRetained = v11;
        }
      }

      *(void *)(WeakRetained + 423) = *(void *)(WeakRetained + 407);
      *(void *)(WeakRetained + 415) = *(void *)(WeakRetained + 391);
      *(void *)(WeakRetained + 375) = *(void *)(WeakRetained + 367);
    }
  }
}

void sub_10003CE18(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([(id)a1 queue]);
  dispatch_assert_queue_V2(v4);

  if (!*(_BYTE *)(a1 + 214))
  {
    id v5 = (id *)sub_10003D2AC(a1, a2);
    if (!*v5)
    {
      uint64_t v6 = v5;
      id String = (void *)NRDataProtectionClassCreateString(a2);
      uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 nrUUID]);
      id v9 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v8);

      if (v9)
      {
        id v11 = sub_10012ADD4(v9, a2);

        if (v11)
        {
          uint64_t v54 = v9;
          uint64_t v13 = sub_10010C6B8(1, v9, a2);
          uint64_t v14 = objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  @"::",  @"0"));
          id v15 = String;
          id v16 = objc_alloc(&OBJC_CLASS___NEIKEv2ConfigurationMessage);
          id v17 = [[NEIKEv2InitiatorTransportIPv6Address alloc] initWithAddress:v14];
          v55[0] = v17;
          int v53 = (void *)v14;
          id v18 = [[NEIKEv2ResponderTransportIPv6Address alloc] initWithAddress:v14];
          v55[1] = v18;
          uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v55, 2LL));
          id v20 = [v16 initWithWithAttributes:v19];
          -[NEIKEv2SessionConfiguration setConfigurationRequest:](v13, "setConfigurationRequest:", v20);

          id v21 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"terminusIKE-QuickRelay-%@",  v15);
          id v22 = objc_alloc(&OBJC_CLASS___NEIKEv2Session);
          id v23 = sub_10010C0B8();
          uint64_t v24 = sub_10010C340();
          uint64_t v25 = *(void *)(a1 + 8);
          id v26 = [(id)a1 virtualInterface];
          uint64_t v27 = v22;
          uint64_t v28 = v13;
          uint64_t v29 = -[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName:packetDelegate:]( v27,  "initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASession Name:packetDelegate:",  v23,  v24,  v13,  v25,  v26,  0LL,  v21,  a1);
          id v30 = *v6;
          *uint64_t v6 = v29;

          if (!*v6)
          {
            int v48 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v31);
            int IsLevelEnabled = _NRLogIsLevelEnabled(v48, 17LL);

            uint64_t v28 = v13;
            id String = v15;
            int v33 = v53;
            id v9 = v54;
            if (IsLevelEnabled)
            {
              id v51 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v50);
              id v52 = [(id)a1 copyDescription];
              _NRLogWithArgs(v51, 17LL, "%@: Failed to create initiator %@ IKE session", v52, String);

              uint64_t v28 = v13;
            }

            goto LABEL_21;
          }

          [(id)a1 reportEvent:3015, @"%@ %@", v15, *v6 detailsFormat];
          sub_10003D41C(a1);
          id String = v15;
          if ((_DWORD)a2 == 3)
          {
            uint64_t v43 = mach_absolute_time();
            uint64_t v44 = *(void *)(a1 + 639);
            id v9 = v54;
            if (!v44)
            {
              uint64_t v36 = 0LL;
              int v33 = v53;
              goto LABEL_19;
            }

            *(void *)(v44 + 32) = v43;
            uint64_t v36 = (char *)*(id *)(a1 + 639);
            int v33 = v53;
            if (v36)
            {
              id v37 = &OBJC_IVAR___NRAnalyticsCmpnLink__ikeClassCAttempts;
              goto LABEL_18;
            }
          }

          else
          {
            BOOL v32 = (_DWORD)a2 == 4;
            int v33 = v53;
            id v9 = v54;
            if (!v32) {
              goto LABEL_20;
            }
            uint64_t v34 = mach_absolute_time();
            uint64_t v35 = *(void *)(a1 + 639);
            if (!v35)
            {
              uint64_t v36 = 0LL;
              goto LABEL_19;
            }

            *(void *)(v35 + 4_Block_object_dispose((const void *)(v1 - 104), 8) = v34;
            uint64_t v36 = (char *)*(id *)(a1 + 639);
            if (v36)
            {
              id v37 = &OBJC_IVAR___NRAnalyticsCmpnLink__ikeClassDAttempts;
LABEL_18:
              ++*(void *)&v36[*v37];
            }
          }

uint64_t sub_10003D2AC(uint64_t result, int a2)
{
  if (result)
  {
    if (a2 == 4)
    {
      uint64_t v2 = &OBJC_IVAR___NRLinkQuickRelay__ikeSessionClassD;
      goto LABEL_6;
    }

    if (a2 == 3)
    {
      uint64_t v2 = &OBJC_IVAR___NRLinkQuickRelay__ikeSessionClassC;
LABEL_6:
      result += *v2;
      return result;
    }

    HIDWORD(v14) = a2;
    id v3 = sub_10003B584();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 16LL);

    if (IsLevelEnabled)
    {
      id v5 = sub_10003B584();
      id String = (void *)NRDataProtectionClassCreateString(HIDWORD(v14));
      _NRLogWithArgs( v5,  16LL,  "%s%.30s:%-4d ABORTING: Cannot copy IKE session pointer for %@",  "",  "-[NRLinkQuickRelay ikeSessionPointerForDataProtectionClass:]",  1107LL,  String);
    }

    uint64_t v7 = _os_log_pack_size(22LL);
    uint64_t v8 = (char *)&v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v9 = __error();
    uint64_t v10 = _os_log_pack_fill( v8,  v7,  *v9,  &_mh_execute_header,  "%{public}s Cannot copy IKE session pointer for %@");
    uint64_t v11 = NRDataProtectionClassCreateString(HIDWORD(v14));
    *(_DWORD *)uint64_t v10 = 136446466;
    *(void *)(v10 + 4) = "-[NRLinkQuickRelay ikeSessionPointerForDataProtectionClass:]";
    *(_WORD *)(v10 + 12) = 2112;
    *(void *)(v10 + 14) = v11;
    id v12 = sub_10003B584();
    uint64_t v13 = _NRLogAbortWithPack(v12, v8);
    return sub_10003D41C(v13);
  }

  return result;
}

void sub_10003D41C(void *a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v4 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([a1 queue]);
    dispatch_assert_queue_V2(v4);

    id String = (void *)NRDataProtectionClassCreateString(a2);
    id v6 = *(id *)sub_10003D2AC((uint64_t)a1, a2);
    uint64_t v7 = v6;
    if (v6)
    {
      id v8 = v6;
      [v8 setClientQueue:a1[1]];
      objc_initWeak(location, a1);
      v57[0] = _NSConcreteStackBlock;
      v57[1] = 3221225472LL;
      v57[2] = sub_10003D908;
      v57[3] = &unk_1001AF2D8;
      objc_copyWeak(&v60, location);
      id v9 = String;
      id v58 = v9;
      id v10 = v8;
      id v59 = v10;
      char v61 = a2;
      [v10 setStateUpdateBlock:v57];
      v52[0] = _NSConcreteStackBlock;
      v52[1] = 3221225472LL;
      v52[2] = sub_10003DF24;
      v52[3] = &unk_1001AF300;
      objc_copyWeak(&v55, location);
      id v11 = v9;
      id v53 = v11;
      id v12 = v10;
      id v54 = v12;
      char v56 = a2;
      [v12 setChildStateUpdateBlock:v52];
      v48[0] = _NSConcreteStackBlock;
      v48[1] = 3221225472LL;
      v48[2] = sub_10003E074;
      v48[3] = &unk_1001AF328;
      objc_copyWeak(&v51, location);
      id v13 = v11;
      id v49 = v13;
      id v14 = v12;
      id v50 = v14;
      [v14 setConfigurationUpdateBlock:v48];
      v44[0] = _NSConcreteStackBlock;
      v44[1] = 3221225472LL;
      v44[2] = sub_10003E140;
      v44[3] = &unk_1001AF350;
      objc_copyWeak(&v47, location);
      id v15 = v13;
      id v45 = v15;
      id v16 = v14;
      id v46 = v16;
      [v16 setTrafficSelectorUpdateBlock:v44];
      v40[0] = _NSConcreteStackBlock;
      v40[1] = 3221225472LL;
      v40[2] = sub_10003E22C;
      v40[3] = &unk_1001AF378;
      objc_copyWeak(&v43, location);
      id v17 = v15;
      id v41 = v17;
      id v18 = v16;
      id v42 = v18;
      [v18 setAdditionalAddressesUpdateBlock:v40];
      v36[0] = _NSConcreteStackBlock;
      v36[1] = 3221225472LL;
      v36[2] = sub_10003E2F8;
      v36[3] = &unk_1001AF3A0;
      objc_copyWeak(&v39, location);
      id v19 = v17;
      id v37 = v19;
      id v20 = v18;
      id v38 = v20;
      [v20 setShortDPDEventBlock:v36];
      v32[0] = _NSConcreteStackBlock;
      v32[1] = 3221225472LL;
      v32[2] = sub_10003E3B8;
      v32[3] = &unk_1001AF378;
      objc_copyWeak(&v35, location);
      id v21 = v19;
      id v33 = v21;
      id v22 = v20;
      id v34 = v22;
      [v22 setPrivateNotifyStatusEvent:v32];
      uint64_t v24 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v23);
      char IsLevelEnabled = _NRLogIsLevelEnabled(v24, 0LL);

      if ((IsLevelEnabled & 1) != 0)
      {
        uint64_t v27 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v26);
        id v28 = [a1 copyDescription];
        _NRLogWithArgs( v27,  0LL,  "%s%.30s:%-4d %@: Setup IKE %@ %@ callbacks",  "",  "-[NRLinkQuickRelay setupIKECallbacksForClass:]",  1341LL,  v28,  v21,  v22);
      }

      objc_destroyWeak(&v35);
      objc_destroyWeak(&v39);

      objc_destroyWeak(&v43);
      objc_destroyWeak(&v47);

      objc_destroyWeak(&v51);
      objc_destroyWeak(&v55);

      objc_destroyWeak(&v60);
      objc_destroyWeak(location);
    }

    else
    {
      id v29 = sub_10003B584();
      int v30 = _NRLogIsLevelEnabled(v29, 17LL);

      if (v30)
      {
        id v31 = sub_10003B584();
        _NRLogWithArgs(v31, 17LL, "%s called with null ikeSession", "-[NRLinkQuickRelay setupIKECallbacksForClass:]");
      }
    }
  }

void sub_10003D888( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id *location, id *a18, id *a19)
{
}

void sub_10003D908(uint64_t a1, uint64_t a2, void *a3)
{
  id v60 = a3;
  id WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 48));
  if (!WeakRetained) {
    goto LABEL_55;
  }
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 40);
  SessionStateid String = (void *)NEIKEv2CreateSessionStateString(a2);
  if (!v60)
  {
    [WeakRetained reportEvent:3009, @"%@ session %@ changed state to %@", v6, v7, SessionStateString detailsFormat];

    switch(a2)
    {
      case 1LL:
        if ([WeakRetained state] == 1)
        {
          id v12 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v11);
          int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 0LL);

          if (IsLevelEnabled)
          {
            id v15 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v14);
            id v16 = [WeakRetained copyDescription];
            _NRLogWithArgs( v15,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ now connecting",  "",  "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke",  1204LL,  v16,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
          }

          [WeakRetained changeStateTo:5];
        }

        else
        {
          unsigned int v31 = [WeakRetained state];
          uint64_t v33 = _NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v32);
          id v34 = (void *)v33;
          if (v31 == 5)
          {
            int v35 = _NRLogIsLevelEnabled(v33, 0LL);

            if (v35)
            {
              id v37 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v36);
              id v38 = [WeakRetained copyDescription];
              uint64_t v58 = *(void *)(a1 + 32);
              uint64_t v59 = *(void *)(a1 + 40);
              uint64_t v56 = 1207LL;
              id v57 = v38;
              id v39 = "%s%.30s:%-4d %@: %@ IKE %@ already connecting";
              goto LABEL_53;
            }
          }

          else
          {
            int v51 = _NRLogIsLevelEnabled(v33, 16LL);

            if (v51)
            {
              id v37 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v52);
              id v38 = [WeakRetained copyDescription];
              _NRLogWithArgs( v37,  16LL,  "%s%.30s:%-4d %@: %@ IKE %@ connecting but weird state",  "",  "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke",  1209LL,  v38,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
              goto LABEL_54;
            }
          }
        }

        goto LABEL_55;
      case 2LL:
        int v27 = *(unsigned __int8 *)(a1 + 56);
        if (v27 == 3)
        {
          uint64_t v40 = mach_absolute_time();
          uint64_t v41 = *(void *)(WeakRetained + 639);
          if (v41) {
            *(void *)(v41 + 40) = v40;
          }
          [WeakRetained setIkeClassCEstablished:1];
          WeakRetained[219] = 0;
          int v30 = objc_alloc_init(&OBJC_CLASS___NSDate);
          sub_10003E7F0((uint64_t)WeakRetained, v30);
        }

        else
        {
          if (v27 != 4) {
            goto LABEL_41;
          }
          uint64_t v28 = mach_absolute_time();
          uint64_t v29 = *(void *)(WeakRetained + 639);
          if (v29) {
            *(void *)(v29 + 56) = v28;
          }
          [WeakRetained setIkeClassDEstablished:1];
          WeakRetained[218] = 0;
          int v30 = objc_alloc_init(&OBJC_CLASS___NSDate);
          sub_10003E7E0((uint64_t)WeakRetained, v30);
        }

LABEL_41:
        int v42 = WeakRetained[16];
        if ((v42 - 8) >= 2)
        {
          if (v42 != 5)
          {
            id v53 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v10);
            int v54 = _NRLogIsLevelEnabled(v53, 0LL);

            if (v54)
            {
              id v37 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v55);
              id v38 = [WeakRetained copyDescription];
              uint64_t v58 = *(void *)(a1 + 32);
              uint64_t v59 = *(void *)(a1 + 40);
              uint64_t v56 = 1231LL;
              id v57 = v38;
              id v39 = "%s%.30s:%-4d %@: %@ IKE %@ connected but weird state";
LABEL_53:
              _NRLogWithArgs( v37,  0LL,  v39,  "",  "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke",  v56,  v57,  v58,  v59);
LABEL_54:
            }

            goto LABEL_55;
          }

          int v48 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v10);
          int v49 = _NRLogIsLevelEnabled(v48, 0LL);

          if (v49)
          {
            id v46 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v50);
            id v47 = [WeakRetained copyDescription];
            _NRLogWithArgs( v46,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ connected",  "",  "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke",  1225LL,  v47,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
            goto LABEL_47;
          }
        }

        else
        {
          id v43 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v10);
          int v44 = _NRLogIsLevelEnabled(v43, 0LL);

          if (v44)
          {
            id v46 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v45);
            id v47 = [WeakRetained copyDescription];
            _NRLogWithArgs( v46,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ connected",  "",  "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke",  1228LL,  v47,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
LABEL_47:
          }
        }

        sub_10003E800((uint64_t)WeakRetained);
        goto LABEL_55;
      case 3LL:
        id v18 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v10);
        int v19 = _NRLogIsLevelEnabled(v18, 0LL);

        if (v19)
        {
          id v21 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v20);
          id v22 = [WeakRetained copyDescription];
          _NRLogWithArgs( v21,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ disconnected",  "",  "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke",  1236LL,  v22,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
        }

        int v23 = *(unsigned __int8 *)(a1 + 56);
        if (v23 == 4)
        {
          [WeakRetained setIkeClassDEstablished:0];
        }

        else if (v23 == 3)
        {
          [WeakRetained setIkeClassCEstablished:0];
        }

        if (WeakRetained[212]) {
          sub_10003E628((uint64_t)WeakRetained, *(unsigned __int8 *)(a1 + 56));
        }
        else {
          [WeakRetained invalidateIKESessionForClass:*(unsigned __int8 *)(a1 + 56)];
        }
        goto LABEL_55;
      case 4LL:
        [WeakRetained cancelWithReason:@"%@ session %@ got unexpected MOBIKE state", *(void *)(a1 + 32), *(void *)(a1 + 40)];
        goto LABEL_55;
      default:
        uint64_t v24 = *(void *)(a1 + 32);
        uint64_t v25 = *(void *)(a1 + 40);
        uint64_t v26 = (void *)NEIKEv2CreateSessionStateString(a2);
        [WeakRetained cancelWithReason:@"%@ session %@ got bad IKE state %@", v24, v25, v26];

        goto LABEL_55;
    }
  }

  [WeakRetained reportEvent:3018, @"%@ session %@ got IKE error %@ with state %@", v6, v7, v60, SessionStateString detailsFormat];

  int v9 = *(unsigned __int8 *)(a1 + 56);
  if (v9 == 3)
  {
    [WeakRetained setIkeClassCEstablished:0];
  }

  else if (v9 == 4)
  {
    [WeakRetained setIkeClassDEstablished:0];
  }

  uint64_t v17 = *(unsigned __int8 *)(a1 + 56);
  if (!WeakRetained[208])
  {
    [WeakRetained processIKEDisconnection:v17 error:v60];
    uint64_t v17 = *(unsigned __int8 *)(a1 + 56);
  }

  if (WeakRetained[212]) {
    sub_10003E628((uint64_t)WeakRetained, v17);
  }
  else {
    [WeakRetained invalidateIKESessionForClass:v17];
  }
LABEL_55:
}

void sub_10003DF24(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v14 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    if (v14)
    {
      uint64_t v8 = *(void *)(a1 + 32);
      uint64_t v9 = *(void *)(a1 + 40);
      SessionStateid String = (void *)NEIKEv2CreateSessionStateString(a3);
      [WeakRetained reportEvent:3018, @"%@ session %@ got child %u state update %@ error %@", v8, v9, a2, SessionStateString, v14 detailsFormat];

      if (!WeakRetained[208])
      {
        [WeakRetained processIKEDisconnection:*(unsigned __int8 *)(a1 + 56) error:v14];
      }
    }

    else
    {
      uint64_t v11 = *(void *)(a1 + 32);
      uint64_t v12 = *(void *)(a1 + 40);
      if (a3 != 3)
      {
        id v13 = (void *)NEIKEv2CreateSessionStateString(a3);
        [WeakRetained reportEvent:3009, @"%@ session %@ child %u state update %@", v11, v12, a2, v13 detailsFormat];

        goto LABEL_12;
      }

      [WeakRetained reportEvent:3018, @"%@ session %@ got child %u Disconnected state with no error", v11, *(void *)(a1 + 40), a2 detailsFormat];
    }

    if (WeakRetained[212]) {
      sub_10003E628((uint64_t)WeakRetained, *(unsigned __int8 *)(a1 + 56));
    }
    else {
      [WeakRetained invalidateIKESessionForClass:*(unsigned __int8 *)(a1 + 56)];
    }
  }

void sub_10003E074(uint64_t a1, void *a2)
{
  id v11 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v5 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      id v10 = [v5 copyDescription];
      _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got config update %@",  "",  "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke_3",  1299LL,  v10,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  v11);
    }
  }
}

void sub_10003E140(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v16 = a3;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v10 = WeakRetained;
  if (WeakRetained)
  {
    id v11 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v9);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0LL);

    if (IsLevelEnabled)
    {
      id v14 = (void *)_NRCopyLogObjectForNRUUID(v10[4], v13);
      id v15 = [v10 copyDescription];
      _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got child %u traffic selector update local %@ remote %@",  "",  "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke_4",  1310LL,  v15,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  a2,  v16,  v7);
    }
  }
}

void sub_10003E22C(uint64_t a1, void *a2)
{
  id v11 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v5 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      id v10 = [v5 copyDescription];
      _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got additional addresses %@",  "",  "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke_5",  1319LL,  v10,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  v11);
    }
  }
}

void sub_10003E2F8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    uint64_t v9 = WeakRetained;
    uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v3);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

    id WeakRetained = v9;
    if (IsLevelEnabled)
    {
      id v7 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v6);
      id v8 = [v9 copyDescription];
      _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got short DPD",  "",  "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke_6",  1327LL,  v8,  *(void *)(a1 + 32),  *(void *)(a1 + 40));

      id WeakRetained = v9;
    }
  }
}

void sub_10003E3B8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v6 = WeakRetained;
  if (WeakRetained)
  {
    id v7 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v5);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0LL);

    if (IsLevelEnabled)
    {
      id v10 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v9);
      id v11 = [v6 copyDescription];
      _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got private notifies %@",  "",  "-[NRLinkQuickRelay setupIKECallbacksForClass:]_block_invoke_7",  1335LL,  v11,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  v3);
    }

    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    id v27 = v3;
    id v12 = v3;
    id v13 = [v12 countByEnumeratingWithState:&v28 objects:v32 count:16];
    if (v13)
    {
      id v14 = v13;
      uint64_t v15 = *(void *)v29;
      do
      {
        for (uint64_t i = 0LL; i != v14; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v29 != v15) {
            objc_enumerationMutation(v12);
          }
          uint64_t v17 = *(void **)(*((void *)&v28 + 1) + 8LL * (void)i);
          unsigned int v18 = [v17 notifyStatus];
          id v19 = (id)objc_claimAutoreleasedReturnValue([v17 notifyData]);
          id v21 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v20);
          int v22 = _NRLogIsLevelEnabled(v21, 1LL);

          if (v22)
          {
            uint64_t v24 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v23);
            id v25 = [v6 copyDescription];
            _NRLogWithArgs( v24,  1LL,  "%s%.30s:%-4d %@: Received notify code %u %@",  "",  "-[NRLinkQuickRelay handleNotifyCode:payload:]",  1346LL,  v25,  v18,  v19);
          }

          if (v18 == 50702)
          {
            uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([v6 linkDelegate]);
            [v26 linkDidReceiveData:v6 data:v19];
          }
        }

        id v14 = [v12 countByEnumeratingWithState:&v28 objects:v32 count:16];
      }

      while (v14);
    }

    id v3 = v27;
  }
}

void sub_10003E628(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([(id)a1 queue]);
  dispatch_assert_queue_V2(v4);

  [(id)a1 invalidateIKESessionForClass:a2];
  if ((_DWORD)a2 == 4)
  {
    if (++*(_BYTE *)(a1 + 218) >= 3u)
    {
      id v13 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v13, 0LL);

      if (IsLevelEnabled)
      {
        id v16 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v15);
        id v17 = [(id)a1 copyDescription];
        _NRLogWithArgs( v16,  0LL,  "%s%.30s:%-4d %@: hit max number of retries for ClassD IKE. Will retry when path changes",  "",  "-[NRLinkQuickRelay restartIKESessionForClass:]",  1137LL,  v17);
      }

      id v11 = (void *)a1;
      uint64_t v12 = 10023LL;
      goto LABEL_11;
    }
  }

  else if ((_DWORD)a2 == 3 && ++*(_BYTE *)(a1 + 219) >= 3u)
  {
    uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
    int v7 = _NRLogIsLevelEnabled(v6, 0LL);

    if (v7)
    {
      uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v8);
      id v10 = [(id)a1 copyDescription];
      _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: hit max number of retries for ClassC IKE. Will retry when path changes",  "",  "-[NRLinkQuickRelay restartIKESessionForClass:]",  1130LL,  v10);
    }

    id v11 = (void *)a1;
    uint64_t v12 = 10024LL;
LABEL_11:
    [v11 reportEvent:v12];
    return;
  }

  sub_10003CE18(a1, a2);
}

void sub_10003E7E0(uint64_t a1, void *a2)
{
}

void sub_10003E7F0(uint64_t a1, void *a2)
{
}

void sub_10003E800(uint64_t a1)
{
  uint64_t v2 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([(id)a1 queue]);
  dispatch_assert_queue_V2(v2);

  if ([(id)a1 state] != 255)
  {
    sub_10003EA98(a1);
    [*(id *)(a1 + 279) setAvailability:1];
    if (*(_BYTE *)(a1 + 211))
    {
      *(_BYTE *)(a1 + 211) = 0;
      if (*(_BYTE *)(a1 + 209))
      {
        dispatch_resume(*(dispatch_object_t *)(a1 + 319));
        *(_BYTE *)(a1 + 209) = 0;
      }
    }

    [(id)a1 changeStateTo:8];
    id v3 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 linkDelegate]);
    [v3 linkIsReady:a1];

    if (!*(_BYTE *)(a1 + 222))
    {
      uint64_t v4 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([(id)a1 queue]);
      dispatch_assert_queue_V2(v4);

      uint64_t v5 = *(dispatch_source_s **)(a1 + 615);
      if (v5)
      {
        dispatch_source_cancel(v5);
        uint64_t v6 = *(void **)(a1 + 615);
        *(void *)(a1 + 615) = 0LL;
      }

      if ([(id)a1 state] == 255)
      {
        uint64_t v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v7);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 0LL);

        if (IsLevelEnabled)
        {
          uint64_t v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v14);
          id v16 = [(id)a1 copyDescription];
          _NRLogWithArgs( v15,  0LL,  "%s%.30s:%-4d %@: not arming link timeout as link is cancelled",  "",  "-[NRLinkQuickRelay armIKELinkTimeout]",  1025LL,  v16);
        }
      }

      else if (!*(void *)(a1 + 615))
      {
        uint64_t v8 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([(id)a1 queue]);
        uint64_t v9 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0LL, 0LL, v8);

        dispatch_time_t v10 = dispatch_time(0x8000000000000000LL, 21600000000000LL);
        dispatch_source_set_timer(v9, v10, 0xFFFFFFFFFFFFFFFFLL, 0LL);
        objc_initWeak(&location, (id)a1);
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 3221225472LL;
        handler[2] = sub_100040768;
        handler[3] = &unk_1001AFED0;
        objc_copyWeak(&v18, &location);
        dispatch_source_set_event_handler(v9, handler);
        dispatch_activate(v9);
        id v11 = *(void **)(a1 + 615);
        *(void *)(a1 + 615) = v9;

        objc_destroyWeak(&v18);
        objc_destroyWeak(&location);
      }

      *(_BYTE *)(a1 + 222) = 1;
    }
  }

void sub_10003EA98(uint64_t a1)
{
  uint64_t v2 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([(id)a1 queue]);
  dispatch_assert_queue_V2(v2);

  if (!*(void *)(a1 + 295))
  {
    id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 279) nexusInstances]);
    uint64_t v5 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v4);
    uint64_t v6 = (void *)v5;
    if (v3)
    {
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 1LL);

      if (IsLevelEnabled)
      {
        uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v8);
        id v10 = [(id)a1 copyDescription];
        _NRLogWithArgs( v9,  1LL,  "%s%.30s:%-4d %@: Created nexus instances: %@",  "",  "-[NRLinkQuickRelay setupNexus]",  787LL,  v10,  v3);
      }

      if ([v3 count] == 1)
      {
        uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v3 firstObject]);
        uint64_t v13 = os_channel_attr_create([v12 getUUIDBytes:v333]);
        uint64_t v15 = v13;
        if (!v13)
        {
          uint64_t v33 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v14);
          int v34 = _NRLogIsLevelEnabled(v33, 17LL);

          if (v34)
          {
            uint64_t v36 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v35);
            id v37 = [(id)a1 copyDescription];
            _NRLogWithArgs(v36, 17LL, "%@: os_channel_attr_create failed", v37);
          }

          goto LABEL_25;
        }

        os_channel_attr_set(v13, 7LL, 1LL);
        uint64_t extended = os_channel_create_extended(v333, 0LL, 0LL, 0xFFFFFFFFLL, v15);
        uint64_t v17 = extended;
        if (!extended)
        {
          int v38 = *__error();
          if (qword_1001DC758 != -1) {
            dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC750, 17LL))
          {
            id v39 = sub_10003B584();
            _NRLogWithArgs(v39, 17LL, "os_channel_create_extended failed: [%d] %s", v38, (const char *)v332);
          }

          NEVirtualInterfaceDisableChannel([(id)a1 virtualInterface]);
          os_channel_attr_destroy(v15);
          goto LABEL_25;
        }

        *(void *)(a1 + 295) = extended;
        v332[0] = 0LL;
        uint64_t v18 = os_channel_attr_get(v15, 0LL, v332);
        uint64_t v20 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v19);
        id v21 = (void *)v20;
        if ((_DWORD)v18)
        {
          int v22 = _NRLogIsLevelEnabled(v20, 17LL);

          if (v22)
          {
            uint64_t v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v23);
            id v25 = [(id)a1 copyDescription];
            _NRLogWithArgs(v24, 17LL, "%@: os_channel_attr_get(TX_RINGS) returned %d", v25, v18);
          }

          goto LABEL_25;
        }

        int v40 = _NRLogIsLevelEnabled(v20, 1LL);

        if (v40)
        {
          int v42 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v41);
          id v43 = [(id)a1 copyDescription];
          _NRLogWithArgs( v42,  1LL,  "%s%.30s:%-4d %@: Nexus Channel TX_RINGS = %llu",  "",  "-[NRLinkQuickRelay setupNexus]",  832LL,  v43,  v332[0]);
        }

        v332[0] = 0LL;
        uint64_t v44 = os_channel_attr_get(v15, 1LL, v332);
        uint64_t v46 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v45);
        id v47 = (void *)v46;
        if ((_DWORD)v44)
        {
          int v48 = _NRLogIsLevelEnabled(v46, 17LL);

          if (v48)
          {
            uint64_t v50 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v49);
            id v51 = [(id)a1 copyDescription];
            _NRLogWithArgs(v50, 17LL, "%@: os_channel_attr_get(RX_RINGS) returned %d", v51, v44);
          }

          goto LABEL_25;
        }

        int v52 = _NRLogIsLevelEnabled(v46, 1LL);

        if (v52)
        {
          int v54 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v53);
          id v55 = [(id)a1 copyDescription];
          _NRLogWithArgs( v54,  1LL,  "%s%.30s:%-4d %@: Nexus Channel RX_RINGS = %llu",  "",  "-[NRLinkQuickRelay setupNexus]",  833LL,  v55,  v332[0]);
        }

        v332[0] = 0LL;
        uint64_t v56 = os_channel_attr_get(v15, 2LL, v332);
        uint64_t v58 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v57);
        uint64_t v59 = (void *)v58;
        if ((_DWORD)v56)
        {
          int v60 = _NRLogIsLevelEnabled(v58, 17LL);

          if (v60)
          {
            id v62 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v61);
            id v63 = [(id)a1 copyDescription];
            _NRLogWithArgs(v62, 17LL, "%@: os_channel_attr_get(TX_SLOTS) returned %d", v63, v56);
          }

          goto LABEL_25;
        }

        int v64 = _NRLogIsLevelEnabled(v58, 1LL);

        if (v64)
        {
          uint64_t v66 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v65);
          id v67 = [(id)a1 copyDescription];
          _NRLogWithArgs( v66,  1LL,  "%s%.30s:%-4d %@: Nexus Channel TX_SLOTS = %llu",  "",  "-[NRLinkQuickRelay setupNexus]",  834LL,  v67,  v332[0]);
        }

        v332[0] = 0LL;
        uint64_t v68 = os_channel_attr_get(v15, 3LL, v332);
        uint64_t v70 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v69);
        uint64_t v71 = (void *)v70;
        if ((_DWORD)v68)
        {
          int v72 = _NRLogIsLevelEnabled(v70, 17LL);

          if (v72)
          {
            uint64_t v74 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v73);
            id v75 = [(id)a1 copyDescription];
            _NRLogWithArgs(v74, 17LL, "%@: os_channel_attr_get(RX_SLOTS) returned %d", v75, v68);
          }

          goto LABEL_25;
        }

        int v76 = _NRLogIsLevelEnabled(v70, 1LL);

        if (v76)
        {
          id v78 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v77);
          id v79 = [(id)a1 copyDescription];
          _NRLogWithArgs( v78,  1LL,  "%s%.30s:%-4d %@: Nexus Channel RX_SLOTS = %llu",  "",  "-[NRLinkQuickRelay setupNexus]",  835LL,  v79,  v332[0]);
        }

        v332[0] = 0LL;
        uint64_t v80 = os_channel_attr_get(v15, 4LL, v332);
        uint64_t v82 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v81);
        id v83 = (void *)v82;
        if ((_DWORD)v80)
        {
          int v84 = _NRLogIsLevelEnabled(v82, 17LL);

          if (v84)
          {
            __int128 v86 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v85);
            id v87 = [(id)a1 copyDescription];
            _NRLogWithArgs(v86, 17LL, "%@: os_channel_attr_get(SLOT_BUF_SIZE) returned %d", v87, v80);
          }

          goto LABEL_25;
        }

        int v88 = _NRLogIsLevelEnabled(v82, 1LL);

        if (v88)
        {
          id v90 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v89);
          id v91 = [(id)a1 copyDescription];
          _NRLogWithArgs( v90,  1LL,  "%s%.30s:%-4d %@: Nexus Channel SLOT_BUF_SIZE = %llu",  "",  "-[NRLinkQuickRelay setupNexus]",  836LL,  v91,  v332[0]);
        }

        v332[0] = 0LL;
        uint64_t v92 = os_channel_attr_get(v15, 5LL, v332);
        uint64_t v94 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v93);
        NSUInteger v95 = (void *)v94;
        if ((_DWORD)v92)
        {
          int v96 = _NRLogIsLevelEnabled(v94, 17LL);

          if (v96)
          {
            uint64_t v98 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v97);
            id v99 = [(id)a1 copyDescription];
            _NRLogWithArgs(v98, 17LL, "%@: os_channel_attr_get(SLOT_META_SIZE) returned %d", v99, v92);
          }

          goto LABEL_25;
        }

        int v100 = _NRLogIsLevelEnabled(v94, 1LL);

        if (v100)
        {
          uint64_t v102 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v101);
          id v103 = [(id)a1 copyDescription];
          _NRLogWithArgs( v102,  1LL,  "%s%.30s:%-4d %@: Nexus Channel SLOT_META_SIZE = %llu",  "",  "-[NRLinkQuickRelay setupNexus]",  837LL,  v103,  v332[0]);
        }

        v332[0] = 0LL;
        uint64_t v104 = os_channel_attr_get(v15, 6LL, v332);
        uint64_t v106 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v105);
        __int128 v107 = (void *)v106;
        if ((_DWORD)v104)
        {
          int v108 = _NRLogIsLevelEnabled(v106, 17LL);

          if (v108)
          {
            __int128 v110 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v109);
            id v111 = [(id)a1 copyDescription];
            _NRLogWithArgs(v110, 17LL, "%@: os_channel_attr_get(EXCLUSIVE) returned %d", v111, v104);
          }

          goto LABEL_25;
        }

        int v112 = _NRLogIsLevelEnabled(v106, 1LL);

        if (v112)
        {
          id v114 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v113);
          id v115 = [(id)a1 copyDescription];
          _NRLogWithArgs( v114,  1LL,  "%s%.30s:%-4d %@: Nexus Channel EXCLUSIVE = %llu",  "",  "-[NRLinkQuickRelay setupNexus]",  838LL,  v115,  v332[0]);
        }

        v332[0] = 0LL;
        uint64_t v116 = os_channel_attr_get(v15, 7LL, v332);
        uint64_t v118 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v117);
        __int128 v119 = (void *)v118;
        if ((_DWORD)v116)
        {
          int v120 = _NRLogIsLevelEnabled(v118, 17LL);

          if (v120)
          {
            __int128 v122 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v121);
            id v123 = [(id)a1 copyDescription];
            _NRLogWithArgs(v122, 17LL, "%@: os_channel_attr_get(NO_AUTO_SYNC) returned %d", v123, v116);
          }

          goto LABEL_25;
        }

        int v124 = _NRLogIsLevelEnabled(v118, 1LL);

        if (v124)
        {
          __int128 v126 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v125);
          id v127 = [(id)a1 copyDescription];
          _NRLogWithArgs( v126,  1LL,  "%s%.30s:%-4d %@: Nexus Channel NO_AUTO_SYNC = %llu",  "",  "-[NRLinkQuickRelay setupNexus]",  839LL,  v127,  v332[0]);
        }

        v332[0] = 0LL;
        uint64_t v128 = os_channel_attr_get(v15, 8LL, v332);
        uint64_t v130 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v129);
        v131 = (void *)v130;
        if ((_DWORD)v128)
        {
          int v132 = _NRLogIsLevelEnabled(v130, 17LL);

          if (v132)
          {
            v134 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v133);
            id v135 = [(id)a1 copyDescription];
            _NRLogWithArgs(v134, 17LL, "%@: os_channel_attr_get(MONITOR) returned %d", v135, v128);
          }

          goto LABEL_25;
        }

        int v136 = _NRLogIsLevelEnabled(v130, 1LL);

        if (v136)
        {
          v138 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v137);
          id v139 = [(id)a1 copyDescription];
          _NRLogWithArgs( v138,  1LL,  "%s%.30s:%-4d %@: Nexus Channel MONITOR = %llu",  "",  "-[NRLinkQuickRelay setupNexus]",  840LL,  v139,  v332[0]);
        }

        v332[0] = 0LL;
        uint64_t v140 = os_channel_attr_get(v15, 9LL, v332);
        uint64_t v142 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v141);
        v143 = (void *)v142;
        if ((_DWORD)v140)
        {
          int v144 = _NRLogIsLevelEnabled(v142, 17LL);

          if (v144)
          {
            v146 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v145);
            id v147 = [(id)a1 copyDescription];
            _NRLogWithArgs(v146, 17LL, "%@: os_channel_attr_get(TX_LOWAT_UNIT) returned %d", v147, v140);
          }

          goto LABEL_25;
        }

        int v148 = _NRLogIsLevelEnabled(v142, 1LL);

        if (v148)
        {
          v150 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v149);
          id v151 = [(id)a1 copyDescription];
          _NRLogWithArgs( v150,  1LL,  "%s%.30s:%-4d %@: Nexus Channel TX_LOWAT_UNIT = %llu",  "",  "-[NRLinkQuickRelay setupNexus]",  841LL,  v151,  v332[0]);
        }

        v332[0] = 0LL;
        uint64_t v152 = os_channel_attr_get(v15, 10LL, v332);
        uint64_t v154 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v153);
        v155 = (void *)v154;
        if ((_DWORD)v152)
        {
          int v156 = _NRLogIsLevelEnabled(v154, 17LL);

          if (v156)
          {
            v158 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v157);
            id v159 = [(id)a1 copyDescription];
            _NRLogWithArgs(v158, 17LL, "%@: os_channel_attr_get(TX_LOWAT_VALUE) returned %d", v159, v152);
          }

          goto LABEL_25;
        }

        int v160 = _NRLogIsLevelEnabled(v154, 1LL);

        if (v160)
        {
          v162 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v161);
          id v163 = [(id)a1 copyDescription];
          _NRLogWithArgs( v162,  1LL,  "%s%.30s:%-4d %@: Nexus Channel TX_LOWAT_VALUE = %llu",  "",  "-[NRLinkQuickRelay setupNexus]",  842LL,  v163,  v332[0]);
        }

        v332[0] = 0LL;
        uint64_t v164 = os_channel_attr_get(v15, 11LL, v332);
        uint64_t v166 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v165);
        v167 = (void *)v166;
        if ((_DWORD)v164)
        {
          int v168 = _NRLogIsLevelEnabled(v166, 17LL);

          if (v168)
          {
            v170 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v169);
            id v171 = [(id)a1 copyDescription];
            _NRLogWithArgs(v170, 17LL, "%@: os_channel_attr_get(RX_LOWAT_UNIT) returned %d", v171, v164);
          }

          goto LABEL_25;
        }

        int v172 = _NRLogIsLevelEnabled(v166, 1LL);

        if (v172)
        {
          v174 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v173);
          id v175 = [(id)a1 copyDescription];
          _NRLogWithArgs( v174,  1LL,  "%s%.30s:%-4d %@: Nexus Channel RX_LOWAT_UNIT = %llu",  "",  "-[NRLinkQuickRelay setupNexus]",  843LL,  v175,  v332[0]);
        }

        v332[0] = 0LL;
        uint64_t v176 = os_channel_attr_get(v15, 12LL, v332);
        uint64_t v178 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v177);
        v179 = (void *)v178;
        if ((_DWORD)v176)
        {
          int v180 = _NRLogIsLevelEnabled(v178, 17LL);

          if (v180)
          {
            v182 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v181);
            id v183 = [(id)a1 copyDescription];
            _NRLogWithArgs(v182, 17LL, "%@: os_channel_attr_get(RX_LOWAT_VALUE) returned %d", v183, v176);
          }

          goto LABEL_25;
        }

        int v184 = _NRLogIsLevelEnabled(v178, 1LL);

        if (v184)
        {
          v186 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v185);
          id v187 = [(id)a1 copyDescription];
          _NRLogWithArgs( v186,  1LL,  "%s%.30s:%-4d %@: Nexus Channel RX_LOWAT_VALUE = %llu",  "",  "-[NRLinkQuickRelay setupNexus]",  844LL,  v187,  v332[0]);
        }

        v332[0] = 0LL;
        uint64_t v188 = os_channel_attr_get(v15, 13LL, v332);
        uint64_t v190 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v189);
        v191 = (void *)v190;
        if ((_DWORD)v188)
        {
          int v192 = _NRLogIsLevelEnabled(v190, 17LL);

          if (v192)
          {
            v194 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v193);
            id v195 = [(id)a1 copyDescription];
            _NRLogWithArgs(v194, 17LL, "%@: os_channel_attr_get(NEXUS_TYPE) returned %d", v195, v188);
          }

          goto LABEL_25;
        }

        int v196 = _NRLogIsLevelEnabled(v190, 1LL);

        if (v196)
        {
          v198 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v197);
          id v199 = [(id)a1 copyDescription];
          _NRLogWithArgs( v198,  1LL,  "%s%.30s:%-4d %@: Nexus Channel NEXUS_TYPE = %llu",  "",  "-[NRLinkQuickRelay setupNexus]",  845LL,  v199,  v332[0]);
        }

        v332[0] = 0LL;
        uint64_t v200 = os_channel_attr_get(v15, 14LL, v332);
        uint64_t v202 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v201);
        v203 = (void *)v202;
        if ((_DWORD)v200)
        {
          int v204 = _NRLogIsLevelEnabled(v202, 17LL);

          if (v204)
          {
            v206 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v205);
            id v207 = [(id)a1 copyDescription];
            _NRLogWithArgs(v206, 17LL, "%@: os_channel_attr_get(NEXUS_EXTENSIONS) returned %d", v207, v200);
          }

          goto LABEL_25;
        }

        int v208 = _NRLogIsLevelEnabled(v202, 1LL);

        if (v208)
        {
          v210 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v209);
          id v211 = [(id)a1 copyDescription];
          _NRLogWithArgs( v210,  1LL,  "%s%.30s:%-4d %@: Nexus Channel NEXUS_EXTENSIONS = %llu",  "",  "-[NRLinkQuickRelay setupNexus]",  846LL,  v211,  v332[0]);
        }

        v332[0] = 0LL;
        uint64_t v212 = os_channel_attr_get(v15, 15LL, v332);
        uint64_t v214 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v213);
        v215 = (void *)v214;
        if ((_DWORD)v212)
        {
          int v216 = _NRLogIsLevelEnabled(v214, 17LL);

          if (v216)
          {
            v218 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v217);
            id v219 = [(id)a1 copyDescription];
            _NRLogWithArgs(v218, 17LL, "%@: os_channel_attr_get(NEXUS_MHINTS) returned %d", v219, v212);
          }

          goto LABEL_25;
        }

        int v220 = _NRLogIsLevelEnabled(v214, 1LL);

        if (v220)
        {
          v222 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v221);
          id v223 = [(id)a1 copyDescription];
          _NRLogWithArgs( v222,  1LL,  "%s%.30s:%-4d %@: Nexus Channel NEXUS_MHINTS = %llu",  "",  "-[NRLinkQuickRelay setupNexus]",  847LL,  v223,  v332[0]);
        }

        v332[0] = 0LL;
        uint64_t v224 = os_channel_attr_get(v15, 18LL, v332);
        uint64_t v226 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v225);
        v227 = (void *)v226;
        if ((_DWORD)v224)
        {
          int v228 = _NRLogIsLevelEnabled(v226, 17LL);

          if (v228)
          {
            v230 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v229);
            id v231 = [(id)a1 copyDescription];
            _NRLogWithArgs(v230, 17LL, "%@: os_channel_attr_get(NEXUS_IFINDEX) returned %d", v231, v224);
          }

          goto LABEL_25;
        }

        int v232 = _NRLogIsLevelEnabled(v226, 1LL);

        if (v232)
        {
          v234 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v233);
          id v235 = [(id)a1 copyDescription];
          _NRLogWithArgs( v234,  1LL,  "%s%.30s:%-4d %@: Nexus Channel NEXUS_IFINDEX = %llu",  "",  "-[NRLinkQuickRelay setupNexus]",  848LL,  v235,  v332[0]);
        }

        v332[0] = 0LL;
        uint64_t v236 = os_channel_attr_get(v15, 19LL, v332);
        uint64_t v238 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v237);
        v239 = (void *)v238;
        if ((_DWORD)v236)
        {
          int v240 = _NRLogIsLevelEnabled(v238, 17LL);

          if (v240)
          {
            v242 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v241);
            id v243 = [(id)a1 copyDescription];
            _NRLogWithArgs(v242, 17LL, "%@: os_channel_attr_get(NEXUS_STATS_SIZE) returned %d", v243, v236);
          }

          goto LABEL_25;
        }

        int v244 = _NRLogIsLevelEnabled(v238, 1LL);

        if (v244)
        {
          v246 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v245);
          id v247 = [(id)a1 copyDescription];
          _NRLogWithArgs( v246,  1LL,  "%s%.30s:%-4d %@: Nexus Channel NEXUS_STATS_SIZE = %llu",  "",  "-[NRLinkQuickRelay setupNexus]",  849LL,  v247,  v332[0]);
        }

        v332[0] = 0LL;
        uint64_t v248 = os_channel_attr_get(v15, 20LL, v332);
        uint64_t v250 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v249);
        v251 = (void *)v250;
        if ((_DWORD)v248)
        {
          int v252 = _NRLogIsLevelEnabled(v250, 17LL);

          if (v252)
          {
            v254 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v253);
            id v255 = [(id)a1 copyDescription];
            _NRLogWithArgs(v254, 17LL, "%@: os_channel_attr_get(NEXUS_FLOWADV_MAX) returned %d", v255, v248);
          }

          goto LABEL_25;
        }

        int v256 = _NRLogIsLevelEnabled(v250, 1LL);

        if (v256)
        {
          v258 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v257);
          id v259 = [(id)a1 copyDescription];
          _NRLogWithArgs( v258,  1LL,  "%s%.30s:%-4d %@: Nexus Channel NEXUS_FLOWADV_MAX = %llu",  "",  "-[NRLinkQuickRelay setupNexus]",  850LL,  v259,  v332[0]);
        }

        os_channel_attr_destroy(v15);
        uint64_t v260 = os_channel_ring_id(*(void *)(a1 + 295), 2LL);
        uint64_t v261 = os_channel_rx_ring(*(void *)(a1 + 295), v260);
        *(void *)(a1 + 303) = v261;
        if (!v261)
        {
          v283 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v262);
          int v284 = _NRLogIsLevelEnabled(v283, 17LL);

          if (v284)
          {
            v286 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v285);
            id v287 = [(id)a1 copyDescription];
            _NRLogWithArgs(v286, 17LL, "%@: _nexusInputRing is NULL", v287);
          }

          goto LABEL_25;
        }

        uint64_t v263 = os_channel_ring_id(*(void *)(a1 + 295), 0LL);
        uint64_t v264 = os_channel_tx_ring(*(void *)(a1 + 295), v263);
        *(void *)(a1 + 311) = v264;
        if (!v264)
        {
          v288 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v265);
          int v289 = _NRLogIsLevelEnabled(v288, 17LL);

          if (v289)
          {
            v291 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v290);
            id v292 = [(id)a1 copyDescription];
            _NRLogWithArgs(v291, 17LL, "%@: _nexusOutputRing is NULL", v292);
          }

          goto LABEL_25;
        }

        unsigned int fd = os_channel_get_fd(*(void *)(a1 + 295));
        if ((fd & 0x80000000) != 0)
        {
          v293 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v266);
          int v294 = _NRLogIsLevelEnabled(v293, 17LL);

          if (v294)
          {
            v296 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v295);
            id v297 = [(id)a1 copyDescription];
            _NRLogWithArgs(v296, 17LL, "%@: os_channel_get_fd failed", v297);
          }

          goto LABEL_25;
        }

        dispatch_group_t v268 = dispatch_group_create();
        if (v268)
        {
          v269 = v268;
          dispatch_source_t v270 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_read,  fd,  0LL,  *(dispatch_queue_t *)(a1 + 8));
          v271 = *(void **)(a1 + 319);
          *(void *)(a1 + 319) = v270;

          if (*(void *)(a1 + 319))
          {
            objc_initWeak(v332, (id)a1);
            v272 = *(dispatch_source_s **)(a1 + 319);
            v330[0] = _NSConcreteStackBlock;
            v330[1] = 3221225472LL;
            v330[2] = sub_1000408D8;
            v330[3] = &unk_1001AFED0;
            v322 = &v331;
            objc_copyWeak(&v331, v332);
            dispatch_source_set_event_handler(v272, v330);
            dispatch_group_enter(v269);
            v273 = *(dispatch_source_s **)(a1 + 319);
            v328[0] = _NSConcreteStackBlock;
            v328[1] = 3221225472LL;
            v328[2] = sub_100040DFC;
            v328[3] = &unk_1001B0A88;
            v274 = v269;
            v329 = v274;
            dispatch_source_set_cancel_handler(v273, v328);
            dispatch_activate(*(dispatch_object_t *)(a1 + 319));
            dispatch_source_t v275 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_write,  fd,  0LL,  *(dispatch_queue_t *)(a1 + 8));
            v276 = *(void **)(a1 + 327);
            *(void *)(a1 + 327) = v275;

            v277 = *(dispatch_source_s **)(a1 + 327);
            if (v277)
            {
              v326[0] = _NSConcreteStackBlock;
              v326[1] = 3221225472LL;
              v326[2] = sub_100040E04;
              v326[3] = &unk_1001AFED0;
              objc_copyWeak(&v327, v332);
              dispatch_source_set_event_handler(v277, v326);
              dispatch_group_enter(v274);
              v278 = *(dispatch_source_s **)(a1 + 327);
              v324[0] = _NSConcreteStackBlock;
              v324[1] = 3221225472LL;
              v324[2] = sub_10004140C;
              v324[3] = &unk_1001B0A88;
              v279 = v274;
              v325 = v279;
              dispatch_source_set_cancel_handler(v278, v324);
              *(_BYTE *)(a1 + 210) = 1;
              v280 = *(dispatch_queue_s **)(a1 + 8);
              v323[0] = _NSConcreteStackBlock;
              v323[1] = 3221225472LL;
              v323[2] = sub_100041414;
              v323[3] = &unk_1001B0578;
              v323[4] = v17;
              dispatch_group_notify(v279, v280, v323);
              v281 = *(void **)(a1 + 335);
              *(void *)(a1 + 335) = v279;
              v282 = v279;

              objc_destroyWeak(&v327);
              objc_destroyWeak(v322);
              objc_destroyWeak(v332);
LABEL_25:

              goto LABEL_26;
            }

            id v314 = sub_10003B584();
            char v315 = _NRLogIsLevelEnabled(v314, 16LL);

            if ((v315 & 1) != 0)
            {
              id v316 = sub_10003B584();
              _NRLogWithArgs( v316,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusWriteSource) != ((void *)0)",  "",  "-[NRLinkQuickRelay setupNexus]",  919);
            }

            uint64_t v317 = _os_log_pack_size(12LL);
            v318 = (char *)&v323[-1] - ((__chkstk_darwin(v317) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            v319 = __error();
            uint64_t v320 = _os_log_pack_fill( v318,  v317,  *v319,  &_mh_execute_header,  "%{public}s Assertion Failed: (_dNexusWriteSource) != ((void *)0)",  v322);
            *(_DWORD *)uint64_t v320 = 136446210;
            *(void *)(v320 + 4) = "-[NRLinkQuickRelay setupNexus]";
            id v321 = sub_10003B584();
            _NRLogAbortWithPack(v321, v318);
          }

          else
          {
            id v306 = sub_10003B584();
            int v307 = _NRLogIsLevelEnabled(v306, 16LL);

            if (v307)
            {
              id v308 = sub_10003B584();
              _NRLogWithArgs( v308,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (_dNexusReadSource) != ((void *)0)",  "",  "-[NRLinkQuickRelay setupNexus]",  884);
            }

            uint64_t v309 = _os_log_pack_size(12LL);
            v310 = (char *)&v323[-1] - ((((uint64_t (*)(void))__chkstk_darwin)() + 15) & 0xFFFFFFFFFFFFFFF0LL);
            v311 = __error();
            uint64_t v312 = _os_log_pack_fill( v310,  v309,  *v311,  &_mh_execute_header,  "%{public}s Assertion Failed: (_dNexusReadSource) != ((void *)0)");
            *(_DWORD *)uint64_t v312 = 136446210;
            *(void *)(v312 + 4) = "-[NRLinkQuickRelay setupNexus]";
            id v313 = sub_10003B584();
            _NRLogAbortWithPack(v313, v310);
          }
        }

        else
        {
          id v298 = sub_10003B584();
          int v299 = _NRLogIsLevelEnabled(v298, 16LL);

          if (v299)
          {
            id v300 = sub_10003B584();
            _NRLogWithArgs( v300,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nexusGroup) != ((void *)0)",  "",  "-[NRLinkQuickRelay setupNexus]",  881);
          }

          uint64_t v301 = _os_log_pack_size(12LL);
          v302 = (char *)&v323[-1] - ((((uint64_t (*)(void))__chkstk_darwin)() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          v303 = __error();
          uint64_t v304 = _os_log_pack_fill( v302,  v301,  *v303,  &_mh_execute_header,  "%{public}s Assertion Failed: (nexusGroup) != ((void *)0)");
          *(_DWORD *)uint64_t v304 = 136446210;
          *(void *)(v304 + 4) = "-[NRLinkQuickRelay setupNexus]";
          id v305 = sub_10003B584();
          _NRLogAbortWithPack(v305, v302);
        }

        __break(1u);
        return;
      }

      __int128 v30 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v11);
      int v31 = _NRLogIsLevelEnabled(v30, 17LL);

      if (v31)
      {
        __int128 v28 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v32);
        id v29 = [(id)a1 copyDescription];
        _NRLogWithArgs(v28, 17LL, "%@: Expected to receive count: %@", v29, v3);
        goto LABEL_15;
      }
    }

    else
    {
      int v26 = _NRLogIsLevelEnabled(v5, 17LL);

      if (v26)
      {
        __int128 v28 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v27);
        id v29 = [(id)a1 copyDescription];
        _NRLogWithArgs(v28, 17LL, "%@: Failed to get nexus instances", v29);
LABEL_15:
      }
    }

void sub_100040740(_Unwind_Exception *a1)
{
}

void sub_100040768(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v8 = WeakRetained;
    if (gNRPacketLoggingEnabled)
    {
      id v3 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v2);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1LL);

      id WeakRetained = v8;
      if (IsLevelEnabled)
      {
        uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(v8[4], v5);
        id v7 = [v8 copyDescription];
        _NRLogWithArgs( v6,  1LL,  "%s%.30s:%-4d %@: IKE Link Timeout fired",  "",  "-[NRLinkQuickRelay armIKELinkTimeout]_block_invoke",  1042LL,  v7);

        id WeakRetained = v8;
      }
    }

    if ([WeakRetained state] == 8)
    {
      id WeakRetained = v8;
LABEL_9:
      *((_BYTE *)WeakRetained + 221) = 1;
      goto LABEL_10;
    }

    id WeakRetained = v8;
    if (*(void *)((char *)v8 + 415) != *(void *)((char *)v8 + 391)
      || *(void *)((char *)v8 + 423) != *(void *)((char *)v8 + 407)
      || *(void *)((char *)v8 + 375) != *(void *)((char *)v8 + 367))
    {
      goto LABEL_9;
    }

    [v8 cancelWithReason:@"Cancelling after timeout"];
    id WeakRetained = v8;
  }

void sub_1000408D8(uint64_t a1)
{
  id WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 32));
  id v3 = WeakRetained;
  if (WeakRetained)
  {
    if (WeakRetained[16] == 255)
    {
      uint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v2);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v13, 16LL);

      if (IsLevelEnabled)
      {
        uint64_t v4 = (char *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v15);
        id v11 = [v3 copyDescription];
        _NRLogWithArgs( v4,  16LL,  "%s%.30s:%-4d %@: Nexus input available but cancelled",  "",  "-[NRLinkQuickRelay setupNexus]_block_invoke",  895LL,  v11);
LABEL_26:

        goto LABEL_27;
      }
    }

    else
    {
      if (gNRPacketLoggingEnabled)
      {
        uint64_t v33 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v2);
        int v34 = _NRLogIsLevelEnabled(v33, 1LL);

        if (v34)
        {
          uint64_t v36 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v35);
          id v37 = [v3 copyDescription];
          _NRLogWithArgs( v36,  1LL,  "%s%.30s:%-4d %@: Nexus input available",  "",  "-[NRLinkQuickRelay setupNexus]_block_invoke",  899LL,  v37);
        }
      }

      ++*(void *)(v3 + 447);
      if (*(void *)(v3 + 231))
      {
        uint64_t v4 = v3;
        uint64_t v5 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([v4 queue]);
        dispatch_assert_queue_V2(v5);

        int v7 = v3[16];
        if (v7 == 255)
        {
          uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v4 + 4), v6);
          int v9 = _NRLogIsLevelEnabled(v8, 16LL);

          if (v9)
          {
            id v11 = (id)_NRCopyLogObjectForNRUUID(*((void *)v4 + 4), v10);
            id v12 = [v4 copyDescription];
            _NRLogWithArgs(v11, 16LL, "%s%.30s:%-4d %@: link is cancelled", "", "NRLinkLoopInterfaceToQR", 1894LL, v12);
LABEL_25:

            goto LABEL_26;
          }

LABEL_28:
}

  if (a3)
  {
    if (*(void *)a3->__u6_addr8 != *(void *)&ifa_addr->sa_data[6]
      || *(void *)&a3->__u6_addr32[2] != *(void *)&ifa_addr[1].sa_len)
    {
      goto LABEL_12;
    }
  }

  if (!-[NRBabelInterface isLocalAddressEqualTo:](v10, "isLocalAddressEqualTo:", &ifa_addr->sa_data[6]))
  {
    if (v7[278] != (__objc2_meth_list *)-1LL) {
      dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
    }
    if (_NRLogIsLevelEnabled(p_class_meths[277], 1LL))
    {
      if (v7[278] != (__objc2_meth_list *)-1LL) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      id v25 = p_class_meths[277];
      int v26 = -[NRBabelInterface localAddress](v10, "localAddress");
      __int128 v28 = (void *)createIPv6AddrString(v26, v27);
      __int128 v30 = (void *)createIPv6AddrString(&ifa_addr->sa_data[6], v29);
      _NRLogWithArgs( v25,  1LL,  "%s%.30s:%-4d changing %@ address from %@ to %@",  "",  "-[NRBabelInterfaceSocket setupLocalAddressCheckAgainst:]",  1010LL,  v10,  v28,  v30);
    }
  }

  -[NRBabelInterface setLocalAddress:](v10, "setLocalAddress:", &ifa_addr->sa_data[6]);

  freeifaddrs(v32);
  if (!a3 || (uint64_t v24 = -[NRBabelInterface isLocalAddressEqualTo:](v10, "isLocalAddressEqualTo:", a3)) != 0) {
    LOBYTE(v24) = 1;
  }
  return v24;
}

              v19[2](v19, 0LL, 0LL, 0LL);
              goto LABEL_29;
            }
          }

          -[NRLink reportEvent:detailsFormat:](self, "reportEvent:detailsFormat:", 3020LL, @"ClassC %@", v14);
          -[NRLinkWired sendClassCUnlockedNotify](self, "sendClassCUnlockedNotify");

LABEL_22:
          int v39 = 0LL;
          goto LABEL_28;
        }

        if (!-[NRLink hasCompanionDatapath](self, "hasCompanionDatapath"))
        {
          __int128 v28 = 0LL;
          goto LABEL_34;
        }

        -[NRLink reportEvent:detailsFormat:](self, "reportEvent:detailsFormat:", 3024LL, @"ClassC %@", v14);
      }

      else
      {
        uint64_t v33 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v32);
        int v34 = _NRLogIsLevelEnabled(v33, 16LL);

        if (v34)
        {
          uint64_t v36 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v35);
          id v37 = -[NRLink copyDescription](self, "copyDescription");
          int v38 = (void *)objc_claimAutoreleasedReturnValue([v15 localIdentifier]);
          _NRLogWithArgs( v36,  16LL,  "%s%.30s:%-4d %@: Unrecognized identifier %@",  "",  "-[NRLinkWired requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  726LL,  v37,  v38);
        }
      }
    }
}

  uint64_t v23 = sub_1000229A0(v3, 18LL);
  uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v23, "firstObject"));

  if (v24)
  {
    id v25 = sub_1000229A0(v3, 18LL);
    int v26 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v25, "firstObject"));

    if (v26 && [v26 length])
    {
      v134[0] = 0;
      [v26 getBytes:v134 length:1];
      if ((v134[0] & 1) != 0) {
        uint64_t v27 = &__kCFBooleanTrue;
      }
      else {
        uint64_t v27 = &__kCFBooleanFalse;
      }
    }

    else
    {
      uint64_t v27 = 0LL;
    }

    __int128 v28 = [v27 BOOLValue];
    __int128 v30 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 96), v29);
    int v31 = _NRLogIsLevelEnabled(v30, 1LL);

    if (!v28)
    {
      if (v31)
      {
        int v38 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 96), v32);
        _NRLogWithArgs( v38,  1LL,  "%s%.30s:%-4d received dns proxy disable request",  "",  "-[NRDDeviceConductor handleDNSProxyMessage:]",  4951);
      }

      [*(id *)(v1 + 568) cancel];
      int v39 = *(void **)(v1 + 568);
      *(void *)(v1 + 56_Block_object_dispose((const void *)(v1 - 104), 8) = 0LL;

      goto LABEL_68;
    }

    if (v31)
    {
      uint64_t v33 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 96), v32);
      _NRLogWithArgs( v33,  1LL,  "%s%.30s:%-4d received discovery proxy enable request",  "",  "-[NRDDeviceConductor handleDNSProxyMessage:]",  4917);
    }

    if (*(_BYTE *)(v1 + 44))
    {
      int v34 = (NSMutableSet *)*(id *)(v1 + 128);
      if ((-[NSMutableSet ikeClassDEstablished](v34, "ikeClassDEstablished") & 1) == 0)
      {
LABEL_67:

        goto LABEL_68;
      }

      uint64_t v35 = *(unsigned __int8 *)(v1 + 61);

      if (v35)
      {
        uint64_t v36 = *(void *)(v1 + 568);
        if (!v36)
        {
LABEL_49:
          [*(id *)(v1 + 568) cancel];
          int v34 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
          uint64_t v129 = 0u;
          uint64_t v130 = 0u;
          v131 = 0u;
          int v132 = 0u;
          uint64_t v40 = *(id *)(v1 + 112);
          id v41 = [v40 countByEnumeratingWithState:&v129 objects:v134 count:16];
          if (v41)
          {
            uint64_t v42 = v41;
            uint64_t v43 = *(void *)v130;
            do
            {
              for (uint64_t i = 0LL; i != v42; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v130 != v43) {
                  objc_enumerationMutation(v40);
                }
                if (*(_BYTE *)(v1 + 47))
                {
                  uint64_t v45 = *(void **)(*((void *)&v129 + 1) + 8LL * (void)i);
                  if ([v45 ikeClassDEstablished])
                  {
                    if ([v45 hasCompanionDatapath]
                      && [v45 virtualInterface]
                      && [v45 type] == 1)
                    {
                      id v46 = (void *)NEVirtualInterfaceCopyName([v45 virtualInterface]);
                      -[NSMutableSet addObject:](v34, "addObject:", v46);
                    }
                  }
                }
              }

              uint64_t v42 = [v40 countByEnumeratingWithState:&v129 objects:v134 count:16];
            }

            while (v42);
          }

          if (-[NSMutableSet count](v34, "count"))
          {
            id v47 = objc_alloc(&OBJC_CLASS___NRDiscoveryProxyServer);
            int v48 = *(void **)(v1 + 104);
            uint64_t v49 = *(id *)(v1 + 96);
            uint64_t v50 = v48;
            id v51 = v34;
            if (v47)
            {
              v133.receiver = v47;
              v133.super_class = (Class)&OBJC_CLASS___NRDiscoveryProxyServer;
              int v52 = (NRDiscoveryProxyServer *)objc_msgSendSuper2(&v133, "initWithQueue:nrUUID:delegate:", v50, v49, v1);
              id v47 = v52;
              if (v52) {
                objc_storeStrong((id *)&v52->_ifNamesSet, v34);
              }
            }

            objc_storeStrong((id *)(v1 + 568), v47);
            [*(id *)(v1 + 568) start];
          }

          goto LABEL_67;
        }

        id v37 = *(unsigned __int8 *)(v36 + 8);
        if (v37 != 1)
        {
          if (v37 == 2)
          {
            objc_msgSend((id)v1, "didUpdateDNSProxyState:state:");
            goto LABEL_68;
          }

          goto LABEL_49;
        }
      }
    }

    id v12 = 0LL;
    goto LABEL_29;
  }

  if ((v20.st_mode & 0xF000) != 0x8000)
  {
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      _NRLogWithArgs(qword_1001DCA50, 17LL, "Refusing to write to non-regular file %@", v5);
    }

    goto LABEL_28;
  }

  if ([v6 length])
  {
    int v9 = write(a1, [v6 bytes], (size_t)objc_msgSend(v6, "length"));
    if (v9 < 0)
    {
      uint64_t v14 = __error();
      uint64_t v15 = *v14;
      if (strerror_r(*v14, __strerrbuf, 0x80uLL)) {
        __strerrbuf[0] = 0;
      }
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
      {
        if (qword_1001DCA58 != -1) {
          dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
        }
        _NRLogWithArgs(qword_1001DCA50, 17LL, "Failed to write to %@: [%d] %s", v5, v15, __strerrbuf);
      }

      goto LABEL_28;
    }

    uint64_t v10 = v9;
    if ((id)v9 != [v6 length])
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
      {
        id v16 = sub_100100C84();
        _NRLogWithArgs(v16, 17, "Wrote %zd instead of %llu to %d", v10, [v6 length], a1);
      }

      goto LABEL_28;
    }
  }

  if (qword_1001DCA58 != -1) {
    dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCA50, 0LL))
  {
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    id v11 = (id)qword_1001DCA50;
    _NRLogWithArgs( v11,  0,  "%s%.30s:%-4d Wrote %llu bytes to %@",  "",  "NRDSafeWriteDataToFileDescriptor",  199,  [v6 length],  v5);
  }

  id v12 = 1LL;
LABEL_29:

  return v12;
}

    int v48 = v34 != 0;
    goto LABEL_44;
  }

  if (!v16)
  {
    uint64_t v44 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v20);
    uint64_t v45 = _NRLogIsLevelEnabled(v44, 2LL);

    if (v45)
    {
      id v47 = (NRDeviceEndpoint *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v46);
      _NRLogWithArgs( v47,  2LL,  "%s%.30s:%-4d discovered device doesn't have IRK",  "",  "-[NRDiscoveryClient addDiscoveredDeviceIfApplicable:endpoint:serviceName:psk:idsDeviceID:peerIdentity:selfIdentity:]",  1035);
LABEL_75:

      goto LABEL_76;
    }

    goto LABEL_76;
  }

  id v90 = v13;
  uint64_t v93 = v16;
  uint64_t v40 = v16;
  uint64_t v22 = v15;
  id v41 = sub_100112C80(a1, v15, v19);
  uint64_t v42 = v41;
  uint64_t v23 = v14;
  if (*(void *)(a1 + 256) == 4LL) {
    uint64_t v43 = sub_100112D5C(a1, v41);
  }
  else {
    uint64_t v43 = sub_100103FB0(v41, v40);
  }
  uint64_t v49 = v43;

  uint64_t v50 = sub_1001159B8(v18, "nrAT");
  uint64_t v33 = sub_100105828(v49, v50);
  if (v33)
  {
    int v52 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v51);
    uint64_t v53 = _NRLogIsLevelEnabled(v52, 0LL);

    if (v53)
    {
      int v54 = *(id *)(a1 + 24);
      uint64_t v56 = (void *)_NRCopyLogObjectForNRUUID(v54, v55);
      _NRLogWithArgs( v56,  0LL,  "%s%.30s:%-4d discovered a valid peer %@",  "",  "-[NRDiscoveryClient addDiscoveredDeviceIfApplicable:endpoint:serviceName:psk:idsDeviceID:peerIdentity:selfIdentity:]",  1042LL,  v23);
    }

    uint64_t v57 = *(unsigned __int8 *)(a1 + 18);
    int v48 = 1;
    if (*(_BYTE *)(a1 + 18) && v57 != 255)
    {
      uint64_t v58 = v40;
      uint64_t v59 = sub_1001129CC(a1, v57, v22, v95);
      int v60 = v59;
      if (*(void *)(a1 + 256) == 4LL) {
        uint64_t v61 = sub_100112D5C(a1, v59);
      }
      else {
        uint64_t v61 = sub_100103FB0(v59, v58);
      }
      id v62 = v61;

      id v63 = sub_1001159B8(v18, "nrD");
      int v48 = sub_100105828(v62, v63);
      if (v48)
      {
        int v88 = v62;
        uint64_t v65 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v64);
        __int128 v86 = _NRLogIsLevelEnabled(v65, 0LL);

        id v62 = v88;
        if (v86)
        {
          id v67 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v66);
          _NRLogWithArgs( v67,  0LL,  "%s%.30s:%-4d discovered a valid device type",  "",  "-[NRDiscoveryClient addDiscoveredDeviceIfApplicable:endpoint:serviceName:psk:idsDeviceID:peerIdentity:selfIdentity:]",  1060);

          id v62 = v88;
        }
      }
    }
  }

  else
  {
    int v48 = 0;
  }

  uint64_t v13 = v90;
LABEL_44:
  uint64_t v14 = v23;
  uint64_t v15 = v22;
  id v16 = v93;
  if (v48 && v33)
  {
    uint64_t v68 = objc_alloc_init(&OBJC_CLASS___NRDeviceEndpoint);
    uint64_t v69 = v68;
    if (v68)
    {
      objc_storeStrong((id *)&v68->_serviceName, obj);
      v69->_int type = *(_BYTE *)(a1 + 18);
      if (v96)
      {
        objc_storeStrong((id *)&v69->_remoteIDSDeviceID, v91);
        goto LABEL_49;
      }
    }

    else if (v96)
    {
LABEL_49:
      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      uint64_t v70 = (id)qword_1001DC870;
      uint64_t v71 = (NSUUID *)sub_1000AFCFC(v70, 0LL);
      int v72 = v71;
      if (v69)
      {
        int v72 = v71;
        localIDSDeviceID = (NSUUID *)v69->_localIDSDeviceID;
        v69->_localIDSDeviceID = (NSString *)&v72->super.isa;
LABEL_58:

        goto LABEL_59;
      }

      goto LABEL_59;
    }

    uint64_t v74 = -[NSUUID initWithUUIDString:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDString:", v15);
    if (v69) {
      objc_storeStrong((id *)&v69->_peerToken, v74);
    }

    id v75 = objc_alloc(&OBJC_CLASS___NSUUID);
    uint64_t v70 = *(id *)(a1 + 112);
    int v76 = -[NSUUID initWithUUIDString:](v75, "initWithUUIDString:", v70);
    int v72 = v76;
    if (v69)
    {
      int v72 = v76;
      localIDSDeviceID = v69->_localToken;
      v69->_localToken = v72;
      goto LABEL_58;
    }

void sub_100040DD8(_Unwind_Exception *a1)
{
}

void sub_100040DFC(uint64_t a1)
{
}

void sub_100040E04(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v3 = WeakRetained;
  if (WeakRetained)
  {
    if (*((unsigned __int8 *)WeakRetained + 16) != 255)
    {
      if (gNRPacketLoggingEnabled)
      {
        id v37 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v2);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v37, 1LL);

        if (IsLevelEnabled)
        {
          uint64_t v40 = (void *)_NRCopyLogObjectForNRUUID(v3[4], v39);
          id v41 = [v3 copyDescription];
          _NRLogWithArgs( v40,  1LL,  "%s%.30s:%-4d %@: Nexus output available",  "",  "-[NRLinkQuickRelay setupNexus]_block_invoke",  931LL,  v41);
        }
      }

      ++*(void *)((char *)v3 + 455);
      uint64_t v4 = v3;
      uint64_t v5 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([v4 queue]);
      dispatch_assert_queue_V2(v5);

      if (*((unsigned __int8 *)v3 + 16) == 255)
      {
        int v31 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v4 + 4), v6);
        int v32 = _NRLogIsLevelEnabled(v31, 16LL);

        if (v32)
        {
          int v34 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v4 + 4), v33);
          id v35 = [v4 copyDescription];
          _NRLogWithArgs(v34, 16LL, "%s%.30s:%-4d %@: link is cancelled", "", "NRLinkLoopQRToInterface", 1965LL, v35);
        }
      }

      else if ([*(id *)(v4 + 343) count])
      {
        uint64_t v7 = os_channel_ring_id(*(void *)(v4 + 295), 0LL);
        uint64_t v8 = os_channel_tx_ring(*(void *)(v4 + 295), v7);
        __int128 v60 = 0u;
        __int128 v61 = 0u;
        __int128 v62 = 0u;
        __int128 v63 = 0u;
        id v9 = *(id *)(v4 + 343);
        id v57 = [v9 countByEnumeratingWithState:&v60 objects:v67 count:16];
        int v10 = 0;
        uint64_t v11 = 0LL;
        uint64_t i = 0LL;
        if (v57)
        {
          id v55 = v9;
          uint64_t v56 = *(void *)v61;
          while (2)
          {
            uint64_t v13 = 0LL;
            int v14 = v10;
            v10 += (int)v57;
            do
            {
              if (*(void *)v61 != v56) {
                objc_enumerationMutation(v9);
              }
              uint64_t v58 = v13;
              uint64_t v15 = *(void **)(*((void *)&v60 + 1) + 8 * v13);
              id v16 = [v15 length];
              uint64_t v17 = (char *)[v15 bytes];
              uint64_t next_slot = os_channel_get_next_slot(v8, i, v64);
              if (!next_slot)
              {
                int v10 = v14;
                goto LABEL_35;
              }

              int v59 = v14;
              int v19 = (int)v16;
              if ((int)v16 >= 1)
              {
                id v54 = v16;
                for (uint64_t i = next_slot; ; uint64_t i = v23)
                {
                  if (v19 >= v65) {
                    unsigned int v20 = v65;
                  }
                  else {
                    unsigned int v20 = v19;
                  }
                  unsigned __int16 v65 = v20;
                  memcpy(__dst, v17, (unsigned __int16)v20);
                  os_channel_set_slot_properties(v8, i, v64);
                  v19 -= v20;
                  if (v19 < 1)
                  {
                    uint64_t v11 = v20 + v11;
                    id v16 = v54;
                    id v9 = v55;
                    goto LABEL_24;
                  }

                  uint64_t v21 = os_channel_get_next_slot(v8, i, v64);
                  if (!v21) {
                    break;
                  }
                  uint64_t v23 = v21;
                  if (gNRPacketLoggingEnabled)
                  {
                    uint64_t v24 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v4 + 4), v22);
                    int v52 = _NRLogIsLevelEnabled(v24, 1LL);

                    if (v52)
                    {
                      int v26 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v4 + 4), v25);
                      id v53 = [v4 copyDescription];
                      _NRLogWithArgs( v26,  1LL,  "%s%.30s:%-4d %@: Writing partial packet",  "",  "NRLinkLoopQRToInterface",  2005LL,  v53);
                    }
                  }

                  v17 += v20;
                  uint64_t v11 = v20 + v11;
                }

                if (gNRPacketLoggingEnabled)
                {
                  id v47 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v4 + 4), v22);
                  int v48 = _NRLogIsLevelEnabled(v47, 1LL);

                  if (v48)
                  {
                    uint64_t v50 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v4 + 4), v49);
                    id v51 = [v4 copyDescription];
                    _NRLogWithArgs( v50,  1LL,  "%s%.30s:%-4d %@: No slot midway",  "",  "NRLinkLoopQRToInterface",  2002LL,  v51);
                  }
                }

                int v10 = v59;
                id v9 = v55;
                goto LABEL_35;
              }

LABEL_35:
        if (gNRPacketLoggingEnabled)
        {
          uint64_t v42 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v4 + 4), v36);
          int v43 = _NRLogIsLevelEnabled(v42, 1LL);

          if (v43)
          {
            uint64_t v45 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v4 + 4), v44);
            id v46 = [v4 copyDescription];
            _NRLogWithArgs( v45,  1LL,  "%s%.30s:%-4d %@: Read from QR: %d bytes",  "",  "NRLinkLoopQRToInterface",  2020LL,  v46,  v11);
          }
        }

        if (i)
        {
          os_channel_advance_slot(v8, i);
          os_channel_sync(*(void *)(v4 + 295), 0LL);
          if (v10 >= 1)
          {
            do
            {
              [*(id *)(v4 + 343) removeFirstObject];
              --v10;
            }

            while (v10);
          }
        }
      }

      else
      {
        dispatch_suspend(*(dispatch_object_t *)(v4 + 327));
        v4[210] = 1;
      }

      goto LABEL_39;
    }

    uint64_t v27 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v2);
    int v28 = _NRLogIsLevelEnabled(v27, 16LL);

    if (v28)
    {
      uint64_t v4 = (char *)_NRCopyLogObjectForNRUUID(v3[4], v29);
      id v30 = [v3 copyDescription];
      _NRLogWithArgs( v4,  16LL,  "%s%.30s:%-4d %@: Nexus output available but cancelled",  "",  "-[NRLinkQuickRelay setupNexus]_block_invoke",  928LL,  v30);

LABEL_39:
    }
  }
}

LABEL_37:
        uint64_t v11 = v37;
        int v10 = v38;
      }

      else
      {
        uint64_t v21 = 0LL;
      }

      nw_connection_set_queue(v10, *(dispatch_queue_t *)(v7 + 16));
      v44[0] = _NSConcreteStackBlock;
      v44[1] = 3221225472LL;
      v44[2] = sub_10005CB3C;
      v44[3] = &unk_1001AE8A8;
      int v28 = v12;
      uint64_t v45 = v28;
      id v46 = v21;
      id v47 = v7;
      int v48 = v13;
      uint64_t v49 = v11;
      uint64_t v29 = v13;
      id v30 = v10;
      uint64_t v50 = v30;
      int v31 = v21;
      nw_connection_set_event_handler(v30, v44);
      uint64_t v42 = v28;
      int v32 = v30;
      uint64_t v13 = v29;
      uint64_t v33 = v32;
      int v43 = v32;
      nw_connection_set_read_close_handler();
      nw_connection_start(v33);
    }
  }
}

  -[NSMutableArray addObject:](v3, "addObject:", @"RdGood");
  if ((a1 & 0x200000) == 0)
  {
LABEL_10:
    if ((a1 & 0x400000) == 0) {
      goto LABEL_11;
    }
    goto LABEL_37;
  }

      if (!gNRPacketLoggingEnabled) {
        goto LABEL_36;
      }
      goto LABEL_59;
    }

    unsigned int v20 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v8);
    uint64_t v21 = _NRLogIsLevelEnabled(v20, 17LL);

    if (!v21)
    {
      int v10 = 0LL;
      goto LABEL_35;
    }

    int v18 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v17);
    int v19 = [(id)a1 copyDescription];
    _NRLogWithArgs(v18, 17LL, "%@: Tried to write but _linkChannel is NULL", v19);
  }

  else
  {
    uint64_t v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v8);
    id v16 = _NRLogIsLevelEnabled(v15, 17LL);

    if (!v16) {
      goto LABEL_22;
    }
    int v18 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v17);
    int v19 = [(id)a1 copyDescription];
    _NRLogWithArgs(v18, 17LL, "%@: Tried to write but _linkOutputRing is NULL", v19);
  }

LABEL_22:
  int v10 = 0LL;
  if (gNRPacketLoggingEnabled) {
    goto LABEL_59;
  }
LABEL_36:
  if ((v10 & 0x8000000000000000LL) != 0)
  {
    [(id)a1 cancelWithReason:@"Write error"];
  }

  else
  {
    if (gNRPacketLoggingEnabled)
    {
      uint64_t v29 = objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
      id v30 = *(void **)(a1 + 1687);
      *(void *)(a1 + 1687) = v29;
    }

    *(void *)(a1 + 1383) += v10;
    if ((id)v10 == v6)
    {
      int v26 = *(void **)(a1 + 1327);
      *(void *)(a1 + 1327) = 0LL;

      sub_100096308(a1, a2 + 1);
    }

    else
    {
      if (v10) {
        objc_msgSend(*(id *)(a1 + 1327), "replaceBytesInRange:withBytes:length:", 0, v10, 0, 0);
      }
      if (*(_BYTE *)(a1 + 222) && *(void *)(a1 + 991))
      {
        *(_BYTE *)(a1 + 222) = 0;
        ++*(void *)(a1 + 1007);
        if (gNRPacketLoggingEnabled)
        {
          uint64_t v39 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v17);
          uint64_t v40 = _NRLogIsLevelEnabled(v39, 1LL);

          if (v40)
          {
            uint64_t v42 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v41);
            int v43 = [(id)a1 copyDescription];
            _NRLogWithArgs( v42,  1LL,  "%s%.30s:%-4d %@: source-resume: LinkOutput",  "",  "NRLinkResumeLinkOutputSource",  823LL,  v43);
          }
        }

        dispatch_resume(*(dispatch_object_t *)(a1 + 991));
      }

      uint64_t v27 = a2 + 1;
      if (!*(_BYTE *)(a1 + 212) && *(void *)(a1 + 391))
      {
        *(_BYTE *)(a1 + 212) = 1;
        ++*(void *)(a1 + 415);
        if (gNRPacketLoggingEnabled)
        {
          uint64_t v44 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v17);
          uint64_t v45 = _NRLogIsLevelEnabled(v44, 1LL);

          if (v45)
          {
            id v47 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v46);
            int v48 = [(id)a1 copyDescription];
            _NRLogWithArgs( v47,  1LL,  "%s%.30s:%-4d %@: source-suspend: NexusInput",  "",  "NRLinkSuspendNexusInputSource",  832LL,  v48);
          }
        }

        dispatch_suspend(*(dispatch_object_t *)(a1 + 391));
      }

      int v28 = *(void **)(a1 + 1351);
      if (v28) {
        [v28 setReceiveWindowPacketCount:0];
      }
      sub_1000989D8(a1, v27);
    }
  }
}

      id v41 = v43;
LABEL_36:
    }
  }
}

    int IsLevelEnabled = 0LL;
    goto LABEL_36;
  }

  LOBYTE(v22) = *v6;
  if ((_BYTE)v22)
  {
    BYTE1(v22) = v6[1];
    if (BYTE1(v22))
    {
      BYTE2(v22) = v6[2];
      if (BYTE2(v22))
      {
        BYTE3(v22) = v6[3];
        if (BYTE3(v22))
        {
          BYTE4(v22) = v6[4];
          if (BYTE4(v22))
          {
            BYTE5(v22) = v6[5];
            if (BYTE5(v22))
            {
              BYTE6(v22) = v6[6];
              if (BYTE6(v22))
              {
                BYTE7(v22) = v6[7];
                if (BYTE7(v22))
                {
                  BYTE8(v22) = v6[8];
                  if (BYTE8(v22))
                  {
                    BYTE9(v22) = v6[9];
                    if (BYTE9(v22))
                    {
                      BYTE10(v22) = v6[10];
                      if (BYTE10(v22))
                      {
                        BYTE11(v22) = v6[11];
                        if (BYTE11(v22))
                        {
                          BYTE12(v22) = v6[12];
                          if (BYTE12(v22))
                          {
                            BYTE13(v22) = v6[13];
                            if (BYTE13(v22))
                            {
                              BYTE14(v22) = v6[14];
                              if (BYTE14(v22)) {
                                HIBYTE(v22) = 0;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  DWORD2(v23) = a2;
  uint64_t v7 = ioctl(v5, 0xC02069BCuLL, &v22);
  int IsLevelEnabled = v7 >= 0;
  if (v7 < 0)
  {
    id v9 = *__error();
    if (strerror_r(v9, __strerrbuf, 0x80uLL)) {
      __strerrbuf[0] = 0;
    }
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      _NRLogWithArgs(qword_1001DCA50, 17LL, "ioctl SIOCSIFSUBFAMILY failed: [%d] %s", v9, __strerrbuf);
    }
  }

  close(v5);
LABEL_36:

  return IsLevelEnabled;
}

    int IsLevelEnabled = 0LL;
    goto LABEL_36;
  }

  LOBYTE(v20) = *v4;
  if ((_BYTE)v20)
  {
    BYTE1(v20) = v4[1];
    if (BYTE1(v20))
    {
      BYTE2(v20) = v4[2];
      if (BYTE2(v20))
      {
        BYTE3(v20) = v4[3];
        if (BYTE3(v20))
        {
          BYTE4(v20) = v4[4];
          if (BYTE4(v20))
          {
            BYTE5(v20) = v4[5];
            if (BYTE5(v20))
            {
              BYTE6(v20) = v4[6];
              if (BYTE6(v20))
              {
                BYTE7(v20) = v4[7];
                if (BYTE7(v20))
                {
                  BYTE8(v20) = v4[8];
                  if (BYTE8(v20))
                  {
                    BYTE9(v20) = v4[9];
                    if (BYTE9(v20))
                    {
                      BYTE10(v20) = v4[10];
                      if (BYTE10(v20))
                      {
                        BYTE11(v20) = v4[11];
                        if (BYTE11(v20))
                        {
                          BYTE12(v20) = v4[12];
                          if (BYTE12(v20))
                          {
                            BYTE13(v20) = v4[13];
                            if (BYTE13(v20))
                            {
                              BYTE14(v20) = v4[14];
                              if (BYTE14(v20)) {
                                HIBYTE(v20) = 0;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  LODWORD(v21) = 1;
  uint64_t v5 = ioctl(v3, 0xC02069D0uLL, &v20);
  int IsLevelEnabled = v5 >= 0;
  if (v5 < 0)
  {
    uint64_t v7 = *__error();
    if (strerror_r(v7, __strerrbuf, 0x80uLL)) {
      __strerrbuf[0] = 0;
    }
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      _NRLogWithArgs(qword_1001DCA50, 17LL, "ioctl SIOCSIFNOACKPRIO failed: [%d] %s", v7, __strerrbuf);
    }
  }

  close(v3);
LABEL_36:

  return IsLevelEnabled;
}

void sub_10004140C(uint64_t a1)
{
}

uint64_t sub_100041414(uint64_t a1)
{
  return os_channel_destroy(*(void *)(a1 + 32));
}

NSString *sub_10004141C(unint64_t a1)
{
  if (a1 >= 6) {
    return -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown[%lld]",  a1);
  }
  else {
    return (NSString *)*(&off_1001AE718 + a1);
  }
}

NSMutableArray *sub_100041474(void *a1, void *a2)
{
  id v3 = a1;
  uint64_t v5 = v3;
  if (*((unsigned __int8 *)v3 + 16) == 255)
  {
    int v32 = (void *)_NRCopyLogObjectForNRUUID(v3[4], v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v32, 16LL);

    if (IsLevelEnabled)
    {
      id v35 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v34);
      id v36 = [v5 copyDescription];
      _NRLogWithArgs(v35, 16LL, "%s%.30s:%-4d %@: link is cancelled", "", "NRLinkLoopInterfaceToQRInner", 1799LL, v36);
LABEL_33:
    }

void sub_100041A54(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v6 = WeakRetained;
  if (WeakRetained)
  {
    if (v3)
    {
      uint64_t v7 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v5);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 16LL);

      if (IsLevelEnabled)
      {
        int v10 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v9);
        id v11 = [v6 copyDescription];
        _NRLogWithArgs( v10,  16,  "%s%.30s:%-4d %@: Failed to write datagram array of length %llu",  "",  "NRLinkLoopInterfaceToQR_block_invoke",  1934,  v11,  [*(id *)(a1 + 32) count]);
      }

      *(void *)((char *)v6 + 399) += *(void *)(a1 + 48);
      uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue([v6 connection]);
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v6 connection]);
      id v14 = [v13 connectionState];
      if ((unint64_t)v14 >= 6) {
        uint64_t v15 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown[%lld]",  v14);
      }
      else {
        uint64_t v15 = (NSString *)*(&off_1001AE718 + (void)v14);
      }
      [v6 reportEvent:10022, @"connection %@ state %@ error %@", v12, v15, v3 detailsFormat];
    }

    else
    {
      *(void *)((char *)WeakRetained + 391) += *(void *)(a1 + 48);
    }

    uint64_t v16 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([v6 queue]);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100041CD8;
    block[3] = &unk_1001B0A88;
    uint64_t v17 = v6;
    id v25 = v17;
    dispatch_async(v16, block);

    if (gNRPacketLoggingEnabled)
    {
      int v19 = (void *)_NRCopyLogObjectForNRUUID(v17[4], v18);
      int v20 = _NRLogIsLevelEnabled(v19, 1LL);

      if (v20)
      {
        uint64_t v22 = (void *)_NRCopyLogObjectForNRUUID(v17[4], v21);
        id v23 = [v17 copyDescription];
        _NRLogWithArgs( v22,  1,  "%s%.30s:%-4d %@: Wrote to QR: %llu bytes, %llu datagrams",  "",  "NRLinkLoopInterfaceToQR_block_invoke",  1954,  v23,  *(void *)(a1 + 48),  [*(id *)(a1 + 32) count]);
      }
    }
  }
}

void sub_100041CD8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(_BYTE *)(v1 + 209))
  {
    *(_BYTE *)(v1 + 209) = 0;
    dispatch_resume(*(dispatch_object_t *)(*(void *)(a1 + 32) + 319LL));
  }

void sub_100041D08(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v8 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v9 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([WeakRetained queue]);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100041DE0;
    block[3] = &unk_1001B0748;
    id v11 = v6;
    id v12 = v8;
    id v13 = v5;
    dispatch_async(v9, block);
  }
}

void sub_100041DE0(uint64_t a1)
{
  id v3 = *(void **)(a1 + 32);
  if (!v3)
  {
    __int128 v167 = 0u;
    __int128 v168 = 0u;
    __int128 v165 = 0u;
    __int128 v166 = 0u;
    id v158 = *(id *)(a1 + 48);
    id v159 = [v158 countByEnumeratingWithState:&v165 objects:v170 count:16];
    if (!v159) {
      goto LABEL_88;
    }
    uint64_t v12 = 0LL;
    uint64_t v13 = *(void *)v166;
    uint64_t v157 = *(void *)v166;
    while (1)
    {
      if (v13 != v157) {
        objc_enumerationMutation(v158);
      }
      uint64_t v160 = v12;
      id v14 = *(void **)(*((void *)&v165 + 1) + 8 * v12);
      if ((unint64_t)[v14 length] <= 2)
      {
        uint64_t v16 = v14;
        uint64_t v17 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 40) + 32LL), v15);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v17, 17LL);

        if (!IsLevelEnabled) {
          goto LABEL_86;
        }
        int v20 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 40) + 32LL), v19);
        id v21 = [*(id *)(a1 + 40) copyDescription];
        _NRLogWithArgs(v20, 17, "%@: Invalid packet length received: %llu", v21, [v16 length]);
        goto LABEL_15;
      }

      id v22 = [v14 length];
      id v154 = v14;
      id v155 = v22;
      int v156 = (unsigned __int8 *)[v14 bytes];
      *(void *)(*(void *)(a1 + 40) + 407LL) += v22;
      if (!(_DWORD)v22) {
        goto LABEL_86;
      }
      uint64_t v24 = v156;
      id v25 = &v156[v22];
      v162 = v25;
      while (1)
      {
        if (v24 + 3 > v25)
        {
          id v79 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 40) + 32LL), v23);
          int v80 = _NRLogIsLevelEnabled(v79, 17LL);

          if (!v80) {
            goto LABEL_86;
          }
          int v20 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 40) + 32LL), v81);
          id v21 = [*(id *)(a1 + 40) copyDescription];
          _NRLogWithArgs( v20,  17LL,  "%@: Received incomplete/malformed datagram: [%p + %zu > %p + %u]",  v21,  v24,  3LL,  v156,  v155);
LABEL_15:

          goto LABEL_16;
        }

        id v163 = v24;
        uint64_t v164 = 0LL;
        uint64_t v26 = *v24;
        unsigned int v27 = *(unsigned __int16 *)(v24 + 1);
        uint64_t v28 = __rev16(v27);
        uint64_t v29 = (v28 + 5);
        uint64_t v164 = v29;
        if (&v24[v29] > v25)
        {
          uint64_t v82 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 40) + 32LL), v23);
          int v83 = _NRLogIsLevelEnabled(v82, 17LL);

          if (v83)
          {
            int v20 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 40) + 32LL), v84);
            unint64_t v1 = (unint64_t)[*(id *)(a1 + 40) copyDescription];
            _NRLogWithArgs( v20,  17LL,  "%@: Received incomplete/malformed datagram: [%p + %lu + %u + %lu > %p + %u]",  v1,  v24,  3LL,  v28,  2LL,  v156,  v155);
            goto LABEL_85;
          }

          goto LABEL_86;
        }

        if ((char)v26 >= 100)
        {
          unint64_t v1 = (v28 + 3);
          unsigned int v30 = v164 - v1;
          if (v30 >= 2) {
            uint64_t v31 = 2LL;
          }
          else {
            uint64_t v31 = v30;
          }
          __memcpy_chk(v169, &v163[v1], v31, 2LL);
          if (v30 <= 1) {
            goto LABEL_120;
          }
          goto LABEL_40;
        }

        unsigned int v32 = v164;
        else {
          uint64_t v33 = v164;
        }
        if (!(_DWORD)v33)
        {
          if (qword_1001DC758 != -1) {
            dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
          }
          __int128 v107 = "nrChecksumUpdate";
          if (_NRLogIsLevelEnabled(qword_1001DC750, 16LL))
          {
            if (qword_1001DC758 != -1) {
              dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
            }
            _NRLogWithArgs( qword_1001DC750,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: dataLen > 0",  "",  "nrChecksumUpdate",  69);
          }

          uint64_t v108 = _os_log_pack_size(12LL);
          size_t v51 = (size_t)&v153 - ((__chkstk_darwin(v108) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v109 = *__error();
          uint64_t v110 = _os_log_pack_fill(v51, v108, v109, &_mh_execute_header, "%{public}s Assertion Failed: dataLen > 0");
LABEL_110:
          *(_DWORD *)uint64_t v110 = 136446210;
          *(void *)(v110 + 4) = v107;
          goto LABEL_114;
        }

        uint64_t v161 = (unsigned __int8 *)(v28 + 3);
        __int16 v34 = os_inet_checksum(v163, v33, 0LL);
        unint64_t v1 = v28 + 3;
        if ((int)v28 + 3 > v32)
        {
          id v111 = sub_10003B584();
          int v112 = _NRLogIsLevelEnabled(v111, 16LL);

          __int128 v107 = "nrChecksumIOVecInner";
          if (v112)
          {
            id v113 = sub_10003B584();
            _NRLogWithArgs( v113,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: computedBytes == writtenLength",  "",  "nrChecksumIOVecInner",  164);
          }

          uint64_t v114 = _os_log_pack_size(12LL);
          size_t v51 = (size_t)&v153 - ((__chkstk_darwin(v114) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v115 = *__error();
          uint64_t v110 = _os_log_pack_fill( v51,  v114,  v115,  &_mh_execute_header,  "%{public}s Assertion Failed: computedBytes == writtenLength");
          goto LABEL_110;
        }

        unsigned int v35 = v164;
        if (v164 < v29)
        {
          BOOL v139 = v33 >= v164;
          id v140 = sub_10003B584();
          int v141 = _NRLogIsLevelEnabled(v140, 16LL);

          if (v35 < (int)v28 + 4)
          {
            if (v141)
            {
              id v149 = sub_10003B584();
              v150 = (void *)createIOVecString(&v163, 1LL);
              _NRLogWithArgs( v149,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: iovecs[iovecIndex].len >= bytesToCheckThisIOVec + 1; %@, iovecI"
                "ndex=%u bytesToCheckThisIOVec=%u",
                "",
                "nrChecksumIOVecInner",
                189LL,
                v150,
                v139,
                v161);
            }

            uint64_t v151 = _os_log_pack_size(34LL);
            id v127 = (char *)&v153 - ((__chkstk_darwin(v151) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v152 = *__error();
            uint64_t v146 = _os_log_pack_fill( v127,  v151,  v152,  &_mh_execute_header,  "%{public}s Assertion Failed: iovecs[iovecIndex].len >= bytesToCheckThisIOVec + 1; %@, iovecIndex=%u"
                     " bytesToCheckThisIOVec=%u");
          }

          else
          {
            if (v141)
            {
              id v142 = sub_10003B584();
              v143 = (void *)createIOVecString(&v163, 1LL);
              _NRLogWithArgs( v142,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: iovecIndex + 1 < numIOVecs; %@, iovecIndex=%u bytesToCheckThisIOVec=%u",
                "",
                "nrChecksumIOVecInner",
                191LL,
                v143,
                v139,
                v161);
            }

            uint64_t v144 = _os_log_pack_size(34LL);
            id v127 = (char *)&v153 - ((__chkstk_darwin(v144) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v145 = *__error();
            uint64_t v146 = _os_log_pack_fill( v127,  v144,  v145,  &_mh_execute_header,  "%{public}s Assertion Failed: iovecIndex + 1 < numIOVecs; %@, iovecIndex=%u bytesToCheckThisIOVec=%u");
          }

          uint64_t v147 = v146;
          uint64_t v148 = createIOVecString(&v163, 1LL);
          sub_100043200(v147, (uint64_t)"nrChecksumIOVecInner", v148, v139, (int)v161);
          goto LABEL_118;
        }

        __int16 v36 = ~v34;
        if (v161[(void)v163] != ~(_BYTE)v34
          || v161[(void)v163 + 1] != (unsigned __int16)(v36 & 0xFF00) >> 8)
        {
          break;
        }

LABEL_40:
        switch((int)v26)
        {
          case 'd':
            id v37 = &OBJC_IVAR___NRLinkQuickRelay__recvKnownIPv6Hdr_ESP;
            break;
          case 'e':
            id v37 = &OBJC_IVAR___NRLinkQuickRelay__recvKnownIPv6Hdr_ESP_ECT0;
            break;
          case 'f':
            id v37 = &OBJC_IVAR___NRLinkQuickRelay__recvKnownIPv6Hdr_TCP;
            break;
          case 'g':
            id v37 = &OBJC_IVAR___NRLinkQuickRelay__recvKnownIPv6Hdr_TCP_ECT0;
            break;
          case 'h':
            id v37 = &OBJC_IVAR___NRLinkQuickRelay__recvKnownIPv6Hdr_ESP_ClassC;
            break;
          case 'i':
            id v37 = &OBJC_IVAR___NRLinkQuickRelay__recvKnownIPv6Hdr_ESP_ClassC_ECT0;
            break;
          default:
            id v37 = &OBJC_IVAR___NRLinkQuickRelay__recvUncompressedIP;
            switch((int)v26)
            {
              case 1:
                int v38 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 40) + 32LL), v23);
                int v39 = _NRLogIsLevelEnabled(v38, 1LL);

                if (v39)
                {
                  uint64_t v40 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 40) + 32LL), v23);
                  id v41 = [*(id *)(a1 + 40) copyDescription];
                  _NRLogWithArgs( v40,  1LL,  "%s%.30s:%-4d %@: Handling PadN %u",  "",  "-[NRLinkQuickRelay readDatagramFromSession]_block_invoke_2",  1705LL,  v41,  v28);
                }

                goto LABEL_21;
              case 2:
                goto LABEL_53;
              case 3:
                id v37 = &OBJC_IVAR___NRLinkQuickRelay__recvEncapsulated6LoWPAN;
                goto LABEL_53;
              case 4:
                int v42 = objc_alloc(&OBJC_CLASS___NSData);
                uint64_t v43 = -[NSData initWithBytes:length:](v42, "initWithBytes:length:", v163 + 3, v28);
                unint64_t v1 = *(void *)(a1 + 40);
                uint64_t v44 = *(void *)(v1 + 471);
                IKEv2Packetid String = (void *)createIKEv2PacketString(v43);
                uint64_t v161 = -[NSData length](v43, "length");
                id v46 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) connection]);
                id v47 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) connection]);
                id v48 = [v47 connectionState];
                if ((unint64_t)v48 >= 6) {
                  id v49 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown[%lld]",  v48);
                }
                else {
                  id v49 = (NSString *)*(&off_1001AE718 + (void)v48);
                }
                [(id)v1 reportEvent:3007, @"Receiving IKEv2 packet #%llu %@ len %llu connection %@ state %@", v44, IKEv2PacketString, v161, v46, v49 detailsFormat];

                ++*(void *)(*(void *)(a1 + 40) + 471LL);
                uint64_t v62 = *(void *)(a1 + 40);
                unsigned __int16 v63 = *(void **)(v62 + 287);
                if (v63)
                {
                  [v63 receivePacketData:v43];
                }

                else
                {
                  uint64_t v64 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v62 + 32), v61);
                  int v65 = _NRLogIsLevelEnabled(v64, 16LL);

                  if (v65)
                  {
                    id v67 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 40) + 32LL), v66);
                    id v68 = [*(id *)(a1 + 40) copyDescription];
                    _NRLogWithArgs( v67,  16LL,  "%s%.30s:%-4d %@: not ready to handle IKE yet",  "",  "-[NRLinkQuickRelay readDatagramFromSession]_block_invoke_2",  1774LL,  v68);
                  }

                  [*(id *)(*(void *)(a1 + 40) + 623) addObject:v43];
                }

                goto LABEL_21;
              default:
                goto LABEL_21;
            }
        }

      int v42 = *((unsigned __int8 *)a3 + OBJC_IVAR___PBDataReader__error);
      if (*((_BYTE *)a3 + OBJC_IVAR___PBDataReader__error)) {
        id v14 = 0LL;
      }
LABEL_42:
      if (v42) {
        uint64_t v43 = 1;
      }
      else {
        uint64_t v43 = (v14 & 7) == 4;
      }
      if (v43) {
        return *((_BYTE *)a3 + OBJC_IVAR___PBDataReader__error) == 0;
      }
      switch((v14 >> 3))
      {
        case 1u:
          id String = PBReaderReadString(a3);
          int v9 = objc_claimAutoreleasedReturnValue(String);
          uint64_t v10 = 32LL;
          goto LABEL_4;
        case 2u:
          Data = PBReaderReadData(a3);
          int v9 = objc_claimAutoreleasedReturnValue(Data);
          uint64_t v10 = 16LL;
          goto LABEL_4;
        case 3u:
          uint64_t v8 = PBReaderReadData(a3);
          int v9 = objc_claimAutoreleasedReturnValue(v8);
          uint64_t v10 = 8LL;
          goto LABEL_4;
        case 4u:
          id v46 = PBReaderReadData(a3);
          int v9 = objc_claimAutoreleasedReturnValue(v46);
          uint64_t v10 = 24LL;
LABEL_4:
          id v11 = *(void **)&self->PBCodable_opaque[v10];
          *(void *)&self->PBCodable_opaque[v10] = v9;

          goto LABEL_5;
        default:
          if ((PBReaderSkipValueWithTag(a3) & 1) == 0) {
            return 0;
          }
LABEL_5:
          id v4 = OBJC_IVAR___PBDataReader__pos;
          id v5 = *(void *)((char *)a3 + OBJC_IVAR___PBDataReader__pos);
          unsigned int v6 = *(void *)((char *)a3 + OBJC_IVAR___PBDataReader__length);
          if (v5 >= v6) {
            return *((_BYTE *)a3 + OBJC_IVAR___PBDataReader__error) == 0;
          }
          break;
      }
    }

    id v14 = 0LL;
LABEL_39:
    void *v12 = 1;
    goto LABEL_40;
  }

  return *((_BYTE *)a3 + OBJC_IVAR___PBDataReader__error) == 0;
}

          goto LABEL_41;
        }

        uint64_t v19 = sub_100100C84();
        int v20 = _NRLogIsLevelEnabled(v19, 17LL);

        if (!v20) {
          goto LABEL_40;
        }
        uint64_t v18 = sub_100100C84();
        _NRLogWithArgs(v18, 17LL, "%s called with null filePath");
      }

      uint64_t v16 = -2005LL;
      goto LABEL_41;
    }

    uint64_t v17 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v6);
    if (v17)
    {
      uint64_t v8 = v17;
      p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
      if (qword_1001DC778 == -1)
      {
LABEL_22:
        if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
        {
          if (p_class_meths[239] != (__objc2_meth_list *)-1LL) {
            dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
          }
          int v20 = (id)qword_1001DC770;
          if (v4)
          {
            id v21 = (void *)v4[4];
            if (!v21)
            {
              id v22 = (_xpc_connection_s *)objc_getProperty(v4, v19, 8LL, 1);
              uint64_t v23 = xpc_connection_get_pid(v22);
              uint64_t v24 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v23);
              bzero(v40, 0x400uLL);
              if ((int)v23 >= 1 && proc_pidpath(v23, v40, 0x400u) >= 1 && v40[0])
              {
                id v25 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v40,  v23);

                uint64_t v24 = v25;
              }

              uint64_t v26 = (void *)v4[4];
              v4[4] = v24;

              id v21 = (void *)v4[4];
            }

            unsigned int v27 = v21;
          }

          else
          {
            unsigned int v27 = 0LL;
          }

          _NRLogWithArgs( v20,  0LL,  "%s%.30s:%-4d Received SupportsRestrictedPorts %@ from %@",  "",  "handleSupportsRestrictedPorts",  1332LL,  v8,  v27);
        }

        if (v4) {
          uint64_t v28 = objc_getProperty(v4, v18, 24LL, 1);
        }
        else {
          uint64_t v28 = 0LL;
        }
        xpc_dictionary_set_BOOL(v28, nrXPCKeySupportsRestrictedPorts, 1);
        uint64_t v16 = 0LL;
        goto LABEL_37;
      }
    }

    else
    {
      uint64_t v33 = sub_10004579C();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v33, 16LL);

      if (IsLevelEnabled)
      {
        unsigned int v35 = sub_10004579C();
        _NRLogWithArgs( v35,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "handleSupportsRestrictedPorts",  1331);
      }

      id v4 = (void *)_os_log_pack_size(12LL);
      uint64_t v8 = &v40[-((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
      __int16 v36 = __error();
      id v37 = _os_log_pack_fill( v8,  v4,  *v36,  &_mh_execute_header,  "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
      *(_DWORD *)id v37 = 136446210;
      *(void *)(v37 + 4) = "handleSupportsRestrictedPorts";
      int v38 = sub_10004579C();
      _NRLogAbortWithPack(v38, v8);
    }

    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    goto LABEL_22;
  }

  uint64_t v29 = sub_10004579C();
  unsigned int v30 = _NRLogIsLevelEnabled(v29, 17LL);

  if (!v30) {
    goto LABEL_40;
  }
  uint64_t v8 = sub_10004579C();
  uint64_t v15 = sub_10004580C(v4, v31);
  _NRLogWithArgs(v8, 17LL, "Missing NRUUID from %@", v15);
LABEL_19:

  uint64_t v16 = -2005LL;
LABEL_37:

LABEL_41:
  return v16;
}

    uint64_t v17 = 0LL;
    goto LABEL_41;
  }

  uint64_t v19 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string_ptr);
  if (v19)
  {
    unsigned int v6 = v19;
    [*(id *)(a1 + 40) addObject:v19];
    uint64_t v17 = 1LL;
    goto LABEL_23;
  }

  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    uint64_t v31 = (id)qword_1001DC770;
    unsigned int v32 = *(id *)(a1 + 32);
    if (v32) {
      unsigned int v32 = objc_getProperty(v32, v30, 16LL, 1);
    }
    __int16 v34 = v32;
    unsigned int v35 = *(void **)(a1 + 32);
    if (v35)
    {
      __int16 v36 = (void *)v35[4];
      if (!v36)
      {
        id v37 = (_xpc_connection_s *)objc_getProperty(v35, v33, 8LL, 1);
        int v38 = xpc_connection_get_pid(v37);
        int v39 = sub_10010393C(v38, 1);
        uint64_t v40 = (void *)v35[4];
        void v35[4] = v39;

        __int16 v36 = (void *)v35[4];
      }

      unsigned int v35 = v36;
    }

    _NRLogWithArgs( v31,  16LL,  "%s%.30s:%-4d Bad string found in policy traffic class message %@ from %@",  "",  "handleDevicePreferences_block_invoke",  1093LL,  v34,  v35);
  }

  unsigned int v6 = 0LL;
LABEL_19:
  uint64_t v17 = 0LL;
LABEL_23:

LABEL_41:
  return v17;
}

  -[NSMutableArray addObject:](v8, "addObject:", @"RadioConditionPoor");
  if ((reason & 0x80000) == 0)
  {
LABEL_15:
    if ((reason & 0x100000) == 0) {
      goto LABEL_16;
    }
    goto LABEL_42;
  }

  -[NSMutableArray addObject:](v3, "addObject:", @"NotPlgd");
  if ((a1 & 0x4000000) == 0)
  {
LABEL_15:
    if ((a1 & 0x8000000) == 0) {
      goto LABEL_16;
    }
    goto LABEL_42;
  }

              if ((_WORD)v26)
              {
                *(void *)(v5 + 1935) |= 0x40uLL;
                if (!v28) {
                  goto LABEL_167;
                }
                unsigned int v27 = v29;
              }

              else
              {
                id v37 = os_channel_get_next_slot(*(void *)(v5 + 1135), v340, v349);
                if (!v37)
                {
                  LODWORD(v26) = 0;
LABEL_167:
                  LODWORD(v27) = v29;
                  if (*(_BYTE *)(v5 + 228) && *(void *)(v5 + 1151))
                  {
                    *(_BYTE *)(v5 + 22_Block_object_dispose((const void *)(v1 - 104), 8) = 0;
                    ++*(void *)(v5 + 1167);
                    if (gNRPacketLoggingEnabled)
                    {
                      v206 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                      id v207 = _NRLogIsLevelEnabled(v206, 1LL);

                      if (v207)
                      {
                        uint64_t v209 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v208);
                        v210 = [(id)v5 copyDescription];
                        _NRLogWithArgs( v209,  1LL,  "%s%.30s:%-4d %@: source-resume: UrgentLinkOutput",  "",  "NRLinkResumeUrgentLinkOutputSource",  827LL,  v210);
                      }
                    }

                    dispatch_resume(*(dispatch_object_t *)(v5 + 1151));
                  }

                  ((void (*)(uint64_t))v329)(v5);
                  *(void *)(v5 + 1935) |= 0x80uLL;
                  if (!gNRPacketLoggingEnabled)
                  {
                    uint64_t v28 = 0LL;
                    goto LABEL_173;
                  }

                  __int128 v166 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                  __int128 v167 = _NRLogIsLevelEnabled(v166, 1LL);

                  uint64_t v61 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                  if (v167)
                  {
                    __int128 v168 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                    uint64_t v169 = [(id)v5 copyDescription];
                    _NRLogWithArgs( v168,  1LL,  "%s%.30s:%-4d %@: no urgent link output slot",  "",  "NRLinkNexusToLinkLoopUrgent",  3222LL,  v169);
                  }

                  uint64_t v28 = 0LL;
LABEL_174:
                  uint64_t v146 = v340;
                  if (v340)
                  {
                    if (v28 != v340) {
                      goto LABEL_278;
                    }
                    uint64_t v147 = v27;
                    uint64_t v148 = v28;
                    id v149 = v340;
                    v150 = 0x40000LL;
                    if ((unsigned __int16)v26 != (unsigned __int16)v147 && (unsigned __int16)v26 != 0)
                    {
                      v150 = 0x20000LL;
                      int v88 = v26;
                    }

                    else
                    {
                      int v88 = v147;
                    }

                    *(void *)(v5 + 1935) |= v150;
                    if (gNRPacketLoggingEnabled)
                    {
                      uint64_t v181 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                      v182 = _NRLogIsLevelEnabled(v181, 1LL);

                      if (v182)
                      {
                        int v184 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v183);
                        uint64_t v185 = [(id)v5 copyDescription];
                        _NRLogWithArgs( v184,  1LL,  "%s%.30s:%-4d %@: UrgentLink:Sending ESP sequence number %u (4)",  "",  "NRLinkNexusToLinkLoopUrgent",  3488LL,  v185,  ESPSequenceNumberFromPacket);
                      }
                    }

                    v367 = v342;
                    os_buflet_set_data_length(v338, (unsigned __int16)v88);
                    os_packet_set_flow_uuid(packet, &v366);
                    uint64_t v151 = os_packet_finalize(packet);
                    if (v151)
                    {
                      v291 = v151;
                      uint64_t v309 = sub_100070554();
                      v310 = _NRLogIsLevelEnabled(v309, 16LL);

                      if (v310)
                      {
                        v311 = sub_100070554();
                        _NRLogWithArgs( v311,  16LL,  "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d",  "",  "NRLinkNexusToLinkLoopUrgent",  3492,  v291);
                      }

                      goto LABEL_302;
                    }

                    uint64_t v153 = *(_DWORD *)(v5 + 299);
                    id v154 = *(_DWORD *)(v5 + 303);
                    if (v153 <= v154)
                    {
                      if (v153 != v154)
                      {
                        uint64_t v264 = sub_100070554();
                        uint64_t v265 = _NRLogIsLevelEnabled(v264, 16LL);

                        if (v265)
                        {
                          uint64_t v266 = sub_100070554();
                          _NRLogWithArgs( v266,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: self->_filledInUrgentLinkWriteBufferBytes == self-> _handledUrgentLinkWriteBufferBytes",  "",  "NRLinkNexusToLinkLoopUrgent",  3507);
                        }

                        v267 = _os_log_pack_size(12LL);
                        uint64_t v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                        dispatch_group_t v268 = *__error();
                        uint64_t v226 = _os_log_pack_fill( v224,  v267,  v268,  &_mh_execute_header,  "%{public}s Assertion Failed: self->_filledInUrgentLinkWriteBufferBytes == self->_handle dUrgentLinkWriteBufferBytes",  v318,  v319);
                        goto LABEL_276;
                      }

                      if (gNRPacketLoggingEnabled)
                      {
                        if (v153)
                        {
                          *(void *)(v5 + 1935) |= 0x100000uLL;
                          int v216 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v152);
                          uint64_t v217 = _NRLogIsLevelEnabled(v216, 1LL);

                          if (v217)
                          {
                            v218 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v152);
                            id v219 = [(id)v5 copyDescription];
                            _NRLogWithArgs( v218,  1LL,  "%s%.30s:%-4d %@: UrgentLink:resetting the linkWriteBuffer from filledIn=%u handled=%u",  "",  "NRLinkNexusToLinkLoopUrgent",  3511LL,  v219,  *(unsigned int *)(v5 + 299),  *(unsigned int *)(v5 + 303));
                          }
                        }
                      }

                      *(_DWORD *)(v5 + 299) = 0;
                    }

                    else
                    {
                      *(void *)(v5 + 1935) |= 0x80000uLL;
                      if (gNRPacketLoggingEnabled)
                      {
                        id v211 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v152);
                        uint64_t v212 = _NRLogIsLevelEnabled(v211, 1LL);

                        if (v212)
                        {
                          uint64_t v214 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v213);
                          v215 = [(id)v5 copyDescription];
                          _NRLogWithArgs( v214,  1LL,  "%s%.30s:%-4d %@: UrgentLink:memmoving the linkWriteBuffer from filledIn=%u handled=%u",  "",  "NRLinkNexusToLinkLoopUrgent",  3500LL,  v215,  *(unsigned int *)(v5 + 299),  *(unsigned int *)(v5 + 303));
                        }
                      }

                      memmove( *(void **)(v5 + 1191),  (const void *)(*(void *)(v5 + 1191) + *(unsigned int *)(v5 + 303)),  (*(_DWORD *)(v5 + 299) - *(_DWORD *)(v5 + 303)));
                      *(_DWORD *)(v5 + 299) -= *(_DWORD *)(v5 + 303);
                    }

                    *(_DWORD *)(v5 + 303) = 0;
                    *(void *)(v5 + 1935) |= 0x200000uLL;
                    uint64_t v146 = v149;
                    if (gNRPacketLoggingEnabled)
                    {
                      v186 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v152);
                      id v187 = _NRLogIsLevelEnabled(v186, 1LL);

                      if (v187)
                      {
                        uint64_t v189 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v188);
                        uint64_t v190 = [(id)v5 copyDescription];
                        _NRLogWithArgs( v189,  1LL,  "%s%.30s:%-4d %@: UrgentLink:advancing past urgentLinkOutputSlot=%p and syncing urgent link output",  "",  "NRLinkNexusToLinkLoopUrgent",  3517LL,  v190,  v148);
                      }

                      if (gNRPacketLoggingEnabled)
                      {
                        v191 = objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
                        int v192 = *(void **)(v5 + 1719);
                        *(void *)(v5 + 1719) = v191;
                      }
                    }

                    os_channel_advance_slot(*(void *)(v5 + 1135), v148);
                    os_channel_sync(*(void *)(v5 + 1119), 0LL);
                    ++*(void *)(v5 + 1463);
                    if (gNRPacketLoggingEnabled)
                    {
                      uint64_t v193 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                      v194 = _NRLogIsLevelEnabled(v193, 1LL);

                      if (v194)
                      {
                        id v195 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                        int v196 = [(id)v5 copyDescription];
                        _NRLogWithArgs( v195,  1LL,  "%s%.30s:%-4d %@: UrgentLink:Wrote to urgent pipe",  "",  "NRLinkNexusToLinkLoopUrgent",  3522LL,  v196);
                      }
                    }
                  }

                  id v155 = v330;
                  if (v330)
                  {
                    *(void *)(v5 + 1935) |= 0x800000uLL;
                    if (gNRPacketLoggingEnabled)
                    {
                      v170 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                      id v171 = _NRLogIsLevelEnabled(v170, 1LL);

                      if (v171)
                      {
                        uint64_t v173 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v172);
                        v174 = [(id)v5 copyDescription];
                        _NRLogWithArgs( v173,  1LL,  "%s%.30s:%-4d %@: DatagramLink:advancing past linkOutputSlot=%p and syncing datagram link output",  "",  "NRLinkNexusToLinkLoopUrgent",  3529LL,  v174,  v330);
                      }

                      id v155 = v330;
                      if (gNRPacketLoggingEnabled)
                      {
                        id v175 = objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
                        uint64_t v176 = *(void **)(v5 + 1703);
                        *(void *)(v5 + 1703) = v175;
                      }
                    }

                    os_channel_advance_slot(*(void *)(v5 + 1055), v155);
                    os_channel_sync(*(void *)(v5 + 1039), 0LL);
                    ++*(void *)(v5 + 1447);
                  }

                  if (v335)
                  {
                    if (v24)
                    {
                      *(void *)(v5 + 1935) |= 0x1000000uLL;
                      if (gNRPacketLoggingEnabled)
                      {
                        uint64_t v197 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                        v198 = _NRLogIsLevelEnabled(v197, 1LL);

                        if (v198)
                        {
                          uint64_t v200 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v199);
                          uint64_t v201 = [(id)v5 copyDescription];
                          _NRLogWithArgs( v200,  1LL,  "%s%.30s:%-4d %@: UrgentLink:advancing past nexusInputSlot=%p and syncing nexus input",  "",  "NRLinkNexusToLinkLoopUrgent",  3539LL,  v201,  v335);
                        }

                        if (gNRPacketLoggingEnabled)
                        {
                          uint64_t v202 = objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
                          v203 = *(void **)(v5 + 1663);
                          *(void *)(v5 + 1663) = v202;
                        }
                      }

                      os_channel_advance_slot(v24, v335);
                      os_channel_sync(v334, 1LL);
                      ++*(void *)(v5 + v323);
                      if (gNRPacketLoggingEnabled)
                      {
                        int v204 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                        uint64_t v205 = _NRLogIsLevelEnabled(v204, 1LL);

                        if (v205)
                        {
                          v179 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                          int v180 = [(id)v5 copyDescription];
                          _NRLogWithArgs( v179,  1LL,  "%s%.30s:%-4d %@: UrgentLink:Served %llu packets, %llu bytes",  "",  "NRLinkNexusToLinkLoopUrgent",  3545LL,  v180,  *(void *)(v5 + v321) - v318,  *(void *)(v5 + v322) - v319);
LABEL_238:
                        }
                      }
                    }

                    else
                    {
                      uint64_t v177 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                      uint64_t v178 = _NRLogIsLevelEnabled(v177, 17LL);

                      if (v178)
                      {
                        v179 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                        int v180 = [(id)v5 copyDescription];
                        _NRLogWithArgs(v179, 17LL, "%@: Tried to sync nexus input but _nexusInputRing is NULL", v180);
                        goto LABEL_238;
                      }
                    }
                  }

                  *(void *)(v5 + 951) = v342;
                  if (*(void *)(v5 + 1935) && *(void *)(v5 + v61[284]))
                  {
                    *(_BYTE *)(v5 + 259) %= *(_BYTE *)(v5 + 258);
                    int v156 = *(void *)(v5 + v61[284]);
                    uint64_t v157 = (void *)(v156 + 8LL * *(unsigned __int8 *)(v5 + 259));
                    if ((unint64_t)(v157 + 1) <= v156 + 8 * (unint64_t)*(unsigned __int8 *)(v5 + 258))
                    {
                      if ((v157 & 7) == 0)
                      {
                        *uint64_t v157 = *(void *)(v5 + 1935);
                        ++*(_BYTE *)(v5 + 259);
                        *(void *)(v5 + 1935) = 0LL;
                      }
                    }

                    else
                    {
                      id v158 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                      id v159 = _NRLogIsLevelEnabled(v158, 17LL);

                      if (v159)
                      {
                        uint64_t v160 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                        uint64_t v161 = [(id)v5 copyDescription];
                        _NRLogWithArgs( v160,  17LL,  "%@: invalid index for ntl log list (curIdx: %u)",  v161,  *(unsigned __int8 *)(v5 + 259));
                      }
                    }
                  }

                  LODWORD(v51) = 0;
                  if (v335)
                  {
                    id v25 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                    goto LABEL_22;
                  }

                  id v25 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                  if (v146 || v330)
                  {
LABEL_22:
                    if ((_DWORD)v51) {
                      goto LABEL_257;
                    }
                    goto LABEL_23;
                  }

                  if ((v325 & 1) != 0)
                  {
                    if (*(_BYTE *)(v5 + 216))
                    {
                      int v88 = (unint64_t)&OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                      if (*(void *)(v5 + 695))
                      {
                        *(_BYTE *)(v5 + 216) = 0;
                        ++*(void *)(v5 + 711);
                        if (!gNRPacketLoggingEnabled) {
                          goto LABEL_251;
                        }
                        goto LABEL_303;
                      }
                    }

    uint64_t v24 = 0LL;
    goto LABEL_34;
  }

  id v5 = v4;
  if ((_NRIsUUIDNonZero(v3) & 1) == 0)
  {
    uint64_t v29 = sub_100121F34();
    unsigned int v30 = _NRLogIsLevelEnabled(v29, 17LL);

    if (v30)
    {
      uint64_t v28 = sub_100121F34();
      _NRLogWithArgs(v28, 17LL, "called with all-zero bluetoothUUID");
      goto LABEL_39;
    }

    goto LABEL_40;
  }

  unsigned int v6 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v6);

  sub_100127AFC(v5);
  uint64_t v33 = 0u;
  __int16 v34 = 0u;
  uint64_t v31 = 0u;
  unsigned int v32 = 0u;
  uint64_t v7 = (id)qword_1001DCB78;
  uint64_t v8 = [v7 countByEnumeratingWithState:&v31 objects:v35 count:16];
  if (v8)
  {
    int v9 = v8;
    uint64_t v10 = *(void *)v32;
    while (2)
    {
      id v11 = 0LL;
      do
      {
        if (*(void *)v32 != v10) {
          objc_enumerationMutation(v7);
        }
        uint64_t v12 = objc_claimAutoreleasedReturnValue( [(id)qword_1001DCB78 objectForKeyedSubscript:*(void *)(*((void *)&v31 + 1) + 8 * (void)v11)]);
        uint64_t v13 = (char *)v12;
        if (v12) {
          id v14 = *(void *)(v12 + 40);
        }
        else {
          id v14 = 0LL;
        }
        if ([v3 isEqual:v14])
        {

          if (v13) {
            goto LABEL_27;
          }
          goto LABEL_17;
        }

        id v11 = (char *)v11 + 1;
      }

      while (v9 != v11);
      uint64_t v15 = [v7 countByEnumeratingWithState:&v31 objects:v35 count:16];
      int v9 = v15;
      if (v15) {
        continue;
      }
      break;
    }
  }

LABEL_17:
  uint64_t v13 = sub_10012E49C(v5);
  if (qword_1001DCBD8 != -1) {
    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
  }
  if (qword_1001DCBD8 != -1)
  {
    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    uint64_t v16 = (void *)qword_1001DCBD0;
    if (v13) {
      goto LABEL_22;
    }
LABEL_42:
    uint64_t v17 = 0LL;
    goto LABEL_23;
  }

  uint64_t v16 = (void *)qword_1001DCBD0;
  if (!v13) {
    goto LABEL_42;
  }
LABEL_22:
  uint64_t v17 = (void *)*((void *)v13 + 4);
LABEL_23:
  uint64_t v18 = v17;
  uint64_t v19 = v16;
  int v20 = (void *)objc_claimAutoreleasedReturnValue([v18 UUIDString]);
  id v21 = (void *)objc_claimAutoreleasedReturnValue([v3 UUIDString]);
  _NRLogWithArgs( v19,  0LL,  "%s%.30s:%-4d Creating new local device with random %@ for Bluetooth query %@",  "",  "+[NRDLocalDevice copyLocalDeviceForBluetoothUUID:shouldCreate:]",  2173LL,  v20,  v21);

LABEL_24:
  [v13 setBluetoothUUID:v3];
  if (v13) {
    id v22 = *((void *)v13 + 4);
  }
  else {
    id v22 = 0LL;
  }
  [(id)qword_1001DCB78 setObject:v13 forKeyedSubscript:v22];
  uint64_t v23 = objc_opt_self(v5);
  sub_100128908(v23);
LABEL_27:
  uint64_t v24 = v13;
  if (qword_1001DCBD8 != -1) {
    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
  {
    if (qword_1001DCBD8 != -1) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    _NRLogWithArgs( qword_1001DCBD0,  0LL,  "%s%.30s:%-4d Returning %@ for Bluetooth query %@",  "",  "+[NRDLocalDevice copyLocalDeviceForBluetoothUUID:shouldCreate:]",  2180LL,  v24,  v3);
  }

LABEL_34:
  return v24;
}

    uint64_t v17 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", "DirectToCloud");
    if (-[NSMutableString length](v11, "length")) {
      -[NSMutableString appendString:](v11, "appendString:", @", ");
    }
    -[NSMutableString appendString:](v11, "appendString:", v17);

    if ((v7 & 0x80) == 0) {
      goto LABEL_46;
    }
    goto LABEL_43;
  }

LABEL_53:
        ++*(void *)(*(void *)(a1 + 40) + *v37);
        unsigned __int16 v50 = 2048;
        unint64_t v1 = (unint64_t)v169;
        bzero(v169, 0x800uLL);
        if (v28 >= 0x7D9)
        {
          if ((_WORD)v28 == 0xFFD8)
          {
            id v116 = sub_10003B584();
            int v117 = _NRLogIsLevelEnabled(v116, 16LL);

            if (v117)
            {
              id v118 = sub_10003B584();
              _NRLogWithArgs( v118,  16LL,  "%s%.30s:%-4d ABORTING: strict_calloc called with size 0",  "",  "strict_calloc",  100);
            }

            uint64_t v119 = _os_log_pack_size(12LL);
            size_t v51 = (size_t)&v153 - ((__chkstk_darwin(v119) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            int v120 = __error();
            uint64_t v121 = _os_log_pack_fill( v51,  v119,  *v120,  &_mh_execute_header,  "%{public}s strict_calloc called with size 0");
            *(_DWORD *)uint64_t v121 = 136446210;
            *(void *)(v121 + 4) = "strict_calloc";
LABEL_114:
            id v122 = sub_10003B584();
            _NRLogAbortWithPack(v122, v51);
LABEL_115:
            id v123 = sub_10003B584();
            int v124 = _NRLogIsLevelEnabled(v123, 16LL);

            if (v124)
            {
              id v125 = sub_10003B584();
              _NRLogWithArgs( v125,  16LL,  "%s%.30s:%-4d ABORTING: strict_calloc(%zu, %zu) failed",  "",  "strict_calloc",  108,  1uLL,  v51);
            }

            uint64_t v126 = _os_log_pack_size(32LL);
            id v127 = (char *)&v153 - ((__chkstk_darwin(v126) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v128 = __error();
            uint64_t v129 = _os_log_pack_fill( v127,  v126,  *v128,  &_mh_execute_header,  "%{public}s strict_calloc(%zu, %zu) failed");
            *(_DWORD *)uint64_t v129 = 136446722;
            *(void *)(v129 + 4) = "strict_calloc";
            *(_WORD *)(v129 + 12) = 2048;
            *(void *)(v129 + 14) = 1LL;
            *(_WORD *)(v129 + 22) = 2048;
            *(void *)(v129 + 24) = v51;
            while (1)
            {
LABEL_118:
              id v130 = sub_10003B584();
              _NRLogAbortWithPack(v130, v127);
LABEL_119:
              uint64_t v31 = 0LL;
LABEL_120:
              id v131 = sub_10003B584();
              int v132 = _NRLogIsLevelEnabled(v131, 16LL);

              if (v132)
              {
                id v133 = sub_10003B584();
                v134 = (void *)createIOVecString(&v163, 1LL);
                _NRLogWithArgs( v133,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), off"
                  "set: %u, ioVec: %@",
                  "",
                  "nrWriteIOVecToBuffer",
                  342LL,
                  v31,
                  2LL,
                  v1,
                  v134);
              }

              uint64_t v135 = _os_log_pack_size(40LL);
              id v127 = (char *)&v153 - ((__chkstk_darwin(v135) + 15) & 0xFFFFFFFFFFFFFFF0LL);
              int v136 = __error();
              uint64_t v137 = _os_log_pack_fill( v127,  v135,  *v136,  &_mh_execute_header,  "%{public}s Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@");
              uint64_t v138 = createIOVecString(&v163, 1LL);
              sub_1000431C4(v137, (uint64_t)"nrWriteIOVecToBuffer", v31, 2, v1, v138);
            }
          }

          size_t v51 = (unsigned __int16)(v28 + 40);
          int v52 = calloc(1uLL, v51);
          if (!v52) {
            goto LABEL_115;
          }
          unint64_t v1 = (unint64_t)v52;
          unsigned __int16 v50 = v28 + 40;
        }

        unsigned int v54 = nrTLVToPacket(&v163, 1LL, v26, v28, v1, v50, *(void *)(a1 + 40) + 671LL, *(void *)(a1 + 40) + 655LL);
        if (gNRPacketLoggingEnabled)
        {
          uint64_t v69 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 40) + 32LL), v53);
          int v70 = _NRLogIsLevelEnabled(v69, 1LL);

          if (v70)
          {
            uint64_t v71 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 40) + 32LL), v53);
            id v72 = [*(id *)(a1 + 40) copyDescription];
            StringFromNRTLVType = (void *)createStringFromNRTLVType(v26);
            _NRLogWithArgs( v71,  1,  "%s%.30s:%-4d %@: Receiving packet [%@(%u/%u), %llu]",  "",  "-[NRLinkQuickRelay readDatagramFromSession]_block_invoke_2",  1733,  v72,  StringFromNRTLVType,  v28,  v54,  [v154 length]);
          }
        }

        if (v54)
        {
          uint64_t v55 = objc_alloc_init(&OBJC_CLASS___NSMutableData);
          -[NSMutableData appendBytes:length:](v55, "appendBytes:length:", v1, v54);
          [*(id *)(*(void *)(a1 + 40) + 343) addObject:v55];
        }

        else
        {
          uint64_t v56 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 40) + 32LL), v53);
          int v57 = _NRLogIsLevelEnabled(v56, 17LL);

          if (!v57) {
            goto LABEL_63;
          }
          uint64_t v55 = (NSMutableData *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 40) + 32LL), v23);
          id v58 = [*(id *)(a1 + 40) copyDescription];
          int v59 = (void *)createStringFromNRTLVType(v26);
          _NRLogWithArgs(v55, 17LL, "%@: failed to reinject %@ tlvLen=%u", v58, v59, v28);
        }

LABEL_63:
        if ((_WORD *)v1 != v169) {
          free((void *)v1);
        }
        uint64_t v60 = *(void *)(a1 + 40);
        if (*(_BYTE *)(v60 + 210))
        {
          if (gNRPacketLoggingEnabled)
          {
            uint64_t v74 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v60 + 32), v23);
            int v75 = _NRLogIsLevelEnabled(v74, 1LL);

            uint64_t v60 = *(void *)(a1 + 40);
            if (v75)
            {
              uint64_t v77 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v60 + 32), v76);
              id v78 = [*(id *)(a1 + 40) copyDescription];
              _NRLogWithArgs( v77,  1LL,  "%s%.30s:%-4d %@: Resuming write source",  "",  "-[NRLinkQuickRelay readDatagramFromSession]_block_invoke_2",  1750LL,  v78);

              uint64_t v60 = *(void *)(a1 + 40);
            }
          }

          dispatch_resume(*(dispatch_object_t *)(v60 + 327));
          *(_BYTE *)(*(void *)(a1 + 40) + 210LL) = 0;
        }

  -[NSMutableArray addObject:](v8, "addObject:", @"RecommendationEngineRestarted");
  if ((reason & 0x400000000000000LL) == 0)
  {
LABEL_28:
    if ((reason & 0x800000000000000LL) == 0) {
      goto LABEL_29;
    }
    goto LABEL_55;
  }

          cbUUIDCandidateMappings = 0LL;
          goto LABEL_22;
        }
      }

      uint64_t v55 = sub_1000FBEC0();
      uint64_t v56 = _NRLogIsLevelEnabled(v55, 16LL);

      if (v56)
      {
        int v57 = sub_1000FBEC0();
        _NRLogWithArgs( v57,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (pairingCandidate) != ((void *)0)",  "",  "-[NRDevicePairingManagerContext requestConfigurationForListener:session:sessionConfig:childConfig:validateAuth Block:responseBlock:]",  923);
      }

      int v38 = (void *)_os_log_pack_size(12LL);
      id v22 = (char *)&v60 - ((__chkstk_darwin(v38) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v58 = *__error();
      uint64_t v53 = _os_log_pack_fill( v22,  v38,  v58,  &_mh_execute_header,  "%{public}s Assertion Failed: (pairingCandidate) != ((void *)0)");
    }

    else
    {
      id v49 = sub_1000FBEC0();
      unsigned __int16 v50 = _NRLogIsLevelEnabled(v49, 16LL);

      if (v50)
      {
        size_t v51 = sub_1000FBEC0();
        _NRLogWithArgs( v51,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (candidateInfo) != ((void *)0)",  "",  "-[NRDevicePairingManagerContext requestConfigurationForListener:session:sessionConfig:childConfig:validateAuth Block:responseBlock:]",  908);
      }

      int v38 = (void *)_os_log_pack_size(12LL);
      id v22 = (char *)&v60 - ((__chkstk_darwin(v38) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v52 = *__error();
      uint64_t v53 = _os_log_pack_fill( v22,  v38,  v52,  &_mh_execute_header,  "%{public}s Assertion Failed: (candidateInfo) != ((void *)0)");
    }

    *(_DWORD *)uint64_t v53 = 136446210;
    *(void *)(v53 + 4) = "-[NRDevicePairingManagerContext requestConfigurationForListener:session:sessionConfig:childCo"
                           "nfig:validateAuthBlock:responseBlock:]";
    int v59 = sub_1000FBEC0();
    _NRLogAbortWithPack(v59, v22);
    goto LABEL_53;
  }

  if (qword_1001DC978 != -1) {
    dispatch_once(&qword_1001DC978, &stru_1001AFA38);
  }
  id v14 = v22;
  uint64_t v15 = v20;
  if (_NRLogIsLevelEnabled(qword_1001DC970, 16LL))
  {
    uint64_t v17 = v66;
    if (qword_1001DC978 != -1) {
      dispatch_once(&qword_1001DC978, &stru_1001AFA38);
    }
    uint64_t v31 = v18;
    id v45 = (id)qword_1001DC970;
    _NRLogWithArgs( v45,  16,  "%s%.30s:%-4d Remote identifier length %zu != %zu",  "",  "-[NRDevicePairingManagerContext requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBloc k:responseBlock:]",  891,  (size_t)[v26 length],  0x10uLL);

    unsigned int v30 = 0LL;
  }

  else
  {
    unsigned int v30 = 0LL;
    uint64_t v17 = v66;
    uint64_t v31 = v18;
  }

            id v78 = (void *)_NRCopyLogObjectForNRUUID(v9, v66);
            id v79 = _NRLogIsLevelEnabled(v78, 16LL);

            if (v79)
            {
              uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v9, v80);
              _NRLogWithArgs( v81,  16LL,  "%s%.30s:%-4d Bad localPublicClassAKeys.length %llu",  "",  "+[NRDLocalDevice queryPairingKeysForNRUUID:minDataProtectionClass:completionBlock:]",  3070,  -[NSMutableData length](v5, "length"));
            }

            goto LABEL_55;
          }

          uint64_t v29 = (void *)_NRCopyLogObjectForNRUUID(v9, v28);
          unsigned int v30 = _NRLogIsLevelEnabled(v29, 16LL);

          if (v30)
          {
            unsigned int v32 = (void *)_NRCopyLogObjectForNRUUID(v9, v31);
            _NRLogWithArgs( v32,  16LL,  "%s%.30s:%-4d Bad localPublicClassDKeys.length %llu",  "",  "+[NRDLocalDevice queryPairingKeysForNRUUID:minDataProtectionClass:completionBlock:]",  3046,  -[NSMutableData length](v11, "length"));
          }
        }
      }

LABEL_17:
      id v11 = 0LL;
      goto LABEL_18;
    }

    int v70 = sub_100121F34();
    uint64_t v71 = _NRLogIsLevelEnabled(v70, 17LL);

    if (v71)
    {
      uint64_t v12 = sub_100121F34();
      _NRLogWithArgs(v12, 17LL, "%s called with null completionBlock");
      goto LABEL_62;
    }
  }

  else
  {
    id v68 = sub_100121F34();
    uint64_t v69 = _NRLogIsLevelEnabled(v68, 17LL);

    if (v69)
    {
      uint64_t v12 = sub_100121F34();
      _NRLogWithArgs(v12, 17LL, "%s called with null nrUUID");
LABEL_62:
    }
  }
}

    uint64_t v31 = 0;
    goto LABEL_54;
  }

  if (qword_1001DCC28 != -1) {
    dispatch_once(&qword_1001DCC28, &stru_1001B0980);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
  {
    if (qword_1001DCC28 != -1) {
      dispatch_once(&qword_1001DCC28, &stru_1001B0980);
    }
    _NRLogWithArgs( qword_1001DCC20,  0LL,  "%s%.30s:%-4d Successfully deleted %@ keychain key %@",  "",  "-[NRDKeyManager deleteKeyfromKeychainWithName:nrUUID:dataProtectionClass:]",  609LL,  String,  v17);
  }

LABEL_83:
      int v88 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 40) + 32LL), v23);
      int v89 = _NRLogIsLevelEnabled(v88, 17LL);

      if (v89)
      {
        int v20 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 40) + 32LL), v90);
        unint64_t v1 = (unint64_t)[*(id *)(a1 + 40) copyDescription];
        id v91 = (void *)createStringFromNRTLVType(v26);
        uint64_t v92 = (void *)createIOVecString(&v163, 1LL);
        _NRLogWithArgs(v20, 17LL, "%@: Invalid checksum detected %@ len %u %@", v1, v91, v28, v92);

LABEL_85:
LABEL_16:
      }

          uint64_t v31 = 1;
LABEL_84:
          uint64_t v64 = -[NSArray initWithArray:](objc_alloc(&OBJC_CLASS___NSArray), "initWithArray:", self->_posrs);
          int v83 = 0u;
          uint64_t v84 = 0u;
          id v85 = 0u;
          int v86 = 0u;
          int v65 = v64;
          uint64_t v66 = -[NSArray countByEnumeratingWithState:objects:count:]( v65,  "countByEnumeratingWithState:objects:count:",  &v83,  v87,  16LL);
          if (v66)
          {
            id v67 = v66;
            id v68 = *(void *)v84;
            do
            {
              for (uint64_t i = 0LL; i != v67; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v84 != v68) {
                  objc_enumerationMutation(v65);
                }
                [*(id *)(*((void *)&v83 + 1) + 8 * (void)i) cancelIfMatchesPrefix:v19 routerID:a8 seqno:a9];
              }

              id v67 = -[NSArray countByEnumeratingWithState:objects:count:]( v65,  "countByEnumeratingWithState:objects:count:",  &v83,  v87,  16LL);
            }

            while (v67);
          }

          uint64_t v18 = v52;
          __int16 v36 = v81;
          goto LABEL_99;
        }
      }

      if (-[NRBabelRoute routerID](v47, "routerID") != a8)
      {
        -[NRBabelRoute setRouterID:](v47, "setRouterID:", a8);
        id v46 = 1;
      }

      if (!-[NRBabelRoute isNextHopEqualTo:](v47, "isNextHopEqualTo:", a6))
      {
        -[NRBabelRoute setNextHop:](v47, "setNextHop:", a6);
        id v46 = 1;
      }

      if (a10 != 0xFFFF) {
        -[NRBabelRoute setInterval:](v47, "setInterval:");
      }
      -[NRBabelRoute setNumExpiryTimerFires:](v47, "setNumExpiryTimerFires:", 0LL);
      -[NRBabelRoute resetExpiryTimer](v47, "resetExpiryTimer");
      if (v46) {
        goto LABEL_51;
      }
LABEL_57:
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      int v52 = v79;
      if (_NRLogIsLevelEnabled(qword_1001DC8A8, 2LL))
      {
        if (qword_1001DC8B0 != -1) {
          dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
        }
        _NRLogWithArgs( qword_1001DC8A8,  2LL,  "%s%.30s:%-4d %@not changing route table entry %@",  "",  "-[NRBabelInstance handleUpdateFromAddr:ForPrefix:plen:nextHop:babelInterface:routerID:seqno:interval:metric:ae:]",  3015LL,  self,  v81);
      }

      uint64_t v31 = 0;
      goto LABEL_84;
    }

    if (a11 == 0xFFFF)
    {
      uint64_t v18 = v79;
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      id v41 = (void *)qword_1001DC8A8;
      uint64_t v53 = bswap64(a8);
      unsigned int v54 = (id)qword_1001DC8A8;
      if (v53 > 0xFFFE)
      {
        int v70 = objc_alloc(&OBJC_CLASS___NSString);
        uint64_t v71 = bswap32(a8);
        uint64_t v55 = -[NSString initWithFormat:]( v70,  "initWithFormat:",  @"<%x:%x:%x:%x>",  HIWORD(v71),  (unsigned __int16)v71,  bswap32(HIDWORD(a8)) >> 16,  __rev16(HIWORD(a8)));
      }

      else
      {
        uint64_t v55 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"<%llx>",  v53,  v76,  v77,  v78);
      }

      id v72 = v55;
      _NRLogWithArgs( v41,  2LL,  "%s%.30s:%-4d %@ignoring new retraction for %@ %@",  "",  "-[NRBabelInstance handleUpdateFromAddr:ForPrefix:plen:nextHop:babelInterface:routerID:seqno:interval:metric:ae:]",  2937LL,  v82,  v19,  v55);
    }

    else
    {
      uint64_t v18 = v79;
      if (!v33)
      {
        uint64_t v56 = -[NRBabelRoute initWithPrefix:neighbor:routerID:seqno:interval:receivedMetric:nextHop:instance:]( objc_alloc(&OBJC_CLASS___NRBabelRoute),  "initWithPrefix:neighbor:routerID:seqno:interval:receivedMetric:nextHop:instance:",  v19,  v20,  a8,  a9,  a10,  a11,  a6,  self);
        if (qword_1001DC8B0 != -1) {
          dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
        }
        uint64_t v81 = v56;
        if (_NRLogIsLevelEnabled(qword_1001DC8A8, 2LL))
        {
          int v52 = v79;
          if (qword_1001DC8B0 != -1) {
            dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
          }
          _NRLogWithArgs( qword_1001DC8A8,  2LL,  "%s%.30s:%-4d %@created new route table entry %@",  "",  "-[NRBabelInstance handleUpdateFromAddr:ForPrefix:plen:nextHop:babelInterface:routerID:seqno:interval:metric:ae:]",  2957LL,  self,  v56);
        }

        else
        {
          int v52 = v79;
        }

        goto LABEL_83;
      }

      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      if (!_NRLogIsLevelEnabled(qword_1001DC8A8, 2LL))
      {
LABEL_97:
        __int16 v36 = 0LL;
LABEL_98:
        uint64_t v31 = 0;
LABEL_99:

        unsigned int v30 = v80;
        goto LABEL_100;
      }

      if (qword_1001DC8B0 != -1) {
        dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
      }
      id v41 = (void *)qword_1001DC8A8;
      int v42 = bswap64(a8);
      uint64_t v43 = (id)qword_1001DC8A8;
      if (v42 > 0xFFFE)
      {
        uint64_t v73 = objc_alloc(&OBJC_CLASS___NSString);
        uint64_t v74 = bswap32(a8);
        uint64_t v44 = -[NSString initWithFormat:]( v73,  "initWithFormat:",  @"<%x:%x:%x:%x>",  HIWORD(v74),  (unsigned __int16)v74,  bswap32(HIDWORD(a8)) >> 16,  __rev16(HIWORD(a8)));
      }

      else
      {
        uint64_t v44 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"<%llx>",  v42,  v76,  v77,  v78);
      }

      id v72 = v44;
      _NRLogWithArgs( v41,  2LL,  "%s%.30s:%-4d %@ignoring unfeasible retraction for %@ %@",  "",  "-[NRBabelInstance handleUpdateFromAddr:ForPrefix:plen:nextHop:babelInterface:routerID:seqno:interval:metric:ae:]",  2942LL,  v82,  v19,  v44);
    }

    goto LABEL_97;
  }

  uint64_t v29 = -[NRBabelInstance purgeAllRoutesFromNeighbor:](self, "purgeAllRoutesFromNeighbor:", v20);
  unsigned int v30 = v20;
  uint64_t v31 = v29;
LABEL_100:

  return v31;
}

            int v52 = kSCEntNetIPv6;
            id v14 = v101;
          }

          uint64_t v53 = (char *)v53 + 1;
        }

        while (v53 != v50);
        unsigned __int16 v50 = -[__CFArray countByEnumeratingWithState:objects:count:]( v48,  "countByEnumeratingWithState:objects:count:",  &v112,  v137,  16LL);
      }

      while (v50);
    }
  }

  uint64_t v106 = 0u;
  __int128 v107 = 0u;
  uint64_t v104 = 0u;
  id v105 = 0u;
  obja = v96;
  uint64_t v74 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( obja,  "countByEnumeratingWithState:objects:count:",  &v104,  v132,  16LL);
  if (v74)
  {
    int v75 = v74;
    uint64_t v76 = *(void *)v105;
    do
    {
      for (iuint64_t i = 0LL; ii != v75; iuint64_t i = (char *)ii + 1)
      {
        if (*(void *)v105 != v76) {
          objc_enumerationMutation(obja);
        }
        id v78 = *(void *)(*((void *)&v104 + 1) + 8LL * (void)ii);
        id v79 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        int v80 = v14;
        uint64_t v81 = (void *)objc_claimAutoreleasedReturnValue([v14[8] objectForKeyedSubscript:v78]);

        if (v81)
        {
          uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([v80[8] objectForKeyedSubscript:v78]);
          -[NSMutableArray addObjectsFromArray:](v79, "addObjectsFromArray:", v82);
        }

        int v83 = (void *)objc_claimAutoreleasedReturnValue([v80[9] objectForKeyedSubscript:v78]);

        if (v83)
        {
          uint64_t v84 = (void *)objc_claimAutoreleasedReturnValue([v80[9] objectForKeyedSubscript:v78]);
          -[NSMutableArray addObjectsFromArray:](v79, "addObjectsFromArray:", v84);
        }

        [v80[10] setObject:v79 forKeyedSubscript:v78];

        id v14 = v80;
      }

      int v75 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( obja,  "countByEnumeratingWithState:objects:count:",  &v104,  v132,  16LL);
    }

    while (v75);
  }

  if (qword_1001DC8D0 != -1) {
    dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC8C8, 1LL))
  {
    if (qword_1001DC8D0 != -1) {
      dispatch_once(&qword_1001DC8D0, &stru_1001AF408);
    }
    id v85 = v14[10];
    int v86 = (id)qword_1001DC8C8;
    _NRLogWithArgs( v86,  1LL,  "%s%.30s:%-4d local endpoint list %@",  "",  "-[NRLinkManagerWired processSCDUpdate:]",  521LL,  v85);
  }

  id v87 = sub_100131A50((uint64_t)&OBJC_CLASS___NRDLocalDevice);
  if (-[NSMutableArray count](v87, "count")) {
    sub_1000C6BDC(v14, v87);
  }
  int v88 = sub_1001317AC((uint64_t)&OBJC_CLASS___NRDLocalDevice);
  if (-[NSMutableArray count](v88, "count")) {
    sub_1000C6BDC(v14, v88);
  }
}

LABEL_86:
      uint64_t v12 = v160 + 1;
      if (v160 + 1 >= (unint64_t)v159)
      {
        id v159 = [v158 countByEnumeratingWithState:&v165 objects:v170 count:16];
        if (!v159)
        {
LABEL_88:

          sub_10003C048(*(void *)(a1 + 40));
          return;
        }

        uint64_t v12 = 0LL;
      }

      uint64_t v13 = *(void *)v166;
    }
  }

  id v4 = v3;
  if ([v4 code] == (id)89)
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v4 domain]);
    unsigned int v6 = [v5 isEqualToString:NSPOSIXErrorDomain];

    if (v6)
    {
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 40) + 32LL), v7);
      int v9 = _NRLogIsLevelEnabled(v8, 16LL);

      if (v9)
      {
        v162 = (unsigned __int8 *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 40) + 32LL), v10);
        id v11 = [*(id *)(a1 + 40) copyDescription];
        _NRLogWithArgs( v162,  16LL,  "%s%.30s:%-4d %@: Read failed on cancelled connection",  "",  "-[NRLinkQuickRelay readDatagramFromSession]_block_invoke_2",  1615LL,  v11);

LABEL_99:
        return;
      }

      return;
    }
  }

  else
  {
  }

  uint64_t v93 = *(void **)(a1 + 40);
  uint64_t v94 = (void *)objc_claimAutoreleasedReturnValue([v93 connection]);
  NSUInteger v95 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) connection]);
  id v96 = [v95 connectionState];
  if ((unint64_t)v96 >= 6) {
    uint64_t v97 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown[%lld]",  v96);
  }
  else {
    uint64_t v97 = (NSString *)*(&off_1001AE718 + (void)v96);
  }
  [v93 reportEvent:10021, @"connection %@ state %@ error %@", v94, v97, *(void *)(a1 + 32) detailsFormat];

  id v99 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 40) + 32LL), v98);
  int v100 = _NRLogIsLevelEnabled(v99, 17LL);

  if (v100)
  {
    v162 = (unsigned __int8 *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 40) + 32LL), v101);
    id v102 = [*(id *)(a1 + 40) copyDescription];
    id v103 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) connection]);
    uint64_t v104 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) connection]);
    id v105 = [v104 connectionState];
    if ((unint64_t)v105 >= 6) {
      uint64_t v106 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown[%lld]",  v105);
    }
    else {
      uint64_t v106 = (NSString *)*(&off_1001AE718 + (void)v105);
    }
    _NRLogWithArgs( v162,  17LL,  "%@: Failed to read data on connection %@ state %@: %@",  v102,  v103,  v106,  *(void *)(a1 + 32));

    goto LABEL_99;
  }

            notify_post("com.apple.networkrelay.referencesChanged");
            sub_1000AD9C8((uint64_t)val);
LABEL_87:
            if (v21) {
              CFRelease(v21);
            }
            if (RandomKey) {
              CFRelease(RandomKey);
            }
            if (v27) {
              CFRelease(v27);
            }

            goto LABEL_94;
          }

          if (qword_1001DC8A0 != -1) {
            dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC898, 17LL))
          {
            if (qword_1001DC8A0 != -1) {
              dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
            }
            _NRLogWithArgs(qword_1001DC898, 17LL, "sec_identity_copy_ref failed");
          }
        }

        else
        {
          if (qword_1001DC8A0 != -1) {
            dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC898, 17LL))
          {
            if (qword_1001DC8A0 != -1) {
              dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
            }
            _NRLogWithArgs(qword_1001DC898, 17LL, "Failed to create local identity");
          }
        }

        unsigned int v27 = 0LL;
        goto LABEL_86;
      }

double sub_1000431C4(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6)
{
  *(void *)&double result = 136447234LL;
  *(_DWORD *)a1 = 136447234;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 1024;
  *(_DWORD *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 1_Block_object_dispose((const void *)(v1 - 104), 8) = 1024;
  *(_DWORD *)(a1 + 20) = a4;
  *(_WORD *)(a1 + 24) = 1024;
  *(_DWORD *)(a1 + 26) = a5;
  *(_WORD *)(a1 + 30) = 2112;
  *(void *)(a1 + 32) = a6;
  return result;
}

double sub_100043200(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  *(void *)&double result = 136446978LL;
  *(_DWORD *)a1 = 136446978;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2112;
  *(void *)(a1 + 14) = a3;
  *(_WORD *)(a1 + 22) = 1024;
  *(_DWORD *)(a1 + 24) = a4;
  *(_WORD *)(a1 + 2_Block_object_dispose((const void *)(v1 - 104), 8) = 1024;
  *(_DWORD *)(a1 + 30) = a5;
  return result;
}

void sub_100043234(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) destination]);
  id v14 = 0LL;
  id v4 = (void *)objc_claimAutoreleasedReturnValue([v2 datagramConnectionForSessionDestination:v3 uid:501 error:&v14]);
  id v5 = v14;

  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472LL;
  void v9[2] = sub_100043330;
  v9[3] = &unk_1001AE6B0;
  unsigned int v6 = *(dispatch_queue_s **)(a1 + 48);
  void v9[4] = *(void *)(a1 + 56);
  id v10 = *(id *)(a1 + 40);
  id v11 = v4;
  id v12 = *(id *)(a1 + 32);
  id v13 = v5;
  id v7 = v5;
  id v8 = v4;
  dispatch_async(v6, v9);
}

void sub_100043330(uint64_t a1)
{
  uint64_t v2 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) queue]);
  dispatch_assert_queue_V2(v2);

  uint64_t v4 = *(void *)(a1 + 32);
  if (*(void *)(a1 + 40))
  {
    id v5 = *(id *)(v4 + 231);
    if (v5)
    {
      unsigned int v6 = v5;
      id v7 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) sessionID]);
      uint64_t v8 = *(void *)(a1 + 32);
      if (v8) {
        int v9 = *(void **)(v8 + 231);
      }
      else {
        int v9 = 0LL;
      }
      id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 sessionID]);
      unsigned __int8 v11 = [v7 isEqualToString:v10];

      uint64_t v4 = *(void *)(a1 + 32);
      if ((v11 & 1) != 0)
      {
        [(id)v4 setConnection:*(void *)(a1 + 48)];
        id v12 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) connection]);

        uint64_t v13 = *(void *)(a1 + 32);
        if (v12)
        {
          if (v13) {
            id v14 = *(void **)(v13 + 231);
          }
          else {
            id v14 = 0LL;
          }
          uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v14 sessionID]);
          if (v13)
          {
            uint64_t v16 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
            -[NSMutableDictionary setObject:forKeyedSubscript:]( v16,  "setObject:forKeyedSubscript:",  &off_1001BC5F8,  @"State");
            -[NSMutableDictionary setObject:forKeyedSubscript:]( v16,  "setObject:forKeyedSubscript:",  v15,  @"SessionID");
            sub_100101A04(@"IDS Session", v16);
          }

          uint64_t v17 = *(void **)(a1 + 32);
          uint64_t v18 = *(void *)(a1 + 40);
          uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v17 connection]);
          [v17 reportEvent:10008, @"session %@ connection %@", v18, v19 detailsFormat];

          uint64_t v21 = *(void *)(a1 + 32);
          if (!v21 || !*(_BYTE *)(v21 + 215))
          {
            [(id)v21 addObserver:*(void *)(a1 + 32) forKeyPath:@"_connection.connectionState" options:5 context:0];
            *(_BYTE *)(*(void *)(a1 + 32) + 215LL) = 1;
            uint64_t v21 = *(void *)(a1 + 32);
          }

          id v22 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v21 + 32), v20);
          int IsLevelEnabled = _NRLogIsLevelEnabled(v22, 0LL);

          if (IsLevelEnabled)
          {
            id v39 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v24);
            id v25 = [*(id *)(a1 + 32) copyDescription];
            uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) connection]);
            _NRLogWithArgs( v39,  0LL,  "%s%.30s:%-4d %@: Obtained connection: %@",  "",  "-[NRLinkQuickRelay sessionStarted:]_block_invoke_2",  2427LL,  v25,  v26);
          }
        }

        else
        {
          [(id)v13 cancelWithReason:@"No datagram connection for session %@ service %@ error %@", *(void *)(a1 + 40), *(void *)(a1 + 56), *(void *)(a1 + 64)];
        }

        return;
      }
    }

    else
    {
      uint64_t v4 = *(void *)(a1 + 32);
    }
  }

  unsigned int v27 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v3);
  int v28 = _NRLogIsLevelEnabled(v27, 0LL);

  if (v28)
  {
    unsigned int v30 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v29);
    id v31 = [*(id *)(a1 + 32) copyDescription];
    unsigned int v32 = v31;
    uint64_t v33 = *(void *)(a1 + 32);
    if (v33) {
      uint64_t v33 = *(void *)(v33 + 231);
    }
    _NRLogWithArgs( v30,  0LL,  "%s%.30s:%-4d %@: mismatched ids session: current %@, previous %@,skip adding KVO for previous connection",  "",  "-[NRLinkQuickRelay sessionStarted:]_block_invoke_2",  2400LL,  v31,  v33,  *(void *)(a1 + 40));
  }

  if (*(void *)(a1 + 48))
  {
    __int16 v34 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v29);
    int v35 = _NRLogIsLevelEnabled(v34, 1LL);

    if (v35)
    {
      id v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v36);
      id v38 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v37,  1LL,  "%s%.30s:%-4d %@: Cancelling %@",  "",  "-[NRLinkQuickRelay sessionStarted:]_block_invoke_2",  2402LL,  v38,  *(void *)(a1 + 48));
    }

    [*(id *)(a1 + 48) cancel];
  }

void sub_1000436F8(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 271), a2);
  }
}

void sub_100043710(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v32 = v3;
  if (!v3)
  {
    if (gNRPacketLoggingEnabled)
    {
      unsigned int v27 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v4);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v27, 1LL);

      if (IsLevelEnabled)
      {
        unsigned int v30 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v29);
        id v31 = [*(id *)(a1 + 32) copyDescription];
        _NRLogWithArgs( v30,  1,  "%s%.30s:%-4d %@: Wrote %llu bytes",  "",  "-[NRLinkQuickRelay writeDatagramToSession:]_block_invoke",  1571,  v31,  [*(id *)(a1 + 40) length]);
      }
    }

    id v18 = [*(id *)(a1 + 40) length];
    uint64_t v19 = *(void *)(a1 + 32);
    uint64_t v20 = 391LL;
    goto LABEL_14;
  }

  if ([v3 code] != (id)89
    || (id v5 = (void *)objc_claimAutoreleasedReturnValue([v32 domain]),
        unsigned int v6 = [v5 isEqualToString:NSPOSIXErrorDomain],
        v5,
        !v6))
  {
    uint64_t v13 = *(void **)(a1 + 32);
    id v14 = (void *)objc_claimAutoreleasedReturnValue([v13 connection]);
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) connection]);
    id v16 = [v15 connectionState];
    if ((unint64_t)v16 >= 6) {
      uint64_t v17 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown[%lld]",  v16);
    }
    else {
      uint64_t v17 = (NSString *)*(&off_1001AE718 + (void)v16);
    }
    [v13 reportEvent:10022, @"connection %@ state %@ error %@", v14, v17, v32 detailsFormat];

    id v22 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v21);
    int v23 = _NRLogIsLevelEnabled(v22, 17LL);

    if (v23)
    {
      id v25 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v24);
      id v26 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v25,  17,  "%@: Failed to write %llu bytes, error %@",  v26,  [*(id *)(a1 + 40) length],  v32);
    }

    id v18 = [*(id *)(a1 + 40) length];
    uint64_t v19 = *(void *)(a1 + 32);
    uint64_t v20 = 399LL;
LABEL_14:
    *(void *)(v19 + v20) += v18;
    goto LABEL_15;
  }

  uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v7);
  int v9 = _NRLogIsLevelEnabled(v8, 16LL);

  if (v9)
  {
    unsigned __int8 v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v10);
    id v12 = [*(id *)(a1 + 32) copyDescription];
    _NRLogWithArgs( v11,  16LL,  "%s%.30s:%-4d %@: Write failed on cancelled connection",  "",  "-[NRLinkQuickRelay writeDatagramToSession:]_block_invoke",  1561LL,  v12);
  }

void sub_1000439DC(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v14 = WeakRetained;
    if (a2)
    {
      id v5 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

      id WeakRetained = v14;
      if (IsLevelEnabled)
      {
        uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(v14[4], v7);
        id v9 = [v14 copyDescription];
        _NRLogWithArgs( v8,  0LL,  "%s%.30s:%-4d %@: Received response to control notify",  "",  "-[NRLinkQuickRelay sendControlData:]_block_invoke",  1522LL,  v9);
LABEL_7:

        id WeakRetained = v14;
      }
    }

    else
    {
      [WeakRetained cancelWithReason:@"Did not receive response to control notify"];
      unsigned __int8 v11 = (void *)_NRCopyLogObjectForNRUUID(v14[4], v10);
      int v12 = _NRLogIsLevelEnabled(v11, 16LL);

      id WeakRetained = v14;
      if (v12)
      {
        uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(v14[4], v13);
        id v9 = [v14 copyDescription];
        _NRLogWithArgs( v8,  16LL,  "%s%.30s:%-4d %@: Did not receive response to control notify",  "",  "-[NRLinkQuickRelay sendControlData:]_block_invoke",  1525LL,  v9);
        goto LABEL_7;
      }
    }
  }
}

void sub_100043B10(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([(id)a1 queue]);
    dispatch_assert_queue_V2(v2);

    if (++*(_BYTE *)(a1 + 217) >= 3u)
    {
      [(id)a1 reportEvent:10025];
      if (!*(_BYTE *)(a1 + 211)) {
        return;
      }
      uint64_t v4 = sub_100041474((void *)a1, 0LL);
      id v29 = (id)objc_claimAutoreleasedReturnValue(v4);
      unsigned int v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 1LL);

      if (IsLevelEnabled)
      {
        id v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v8);
        id v10 = [(id)a1 copyDescription];
        _NRLogWithArgs( v9,  1,  "%s%.30s:%-4d %@: Drained %zu packets",  "",  "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]",  584,  v10,  [v29 count]);
      }

      *(_BYTE *)(a1 + 211) = 0;
      if (*(_BYTE *)(a1 + 209))
      {
        dispatch_resume(*(dispatch_object_t *)(a1 + 319));
        *(_BYTE *)(a1 + 209) = 0;
      }

      goto LABEL_16;
    }

    if (*(unsigned __int8 *)(a1 + 16) == 255)
    {
      id v16 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v3);
      int v17 = _NRLogIsLevelEnabled(v16, 16LL);

      if (!v17) {
        return;
      }
      id v29 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v18);
      id v15 = [(id)a1 copyDescription];
      _NRLogWithArgs( v29,  16LL,  "%s%.30s:%-4d %@: Asked to setup IDS session but cancelled",  "",  "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]",  596LL,  v15);
      goto LABEL_15;
    }

    if (*(_BYTE *)(a1 + 216))
    {
      int v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v11);
      int v13 = _NRLogIsLevelEnabled(v12, 0LL);

      if (!v13) {
        return;
      }
      id v29 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v14);
      id v15 = [(id)a1 copyDescription];
      _NRLogWithArgs( v29,  0LL,  "%s%.30s:%-4d %@: Tried to setup IDS Session but already in progress",  "",  "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]",  606LL,  v15);
      goto LABEL_15;
    }

    if (*(void *)(a1 + 231))
    {
      uint64_t v19 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v11);
      int v20 = _NRLogIsLevelEnabled(v19, 17LL);

      if (v20)
      {
        id v29 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v21);
        id v15 = [(id)a1 copyDescription];
        _NRLogWithArgs(v29, 17LL, "%@: Tried to setup IDS Session but we already have one", v15);
LABEL_15:

LABEL_16:
      }
    }

    else
    {
      *(_BYTE *)(a1 + 216) = 1;
      id v22 = *(id *)(a1 + 223);
      int v23 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 queue]);
      uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 description]);
      if (qword_1001DCA40 != -1) {
        dispatch_once(&qword_1001DCA40, &stru_1001AFC88);
      }
      id v25 = (dispatch_queue_s *)(id)qword_1001DCA48;
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472LL;
      block[2] = sub_1000440EC;
      block[3] = &unk_1001AF908;
      id v31 = v24;
      id v32 = v22;
      id v33 = v23;
      uint64_t v34 = a1;
      id v26 = v23;
      id v27 = v22;
      id v28 = v24;
      dispatch_async(v25, block);
    }
  }

uint64_t sub_100043ECC(void *a1)
{
  uint64_t v1 = (uint64_t)a1;
  if (a1)
  {
    uint64_t v2 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([a1 queue]);
    dispatch_assert_queue_V2(v2);

    uint64_t v3 = *(void *)(v1 + 223);
    uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 32), v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

    if (!v3)
    {
      if (IsLevelEnabled)
      {
        id v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 32), v7);
        id v11 = [(id)v1 copyDescription];
        _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d %@: Bootstrapping IDSService",  "",  "-[NRLinkQuickRelay setupIDSService]",  557LL,  v11);
      }

      int v12 = -[IDSService initWithService:]( objc_alloc(&OBJC_CLASS___IDSService),  "initWithService:",  @"com.apple.private.alloy.terminus");
      if (!v12)
      {
        if (qword_1001DC758 != -1) {
          dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC750, 17LL))
        {
          if (qword_1001DC758 != -1) {
            dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
          }
          _NRLogWithArgs( qword_1001DC750,  17LL,  "[IDSService alloc] initWithService:%@] failed",  @"com.apple.private.alloy.terminus");
        }

        uint64_t v8 = 0LL;
        uint64_t v1 = 0LL;
        goto LABEL_18;
      }

      uint64_t v8 = v12;
      int v13 = (void *)objc_claimAutoreleasedReturnValue([(id)v1 queue]);
      -[IDSService addDelegate:queue:](v8, "addDelegate:queue:", v1, v13);

      objc_storeStrong((id *)(v1 + 223), v8);
LABEL_9:
      uint64_t v1 = 1LL;
LABEL_18:

      return v1;
    }

    if (IsLevelEnabled)
    {
      uint64_t v8 = (IDSService *)_NRCopyLogObjectForNRUUID(*(void *)(v1 + 32), v7);
      id v9 = [(id)v1 copyDescription];
      _NRLogWithArgs( v8,  0LL,  "%s%.30s:%-4d %@: IDSService already exists: %@",  "",  "-[NRLinkQuickRelay setupIDSService]",  553LL,  v9,  *(void *)(v1 + 223));

      goto LABEL_9;
    }

    return 1LL;
  }

  return v1;
}

void sub_1000440EC(uint64_t a1)
{
  if (qword_1001DC758 != -1) {
    dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC750, 0LL))
  {
    if (qword_1001DC758 != -1) {
      dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
    }
    _NRLogWithArgs( qword_1001DC750,  0LL,  "%s%.30s:%-4d %@ Bootstrapping IDSSession",  "",  "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]_block_invoke",  621LL,  *(void *)(a1 + 32));
  }

  __int128 v43 = 0u;
  __int128 v44 = 0u;
  __int128 v41 = 0u;
  __int128 v42 = 0u;
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) devices]);
  id v3 = [v2 countByEnumeratingWithState:&v41 objects:v48 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v42;
LABEL_9:
    uint64_t v6 = 0LL;
    while (1)
    {
      if (*(void *)v42 != v5) {
        objc_enumerationMutation(v2);
      }
      uint64_t v7 = *(void **)(*((void *)&v41 + 1) + 8 * v6);
      if (v4 == (id)++v6)
      {
        id v4 = [v2 countByEnumeratingWithState:&v41 objects:v48 count:16];
        if (v4) {
          goto LABEL_9;
        }
        goto LABEL_15;
      }
    }

    id v8 = v7;

    if (!v8) {
      goto LABEL_31;
    }
    if (qword_1001DC758 != -1) {
      dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC750, 1LL))
    {
      if (qword_1001DC758 != -1) {
        dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
      }
      _NRLogWithArgs( qword_1001DC750,  1LL,  "%s%.30s:%-4d %@ Default device: %@",  "",  "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]_block_invoke",  643LL,  *(void *)(a1 + 32),  v8);
    }

    id v30 = [[IDSAccountController alloc] initWithService:@"com.apple.private.alloy.terminus"];
    id v9 = (void *)objc_claimAutoreleasedReturnValue([v30 accounts]);
    if (qword_1001DC758 != -1) {
      dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC750, 1LL))
    {
      if (qword_1001DC758 != -1) {
        dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
      }
      _NRLogWithArgs( qword_1001DC750,  1LL,  "%s%.30s:%-4d %@ Received the following accounts: %@",  "",  "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]_block_invoke",  648LL,  *(void *)(a1 + 32),  v9);
    }

    __int128 v38 = 0u;
    __int128 v39 = 0u;
    __int128 v36 = 0u;
    __int128 v37 = 0u;
    id v10 = v9;
    id v11 = [v10 countByEnumeratingWithState:&v36 objects:v47 count:16];
    if (v11)
    {
      id v12 = v11;
      uint64_t v13 = *(void *)v37;
LABEL_39:
      uint64_t v15 = 0LL;
      while (1)
      {
        if (*(void *)v37 != v13) {
          objc_enumerationMutation(v10);
        }
        id v16 = *(void **)(*((void *)&v36 + 1) + 8 * v15);
        if (v16)
        {
        }

        if (v12 == (id)++v15)
        {
          id v12 = [v10 countByEnumeratingWithState:&v36 objects:v47 count:16];
          if (!v12) {
            goto LABEL_58;
          }
          goto LABEL_39;
        }
      }

      id v31 = v16;

      if (qword_1001DC758 != -1) {
        dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC750, 1LL))
      {
        if (qword_1001DC758 != -1) {
          dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
        }
        _NRLogWithArgs( qword_1001DC750,  1LL,  "%s%.30s:%-4d %@ Default account: %@",  "",  "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]_block_invoke",  668LL,  *(void *)(a1 + 32),  v31);
      }

      uint64_t v17 = objc_claimAutoreleasedReturnValue([v8 pushToken]);
      uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v8 identities]);
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v8 service]);
      id v29 = (void *)v17;
      int v20 = (void *)_IDSCopyIDForPushTokenAndIdentitiesWithService(v17, v18, v19);
      uint64_t v21 = objc_alloc(&OBJC_CLASS___IDSSession);
      id v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSSet setWithObject:](&OBJC_CLASS___NSSet, "setWithObject:", v20));
      v45[0] = IDSSessionSingleChannelDirectModeKey;
      v45[1] = IDSSessionForceInternetInvitationKey;
      v46[0] = &__kCFBooleanTrue;
      v46[1] = &__kCFBooleanTrue;
      int v23 = (void *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v46,  v45,  2LL));
      uint64_t v24 = -[IDSSession initWithAccount:destinations:options:]( v21,  "initWithAccount:destinations:options:",  v31,  v22,  v23);

      if (qword_1001DC758 != -1) {
        dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC750, 1LL))
      {
        if (qword_1001DC758 != -1) {
          dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
        }
        _NRLogWithArgs( qword_1001DC750,  1LL,  "%s%.30s:%-4d %@ Default session: %@",  "",  "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]_block_invoke",  683LL,  *(void *)(a1 + 32),  v24);
      }

      v32[0] = _NSConcreteStackBlock;
      v32[1] = 3221225472LL;
      v32[2] = sub_100044908;
      v32[3] = &unk_1001B0748;
      id v25 = *(dispatch_queue_s **)(a1 + 48);
      void v32[4] = *(void *)(a1 + 56);
      id v33 = v24;
      id v34 = v20;
      id v26 = v20;
      id v27 = v24;
      dispatch_async(v25, v32);
    }

    else
    {
LABEL_58:

      if (qword_1001DC758 != -1) {
        dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC750, 17LL))
      {
        if (qword_1001DC758 != -1) {
          dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
        }
        _NRLogWithArgs( qword_1001DC750,  17LL,  "Failed to find default account for service %@",  @"com.apple.private.alloy.terminus");
      }

      v35[0] = _NSConcreteStackBlock;
      v35[1] = 3221225472LL;
      v35[2] = sub_1000448D0;
      v35[3] = &unk_1001B0A88;
      id v28 = *(dispatch_queue_s **)(a1 + 48);
      void v35[4] = *(void *)(a1 + 56);
      dispatch_async(v28, v35);
    }
  }

  else
  {
LABEL_15:

LABEL_31:
    if (qword_1001DC758 != -1) {
      dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC750, 16LL))
    {
      if (qword_1001DC758 != -1) {
        dispatch_once(&qword_1001DC758, &stru_1001AE6D0);
      }
      _NRLogWithArgs( qword_1001DC750,  16LL,  "%s%.30s:%-4d Failed to find default device for service %@",  "",  "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]_block_invoke",  634LL,  @"com.apple.private.alloy.terminus");
    }

    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472LL;
    block[2] = sub_100044898;
    block[3] = &unk_1001B0A88;
    uint64_t v14 = *(dispatch_queue_s **)(a1 + 48);
    void block[4] = *(void *)(a1 + 56);
    dispatch_async(v14, block);
  }

id sub_100044898(uint64_t a1)
{
  uint64_t v2 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) queue]);
  dispatch_assert_queue_V2(v2);

  return [*(id *)(a1 + 32) suspend];
}

id sub_1000448D0(uint64_t a1)
{
  uint64_t v2 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) queue]);
  dispatch_assert_queue_V2(v2);

  return [*(id *)(a1 + 32) suspend];
}

void sub_100044908(id *a1)
{
  uint64_t v2 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([a1[4] queue]);
  dispatch_assert_queue_V2(v2);

  *((_BYTE *)a1[4] + 216) = 0;
  id v4 = a1[4];
  if (*((unsigned __int8 *)v4 + 16) == 255)
  {
    uint64_t v21 = (void *)_NRCopyLogObjectForNRUUID(v4[4], v3);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v21, 16LL);

    if (IsLevelEnabled)
    {
      id v25 = (id)_NRCopyLogObjectForNRUUID(*((void *)a1[4] + 4), v23);
      id v24 = [a1[4] copyDescription];
      _NRLogWithArgs( v25,  16LL,  "%s%.30s:%-4d %@: Asked to finish setting up IDS session but cancelled",  "",  "-[NRLinkQuickRelay setupIDSSessionAndSendInvitation]_block_invoke_4",  689LL,  v24);
    }
  }

  else
  {
    id v5 = a1[5];
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([a1[4] queue]);
    [v5 setDelegate:v4 queue:v6];

    uint64_t v7 = (char *)a1[4];
    if (v7)
    {
      objc_storeStrong((id *)(v7 + 231), a1[5]);
      id v8 = (char *)a1[4];
      if (v8)
      {
        objc_storeStrong((id *)(v8 + 239), a1[6]);
        id v9 = (char *)a1[4];
        if (v9)
        {
          id v10 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([v9 queue]);
          dispatch_assert_queue_V2(v10);

          id v12 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v9 + 4), v11);
          int v13 = _NRLogIsLevelEnabled(v12, 0LL);

          if (v13)
          {
            uint64_t v15 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v9 + 4), v14);
            id v16 = [v9 copyDescription];
            _NRLogWithArgs( v15,  0LL,  "%s%.30s:%-4d %@: Sending session invitation",  "",  "-[NRLinkQuickRelay sendInvitation]",  764LL,  v16);
          }

          v9[213] = 1;
          [*(id *)(v9 + 231) sendInvitation];
          uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v9 + 231) sessionID]);
          uint64_t v18 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v18,  "setObject:forKeyedSubscript:",  &off_1001BC5C8,  @"State");
          -[NSMutableDictionary setObject:forKeyedSubscript:]( v18,  "setObject:forKeyedSubscript:",  v17,  @"SessionID");
          sub_100101A04(@"IDS Session", v18);

          [v9 reportEvent:10003, @"%@", *(void *)(v9 + 231) detailsFormat];
          ++*(void *)(v9 + 367);
          uint64_t v19 = mach_absolute_time();
          uint64_t v20 = *(void *)(v9 + 639);
          if (v20) {
            *(void *)(v20 + 112) = v19;
          }
        }
      }
    }
  }

id sub_100044BBC(uint64_t a1)
{
  return [*(id *)(a1 + 32) removeDelegate:*(void *)(a1 + 40)];
}

char *sub_1000454C4(char *a1, void *a2, void *a3)
{
  id v5 = a2;
  uint64_t v6 = a3;
  uint64_t v7 = v6;
  if (!a1) {
    goto LABEL_16;
  }
  if (!v6)
  {
    id v18 = sub_10004579C();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 17LL);

    if (IsLevelEnabled)
    {
      id v20 = sub_10004579C();
      _NRLogWithArgs(v20, 17LL, "%s called with null connection", "-[TXSContext initWithRequest:onConnection:]");

      id v16 = 0LL;
      goto LABEL_6;
    }

id sub_10004579C()
{
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  return (id)qword_1001DC770;
}

void sub_1000457DC(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC770;
  qword_1001DC770 = (uint64_t)v1;
}

id sub_10004580C(void *self, const char *a2)
{
  if (!self) {
    return 0LL;
  }
  uint64_t v3 = (void *)self[4];
  if (!v3)
  {
    Property = (_xpc_connection_s *)objc_getProperty(self, a2, 8LL, 1);
    uint64_t pid = xpc_connection_get_pid(Property);
    uint64_t v6 = -[NSString initWithFormat:](objc_alloc(&OBJC_CLASS___NSString), "initWithFormat:", @"unknown:%d", pid);
    bzero(buffer, 0x400uLL);
    if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1)
    {
      if (buffer[0])
      {
        uint64_t v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

        uint64_t v6 = v7;
      }
    }

    id v8 = (void *)self[4];
    self[4] = v6;

    uint64_t v3 = (void *)self[4];
  }

  return v3;
}

void *sub_100045950(void *a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (a1)
  {
    v18.receiver = a1;
    v18.super_class = (Class)&OBJC_CLASS___TXSHandler;
    uint64_t v6 = objc_msgSendSuper2(&v18, "init");
    if (!v6)
    {
      id v9 = sub_10004579C();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 16LL);

      if (IsLevelEnabled)
      {
        id v11 = sub_10004579C();
        _NRLogWithArgs( v11,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[TXSHandler initWithHandlerFunction:allowedEntitlementGroup:]",  163);
      }

      uint64_t v12 = _os_log_pack_size(12LL);
      int v13 = (char *)&v17 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v14 = __error();
      uint64_t v15 = _os_log_pack_fill(v13, v12, *v14, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v15 = 136446210;
      *(void *)(v15 + 4) = "-[TXSHandler initWithHandlerFunction:allowedEntitlementGroup:]";
      id v16 = sub_10004579C();
      _NRLogAbortWithPack(v16, v13);
    }

    a1 = v6;
    v6[2] = a2;
    objc_setProperty_atomic(v6, v7, v5, 8LL);
  }

  return a1;
}

void *sub_100045AB0(void *a1)
{
  if (!a1) {
    return 0LL;
  }
  v41.receiver = a1;
  v41.super_class = (Class)&OBJC_CLASS___TerminusdXPCServer;
  id v1 = objc_msgSendSuper2(&v41, "init");
  if (!v1)
  {
    id v29 = sub_10004579C();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v29, 16LL);

    if (IsLevelEnabled)
    {
      id v31 = sub_10004579C();
      _NRLogWithArgs( v31,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[TerminusdXPCServer initInternal]",  1385);
    }

    uint64_t v32 = _os_log_pack_size(12LL);
    id v33 = (char *)&v37 - ((v32 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v34 = __error();
    uint64_t v35 = _os_log_pack_fill(v33, v32, *v34, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)uint64_t v35 = 136446210;
    *(void *)(v35 + 4) = "-[TerminusdXPCServer initInternal]";
    id v36 = sub_10004579C();
    _NRLogAbortWithPack(v36, v33);
    return 0LL;
  }

  uint64_t v2 = v1;
  uint64_t v3 = sub_100146AFC();
  objc_setProperty_atomic(v2, v4, v3, 8LL);

  Property = (dispatch_queue_s *)objc_getProperty(v2, v5, 8LL, 1);
  dispatch_assert_queue_V2(Property);
  uint64_t v7 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  objc_setProperty_atomic(v2, v8, v7, 32LL);

  id v9 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
  objc_setProperty_atomic(v2, v10, v9, 40LL);

  id v11 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
  objc_setProperty_atomic(v2, v12, v11, 24LL);

  sub_100045DFC(v2);
  int v13 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  objc_setProperty_atomic(v2, v14, v13, 48LL);

  __int128 v40 = 0u;
  __int128 v39 = 0u;
  __int128 v38 = 0u;
  __int128 v37 = 0u;
  id v16 = objc_getProperty(v2, v15, 40LL, 1);
  id v17 = [v16 countByEnumeratingWithState:&v37 objects:v43 count:16];
  if (v17)
  {
    id v19 = v17;
    uint64_t v20 = *(void *)v38;
    do
    {
      id v21 = 0LL;
      do
      {
        if (*(void *)v38 != v20) {
          objc_enumerationMutation(v16);
        }
        uint64_t v22 = *(void *)(*((void *)&v37 + 1) + 8LL * (void)v21);
        id v23 = objc_getProperty(v2, v18, 48LL, 1);
        uint64_t v42 = v22;
        id v24 = v23;
        uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v42,  1LL,  (void)v37));
        [v24 addObject:v25];

        id v21 = (char *)v21 + 1;
      }

      while (v19 != v21);
      id v19 = [v16 countByEnumeratingWithState:&v37 objects:v43 count:16];
    }

    while (v19);
  }

  objc_setProperty_atomic(v2, v26, 0LL, 40LL);
  sub_100047470(v2, v27);
  return v2;
}

void sub_100045DFC(void *a1)
{
  uint64_t v2 = objc_alloc(&OBJC_CLASS___NSString);
  uint64_t v3 = -[NSString initWithUTF8String:](v2, "initWithUTF8String:", nrXPCEntitlementPing);
  uint64_t v265 = v3;
  SEL v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v265, 1LL));
  uint64_t v266 = v4;
  SEL v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v266, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100048FBC, 1LL, v5);

  uint64_t v6 = objc_alloc(&OBJC_CLASS___NSString);
  uint64_t v7 = nrXPCEntitlementCompanionLink;
  SEL v8 = -[NSString initWithUTF8String:](v6, "initWithUTF8String:", nrXPCEntitlementCompanionLink);
  uint64_t v263 = v8;
  id v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v263, 1LL));
  uint64_t v264 = v9;
  SEL v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v264, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100049698, 25LL, v10);

  id v11 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v7);
  uint64_t v261 = v11;
  SEL v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v261, 1LL));
  uint64_t v262 = v12;
  int v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v262, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100049870, 2LL, v13);

  SEL v14 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v7);
  id v259 = v14;
  SEL v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v259, 1LL));
  uint64_t v260 = v15;
  id v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v260, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100049A48, 3LL, v16);

  id v17 = objc_alloc(&OBJC_CLASS___NSString);
  objc_super v18 = -[NSString initWithUTF8String:](v17, "initWithUTF8String:", nrXPCEntitlementCompanionLinkIsEnabled);
  uint64_t v257 = v18;
  id v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v257, 1LL));
  v258 = v19;
  uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v258, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100049C20, 12LL, v20);

  id v21 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v7);
  id v255 = v21;
  uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v255, 1LL));
  int v256 = v22;
  id v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v256, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100049E4C, 4LL, v23);

  id v24 = objc_alloc(&OBJC_CLASS___NSString);
  uint64_t v25 = nrXPCEntitlementDiagnostic;
  SEL v26 = -[NSString initWithUTF8String:](v24, "initWithUTF8String:", nrXPCEntitlementDiagnostic);
  uint64_t v253 = v26;
  int v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v253, 1LL));
  v254 = v27;
  id v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v254, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10004A088, 21LL, v28);

  id v29 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v25);
  v251 = v29;
  id v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v251, 1LL));
  int v252 = v30;
  id v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v252, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10004A5C4, 22LL, v31);

  uint64_t v32 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v25);
  uint64_t v249 = v32;
  id v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v249, 1LL));
  uint64_t v250 = v33;
  id v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v250, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10004AB48, 33LL, v34);

  uint64_t v35 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v7);
  id v247 = v35;
  id v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v247, 1LL));
  uint64_t v248 = v36;
  __int128 v37 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v248, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10004AF50, 5LL, v37);

  __int128 v38 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v7);
  uint64_t v245 = v38;
  __int128 v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v245, 1LL));
  v246 = v39;
  __int128 v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v246, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10004B1A0, 48LL, v40);

  objc_super v41 = objc_alloc(&OBJC_CLASS___NSString);
  uint64_t v42 = nrXPCEntitlementDevicesRead;
  __int128 v43 = -[NSString initWithUTF8String:](v41, "initWithUTF8String:", nrXPCEntitlementDevicesRead);
  id v243 = v43;
  __int128 v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v243, 1LL));
  int v244 = v44;
  id v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v244, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10004B4D4, 6LL, v45);

  id v46 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v7);
  uint64_t v241 = v46;
  id v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v241, 1LL));
  v242 = v47;
  id v48 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v242, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10004BD30, 7LL, v48);

  id v49 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v7);
  v239 = v49;
  unsigned __int16 v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v239, 1LL));
  int v240 = v50;
  size_t v51 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v240, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10004C468, 31LL, v51);

  int v52 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v42);
  uint64_t v237 = v52;
  uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v237, 1LL));
  uint64_t v238 = v53;
  unsigned int v54 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v238, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10004CAE4, 13LL, v54);

  uint64_t v55 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v42);
  id v235 = v55;
  uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v235, 1LL));
  uint64_t v236 = v56;
  int v57 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v236, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10004D164, 50LL, v57);

  id v58 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v42);
  uint64_t v233 = v58;
  int v59 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v233, 1LL));
  v234 = v59;
  uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v234, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10004D880, 46LL, v60);

  uint64_t v61 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v42);
  id v231 = v61;
  uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v231, 1LL));
  int v232 = v62;
  unsigned __int16 v63 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v232, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10004E05C, 45LL, v63);

  uint64_t v64 = objc_alloc(&OBJC_CLASS___NSString);
  uint64_t v65 = nrXPCEntitlementTesting;
  uint64_t v66 = -[NSString initWithUTF8String:](v64, "initWithUTF8String:", nrXPCEntitlementTesting);
  uint64_t v229 = v66;
  id v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v229, 1LL));
  v230 = v67;
  id v68 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v230, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10004E264, 20LL, v68);

  uint64_t v69 = objc_alloc(&OBJC_CLASS___NSString);
  uint64_t v70 = nrXPCEntitlementDevicesWrite;
  uint64_t v71 = -[NSString initWithUTF8String:](v69, "initWithUTF8String:", nrXPCEntitlementDevicesWrite);
  v227 = v71;
  id v72 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v227, 1LL));
  int v228 = v72;
  uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v228, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10004E60C, 14LL, v73);

  uint64_t v74 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v70);
  uint64_t v225 = v74;
  int v75 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v225, 1LL));
  uint64_t v226 = v75;
  uint64_t v76 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v226, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10004F818, 15LL, v76);

  uint64_t v77 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v70);
  id v223 = v77;
  id v78 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v223, 1LL));
  uint64_t v224 = v78;
  id v79 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v224, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10004FDE8, 19LL, v79);

  int v80 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v70);
  uint64_t v221 = v80;
  uint64_t v81 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v221, 1LL));
  v222 = v81;
  uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v222, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_1000502D8, 16LL, v82);

  int v83 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v70);
  id v219 = v83;
  uint64_t v84 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v219, 1LL));
  int v220 = v84;
  id v85 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v220, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100050834, 17LL, v85);

  int v86 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v65);
  uint64_t v217 = v86;
  id v87 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v217, 1LL));
  v218 = v87;
  int v88 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v218, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100050D90, 18LL, v88);

  int v89 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v65);
  v215 = v89;
  uint64_t v90 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v215, 1LL));
  int v216 = v90;
  id v91 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v216, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10005113C, 47LL, v91);

  uint64_t v92 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v65);
  uint64_t v213 = v92;
  uint64_t v93 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v213, 1LL));
  uint64_t v214 = v93;
  uint64_t v94 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v214, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_1000513A4, 23LL, v94);

  NSUInteger v95 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v65);
  id v211 = v95;
  id v96 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v211, 1LL));
  uint64_t v212 = v96;
  uint64_t v97 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v212, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_1000515C4, 24LL, v97);

  uint64_t v98 = objc_alloc(&OBJC_CLASS___NSString);
  id v99 = -[NSString initWithUTF8String:](v98, "initWithUTF8String:", nrXPCEntitlementDeviceMonitor);
  uint64_t v209 = v99;
  int v100 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v209, 1LL));
  v210 = v100;
  uint64_t v101 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v210, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_1000517E4, 10LL, v101);

  id v102 = objc_alloc(&OBJC_CLASS___NSString);
  id v103 = -[NSString initWithUTF8String:](v102, "initWithUTF8String:", nrXPCEntitlementDevicePreferences);
  id v207 = v103;
  uint64_t v104 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v207, 1LL));
  int v208 = v104;
  id v105 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v208, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100052240, 11LL, v105);

  uint64_t v106 = objc_alloc(&OBJC_CLASS___NSString);
  __int128 v107 = -[NSString initWithUTF8String:](v106, "initWithUTF8String:", nrXPCEntitlementTestLinkRecommendation);
  uint64_t v205 = v107;
  uint64_t v108 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v205, 1LL));
  v206 = v108;
  uint64_t v109 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v206, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10005317C, 26LL, v109);

  uint64_t v110 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v65);
  v203 = v110;
  id v111 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v203, 1LL));
  int v204 = v111;
  int v112 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v204, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10005334C, 27LL, v112);

  id v113 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v65);
  uint64_t v201 = v113;
  uint64_t v114 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v201, 1LL));
  uint64_t v202 = v114;
  uint64_t v115 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v202, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100053574, 28LL, v115);

  id v116 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v65);
  id v199 = v116;
  int v117 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v199, 1LL));
  uint64_t v200 = v117;
  id v118 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v200, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100053BE0, 38LL, v118);

  uint64_t v119 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v65);
  uint64_t v197 = v119;
  int v120 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v197, 1LL));
  v198 = v120;
  uint64_t v121 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v198, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100053E5C, 29LL, v121);

  id v122 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v65);
  id v195 = v122;
  id v123 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v195, 1LL));
  int v196 = v123;
  int v124 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v196, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100054248, 37LL, v124);

  id v125 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v65);
  uint64_t v193 = v125;
  uint64_t v126 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v193, 1LL));
  v194 = v126;
  id v127 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v194, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_1000544CC, 51LL, v127);

  uint64_t v128 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v65);
  v191 = v128;
  uint64_t v129 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v191, 1LL));
  int v192 = v129;
  id v130 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v192, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_1000548E8, 39LL, v130);

  id v131 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v65);
  uint64_t v189 = v131;
  int v132 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v189, 1LL));
  uint64_t v190 = v132;
  id v133 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v190, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100054DDC, 40LL, v133);

  v134 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v65);
  id v187 = v134;
  uint64_t v135 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v187, 1LL));
  uint64_t v188 = v135;
  int v136 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v188, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100055620, 43LL, v136);

  uint64_t v137 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v65);
  uint64_t v185 = v137;
  uint64_t v138 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v185, 1LL));
  v186 = v138;
  BOOL v139 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v186, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100055A44, 34LL, v139);

  id v140 = objc_alloc(&OBJC_CLASS___NSString);
  int v141 = -[NSString initWithUTF8String:](v140, "initWithUTF8String:", nrXPCEntitlementFixedInterfaceMode);
  id v183 = v141;
  id v142 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v183, 1LL));
  int v184 = v142;
  v143 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v184, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100055F64, 32LL, v143);

  uint64_t v144 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v42);
  uint64_t v181 = v144;
  uint64_t v145 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v181, 1LL));
  v182 = v145;
  uint64_t v146 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v182, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_1000564F0, 35LL, v146);

  uint64_t v147 = objc_alloc(&OBJC_CLASS___NSString);
  uint64_t v148 = -[NSString initWithUTF8String:](v147, "initWithUTF8String:", nrXPCEntitlementRetryConnections);
  v179 = v148;
  id v149 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v179, 1LL));
  int v180 = v149;
  v150 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v180, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_1000569E0, 36LL, v150);

  uint64_t v151 = objc_alloc(&OBJC_CLASS___NSString);
  uint64_t v152 = -[NSString initWithUTF8String:](v151, "initWithUTF8String:", nrXPCEntitlementXPCComm);
  uint64_t v177 = v152;
  uint64_t v153 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v177, 1LL));
  uint64_t v178 = v153;
  id v154 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v178, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100056DB8, 41LL, v154);

  id v155 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v65);
  id v175 = v155;
  int v156 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v175, 1LL));
  uint64_t v176 = v156;
  uint64_t v157 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v176, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100057BD4, 42LL, v157);

  id v158 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", v65);
  uint64_t v173 = v158;
  id v159 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v173, 1LL));
  v174 = v159;
  uint64_t v160 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v174, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_100057F2C, 44LL, v160);

  uint64_t v161 = objc_alloc(&OBJC_CLASS___NSString);
  v162 = -[NSString initWithUTF8String:](v161, "initWithUTF8String:", nrXPCEntitlementPairing);
  id v171 = v162;
  id v163 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v171, 1LL));
  int v172 = v163;
  uint64_t v164 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v172, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_1000580FC, 49LL, v164);

  __int128 v165 = objc_alloc(&OBJC_CLASS___NSString);
  __int128 v166 = -[NSString initWithUTF8String:](v165, "initWithUTF8String:", nrXPCEntitlementIdentityProxy);
  uint64_t v169 = v166;
  __int128 v167 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v169, 1LL));
  v170 = v167;
  __int128 v168 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v170, 1LL));
  sub_1000491D8(a1, (uint64_t)sub_10005846C, 52LL, v168);
}

void sub_100047470(void *a1, const char *a2)
{
  Property = (dispatch_queue_s *)objc_getProperty(a1, a2, 8LL, 1);
  dispatch_assert_queue_V2(Property);
  SEL v4 = (const char *)nrXPCServiceName;
  uint64_t v6 = (dispatch_queue_s *)objc_getProperty(a1, v5, 8LL, 1);
  xpc_connection_t mach_service = xpc_connection_create_mach_service(v4, v6, 1uLL);
  objc_setProperty_atomic(a1, v8, mach_service, 16LL);

  if (!objc_getProperty(a1, v9, 16LL, 1))
  {
    id v16 = sub_10004579C();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v16, 16LL);

    if (IsLevelEnabled)
    {
      id v18 = sub_10004579C();
      _NRLogWithArgs( v18,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (self.listener) != ((void *)0)",  "",  "-[TerminusdXPCServer startXPCListener]",  1617);
    }

    uint64_t v19 = _os_log_pack_size(12LL);
    uint64_t v20 = (char *)handler - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v21 = __error();
    uint64_t v22 = _os_log_pack_fill( v20,  v19,  *v21,  &_mh_execute_header,  "%{public}s Assertion Failed: (self.listener) != ((void *)0)");
    *(_DWORD *)uint64_t v22 = 136446210;
    *(void *)(v22 + 4) = "-[TerminusdXPCServer startXPCListener]";
    id v23 = sub_10004579C();
    _NRLogAbortWithPack(v23, v20);
LABEL_10:
    __break(1u);
  }

  id v11 = objc_getProperty(a1, v10, 16LL, 1);
  if (xpc_get_type(v11) != (xpc_type_t)&_xpc_type_connection)
  {
    id v24 = sub_10004579C();
    int v25 = _NRLogIsLevelEnabled(v24, 16LL);

    if (v25)
    {
      id v26 = sub_10004579C();
      _NRLogWithArgs( v26,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (&_xpc_type_connection) == xpc_get_type(self.listener)",  "",  "-[TerminusdXPCServer startXPCListener]",  1618);
    }

    uint64_t v27 = _os_log_pack_size(12LL);
    id v28 = (char *)handler - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    id v29 = __error();
    uint64_t v30 = _os_log_pack_fill( v28,  v27,  *v29,  &_mh_execute_header,  "%{public}s Assertion Failed: (&_xpc_type_connection) == xpc_get_type(self.listener)");
    *(_DWORD *)uint64_t v30 = 136446210;
    *(void *)(v30 + 4) = "-[TerminusdXPCServer startXPCListener]";
    id v31 = sub_10004579C();
    _NRLogAbortWithPack(v31, v28);
    goto LABEL_10;
  }

  objc_initWeak(&location, a1);
  int v13 = (_xpc_connection_s *)objc_getProperty(a1, v12, 16LL, 1);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_1000477C0;
  handler[3] = &unk_1001AE798;
  objc_copyWeak(&v33, &location);
  void handler[4] = a1;
  xpc_connection_set_event_handler(v13, handler);

  SEL v15 = (_xpc_connection_s *)objc_getProperty(a1, v14, 16LL, 1);
  xpc_connection_resume(v15);

  objc_destroyWeak(&v33);
  objc_destroyWeak(&location);
}

void sub_100047784(_Unwind_Exception *a1)
{
}

void sub_1000477C0(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
    if (WeakRetained)
    {
      xpc_type_t type = xpc_get_type(v3);
      if (type == (xpc_type_t)&_xpc_type_connection)
      {
        uint64_t v27 = 0LL;
        id v28 = &v27;
        uint64_t v29 = 0x3032000000LL;
        uint64_t v30 = sub_100047B7C;
        id v31 = sub_100047B8C;
        id v7 = v3;
        id v32 = v7;
        id v9 = objc_getProperty(WeakRetained, v8, 48LL, 1);
        LOBYTE(v7) = sub_100047B94(v7, v9);

        if ((v7 & 1) != 0)
        {
          id v11 = (_xpc_connection_s *)v28[5];
          id Property = *(id *)(a1 + 32);
          if (Property) {
            id Property = objc_getProperty(Property, v10, 8LL, 1);
          }
          int v13 = (dispatch_queue_s *)Property;
          xpc_connection_set_target_queue(v11, v13);

          objc_initWeak(&location, WeakRetained);
          SEL v14 = (_xpc_connection_s *)v28[5];
          handler[0] = _NSConcreteStackBlock;
          handler[1] = 3221225472LL;
          handler[2] = sub_100047DD8;
          handler[3] = &unk_1001AE770;
          void handler[5] = &v27;
          objc_copyWeak(&v25, &location);
          void handler[4] = *(void *)(a1 + 32);
          xpc_connection_set_event_handler(v14, handler);
          xpc_connection_resume((xpc_connection_t)v28[5]);
          id v16 = *(id *)(a1 + 32);
          if (v16) {
            id v16 = objc_getProperty(v16, v15, 24LL, 1);
          }
          id v17 = v16;
          [v17 addObject:v28[5]];

          objc_destroyWeak(&v25);
          objc_destroyWeak(&location);
        }

        else
        {
          if (qword_1001DC778 != -1) {
            dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
          }
          id v18 = (id)qword_1001DC770;
          char IsLevelEnabled = _NRLogIsLevelEnabled(v18, 16LL);

          if ((IsLevelEnabled & 1) != 0)
          {
            if (qword_1001DC778 != -1) {
              dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
            }
            id v20 = (id)qword_1001DC770;
            pid_t pid = xpc_connection_get_pid((xpc_connection_t)v28[5]);
            _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d client pid %d does not have any known entitlement",  "",  "-[TerminusdXPCServer startXPCListener]_block_invoke",  1632,  pid);
          }

          xpc_connection_cancel((xpc_connection_t)v28[5]);
        }

        _Block_object_dispose(&v27, 8);
      }

      else if (type == (xpc_type_t)&_xpc_type_error)
      {
        uint64_t v6 = xpc_copy_description(v3);
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC770, 17LL))
        {
          if (qword_1001DC778 != -1) {
            dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
          }
          _NRLogWithArgs(qword_1001DC770, 17LL, "FATAL: XPC listener received error %s", v6);
        }

        if (v6) {
          free(v6);
        }
      }
    }
  }

  else
  {
    id v22 = sub_10004579C();
    int v23 = _NRLogIsLevelEnabled(v22, 17LL);

    if (!v23) {
      goto LABEL_28;
    }
    id WeakRetained = sub_10004579C();
    _NRLogWithArgs(WeakRetained, 17LL, "%s called with null msg", "-[TerminusdXPCServer startXPCListener]_block_invoke");
  }

LABEL_28:
}

void sub_100047B48( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location, char a21)
{
}

uint64_t sub_100047B7C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void sub_100047B8C(uint64_t a1)
{
}

uint64_t sub_100047B94(void *a1, void *a2)
{
  id v21 = a1;
  __int128 v22 = 0u;
  __int128 v23 = 0u;
  __int128 v24 = 0u;
  __int128 v25 = 0u;
  id obj = a2;
  id v20 = [obj countByEnumeratingWithState:&v22 objects:v30 count:16];
  if (v20)
  {
    uint64_t v19 = *(void *)v23;
    while (2)
    {
      uint64_t v3 = 0LL;
      while (2)
      {
        if (*(void *)v23 != v19) {
          objc_enumerationMutation(obj);
        }
        SEL v4 = *(void **)(*((void *)&v22 + 1) + 8 * v3);
        id v5 = v21;
        id v6 = v4;
        __int128 v26 = 0u;
        __int128 v27 = 0u;
        __int128 v28 = 0u;
        __int128 v29 = 0u;
        id v7 = v6;
        id v8 = [v7 countByEnumeratingWithState:&v26 objects:v31 count:16];
        if (!v8)
        {
LABEL_21:

          uint64_t v16 = 1LL;
          goto LABEL_22;
        }

        id v9 = v8;
        uint64_t v10 = *(void *)v27;
LABEL_10:
        uint64_t v11 = 0LL;
        while (1)
        {
          if (*(void *)v27 != v10) {
            objc_enumerationMutation(v7);
          }
          id v12 = *(id *)(*((void *)&v26 + 1) + 8 * v11);
          id v13 = v5;
          SEL v14 = (void *)xpc_connection_copy_entitlement_value(v13, [v12 UTF8String]);

          if (!v14 || xpc_get_type(v14) != (xpc_type_t)&_xpc_type_BOOL) {
            break;
          }
          BOOL value = xpc_BOOL_get_value(v14);

          if (!value) {
            goto LABEL_5;
          }
          if (v9 == (id)++v11)
          {
            id v9 = [v7 countByEnumeratingWithState:&v26 objects:v31 count:16];
            if (v9) {
              goto LABEL_10;
            }
            goto LABEL_21;
          }
        }

LABEL_5:
        if ((id)++v3 != v20) {
          continue;
        }
        break;
      }

      id v20 = [obj countByEnumeratingWithState:&v22 objects:v30 count:16];
      if (v20) {
        continue;
      }
      break;
    }
  }

  uint64_t v16 = 0LL;
LABEL_22:

  return v16;
}

void sub_100047DD8(uint64_t a1, void *a2)
{
  id v3 = a2;
  xpc_object_t object = v3;
  if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL))
  {
    if (!v3)
    {
      id v132 = sub_10004579C();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v132, 17LL);

      if (!IsLevelEnabled) {
        goto LABEL_165;
      }
      id WeakRetained = sub_10004579C();
      _NRLogWithArgs( WeakRetained,  17LL,  "%s called with null request",  "-[TerminusdXPCServer startXPCListener]_block_invoke_2");
      goto LABEL_164;
    }

    id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
    if (WeakRetained)
    {
      xpc_type_t type = xpc_get_type(object);
      if (type != (xpc_type_t)&_xpc_type_dictionary)
      {
        if (type != (xpc_type_t)&_xpc_type_error)
        {
          id v7 = xpc_copy_description(object);
          if (qword_1001DC778 != -1) {
            dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
          {
            if (qword_1001DC778 != -1) {
              dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
            }
            _NRLogWithArgs( qword_1001DC770,  16LL,  "%s%.30s:%-4d received unknown type for request: %s",  "",  "-[TerminusdXPCServer startXPCListener]_block_invoke_2",  1679,  v7);
          }

          if (v7) {
            free(v7);
          }
          goto LABEL_164;
        }

        id Property = *(id *)(a1 + 32);
        if (Property) {
          id Property = objc_getProperty(Property, v6, 24LL, 1);
        }
        [Property removeObject:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40)];
        objc_opt_self(&OBJC_CLASS___NRLinkDirector);
        if (qword_1001DC878 != -1) {
          dispatch_once(&qword_1001DC878, &stru_1001AEED0);
        }
        __int128 v25 = (id *)(id)qword_1001DC870;
        id v26 = *(id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
        uint64_t v141 = a1;
        v150 = v25;
        if (v25)
        {
          __int128 v27 = sub_100146AFC();
          dispatch_assert_queue_V2((dispatch_queue_t)v27);

          if (v26)
          {
            __int128 v157 = 0u;
            __int128 v158 = 0u;
            __int128 v155 = 0u;
            __int128 v156 = 0u;
            id v28 = v150[27];
            id v29 = [v28 countByEnumeratingWithState:&v155 objects:buffer count:16];
            if (v29)
            {
              id v30 = v29;
              uint64_t v31 = *(void *)v156;
              do
              {
                for (uint64_t i = 0LL; i != v30; uint64_t i = (char *)i + 1)
                {
                  if (*(void *)v156 != v31) {
                    objc_enumerationMutation(v28);
                  }
                  uint64_t v33 = objc_claimAutoreleasedReturnValue( [v150[27] objectForKeyedSubscript:*(void *)(*((void *)&v155 + 1) + 8 * (void)i)]);
                  id v34 = v26;
                  if (v33)
                  {
                    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v33 + 104));
                    [*(id *)(v33 + 168) removeObject:v34];
                  }
                }

                id v30 = [v28 countByEnumeratingWithState:&v155 objects:buffer count:16];
              }

              while (v30);
            }

            id v35 = [v150[28] copy];
            __int128 v151 = 0u;
            __int128 v152 = 0u;
            __int128 v153 = 0u;
            __int128 v154 = 0u;
            id v36 = v35;
            id v37 = [v36 countByEnumeratingWithState:&v151 objects:&v160 count:16];
            if (v37)
            {
              id v38 = v37;
              uint64_t v39 = *(void *)v152;
              do
              {
                for (j = 0LL; j != v38; j = (char *)j + 1)
                {
                  if (*(void *)v152 != v39) {
                    objc_enumerationMutation(v36);
                  }
                  objc_super v41 = *(void **)(*((void *)&v151 + 1) + 8LL * (void)j);
                  if (v41 && (id)v41[2] == v26)
                  {
                    [v150[28] removeObject:*(void *)(*((void *)&v151 + 1) + 8 * (void)j)];
                    uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue([v41 description]);
                    sub_10011BB18(0LL, 1017, 0LL, v42);
                  }
                }

                id v38 = [v36 countByEnumeratingWithState:&v151 objects:&v160 count:16];
              }

              while (v38);
            }

            a1 = v141;
          }

          else
          {
            id v134 = sub_1000A2100();
            int v135 = _NRLogIsLevelEnabled(v134, 17LL);

            if (v135)
            {
              id v136 = sub_1000A2100();
              _NRLogWithArgs( v136,  17LL,  "%s called with null connection",  "-[NRLinkDirector removeDeviceMonitorConnection:]");
            }
          }
        }

        id v43 = *(id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
        if (v150)
        {
          __int128 v44 = sub_100146AFC();
          dispatch_assert_queue_V2((dispatch_queue_t)v44);

          if (v43)
          {
            id v140 = WeakRetained;
            __int128 v157 = 0u;
            __int128 v158 = 0u;
            __int128 v155 = 0u;
            __int128 v156 = 0u;
            id obj = v150[27];
            id v149 = [obj countByEnumeratingWithState:&v155 objects:buffer count:16];
            if (v149)
            {
              id v147 = v43;
              uint64_t v148 = *(void *)v156;
              do
              {
                for (k = 0LL; k != v149; k = (char *)k + 1)
                {
                  if (*(void *)v156 != v148) {
                    objc_enumerationMutation(obj);
                  }
                  uint64_t v46 = objc_claimAutoreleasedReturnValue( [v150[27] objectForKeyedSubscript:*(void *)(*((void *)&v155 + 1) + 8 * (void)k)]);
                  id v47 = v43;
                  if (v46)
                  {
                    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v46 + 104));
                    uint64_t v48 = *(void *)(v46 + 184);
                    id v49 = v47;
                    if (v48)
                    {
                      unsigned __int16 v50 = *(dispatch_queue_s **)(v48 + 24);
                      if (v50) {
                        dispatch_assert_queue_V2(v50);
                      }
                      size_t v51 = (_xpc_connection_s *)v49;
                      int v52 = *(dispatch_queue_s **)(v48 + 24);
                      if (v52) {
                        dispatch_assert_queue_V2(v52);
                      }
                      if ([*(id *)(v48 + 32) count])
                      {
                        context = xpc_connection_get_context(v51);
                        if (context)
                        {
                          unsigned int v54 = context;
                          uint64_t v55 = -[NSString initWithUTF8String:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithUTF8String:",  context);
                          uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v48 + 32) objectForKeyedSubscript:v55]);
                          if (v56)
                          {
                            int v57 = v55;
                            uint64_t v144 = v55;
                            id v145 = v47;
                            if (v57)
                            {
                              id v58 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  "-"));
                              int v59 = (void *)objc_claimAutoreleasedReturnValue( -[NSString componentsSeparatedByString:]( v57,  "componentsSeparatedByString:",  v58));
                              uint64_t v143 = v46;
                              uint64_t v60 = v54;
                              id v61 = v49;
                              uint64_t v62 = v57;
                              unsigned __int16 v63 = v56;
                              uint64_t v64 = v59;
                              uint64_t v65 = (NSString *)objc_claimAutoreleasedReturnValue([v59 firstObject]);

                              uint64_t v56 = v63;
                              int v57 = v62;
                              id v49 = v61;
                              unsigned int v54 = v60;
                              uint64_t v46 = v143;

                              if (!v65) {
                                goto LABEL_67;
                              }
                            }

                            else
                            {
                              if (qword_1001DCAD8 != -1) {
                                dispatch_once(&qword_1001DCAD8, &stru_1001AFE60);
                              }
                              id v86 = (id)qword_1001DCAD0;
                              int v87 = _NRLogIsLevelEnabled(v86, 17LL);

                              if (v87)
                              {
                                if (qword_1001DCAD8 != -1) {
                                  dispatch_once(&qword_1001DCAD8, &stru_1001AFE60);
                                }
                                id v88 = (id)qword_1001DCAD0;
                                _NRLogWithArgs( v88,  17LL,  "%s called with null contextKey",  "NRDPMCopyClientNameFromContextString");
                              }

LABEL_164:
LABEL_165:
}

                  if (sub_100023824((uint64_t)v215))
                  {
                    *((_BYTE *)v217 + 12) = 1;
                    uint64_t v128 = "Successfully sent";
                  }

                  else
                  {
                    uint64_t v128 = "Failed to send";
                  }

                  uint64_t v129 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v27 == 9));
                  sub_1000D4F78( v216,  1020,  @"%s prefer Wi-Fi ack %@",  v130,  v131,  v132,  v133,  v134,  (uint64_t)v128);
                  goto LABEL_247;
                }

                if (v34) {
                  *((_BYTE *)v34 + _Block_object_dispose((const void *)(v1 - 104), 8) = 1;
                }
                BYTE4(v233[0]) = 0;
                LODWORD(v233[0]) = 0;
                *(_DWORD *)((char *)v233 + 5) = 0x1000000;
                if (v27 == 9)
                {
                  LOBYTE(v233[0]) = 1;
                  uint64_t v93 = *(id *)(v216 + 432);
                }

                else
                {
                  uint64_t v93 = 0LL;
                }

                uint64_t v119 = -[NSMutableData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSMutableData),  "initWithBytes:length:",  v233,  9LL);
                v222 = 0u;
                id v223 = 0u;
                int v220 = 0u;
                uint64_t v221 = 0u;
                uint64_t v120 = v93;
                uint64_t v121 = [v120 countByEnumeratingWithState:&v220 objects:v246 count:16];
                if (!v121) {
                  goto LABEL_163;
                }
                id v122 = *(void *)v221;
LABEL_147:
                id v123 = 0LL;
                break;
              case 0xB:
                id v29 = v216;
                if (!*(_BYTE *)(v216 + 10))
                {
LABEL_137:
                  id v28 = 1;
                  goto LABEL_250;
                }

                int v83 = (id *)sub_100021C64(objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage), *(void **)(v216 + 96));
                uint64_t v84 = v83;
                if (v83) {
                  objc_storeStrong(v83 + 3, v214);
                }
                sub_1000D4FF8(v216, v84);
                if (sub_100023824((uint64_t)v84))
                {
                  *((_BYTE *)v217 + 12) = 1;
                  uint64_t v85 = "Successfully sent";
                }

                else
                {
                  uint64_t v85 = "Failed to send";
                }

                dispatch_assert_queue_V2(*(dispatch_queue_t *)(v216 + 104));
                objc_opt_self(&OBJC_CLASS___NRLinkDirector);
                if (qword_1001DC878 != -1) {
                  dispatch_once(&qword_1001DC878, &stru_1001AEED0);
                }
                id v139 = (id)qword_1001DC870;
                id v140 = v139;
                if (v139) {
                  uint64_t v141 = (void *)*((void *)v139 + 6);
                }
                else {
                  uint64_t v141 = 0LL;
                }
                id v142 = v141;

                if (v142) {
                  uint64_t v143 = (void *)v142[8];
                }
                else {
                  uint64_t v143 = 0LL;
                }
                id v211 = v143;
                sub_1000D4F78( v216,  1040,  @"%s AWDL address update %@",  v144,  v145,  v146,  v147,  v148,  (uint64_t)v85);

                goto LABEL_248;
              default:
                id v28 = 1;
                id v29 = v216;
                goto LABEL_250;
            }

            while (1)
            {
              if (*(void *)v221 != v122) {
                objc_enumerationMutation(v120);
              }
              id v124 = *(void **)(*((void *)&v220 + 1) + 8 * v123);
              SEL v125 = ([v124 unsignedCharValue] - 101);
              if (v125 >= 4) {
                break;
              }
              int v232 = 0x7060502u >> (8 * v125);
              if (!v232) {
                goto LABEL_155;
              }
LABEL_158:
              if (v232) {
                NRTLVAdd(v119, 1LL, 1LL, &v232);
              }
              if (v121 == (id)++v123)
              {
                uint64_t v121 = [v120 countByEnumeratingWithState:&v220 objects:v246 count:16];
                if (!v121)
                {
LABEL_163:

                  sub_1000222F4((uint64_t)v215, 13, v119);
                  goto LABEL_164;
                }

                goto LABEL_147;
              }
            }

            int v232 = 0;
LABEL_155:
            id v126 = [v124 unsignedCharValue];
            id v127 = 0x40300020100uLL >> (8 * v126);
            if (v126 >= 6) {
              LOBYTE(v127) = 0;
            }
            int v232 = v127;
            goto LABEL_158;
          }

uint64_t sub_100048FBC(void *a1)
{
  id v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v3 = (id)qword_1001DC770;
    if (v1)
    {
      SEL v4 = (void *)v1[4];
      if (!v4)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        id v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v7 = v8;
        }

        id v9 = (void *)v1[4];
        v1[4] = v7;

        SEL v4 = (void *)v1[4];
      }

      id v10 = v4;
    }

    else
    {
      id v10 = 0LL;
    }

    _NRLogWithArgs(v3, 0LL, "%s%.30s:%-4d Received DaemonPing from %@", "", "handlePing", 190LL, v10);
  }

  pid_t v11 = getpid();
  xpc_object_t v13 = xpc_string_create_with_format("PingReply(%d)", v11);
  if (v1) {
    id v14 = objc_getProperty(v1, v12, 24LL, 1);
  }
  else {
    id v14 = 0LL;
  }
  xpc_dictionary_set_value(v14, nrXPCKeyPingMessage, v13);

  return 0LL;
}

void sub_1000491D8(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a4;
  if (a2)
  {
    id v8 = sub_100045950(objc_alloc(&OBJC_CLASS___TXSHandler), a2, v7);
    if (v8)
    {
      id v9 = (id)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](&OBJC_CLASS___NSNumber, "numberWithUnsignedLongLong:", a3));
      id v11 = objc_msgSend(objc_getProperty(a1, v10, 32, 1), "objectForKeyedSubscript:", v9);
      id v12 = (void *)objc_claimAutoreleasedReturnValue(v11);

      if (v12)
      {
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        id v13 = (id)qword_1001DC770;
        StringFromNRXPCType = (void *)createStringFromNRXPCType(a3);
        _NRLogWithArgs(v13, 17LL, "Trying to reregister handler for type %@", StringFromNRXPCType);
      }

      else
      {
        __int128 v45 = 0u;
        __int128 v46 = 0u;
        __int128 v43 = 0u;
        __int128 v44 = 0u;
        id v15 = v7;
        id v38 = [v15 countByEnumeratingWithState:&v43 objects:v48 count:16];
        if (v38)
        {
          id v36 = v7;
          char v16 = 0;
          uint64_t v17 = *(void *)v44;
          id v37 = v15;
          uint64_t v35 = *(void *)v44;
          do
          {
            for (uint64_t i = 0LL; i != v38; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v44 != v17) {
                objc_enumerationMutation(v15);
              }
              uint64_t v19 = *(void **)(*((void *)&v43 + 1) + 8LL * (void)i);
              __int128 v39 = 0u;
              __int128 v40 = 0u;
              __int128 v41 = 0u;
              __int128 v42 = 0u;
              id v20 = v19;
              id v21 = [v20 countByEnumeratingWithState:&v39 objects:v47 count:16];
              if (v21)
              {
                id v22 = v21;
                uint64_t v23 = *(void *)v40;
                while (2)
                {
                  for (j = 0LL; j != v22; j = (char *)j + 1)
                  {
                    if (*(void *)v40 != v23) {
                      objc_enumerationMutation(v20);
                    }
                    __int128 v25 = *(void **)(*((void *)&v39 + 1) + 8LL * (void)j);
                    if (([v25 hasPrefix:@"com.apple."] & 1) == 0)
                    {
                      if (qword_1001DC778 != -1) {
                        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
                      }
                      id v7 = v36;
                      if (_NRLogIsLevelEnabled(qword_1001DC770, 17LL))
                      {
                        if (qword_1001DC778 != -1) {
                          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
                        }
                        id v28 = (id)qword_1001DC770;
                        id v29 = (void *)createStringFromNRXPCType(a3);
                        _NRLogWithArgs( v28,  17LL,  "Refusing to register handler for type %@ with invalid entitlement %@",  v29,  v25);
                      }

                      goto LABEL_47;
                    }

                    objc_msgSend(objc_getProperty(a1, v26, 40, 1), "addObject:", v25);
                  }

                  id v22 = [v20 countByEnumeratingWithState:&v39 objects:v47 count:16];
                  if (v22) {
                    continue;
                  }
                  break;
                }

                char v16 = 1;
                id v15 = v37;
                uint64_t v17 = v35;
              }
            }

            id v38 = [v15 countByEnumeratingWithState:&v43 objects:v48 count:16];
          }

          while (v38);

          id v7 = v36;
          if ((v16 & 1) != 0)
          {
            objc_msgSend(objc_getProperty(a1, v27, 32, 1), "setObject:forKeyedSubscript:", v8, v9);
            goto LABEL_47;
          }
        }

        else
        {
        }

        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        id v13 = (id)qword_1001DC770;
        StringFromNRXPCType = (void *)createStringFromNRXPCType(a3);
        _NRLogWithArgs( v13,  17LL,  "Refusing to register handler for type %@ without any entitlement",  StringFromNRXPCType);
      }
    }

    else
    {
      id v33 = sub_10004579C();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v33, 17LL);

      if (!IsLevelEnabled)
      {
LABEL_48:

        goto LABEL_49;
      }

      id v9 = sub_10004579C();
      _NRLogWithArgs(v9, 17LL, "[TXSHandler initWithHandlerFunction:] failed");
    }

uint64_t sub_100049698(void *a1)
{
  id v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v3 = (id)qword_1001DC770;
    if (v1)
    {
      SEL v4 = (void *)v1[4];
      if (!v4)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        id v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v7 = v8;
        }

        id v9 = (void *)v1[4];
        v1[4] = v7;

        SEL v4 = (void *)v1[4];
      }

      id v10 = v4;
    }

    else
    {
      id v10 = 0LL;
    }

    _NRLogWithArgs( v3,  0LL,  "%s%.30s:%-4d Setting companion link to default due to request from %@",  "",  "handleCompanionLinkDefault",  198LL,  v10);
  }

  sub_10009FA90(0LL);

  return 0LL;
}

uint64_t sub_100049870(void *a1)
{
  id v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v3 = (id)qword_1001DC770;
    if (v1)
    {
      SEL v4 = (void *)v1[4];
      if (!v4)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        id v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v7 = v8;
        }

        id v9 = (void *)v1[4];
        v1[4] = v7;

        SEL v4 = (void *)v1[4];
      }

      id v10 = v4;
    }

    else
    {
      id v10 = 0LL;
    }

    _NRLogWithArgs( v3,  0LL,  "%s%.30s:%-4d Enabling companion link due to request from %@",  "",  "handleCompanionLinkEnable",  205LL,  v10);
  }

  sub_10009FA90(1LL);

  return 0LL;
}

uint64_t sub_100049A48(void *a1)
{
  id v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v3 = (id)qword_1001DC770;
    if (v1)
    {
      SEL v4 = (void *)v1[4];
      if (!v4)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        id v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v7 = v8;
        }

        id v9 = (void *)v1[4];
        v1[4] = v7;

        SEL v4 = (void *)v1[4];
      }

      id v10 = v4;
    }

    else
    {
      id v10 = 0LL;
    }

    _NRLogWithArgs( v3,  0LL,  "%s%.30s:%-4d Disabling companion link due to request from %@",  "",  "handleCompanionLinkDisable",  212LL,  v10);
  }

  sub_10009FA90(2LL);

  return 0LL;
}

uint64_t sub_100049C20(void *a1)
{
  id v1 = a1;
  int v3 = sub_10009F9C0((uint64_t)v1);
  if (v1) {
    id Property = objc_getProperty(v1, v2, 24LL, 1);
  }
  else {
    id Property = 0LL;
  }
  xpc_dictionary_set_BOOL(Property, nrXPCKeyCompanionLinkIsEnabled, v3);
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v6 = (id)qword_1001DC770;
    if (v1)
    {
      id v7 = (void *)v1[4];
      if (!v7)
      {
        id v8 = (_xpc_connection_s *)objc_getProperty(v1, v5, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(v8);
        id v10 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v11 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v10 = v11;
        }

        id v12 = (void *)v1[4];
        v1[4] = v10;

        id v7 = (void *)v1[4];
      }

      id v13 = v7;
    }

    else
    {
      id v13 = 0LL;
    }

    id v14 = "dis";
    if (v3) {
      id v14 = "en";
    }
    _NRLogWithArgs( v6,  0LL,  "%s%.30s:%-4d Informing %@ that companion link is %sabled",  "",  "handleCompanionLinkIsEnabled",  222LL,  v13,  v14);
  }

  return 0LL;
}

uint64_t sub_100049E4C(void *a1)
{
  id v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v3 = (id)qword_1001DC770;
    if (v1)
    {
      SEL v4 = (void *)v1[4];
      if (!v4)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        id v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v7 = v8;
        }

        id v9 = (void *)v1[4];
        v1[4] = v7;

        SEL v4 = (void *)v1[4];
      }

      id v10 = v4;
    }

    else
    {
      id v10 = 0LL;
    }

    _NRLogWithArgs( v3,  0LL,  "%s%.30s:%-4d Sending companion link status to %@",  "",  "handleCompanionLinkStatus",  398LL,  v10);
  }

  id v11 = sub_1000599A4();
  id v13 = (void *)objc_claimAutoreleasedReturnValue(v11);
  if (v13)
  {
    if (v1) {
      id v14 = objc_getProperty(v1, v12, 24LL, 1);
    }
    else {
      id v14 = 0LL;
    }
    id v15 = (const char *)nrXPCKeyCompanionLinkStatusMessage;
    id v16 = v14;
    xpc_dictionary_set_string(v16, v15, (const char *)[v13 UTF8String]);

    uint64_t v17 = 0LL;
  }

  else
  {
    uint64_t v17 = -2004LL;
  }

  return v17;
}

uint64_t sub_10004A088(void *a1)
{
  id Property = a1;
  id v3 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v2, 16LL, 1);
  }
  string = xpc_dictionary_get_string(Property, nrXPCKeyCompanionLinkStatusDumpToDirectoryPath);
  if (string)
  {
    id v5 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
    if (-[NSString hasPrefix:](v5, "hasPrefix:", @"/var/mobile/Library/Logs/")
      || -[NSString hasPrefix:](v5, "hasPrefix:", @"/private/var/mobile/Library/Logs/")
      || -[NSString hasPrefix:](v5, "hasPrefix:", @"/tmp/")
      || -[NSString hasPrefix:](v5, "hasPrefix:", @"/private/var/tmp/"))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
      {
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        id v8 = (id)qword_1001DC770;
        if (v3)
        {
          id v9 = (void *)v3[4];
          if (!v9)
          {
            id v10 = (_xpc_connection_s *)objc_getProperty(v3, v7, 8LL, 1);
            uint64_t pid = xpc_connection_get_pid(v10);
            id v12 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
            bzero(buffer, 0x400uLL);
            if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
            {
              id v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

              id v12 = v13;
            }

            id v14 = (void *)v3[4];
            void v3[4] = v12;

            id v9 = (void *)v3[4];
          }

          id v15 = v9;
        }

        else
        {
          id v15 = 0LL;
        }

        _NRLogWithArgs( v8,  0LL,  "%s%.30s:%-4d Saving companion link status to %@ for %@",  "",  "handleCompanionLinkStatusToDirectory",  309LL,  v5,  v15);
      }

      if (v3) {
        id v16 = objc_getProperty(v3, v6, 16LL, 1);
      }
      else {
        id v16 = 0LL;
      }
      uint64_t v17 = xpc_dictionary_get_string(v16, nrXPCKeyCompanionLinkStatusSandboxExtensionToken);
      id v18 = v17;
      if (v17) {
        uint64_t v19 = sandbox_extension_consume(v17);
      }
      else {
        uint64_t v19 = -1LL;
      }
      id v29 = sub_10005AB28(v5);
      id v27 = (id)objc_claimAutoreleasedReturnValue(v29);
      if (v18 && (v19 & 0x8000000000000000LL) == 0) {
        sandbox_extension_release(v19);
      }
      if ([v27 count]) {
        uint64_t v28 = 0LL;
      }
      else {
        uint64_t v28 = -2012LL;
      }
    }

    else
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      if (!_NRLogIsLevelEnabled(qword_1001DC770, 17LL))
      {
        uint64_t v28 = -2005LL;
        goto LABEL_48;
      }

      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      id v27 = (id)qword_1001DC770;
      if (v3)
      {
        id v32 = (void *)v3[4];
        if (!v32)
        {
          id v33 = (_xpc_connection_s *)objc_getProperty(v3, v31, 8LL, 1);
          uint64_t v34 = xpc_connection_get_pid(v33);
          uint64_t v35 = sub_10010393C(v34, 1);
          id v36 = (void *)v3[4];
          void v3[4] = v35;

          id v32 = (void *)v3[4];
        }

        id v37 = v32;
      }

      else
      {
        id v37 = 0LL;
      }

      _NRLogWithArgs(v27, 17LL, "Refusing to save companion link status to %@ for %@", v5, v37);

      uint64_t v28 = -2005LL;
    }
  }

  else
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (!_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
    {
      uint64_t v28 = -2005LL;
      goto LABEL_49;
    }

    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v5 = (NSString *)(id)qword_1001DC770;
    if (v3)
    {
      id v21 = (void *)v3[4];
      if (!v21)
      {
        id v22 = (_xpc_connection_s *)objc_getProperty(v3, v20, 8LL, 1);
        uint64_t v23 = xpc_connection_get_pid(v22);
        __int128 v24 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v23);
        bzero(buffer, 0x400uLL);
        if ((int)v23 >= 1 && proc_pidpath(v23, buffer, 0x400u) >= 1 && buffer[0])
        {
          __int128 v25 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  v23);

          __int128 v24 = v25;
        }

        id v26 = (void *)v3[4];
        void v3[4] = v24;

        id v21 = (void *)v3[4];
      }

      id v27 = v21;
    }

    else
    {
      id v27 = 0LL;
    }

    _NRLogWithArgs( v5,  16LL,  "%s%.30s:%-4d Missing directory name from %@",  "",  "handleCompanionLinkStatusToDirectory",  297LL,  v27);
    uint64_t v28 = -2005LL;
  }

LABEL_48:
LABEL_49:

  return v28;
}

uint64_t sub_10004A5C4(void *a1)
{
  id v1 = a1;
  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  if (qword_1001DC778 != -1) {
    goto LABEL_39;
  }
  while (1)
  {
    if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
    {
      if (p_class_meths[239] != (__objc2_meth_list *)-1LL) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      id v4 = (id)qword_1001DC770;
      if (v1)
      {
        id v5 = (void *)*((void *)v1 + 4);
        if (!v5)
        {
          id Property = (_xpc_connection_s *)objc_getProperty(v1, v3, 8LL, 1);
          uint64_t pid = xpc_connection_get_pid(Property);
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
          bzero(v51, 0x400uLL);
          if ((int)pid >= 1 && proc_pidpath(pid, v51, 0x400u) >= 1 && v51[0])
          {
            id v9 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v51,  pid);

            id v8 = v9;
          }

          id v10 = (void *)*((void *)v1 + 4);
          *((void *)v1 + 4) = v8;

          id v5 = (void *)*((void *)v1 + 4);
        }

        id v11 = v5;
      }

      else
      {
        id v11 = 0LL;
      }

      _NRLogWithArgs( v4,  0LL,  "%s%.30s:%-4d Saving companion link status to temp directory for %@",  "",  "handleCompanionLinkStatusToTempDirectory",  372LL,  v11);
    }

    id v12 = objc_alloc(&OBJC_CLASS___NSString);
    id v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
    id v14 = (void *)objc_claimAutoreleasedReturnValue([v13 UUIDString]);
    id v15 = -[NSString initWithFormat:](v12, "initWithFormat:", @"/tmp/terminusd/%@", v14);

    id v16 = sub_10005AB28(v15);
    uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
    if (![v17 count])
    {
      uint64_t v30 = -2012LL;
      goto LABEL_30;
    }

    xpc_object_t v18 = xpc_array_create(0LL, 0LL);
    if (v18) {
      break;
    }
    id v39 = sub_10004579C();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v39, 16LL);

    if (IsLevelEnabled)
    {
      id v41 = sub_10004579C();
      _NRLogWithArgs( v41,  16LL,  "%s%.30s:%-4d ABORTING: xpc_array_create(%p, %u) failed",  "",  "nr_xpc_array_create",  56,  0LL,  0);
    }

    p_class_meths = (__objc2_meth_list **)_os_log_pack_size(28LL);
    uint64_t v35 = (char *)&v44 - ((__chkstk_darwin(p_class_meths) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    __int128 v42 = __error();
    uint64_t v43 = _os_log_pack_fill( v35,  p_class_meths,  *v42,  &_mh_execute_header,  "%{public}s xpc_array_create(%p, %u) failed");
    sub_10005B18C(v43, (uint64_t)"nr_xpc_array_create");
LABEL_38:
    id v38 = sub_10004579C();
    _NRLogAbortWithPack(v38, v35);
LABEL_39:
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }

  uint64_t v19 = v18;
  __int128 v44 = v15;
  __int128 v45 = v1;
  __int128 v48 = 0u;
  __int128 v49 = 0u;
  __int128 v46 = 0u;
  __int128 v47 = 0u;
  id v20 = v17;
  id v21 = [v20 countByEnumeratingWithState:&v46 objects:v50 count:16];
  if (v21)
  {
    id v22 = v21;
    uint64_t v23 = *(void *)v47;
LABEL_19:
    uint64_t v24 = 0LL;
    while (1)
    {
      if (*(void *)v47 != v23) {
        objc_enumerationMutation(v20);
      }
      __int128 v25 = (const char *)[*(id *)(*((void *)&v46 + 1) + 8 * v24) UTF8String];
      if (v25)
      {
        id v1 = (char *)v25;
        xpc_object_t v26 = xpc_string_create(v25);
        if (!v26)
        {
          if (qword_1001DC778 != -1) {
            dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
          }
          id v32 = (id)qword_1001DC770;
          int v33 = _NRLogIsLevelEnabled(v32, 16LL);

          if (v33)
          {
            if (qword_1001DC778 != -1) {
              dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
            }
            id v34 = (id)qword_1001DC770;
            _NRLogWithArgs( v34,  16LL,  "%s%.30s:%-4d ABORTING: xpc_string_create(%s) failed",  "",  "nr_xpc_string_create",  181,  v1);
          }

          p_class_meths = (__objc2_meth_list **)_os_log_pack_size(22LL);
          uint64_t v35 = (char *)&v44 - ((__chkstk_darwin(p_class_meths) + 15) & 0xFFFFFFFFFFFFFFF0LL);
          id v36 = __error();
          uint64_t v37 = _os_log_pack_fill( v35,  p_class_meths,  *v36,  &_mh_execute_header,  "%{public}s xpc_string_create(%s) failed");
          *(_DWORD *)uint64_t v37 = 136446466;
          *(void *)(v37 + 4) = "nr_xpc_string_create";
          *(_WORD *)(v37 + 12) = 2080;
          *(void *)(v37 + 14) = v1;
          goto LABEL_38;
        }

        id v27 = v26;
        xpc_array_append_value(v19, v26);
      }

      if (v22 == (id)++v24)
      {
        id v22 = [v20 countByEnumeratingWithState:&v46 objects:v50 count:16];
        if (!v22) {
          break;
        }
        goto LABEL_19;
      }
    }
  }

  id v1 = v45;
  if (v45) {
    id v29 = objc_getProperty(v45, v28, 24LL, 1);
  }
  else {
    id v29 = 0LL;
  }
  id v15 = v44;
  xpc_dictionary_set_value(v29, nrXPCKeyCompanionLinkStatusDumpFilePaths, v19);

  uint64_t v30 = 0LL;
LABEL_30:

  return v30;
}

uint64_t sub_10004AB48(void *a1)
{
  id Property = a1;
  id v3 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v2, 16LL, 1);
  }
  int v5 = xpc_dictionary_dup_fd(Property, nrXPCKeyCompanionLinkStatusDumpToFileDescriptor);
  if (v5 == -1)
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 17LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      _NRLogWithArgs(qword_1001DC770, 17LL, "Missing file descriptor key failed");
    }
  }

  else
  {
    if (v3) {
      id v6 = objc_getProperty(v3, v4, 16LL, 1);
    }
    else {
      id v6 = 0LL;
    }
    string = xpc_dictionary_get_string(v6, nrXPCKeyCompanionLinkStatusDumpToFilePath);
    if (string)
    {
      id v8 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", string);
      id v9 = sub_1000599A4();
      id v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
      if (!v10)
      {
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC770, 17LL))
        {
          if (qword_1001DC778 != -1) {
            dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
          }
          _NRLogWithArgs(qword_1001DC770, 17LL, "Companion link status is empty failed");
        }

        uint64_t v15 = -2004LL;
        goto LABEL_48;
      }

      id v11 = v8;
      id v12 = v10;
      if (v5 < 0)
      {
        id v16 = sub_100100C84();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v16, 17LL);

        if (!IsLevelEnabled) {
          goto LABEL_40;
        }
        id v18 = sub_100100C84();
        _NRLogWithArgs(v18, 17LL, "%s called with null fd >= 0");
      }

      else
      {
        if (v11)
        {
          if (-[NSString length](v11, "length"))
          {
            id v13 = (void *)objc_claimAutoreleasedReturnValue([v12 dataUsingEncoding:4]);
            char v14 = sub_100100CC4(v5, v11, v13);

            if ((v14 & 1) != 0)
            {
              uint64_t v15 = 0LL;
LABEL_48:

              goto LABEL_49;
            }

LABEL_41:
            if (qword_1001DC778 != -1) {
              dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
            }
            if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
            {
              if (qword_1001DC778 != -1) {
                dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
              }
              _NRLogWithArgs( qword_1001DC770,  16LL,  "%s%.30s:%-4d Failed to write companion link status to fd %d",  "",  "handleCompanionLinkStatusToFileDescriptor",  359,  v5);
            }

            uint64_t v15 = -2012LL;
            goto LABEL_48;
          }

          id v21 = sub_100100C84();
          int v22 = _NRLogIsLevelEnabled(v21, 17LL);

          if (v22)
          {
            id v18 = sub_100100C84();
            _NRLogWithArgs(v18, 17LL, "%s called with null filePath.length");
            goto LABEL_39;
          }
}

  -[NSMutableArray addObject:](v8, "addObject:", @"RadioConditionFair");
  if ((reason & 0x100000) == 0)
  {
LABEL_16:
    if ((reason & 0x200000) == 0) {
      goto LABEL_17;
    }
    goto LABEL_43;
  }

  -[NSMutableArray addObject:](v3, "addObject:", @"BtryPoor");
  if ((a1 & 0x8000000) == 0)
  {
LABEL_16:
    if ((a1 & 0x10000000) == 0) {
      goto LABEL_17;
    }
    goto LABEL_43;
  }
        }
      }

      else
      {
        int v22 = sub_1000F4464();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v22, 17LL);

        if (IsLevelEnabled)
        {
          uint64_t v24 = sub_1000F4464();
          _NRLogWithArgs( v24,  17LL,  "%s called with null asName",  "-[NRApplicationServiceManager useOnlyLocalLinksForASName:]");
        }

        id v4 = 0LL;
      }
    }
  }

  else
  {
    id v4 = 0LL;
  }

  return v4;
}

    uint64_t v30 = 0LL;
    int v31 = v18;
    goto LABEL_42;
  }

  v67[0] = 0LL;
  v67[1] = 0LL;
  __int128 v25 = (void *)objc_claimAutoreleasedReturnValue([v16 remoteIdentifier]);
  xpc_object_t v26 = (void *)objc_claimAutoreleasedReturnValue([v25 identifierData]);

  if ([v26 length] == (id)16)
  {
    [v26 getBytes:v67 length:16];
    id v27 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v67);
    uint64_t v28 = [[NEIKEv2AuthenticationProtocol alloc] initWithMethod:13];
    id v29 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
    uint64_t v64 = v28;
    uint64_t v30 = sub_10010C5AC(0, v29, v28);

    int v31 = v18;
    if (!(*((unsigned int (**)(id, NEIKEv2SessionConfiguration *))v18 + 2))(v18, v30))
    {
      int v33 = (id *)v30;
      uint64_t v30 = 0LL;
      goto LABEL_37;
    }

    if (v65) {
      pairingCandidates = v65->_pairingCandidates;
    }
    else {
      pairingCandidates = 0LL;
    }
    unsigned __int16 v63 = v27;
    int v33 = (id *)objc_claimAutoreleasedReturnValue(-[NSMutableDictionary objectForKeyedSubscript:](pairingCandidates, "objectForKeyedSubscript:", v27));
    if (v33)
    {
LABEL_23:
      id v41 = v20;
      sub_1000FC09C((uint64_t)&OBJC_CLASS___NRDevicePairingCandidateContext, v33 + 15);
      __int128 v42 = v33[15];
      v33[15] = v41;

      sub_1000FC1F4((uint64_t)v33);
      id v27 = v63;
LABEL_37:

      char v14 = v22;
      uint64_t v15 = v20;
      uint64_t v17 = v66;

      goto LABEL_42;
    }

    id v34 = (id *)-[NRDevicePairingCandidate initInternalWithUUID:]( objc_alloc(&OBJC_CLASS___NRDevicePairingCandidate),  "initInternalWithUUID:",  v63);
    if (v34)
    {
      int v33 = v34;
      uint64_t v62 = v63;
      objc_msgSend(v33, "setCbUUID:");
      uint64_t v35 = objc_alloc(&OBJC_CLASS___NRDevicePairingCandidateContext);
      id v61 = v33;
      if (v65)
      {
        id v36 = sub_1000FBF00((id *)&v35->super.isa, v33, v65->_queue, v65);
        if (v36)
        {
          int v33 = v36;
          uint64_t v37 = v65->_pairingCandidates;
          goto LABEL_20;
        }
      }

      else
      {
        unsigned int v54 = sub_1000FBF00((id *)&v35->super.isa, v33, 0LL, 0LL);
        if (v54)
        {
          int v33 = v54;
          uint64_t v37 = 0LL;
LABEL_20:
          -[NSMutableDictionary setObject:forKeyedSubscript:](v37, "setObject:forKeyedSubscript:", v33, v62);
          id v38 = (void *)objc_claimAutoreleasedReturnValue([v61 uuid]);
          if (v65)
          {
            cbUUIDCandidateMappings = v65->_cbUUIDCandidateMappings;
LABEL_22:
            __int128 v40 = v62;
            -[NSMutableDictionary setObject:forKeyedSubscript:]( cbUUIDCandidateMappings,  "setObject:forKeyedSubscript:",  v38,  v62);

            goto LABEL_23;
          }

          close((int)v7);
          goto LABEL_42;
        }
      }

      else
      {
        id v16 = sub_100100C84();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v16, 16LL);

        a2 = "_strict_strlcpy";
        if (IsLevelEnabled)
        {
          id v18 = sub_100100C84();
          _NRLogWithArgs( v18,  16LL,  "%s%.30s:%-4d ABORTING: strict_strlcpy called with NULL src",  "",  "_strict_strlcpy",  240);
        }

        int v5 = (id)_os_log_pack_size(12LL);
        id v7 = &__strerrbuf[-((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
        id v19 = __error();
        int v20 = _os_log_pack_fill( v7,  v5,  *v19,  &_mh_execute_header,  "%{public}s strict_strlcpy called with NULL src");
        *(_DWORD *)int v20 = 136446210;
        *(void *)(v20 + 4) = "_strict_strlcpy";
        id v21 = sub_100100C84();
        _NRLogAbortWithPack(v21, v7);
      }

      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      goto LABEL_22;
    }

    id v10 = *__error();
    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      _NRLogWithArgs(qword_1001DCA50, 17LL, "Failed to create socket for setting interface peer family - %d", v10);
    }
  }

  else
  {
    id v13 = sub_100100C84();
    char v14 = _NRLogIsLevelEnabled(v13, 17LL);

    if (v14)
    {
      uint64_t v15 = sub_100100C84();
      _NRLogWithArgs(v15, 17LL, "%s called with null intfName", "NRSetInterfacePeerDeviceEgressFunctionalType");
    }
  }

  uint64_t v2 = 0LL;
LABEL_42:

  return v2;
}

    if (!(_WORD)v31)
    {
      int v135 = sub_100107F78();
      id v136 = _NRLogIsLevelEnabled(v135, 17LL);

      if (!v136)
      {
        char v14 = 0LL;
        goto LABEL_94;
      }

      unsigned __int16 v50 = (NSMutableSet *)sub_100107F78();
      size_t v51 = (void *)createIPv6AddrString(&v183, v137);
      _NRLogWithArgs(v50, 17LL, "%@ Received bad proxy config %@.%u", v166, v51, 0LL);
      char v14 = 0LL;
LABEL_93:

LABEL_94:
      _Block_object_dispose(&v177, 8);

      _Block_object_dispose(&v170, 8);
      goto LABEL_161;
    }

    if (qword_1001DCAC8 != -1) {
      dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
    }
    __int128 v47 = (id)qword_1001DCAC0;
    __int128 v48 = _NRLogIsLevelEnabled(v47, 0LL);

    if (v48)
    {
      if (qword_1001DCAC8 != -1) {
        dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
      }
      __int128 v49 = (id)qword_1001DCAC0;
      _NRLogWithArgs( v49,  0LL,  "%s%.30s:%-4d %@ Registering proxy config %@.%u",  "",  "NRLinkConfigureProxyAgent",  1491LL,  v166,  v32,  (unsigned __int16)v31);
    }

    unsigned __int16 v50 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
    -[NSMutableSet addObjectsFromArray:](v50, "addObjectsFromArray:", &off_1001BCAA0);
    size_t v51 = sub_100136E34(v12);
    if (v51) {
      -[NSMutableSet addObjectsFromArray:](v50, "addObjectsFromArray:", v51);
    }
    if (v32) {
      -[NSMutableSet addObject:](v50, "addObject:", v32);
    }
    int v52 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v52,  "setObject:forKeyedSubscript:",  v32,  kSCPropNetProxiesSOCKSProxy);
    uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedShort:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedShort:",  (unsigned __int16)v31));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v52,  "setObject:forKeyedSubscript:",  v53,  kSCPropNetProxiesSOCKSPort);

    -[NSMutableDictionary setObject:forKeyedSubscript:]( v52,  "setObject:forKeyedSubscript:",  &off_1001BC820,  kSCPropNetProxiesSOCKSEnable);
    unsigned int v54 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableSet allObjects](v50, "allObjects"));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v52,  "setObject:forKeyedSubscript:",  v54,  kSCPropNetProxiesExceptionsList);

    -[NSMutableDictionary setObject:forKeyedSubscript:]( v52,  "setObject:forKeyedSubscript:",  @"shoes",  @"kCFStreamPropertySOCKSVersion");
    if (_os_feature_enabled_impl("Network", "shoes_udp_associate")
      && *(_BYTE *)(*((void *)&v170 + 1) + 24LL))
    {
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v52,  "setObject:forKeyedSubscript:",  &off_1001BC820,  @"SHOESUDPAssociate");
    }

    if (*((_BYTE *)v12 + 16)) {
      -[NSMutableDictionary setObject:forKeyedSubscript:]( v52,  "setObject:forKeyedSubscript:",  @"com.apple.datausage.alt-account",  @"SHOESFixedBundleID");
    }
    uint64_t v55 = [[NEProxyConfigurationNetworkAgent alloc] initWithProxyConfiguration:v52];
    [v55 setActive:1];
    uint64_t v56 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
    [v55 setAgentUUID:v56];

    [v55 setVoluntary:0];
    [v55 setUserActivated:0];
    [v55 setKernelActivated:0];
    int v57 = objc_claimAutoreleasedReturnValue([v55 agentUUID]);
    id v58 = *a5;
    *a5 = (id)v57;

    int v59 = -[NWNetworkAgentRegistration initWithNetworkAgentClass:]( objc_alloc(&OBJC_CLASS___NWNetworkAgentRegistration),  "initWithNetworkAgentClass:",  objc_opt_class(&OBJC_CLASS___NEProxyConfigurationNetworkAgent));
    uint64_t v60 = *a4;
    *a4 = v59;

    if (!*a4)
    {
      if (qword_1001DCAC8 != -1) {
        dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
      }
      id v68 = (id)qword_1001DCAC0;
      int v69 = _NRLogIsLevelEnabled(v68, 17LL);

      if ((v69 & 1) != 0)
      {
        if (qword_1001DCAC8 != -1) {
          dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
        }
        uint64_t v67 = (id)qword_1001DCAC0;
        _NRLogWithArgs(v67, 17LL, "%@ Failed to create proxy agent registration", v166);
        goto LABEL_76;
      }

      goto LABEL_77;
    }

    if ([*a4 registerNetworkAgent:v55])
    {
      id v61 = v12[16];
      uint64_t v62 = [v61 hasPoliciesForProxyCriteria];

      if ((v62 & 1) == 0)
      {
        unsigned __int16 v63 = v12[16];
        if ([v63 hasCompanionDatapath])
        {
          uint64_t v64 = [*a4 addNetworkAgentToInterfaceNamed:v165];

          if ((v64 & 1) == 0)
          {
            uint64_t v65 = sub_100107F78();
            uint64_t v66 = _NRLogIsLevelEnabled(v65, 17LL);

            if (v66)
            {
              uint64_t v67 = sub_100107F78();
              _NRLogWithArgs(v67, 17LL, "%@ Failed to add proxy agent to %@", v166, v165);
LABEL_76:
              char v14 = 0LL;
LABEL_90:

              goto LABEL_92;
            }

            goto LABEL_77;
          }
        }

        else
        {
        }
      }

      if (qword_1001DCAC8 != -1) {
        dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
      }
      uint64_t v74 = (id)qword_1001DCAC0;
      int v75 = _NRLogIsLevelEnabled(v74, 0LL);

      if (!v75)
      {
        char v14 = 1LL;
        goto LABEL_92;
      }

      if (qword_1001DCAC8 != -1) {
        dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
      }
      uint64_t v67 = (id)qword_1001DCAC0;
      id v76 = (void *)objc_claimAutoreleasedReturnValue([v55 agentUUID]);
      _NRLogWithArgs( v67,  0LL,  "%s%.30s:%-4d %@ Set up proxy agent %@ for configuration: %@",  "",  "NRLinkConfigureProxyAgent",  1546LL,  v166,  v76,  v52);

      char v14 = 1LL;
      goto LABEL_90;
    }

    if (qword_1001DCAC8 != -1) {
      dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
    }
    uint64_t v70 = (id)qword_1001DCAC0;
    uint64_t v71 = _NRLogIsLevelEnabled(v70, 17LL);

    if (v71)
    {
      if (qword_1001DCAC8 != -1) {
        dispatch_once(&qword_1001DCAC8, &stru_1001AFE40);
      }
      uint64_t v67 = (id)qword_1001DCAC0;
      _NRLogWithArgs(v67, 17LL, "%@ Failed to register proxy agent", v166);
      goto LABEL_76;
    }
}

uint64_t sub_10004AF50(void *a1)
{
  id v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v3 = (id)qword_1001DC770;
    if (v1)
    {
      id v4 = (void *)v1[4];
      if (!v4)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        id v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v7 = v8;
        }

        id v9 = (void *)v1[4];
        v1[4] = v7;

        id v4 = (void *)v1[4];
      }

      id v10 = v4;
    }

    else
    {
      id v10 = 0LL;
    }

    _NRLogWithArgs( v3,  0LL,  "%s%.30s:%-4d Cancelling companion link due to %@",  "",  "handleCompanionLinkCancel",  410LL,  v10);
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v11 = (id)qword_1001DC870;
  unsigned int v12 = sub_1000A46D4((uint64_t)v11);

  if (v1) {
    id v14 = objc_getProperty(v1, v13, 24LL, 1);
  }
  else {
    id v14 = 0LL;
  }
  xpc_dictionary_set_uint64(v14, nrXPCKeyCompanionLinkCount, v12);

  return 0LL;
}

uint64_t sub_10004B1A0(void *a1)
{
  id v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v3 = (id)qword_1001DC770;
    if (v1)
    {
      id v4 = (void *)v1[4];
      if (!v4)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        id v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v7 = v8;
        }

        id v9 = (void *)v1[4];
        v1[4] = v7;

        id v4 = (void *)v1[4];
      }

      id v10 = v4;
    }

    else
    {
      id v10 = 0LL;
    }

    _NRLogWithArgs(v3, 0LL, "%s%.30s:%-4d Flushing BT pipe due to %@", "", "handleCompanionLinkFlushBTPipe", 418LL, v10);
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v11 = (id *)(id)qword_1001DC870;
  unsigned int v12 = v11;
  if (v11)
  {
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    id v13 = v11[27];
    id v14 = [v13 countByEnumeratingWithState:&v29 objects:buffer count:16];
    if (v14)
    {
      id v15 = v14;
      uint64_t v16 = *(void *)v30;
      do
      {
        for (uint64_t i = 0LL; i != v15; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v30 != v16) {
            objc_enumerationMutation(v13);
          }
          uint64_t v18 = objc_claimAutoreleasedReturnValue( [v12[27] objectForKeyedSubscript:*(void *)(*((void *)&v29 + 1) + 8 * (void)i)]);
          id v19 = (void *)v18;
          if (v18)
          {
            dispatch_assert_queue_V2(*(dispatch_queue_t *)(v18 + 104));
            id v20 = sub_1000D8B90((uint64_t)v19, 1, 0);
          }

          else
          {
            id v20 = 0LL;
          }
        }

        id v15 = [v13 countByEnumeratingWithState:&v29 objects:buffer count:16];
      }

      while (v15);
    }
  }

  return 0LL;
}

uint64_t sub_10004B4D4(void *a1)
{
  id Property = a1;
  int v5 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v4, 16LL, 1);
  }
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyNRUUID);
  if (uuid)
  {
    id v7 = uuid;
    if (uuid_is_null(uuid))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
      {
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        id v9 = (id)qword_1001DC770;
        if (v5)
        {
          id v10 = (void *)v5[4];
          if (!v10)
          {
            id v11 = (_xpc_connection_s *)objc_getProperty(v5, v8, 8LL, 1);
            uint64_t pid = xpc_connection_get_pid(v11);
            id v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
            bzero(v65, 0x400uLL);
            if ((int)pid >= 1 && proc_pidpath(pid, v65, 0x400u) >= 1 && LOBYTE(v65[0]))
            {
              id v14 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v65,  pid);

              id v13 = v14;
            }

            id v15 = (void *)v5[4];
            void v5[4] = v13;

            id v10 = (void *)v5[4];
          }

          id v16 = v10;
        }

        else
        {
          id v16 = 0LL;
        }

        _NRLogWithArgs(v9, 16LL, "%s%.30s:%-4d All-zero NRUUID from %@", "", "handleResolveEndpoint", 432LL, v16);
        goto LABEL_19;
      }

LABEL_76:
      uint64_t v17 = -2005LL;
      goto LABEL_77;
    }

    uint64_t v18 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v7);
    if (v18)
    {
      id v20 = (char *)v18;
      if (v5) {
        id v21 = objc_getProperty(v5, v19, 16LL, 1);
      }
      else {
        id v21 = 0LL;
      }
      unsigned __int8 uint64 = xpc_dictionary_get_uint64(v21, nrXPCKeyDataProtectionClass);
      p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
      if (qword_1001DC778 == -1)
      {
LABEL_24:
        if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
        {
          if (p_class_meths[239] != (__objc2_meth_list *)-1LL) {
            dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
          }
          id v22 = (id)qword_1001DC770;
          id String = (void *)NRDataProtectionClassCreateString(uint64);
          if (v5)
          {
            uint64_t v25 = (void *)v5[4];
            if (!v25)
            {
              uint64_t v26 = (_xpc_connection_s *)objc_getProperty(v5, v23, 8LL, 1);
              uint64_t v27 = xpc_connection_get_pid(v26);
              uint64_t v28 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v27);
              bzero(v65, 0x400uLL);
              if ((int)v27 >= 1 && proc_pidpath(v27, v65, 0x400u) >= 1 && LOBYTE(v65[0]))
              {
                __int128 v29 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v65,  v27);

                uint64_t v28 = v29;
              }

              __int128 v30 = (void *)v5[4];
              void v5[4] = v28;

              uint64_t v25 = (void *)v5[4];
            }

            id v31 = v25;
          }

          else
          {
            id v31 = 0LL;
          }

          _NRLogWithArgs( v22,  0LL,  "%s%.30s:%-4d Received resolution request for %@ %@ from %@",  "",  "handleResolveEndpoint",  442LL,  v20,  String,  v31);
        }

        else {
          unsigned __int8 v32 = uint64;
        }
        int v33 = sub_100129C28((uint64_t)&OBJC_CLASS___NRDLocalDevice, v20, 0);
        id v34 = v33;
        if (!v33)
        {
          if (p_class_meths[239] != (__objc2_meth_list *)-1LL) {
            dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
          {
            if (p_class_meths[239] != (__objc2_meth_list *)-1LL) {
              dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
            }
            id v37 = (id)qword_1001DC770;
            if (v5)
            {
              id v38 = (void *)v5[4];
              if (!v38)
              {
                id v39 = (_xpc_connection_s *)objc_getProperty(v5, v36, 8LL, 1);
                uint64_t v40 = xpc_connection_get_pid(v39);
                id v41 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v40);
                bzero(v65, 0x400uLL);
                if ((int)v40 >= 1 && proc_pidpath(v40, v65, 0x400u) >= 1 && LOBYTE(v65[0]))
                {
                  __int128 v42 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v65,  v40);

                  id v41 = v42;
                }

                uint64_t v43 = (void *)v5[4];
                void v5[4] = v41;

                id v38 = (void *)v5[4];
              }

              id v44 = v38;
            }

            else
            {
              id v44 = 0LL;
            }

            _NRLogWithArgs( v37,  16LL,  "%s%.30s:%-4d Unknown NRUUID %@ from %@",  "",  "handleResolveEndpoint",  450LL,  v20,  v44);

            uint64_t v17 = -2008LL;
          }

          else
          {
            uint64_t v17 = -2008LL;
          }

          goto LABEL_73;
        }

        v65[0] = 0uLL;
        if (v32 == 4)
        {
          sub_10012D7C8(v33, v65);
        }

        else
        {
          if (v32 != 3)
          {
            if (p_class_meths[239] != (__objc2_meth_list *)-1LL) {
              dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
            }
            if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
            {
              if (p_class_meths[239] != (__objc2_meth_list *)-1LL) {
                dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
              }
              id v47 = (id)qword_1001DC770;
              uint64_t v48 = v32;
              if (v5)
              {
                __int128 v49 = (void *)v5[4];
                if (!v49)
                {
                  unsigned __int16 v50 = (_xpc_connection_s *)objc_getProperty(v5, v46, 8LL, 1);
                  uint64_t v51 = xpc_connection_get_pid(v50);
                  int v52 = sub_10010393C(v51, 1);
                  uint64_t v53 = (void *)v5[4];
                  void v5[4] = v52;

                  __int128 v49 = (void *)v5[4];
                }

                id v54 = v49;
              }

              else
              {
                id v54 = 0LL;
              }

              _NRLogWithArgs( v47,  16LL,  "%s%.30s:%-4d Invalid data protection class %llu from %@",  "",  "handleResolveEndpoint",  461LL,  v48,  v54);
            }

            uint64_t v17 = -2005LL;
            goto LABEL_73;
          }

          sub_100136A64(v33, v65);
        }

        if (v5) {
          id v45 = objc_getProperty(v5, v35, 24LL, 1);
        }
        else {
          id v45 = 0LL;
        }
        xpc_dictionary_set_data(v45, nrXPCKeyIPv6Address, v65, 0x10uLL);
        uint64_t v17 = 0LL;
LABEL_73:

        goto LABEL_77;
      }
    }

    else
    {
      id v59 = sub_10004579C();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v59, 16LL);

      if (IsLevelEnabled)
      {
        id v61 = sub_10004579C();
        _NRLogWithArgs( v61,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "handleResolveEndpoint",  436);
      }

      int v5 = (void *)_os_log_pack_size(12LL);
      id v20 = (char *)v65 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v62 = __error();
      uint64_t v63 = _os_log_pack_fill( v20,  v5,  *v62,  &_mh_execute_header,  "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
      *(_DWORD *)uint64_t v63 = 136446210;
      *(void *)(v63 + 4) = "handleResolveEndpoint";
      id v64 = sub_10004579C();
      _NRLogAbortWithPack(v64, v20);
    }

    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    goto LABEL_24;
  }

  id v55 = sub_10004579C();
  int v56 = _NRLogIsLevelEnabled(v55, 16LL);

  if (!v56) {
    goto LABEL_76;
  }
  id v9 = sub_10004579C();
  id v16 = sub_10004580C(v5, v57);
  _NRLogWithArgs(v9, 16LL, "%s%.30s:%-4d Missing NRUUID from %@", "", "handleResolveEndpoint", 428LL, v16);
LABEL_19:

  uint64_t v17 = -2005LL;
LABEL_77:

  return v17;
}

      unsigned int v12 = v5 == 0LL;
      id v10 = objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol);
      id v8 = 0LL;
      goto LABEL_19;
    case 4:
      if (qword_1001DCA68 != -1) {
        dispatch_once(&qword_1001DCA68, &stru_1001AFD30);
      }
      id String = (id)qword_1001DCA60;
      if (v5)
      {
        id v7 = 9LL;
LABEL_16:
        id v8 = (id *)v5[v7];
        id v9 = *((unsigned __int16 *)v5 + 14);
        id v10 = objc_alloc(&OBJC_CLASS___NEIKEv2AuthenticationProtocol);
        if (v9 >= 0x14)
        {
          id v11 = [v10 initWithDigitalSignature:3];
          unsigned int v12 = 0;
          goto LABEL_20;
        }

        unsigned int v12 = 0;
LABEL_19:
        id v11 = [v10 initWithNonStandardDigitalSignature:3];
LABEL_20:
        id v13 = sub_10010C5AC(a1, String, v11);
        id v14 = v13;
        if (v8)
        {
          id v15 = (uint64_t *)v8[1];
          id v16 = v15;
          if (v15) {
            uint64_t v17 = v15[2];
          }
          else {
            uint64_t v17 = 0LL;
          }
          -[NEIKEv2SessionConfiguration setRemotePublicKeyRef:](v14, "setRemotePublicKeyRef:", v17);

          uint64_t v18 = (uint64_t *)v8[2];
          id v19 = v18;
          if (v18) {
            id v20 = v18[2];
          }
          else {
            id v20 = 0LL;
          }
        }

        else
        {
          -[NEIKEv2SessionConfiguration setRemotePublicKeyRef:](v13, "setRemotePublicKeyRef:", 0LL);
          id v19 = 0LL;
          id v20 = 0LL;
        }

        -[NEIKEv2SessionConfiguration setLocalPrivateKeyRef:](v14, "setLocalPrivateKeyRef:", v20);

        if (a1 && _os_feature_enabled_impl("terminus", "EncryptedIdentity"))
        {
          if (!v12)
          {
            if (*((unsigned __int16 *)v5 + 14) >= 0x14u)
            {
              id v21 = (void *)objc_claimAutoreleasedReturnValue(-[NEIKEv2SessionConfiguration remoteIdentifier](v14, "remoteIdentifier"));
              id v22 = v5[4];
              uint64_t v23 = v21;
              uint64_t v24 = v22;
              uint64_t v25 = objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
              if (v23)
              {
                if (v24)
                {
                  uint64_t v26 = sub_100129C28(v25, v24, 0);
                  uint64_t v27 = v23;
                  if (v26 && (uint64_t v28 = (void *)v26[8]) != 0LL)
                  {
                    int v57 = v24;
                    id v58 = v23;
                    id v59 = v26;
                    memset(v62, 0, sizeof(v62));
                    id v61 = 0u;
                    uint64_t v60 = 1;
                    __int128 v29 = (void *)v28[1];
                    __int128 v30 = v27;
                    id v31 = v28;
                    [v29 getUUIDBytes:&v61];

                    arc4random_buf(v62, 0x4FuLL);
                    unsigned __int8 v32 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  &v60,  96LL);
                    int v33 = objc_alloc(&OBJC_CLASS___NEIKEv2EncryptedKeyIDIdentifier);
                    int v56 = v30;
                    id v34 = (void *)objc_claimAutoreleasedReturnValue([v30 identifierData]);
                    uint64_t v35 = (void *)v59[8];
                    if (v35) {
                      id v36 = v35[2];
                    }
                    else {
                      id v36 = 0LL;
                    }
                    id v37 = v35;
                    id v38 = [v33 initWithKeyID:v32 aad:v34 key:v36];

                    uint64_t v24 = v57;
                    uint64_t v23 = v58;
                    uint64_t v26 = v59;
                    uint64_t v27 = v56;
                  }

                  else
                  {
                    id v38 = 0LL;
                  }

                  goto LABEL_64;
                }

                unsigned __int16 v50 = 0LL;
                uint64_t v51 = v23;
                id v54 = sub_100121F34();
                int IsLevelEnabled = _NRLogIsLevelEnabled(v54, 17LL);

                if (IsLevelEnabled)
                {
                  uint64_t v26 = sub_100121F34();
                  _NRLogWithArgs(v26, 17LL, "%s called with null nrUUID");
                  goto LABEL_74;
                }
              }

              else
              {
                unsigned __int16 v50 = v24;
                uint64_t v51 = 0LL;
                int v52 = sub_100121F34();
                uint64_t v53 = _NRLogIsLevelEnabled(v52, 17LL);

                if (v53)
                {
                  uint64_t v26 = sub_100121F34();
                  _NRLogWithArgs(v26, 17LL, "%s called with null serviceIdentifier");
LABEL_74:
                  id v38 = 0LL;
                  uint64_t v23 = v51;
                  uint64_t v24 = v50;
LABEL_64:

LABEL_65:
                  if (v38) {
                    -[NEIKEv2SessionConfiguration setLocalIdentifier:](v14, "setLocalIdentifier:", v38);
                  }

                  goto LABEL_37;
                }
              }

              id v38 = 0LL;
              uint64_t v23 = v51;
              uint64_t v24 = v50;
              goto LABEL_65;
            }
}

uint64_t sub_10004BD30(void *a1)
{
  id Property = a1;
  id v3 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v2, 16LL, 1);
  }
  xpc_object_t value = xpc_dictionary_get_value(Property, nrXPCKeyPacketLoggingVal);
  int v5 = (void *)objc_claimAutoreleasedReturnValue(value);
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_BOOL)
  {
    BOOL v7 = xpc_BOOL_get_value(v5);
    if (qword_1001DC868 != -1) {
      dispatch_once(&qword_1001DC868, &stru_1001AEE98);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC860, 1LL))
    {
      if (qword_1001DC868 != -1) {
        dispatch_once(&qword_1001DC868, &stru_1001AEE98);
      }
      id v8 = "Dis";
      if (v7) {
        id v8 = "En";
      }
      if (gNRPacketLoggingEnabled) {
        id v9 = "en";
      }
      else {
        id v9 = "dis";
      }
      _NRLogWithArgs( qword_1001DC860,  1LL,  "%s%.30s:%-4d %sabling packet logging (was %sabled)",  "",  "terminusdSettingsSetPacketLoggingEnabled",  122,  v8,  v9);
    }

    os_unfair_lock_lock((os_unfair_lock_t)&unk_1001DC848);
    gNRPacketLoggingEnabled = v7;
    id v10 = -[NSMutableDictionary initWithContentsOfFile:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithContentsOfFile:",  @"/var/mobile/Library/terminus/com.apple.terminus.plist");
    if (!v10) {
      id v10 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    }
    id v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v7));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v10,  "setObject:forKeyedSubscript:",  v11,  @"PacketLogging");

    LODWORD(v11) = sub_1001013AC(@"/var/mobile/Library/terminus/com.apple.terminus.plist", v10, 1);
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001DC848);
    if ((_DWORD)v11)
    {
      if (qword_1001DC868 != -1) {
        dispatch_once(&qword_1001DC868, &stru_1001AEE98);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC860, 0LL))
      {
        if (qword_1001DC868 != -1) {
          dispatch_once(&qword_1001DC868, &stru_1001AEE98);
        }
        _NRLogWithArgs(qword_1001DC860, 0LL, "%s%.30s:%-4d %sabled packet logging");
      }
    }

    else
    {
      if (qword_1001DC868 != -1) {
        dispatch_once(&qword_1001DC868, &stru_1001AEE98);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC860, 16LL))
      {
        if (qword_1001DC868 != -1) {
          dispatch_once(&qword_1001DC868, &stru_1001AEE98);
        }
        _NRLogWithArgs(qword_1001DC860, 16LL, "%s%.30s:%-4d Failed to %sable packet logging");
      }
    }

    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      id v13 = (id)qword_1001DC770;
      if (v7) {
        id v14 = "En";
      }
      else {
        id v14 = "Dis";
      }
      if (v3)
      {
        id v15 = (void *)v3[4];
        if (!v15)
        {
          id v16 = (_xpc_connection_s *)objc_getProperty(v3, v12, 8LL, 1);
          uint64_t pid = xpc_connection_get_pid(v16);
          uint64_t v18 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
          bzero(buffer, 0x400uLL);
          if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
          {
            id v19 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

            uint64_t v18 = v19;
          }

          id v20 = (void *)v3[4];
          void v3[4] = v18;

          id v15 = (void *)v3[4];
        }

        id v21 = v15;
      }

      else
      {
        id v21 = 0LL;
      }

      _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d %sabled packet logging due to request from %@",  "",  "handleSetPacketLogging",  480LL,  v14,  v21);
    }

    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v22 = (unsigned __int8 *)(id)qword_1001DC870;
    if (v22 && (int v23 = v22[10], v22, v23))
    {
      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      id v34 = v5;
      uint64_t v35 = v3;
      uint64_t v24 = (id *)(id)qword_1001DC870;
      uint64_t v25 = v24;
      if (v24)
      {
        __int128 v39 = 0u;
        __int128 v40 = 0u;
        __int128 v37 = 0u;
        __int128 v38 = 0u;
        id obj = v24[27];
        id v26 = [obj countByEnumeratingWithState:&v37 objects:buffer count:16];
        if (v26)
        {
          id v27 = v26;
          uint64_t v28 = *(void *)v38;
          do
          {
            for (uint64_t i = 0LL; i != v27; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v38 != v28) {
                objc_enumerationMutation(obj);
              }
              __int128 v30 = (void *)objc_claimAutoreleasedReturnValue( [v25[27] objectForKeyedSubscript:*(void *)(*((void *)&v37 + 1) + 8 * (void)i)]);
              if (v30)
              {
                id v31 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
                unsigned __int8 v32 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithBool:]( &OBJC_CLASS___NSNumber,  "numberWithBool:",  gNRPacketLoggingEnabled));
                -[NSMutableDictionary setObject:forKeyedSubscript:]( v31,  "setObject:forKeyedSubscript:",  v32,  @"packet-logging");

                sub_1000EFBC8((uint64_t)v30, v31);
              }
            }

            id v27 = [obj countByEnumeratingWithState:&v37 objects:buffer count:16];
          }

          while (v27);
        }
      }

      uint64_t v6 = 0LL;
      int v5 = v34;
      id v3 = v35;
    }

    else
    {
      uint64_t v6 = 0LL;
    }
  }

  else
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      _NRLogWithArgs( qword_1001DC770,  16LL,  "%s%.30s:%-4d Received an invalid type for SetPacketLogging",  "",  "handleSetPacketLogging",  472);
      uint64_t v6 = -2005LL;
    }

    else
    {
      uint64_t v6 = -2005LL;
    }
  }

  return v6;
}

uint64_t sub_10004C468(void *a1)
{
  id Property = a1;
  id v3 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v2, 16LL, 1);
  }
  xpc_object_t value = xpc_dictionary_get_value(Property, nrXPCKeyMPKLLoggingVal);
  int v5 = (void *)objc_claimAutoreleasedReturnValue(value);
  if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_BOOL)
  {
    BOOL v7 = xpc_BOOL_get_value(v5);
    if (qword_1001DC868 != -1) {
      dispatch_once(&qword_1001DC868, &stru_1001AEE98);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC860, 1LL))
    {
      if (qword_1001DC868 != -1) {
        dispatch_once(&qword_1001DC868, &stru_1001AEE98);
      }
      if (v7) {
        id v8 = "En";
      }
      else {
        id v8 = "Dis";
      }
      if (gNRMPKLLoggingEnabled) {
        id v9 = "en";
      }
      else {
        id v9 = "dis";
      }
      _NRLogWithArgs( qword_1001DC860,  1LL,  "%s%.30s:%-4d %sabling MPKL logging (was %sabled)",  "",  "terminusdSettingsSetMPKLLoggingEnabled",  142,  v8,  v9);
    }

    os_unfair_lock_lock((os_unfair_lock_t)&unk_1001DC848);
    gNRMPKLLoggingEnabled = v7;
    id v10 = -[NSMutableDictionary initWithContentsOfFile:]( objc_alloc(&OBJC_CLASS___NSMutableDictionary),  "initWithContentsOfFile:",  @"/var/mobile/Library/terminus/com.apple.terminus.plist");
    if (!v10) {
      id v10 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    }
    id v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v7));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v10, "setObject:forKeyedSubscript:", v11, @"MPKLLogging");

    LODWORD(v11) = sub_1001013AC(@"/var/mobile/Library/terminus/com.apple.terminus.plist", v10, 1);
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1001DC848);
    if ((_DWORD)v11)
    {
      if (qword_1001DC868 != -1) {
        dispatch_once(&qword_1001DC868, &stru_1001AEE98);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC860, 0LL))
      {
        if (qword_1001DC868 != -1) {
          dispatch_once(&qword_1001DC868, &stru_1001AEE98);
        }
        _NRLogWithArgs(qword_1001DC860, 0LL, "%s%.30s:%-4d %sabled MPKL logging");
      }
    }

    else
    {
      if (qword_1001DC868 != -1) {
        dispatch_once(&qword_1001DC868, &stru_1001AEE98);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC860, 16LL))
      {
        if (qword_1001DC868 != -1) {
          dispatch_once(&qword_1001DC868, &stru_1001AEE98);
        }
        _NRLogWithArgs(qword_1001DC860, 16LL, "%s%.30s:%-4d Failed to %sable MPKL logging");
      }
    }

    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v12 = (id)qword_1001DC870;
    id v13 = v12;
    if (v12)
    {
      uint64_t v14 = *((void *)v12 + 5);
      if (v14)
      {
        __int128 v33 = 0u;
        __int128 v34 = 0u;
        __int128 v31 = 0u;
        __int128 v32 = 0u;
        id v15 = *(id *)(v14 + 40);
        id v16 = [v15 countByEnumeratingWithState:&v31 objects:buffer count:16];
        if (v16)
        {
          id v17 = v16;
          uint64_t v18 = *(void *)v32;
          do
          {
            for (uint64_t i = 0LL; i != v17; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v32 != v18) {
                objc_enumerationMutation(v15);
              }
              [*(id *)(*((void *)&v31 + 1) + 8 * (void)i) virtualInterface];
            }

            id v17 = [v15 countByEnumeratingWithState:&v31 objects:buffer count:16];
          }

          while (v17);
        }
      }
    }

    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      id v21 = (id)qword_1001DC770;
      if (v7) {
        id v22 = "En";
      }
      else {
        id v22 = "Dis";
      }
      if (v3)
      {
        int v23 = (void *)v3[4];
        if (!v23)
        {
          uint64_t v24 = (_xpc_connection_s *)objc_getProperty(v3, v20, 8LL, 1);
          uint64_t pid = xpc_connection_get_pid(v24);
          id v26 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
          bzero(buffer, 0x400uLL);
          if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
          {
            id v27 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

            id v26 = v27;
          }

          uint64_t v28 = (void *)v3[4];
          void v3[4] = v26;

          int v23 = (void *)v3[4];
        }

        id v29 = v23;
      }

      else
      {
        id v29 = 0LL;
      }

      _NRLogWithArgs( v21,  0LL,  "%s%.30s:%-4d %sabled MPKL logging due to request from %@",  "",  "handleSetMPKLLogging",  501LL,  v22,  v29);
    }

    uint64_t v6 = 0LL;
  }

  else
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      _NRLogWithArgs( qword_1001DC770,  16LL,  "%s%.30s:%-4d Received an invalid type for SetMPKLLogging",  "",  "handleSetMPKLLogging",  493);
      uint64_t v6 = -2005LL;
    }

    else
    {
      uint64_t v6 = -2005LL;
    }
  }

  return v6;
}

uint64_t sub_10004CAE4(void *a1)
{
  id Property = a1;
  int v5 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v4, 16LL, 1);
  }
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyBluetoothUUID);
  if (!uuid)
  {
    id v38 = sub_10004579C();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v38, 16LL);

    if (!IsLevelEnabled) {
      goto LABEL_20;
    }
    id v9 = sub_10004579C();
    id v16 = sub_10004580C(v5, v40);
    _NRLogWithArgs( v9,  16LL,  "%s%.30s:%-4d Missing BluetoothUUID from %@",  "",  "handleCompanionLinkCopyNRUUIDForBluetoothUUID",  519LL,  v16);
LABEL_19:

LABEL_20:
    uint64_t v17 = -2005LL;
    goto LABEL_41;
  }

  BOOL v7 = uuid;
  if (uuid_is_null(uuid))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v9 = (id)qword_1001DC770;
    if (v5)
    {
      id v10 = (void *)v5[4];
      if (!v10)
      {
        id v11 = (_xpc_connection_s *)objc_getProperty(v5, v8, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(v11);
        id v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(v52, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, v52, 0x400u) >= 1 && v52[0])
        {
          uint64_t v14 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v52,  pid);

          id v13 = v14;
        }

        id v15 = (void *)v5[4];
        void v5[4] = v13;

        id v10 = (void *)v5[4];
      }

      id v16 = v10;
    }

    else
    {
      id v16 = 0LL;
    }

    _NRLogWithArgs( v9,  16LL,  "%s%.30s:%-4d All-zero BluetoothUUID from %@",  "",  "handleCompanionLinkCopyNRUUIDForBluetoothUUID",  523LL,  v16);
    goto LABEL_19;
  }

  uint64_t v18 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v7);
  if (!v18)
  {
    id v41 = sub_10004579C();
    int v42 = _NRLogIsLevelEnabled(v41, 16LL);

    if (v42)
    {
      id v43 = sub_10004579C();
      _NRLogWithArgs( v43,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (bluetoothUUID) != ((void *)0)",  "",  "handleCompanionLinkCopyNRUUIDForBluetoothUUID",  527);
    }

    int v5 = (void *)_os_log_pack_size(12LL);
    id v22 = &v52[-((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
    uint64_t v44 = *__error();
    uint64_t v45 = _os_log_pack_fill( v22,  v5,  v44,  &_mh_execute_header,  "%{public}s Assertion Failed: (bluetoothUUID) != ((void *)0)");
    goto LABEL_50;
  }

  id v19 = v18;
  uint64_t v20 = objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
  id v21 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v21);

  id v22 = v19;
  objc_opt_self(v20);
  p_class_meths = sub_10012E648((uint64_t)&OBJC_CLASS___NRDLocalDevice, v22);

  if (p_class_meths) {
    int v23 = (void *)p_class_meths[4];
  }
  else {
    int v23 = 0LL;
  }
  id v1 = v23;

  if (!v1)
  {
    id v46 = sub_10004579C();
    int v47 = _NRLogIsLevelEnabled(v46, 16LL);

    if (v47)
    {
      id v48 = sub_10004579C();
      _NRLogWithArgs( v48,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "handleCompanionLinkCopyNRUUIDForBluetoothUUID",  529);
    }

    int v5 = (void *)_os_log_pack_size(12LL);
    id v22 = &v52[-((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
    uint64_t v49 = *__error();
    uint64_t v45 = _os_log_pack_fill(v22, v5, v49, &_mh_execute_header, "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
LABEL_50:
    *(_DWORD *)uint64_t v45 = 136446210;
    *(void *)(v45 + 4) = "handleCompanionLinkCopyNRUUIDForBluetoothUUID";
    id v50 = sub_10004579C();
    _NRLogAbortWithPack(v50, v22);
    goto LABEL_51;
  }

  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  if (qword_1001DC778 != -1) {
LABEL_51:
  }
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (p_class_meths[239] != -1LL) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v25 = (id)qword_1001DC770;
    if (v5)
    {
      id v26 = (void *)v5[4];
      if (!v26)
      {
        id v27 = (_xpc_connection_s *)objc_getProperty(v5, v24, 8LL, 1);
        uint64_t v28 = xpc_connection_get_pid(v27);
        id v29 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v28);
        bzero(v52, 0x400uLL);
        if ((int)v28 >= 1 && proc_pidpath(v28, v52, 0x400u) >= 1 && v52[0])
        {
          __int128 v30 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v52,  v28);

          id v29 = v30;
        }

        __int128 v31 = (void *)v5[4];
        void v5[4] = v29;

        id v26 = (void *)v5[4];
      }

      id v32 = v26;
    }

    else
    {
      id v32 = 0LL;
    }

    __int128 v33 = (void *)objc_claimAutoreleasedReturnValue([v22 UUIDString]);
    __int128 v34 = (void *)objc_claimAutoreleasedReturnValue([v1 UUIDString]);
    _NRLogWithArgs( v25,  0LL,  "%s%.30s:%-4d Informing %@ that BTUUID %@ maps to NRUUID %@",  "",  "handleCompanionLinkCopyNRUUIDForBluetoothUUID",  531LL,  v32,  v33,  v34);
  }

  [v1 getUUIDBytes:v52];
  if (v5) {
    id v36 = objc_getProperty(v5, v35, 24LL, 1);
  }
  else {
    id v36 = 0LL;
  }
  xpc_dictionary_set_uuid(v36, nrXPCKeyNRUUID, v52);

  uint64_t v17 = 0LL;
LABEL_41:

  return v17;
}

uint64_t sub_10004D164(void *a1)
{
  id Property = a1;
  id v4 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v3, 16LL, 1);
  }
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyNRUUID);
  if (!uuid)
  {
    id v44 = sub_10004579C();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v44, 16LL);

    if (IsLevelEnabled)
    {
      id v8 = (__objc2_meth_list *)sub_10004579C();
      id v15 = sub_10004580C(v4, v46);
      _NRLogWithArgs( v8,  16LL,  "%s%.30s:%-4d Missing nrUUID from %@",  "",  "handleCompanionLinkCopyBluetoothUUIDForNRUUID",  542LL,  v15);
LABEL_18:

      uint64_t v16 = -2005LL;
      goto LABEL_57;
    }

    goto LABEL_56;
  }

  uint64_t v6 = uuid;
  if (uuid_is_null(uuid))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
    {
      if (qword_1001DC778 == -1)
      {
LABEL_9:
        id v8 = p_class_meths[238];
        if (v4)
        {
          id v9 = (void *)v4[4];
          if (!v9)
          {
            id v10 = (_xpc_connection_s *)objc_getProperty(v4, v7, 8LL, 1);
            uint64_t pid = xpc_connection_get_pid(v10);
            id v12 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
            bzero(v56, 0x400uLL);
            if ((int)pid >= 1 && proc_pidpath(pid, v56, 0x400u) >= 1 && LOBYTE(v56[0]))
            {
              id v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v56,  pid);

              id v12 = v13;
            }

            uint64_t v14 = (void *)v4[4];
            v4[4] = v12;

            id v9 = (void *)v4[4];
          }

          id v15 = v9;
        }

        else
        {
          id v15 = 0LL;
        }

        _NRLogWithArgs( v8,  16LL,  "%s%.30s:%-4d All-zero nrUUID from %@",  "",  "handleCompanionLinkCopyBluetoothUUIDForNRUUID",  546LL,  v15);
        goto LABEL_18;
      }

uint64_t sub_10004D880(void *a1)
{
  id Property = a1;
  id v4 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v3, 16LL, 1);
  }
  string = xpc_dictionary_get_string(Property, nrXPCKeyIDSDeviceID);
  if (!string)
  {
    id v47 = sub_10004579C();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v47, 16LL);

    if (!IsLevelEnabled) {
      goto LABEL_46;
    }
    id v29 = sub_10004579C();
    id v36 = sub_10004580C(v4, v49);
    _NRLogWithArgs( v29,  16LL,  "%s%.30s:%-4d Missing idsDeviceIDString from %@",  "",  "handleCompanionLinkCopyNRUUIDForIDSDeviceID",  570LL,  v36);
    goto LABEL_45;
  }

  BOOL v7 = string;
  if (*string)
  {
    if (v4) {
      id v8 = objc_getProperty(v4, v6, 16LL, 1);
    }
    else {
      id v8 = 0LL;
    }
    p_class_meths = (__objc2_meth_list **)xpc_dictionary_get_BOOL(v8, nrXPCKeyShouldCreateDevice);
    id v10 = (unsigned __int8 *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v7));
    if (v10)
    {
      id v11 = v10;
      id v12 = sub_10012EA10((uint64_t)&OBJC_CLASS___NRDLocalDevice, v10, (int)p_class_meths);
      id v1 = v12;
      if (v12) {
        char v13 = 1;
      }
      else {
        char v13 = (char)p_class_meths;
      }
      if ((v13 & 1) == 0)
      {
        p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
        if (qword_1001DC778 == -1)
        {
LABEL_48:
          if (!_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
          {
LABEL_61:

            uint64_t v37 = 0LL;
            goto LABEL_62;
          }

          if (p_class_meths[239] != (__objc2_meth_list *)-1LL) {
            dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
          }
          id v15 = (id)qword_1001DC770;
          if (v4)
          {
            uint64_t v39 = (void *)v4[4];
            if (!v39)
            {
              __int128 v40 = (_xpc_connection_s *)objc_getProperty(v4, v38, 8LL, 1);
              uint64_t pid = xpc_connection_get_pid(v40);
              int v42 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
              bzero(v61, 0x400uLL);
              if ((int)pid >= 1 && proc_pidpath(pid, v61, 0x400u) >= 1 && v61[0])
              {
                id v43 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v61,  pid);

                int v42 = v43;
              }

              id v44 = (void *)v4[4];
              v4[4] = v42;

              uint64_t v39 = (void *)v4[4];
            }

            id v45 = v39;
          }

          else
          {
            id v45 = 0LL;
          }

          _NRLogWithArgs( v15,  0LL,  "%s%.30s:%-4d Informing %@ that IDSDeviceID %@ does not map to any known device",  "",  "handleCompanionLinkCopyNRUUIDForIDSDeviceID",  584LL,  v45,  v11);

LABEL_60:
          goto LABEL_61;
        }

LABEL_72:
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        goto LABEL_48;
      }

      if (v12)
      {
        id v14 = *((id *)v12 + 4);
        if (v14)
        {
          id v15 = v14;
          if (qword_1001DC778 != -1) {
            dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
          {
            if (qword_1001DC778 != -1) {
              dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
            }
            id v17 = (id)qword_1001DC770;
            if (v4)
            {
              uint64_t v18 = (void *)v4[4];
              if (!v18)
              {
                id v19 = (_xpc_connection_s *)objc_getProperty(v4, v16, 8LL, 1);
                uint64_t v20 = xpc_connection_get_pid(v19);
                id v21 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v20);
                bzero(v61, 0x400uLL);
                if ((int)v20 >= 1 && proc_pidpath(v20, v61, 0x400u) >= 1 && v61[0])
                {
                  id v22 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v61,  v20);

                  id v21 = v22;
                }

                id v23 = (void *)v4[4];
                v4[4] = v21;

                uint64_t v18 = (void *)v4[4];
              }

              id v24 = v18;
            }

            else
            {
              id v24 = 0LL;
            }

            id v25 = (void *)objc_claimAutoreleasedReturnValue([v15 UUIDString]);
            _NRLogWithArgs( v17,  0LL,  "%s%.30s:%-4d Informing %@ that IDSDeviceID %@ maps to NRUUID %@",  "",  "handleCompanionLinkCopyNRUUIDForIDSDeviceID",  591LL,  v24,  v11,  v25);
          }

          [v15 getUUIDBytes:v61];
          if (v4) {
            id v27 = objc_getProperty(v4, v26, 24LL, 1);
          }
          else {
            id v27 = 0LL;
          }
          xpc_dictionary_set_uuid(v27, nrXPCKeyNRUUID, v61);
          goto LABEL_60;
        }
      }

      id v55 = sub_10004579C();
      int v56 = _NRLogIsLevelEnabled(v55, 16LL);

      if (v56)
      {
        id v57 = sub_10004579C();
        _NRLogWithArgs( v57,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "handleCompanionLinkCopyNRUUIDForIDSDeviceID",  589);
      }

      id v4 = (void *)_os_log_pack_size(12LL);
      id v11 = &v61[-((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
      uint64_t v58 = *__error();
      uint64_t v54 = _os_log_pack_fill(v11, v4, v58, &_mh_execute_header, "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    }

    else
    {
      id v50 = sub_10004579C();
      int v51 = _NRLogIsLevelEnabled(v50, 16LL);

      if (v51)
      {
        id v52 = sub_10004579C();
        _NRLogWithArgs( v52,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (idsDeviceID) != ((void *)0)",  "",  "handleCompanionLinkCopyNRUUIDForIDSDeviceID",  579);
      }

      id v4 = (void *)_os_log_pack_size(12LL);
      id v11 = &v61[-((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL) - 8];
      uint64_t v53 = *__error();
      uint64_t v54 = _os_log_pack_fill( v11,  v4,  v53,  &_mh_execute_header,  "%{public}s Assertion Failed: (idsDeviceID) != ((void *)0)");
    }

    *(_DWORD *)uint64_t v54 = 136446210;
    *(void *)(v54 + 4) = "handleCompanionLinkCopyNRUUIDForIDSDeviceID";
    id v59 = sub_10004579C();
    _NRLogAbortWithPack(v59, v11);
    goto LABEL_72;
  }

  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v29 = (id)qword_1001DC770;
    if (v4)
    {
      id v30 = (void *)v4[4];
      if (!v30)
      {
        __int128 v31 = (_xpc_connection_s *)objc_getProperty(v4, v28, 8LL, 1);
        uint64_t v32 = xpc_connection_get_pid(v31);
        __int128 v33 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v32);
        bzero(v61, 0x400uLL);
        if ((int)v32 >= 1 && proc_pidpath(v32, v61, 0x400u) >= 1 && v61[0])
        {
          id v34 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v61,  v32);

          __int128 v33 = v34;
        }

        uint64_t v35 = (void *)v4[4];
        v4[4] = v33;

        id v30 = (void *)v4[4];
      }

      id v36 = v30;
    }

    else
    {
      id v36 = 0LL;
    }

    _NRLogWithArgs( v29,  16LL,  "%s%.30s:%-4d Empty idsDeviceIDString from %@",  "",  "handleCompanionLinkCopyNRUUIDForIDSDeviceID",  574LL,  v36);
LABEL_45:
  }

    uint64_t v82 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v79);
    int v83 = _NRLogIsLevelEnabled(v82, 0LL);

    if (v83)
    {
      uint64_t v85 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 24), v84);
      _NRLogWithArgs( v85,  0LL,  "%s%.30s:%-4d discovered valid advertisement data",  "",  "-[NRDiscoveryClient addDiscoveredDeviceIfApplicable:endpoint:serviceName:psk:idsDeviceID:peerIdentity:selfIdentity:]",  1087);
    }

    goto LABEL_74;
  }

              if (++v35 >= (unint64_t)v34)
              {
                id v34 = [v33 countByEnumeratingWithState:&v194 objects:v212 count:16];
                if (!v34) {
                  break;
                }
                uint64_t v35 = 0LL;
              }
            }
          }
        }

        id v50 = v177;
        if (v177) {
          id v50 = (id *)v177[5];
        }
        int v51 = v50;
        id v52 = -[__CFArray containsObject:](keys, "containsObject:", v51);

        if (v52)
        {
          if (v177)
          {
            uint64_t v53 = v177[8];
            [v53 removeAllObjects];

            uint64_t v54 = v177[5];
          }

          else
          {
            [0 removeAllObjects];
            uint64_t v54 = 0LL;
          }

          id v55 = v54;
          int v56 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKeyedSubscript:](v170, "objectForKeyedSubscript:", v55));

          toa = (id *)objc_claimAutoreleasedReturnValue([v56 objectForKeyedSubscript:kSCPropNetIPv6Addresses]);
          uint64_t v173 = (void *)objc_claimAutoreleasedReturnValue([v56 objectForKeyedSubscript:kSCPropNetIPv6Flags]);
          id v57 = [toa count];
          if (v57 != [v173 count])
          {
            if (qword_1001DCBF8 != -1) {
              dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
            }
            uint64_t v79 = (id)qword_1001DCBF0;
            int v80 = _NRLogIsLevelEnabled(v79, 17LL);

            if (v80)
            {
              if (qword_1001DCBF8 != -1) {
                dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
              }
              int v81 = (id)qword_1001DCBF0;
              _NRLogWithArgs(v81, 17LL, "Mismatch between ipv6 address and flags array: %@ %@", toa, v173);
            }

            goto LABEL_161;
          }

          uint64_t v58 = [toa count];
          if (v58)
          {
            id v59 = 0LL;
            while (1)
            {
              uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue([v173 objectAtIndexedSubscript:v59]);
              id v61 = (NSString *)objc_claimAutoreleasedReturnValue([toa objectAtIndexedSubscript:v59]);
              uint64_t v62 = [v60 unsignedIntValue];
              if (((unsigned __int16)v62 & 0x101F) != 0)
              {
                if (qword_1001DCBF8 != -1) {
                  dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                }
                uint64_t v63 = (id)qword_1001DCBF0;
                id v64 = _NRLogIsLevelEnabled(v63, 1LL);

                if (v64)
                {
                  if (qword_1001DCBF8 != -1) {
                    dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
                  }
                  uint64_t v65 = (id)qword_1001DCBF0;
                  _NRLogWithArgs( v65,  1LL,  "%s%.30s:%-4d Ignoring ipv6 address: %@ (%#x)",  "",  "-[NRLinkManagerWiFi processSCDUpdate:]",  2357LL,  v61,  v62);
                }

                goto LABEL_127;
              }

              if (inet_pton(30, -[NSString UTF8String](v61, "UTF8String"), &v216) == 1) {
                break;
              }
LABEL_127:

              if (v58 == (id)++v59) {
                goto LABEL_142;
              }
            }

            uint64_t v66 = v216 | HIDWORD(v216) | v217;
            if (!v66 && !HIDWORD(v217)
              || (HIDWORD(v217) == 0x1000000 ? (uint64_t v70 = v66 == 0) : (uint64_t v70 = 0), v70 || v216 == 255))
            {
              if (qword_1001DCBF8 != -1) {
                dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
              }
              uint64_t v67 = (id)qword_1001DCBF0;
              id v68 = _NRLogIsLevelEnabled(v67, 1LL);

              if (!v68) {
                goto LABEL_127;
              }
              if (qword_1001DCBF8 != -1) {
                dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
              }
              int v69 = (id *)(id)qword_1001DCBF0;
              _NRLogWithArgs( v69,  1LL,  "%s%.30s:%-4d Ignoring ipv6 address: %@",  "",  "-[NRLinkManagerWiFi processSCDUpdate:]",  2368LL,  v61);
            }

            else
            {
              if ((v216 & 0xC0FF) != 0x80FE)
              {
                id v76 = v177;
                if (v177) {
                  goto LABEL_124;
                }
                goto LABEL_125;
              }

              if (v177 && *((_BYTE *)v177 + 8))
              {
                uint64_t v71 = v177[3];
                id v72 = -[NSString containsString:](v61, "containsString:", v71);

                if ((v72 & 1) == 0)
                {
                  uint64_t v73 = objc_alloc(&OBJC_CLASS___NSString);
                  uint64_t v74 = v177[3];
                  int v75 = -[NSString initWithFormat:](v73, "initWithFormat:", @"%@%%%@", v61, v74);

                  id v61 = v75;
                }

uint64_t sub_10004E05C(void *a1)
{
  id v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v4 = (id)qword_1001DC770;
    if (v1)
    {
      int v5 = (void *)v1[4];
      if (!v5)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v3, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v9 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v8 = v9;
        }

        id v10 = (void *)v1[4];
        v1[4] = v8;

        int v5 = (void *)v1[4];
      }

      id v11 = v5;
    }

    else
    {
      id v11 = 0LL;
    }

    _NRLogWithArgs( v4,  0LL,  "%s%.30s:%-4d Informing %@ that the networkrelay version is %u",  "",  "handleCompanionLinkGetNetworkRelayVersion",  510LL,  v11,  22LL);
  }

  if (v1) {
    id v12 = objc_getProperty(v1, v2, 24LL, 1);
  }
  else {
    id v12 = 0LL;
  }
  xpc_dictionary_set_uint64(v12, nrXPCKeyNetworkRelayVersion, 0x16uLL);

  return 0LL;
}

uint64_t sub_10004E264(void *a1)
{
  id v1 = a1;
  id v2 = sub_100131EA8((uint64_t)&OBJC_CLASS___NRDLocalDevice);
  if (v2)
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      id v4 = (id)qword_1001DC770;
      if (v1)
      {
        int v5 = (void *)v1[4];
        if (!v5)
        {
          id Property = (_xpc_connection_s *)objc_getProperty(v1, v3, 8LL, 1);
          uint64_t pid = xpc_connection_get_pid(Property);
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
          bzero(buffer, 0x400uLL);
          if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
          {
            id v9 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

            id v8 = v9;
          }

          id v10 = (void *)v1[4];
          v1[4] = v8;

          int v5 = (void *)v1[4];
        }

        id v11 = v5;
      }

      else
      {
        id v11 = 0LL;
      }

      id v12 = (void *)objc_claimAutoreleasedReturnValue([v2 UUIDString]);
      _NRLogWithArgs( v4,  0LL,  "%s%.30s:%-4d Informing %@ that best testing NRUUID is %@",  "",  "handleCompanionLinkCopyBestTestingNRUUID",  606LL,  v11,  v12);
    }

    [v2 getUUIDBytes:buffer];
    if (v1) {
      id v14 = objc_getProperty(v1, v13, 24LL, 1);
    }
    else {
      id v14 = 0LL;
    }
    xpc_dictionary_set_uuid(v14, nrXPCKeyNRUUID, buffer);
    uint64_t v15 = 0LL;
  }

  else
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      id v17 = (id)qword_1001DC770;
      if (v1)
      {
        uint64_t v18 = (void *)v1[4];
        if (!v18)
        {
          id v19 = (_xpc_connection_s *)objc_getProperty(v1, v16, 8LL, 1);
          uint64_t v20 = xpc_connection_get_pid(v19);
          id v21 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v20);
          bzero(buffer, 0x400uLL);
          if ((int)v20 >= 1 && proc_pidpath(v20, buffer, 0x400u) >= 1 && buffer[0])
          {
            id v22 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  v20);

            id v21 = v22;
          }

          id v23 = (void *)v1[4];
          v1[4] = v21;

          uint64_t v18 = (void *)v1[4];
        }

        id v24 = v18;
      }

      else
      {
        id v24 = 0LL;
      }

      _NRLogWithArgs( v17,  0LL,  "%s%.30s:%-4d Could not find a best test device for %@",  "",  "handleCompanionLinkCopyBestTestingNRUUID",  603LL,  v24);
    }

    uint64_t v15 = -2011LL;
  }

  return v15;
}

uint64_t sub_10004E60C(void *a1)
{
  id Property = a1;
  BOOL v7 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v6, 16LL, 1);
  }
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyNRUUID);
  if (uuid)
  {
    id v9 = uuid;
    if (uuid_is_null(uuid))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
      {
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        id v11 = (id)qword_1001DC770;
        if (v7)
        {
          id v12 = (void *)v7[4];
          if (!v12)
          {
            char v13 = (_xpc_connection_s *)objc_getProperty(v7, v10, 8LL, 1);
            uint64_t pid = xpc_connection_get_pid(v13);
            uint64_t v15 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
            bzero(v160, 0x400uLL);
            if ((int)pid >= 1 && proc_pidpath(pid, v160, 0x400u) >= 1 && LOBYTE(v160[0]))
            {
              uint64_t v16 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v160,  pid);

              uint64_t v15 = v16;
            }

            id v17 = (void *)v7[4];
            v7[4] = v15;

            id v12 = (void *)v7[4];
          }

          id v18 = v12;
        }

        else
        {
          id v18 = 0LL;
        }

        _NRLogWithArgs( v11,  16LL,  "%s%.30s:%-4d All-zero NRUUID from %@",  "",  "handleRegisterDeviceByNRUUID",  621LL,  v18);
        goto LABEL_19;
      }

LABEL_142:
      uint64_t v19 = -2005LL;
      goto LABEL_143;
    }

    uint64_t v20 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v9);
    if (!v20)
    {
      id v126 = sub_10004579C();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v126, 16LL);

      if (IsLevelEnabled)
      {
        id v128 = sub_10004579C();
        _NRLogWithArgs( v128,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "handleRegisterDeviceByNRUUID",  625);
      }

      BOOL v7 = (void *)_os_log_pack_size(12LL);
      id v76 = (char *)v142 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v129 = *__error();
      uint64_t v130 = _os_log_pack_fill( v76,  v7,  v129,  &_mh_execute_header,  "%{public}s Assertion Failed: (nrUUID) != ((void *)0)",  v142[0]);
      goto LABEL_155;
    }

    id v21 = v20;
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      id v24 = (id)qword_1001DC770;
      if (v7)
      {
        id v25 = (void *)v7[4];
        if (!v25)
        {
          uint64_t v26 = (_xpc_connection_s *)objc_getProperty(v7, v23, 8LL, 1);
          uint64_t v27 = xpc_connection_get_pid(v26);
          uint64_t v28 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v27);
          bzero(v160, 0x400uLL);
          if ((int)v27 >= 1 && proc_pidpath(v27, v160, 0x400u) >= 1 && LOBYTE(v160[0]))
          {
            id v29 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v160,  v27);

            uint64_t v28 = v29;
          }

          id v30 = (void *)v7[4];
          v7[4] = v28;

          id v25 = (void *)v7[4];
        }

        id v31 = v25;
      }

      else
      {
        id v31 = 0LL;
      }

      uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue(-[NSUUID UUIDString](v21, "UUIDString"));
      _NRLogWithArgs( v24,  0LL,  "%s%.30s:%-4d Client %@ registering %@",  "",  "handleRegisterDeviceByNRUUID",  626LL,  v31,  v32);
    }

    if (v7) {
      id v33 = objc_getProperty(v7, v22, 16LL, 1);
    }
    else {
      id v33 = 0LL;
    }
    int64_t int64 = xpc_dictionary_get_int64(v33, nrXPCKeyPairingProtocolVersion);
    if (v7) {
      id v35 = objc_getProperty(v7, v34, 16LL, 1);
    }
    else {
      id v35 = 0LL;
    }
    uint64_t uint64 = xpc_dictionary_get_uint64(v35, nrXPCKeyPeerNetworkRelayVersion);
    uint64_t v38 = uint64;
    if (uint64 < 0x10000)
    {
      int v40 = uint64;
    }

    else
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      int v39 = _NRLogIsLevelEnabled(qword_1001DC770, 0LL);
      int v40 = 0;
      if (v39)
      {
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        _NRLogWithArgs( qword_1001DC770,  0LL,  "%s%.30s:%-4d ignoring invalid peer version %llu",  "",  "handleRegisterDeviceByNRUUID",  632,  v38);
        int v40 = 0;
      }
    }

    int v147 = v40;
    if (v7) {
      id v41 = objc_getProperty(v7, v37, 16LL, 1);
    }
    else {
      id v41 = 0LL;
    }
    unsigned int v146 = xpc_dictionary_get_BOOL(v41, nrXPCKeyWasInitiallySetupUsingIDSPairing);
    v160[0] = 0LL;
    v150 = v21;
    if (v7) {
      id v43 = objc_getProperty(v7, v42, 16LL, 1);
    }
    else {
      id v43 = 0LL;
    }
    data = xpc_dictionary_get_data(v43, nrXPCKeyOutOfBandKey, v160);
    if (data)
    {
      id v2 = +[NSData _newZeroingDataWithBytes:length:]( &OBJC_CLASS___NSData,  "_newZeroingDataWithBytes:length:",  data,  v160[0]);
      if (v7)
      {
LABEL_53:
        id v46 = objc_getProperty(v7, v45, 16LL, 1);
        goto LABEL_54;
      }
    }

    else
    {
      id v2 = 0LL;
      if (v7) {
        goto LABEL_53;
      }
    }

    id v46 = 0LL;
LABEL_54:
    BOOL v48 = xpc_dictionary_get_BOOL(v46, nrXPCKeyPairWithSPPLink);
    if (v7) {
      id v49 = objc_getProperty(v7, v47, 16LL, 1);
    }
    else {
      id v49 = 0LL;
    }
    BOOL v51 = xpc_dictionary_get_BOOL(v49, nrXPCKeyIsAltAccountPairing);
    size_t v159 = 0LL;
    if (v7) {
      id v52 = objc_getProperty(v7, v50, 16LL, 1);
    }
    else {
      id v52 = 0LL;
    }
    uint64_t v53 = xpc_dictionary_get_data(v52, nrXPCKeyRemoteDeviceMACAddress, &v159);
    if (v53)
    {
      uint64_t v54 = v53;
      id v55 = objc_alloc(&OBJC_CLASS___NSData);
      __int128 v151 = -[NSData initWithBytes:length:](v55, "initWithBytes:length:", v54, v159);
    }

    else
    {
      __int128 v151 = 0LL;
    }

    v157[0] = _NSConcreteStackBlock;
    v157[1] = 3221225472LL;
    v157[2] = sub_100059810;
    v157[3] = &unk_1001AF078;
    id v1 = v7;
    id v158 = v1;
    int v56 = objc_retainBlock(v157);
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v57 = (unsigned __int8 *)(id)qword_1001DC870;
    if (v57)
    {
      int v59 = v57[8];

      if (v59)
      {
        id v131 = sub_10004579C();
        int v132 = _NRLogIsLevelEnabled(v131, 16LL);

        id v4 = v150;
        if (v132)
        {
          id v133 = sub_10004579C();
          _NRLogWithArgs( v133,  16LL,  "%s%.30s:%-4d Pairing was attempted while in fixed interface mode for NRUUID %@",  "",  "handleRegisterDeviceByNRUUID",  667LL,  v150);
        }

        ((void (*)(void *, uint64_t, const __CFString *))v56[2])( v56,  -2016LL,  @"Pairing was attempted while in fixed interface mode");
        int v87 = v151;
        goto LABEL_112;
      }
    }

    __int128 v153 = (void (**)(void, uint64_t, const __CFString *))v56;
    BOOL v144 = v51;
    BOOL v145 = v48;
    if (v7) {
      id v60 = objc_getProperty(v1, v58, 16LL, 1);
    }
    else {
      id v60 = 0LL;
    }
    xpc_object_t value = xpc_dictionary_get_value(v60, nrXPCKeyOperationalPropData);
    uint64_t v62 = (void *)objc_claimAutoreleasedReturnValue(value);
    id v149 = v62;
    if (!v62 || (uint64_t v63 = v62, xpc_get_type(v62) != (xpc_type_t)&_xpc_type_data))
    {
      id v64 = 0LL;
      goto LABEL_72;
    }

    id v89 = objc_alloc(&OBJC_CLASS___NSData);
    bytes_ptr = xpc_data_get_bytes_ptr(v63);
    id v3 = -[NSData initWithBytes:length:](v89, "initWithBytes:length:", bytes_ptr, xpc_data_get_length(v63));
    id v156 = 0LL;
    id v91 = +[NSKeyedUnarchiver unarchivedObjectOfClass:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClass:fromData:error:",  objc_opt_class(&OBJC_CLASS___NRDeviceOperationalProperties),  v3,  &v156);
    id v92 = (void *)objc_claimAutoreleasedReturnValue(v91);
    id v152 = v156;
    if (v92
      && (uint64_t v93 = objc_opt_class(&OBJC_CLASS___NRDeviceOperationalProperties), (objc_opt_isKindOfClass(v92, v93) & 1) != 0)
      && !v152)
    {
      uint64_t v94 = v92;
      NSUInteger v95 = (void *)objc_claimAutoreleasedReturnValue([v92 allowedLinkTypes]);
      __int128 v154 = v94;
      if ([v95 count])
      {
LABEL_102:

LABEL_130:
        id v64 = v154;
LABEL_72:
        sub_100105340(v64);
        if (v7) {
          id v66 = objc_getProperty(v1, v65, 16LL, 1);
        }
        else {
          id v66 = 0LL;
        }
        xpc_object_t v67 = xpc_dictionary_get_value(v66, nrXPCKeyPeerIPAddressData);
        id v68 = (void *)objc_claimAutoreleasedReturnValue(v67);
        __int128 v154 = v64;
        id v152 = v68;
        if (v68 && (uint64_t v70 = v68, xpc_get_type(v68) == (xpc_type_t)&_xpc_type_data))
        {
          id v143 = v2;
          id v96 = objc_alloc(&OBJC_CLASS___NSData);
          id v97 = xpc_data_get_bytes_ptr(v70);
          id v88 = -[NSData initWithBytes:length:](v96, "initWithBytes:length:", v97, xpc_data_get_length(v70));
          v142[1] = &OBJC_CLASS___NSSet;
          v142[0] = objc_opt_class(&OBJC_CLASS___NSDictionary);
          uint64_t v98 = objc_opt_class(&OBJC_CLASS___NSArray);
          uint64_t v99 = objc_opt_class(&OBJC_CLASS___NSUUID);
          uint64_t v100 = objc_opt_class(&OBJC_CLASS___NSData);
          uint64_t v101 = objc_opt_class(&OBJC_CLASS___NSDate);
          uint64_t v102 = objc_opt_class(&OBJC_CLASS___NSNumber);
          uint64_t v103 = objc_opt_class(&OBJC_CLASS___NSString);
          uint64_t v104 = +[NSSet setWithObjects:]( &OBJC_CLASS___NSSet,  "setWithObjects:",  v142[0],  v98,  v99,  v100,  v101,  v102,  v103,  objc_opt_class(&OBJC_CLASS___NWAddressEndpoint),  0LL);
          id v105 = (void *)objc_claimAutoreleasedReturnValue(v104);
          id v155 = 0LL;
          id v3 = (NSData *)objc_claimAutoreleasedReturnValue( +[NSKeyedUnarchiver unarchivedObjectOfClasses:fromData:error:]( &OBJC_CLASS___NSKeyedUnarchiver,  "unarchivedObjectOfClasses:fromData:error:",  v105,  v88,  &v155));
          id v86 = v155;
          if (!v3
            || (uint64_t v106 = objc_opt_class(&OBJC_CLASS___NSDictionary), (objc_opt_isKindOfClass(v3, v106) & 1) == 0)
            || v86)
          {
            id v4 = v150;
            int v56 = v153;
            if (qword_1001DC778 != -1) {
              dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
            }
            int v87 = v151;
            if (_NRLogIsLevelEnabled(qword_1001DC770, 17LL))
            {
              if (qword_1001DC778 != -1) {
                dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
              }
              _NRLogWithArgs(qword_1001DC770, 17LL, "Failed to unarchive peer IP properties %@", v86);
            }

            v153[2](v153, -2005LL, @"Failed to unarchive peer IP properties");

            id v2 = v143;
            goto LABEL_110;
          }

          id v4 = v150;
          id v2 = v143;
          if (v7) {
            goto LABEL_77;
          }
        }

        else
        {
          id v3 = 0LL;
          id v4 = v150;
          if (v7)
          {
LABEL_77:
            id v71 = objc_getProperty(v1, v69, 16LL, 1);
LABEL_78:
            int v56 = v153;
            if (!xpc_dictionary_get_BOOL(v71, nrXPCKeyIsEphemeral))
            {
LABEL_93:
              if (v7) {
                id v83 = objc_getProperty(v1, v72, 16LL, 1);
              }
              else {
                id v83 = 0LL;
              }
              xpc_object_t v84 = xpc_dictionary_get_value(v83, nrXPCKeyCandidateService);
              uint64_t v85 = (void *)objc_claimAutoreleasedReturnValue(v84);
              id v86 = v85;
              int v87 = v151;
              if (v85 && xpc_get_type(v85) == (xpc_type_t)&_xpc_type_string)
              {
                string_ptr = xpc_string_get_string_ptr(v86);
                int v87 = v151;
                id v88 = (NSData *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  string_ptr));
              }

              else
              {
                id v88 = 0LL;
              }

              sub_10012ED8C( (uint64_t)&OBJC_CLASS___NRDLocalDevice,  v4,  int64,  (unsigned __int16)v147,  v146,  v2,  (void *)v145,  v144,  v87,  v154,  v3,  v88,  v56);
LABEL_110:

              id v92 = v154;
LABEL_111:

LABEL_112:
              uint64_t v19 = -2000LL;
              goto LABEL_143;
            }

            uint64_t v73 = v4;
            uint64_t v74 = objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
            if ((_NRIsUUIDNonZero(v73) & 1) != 0)
            {
              int v75 = sub_100146AFC();
              dispatch_assert_queue_V2((dispatch_queue_t)v75);

              sub_100127AFC(v74);
              id v76 = (char *)objc_claimAutoreleasedReturnValue([(id)qword_1001DCB78 objectForKeyedSubscript:v73]);
              if (v76) {
                goto LABEL_89;
              }
              if (qword_1001DCBD8 != -1) {
                dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
              }
              if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
              {
                if (qword_1001DCBD8 != -1) {
                  dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
                }
                id v77 = (id)qword_1001DCBD0;
                id v78 = (void *)objc_claimAutoreleasedReturnValue(-[NSUUID UUIDString](v73, "UUIDString"));
                _NRLogWithArgs( v77,  0LL,  "%s%.30s:%-4d Creating new ephemeral local device for query %@",  "",  "+[NRDLocalDevice createEphemeralLocalDeviceForNRUUID:]",  2143LL,  v78);
              }

              uint64_t v79 = sub_100123CC0((char *)objc_alloc(&OBJC_CLASS___NRDLocalDevice), v73);
              id v76 = v79;
              if (v79)
              {
                v79[24] = 1;
                [(id)qword_1001DCB78 setObject:v79 forKeyedSubscript:v73];
LABEL_89:

                objc_opt_self(&OBJC_CLASS___NRLinkDirector);
                if (qword_1001DC878 == -1)
                {
LABEL_90:
                  int v56 = v153;
                  id v81 = (id)qword_1001DC870;
                  if (v7) {
                    id v82 = objc_getProperty(v1, v80, 8LL, 1);
                  }
                  else {
                    id v82 = 0LL;
                  }
                  sub_1000AF9A4((uint64_t)v81, v76, v82);

                  goto LABEL_93;
                }

                    id v76 = (void *)objc_claimAutoreleasedReturnValue([obja hostname]);
                    objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
                    if (qword_1001DC640 != -1) {
                      dispatch_once(&qword_1001DC640, &stru_1001ADE98);
                    }
                    id v77 = (id)qword_1001DC638;
                    id v78 = @"62743";
                    if (!v77) {
                      id v78 = 0LL;
                    }
                    uint64_t v79 = v78;
                    int v80 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v76,  v79));

                    id v81 = objc_alloc(&OBJC_CLASS___NRLinkWired);
                    if (v133) {
                      id v82 = (void *)v133[3];
                    }
                    else {
                      id v82 = 0LL;
                    }
                    id v83 = v82;
                    objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
                    if (qword_1001DC640 != -1) {
                      dispatch_once(&qword_1001DC640, &stru_1001ADE98);
                    }
                    xpc_object_t v84 = (id)qword_1001DC638;
                    uint64_t v85 = @"62743";
                    if (!v84) {
                      uint64_t v85 = 0LL;
                    }
                    id v86 = v85;
                    int v87 = v83;
                    id v88 = v133;
                    id v89 = v24;
                    id v90 = v143;
                    objb = v141;
                    id v91 = v80;
                    id v92 = v86;
                    id v131 = v88;
                    if (!v81)
                    {
                      NSUInteger v95 = v84;
                      goto LABEL_186;
                    }

                    if (!v87)
                    {
                      if (qword_1001DC8C0 != -1) {
                        dispatch_once(&qword_1001DC8C0, &stru_1001AF3E8);
                      }
                      uint64_t v100 = (id)qword_1001DC8B8;
                      int IsLevelEnabled = _NRLogIsLevelEnabled(v100, 17LL);

                      if (IsLevelEnabled)
                      {
                        NSUInteger v95 = v84;
                        if (qword_1001DC8C0 != -1) {
                          dispatch_once(&qword_1001DC8C0, &stru_1001AF3E8);
                        }
                        id v24 = v136;
                        uint64_t v102 = (id)qword_1001DC8B8;
                        _NRLogWithArgs(v102, 17LL, "%s called with null queue");
                        goto LABEL_185;
                      }

          uint64_t v28 = 1;
        }

        id v82 = v177;
        if (v177) {
          id v82 = (id *)v177[6];
        }
        id v83 = v82;
        xpc_object_t v84 = -[__CFArray containsObject:](keys, "containsObject:", v83);

        if (v84)
        {
          uint64_t v85 = v177;
          if (v177) {
            uint64_t v85 = (id *)v177[6];
          }
          id v86 = v85;
          int v87 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKeyedSubscript:](v170, "objectForKeyedSubscript:", v86));

          if (v87)
          {
            id v88 = (void *)objc_claimAutoreleasedReturnValue([v87 objectForKeyedSubscript:kSCPropNetLinkActive]);
            id v89 = [v88 BOOLValue];
            if (v177)
            {
              *((_BYTE *)v177 + 9) = v89;
              if (v89) {
                sub_10001DF44((uint64_t)v177);
              }
            }
          }

          else if (v177)
          {
            *((_BYTE *)v177 + 9) = 0;
          }

          id v91 = v177;
        }

        else
        {
          id v90 = v28;
          id v91 = v177;
          if (!v90) {
            goto LABEL_161;
          }
        }

        id v92 = v91 == 0LL;
        uint64_t v93 = (id *)*(id *)(a1 + 128);
        uint64_t v94 = v91 == v93;

        if (!v92) {
          ++*((_DWORD *)v177 + 4);
        }
        -[NSMutableArray addObject:](v166, "addObject:", v177);
        v169 |= v94;
LABEL_161:
        id v23 = v171 + 1;
        if (v171 + 1 >= (unint64_t)v172)
        {
          int v172 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v168,  "countByEnumeratingWithState:objects:count:",  &v198,  v213,  16LL);
          if (!v172) {
            goto LABEL_168;
          }
          id v23 = 0LL;
        }
      }
    }

    uint64_t v169 = 0;
LABEL_168:

    NSUInteger v95 = *(id *)(a1 + 136);
    id v96 = -[__CFArray containsObject:](keys, "containsObject:", v95);

    if (v96)
    {
      *(_BYTE *)(a1 + 32) = 0;
      id v97 = *(id *)(a1 + 136);
      uint64_t v98 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKeyedSubscript:](v170, "objectForKeyedSubscript:", v97));

      if (v98)
      {
        uint64_t v99 = (void *)objc_claimAutoreleasedReturnValue([v98 objectForKeyedSubscript:@"InternalInterfaces"]);
        if ([v99 count])
        {
          uint64_t v100 = (void *)objc_claimAutoreleasedReturnValue([v98 objectForKeyedSubscript:@"Hosts"]);
          uint64_t v101 = (void *)objc_claimAutoreleasedReturnValue([v100 objectForKeyedSubscript:@"Current"]);
          if ([v101 unsignedIntValue])
          {
            if (qword_1001DCBF8 != -1) {
              dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
            }
            uint64_t v102 = (id)qword_1001DCBF0;
            uint64_t v103 = _NRLogIsLevelEnabled(v102, 1LL);

            if (v103)
            {
              if (qword_1001DCBF8 != -1) {
                dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
              }
              uint64_t v104 = (id)qword_1001DCBF0;
              _NRLogWithArgs( v104,  1LL,  "%s%.30s:%-4d Bridge active",  "",  "-[NRLinkManagerWiFi processSCDUpdate:]",  2417);
            }

            *(_BYTE *)(a1 + 32) = 1;
          }
        }
      }
    }
  }

  else
  {
    uint64_t v169 = 0;
  }

  int v192 = 0u;
  uint64_t v193 = 0u;
  uint64_t v190 = 0u;
  v191 = 0u;
  uint64_t v178 = v166;
  id v105 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v178,  "countByEnumeratingWithState:objects:count:",  &v190,  v211,  16LL);
  if (!v105) {
    goto LABEL_251;
  }
  uint64_t v106 = *(void *)v191;
  do
  {
    for (m = 0LL; m != v105; m = (char *)m + 1)
    {
      if (*(void *)v191 != v106) {
        objc_enumerationMutation(v178);
      }
      id v108 = *(void **)(*((void *)&v190 + 1) + 8LL * (void)m);
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      uint64_t v109 = (id)qword_1001DCBF0;
      id v110 = _NRLogIsLevelEnabled(v109, 1LL);

      if (v110)
      {
        if (qword_1001DCBF8 != -1) {
          dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
        }
        uint64_t v111 = (id)qword_1001DCBF0;
        _NRLogWithArgs( v111,  1LL,  "%s%.30s:%-4d SCD changed config: %@",  "",  "-[NRLinkManagerWiFi processSCDUpdate:]",  2436LL,  v108);
      }

      if (sub_10001E054((uint64_t)v108))
      {
        if (v108) {
          id v112 = (void *)v108[7];
        }
        else {
          id v112 = 0LL;
        }
        uint64_t v113 = v112;
        id v114 = [v113 count] == 0;

        if (v114)
        {
          if (v108) {
            id v137 = (void *)*((unsigned int *)v108 + 4);
          }
          else {
            id v137 = 0LL;
          }
          objc_initWeak(&location, (id)a1);
          int v138 = dispatch_time(0x8000000000000000LL, 3000000000LL);
          if (a1) {
            id v139 = *(void **)(a1 + 24);
          }
          else {
            id v139 = 0LL;
          }
          uint64_t v140 = v139;
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472LL;
          block[2] = sub_10013FD90;
          block[3] = &unk_1001B0888;
          objc_copyWeak(v189, &location);
          v189[1] = v137;
          void block[4] = v108;
          void block[5] = a1;
          dispatch_after(v138, v140, block);

          objc_destroyWeak(v189);
          objc_destroyWeak(&location);
        }

        else
        {
          id v115 = *(id *)(a1 + 104);
          id v116 = v108 == v115;

          if (v116)
          {
            sub_10013EFF8(a1);
          }

          else
          {
            int v117 = *(id *)(a1 + 112);
            int v118 = v108 == v117;

            if (v118)
            {
              sub_10013F484((id *)a1);
            }

            else
            {
              id v119 = *(id *)(a1 + 128);
              int v120 = v108 == v119;

              if (v120) {
                sub_10013F988(a1);
              }
            }
          }
        }
      }

      else
      {
        id v121 = *(id *)(a1 + 104);
        id v122 = v108 == v121;

        if (v122)
        {
          id v127 = (dispatch_queue_s *)*(id *)(a1 + 24);
          dispatch_assert_queue_V2(v127);

          if (!*(void *)(a1 + 56)) {
            continue;
          }
          if (qword_1001DCBF8 != -1) {
            dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCBF0, 1LL))
          {
            if (qword_1001DCBF8 != -1) {
              dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
            }
            _NRLogWithArgs( qword_1001DCBF0,  1LL,  "%s%.30s:%-4d Interface is NOT available",  "",  "-[NRLinkManagerWiFi interfaceUnavailable]",  975);
          }

          id v128 = (dispatch_queue_s *)*(id *)(a1 + 24);
          dispatch_assert_queue_V2(v128);

          uint64_t v129 = *(void **)(a1 + 56);
          *(void *)(a1 + 56) = 0LL;

          uint64_t v130 = *(void **)(a1 + 80);
          *(void *)(a1 + 80) = 0LL;

          [(id)a1 reportEvent:11003 details:@"<nil>"];
          sub_10013BC04(a1);
          id v131 = [*(id *)(a1 + 152) copy];
          int v208 = 0u;
          uint64_t v209 = 0u;
          v206 = 0u;
          id v207 = 0u;
          int v132 = v131;
          id v133 = [v132 countByEnumeratingWithState:&v206 objects:&location count:16];
          if (v133)
          {
            id v134 = *(void *)v207;
            do
            {
              for (n = 0LL; n != v133; n = (char *)n + 1)
              {
                if (*(void *)v207 != v134) {
                  objc_enumerationMutation(v132);
                }
                id v136 = *(void **)(*((void *)&v206 + 1) + 8LL * (void)n);
                if ([v136 subtype] == 101)
                {
                  [v136 setNoTransport:1];
                  [v136 cancelWithReason:@"Interface went away"];
                }
              }

              id v133 = [v132 countByEnumeratingWithState:&v206 objects:&location count:16];
            }

            while (v133);
          }

          goto LABEL_223;
        }

        int v123 = *(id *)(a1 + 112);
        id v124 = v108 == v123;

        if (v124)
        {
          id v141 = (dispatch_queue_s *)*(id *)(a1 + 24);
          dispatch_assert_queue_V2(v141);

          if (*(void *)(a1 + 64))
          {
            if (qword_1001DCBF8 != -1) {
              dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
            }
            if (_NRLogIsLevelEnabled(qword_1001DCBF0, 1LL))
            {
              if (qword_1001DCBF8 != -1) {
                dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
              }
              _NRLogWithArgs( qword_1001DCBF0,  1LL,  "%s%.30s:%-4d AWDL interface is NOT available",  "",  "-[NRLinkManagerWiFi awdlUnavailable]",  1363);
            }

            id v142 = (dispatch_queue_s *)*(id *)(a1 + 24);
            dispatch_assert_queue_V2(v142);

            id v143 = *(void **)(a1 + 64);
            *(void *)(a1 + 64) = 0LL;

            [(id)a1 reportEvent:11005 details:@"<nil>"];
            id WeakRetained = objc_loadWeakRetained((id *)(a1 + 160));
            [WeakRetained localAWDLEndpointChanged:0];

            BOOL v145 = [*(id *)(a1 + 152) copy];
            int v208 = 0u;
            uint64_t v209 = 0u;
            v206 = 0u;
            id v207 = 0u;
            int v132 = v145;
            unsigned int v146 = [v132 countByEnumeratingWithState:&v206 objects:&location count:16];
            if (v146)
            {
              int v147 = *(void *)v207;
              do
              {
                for (iuint64_t i = 0LL; ii != v146; iuint64_t i = (char *)ii + 1)
                {
                  if (*(void *)v207 != v147) {
                    objc_enumerationMutation(v132);
                  }
                  id v149 = *(void **)(*((void *)&v206 + 1) + 8LL * (void)ii);
                  if ([v149 subtype] == 102)
                  {
                    [v149 setNoTransport:1];
                    [v149 cancelWithReason:@"Interface went away"];
                  }
                }

                unsigned int v146 = [v132 countByEnumeratingWithState:&v206 objects:&location count:16];
              }

              while (v146);
            }

LABEL_156:
                dispatch_once(&qword_1001DC878, &stru_1001AEED0);
                goto LABEL_90;
              }

              [(id)qword_1001DCB78 setObject:0 forKeyedSubscript:v73];
            }

            else
            {
              id v134 = sub_100121F34();
              int v135 = _NRLogIsLevelEnabled(v134, 17LL);

              if (v135)
              {
                id v136 = sub_100121F34();
                _NRLogWithArgs(v136, 17LL, "called with all-zero nrUUID");
              }
            }

            id v137 = sub_10004579C();
            int v138 = _NRLogIsLevelEnabled(v137, 16LL);

            if (v138)
            {
              id v139 = sub_10004579C();
              _NRLogWithArgs( v139,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "handleRegisterDeviceByNRUUID",  725);
            }

            BOOL v7 = (void *)_os_log_pack_size(12LL);
            id v76 = (char *)v142 - ((__chkstk_darwin(v7) + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v140 = *__error();
            uint64_t v130 = _os_log_pack_fill( v76,  v7,  v140,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)",  v142[0]);
LABEL_155:
            *(_DWORD *)uint64_t v130 = 136446210;
            *(void *)(v130 + 4) = "handleRegisterDeviceByNRUUID";
            id v141 = sub_10004579C();
            _NRLogAbortWithPack(v141, v76);
            goto LABEL_156;
          }
        }

        id v71 = 0LL;
        goto LABEL_78;
      }

      id v143 = v2;
      uint64_t v109 = (void *)objc_claimAutoreleasedReturnValue([v94 allowedLinkSubtypes]);
      id v110 = [v109 count];

      if (v110)
      {
        id v2 = v143;
        goto LABEL_130;
      }

      if (v7) {
        id v112 = objc_getProperty(v1, v111, 8LL, 1);
      }
      else {
        id v112 = 0LL;
      }
      uint64_t v113 = nrXPCEntitlementTesting;
      id v114 = v112;
      id v115 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v113));
      LODWORD(v113) = sub_100059918(v114, v115);

      id v116 = sub_10004579C();
      int v117 = v116;
      if ((_DWORD)v113)
      {
        int v118 = _NRLogIsLevelEnabled(v116, 0LL);

        id v2 = v143;
        if (v118)
        {
          id v119 = sub_10004579C();
          _NRLogWithArgs( v119,  0LL,  "%s%.30s:%-4d Ignoring operational properties",  "",  "handleRegisterDeviceByNRUUID",  690);
        }

        NSUInteger v95 = v154;
        __int128 v154 = 0LL;
        goto LABEL_102;
      }

      int v120 = _NRLogIsLevelEnabled(v116, 17LL);

      id v2 = v143;
      if (v120)
      {
        id v121 = sub_10004579C();
        _NRLogWithArgs(v121, 17LL, "Received invalid operational properties %@", v154);

        id v92 = v154;
        id v108 = @"Received invalid operational properties";
        id v4 = v150;
        int v87 = v151;
        int v56 = v153;
      }

      else
      {
        id v108 = @"Received invalid operational properties";
        id v4 = v150;
        int v87 = v151;
        int v56 = v153;
        id v92 = v154;
      }
    }

    else
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      id v4 = v150;
      int v87 = v151;
      int v56 = v153;
      if (_NRLogIsLevelEnabled(qword_1001DC770, 17LL))
      {
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        _NRLogWithArgs(qword_1001DC770, 17LL, "Failed to unarchive operational properties %@", v152);
      }

      id v108 = @"Failed to unarchive operational properties";
    }

    ((void (*)(void *, uint64_t, const __CFString *))v56[2])(v56, -2005LL, v108);
    goto LABEL_111;
  }

  id v122 = sub_10004579C();
  int v123 = _NRLogIsLevelEnabled(v122, 16LL);

  if (!v123) {
    goto LABEL_142;
  }
  id v11 = sub_10004579C();
  id v18 = sub_10004580C(v7, v124);
  _NRLogWithArgs(v11, 16LL, "%s%.30s:%-4d Missing NRUUID from %@", "", "handleRegisterDeviceByNRUUID", 617LL, v18);
LABEL_19:

  uint64_t v19 = -2005LL;
LABEL_143:

  return v19;
}

uint64_t sub_10004F818(void *a1)
{
  id Property = a1;
  id v4 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v3, 16LL, 1);
  }
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyNRUUID);
  if (!uuid)
  {
    id v33 = sub_10004579C();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v33, 16LL);

    if (!IsLevelEnabled) {
      goto LABEL_20;
    }
    id v8 = sub_10004579C();
    id v15 = sub_10004580C(v4, v35);
    _NRLogWithArgs(v8, 16LL, "%s%.30s:%-4d Missing NRUUID from %@", "", "handleUnregisterDeviceByNRUUID", 755LL, v15);
LABEL_19:

LABEL_20:
    uint64_t v16 = -2005LL;
    goto LABEL_40;
  }

  uint64_t v6 = uuid;
  if (uuid_is_null(uuid))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v8 = (id)qword_1001DC770;
    if (v4)
    {
      id v9 = (void *)v4[4];
      if (!v9)
      {
        id v10 = (_xpc_connection_s *)objc_getProperty(v4, v7, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(v10);
        id v12 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(v44, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, v44, 0x400u) >= 1 && v44[0])
        {
          char v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v44,  pid);

          id v12 = v13;
        }

        id v14 = (void *)v4[4];
        v4[4] = v12;

        id v9 = (void *)v4[4];
      }

      id v15 = v9;
    }

    else
    {
      id v15 = 0LL;
    }

    _NRLogWithArgs(v8, 16LL, "%s%.30s:%-4d All-zero NRUUID from %@", "", "handleUnregisterDeviceByNRUUID", 759LL, v15);
    goto LABEL_19;
  }

  id v17 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v6);
  if (!v17)
  {
    id v36 = sub_10004579C();
    int v37 = _NRLogIsLevelEnabled(v36, 16LL);

    if (v37)
    {
      id v38 = sub_10004579C();
      _NRLogWithArgs( v38,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "handleUnregisterDeviceByNRUUID",  763);
    }

    id v4 = (void *)_os_log_pack_size(12LL);
    id v18 = (NSUUID *)((char *)v42 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL));
    int v39 = __error();
    uint64_t v40 = _os_log_pack_fill( v18,  v4,  *v39,  &_mh_execute_header,  "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    *(_DWORD *)uint64_t v40 = 136446210;
    *(void *)(v40 + 4) = "handleUnregisterDeviceByNRUUID";
    id v41 = sub_10004579C();
    _NRLogAbortWithPack(v41, v18);
    goto LABEL_46;
  }

  id v18 = v17;
  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  if (qword_1001DC778 != -1) {
LABEL_46:
  }
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (p_class_meths[239] != (__objc2_meth_list *)-1LL) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v20 = (id)qword_1001DC770;
    if (v4)
    {
      id v21 = (void *)v4[4];
      if (!v21)
      {
        id v22 = (_xpc_connection_s *)objc_getProperty(v4, v19, 8LL, 1);
        uint64_t v23 = xpc_connection_get_pid(v22);
        id v24 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v23);
        bzero(v44, 0x400uLL);
        if ((int)v23 >= 1 && proc_pidpath(v23, v44, 0x400u) >= 1 && v44[0])
        {
          id v25 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v44,  v23);

          id v24 = v25;
        }

        uint64_t v26 = (void *)v4[4];
        v4[4] = v24;

        id v21 = (void *)v4[4];
      }

      id v27 = v21;
    }

    else
    {
      id v27 = 0LL;
    }

    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(-[NSUUID UUIDString](v18, "UUIDString"));
    _NRLogWithArgs( v20,  0LL,  "%s%.30s:%-4d Client %@ unregistering %@",  "",  "handleUnregisterDeviceByNRUUID",  764LL,  v27,  v28);
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v30 = (id)qword_1001DC870;
  if (v4) {
    id v31 = objc_getProperty(v4, v29, 8LL, 1);
  }
  else {
    id v31 = 0LL;
  }
  sub_1000AF9A4((uint64_t)v30, 0LL, v31);

  v42[0] = _NSConcreteStackBlock;
  v42[1] = 3221225472LL;
  v42[2] = sub_100059704;
  v42[3] = &unk_1001AF078;
  id v43 = v4;
  sub_100130BE8((uint64_t)&OBJC_CLASS___NRDLocalDevice, v18, v42);

  uint64_t v16 = -2000LL;
LABEL_40:

  return v16;
}

uint64_t sub_10004FDE8(void *a1)
{
  id v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v3 = (id)qword_1001DC770;
    if (v1)
    {
      id v4 = (void *)v1[4];
      if (!v4)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        BOOL v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          BOOL v7 = v8;
        }

        id v9 = (void *)v1[4];
        v1[4] = v7;

        id v4 = (void *)v1[4];
      }

      id v10 = v4;
    }

    else
    {
      id v10 = 0LL;
    }

    _NRLogWithArgs( v3,  0LL,  "%s%.30s:%-4d Client %@ unregistering all devices",  "",  "handleUnregisterAllDevices",  786LL,  v10);
  }

  v33[0] = _NSConcreteStackBlock;
  v33[1] = 3221225472LL;
  id v34 = sub_1000595F8;
  id v35 = &unk_1001AF078;
  id v36 = v1;
  id v31 = v1;
  id v30 = v33;
  uint64_t v11 = objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
  id v12 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v12);

  uint64_t v29 = v11;
  sub_100127AFC(v11);
  id v13 = [(id)qword_1001DCB78 copy];
  __int128 v37 = 0u;
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  id obj = v13;
  id v14 = [obj countByEnumeratingWithState:&v37 objects:buffer count:16];
  if (v14)
  {
    id v15 = v14;
    uint64_t v16 = *(void *)v38;
    do
    {
      for (uint64_t i = 0LL; i != v15; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v38 != v16) {
          objc_enumerationMutation(obj);
        }
        uint64_t v19 = *(void **)(*((void *)&v37 + 1) + 8LL * (void)i);
        id v20 = sub_100129C28((uint64_t)&OBJC_CLASS___NRDLocalDevice, v19, 0);
        id v21 = v20;
        if (v20)
        {
          id v22 = *((id *)v20 + 4);
          uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v21 description]);
          sub_10011BB18(v22, 5002, v23, 0LL);

          id v24 = sub_10012BF24((uint64_t)&OBJC_CLASS___NRDLocalDevice, v21);
          [(id)qword_1001DCB78 setObject:v24 forKeyedSubscript:v19];

          if (*((void *)v21 + 7)) {
            objc_msgSend((id)qword_1001DCB80, "setObject:forKeyedSubscript:", 0);
          }
        }

        else
        {
          id v18 = sub_10012BF24((uint64_t)&OBJC_CLASS___NRDLocalDevice, 0LL);
          [(id)qword_1001DCB78 setObject:v18 forKeyedSubscript:v19];
        }

        sub_10009FF2C(v19, 0LL);
        sub_10012AEE0((uint64_t)v21);
      }

      id v15 = [obj countByEnumeratingWithState:&v37 objects:buffer count:16];
    }

    while (v15);
  }

  uint64_t v25 = objc_opt_self(v29);
  sub_100128908(v25);
  if (qword_1001DCBD8 != -1) {
    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
  {
    if (qword_1001DCBD8 != -1) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    _NRLogWithArgs( qword_1001DCBD0,  0LL,  "%s%.30s:%-4d Unregistered all devices",  "",  "+[NRDLocalDevice unregisterAllDevicesWithCompletionBlock:]",  2675);
  }

  v34((uint64_t)v30, 0LL, 0LL);
  uint64_t v26 = sub_100146AFC();
  dispatch_async((dispatch_queue_t)v26, &stru_1001AEA60);

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v27 = (char *)(id)qword_1001DC870;
  sub_1000A49E8(v27);

  return -2000LL;
}

uint64_t sub_1000502D8(void *a1)
{
  id Property = a1;
  id v4 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v3, 16LL, 1);
  }
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyNRUUID);
  if (!uuid)
  {
    id v30 = sub_10004579C();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v30, 16LL);

    if (!IsLevelEnabled) {
      goto LABEL_20;
    }
    id v8 = sub_10004579C();
    id v15 = sub_10004580C(v4, v32);
    _NRLogWithArgs(v8, 16LL, "%s%.30s:%-4d Missing NRUUID from %@", "", "handleEnableDeviceByNRUUID", 808LL, v15);
LABEL_19:

LABEL_20:
    uint64_t v16 = -2005LL;
    goto LABEL_36;
  }

  uint64_t v6 = uuid;
  if (uuid_is_null(uuid))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v8 = (id)qword_1001DC770;
    if (v4)
    {
      id v9 = (void *)v4[4];
      if (!v9)
      {
        id v10 = (_xpc_connection_s *)objc_getProperty(v4, v7, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(v10);
        id v12 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(v41, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, v41, 0x400u) >= 1 && v41[0])
        {
          id v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v41,  pid);

          id v12 = v13;
        }

        id v14 = (void *)v4[4];
        v4[4] = v12;

        id v9 = (void *)v4[4];
      }

      id v15 = v9;
    }

    else
    {
      id v15 = 0LL;
    }

    _NRLogWithArgs(v8, 16LL, "%s%.30s:%-4d All-zero NRUUID from %@", "", "handleEnableDeviceByNRUUID", 812LL, v15);
    goto LABEL_19;
  }

  id v17 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v6);
  if (!v17)
  {
    id v33 = sub_10004579C();
    int v34 = _NRLogIsLevelEnabled(v33, 16LL);

    if (v34)
    {
      id v35 = sub_10004579C();
      _NRLogWithArgs( v35,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "handleEnableDeviceByNRUUID",  816);
    }

    id v4 = (void *)_os_log_pack_size(12LL);
    id v18 = (NSUUID *)((char *)v39 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL));
    id v36 = __error();
    uint64_t v37 = _os_log_pack_fill( v18,  v4,  *v36,  &_mh_execute_header,  "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    *(_DWORD *)uint64_t v37 = 136446210;
    *(void *)(v37 + 4) = "handleEnableDeviceByNRUUID";
    id v38 = sub_10004579C();
    _NRLogAbortWithPack(v38, v18);
    goto LABEL_42;
  }

  id v18 = v17;
  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  if (qword_1001DC778 != -1) {
LABEL_42:
  }
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (p_class_meths[239] != (__objc2_meth_list *)-1LL) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v20 = (id)qword_1001DC770;
    if (v4)
    {
      id v21 = (void *)v4[4];
      if (!v21)
      {
        id v22 = (_xpc_connection_s *)objc_getProperty(v4, v19, 8LL, 1);
        uint64_t v23 = xpc_connection_get_pid(v22);
        id v24 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v23);
        bzero(v41, 0x400uLL);
        if ((int)v23 >= 1 && proc_pidpath(v23, v41, 0x400u) >= 1 && v41[0])
        {
          uint64_t v25 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v41,  v23);

          id v24 = v25;
        }

        uint64_t v26 = (void *)v4[4];
        v4[4] = v24;

        id v21 = (void *)v4[4];
      }

      id v27 = v21;
    }

    else
    {
      id v27 = 0LL;
    }

    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(-[NSUUID UUIDString](v18, "UUIDString"));
    _NRLogWithArgs(v20, 0LL, "%s%.30s:%-4d Client %@ enabling %@", "", "handleEnableDeviceByNRUUID", 817LL, v27, v28);
  }

  v39[0] = _NSConcreteStackBlock;
  v39[1] = 3221225472LL;
  v39[2] = sub_1000594F0;
  v39[3] = &unk_1001AF078;
  __int128 v40 = v4;
  sub_10012FC24((uint64_t)&OBJC_CLASS___NRDLocalDevice, v18, v39);

  uint64_t v16 = -2000LL;
LABEL_36:

  return v16;
}

uint64_t sub_100050834(void *a1)
{
  id Property = a1;
  id v4 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v3, 16LL, 1);
  }
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyNRUUID);
  if (!uuid)
  {
    id v30 = sub_10004579C();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v30, 16LL);

    if (!IsLevelEnabled) {
      goto LABEL_20;
    }
    id v8 = sub_10004579C();
    id v15 = sub_10004580C(v4, v32);
    _NRLogWithArgs(v8, 16LL, "%s%.30s:%-4d Missing NRUUID from %@", "", "handleDisableDeviceByNRUUID", 838LL, v15);
LABEL_19:

LABEL_20:
    uint64_t v16 = -2005LL;
    goto LABEL_36;
  }

  uint64_t v6 = uuid;
  if (uuid_is_null(uuid))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v8 = (id)qword_1001DC770;
    if (v4)
    {
      id v9 = (void *)v4[4];
      if (!v9)
      {
        id v10 = (_xpc_connection_s *)objc_getProperty(v4, v7, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(v10);
        id v12 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(v41, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, v41, 0x400u) >= 1 && v41[0])
        {
          id v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v41,  pid);

          id v12 = v13;
        }

        id v14 = (void *)v4[4];
        v4[4] = v12;

        id v9 = (void *)v4[4];
      }

      id v15 = v9;
    }

    else
    {
      id v15 = 0LL;
    }

    _NRLogWithArgs(v8, 16LL, "%s%.30s:%-4d All-zero NRUUID from %@", "", "handleDisableDeviceByNRUUID", 842LL, v15);
    goto LABEL_19;
  }

  id v17 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v6);
  if (!v17)
  {
    id v33 = sub_10004579C();
    int v34 = _NRLogIsLevelEnabled(v33, 16LL);

    if (v34)
    {
      id v35 = sub_10004579C();
      _NRLogWithArgs( v35,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "handleDisableDeviceByNRUUID",  846);
    }

    id v4 = (void *)_os_log_pack_size(12LL);
    id v18 = (NSUUID *)((char *)v39 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL));
    id v36 = __error();
    uint64_t v37 = _os_log_pack_fill( v18,  v4,  *v36,  &_mh_execute_header,  "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    *(_DWORD *)uint64_t v37 = 136446210;
    *(void *)(v37 + 4) = "handleDisableDeviceByNRUUID";
    id v38 = sub_10004579C();
    _NRLogAbortWithPack(v38, v18);
    goto LABEL_42;
  }

  id v18 = v17;
  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  if (qword_1001DC778 != -1) {
LABEL_42:
  }
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (p_class_meths[239] != (__objc2_meth_list *)-1LL) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v20 = (id)qword_1001DC770;
    if (v4)
    {
      id v21 = (void *)v4[4];
      if (!v21)
      {
        id v22 = (_xpc_connection_s *)objc_getProperty(v4, v19, 8LL, 1);
        uint64_t v23 = xpc_connection_get_pid(v22);
        id v24 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v23);
        bzero(v41, 0x400uLL);
        if ((int)v23 >= 1 && proc_pidpath(v23, v41, 0x400u) >= 1 && v41[0])
        {
          uint64_t v25 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v41,  v23);

          id v24 = v25;
        }

        uint64_t v26 = (void *)v4[4];
        v4[4] = v24;

        id v21 = (void *)v4[4];
      }

      id v27 = v21;
    }

    else
    {
      id v27 = 0LL;
    }

    uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue(-[NSUUID UUIDString](v18, "UUIDString"));
    _NRLogWithArgs(v20, 0LL, "%s%.30s:%-4d Client %@ disabling %@", "", "handleDisableDeviceByNRUUID", 847LL, v27, v28);
  }

  v39[0] = _NSConcreteStackBlock;
  v39[1] = 3221225472LL;
  v39[2] = sub_1000593E8;
  v39[3] = &unk_1001AF078;
  __int128 v40 = v4;
  sub_100131034((uint64_t)&OBJC_CLASS___NRDLocalDevice, v18, v39);

  uint64_t v16 = -2000LL;
LABEL_36:

  return v16;
}

uint64_t sub_100050D90(void *a1)
{
  id v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v3 = (id)qword_1001DC770;
    if (v1)
    {
      id v4 = (void *)v1[4];
      if (!v4)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        BOOL v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          BOOL v7 = v8;
        }

        id v9 = (void *)v1[4];
        v1[4] = v7;

        id v4 = (void *)v1[4];
      }

      id v10 = v4;
    }

    else
    {
      id v10 = 0LL;
    }

    _NRLogWithArgs(v3, 0LL, "%s%.30s:%-4d Client %@ copying device list", "", "handleCopyDeviceListString", 1019LL, v10);
  }

  uint64_t v11 = objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
  id v12 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v12);

  sub_100127AFC(v11);
  id v13 = [(id)qword_1001DCB78 copy];
  id v14 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
  -[NSMutableString appendFormat:](v14, "appendFormat:", @"%llu devices:", [v13 count]);
  __int128 v32 = 0u;
  __int128 v33 = 0u;
  __int128 v30 = 0u;
  __int128 v31 = 0u;
  id v15 = v13;
  id v16 = [v15 countByEnumeratingWithState:&v30 objects:buffer count:16];
  if (v16)
  {
    id v17 = v16;
    uint64_t v18 = *(void *)v31;
    do
    {
      for (uint64_t i = 0LL; i != v17; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v31 != v18) {
          objc_enumerationMutation(v15);
        }
        id v20 = (id *)objc_claimAutoreleasedReturnValue( [v15 objectForKeyedSubscript:*(void *)(*((void *)&v30 + 1) + 8 * (void)i)]);
        id v21 = (void *)sub_10012C014(v20);
        -[NSMutableString appendFormat:](v14, "appendFormat:", @"\n\t%@", v21);
      }

      id v17 = [v15 countByEnumeratingWithState:&v30 objects:buffer count:16];
    }

    while (v17);
  }

  if (v14)
  {
    if (v1) {
      id v23 = objc_getProperty(v1, v22, 24LL, 1);
    }
    else {
      id v23 = 0LL;
    }
    id v24 = (const char *)nrXPCKeyDeviceListString;
    id v25 = v23;
    xpc_dictionary_set_string(v25, v24, (const char *)-[NSMutableString UTF8String](v14, "UTF8String"));
    uint64_t v26 = 0LL;
  }

  else
  {
    id v28 = sub_10004579C();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v28, 17LL);

    if (!IsLevelEnabled)
    {
      uint64_t v26 = -2009LL;
      goto LABEL_27;
    }

    id v25 = sub_10004579C();
    _NRLogWithArgs(v25, 17LL, "[NRDLocalDevice copyDeviceListString] failed");
    uint64_t v26 = -2009LL;
  }

LABEL_27:
  return v26;
}

uint64_t sub_10005113C(void *a1)
{
  id v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v3 = (id)qword_1001DC770;
    if (v1)
    {
      id v4 = (void *)v1[4];
      if (!v4)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        BOOL v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          BOOL v7 = v8;
        }

        id v9 = (void *)v1[4];
        v1[4] = v7;

        id v4 = (void *)v1[4];
      }

      id v10 = v4;
    }

    else
    {
      id v10 = 0LL;
    }

    _NRLogWithArgs(v3, 0LL, "%s%.30s:%-4d Client %@ copying IDS device ID", "", "handleCopyIDSDeviceID", 1052LL, v10);
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  uint64_t v11 = (id)qword_1001DC870;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472LL;
  v14[2] = sub_1000592FC;
  v14[3] = &unk_1001AE7E0;
  id v15 = v1;
  id v12 = v1;

  return -2000LL;
}

uint64_t sub_1000513A4(void *a1)
{
  id v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v3 = (id)qword_1001DC770;
    if (v1)
    {
      id v4 = (void *)v1[4];
      if (!v4)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        BOOL v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          BOOL v7 = v8;
        }

        id v9 = (void *)v1[4];
        v1[4] = v7;

        id v4 = (void *)v1[4];
      }

      id v10 = v4;
    }

    else
    {
      id v10 = 0LL;
    }

    _NRLogWithArgs(v3, 0LL, "%s%.30s:%-4d Client %@ enabling cloud link", "", "handleEnableCloudLink", 866LL, v10);
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v11 = (id)qword_1001DC870;
  sub_1000AEE40((uint64_t)v11, 1);

  return 0LL;
}

uint64_t sub_1000515C4(void *a1)
{
  id v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v3 = (id)qword_1001DC770;
    if (v1)
    {
      id v4 = (void *)v1[4];
      if (!v4)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        BOOL v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          BOOL v7 = v8;
        }

        id v9 = (void *)v1[4];
        v1[4] = v7;

        id v4 = (void *)v1[4];
      }

      id v10 = v4;
    }

    else
    {
      id v10 = 0LL;
    }

    _NRLogWithArgs(v3, 0LL, "%s%.30s:%-4d Client %@ disabling cloud link", "", "handleDisableCloudLink", 874LL, v10);
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v11 = (id)qword_1001DC870;
  sub_1000AEE40((uint64_t)v11, 0);

  return 0LL;
}

uint64_t sub_1000517E4(void *a1)
{
  id Property = a1;
  id v4 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v3, 16LL, 1);
  }
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyDeviceIdentifier);
  if (uuid)
  {
    uint64_t v6 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", uuid);
    if (v6)
    {
      BOOL v7 = v6;
      p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
      if (qword_1001DC778 == -1) {
        goto LABEL_6;
      }
    }

    else
    {
      id v59 = sub_10004579C();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v59, 16LL);

      if (IsLevelEnabled)
      {
        id v61 = sub_10004579C();
        _NRLogWithArgs( v61,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (deviceIdentifier) != ((void *)0)",  "",  "handleDeviceMonitorStatusQuery",  1142);
      }

      id v4 = (void *)_os_log_pack_size(12LL);
      BOOL v7 = (NSUUID *)&v78[-((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
      uint64_t v62 = __error();
      uint64_t v63 = _os_log_pack_fill( v7,  v4,  *v62,  &_mh_execute_header,  "%{public}s Assertion Failed: (deviceIdentifier) != ((void *)0)");
      *(_DWORD *)uint64_t v63 = 136446210;
      *(void *)(v63 + 4) = "handleDeviceMonitorStatusQuery";
      id v64 = sub_10004579C();
      _NRLogAbortWithPack(v64, v7);
    }

    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
LABEL_6:
    id v8 = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
    {
      if (p_class_meths[239] != (__objc2_meth_list *)-1LL) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      id v9 = (id)qword_1001DC770;
      id v11 = (void *)objc_claimAutoreleasedReturnValue(-[NSUUID UUIDString](v7, "UUIDString"));
      if (v4)
      {
        id v12 = (void *)v4[4];
        if (!v12)
        {
          id v13 = (_xpc_connection_s *)objc_getProperty(v4, v10, 8LL, 1);
          uint64_t pid = xpc_connection_get_pid(v13);
          id v15 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
          bzero(v78, 0x400uLL);
          if ((int)pid >= 1 && proc_pidpath(pid, v78, 0x400u) >= 1 && v78[0])
          {
            id v16 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v78,  pid);

            id v15 = v16;
          }

          id v17 = (void *)v4[4];
          v4[4] = v15;

          id v12 = (void *)v4[4];
        }

        id v18 = v12;
      }

      else
      {
        id v18 = 0LL;
      }

      _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d Received request for device monitor status query of %@ from %@",  "",  "handleDeviceMonitorStatusQuery",  1144LL,  v11,  v18);
    }

    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    uint64_t v19 = (id *)(id)qword_1001DC870;
    objc_opt_self(&OBJC_CLASS___TerminusdXPCServer);
    if (qword_1001DC768 != -1) {
      dispatch_once(&qword_1001DC768, &stru_1001AE748);
    }
    id v20 = (id)qword_1001DC760;
    id v22 = v20;
    if (v20) {
      id v20 = objc_getProperty(v20, v21, 24LL, 1);
    }
    id v24 = v20;
    if (v4) {
      id v25 = objc_getProperty(v4, v23, 8LL, 1);
    }
    else {
      id v25 = 0LL;
    }
    unsigned int v26 = [v24 containsObject:v25];

    if (!v26)
    {
      if (p_class_meths[239] != (__objc2_meth_list *)-1LL) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      if (!_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
      {
        uint64_t v45 = -2010LL;
LABEL_91:

        goto LABEL_92;
      }

      if (p_class_meths[239] != (__objc2_meth_list *)-1LL) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      id v36 = (id)qword_1001DC770;
      id v47 = (void *)objc_claimAutoreleasedReturnValue(-[NSUUID UUIDString](v7, "UUIDString"));
      if (v4)
      {
        BOOL v48 = (void *)v4[4];
        if (!v48)
        {
          id v49 = (_xpc_connection_s *)objc_getProperty(v4, v46, 8LL, 1);
          uint64_t v50 = xpc_connection_get_pid(v49);
          BOOL v51 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v50);
          bzero(v78, 0x400uLL);
          if ((int)v50 >= 1 && proc_pidpath(v50, v78, 0x400u) >= 1 && v78[0])
          {
            id v52 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v78,  v50);

            BOOL v51 = v52;
          }

          uint64_t v53 = (void *)v4[4];
          v4[4] = v51;

          BOOL v48 = (void *)v4[4];
        }

        id v54 = v48;
      }

      else
      {
        id v54 = 0LL;
      }

      _NRLogWithArgs( v36,  16LL,  "%s%.30s:%-4d Connection lost before first update for %@ %@",  "",  "handleDeviceMonitorStatusQuery",  1163LL,  v47,  v54);

      uint64_t v45 = -2010LL;
LABEL_90:

      goto LABEL_91;
    }

    if (v4)
    {
      id v28 = objc_getProperty(v4, v27, 8LL, 1);
      sub_1000AF22C((uint64_t)v19, v28, v7);
      id v30 = objc_getProperty(v4, v29, 24LL, 1);
    }

    else
    {
      sub_1000AF22C((uint64_t)v19, 0LL, v7);
      id v30 = 0LL;
    }

    __int128 v31 = v7;
    id v32 = v30;
    __int128 v33 = v32;
    if (v19)
    {
      if (v32)
      {
        uint64_t v34 = objc_claimAutoreleasedReturnValue([v19[27] objectForKeyedSubscript:v31]);
        if (v34)
        {
          id v35 = (id)v34;
          sub_1000DB1DC(v34, v33);
          id v36 = v33;
        }

        else
        {
          id v36 = v33;
          id v55 = v31;
          uint64_t v56 = objc_opt_self(&OBJC_CLASS___NRDDeviceConductor);
          sub_1000DB570(v56, v55, 0, 0, 0, 0, 0, 0, 0, 0, 0LL, 0, 0, v36);

          id v8 = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
          id v35 = 0LL;
        }

LABEL_64:
        if (v36)
        {
          if (v4) {
            uint64_t v58 = (_xpc_connection_s *)objc_getProperty(v4, v57, 8LL, 1);
          }
          else {
            uint64_t v58 = 0LL;
          }
          xpc_connection_send_message(v58, v36);
          uint64_t v45 = -2000LL;
          goto LABEL_90;
        }

                  id v96 = _NRCopyLogObjectForNRUUID(*(void *)(v2 + 32), v95);
                  id v97 = (void *)v96;
                  if ((v82 & 1) != 0)
                  {
                    uint64_t v98 = _NRLogIsLevelEnabled(v96, 0LL);

                    if (v98)
                    {
                      uint64_t v100 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v2 + 32), v99);
                      uint64_t v101 = (void *)objc_claimAutoreleasedReturnValue([(id)v2 agentUUID]);
                      _NRLogWithArgs( v100,  0LL,  "%s%.30s:%-4d Successfully added fallback path controller for agent (%@)",  "",  "-[NRCompanionProxyAgent registerAgent]",  224LL,  v101);

LABEL_69:
                    }
                  }

                  else
                  {
                    uint64_t v102 = _NRLogIsLevelEnabled(v96, 17LL);

                    if (v102)
                    {
                      uint64_t v100 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v2 + 32), v103);
                      _NRLogWithArgs(v100, 17LL, "unable to register path controllers");
                      goto LABEL_69;
                    }
                  }
}
}

          if (v24)
          {
            -[NSMutableSet addObject:](v11, "addObject:", v24);
          }
        }
      }

LABEL_75:
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        if (_NRLogIsLevelEnabled(v8[238], 16LL))
        {
          if (qword_1001DC778 != -1) {
            dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
          }
          xpc_object_t v67 = v8[238];
          int v69 = (void *)objc_claimAutoreleasedReturnValue(-[NSUUID UUIDString](v31, "UUIDString"));
          if (v4)
          {
            uint64_t v70 = (void *)v4[4];
            if (!v70)
            {
              id v71 = (_xpc_connection_s *)objc_getProperty(v4, v68, 8LL, 1);
              uint64_t v72 = xpc_connection_get_pid(v71);
              uint64_t v73 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v72);
              bzero(v78, 0x400uLL);
              if ((int)v72 >= 1 && proc_pidpath(v72, v78, 0x400u) >= 1 && v78[0])
              {
                uint64_t v74 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v78,  v72);

                uint64_t v73 = v74;
              }

              int v75 = (void *)v4[4];
              v4[4] = v73;

              uint64_t v70 = (void *)v4[4];
            }

            id v76 = v70;
          }

          else
          {
            id v76 = 0LL;
          }

          _NRLogWithArgs( v67,  16LL,  "%s%.30s:%-4d Could not get monitor status for %@ %@",  "",  "handleDeviceMonitorStatusQuery",  1158LL,  v69,  v76);
        }

        id v36 = 0LL;
        uint64_t v45 = -2008LL;
        goto LABEL_90;
      }

      id v65 = sub_1000A2100();
      int v66 = _NRLogIsLevelEnabled(v65, 17LL);

      if (v66)
      {
        id v35 = sub_1000A2100();
        _NRLogWithArgs( v35,  17LL,  "%s called with null replyDict",  "-[NRLinkDirector copyDeviceMonitorStatusForNRUUID:replyDict:]");
        id v36 = 0LL;
        goto LABEL_64;
      }
    }

    goto LABEL_75;
  }

  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    BOOL v7 = (NSUUID *)(id)qword_1001DC770;
    if (v4)
    {
      uint64_t v19 = (id *)objc_getProperty(v4, v37, 16LL, 1);
      __int128 v39 = (void *)v4[4];
      if (!v39)
      {
        __int128 v40 = (_xpc_connection_s *)objc_getProperty(v4, v38, 8LL, 1);
        uint64_t v41 = xpc_connection_get_pid(v40);
        int v42 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v41);
        bzero(v78, 0x400uLL);
        if ((int)v41 >= 1 && proc_pidpath(v41, v78, 0x400u) >= 1 && v78[0])
        {
          id v43 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v78,  v41);

          int v42 = v43;
        }

        id v44 = (void *)v4[4];
        v4[4] = v42;

        __int128 v39 = (void *)v4[4];
      }

      id v22 = v39;
    }

    else
    {
      uint64_t v19 = 0LL;
      id v22 = 0LL;
    }

    _NRLogWithArgs( v7,  16LL,  "%s%.30s:%-4d No device identifier found in message %@ from %@",  "",  "handleDeviceMonitorStatusQuery",  1137LL,  v19,  v22);
    uint64_t v45 = -2005LL;
    goto LABEL_91;
  }

  uint64_t v45 = -2005LL;
LABEL_92:

  return v45;
}

            goto LABEL_76;
          }
        }

        else
        {
          if ([v105 integerValue] != (id)2)
          {
            int v66 = (void *)_NRCopyLogObjectForNRUUID(v48[4], v57);
            xpc_object_t v67 = _NRLogIsLevelEnabled(v66, 17LL);

            if (v67)
            {
              id v61 = (void *)_NRCopyLogObjectForNRUUID(v48[4], v68);
              uint64_t v62 = [v48 copyDescription];
              _NRLogWithArgs(v61, 17LL, "%@: Invalid channel ID: %@", v62, v105);
              goto LABEL_74;
            }

            goto LABEL_75;
          }

          if (v54 && *((_BYTE *)v48 + 248))
          {
            uint64_t v58 = (void *)_NRCopyLogObjectForNRUUID(v48[4], v57);
            id v59 = _NRLogIsLevelEnabled(v58, 0LL);

            if (v59)
            {
              id v61 = (void *)_NRCopyLogObjectForNRUUID(v48[4], v60);
              uint64_t v62 = [v48 copyDescription];
              _NRLogWithArgs( v61,  0LL,  "%s%.30s:%-4d %@: ignoring pre-activation message for high",  "",  "-[NRLinkBluetooth processXPCCommDictionary:]",  5994LL,  v62);
LABEL_74:

              goto LABEL_75;
            }

            goto LABEL_75;
          }
        }

        sub_10009EFF4((uint64_t)v48, v53, v56 != (id)1);
        goto LABEL_75;
      }
    }

    else
    {
      id v36 = 0LL;
      if (v33) {
        goto LABEL_41;
      }
    }

      id v64 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v20);
      id v65 = _NRLogIsLevelEnabled(v64, 1LL);

      if (!v65) {
        goto LABEL_63;
      }
      id v27 = (NSString *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v66);
      id v28 = [(id)a1 copyDescription];
      int v252 = v28;
      v254 = a2;
      v251 = 7964LL;
      id v52 = "%s%.30s:%-4d %@: Received unknown notify code %u";
      goto LABEL_59;
    }

    id v17 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v13);
    id v18 = _NRLogIsLevelEnabled(v17, 1LL);

    if (v18)
    {
      id v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v19);
      id v16 = [(id)a1 copyDescription];
      _NRLogWithArgs( v15,  1LL,  "%s%.30s:%-4d %@: Received seq per TC notify",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7680LL,  v16);
      goto LABEL_12;
    }
  }

  if (qword_1001DCBD8 != -1) {
    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
  {
    if (qword_1001DCBD8 != -1) {
      dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    }
    _NRLogWithArgs( qword_1001DCBD0,  0LL,  "%s%.30s:%-4d Skipping saving ClassD configs",  "",  "+[NRDLocalDevice saveAllDevicesToDiskWithForce:]",  1291);
  }

uint64_t sub_100052240(void *a1)
{
  id v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v4 = (id)qword_1001DC770;
    if (v1)
    {
      int v5 = (void *)v1[4];
      if (!v5)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v3, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v9 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v8 = v9;
        }

        id v10 = (void *)v1[4];
        v1[4] = v8;

        int v5 = (void *)v1[4];
      }

      id v11 = v5;
    }

    else
    {
      id v11 = 0LL;
    }

    _NRLogWithArgs( v4,  0LL,  "%s%.30s:%-4d Received request to set device preferences from %@",  "",  "handleDevicePreferences",  1063LL,  v11);
  }

  if (v1) {
    id v12 = objc_getProperty(v1, v2, 16LL, 1);
  }
  else {
    id v12 = 0LL;
  }
  uuid = xpc_dictionary_get_uuid(v12, nrXPCKeyDeviceIdentifier);
  if (uuid)
  {
    id v15 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", uuid);
    if (v1) {
      id v16 = objc_getProperty(v1, v14, 16LL, 1);
    }
    else {
      id v16 = 0LL;
    }
    xpc_object_t value = xpc_dictionary_get_value(v16, nrXPCKeyDevicePreferencesPolicyTrafficClassifiers);
    id v18 = (void *)objc_claimAutoreleasedReturnValue(value);
    id v20 = v18;
    if (v18 && xpc_get_type(v18) == (xpc_type_t)&_xpc_type_array)
    {
      id v90 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
      applier[0] = _NSConcreteStackBlock;
      applier[1] = 3221225472LL;
      applier[2] = sub_100058B38;
      applier[3] = &unk_1001AE808;
      id v133 = v1;
      id v21 = v90;
      id v134 = v21;
      xpc_array_apply(v20, applier);

      if (v1) {
        goto LABEL_23;
      }
    }

    else
    {
      id v21 = 0LL;
      if (v1)
      {
LABEL_23:
        id v22 = objc_getProperty(v1, v19, 16LL, 1);
        goto LABEL_24;
      }
    }

    id v22 = 0LL;
LABEL_24:
    BOOL v129 = xpc_dictionary_get_BOOL(v22, nrXPCKeyDevicePreferencesIsDeviceSetupInProgress);
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      id v25 = (id)qword_1001DC770;
      if (v1)
      {
        unsigned int v26 = (void *)v1[4];
        if (!v26)
        {
          id v27 = (_xpc_connection_s *)objc_getProperty(v1, v24, 8LL, 1);
          uint64_t v28 = xpc_connection_get_pid(v27);
          SEL v29 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v28);
          bzero(buffer, 0x400uLL);
          if ((int)v28 >= 1 && proc_pidpath(v28, buffer, 0x400u) >= 1 && buffer[0])
          {
            id v30 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  v28);

            SEL v29 = v30;
          }

          __int128 v31 = (void *)v1[4];
          v1[4] = v29;

          unsigned int v26 = (void *)v1[4];
        }

        id v32 = v26;
      }

      else
      {
        id v32 = 0LL;
      }

      __int128 v33 = (void *)_NRCopyPolicyTrafficClassifiersDescription(v21);
      _NRLogWithArgs( v25,  0LL,  "%s%.30s:%-4d Received policy traffic classifiers from %@ for device %@ : %@",  "",  "handleDevicePreferences",  1105LL,  v32,  v15,  v33);
    }

    if (v1) {
      id v34 = objc_getProperty(v1, v23, 16LL, 1);
    }
    else {
      id v34 = 0LL;
    }
    xpc_object_t v35 = xpc_dictionary_get_value(v34, nrXPCKeyDevicePreferencesBTLinkPreferences);
    id v36 = (void *)objc_claimAutoreleasedReturnValue(v35);
    uint64_t v37 = v36;
    if (v36 && xpc_get_type(v36) == (xpc_type_t)&_xpc_type_dictionary)
    {
      id v38 = +[NRLinkPreferences createFromEncodedXPCDict:]( &OBJC_CLASS___NRLinkPreferences,  "createFromEncodedXPCDict:",  v37);
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
      {
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        id v92 = (id)qword_1001DC770;
        if (v1)
        {
          uint64_t v93 = (void *)v1[4];
          if (!v93)
          {
            id v124 = v37;
            uint64_t v94 = (_xpc_connection_s *)objc_getProperty(v1, v91, 8LL, 1);
            uint64_t v95 = xpc_connection_get_pid(v94);
            id v96 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v95);
            bzero(buffer, 0x400uLL);
            if ((int)v95 >= 1 && proc_pidpath(v95, buffer, 0x400u) >= 1 && buffer[0])
            {
              id v97 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  v95);

              id v96 = v97;
            }

            uint64_t v98 = (void *)v1[4];
            v1[4] = v96;

            uint64_t v93 = (void *)v1[4];
            uint64_t v37 = v124;
          }

          id v99 = v93;
        }

        else
        {
          id v99 = 0LL;
        }

        _NRLogWithArgs( v92,  0LL,  "%s%.30s:%-4d Received link preferences from %@ for device %@ : %@",  "",  "handleDevicePreferences",  1113LL,  v99,  v15,  v38);
      }
    }

    else
    {
      id v38 = 0LL;
    }

    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v131 = (id *)(id)qword_1001DC870;
    objc_opt_self(&OBJC_CLASS___TerminusdXPCServer);
    if (qword_1001DC768 != -1) {
      dispatch_once(&qword_1001DC768, &stru_1001AE748);
    }
    id v39 = (id)qword_1001DC760;
    uint64_t v130 = v39;
    if (v39) {
      id v39 = objc_getProperty(v39, v40, 24LL, 1);
    }
    id v42 = v39;
    if (v1) {
      id v43 = objc_getProperty(v1, v41, 8LL, 1);
    }
    else {
      id v43 = 0LL;
    }
    unsigned int v44 = [v42 containsObject:v43];

    if (!v44)
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
      {
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        id v81 = (id)qword_1001DC770;
        if (v1)
        {
          id v82 = (void *)v1[4];
          if (!v82)
          {
            id v83 = v37;
            xpc_object_t v84 = (_xpc_connection_s *)objc_getProperty(v1, v80, 8LL, 1);
            uint64_t v85 = xpc_connection_get_pid(v84);
            id v86 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v85);
            bzero(buffer, 0x400uLL);
            if ((int)v85 >= 1 && proc_pidpath(v85, buffer, 0x400u) >= 1 && buffer[0])
            {
              int v87 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  v85);

              id v86 = v87;
            }

            id v88 = (void *)v1[4];
            v1[4] = v86;

            id v82 = (void *)v1[4];
            uint64_t v37 = v83;
          }

          id v89 = v82;
        }

        else
        {
          id v89 = 0LL;
        }

        _NRLogWithArgs( v81,  16LL,  "%s%.30s:%-4d Connection lost before applying preference for %@",  "",  "handleDevicePreferences",  1127LL,  v89);
      }

      goto LABEL_130;
    }

    id v126 = v20;
    id v127 = v38;
    if (v1)
    {
      id v46 = objc_getProperty(v1, v45, 8LL, 1);
      uint64_t v47 = (uint64_t)v131;
      sub_1000AF63C((uint64_t)v131, v38, v46, v15);
      id v49 = objc_getProperty(v1, v48, 8LL, 1);
    }

    else
    {
      uint64_t v47 = (uint64_t)v131;
      sub_1000AF63C((uint64_t)v131, v38, 0LL, v15);
      id v49 = 0LL;
    }

    uint64_t v50 = v21;
    BOOL v51 = v21;
    id v52 = v49;
    uint64_t v53 = v15;
    if (v47)
    {
      id v54 = sub_100146AFC();
      dispatch_assert_queue_V2((dispatch_queue_t)v54);

      id v128 = v52;
      if (v52)
      {
        if (v53)
        {
          uint64_t v55 = objc_claimAutoreleasedReturnValue([*(id *)(v47 + 216) objectForKeyedSubscript:v53]);
          if (v55)
          {
            uint64_t v56 = v55;
            int v123 = v37;
            id v121 = v51;
            id v57 = v51;
            id v58 = v52;
            dispatch_assert_queue_V2(*(dispatch_queue_t *)(v56 + 104));
            uint64_t v59 = *(void *)(v56 + 184);
            id v60 = v57;
            id v61 = v58;
            if (v59)
            {
              id v122 = v50;
              uint64_t v62 = v15;
              uint64_t v63 = *(dispatch_queue_s **)(v59 + 24);
              if (v63) {
                dispatch_assert_queue_V2(v63);
              }
              id v64 = sub_10010EE08(v61);
              int v66 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v59 + 16), v65);
              int IsLevelEnabled = _NRLogIsLevelEnabled(v66, 0LL);

              if (IsLevelEnabled)
              {
                int v69 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v59 + 16), v68);
                uint64_t v70 = (void *)_NRCopyPolicyTrafficClassifiersDescription(v60);
                _NRLogWithArgs( v69,  0LL,  "%s%.30s:%-4d Setting policy traffic classifiers for %@ : %@",  "",  "-[NRDevicePreferencesManager setPolicyTrafficClassifiers:forConnection:]",  264LL,  v64,  v70);
              }

              [*(id *)(v59 + 40) setObject:v60 forKeyedSubscript:v64];
              sub_10010E880(v59);

              id v15 = v62;
              uint64_t v50 = v122;
            }

            uint64_t v37 = v123;
            uint64_t v47 = (uint64_t)v131;
            BOOL v51 = v121;
          }

          else
          {
            uint64_t v100 = objc_alloc_init(&OBJC_CLASS___NRDOrphanedConnection);
            p_Class isa = (id *)&v100->super.isa;
            if (v100)
            {
              objc_storeStrong((id *)&v100->_nrUUID, v15);
              objc_storeStrong(p_isa + 2, v49);
            }

            [*(id *)(v47 + 232) addObject:p_isa];
            uint64_t v102 = (void *)objc_claimAutoreleasedReturnValue([p_isa description]);
            sub_10011BB18(0LL, 1022, 0LL, v102);

            uint64_t v56 = 0LL;
          }

          goto LABEL_113;
        }

        id v116 = sub_1000A2100();
        int v117 = _NRLogIsLevelEnabled(v116, 17LL);

        if (v117)
        {
          uint64_t v56 = (uint64_t)sub_1000A2100();
          _NRLogWithArgs(v56, 17LL, "%s called with null nrUUID");
          goto LABEL_113;
        }
      }

      else
      {
        id v114 = sub_1000A2100();
        int v115 = _NRLogIsLevelEnabled(v114, 17LL);

        if (v115)
        {
          uint64_t v56 = (uint64_t)sub_1000A2100();
          _NRLogWithArgs(v56, 17LL, "%s called with null connection");
LABEL_113:

          id v52 = v128;
        }
      }
    }

    if (v129)
    {
      id v21 = v50;
      if (v1) {
        id v104 = objc_getProperty(v1, v103, 8LL, 1);
      }
      else {
        id v104 = 0LL;
      }
      id v105 = v104;
      uint64_t v106 = v53;
      if (v131)
      {
        __int128 v107 = sub_100146AFC();
        dispatch_assert_queue_V2((dispatch_queue_t)v107);

        uint64_t v108 = objc_claimAutoreleasedReturnValue([v131[27] objectForKeyedSubscript:v106]);
        if (v108)
        {
          uint64_t v109 = (id *)v105;
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(v108 + 104));
          if (v109)
          {
            [*(id *)(v108 + 176) addObject:v109];
            if ([*(id *)(v108 + 176) count]) {
              sub_1000EF77C(v108, 1);
            }
          }

          else
          {
            SEL v125 = v37;
            if (qword_1001DC8F0 != -1) {
              dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
            }
            id v118 = (id)qword_1001DC8E8;
            int v119 = _NRLogIsLevelEnabled(v118, 17LL);

            if (v119)
            {
              if (qword_1001DC8F0 != -1) {
                dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
              }
              id v120 = (id)qword_1001DC8E8;
              _NRLogWithArgs( v120,  17LL,  "%s called with null connection",  "-[NRDDeviceConductor addDeviceSetupInProgressConnection:]");
            }

            uint64_t v37 = v125;
          }
        }

        else
        {
          uint64_t v111 = objc_alloc_init(&OBJC_CLASS___NRDOrphanedConnection);
          uint64_t v109 = (id *)&v111->super.isa;
          if (v111)
          {
            objc_storeStrong((id *)&v111->_nrUUID, v15);
            objc_storeStrong(v109 + 2, v104);
          }

          [v131[29] addObject:v109];
          id v112 = (void *)objc_claimAutoreleasedReturnValue([v109 description]);
          sub_10011BB18(0LL, 1022, 0LL, v112);
        }
      }

      id v20 = v126;
      id v38 = v127;
    }

    else
    {
      id v21 = v50;
      if (v1) {
        id v110 = objc_getProperty(v1, v103, 8LL, 1);
      }
      else {
        id v110 = 0LL;
      }
      id v20 = v126;
      id v38 = v127;
      sub_1000AF38C(v47, v110);
    }

LABEL_130:
    uint64_t v79 = 0LL;
LABEL_131:

    goto LABEL_132;
  }

  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v15 = (NSUUID *)(id)qword_1001DC770;
    if (v1)
    {
      id v21 = (NSMutableSet *)objc_getProperty(v1, v71, 16LL, 1);
      uint64_t v73 = (void *)v1[4];
      if (!v73)
      {
        uint64_t v74 = (_xpc_connection_s *)objc_getProperty(v1, v72, 8LL, 1);
        uint64_t v75 = xpc_connection_get_pid(v74);
        id v76 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v75);
        bzero(buffer, 0x400uLL);
        if ((int)v75 >= 1 && proc_pidpath(v75, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v77 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  v75);

          id v76 = v77;
        }

        id v78 = (void *)v1[4];
        v1[4] = v76;

        uint64_t v73 = (void *)v1[4];
      }

      id v20 = v73;
    }

    else
    {
      id v21 = 0LL;
      id v20 = 0LL;
    }

    _NRLogWithArgs( v15,  16LL,  "%s%.30s:%-4d No device identifier found in message %@ from %@",  "",  "handleDevicePreferences",  1067LL,  v21,  v20);
    uint64_t v79 = -2005LL;
    goto LABEL_131;
  }

  uint64_t v79 = -2005LL;
LABEL_132:

  return v79;
}

uint64_t sub_10005317C(void *a1)
{
  id v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v3 = (id)qword_1001DC770;
    if (v1)
    {
      id v4 = (void *)v1[4];
      if (!v4)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        BOOL v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          BOOL v7 = v8;
        }

        id v9 = (void *)v1[4];
        v1[4] = v7;

        id v4 = (void *)v1[4];
      }

      id v10 = v4;
    }

    else
    {
      id v10 = 0LL;
    }

    _NRLogWithArgs( v3,  0LL,  "%s%.30s:%-4d Received a link recommendation: %@",  "",  "handleCompanionLinkRecommendation",  1170LL,  v10);
  }

  return -2005LL;
}

uint64_t sub_10005334C(void *a1)
{
  id v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v4 = (id)qword_1001DC770;
    if (v1)
    {
      int v5 = (void *)v1[4];
      if (!v5)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v3, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v9 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v8 = v9;
        }

        id v10 = (void *)v1[4];
        v1[4] = v8;

        int v5 = (void *)v1[4];
      }

      id v11 = v5;
    }

    else
    {
      id v11 = 0LL;
    }

    _NRLogWithArgs(v4, 0LL, "%s%.30s:%-4d Sending babel routes to %@", "", "handleTestGetBabelRoutes", 1283LL, v11);
  }

  if (v1) {
    id v12 = objc_getProperty(v1, v2, 24LL, 1);
  }
  else {
    id v12 = 0LL;
  }
  id v13 = (const char *)nrXPCKeyBabelRoutes;
  id v14 = v12;
  xpc_dictionary_set_string(v14, v13, (const char *)[@"BABEL_NOT_SUPPORTED" UTF8String]);

  return 0LL;
}

uint64_t sub_100053574(void *a1)
{
  id Property = a1;
  id v4 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v3, 16LL, 1);
  }
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyNRUUID);
  if (!uuid)
  {
    id v36 = sub_10004579C();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v36, 16LL);

    if (IsLevelEnabled)
    {
      id v8 = sub_10004579C();
      id v15 = sub_10004580C(v4, v38);
      _NRLogWithArgs(v8, 16LL, "%s%.30s:%-4d Missing NRUUID from %@", "", "handleMeasureBTLatency", 1296LL, v15);
LABEL_19:

      uint64_t v16 = -2005LL;
      goto LABEL_49;
    }

uint64_t sub_100053BE0(void *a1)
{
  id Property = a1;
  id v3 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v2, 16LL, 1);
  }
  BOOL v4 = xpc_dictionary_get_BOOL(Property, nrXPCKeyWatchRoleSwitchAllowed);
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v6 = (id)qword_1001DC770;
    if (v3)
    {
      BOOL v7 = (void *)v3[4];
      if (!v7)
      {
        id v8 = (_xpc_connection_s *)objc_getProperty(v3, v5, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(v8);
        id v10 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v11 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v10 = v11;
        }

        id v12 = (void *)v3[4];
        void v3[4] = v10;

        BOOL v7 = (void *)v3[4];
      }

      id v13 = v7;
    }

    else
    {
      id v13 = 0LL;
    }

    _NRLogWithArgs( v6,  0LL,  "%s%.30s:%-4d Client %@ setting Watch Role switch allowed=%d",  "",  "handleSetWatchRoleSwitchAllowed",  883LL,  v13,  v4);
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v14 = (id)qword_1001DC870;
  if (v14)
  {
    if (v4) {
      sub_10009FCD0(0LL, @"EnableWatchRoleSwitch", &__kCFBooleanTrue);
    }
    else {
      sub_10009FF2C(0LL, @"EnableWatchRoleSwitch");
    }
  }

  return 0LL;
}

uint64_t sub_100053E5C(void *a1)
{
  id Property = a1;
  id v3 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v2, 16LL, 1);
  }
  BOOL v37 = xpc_dictionary_get_BOOL(Property, nrXPCKeyWiFiRangeExtensionAllowed);
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v5 = (id)qword_1001DC770;
    if (v3)
    {
      id v6 = (void *)v3[4];
      if (!v6)
      {
        BOOL v7 = (_xpc_connection_s *)objc_getProperty(v3, v4, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(v7);
        id v9 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v10 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v9 = v10;
        }

        id v11 = (void *)v3[4];
        void v3[4] = v9;

        id v6 = (void *)v3[4];
      }

      id v12 = v6;
    }

    else
    {
      id v12 = 0LL;
    }

    _NRLogWithArgs( v5,  0LL,  "%s%.30s:%-4d Client %@ setting Wi-Fi range extension allowed=%d",  "",  "handleSetWiFiRangeExtensionAllowed",  901LL,  v12,  v37);
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v36 = v3;
  id v13 = (id *)(id)qword_1001DC870;
  id v14 = v13;
  if (v13)
  {
    __int128 v40 = 0u;
    __int128 v41 = 0u;
    __int128 v38 = 0u;
    __int128 v39 = 0u;
    id v15 = v13[27];
    id v16 = [v15 countByEnumeratingWithState:&v38 objects:buffer count:16];
    if (v16)
    {
      id v17 = v16;
      uint64_t v18 = *(void *)v39;
      if (v37) {
        uint64_t v19 = "NO";
      }
      else {
        uint64_t v19 = "YES";
      }
      do
      {
        for (uint64_t i = 0LL; i != v17; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v39 != v18) {
            objc_enumerationMutation(v15);
          }
          uint64_t v27 = objc_claimAutoreleasedReturnValue( [v14[27] objectForKeyedSubscript:*(void *)(*((void *)&v38 + 1) + 8 * (void)i)]);
          uint64_t v28 = (void **)v27;
          if (v27)
          {
            dispatch_assert_queue_V2(*(dispatch_queue_t *)(v27 + 104));
            if (_NRIsAppleInternal(v29))
            {
              __int128 v31 = (void *)_NRCopyLogObjectForNRUUID(v28[12], v30);
              int IsLevelEnabled = _NRLogIsLevelEnabled(v31, 0LL);

              if (IsLevelEnabled)
              {
                id v34 = (void *)_NRCopyLogObjectForNRUUID(v28[12], v33);
                _NRLogWithArgs( v34,  0LL,  "%s%.30s:%-4d Setting Wi-Fi range extension allowed=%d",  "",  "-[NRDDeviceConductor setWiFiRangeExtensionAllowedForTesting:]",  2107,  v37);
              }

              id v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", !v37));
              sub_10009FCD0(v28[12], @"DisableRangeExtension", v21);
              sub_1000D4F78((uint64_t)v28, 1025, @"%s", v22, v23, v24, v25, v26, (uint64_t)v19);
            }
          }
        }

        id v17 = [v15 countByEnumeratingWithState:&v38 objects:buffer count:16];
      }

      while (v17);
    }
  }

  return 0LL;
}

uint64_t sub_100054248(void *a1)
{
  id Property = a1;
  id v3 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v2, 16LL, 1);
  }
  BOOL v4 = xpc_dictionary_get_BOOL(Property, nrXPCKeySimulateAltAccount);
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v6 = (id)qword_1001DC770;
    if (v3)
    {
      BOOL v7 = (void *)v3[4];
      if (!v7)
      {
        id v8 = (_xpc_connection_s *)objc_getProperty(v3, v5, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(v8);
        id v10 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v11 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v10 = v11;
        }

        id v12 = (void *)v3[4];
        void v3[4] = v10;

        BOOL v7 = (void *)v3[4];
      }

      id v13 = v7;
    }

    else
    {
      id v13 = 0LL;
    }

    _NRLogWithArgs( v6,  0LL,  "%s%.30s:%-4d Client %@ setting simulate alt-account=%d",  "",  "handleSetSimulateAltAccount",  892LL,  v13,  v4);
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v14 = (id)qword_1001DC870;
  if (v14)
  {
    id v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v4));
    sub_10009FCD0(0LL, @"SimulateAltAccount", v15);
  }

  return 0LL;
}

uint64_t sub_1000544CC(void *a1)
{
  id Property = a1;
  id v3 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v2, 16LL, 1);
  }
  string = xpc_dictionary_get_string(Property, nrXPCKeyTetheringBundleIDs);
  if (string)
  {
    id v5 = (id)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", string));
    id v6 = (void *)objc_claimAutoreleasedReturnValue([v5 componentsSeparatedByString:@","]);
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v8 = (id)qword_1001DC770;
    if (v3)
    {
      id v9 = (void *)v3[4];
      if (!v9)
      {
        id v10 = (_xpc_connection_s *)objc_getProperty(v3, v7, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(v10);
        id v12 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v12 = v13;
        }

        id v14 = (void *)v3[4];
        void v3[4] = v12;

        id v9 = (void *)v3[4];
      }

      id v15 = v9;
    }

    else
    {
      id v15 = 0LL;
    }

    _NRLogWithArgs( v8,  0LL,  "%s%.30s:%-4d Client %@ setting tethering bundle IDs to %@",  "",  "handleSetTetheringBundleIDs",  923LL,  v15,  v6);

LABEL_32:
LABEL_33:

    goto LABEL_34;
  }

  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v5 = (id)qword_1001DC770;
    if (v3)
    {
      id v17 = (void *)v3[4];
      if (!v17)
      {
        uint64_t v18 = (_xpc_connection_s *)objc_getProperty(v3, v16, 8LL, 1);
        uint64_t v19 = xpc_connection_get_pid(v18);
        id v20 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v19);
        bzero(buffer, 0x400uLL);
        if ((int)v19 >= 1 && proc_pidpath(v19, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v21 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  v19);

          id v20 = v21;
        }

        uint64_t v22 = (void *)v3[4];
        void v3[4] = v20;

        id v17 = (void *)v3[4];
      }

      id v8 = v17;
    }

    else
    {
      id v8 = 0LL;
    }

    _NRLogWithArgs( v5,  0LL,  "%s%.30s:%-4d Client %@ setting tethering bundle IDs to nil",  "",  "handleSetTetheringBundleIDs",  925LL,  v8);
    id v6 = 0LL;
    goto LABEL_32;
  }

  id v6 = 0LL;
LABEL_34:
  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v23 = (id)qword_1001DC870;
  id v24 = v6;
  if (v23)
  {
    if (v24) {
      sub_10009FCD0(0LL, @"TetheringBundleIDs", v24);
    }
    else {
      sub_10009FF2C(0LL, @"TetheringBundleIDs");
    }
  }

  return 0LL;
}

uint64_t sub_1000548E8(void *a1)
{
  id Property = a1;
  id v3 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v2, 16LL, 1);
  }
  BOOL v4 = xpc_dictionary_get_BOOL(Property, nrXPCKeyBlockSHOESTraffic);
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v6 = (id)qword_1001DC770;
    if (v3)
    {
      BOOL v7 = (void *)v3[4];
      if (!v7)
      {
        id v8 = (_xpc_connection_s *)objc_getProperty(v3, v5, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(v8);
        id v10 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && LOBYTE(buffer[0]))
        {
          id v11 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v10 = v11;
        }

        id v12 = (void *)v3[4];
        void v3[4] = v10;

        BOOL v7 = (void *)v3[4];
      }

      id v13 = v7;
    }

    else
    {
      id v13 = 0LL;
    }

    _NRLogWithArgs(v6, 0LL, "%s%.30s:%-4d Client %@ blocking SHOES Traffic", "", "handleBlockSHOESTraffic", 946LL, v13);
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v14 = (id)qword_1001DC870;
  id v15 = v14;
  if (v14 && _NRIsAppleInternal(v14))
  {
    if (v4)
    {
      objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
      id v16 = sub_100146AFC();
      dispatch_assert_queue_V2((dispatch_queue_t)v16);

      buffer[0] = xmmword_100156950;
      id v17 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", buffer, 16LL);
      id v18 = sub_10012D958((uint64_t)&OBJC_CLASS___NRDLocalDevice, v17, @"0");
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(v18);

      id v20 = (void *)objc_claimAutoreleasedReturnValue([v19 hostname]);
      id v21 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v20,  @"62742"));

      uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:",  v21,  64LL));
      id v23 = objc_alloc(&OBJC_CLASS___NEPolicy);
      id v24 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult drop](&OBJC_CLASS___NEPolicyResult, "drop"));
      *(void *)&buffer[0] = v22;
      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      *((void *)&buffer[0] + 1) = v25;
      uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", buffer, 2LL));
      id v27 = [v23 initWithOrder:10 result:v24 conditions:v26];

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v28 = (id)qword_1001DCB58;
      id v29 = sub_100120E44((uint64_t)v28, @"TESTING-NRDLD-Drop-SHOES", v27);
    }

    else
    {
      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v31 = (id)qword_1001DCB58;
      sub_10012114C((uint64_t)v31, @"TESTING-NRDLD-Drop-SHOES");
    }

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v32 = (id)qword_1001DCB58;
    uint64_t v33 = (id *)v32;
    if (v32)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v32 + 1));
      if (([v33[2] apply] & 1) == 0) {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v34,  v35,  v36,  v38);
      }
    }

    uint64_t v30 = 0LL;
  }

  else
  {
    uint64_t v30 = -2001LL;
  }

  return v30;
}

uint64_t sub_100054DDC(void *a1)
{
  id Property = a1;
  id v3 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v2, 16LL, 1);
  }
  BOOL v4 = xpc_dictionary_get_BOOL(Property, nrXPCKeyBlockIDSTraffic);
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v6 = (id)qword_1001DC770;
    if (v3)
    {
      BOOL v7 = (void *)v3[4];
      if (!v7)
      {
        id v8 = (_xpc_connection_s *)objc_getProperty(v3, v5, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(v8);
        id v10 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && LOBYTE(buffer[0]))
        {
          id v11 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v10 = v11;
        }

        id v12 = (void *)v3[4];
        void v3[4] = v10;

        BOOL v7 = (void *)v3[4];
      }

      id v13 = v7;
    }

    else
    {
      id v13 = 0LL;
    }

    _NRLogWithArgs(v6, 0LL, "%s%.30s:%-4d Client %@ blocking IDS Traffic", "", "handleBlockIDSTraffic", 955LL, v13);
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v14 = (id)qword_1001DC870;
  id v15 = v14;
  if (v14 && _NRIsAppleInternal(v14))
  {
    if (v4)
    {
      objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
      id v16 = sub_100146AFC();
      dispatch_assert_queue_V2((dispatch_queue_t)v16);

      buffer[0] = xmmword_100156950;
      id v17 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", buffer, 16LL);
      id v18 = sub_10012D958((uint64_t)&OBJC_CLASS___NRDLocalDevice, v17, @"0");
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(v18);

      int v69 = v19;
      id v20 = (void *)objc_claimAutoreleasedReturnValue([v19 hostname]);
      id v21 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v20,  @"61314"));

      uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition localAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "localAddress:prefix:",  v21,  64LL));
      id v23 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:",  v21,  64LL));
      id v24 = objc_alloc(&OBJC_CLASS___NEPolicy);
      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult drop](&OBJC_CLASS___NEPolicyResult, "drop"));
      *(void *)&buffer[0] = v23;
      uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      *((void *)&buffer[0] + 1) = v26;
      id v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", buffer, 2LL));
      id v28 = [v24 initWithOrder:10 result:v25 conditions:v27];

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v29 = (id)qword_1001DCB58;
      xpc_object_t v67 = v28;
      id v30 = sub_100120E44((uint64_t)v29, @"TESTING-NRDLD-Drop-IDS", v28);

      id v31 = objc_alloc(&OBJC_CLASS___NEPolicy);
      id v32 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult drop](&OBJC_CLASS___NEPolicyResult, "drop"));
      v73[0] = v22;
      uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      v73[1] = v33;
      uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v73, 2LL));
      id v35 = [v31 initWithOrder:10 result:v32 conditions:v34];

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v36 = (id)qword_1001DCB58;
      uint64_t v68 = v35;
      id v37 = sub_100120E44((uint64_t)v36, @"TESTING-NRDLD-Drop-IDS", v35);

      uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue([v69 hostname]);
      __int128 v39 = (void *)objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v38,  @"61315"));

      uint64_t v40 = objc_claimAutoreleasedReturnValue( +[NEPolicyCondition localAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "localAddress:prefix:",  v39,  64LL));
      uint64_t v41 = objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:",  v39,  64LL));

      id v42 = objc_alloc(&OBJC_CLASS___NEPolicy);
      id v43 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult drop](&OBJC_CLASS___NEPolicyResult, "drop"));
      int v66 = (void *)v41;
      v72[0] = v41;
      uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      v72[1] = v44;
      id v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v72, 2LL));
      id v46 = [v42 initWithOrder:10 result:v43 conditions:v45];

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v47 = (id)qword_1001DCB58;
      id v48 = sub_100120E44((uint64_t)v47, @"TESTING-NRDLD-Drop-IDS", v46);

      id v49 = objc_alloc(&OBJC_CLASS___NEPolicy);
      uint64_t v50 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult drop](&OBJC_CLASS___NEPolicyResult, "drop"));
      BOOL v51 = (void *)v40;
      v71[0] = v40;
      id v52 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      v71[1] = v52;
      uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v71, 2LL));
      id v54 = [v49 initWithOrder:10 result:v50 conditions:v53];

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v55 = (id)qword_1001DCB58;
      id v56 = sub_100120E44((uint64_t)v55, @"TESTING-NRDLD-Drop-IDS", v54);
    }

    else
    {
      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v58 = (id)qword_1001DCB58;
      sub_10012114C((uint64_t)v58, @"TESTING-NRDLD-Drop-IDS");
    }

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v59 = (id)qword_1001DCB58;
    id v60 = (id *)v59;
    if (v59)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v59 + 1));
      if (([v60[2] apply] & 1) == 0) {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v61,  v62,  v63,  v65);
      }
    }

    uint64_t v57 = 0LL;
  }

  else
  {
    uint64_t v57 = -2001LL;
  }

  return v57;
}

uint64_t sub_100055620(void *a1)
{
  id Property = a1;
  id v3 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v2, 16LL, 1);
  }
  BOOL v32 = xpc_dictionary_get_BOOL(Property, nrXPCKeySimulateWakePacket);
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v5 = (id)qword_1001DC770;
    if (v3)
    {
      id v6 = (void *)v3[4];
      if (!v6)
      {
        BOOL v7 = (_xpc_connection_s *)objc_getProperty(v3, v4, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(v7);
        id v9 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v10 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v9 = v10;
        }

        id v11 = (void *)v3[4];
        void v3[4] = v9;

        id v6 = (void *)v3[4];
      }

      id v12 = v6;
    }

    else
    {
      id v12 = 0LL;
    }

    id v13 = "stop";
    if (v32) {
      id v13 = "start";
    }
    _NRLogWithArgs( v5,  0LL,  "%s%.30s:%-4d Client %@ requesting to %s simulating wake packets",  "",  "handleSimulateWakePacket",  965LL,  v12,  v13);
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v14 = (id)qword_1001DC870;
  id v15 = v14;
  if (v14 && _NRIsAppleInternal(v14))
  {
    uint64_t v16 = 0LL;
    v15[9] = v32;
  }

  else
  {
    uint64_t v16 = -2001LL;
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v17 = (unsigned __int8 *)(id)qword_1001DC870;
  if (!v17)
  {
    id v20 = 0LL;
LABEL_43:

    goto LABEL_44;
  }

  int v18 = v17[10];

  if (v18)
  {
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v29 = v15;
    id v30 = v3;
    uint64_t v19 = (id *)(id)qword_1001DC870;
    id v20 = v19;
    if (v19)
    {
      __int128 v35 = 0u;
      __int128 v36 = 0u;
      __int128 v33 = 0u;
      __int128 v34 = 0u;
      id obj = v19[27];
      id v21 = [obj countByEnumeratingWithState:&v33 objects:buffer count:16];
      if (v21)
      {
        id v22 = v21;
        uint64_t v23 = *(void *)v34;
        do
        {
          for (uint64_t i = 0LL; i != v22; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v34 != v23) {
              objc_enumerationMutation(obj);
            }
            uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue( [v20[27] objectForKeyedSubscript:*(void *)(*((void *)&v33 + 1) + 8 * (void)i)]);
            if (v25)
            {
              uint64_t v26 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
              id v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v32));
              -[NSMutableDictionary setObject:forKeyedSubscript:]( v26,  "setObject:forKeyedSubscript:",  v27,  @"test-wake-pkt");

              sub_1000EFBC8((uint64_t)v25, v26);
            }
          }

          id v22 = [obj countByEnumeratingWithState:&v33 objects:buffer count:16];
        }

        while (v22);
      }
    }

    id v3 = v30;
    id v15 = v29;
    goto LABEL_43;
  }

uint64_t sub_100055A44(void *a1)
{
  id v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v3 = (id)qword_1001DC770;
    if (v1)
    {
      BOOL v4 = (void *)v1[4];
      if (!v4)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        BOOL v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          BOOL v7 = v8;
        }

        id v9 = (void *)v1[4];
        v1[4] = v7;

        BOOL v4 = (void *)v1[4];
      }

      id v10 = v4;
    }

    else
    {
      id v10 = 0LL;
    }

    _NRLogWithArgs( v3,  0LL,  "%s%.30s:%-4d Client %@ requesting to test NRLinkDirectorMessage",  "",  "handleTestNRLinkDirectorMessage",  976LL,  v10);
  }

  id v11 = sub_100131EA8((uint64_t)&OBJC_CLASS___NRDLocalDevice);
  id v12 = v11;
  if (v11)
  {
    id v13 = v11;
    objc_opt_self(&OBJC_CLASS___NRLinkDirectorMessage);
    if (qword_1001DC718 != -1) {
      dispatch_once(&qword_1001DC718, &stru_1001AE4C8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC710, 0LL))
    {
      if (qword_1001DC718 != -1) {
        dispatch_once(&qword_1001DC718, &stru_1001AE4C8);
      }
      _NRLogWithArgs( qword_1001DC710,  0LL,  "%s%.30s:%-4d Testing NRLinkDirectorMessage send/receive",  "",  "+[NRLinkDirectorMessage testForNRUUID:]",  1237);
    }

    sub_100024AD8((uint64_t)&OBJC_CLASS___NRLinkDirectorMessage, v13);
    id v14 = sub_100021C64(objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage), v13);
    char v15 = sub_100023FAC((uint64_t)&OBJC_CLASS___NRLinkDirectorMessage, v14);
    sub_100024AD8((uint64_t)&OBJC_CLASS___NRLinkDirectorMessage, v13);
    uint64_t v16 = sub_100021AF8(objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage), v13, 1);

    char v17 = sub_100023FAC((uint64_t)&OBJC_CLASS___NRLinkDirectorMessage, v16);
    sub_100024AD8((uint64_t)&OBJC_CLASS___NRLinkDirectorMessage, v13);
    int v18 = sub_100021AF8(objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage), v13, 2);

    char v19 = sub_100023FAC((uint64_t)&OBJC_CLASS___NRLinkDirectorMessage, v18);
    sub_100024AD8((uint64_t)&OBJC_CLASS___NRLinkDirectorMessage, v13);

    if (v1) {
      id v21 = objc_getProperty(v1, v20, 24LL, 1);
    }
    else {
      id v21 = 0LL;
    }
    xpc_dictionary_set_BOOL(v21, nrXPCKeyTestNRLinkDirectorMessage, v15 & v17 & v19);
    uint64_t v22 = 0LL;
  }

  else
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      id v24 = (id)qword_1001DC770;
      if (v1)
      {
        id v26 = objc_getProperty(v1, v23, 16LL, 1);
        id v27 = (void *)v1[4];
        if (!v27)
        {
          id v28 = (_xpc_connection_s *)objc_getProperty(v1, v25, 8LL, 1);
          uint64_t v29 = xpc_connection_get_pid(v28);
          id v30 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v29);
          bzero(buffer, 0x400uLL);
          if ((int)v29 >= 1 && proc_pidpath(v29, buffer, 0x400u) >= 1 && buffer[0])
          {
            id v31 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  v29);

            id v30 = v31;
          }

          BOOL v32 = (void *)v1[4];
          v1[4] = v30;

          id v27 = (void *)v1[4];
        }

        id v33 = v27;
      }

      else
      {
        id v26 = 0LL;
        id v33 = 0LL;
      }

      _NRLogWithArgs( v24,  16LL,  "%s%.30s:%-4d No testing identifier found for message %@ from %@",  "",  "handleTestNRLinkDirectorMessage",  979LL,  v26,  v33);
    }

    uint64_t v22 = -2011LL;
  }

  return v22;
}

uint64_t sub_100055F64(void *a1)
{
  id Property = a1;
  id v3 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v2, 16LL, 1);
  }
  BOOL v5 = xpc_dictionary_get_BOOL(Property, nrXPCKeyFixedInterfaceModeSetEnabled);
  if (v3) {
    id v6 = objc_getProperty(v3, v4, 16LL, 1);
  }
  else {
    id v6 = 0LL;
  }
  string = xpc_dictionary_get_string(v6, nrXPCKeyFixedInterfaceModeInterfaceName);
  if (v3) {
    id v9 = objc_getProperty(v3, v7, 16LL, 1);
  }
  else {
    id v9 = 0LL;
  }
  id v11 = xpc_dictionary_get_string(v9, nrXPCKeyFixedInterfaceModePeerAddress);
  if (v3) {
    id v12 = objc_getProperty(v3, v10, 16LL, 1);
  }
  else {
    id v12 = 0LL;
  }
  id v13 = xpc_dictionary_get_string(v12, nrXPCKeyIDSDeviceID);
  id v14 = v13;
  if (!v5)
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      id v18 = (id)qword_1001DC770;
      if (v3)
      {
        id v27 = (void *)v3[4];
        if (!v27)
        {
          id v28 = (_xpc_connection_s *)objc_getProperty(v3, v26, 8LL, 1);
          uint64_t pid = xpc_connection_get_pid(v28);
          id v30 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
          bzero(buffer, 0x400uLL);
          if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
          {
            id v31 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

            id v30 = v31;
          }

          BOOL v32 = (void *)v3[4];
          void v3[4] = v30;

          id v27 = (void *)v3[4];
        }

        id v25 = v27;
      }

      else
      {
        id v25 = 0LL;
      }

      _NRLogWithArgs( v18,  0LL,  "%s%.30s:%-4d Client %@ setting fixed-interface mode disabled",  "",  "handleSetFixedInterfaceMode",  1006LL,  v25);
      goto LABEL_45;
    }

LABEL_52:
      goto LABEL_53;
    }

  -[NSMutableArray addObject:](v8, "addObject:", @"NSURLPathDataTransferComplete");
  if ((reason & 0x200000000000000LL) == 0)
  {
LABEL_27:
    if ((reason & 0x400000000000000LL) == 0) {
      goto LABEL_28;
    }
    goto LABEL_54;
  }

    dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
    goto LABEL_22;
  }
      }

      id v28 = [v26 countByEnumeratingWithState:&v40 objects:v52 count:16];
    }

    while (v28);
  }
}

LABEL_58:
    sub_1000AF07C((uint64_t)v33, v5, v34, v35, 0LL);
    if (!v11) {
      goto LABEL_53;
    }
    goto LABEL_52;
  }

  if (string) {
    BOOL v15 = 0;
  }
  else {
    BOOL v15 = v11 == 0LL;
  }
  if (!v15 || v13 != 0LL)
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      id v18 = (id)qword_1001DC770;
      if (v3)
      {
        char v19 = (void *)v3[4];
        if (!v19)
        {
          id v20 = (_xpc_connection_s *)objc_getProperty(v3, v17, 8LL, 1);
          uint64_t v21 = xpc_connection_get_pid(v20);
          uint64_t v22 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v21);
          bzero(buffer, 0x400uLL);
          if ((int)v21 >= 1 && proc_pidpath(v21, buffer, 0x400u) >= 1 && buffer[0])
          {
            uint64_t v23 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  v21);

            uint64_t v22 = v23;
          }

          id v24 = (void *)v3[4];
          void v3[4] = v22;

          char v19 = (void *)v3[4];
        }

        id v25 = v19;
      }

      else
      {
        id v25 = 0LL;
      }

      _NRLogWithArgs( v18,  0LL,  "%s%.30s:%-4d Client %@ setting fixed-interface mode enabled: %d, interface: %s, peer address: %s",  "",  "handleSetFixedInterfaceMode",  1004LL,  v25,  1LL,  string,  v11);
LABEL_45:

      goto LABEL_46;
    }

    goto LABEL_46;
  }

  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    _NRLogWithArgs( qword_1001DC770,  16LL,  "%s%.30s:%-4d No interface name/address/idsDeviceID for fixed-interface mode",  "",  "handleSetFixedInterfaceMode",  1000);
  }

  uint64_t v37 = -2005LL;
LABEL_67:

  return v37;
}

                id v88 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v2 + 32), v61);
                LODWORD(v82) = _NRLogIsLevelEnabled(v88, 17LL);

                if ((_DWORD)v82)
                {
                  id v90 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v2 + 32), v89);
                  _NRLogWithArgs( v90,  17LL,  "Attempting to register fallback path controller with invalid fallback interface");

                  id v52 = 0LL;
                  LOBYTE(v82) = 0;
                }

                else
                {
                  id v52 = 0LL;
                }

                goto LABEL_64;
              }
            }

            else
            {
              id v59 = sub_1000A2100();
              id v60 = _NRLogIsLevelEnabled(v59, 17LL);

              if (v60)
              {
                uint64_t v50 = sub_1000A2100();
                _NRLogWithArgs( v50,  17LL,  "%s called with null nrUUID",  "-[NRLinkDirector copyCatchAllInterfaceNameForNRUUID:]");
                goto LABEL_46;
              }
            }
          }

          goto LABEL_58;
        }
      }

      else
      {
        uint64_t v53 = sub_10005E8D4();
        id v54 = _NRLogIsLevelEnabled(v53, 16LL);

        if (v54)
        {
          id v55 = sub_10005E8D4();
          _NRLogWithArgs( v55,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRCompanionProxyAgent registerAgent]",  218);
        }

        id v2 = _os_log_pack_size(12LL);
        id v26 = (id *)((char *)&v107 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL));
        id v56 = __error();
        uint64_t v57 = _os_log_pack_fill( v26,  v2,  *v56,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
        *(_DWORD *)uint64_t v57 = 136446210;
        *(void *)(v57 + 4) = "-[NRCompanionProxyAgent registerAgent]";
        id v58 = sub_10005E8D4();
        _NRLogAbortWithPack(v58, v26);
      }

      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      goto LABEL_34;
    }

    id v27 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v2 + 32), v12);
    id v28 = _NRLogIsLevelEnabled(v27, 16LL);

    if (v28)
    {
      id v26 = (id *)_NRCopyLogObjectForNRUUID(*(void *)(v2 + 32), v29);
      _NRLogWithArgs(v26, 16LL, "%s%.30s:%-4d unable register network agent");
      goto LABEL_19;
    }
  }

  else
  {
    uint64_t v23 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v2 + 32), v10);
    id v24 = _NRLogIsLevelEnabled(v23, 16LL);

    if (v24)
    {
      id v26 = (id *)_NRCopyLogObjectForNRUUID(*(void *)(v2 + 32), v25);
      _NRLogWithArgs(v26, 16LL, "%s%.30s:%-4d unable to allocate registration object");
LABEL_19:
    }
  }
}
}

            [v4 start];
            goto LABEL_59;
          case 2u:
            __int128 v34 = objc_opt_class(&OBJC_CLASS___NRLinkWiFi);
            if ((objc_opt_isKindOfClass(v4, v34) & 1) == 0)
            {
              id v64 = (unsigned __int8 *)sub_1000A2C08((uint64_t)&OBJC_CLASS___NRLinkDirector);
              if (!v64 || (int v66 = v64[8], v64, !v66))
              {
                xpc_object_t v67 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v65);
                uint64_t v68 = _NRLogIsLevelEnabled(v67, 17LL);

                if (v68)
                {
                  StringFromNRLinkType = self->_nrUUID;
                  id v31 = (void *)_NRCopyLogObjectForNRUUID(StringFromNRLinkType, v69);
                  _NRLogWithArgs(v31, 17LL, "Bad link %@", v4);
LABEL_27:
                }

                goto LABEL_59;
              }
            }

            __int128 v35 = (char *)v4;
            if ([v35 subtype] == 101)
            {
              dispatch_assert_queue_V2((dispatch_queue_t)self->_queue);
              if (self->_isAlwaysReachableOverWiFi)
              {
                __int128 v36 = objc_alloc_init(&OBJC_CLASS___NRLinkDirectorRequest);
                uint64_t v37 = v36;
                if (v36)
                {
                  v36->_xpc_type_t type = 1;
                  v36->_requiredLinkType = 1;
                  *(_WORD *)&v36->_attemptImmediately = 257;
                }

                sub_1000D312C((uint64_t)self, v36);
              }
            }

            if (self->_isPreferWiFiProvider && !self->_isCoalescingLinkUpgradeRequest)
            {
              if (self->_supportsNAN || self->_supportsAWDL) {
                uint64_t v38 = 5000000000LL;
              }
              else {
                uint64_t v38 = 1000000000LL;
              }
              self->_isCoalescingLinkUpgradeRequest = 1;
              __int128 v39 = dispatch_time(0x8000000000000000LL, v38);
              queue = self->_queue;
              block[0] = _NSConcreteStackBlock;
              block[1] = 3221225472LL;
              block[2] = sub_1000EC2EC;
              block[3] = &unk_1001B0A88;
              void block[4] = self;
              dispatch_after(v39, (dispatch_queue_t)queue, block);
            }

            if ([v35 subtype] == 102)
            {
              if (self->_isCompanionLink) {
                sub_1000D8670((uint64_t)self);
              }
              else {
                sub_1000D9FE0((uint64_t)self);
              }
              goto LABEL_43;
            }

            if ([v35 subtype] == 101)
            {
              if (self->_isAlwaysReachableOverWiFi || !self->_isCompanionLink)
              {
LABEL_48:
                [v35 start];

LABEL_59:
                sub_1000E9E10((uint64_t)self);
                sub_1000DAF94((uint64_t)self);
                goto LABEL_60;
              }

              id v54 = (unsigned __int8 *)sub_1000A2C08((uint64_t)&OBJC_CLASS___NRLinkDirector);
              if (v54)
              {
                id v56 = v54[8];

                if (v56)
                {
                  uint64_t v57 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v55);
                  id v58 = _NRLogIsLevelEnabled(v57, 0LL);

                  if (v58)
                  {
                    id v60 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v59);
                    _NRLogWithArgs( v60,  0LL,  "%s%.30s:%-4d Starting link for fixed interface mode",  "",  "-[NRDDeviceConductor linkIsAvailable:]",  5605);
                  }

                  goto LABEL_48;
                }
              }

  uint64_t v57 = *(void *)(a1 + 32);
  if (!v57) {
    goto LABEL_97;
  }
LABEL_59:
  if (!*(_BYTE *)(v57 + 10)) {
    goto LABEL_97;
  }
  uint64_t v63 = sub_100020CF0(*(void *)(a1 + 40));
  id v64 = *(void *)(a1 + 32);
  if (v64)
  {
    if (v63 != *(void *)(v64 + 344)) {
      goto LABEL_97;
    }
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v64 + 104));
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    uint64_t v65 = (id)qword_1001DC870;
    int v66 = v65;
    if (v65) {
      xpc_object_t v67 = (void *)*((void *)v65 + 6);
    }
    else {
      xpc_object_t v67 = 0LL;
    }
    uint64_t v68 = v67;

    if (v68 && (int v69 = v68[14]) != 0) {
      uint64_t v70 = *(_DWORD *)(v69 + 12);
    }
    else {
      uint64_t v70 = 0;
    }
  }

  else
  {
    if (v63) {
      goto LABEL_97;
    }
    uint64_t v68 = 0LL;
    uint64_t v70 = 0;
  }

  id v71 = *(void **)(a1 + 40);
  if (v71)
  {
    uint64_t v72 = sub_1000229A0(v71, 10LL);
    uint64_t v73 = (NSMutableArray *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v72, "firstObject"));

    if (v73 && -[NSMutableArray length](v73, "length"))
    {
      LOBYTE(v235) = 0;
      -[NSMutableArray getBytes:length:](v73, "getBytes:length:", &v235, 1LL);
      else {
        uint64_t v74 = &__kCFBooleanFalse;
      }

      if ([v74 BOOLValue])
      {
        uint64_t v75 = *(void **)(a1 + 40);
        if (v75) {
          uint64_t v73 = sub_1000234F4(v75, v70, 1);
        }
        else {
          uint64_t v73 = 0LL;
        }
        id v76 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v73, "firstObject"));
        id v77 = *(void *)(a1 + 32);
        if (v77)
        {
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(v77 + 104));
          objc_opt_self(&OBJC_CLASS___NRLinkDirector);
          if (qword_1001DC878 != -1) {
            dispatch_once(&qword_1001DC878, &stru_1001AEED0);
          }
          id v78 = (id)qword_1001DC870;
          uint64_t v79 = v78;
          if (v78) {
            int v80 = (void *)*((void *)v78 + 6);
          }
          else {
            int v80 = 0LL;
          }
          id v81 = v80;

          id v82 = *(void *)(a1 + 32);
          if (v82) {
            id v83 = *(void **)(v82 + 96);
          }
          else {
            id v83 = 0LL;
          }
        }

        else
        {
          id v81 = 0LL;
          id v83 = 0LL;
        }

        sub_100140BC8(v81, v76, v83);

        sub_1000D4F78( *(void *)(a1 + 32),  1040,  @"%@ received AWDL address update: %@",  v84,  v85,  v86,  v87,  v88,  *(void *)(a1 + 32));
      }

      else
      {
        id v89 = *(void *)(a1 + 32);
        if (v89)
        {
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(v89 + 104));
          objc_opt_self(&OBJC_CLASS___NRLinkDirector);
          if (qword_1001DC878 != -1) {
            dispatch_once(&qword_1001DC878, &stru_1001AEED0);
          }
          id v90 = (id)qword_1001DC870;
          id v91 = v90;
          if (v90) {
            id v92 = (void *)*((void *)v90 + 6);
          }
          else {
            id v92 = 0LL;
          }
          uint64_t v73 = v92;

          uint64_t v93 = *(void *)(a1 + 32);
          if (v93) {
            uint64_t v94 = *(void **)(v93 + 96);
          }
          else {
            uint64_t v94 = 0LL;
          }
        }

        else
        {
          uint64_t v73 = 0LL;
          uint64_t v94 = 0LL;
        }

        sub_100140BC8((id *)&v73->super.super.isa, 0LL, v94);
      }
    }

    else
    {
      uint64_t v74 = 0LL;
    }
  }

  else
  {
    uint64_t v74 = 0LL;
  }

LABEL_97:
  uint64_t v95 = sub_100020CF0(*(void *)(a1 + 40));
  id v96 = *(void *)(a1 + 32);
  if (v96)
  {
    if (v95 != *(void *)(v96 + 352)) {
      goto LABEL_137;
    }
LABEL_99:
    id v97 = *(void **)(a1 + 40);
    if (!v97)
    {
      id v99 = 0LL;
      goto LABEL_136;
    }

    uint64_t v98 = sub_1000229A0(v97, 15LL);
    id v99 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v98, "firstObject"));

    if (!v99)
    {
LABEL_136:

      id v96 = *(void *)(a1 + 32);
      goto LABEL_137;
    }

    uint64_t v100 = -[NSString initWithData:encoding:](objc_alloc(&OBJC_CLASS___NSString), "initWithData:encoding:", v99, 4LL);
    uint64_t v101 = v100;
    if (!v100)
    {
LABEL_135:

      goto LABEL_136;
    }

    uint64_t v102 = *(void *)(a1 + 32);
    _NRIsAppleInternal(v100);
    sub_1000D4F78(v102, 1051, @"%@ received country code update: %@", v103, v104, v105, v106, v107, v102);
    if (!*(void *)(a1 + 32))
    {
      uint64_t v233 = v101;
      uint64_t v111 = 0LL;
      goto LABEL_134;
    }

    dispatch_assert_queue_V2(*(dispatch_queue_t *)(*(void *)(a1 + 32) + 104LL));
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    uint64_t v108 = (id)qword_1001DC870;
    uint64_t v109 = v108;
    if (v108) {
      id v110 = (void *)*((void *)v108 + 6);
    }
    else {
      id v110 = 0LL;
    }
    uint64_t v111 = v110;

    id v112 = v101;
    if (!v111) {
      goto LABEL_134;
    }
    uint64_t v113 = v112;
    id v114 = (dispatch_queue_s *)v111[3];
    dispatch_assert_queue_V2(v114);

    if (-[NSString compare:options:](v113, "compare:options:", @"XZ", 1LL) == NSOrderedSame)
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCBF0, 17LL))
      {
        if (qword_1001DCBF8 != -1) {
          dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
        }
        _NRLogWithArgs(qword_1001DCBF0, 17LL, "received invalid country code");
      }

      goto LABEL_134;
    }

    int v115 = v111[22];
    v254 = 0LL;
    id v255 = &v254;
    int v256 = 0x2020000000LL;
    uint64_t v257 = 0;
    uint64_t v250 = 0LL;
    v251 = &v250;
    int v252 = 0x2020000000LL;
    uint64_t v253 = 0;
    int v244 = 0LL;
    uint64_t v245 = &v244;
    v246 = 0x3032000000LL;
    id v247 = sub_10013D160;
    uint64_t v248 = sub_10013D170;
    uint64_t v249 = 0LL;
    id v235 = _NSConcreteStackBlock;
    uint64_t v236 = 3221225472LL;
    uint64_t v237 = sub_100142BAC;
    uint64_t v238 = &unk_1001B0838;
    v234 = v115;
    v239 = v234;
    uint64_t v241 = &v254;
    int v240 = v113;
    v242 = &v244;
    id v243 = &v250;
    if (sub_10013D090((uint64_t)&OBJC_CLASS___NRLinkManagerWiFi, &v235)
      || !*((_BYTE *)v255 + 24) && !*((_BYTE *)v251 + 24)
      || v245[5])
    {
      id v231 = sub_10013A600();
      int v232 = _NRLogIsLevelEnabled(v231, 16LL);

      if (!v232) {
        goto LABEL_133;
      }
      id v118 = sub_10013A600();
      _NRLogWithArgs( v118,  16LL,  "%s%.30s:%-4d failed to set peer country code %@",  "",  "-[NRLinkManagerWiFi setPeerCountryCodeIfApplicable:]",  1962LL,  v245[5]);
    }

    else if (*((_BYTE *)v251 + 24))
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      id v116 = (id)qword_1001DCBF0;
      int v117 = _NRLogIsLevelEnabled(v116, 1LL);

      if ((v117 & 1) == 0) {
        goto LABEL_133;
      }
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      id v118 = (id)qword_1001DCBF0;
      _NRLogWithArgs( v118,  1LL,  "%s%.30s:%-4d not setting companion country code as local country code is available",  "",  "-[NRLinkManagerWiFi setPeerCountryCodeIfApplicable:]",  1957);
    }

    else
    {
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      int v119 = (id)qword_1001DCBF0;
      id v120 = _NRLogIsLevelEnabled(v119, 1LL);

      if (!v120) {
        goto LABEL_133;
      }
      if (qword_1001DCBF8 != -1) {
        dispatch_once(&qword_1001DCBF8, &stru_1001B08D0);
      }
      id v118 = (id)qword_1001DCBF0;
      _NRLogWithArgs( v118,  1LL,  "%s%.30s:%-4d successfully set peer country code",  "",  "-[NRLinkManagerWiFi setPeerCountryCodeIfApplicable:]",  1959);
    }

LABEL_133:
    _Block_object_dispose(&v244, 8);

    _Block_object_dispose(&v250, 8);
    _Block_object_dispose(&v254, 8);

LABEL_134:
    goto LABEL_135;
  }

  if (!v95) {
    goto LABEL_99;
  }
LABEL_137:
  if (v96 && *(_BYTE *)(v96 + 8))
  {
    LOBYTE(v236) = 0;
    id v235 = 0LL;
    id v121 = *(void **)(a1 + 40);
    if (v121)
    {
      id v122 = sub_1000229A0(v121, 13LL);
      int v123 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v122, "firstObject"));

      if (v123)
      {
        [v123 getBytes:&v235 length:9];
        if ((v236 & 1) == 0)
        {
          id v124 = 0LL;
          goto LABEL_226;
        }

        id v124 = (void *)objc_claimAutoreleasedReturnValue( +[NSNumber numberWithUnsignedChar:]( &OBJC_CLASS___NSNumber,  "numberWithUnsignedChar:",  v235));
        id v131 = v123;
        if (!v124)
        {
LABEL_223:
          int v123 = v131;
          goto LABEL_226;
        }

uint64_t sub_1000564F0(void *a1)
{
  id Property = a1;
  BOOL v4 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v3, 16LL, 1);
  }
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyDeviceIdentifier);
  if (uuid)
  {
    id v6 = uuid;
    if (uuid_is_null(uuid))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC770, 17LL))
      {
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        id v8 = (id)qword_1001DC770;
        if (v4)
        {
          id v9 = (void *)v4[4];
          if (!v9)
          {
            id v10 = (_xpc_connection_s *)objc_getProperty(v4, v7, 8LL, 1);
            uint64_t pid = xpc_connection_get_pid(v10);
            id v12 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
            bzero(v40, 0x400uLL);
            if ((int)pid >= 1 && proc_pidpath(pid, v40, 0x400u) >= 1 && v40[0])
            {
              id v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v40,  pid);

              id v12 = v13;
            }

            id v14 = (void *)v4[4];
            v4[4] = v12;

            id v9 = (void *)v4[4];
          }

          id v15 = v9;
        }

        else
        {
          id v15 = 0LL;
        }

        _NRLogWithArgs(v8, 17LL, "All-zero NRUUID from %@", v15);
        goto LABEL_19;
      }

uint64_t sub_1000569E0(void *a1)
{
  id v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v3 = (id)qword_1001DC770;
    if (v1)
    {
      BOOL v4 = (void *)v1[4];
      if (!v4)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        BOOL v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          BOOL v7 = v8;
        }

        id v9 = (void *)v1[4];
        v1[4] = v7;

        BOOL v4 = (void *)v1[4];
      }

      id v10 = v4;
    }

    else
    {
      id v10 = 0LL;
    }

    _NRLogWithArgs( v3,  0LL,  "%s%.30s:%-4d %@ requested a refresh of the companion link agent generation",  "",  "handleRefreshCompanionProxyAgent",  1339LL,  v10);
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v11 = (id *)(id)qword_1001DC870;
  if (v11)
  {
    id v28 = v11;
    id v12 = (void *)objc_claimAutoreleasedReturnValue([v11[27] allValues]);
    __int128 v29 = 0u;
    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v32 = 0u;
    id v13 = v12;
    id v14 = [v13 countByEnumeratingWithState:&v29 objects:v38 count:16];
    if (v14)
    {
      id v16 = v14;
      uint64_t v17 = *(void *)v30;
      do
      {
        for (uint64_t i = 0LL; i != v16; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v30 != v17) {
            objc_enumerationMutation(v13);
          }
          uint64_t v19 = *(void *)(*((void *)&v29 + 1) + 8LL * (void)i);
          if (v19)
          {
            if (*(_BYTE *)(v19 + 13))
            {
              __int128 v35 = 0u;
              __int128 v36 = 0u;
              __int128 v33 = 0u;
              __int128 v34 = 0u;
              id v20 = *(id *)(v19 + 112);
              id v21 = [v20 countByEnumeratingWithState:&v33 objects:buffer count:16];
              if (v21)
              {
                id v22 = v21;
                uint64_t v23 = *(void *)v34;
                do
                {
                  for (j = 0LL; j != v22; j = (char *)j + 1)
                  {
                    if (*(void *)v34 != v23) {
                      objc_enumerationMutation(v20);
                    }
                    [*(id *)(*((void *)&v33 + 1) + 8 * (void)j) refreshCompanionProxyAgent];
                  }

                  id v22 = [v20 countByEnumeratingWithState:&v33 objects:buffer count:16];
                }

                while (v22);
              }

              goto LABEL_22;
            }

            id v25 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v19 + 96), v15);
            int IsLevelEnabled = _NRLogIsLevelEnabled(v25, 1LL);

            if (IsLevelEnabled)
            {
              id v20 = (id)_NRCopyLogObjectForNRUUID(*(void *)(v19 + 96), v15);
              _NRLogWithArgs( v20,  1LL,  "%s%.30s:%-4d Ignoring refreshCompanionProxyAgent as conductor is disabled",  "",  "-[NRDDeviceConductor refreshCompanionProxyAgent]",  2612);
LABEL_22:

              continue;
            }
          }
        }

        id v16 = [v13 countByEnumeratingWithState:&v29 objects:v38 count:16];
      }

      while (v16);
    }

    id v11 = v28;
  }

  return 0LL;
}

uint64_t sub_100056DB8(void *a1)
{
  id Property = a1;
  BOOL v4 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v3, 16LL, 1);
  }
  uuid = xpc_dictionary_get_uuid(Property, nrXPCKeyDeviceIdentifier);
  if (uuid)
  {
    id v6 = uuid;
    if (uuid_is_null(uuid))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC770, 17LL))
      {
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        id v8 = (id)qword_1001DC770;
        if (v4)
        {
          id v9 = (void *)v4[4];
          if (!v9)
          {
            id v10 = (_xpc_connection_s *)objc_getProperty(v4, v7, 8LL, 1);
            uint64_t pid = xpc_connection_get_pid(v10);
            id v12 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
            bzero(v123, 0x400uLL);
            if ((int)pid >= 1 && proc_pidpath(pid, v123, 0x400u) >= 1 && v123[0])
            {
              id v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v123,  pid);

              id v12 = v13;
            }

            id v14 = (void *)v4[4];
            v4[4] = v12;

            id v9 = (void *)v4[4];
          }

          id v15 = v9;
        }

        else
        {
          id v15 = 0LL;
        }

        _NRLogWithArgs(v8, 17LL, "All-zero NRUUID from %@", v15);
        goto LABEL_19;
      }

LABEL_118:
      uint64_t v16 = -2005LL;
      goto LABEL_119;
    }

    uint64_t v17 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v6);
    if (v17)
    {
      id v1 = v17;
      p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
      if (qword_1001DC778 == -1) {
        goto LABEL_22;
      }
    }

    else
    {
      id v93 = sub_10004579C();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v93, 16LL);

      if (IsLevelEnabled)
      {
        id v95 = sub_10004579C();
        _NRLogWithArgs( v95,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "handleXPCComm",  1358);
      }

      BOOL v4 = (void *)_os_log_pack_size(12LL);
      p_class_meths = (__objc2_meth_list **)((char *)&v99 - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL));
      id v96 = __error();
      uint64_t v97 = _os_log_pack_fill( p_class_meths,  v4,  *v96,  &_mh_execute_header,  "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
      *(_DWORD *)uint64_t v97 = 136446210;
      *(void *)(v97 + 4) = "handleXPCComm";
      id v98 = sub_10004579C();
      _NRLogAbortWithPack(v98, p_class_meths);
      __break(1u);
    }

    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
LABEL_22:
    int v19 = _NRLogIsLevelEnabled(qword_1001DC770, 0LL);
    uint64_t v108 = v1;
    if (v19)
    {
      if (p_class_meths[239] != (__objc2_meth_list *)-1LL) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      id v22 = (id)qword_1001DC770;
      if (v4)
      {
        uint64_t v23 = (void *)v4[4];
        if (!v23)
        {
          id v24 = (_xpc_connection_s *)objc_getProperty(v4, v21, 8LL, 1);
          uint64_t v25 = xpc_connection_get_pid(v24);
          id v26 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v25);
          bzero(v123, 0x400uLL);
          if ((int)v25 >= 1)
          {
            if (proc_pidpath(v25, v123, 0x400u) >= 1 && v123[0])
            {
              id v27 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  v123,  v25);

              id v26 = v27;
            }

            id v1 = v108;
          }

          id v28 = (void *)v4[4];
          v4[4] = v26;

          uint64_t v23 = (void *)v4[4];
        }

        id v29 = v23;
      }

      else
      {
        id v29 = 0LL;
      }

      _NRLogWithArgs(v22, 0LL, "%s%.30s:%-4d Received XPCComm %@ from %@", "", "handleXPCComm", 1359LL, v1, v29);
    }

    if (v4) {
      id v30 = objc_getProperty(v4, v20, 16LL, 1);
    }
    else {
      id v30 = 0LL;
    }
    xpc_object_t dictionary = xpc_dictionary_get_dictionary(v30, nrXPCKeyXPCCommNotification);
    id v32 = (id)objc_claimAutoreleasedReturnValue(dictionary);
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    __int128 v33 = (id)qword_1001DC870;
    __int128 v35 = v33;
    if (v4)
    {
      id v36 = objc_getProperty(v4, v34, 8LL, 1);
      if (v35)
      {
LABEL_41:
        __int128 v107 = v35;
        uint64_t v37 = (void *)v35[27];
        id v38 = v32;
        id v39 = v36;
        uint64_t v40 = objc_claimAutoreleasedReturnValue([v37 objectForKeyedSubscript:v108]);
        id v41 = v39;
        id v42 = v38;
        if (!v40 || !*(_BYTE *)(v40 + 13))
        {
LABEL_105:

          pid_t v86 = xpc_connection_get_pid((xpc_connection_t)v41);
          uint64_t v124 = 0LL;
          memset(v123, 0, sizeof(v123));
          if (proc_pidinfo(v86, 17, 1uLL, v123, 56) == 56)
          {
            int v87 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v123);
            id v88 = (void *)v107[32];
            v107[32] = v87;
          }

          else
          {
            if (qword_1001DC8A0 != -1) {
              dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
            }
            if (_NRLogIsLevelEnabled(qword_1001DC898, 17LL))
            {
              if (qword_1001DC8A0 != -1) {
                dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
              }
              _NRLogWithArgs(qword_1001DC898, 17LL, "Failed to retrieve process UUID");
            }
          }

          __int128 v35 = v107;
          goto LABEL_114;
        }

        [*(id *)(v40 + 152) addObject:v41];
        uint64_t v44 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v40 + 96), v43);
        int v45 = _NRLogIsLevelEnabled(v44, 0LL);

        if (v45)
        {
          id v47 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v40 + 96), v46);
          _NRLogWithArgs( v47,  0LL,  "%s%.30s:%-4d Received notification: %@",  "",  "-[NRDDeviceConductor processXPCCommNotificationForConnection:notificationDictionary:]",  7342LL,  v42);
        }

        dispatch_assert_queue_V2(*(dispatch_queue_t *)(v40 + 104));
        id v48 = sub_1000D8B90(v40, 1, 0);
        if (!v48
          || (uint64_t v49 = objc_opt_class(&OBJC_CLASS___NRLinkBluetooth), isKindOfClass = objc_opt_isKindOfClass(v48, v49),
                                                                   !v42)
          || (isKindOfClass & 1) == 0
          || [v48 state] == 255)
        {
LABEL_102:
          if ([*(id *)(v40 + 160) count]) {
            sub_1000EFBC8(v40, 0LL);
          }

          goto LABEL_105;
        }

        uint64_t v110 = 0LL;
        uint64_t v111 = &v110;
        uint64_t v112 = 0x3032000000LL;
        uint64_t v113 = sub_1000DF67C;
        id v114 = sub_1000DF68C;
        id v115 = 0LL;
        v109[0] = _NSConcreteStackBlock;
        v109[1] = 3221225472LL;
        v109[2] = sub_1000EF9C8;
        v109[3] = &unk_1001AF5B0;
        v109[4] = v40;
        v109[5] = &v110;
        xpc_dictionary_apply(v42, v109);
        id v106 = (id)v111[5];
        unsigned int v51 = [v48 state];
        if (!v106 || v51 == 255)
        {
LABEL_101:

          _Block_object_dispose(&v110, 8);
          goto LABEL_102;
        }

        id v102 = (id)objc_claimAutoreleasedReturnValue([v106 objectForKeyedSubscript:@"checkin"]);
        if ([v102 BOOLValue] && objc_msgSend(v48, "state") == 8)
        {
          sub_10008F364(v48, 0LL, &off_1001BC628);
          id v52 = (void *)objc_claimAutoreleasedReturnValue([*(id *)((char *)v48 + 1335) nexusInstances]);
          sub_10009597C((uint64_t)v48, v52);
        }

        id v104 = (id)objc_claimAutoreleasedReturnValue([v106 objectForKeyedSubscript:@"message"]);
        if (!v104)
        {
LABEL_77:
          id v105 = (id)objc_claimAutoreleasedReturnValue([v106 objectForKeyedSubscript:@"datapath-report"]);
          if (v105)
          {
            int v69 = (void *)objc_claimAutoreleasedReturnValue([v105 objectForKeyedSubscript:@"datapath-report-stall"]);
            if ([v69 BOOLValue])
            {
              uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue([v105 objectForKeyedSubscript:@"channel-id-list"]);
              __int128 v118 = 0u;
              __int128 v119 = 0u;
              __int128 v116 = 0u;
              __int128 v117 = 0u;
              id v71 = [v70 countByEnumeratingWithState:&v116 objects:v123 count:16];
              uint64_t v100 = v69;
              id v101 = v42;
              id v103 = v32;
              if (v71)
              {
                uint64_t v72 = *(void *)v117;
                do
                {
                  for (uint64_t i = 0LL; i != v71; uint64_t i = (char *)i + 1)
                  {
                    if (*(void *)v117 != v72) {
                      objc_enumerationMutation(v70);
                    }
                    unint64_t v74 = (unint64_t)[*(id *)(*((void *)&v116 + 1) + 8 * (void)i) integerValue]
                        - 1;
                    if (v74 <= 2) {
                      sub_100097034(v48, (&off_1001AEE40)[v74]);
                    }
                  }

                  id v71 = [v70 countByEnumeratingWithState:&v116 objects:v123 count:16];
                }

                while (v71);
              }

              id v32 = v103;
              int v69 = v100;
              id v42 = v101;
            }

            uint64_t v75 = (void *)objc_claimAutoreleasedReturnValue([v105 objectForKeyedSubscript:@"datapath-report-remediate"]);
          }

          uint64_t v76 = objc_claimAutoreleasedReturnValue([v106 objectForKeyedSubscript:@"error"]);
          id v77 = (void *)v76;
          if (v76) {
            [v48 cancelWithReason:@"parser internal error: %@", v76];
          }
          id v78 = (void *)objc_claimAutoreleasedReturnValue([v106 objectForKeyedSubscript:@"wake-pkt-sn"]);
          id v103 = (id)objc_claimAutoreleasedReturnValue([v106 objectForKeyedSubscript:@"wake-pkt-spi"]);
          if (v78)
          {
            uint64_t v79 = objc_opt_class(&OBJC_CLASS___NSNumber);
            unsigned __int8 v80 = objc_opt_isKindOfClass(v78, v79);
            if ((v80 & (v103 != 0LL)) == 1)
            {
              uint64_t v81 = objc_opt_class(&OBJC_CLASS___NSNumber);
              if ((objc_opt_isKindOfClass(v103, v81) & 1) != 0)
              {
                unsigned int v82 = [v78 unsignedIntValue];
                unsigned int v83 = [v103 unsignedIntValue];
                LODWORD(v100) = v82;
                id v101 = v77;
                unsigned int v84 = v83;
                if (qword_1001DC9E8 != -1) {
                  dispatch_once(&qword_1001DC9E8, &stru_1001AFB78);
                }
                uint64_t v85 = (dispatch_queue_s *)(id)qword_1001DC9E0;
                v120[0] = _NSConcreteStackBlock;
                v120[1] = 3221225472LL;
                void v120[2] = sub_10008BBD0;
                v120[3] = &unk_1001B0578;
                unsigned int v121 = v84;
                int v122 = (int)v100;
                dispatch_async(v85, v120);

                id v77 = v101;
              }
            }
          }

          goto LABEL_101;
        }

        uint64_t v53 = (void *)objc_claimAutoreleasedReturnValue([v104 objectForKeyedSubscript:@"message-data"]);
        if (!v53)
        {
LABEL_76:

          goto LABEL_77;
        }

        id v105 = (id)objc_claimAutoreleasedReturnValue([v104 objectForKeyedSubscript:@"channel-id"]);
        id v103 = (id)objc_claimAutoreleasedReturnValue([v104 objectForKeyedSubscript:@"message-pre-act"]);
        unsigned int v54 = [v103 BOOLValue];
        id v56 = [v105 integerValue];
        if (v56 == (id)1)
        {
          if (v54 && *((_BYTE *)v48 + 247))
          {
            uint64_t v63 = (void *)_NRCopyLogObjectForNRUUID(v48[4], v55);
            int v64 = _NRLogIsLevelEnabled(v63, 0LL);

            if (v64)
            {
              uint64_t v61 = (void *)_NRCopyLogObjectForNRUUID(v48[4], v65);
              id v62 = [v48 copyDescription];
              _NRLogWithArgs( v61,  0LL,  "%s%.30s:%-4d %@: ignoring pre-activation message for medium",  "",  "-[NRLinkBluetooth processXPCCommDictionary:]",  5988LL,  v62);
              goto LABEL_74;
            }

                    ++*(void *)(v5 + *v66);
LABEL_119:
                    *(void *)(v5 + 1415) += v63;
                    uint64_t v85 = (unsigned __int16)(v27 - v62);
                    if (v63 <= v85)
                    {
                      id v26 = v62 + v63;
                      id v28 = v341;
                      goto LABEL_134;
                    }

                    id v327 = v48;
                    pid_t v86 = v340;
                    *(void *)(v5 + 1935) |= 0x4000uLL;
                    if (gNRPacketLoggingEnabled)
                    {
                      int v123 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                      uint64_t v124 = _NRLogIsLevelEnabled(v123, 1LL);

                      if (v124)
                      {
                        id v126 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v125);
                        id v127 = [(id)v5 copyDescription];
                        _NRLogWithArgs( v126,  1LL,  "%s%.30s:%-4d %@: UrgentLink:Sending ESP sequence number %u (2)",  "",  "NRLinkNexusToLinkLoopUrgent",  3415LL,  v127,  ESPSequenceNumberFromPacket);
                      }
                    }

                    v367 = v342;
                    os_buflet_set_data_length(v338, v41);
                    os_packet_set_flow_uuid(packet, &v366);
                    int v87 = os_packet_finalize(packet);
                    id v28 = v341;
                    id v88 = (unint64_t)&OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                    if (v87)
                    {
                      v291 = v87;
                      uint64_t v312 = sub_100070554();
                      id v313 = _NRLogIsLevelEnabled(v312, 16LL);

                      if (v313)
                      {
                        id v314 = sub_100070554();
                        _NRLogWithArgs( v314,  16LL,  "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d",  "",  "NRLinkNexusToLinkLoopUrgent",  3419,  v291);
                      }
}

LABEL_114:
    id v15 = v32;
    uint64_t v16 = 0LL;
    id v8 = v108;
    goto LABEL_115;
  }

  id v89 = sub_10004579C();
  int v90 = _NRLogIsLevelEnabled(v89, 17LL);

  if (!v90) {
    goto LABEL_118;
  }
  id v8 = sub_10004579C();
  id v15 = sub_10004580C(v4, v91);
  _NRLogWithArgs(v8, 17LL, "Missing NRUUID from %@", v15);
LABEL_19:
  uint64_t v16 = -2005LL;
LABEL_115:

LABEL_119:
  return v16;
}

void sub_100057BB0(_Unwind_Exception *a1)
{
}

uint64_t sub_100057BD4(void *a1)
{
  id Property = a1;
  id v3 = Property;
  if (Property) {
    id Property = objc_getProperty(Property, v2, 16LL, 1);
  }
  BOOL v4 = xpc_dictionary_get_BOOL(Property, nrXPCKeyEnableBluetoothPacketParser);
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v6 = (id)qword_1001DC770;
    if (v3)
    {
      BOOL v7 = (void *)v3[4];
      if (!v7)
      {
        id v8 = (_xpc_connection_s *)objc_getProperty(v3, v5, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(v8);
        id v10 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v11 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v10 = v11;
        }

        id v12 = (void *)v3[4];
        void v3[4] = v10;

        BOOL v7 = (void *)v3[4];
      }

      id v13 = v7;
    }

    else
    {
      id v13 = 0LL;
    }

    _NRLogWithArgs( v6,  0LL,  "%s%.30s:%-4d Client %@ setting bluetooth proxy path state enabled=%d",  "",  "handleEnableBluetoothPacketParser",  910LL,  v13,  v4);
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v14 = (id)qword_1001DC870;
  if (v14)
  {
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC898, 0LL))
    {
      if (qword_1001DC8A0 != -1) {
        dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
      }
      _NRLogWithArgs( qword_1001DC898,  0LL,  "%s%.30s:%-4d Setting bluetooth proxy path state enabled=%d",  "",  "-[NRLinkDirector setEnableBluetoothPacketParserForTesting:]",  1113,  v4);
    }

    if (v4)
    {
      id v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", 1LL));
      sub_10009FCD0(0LL, @"EnableBluetoothPacketParser", v15);

      id v21 = "YES";
    }

    else
    {
      sub_10009FF2C(0LL, @"EnableBluetoothPacketParser");
      id v21 = "NO";
    }

    sub_1000A2084((uint64_t)v14, 1039, @"%s", v16, v17, v18, v19, v20, (uint64_t)v21);
  }

  return 0LL;
}

uint64_t sub_100057F2C(void *a1)
{
  uint64_t v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v3 = (id)qword_1001DC770;
    if (v1)
    {
      BOOL v4 = (void *)v1[4];
      if (!v4)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        BOOL v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          BOOL v7 = v8;
        }

        id v9 = (void *)v1[4];
        v1[4] = v7;

        BOOL v4 = (void *)v1[4];
      }

      id v10 = v4;
    }

    else
    {
      id v10 = 0LL;
    }

    _NRLogWithArgs( v3,  0LL,  "%s%.30s:%-4d Ignoring request to set companion link encryption type from %@",  "",  "handleCompanionLinkSetEncryptionType",  1276LL,  v10);
  }

  return 0LL;
}

uint64_t sub_1000580FC(void *a1)
{
  uint64_t v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v3 = (id)qword_1001DC770;
    if (v1)
    {
      BOOL v4 = (void *)v1[4];
      if (!v4)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        BOOL v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && LOBYTE(buffer[0]))
        {
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          BOOL v7 = v8;
        }

        id v9 = (void *)v1[4];
        v1[4] = v7;

        BOOL v4 = (void *)v1[4];
      }

      id v10 = v4;
    }

    else
    {
      id v10 = 0LL;
    }

    _NRLogWithArgs( v3,  0LL,  "%s%.30s:%-4d Received device pairing connection from %@",  "",  "handleDevicePairingConnection",  1371LL,  v10);
  }

  objc_opt_self(&OBJC_CLASS___NRDevicePairingDirector);
  id v11 = (void *)qword_1001DC968;
  if (!qword_1001DC968)
  {
    id v12 = objc_alloc_init(&OBJC_CLASS___NRDevicePairingDirector);
    id v13 = (void *)qword_1001DC968;
    qword_1001DC968 = (uint64_t)v12;

    id v11 = (void *)qword_1001DC968;
  }

  id v15 = v11;
  if (v1)
  {
    id v16 = objc_getProperty(v1, v14, 8LL, 1);
    if (!v15) {
      goto LABEL_26;
    }
  }

  else
  {
    id v16 = 0LL;
    if (!v15) {
      goto LABEL_26;
    }
  }

  id v17 = v16;
  uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
  uint64_t v19 = sub_1000FE37C(objc_alloc(&OBJC_CLASS___NRDevicePairingManagerConnection), v17);
  [v15[2] setObject:v19 forKeyedSubscript:v18];
  buffer[0] = _NSConcreteStackBlock;
  buffer[1] = 3221225472LL;
  buffer[2] = sub_1000FF2AC;
  buffer[3] = &unk_1001AFA18;
  buffer[4] = v15;
  id v20 = v18;
  id v23 = v20;
  xpc_connection_set_event_handler((xpc_connection_t)v17, buffer);

  if (qword_1001DC978 != -1) {
    dispatch_once(&qword_1001DC978, &stru_1001AFA38);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC970, 0LL))
  {
    if (qword_1001DC978 != -1) {
      dispatch_once(&qword_1001DC978, &stru_1001AFA38);
    }
    _NRLogWithArgs( qword_1001DC970,  0LL,  "%s%.30s:%-4d Registered device pairing connection %@",  "",  "-[NRDevicePairingDirector addDevicePairingConnection:]",  3075LL,  v20);
  }

LABEL_26:
  return 0LL;
}

uint64_t sub_10005846C(void *a1)
{
  uint64_t v1 = a1;
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v3 = (id)qword_1001DC770;
    if (v1)
    {
      BOOL v4 = (void *)v1[4];
      if (!v4)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(v1, v2, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        BOOL v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v8 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          BOOL v7 = v8;
        }

        id v9 = (void *)v1[4];
        v1[4] = v7;

        BOOL v4 = (void *)v1[4];
      }

      id v10 = v4;
    }

    else
    {
      id v10 = 0LL;
    }

    _NRLogWithArgs( v3,  0LL,  "%s%.30s:%-4d Client %@ trying to resolve identity proxy",  "",  "handleIdentityProxyResolutionRequest",  1031LL,  v10);
  }

  id v11 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v12 = (id)qword_1001DC870;
  id v13 = v12;
  if (v12) {
    id v14 = (void *)*((void *)v12 + 15);
  }
  else {
    id v14 = 0LL;
  }
  id v15 = v14;
  -[NSMutableDictionary setObject:forKeyedSubscript:](v11, "setObject:forKeyedSubscript:", v15, @"id-ref");

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v16 = (id)qword_1001DC870;
  id v17 = v16;
  if (v16) {
    uint64_t v18 = (void *)*((void *)v16 + 14);
  }
  else {
    uint64_t v18 = 0LL;
  }
  id v19 = v18;
  -[NSMutableDictionary setObject:forKeyedSubscript:](v11, "setObject:forKeyedSubscript:", v19, @"cert-ref");

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v20 = (id)qword_1001DC870;
  id v21 = v20;
  if (v20) {
    id v22 = (void *)*((void *)v20 + 16);
  }
  else {
    id v22 = 0LL;
  }
  id v23 = v22;
  -[NSMutableDictionary setObject:forKeyedSubscript:](v11, "setObject:forKeyedSubscript:", v23, @"key-ref");

  id v24 = (void *)_CFXPCCreateXPCObjectFromCFObject(v11);
  if (v24)
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      _NRLogWithArgs( qword_1001DC770,  0LL,  "%s%.30s:%-4d sending response %@",  "",  "handleIdentityProxyResolutionRequest",  1044LL,  v11);
    }

    if (v1) {
      id v26 = objc_getProperty(v1, v25, 24LL, 1);
    }
    else {
      id v26 = 0LL;
    }
    xpc_dictionary_set_value(v26, nrXPCKeyIdentityProxyReferences, v24);
    uint64_t v27 = 0LL;
  }

  else
  {
    id v29 = sub_10004579C();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v29, 17LL);

    if (IsLevelEnabled)
    {
      id v31 = sub_10004579C();
      _NRLogWithArgs(v31, 17LL, "_CFXPCCreateXPCObjectFromCFObject failed");
    }

    uint64_t v27 = -2001LL;
  }

  return v27;
}

void sub_1000588C8(uint64_t a1, uint64_t a2)
{
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    id v6 = (id)qword_1001DC770;
    uint64_t v8 = *(void *)(a1 + 32);
    BOOL v7 = *(void **)(a1 + 40);
    if (v7)
    {
      id v9 = (void *)v7[4];
      if (!v9)
      {
        id Property = (_xpc_connection_s *)objc_getProperty(*(id *)(a1 + 40), v5, 8LL, 1);
        uint64_t pid = xpc_connection_get_pid(Property);
        id v12 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
        bzero(buffer, 0x400uLL);
        if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
        {
          id v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

          id v12 = v13;
        }

        id v14 = (void *)v7[4];
        v7[4] = v12;

        id v9 = (void *)v7[4];
      }

      BOOL v7 = v9;
    }

    _NRLogWithArgs( v6,  0LL,  "%s%.30s:%-4d Measured BT latency %lluns for %@ from %@",  "",  "handleMeasureBTLatency_block_invoke",  1311LL,  a2,  v8,  v7);
  }

  id v15 = *(id *)(a1 + 40);
  if (v15) {
    id v15 = objc_getProperty(v15, v4, 24LL, 1);
  }
  xpc_dictionary_set_int64(v15, nrXPCKeyResult, 0LL);
  id v17 = *(id *)(a1 + 40);
  if (v17) {
    id v17 = objc_getProperty(v17, v16, 24LL, 1);
  }
  xpc_dictionary_set_uint64(v17, nrXPCKeyBTLatency, a2);
  id v19 = *(id *)(a1 + 40);
  if (v19) {
    id v19 = objc_getProperty(v19, v18, 8LL, 1);
  }
  connection = (_xpc_connection_s *)v19;
  id v21 = *(void **)(a1 + 40);
  if (v21) {
    id v22 = objc_getProperty(v21, v20, 24LL, 1);
  }
  else {
    id v22 = 0LL;
  }
  xpc_connection_send_message(connection, v22);
}

uint64_t sub_100058B38(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (xpc_get_type(v4) != (xpc_type_t)&_xpc_type_string)
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      id v6 = (NSString *)(id)qword_1001DC770;
      id Property = *(id *)(a1 + 32);
      if (Property) {
        id Property = objc_getProperty(Property, v5, 16LL, 1);
      }
      id v9 = Property;
      id v10 = *(void **)(a1 + 32);
      if (v10)
      {
        id v11 = (void *)v10[4];
        if (!v11)
        {
          id v12 = (_xpc_connection_s *)objc_getProperty(v10, v8, 8LL, 1);
          uint64_t pid = xpc_connection_get_pid(v12);
          id v14 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  pid);
          bzero(buffer, 0x400uLL);
          if ((int)pid >= 1 && proc_pidpath(pid, buffer, 0x400u) >= 1 && buffer[0])
          {
            id v15 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  pid);

            id v14 = v15;
          }

          id v16 = (void *)v10[4];
          v10[4] = v14;

          id v11 = (void *)v10[4];
        }

        id v10 = v11;
      }

      _NRLogWithArgs( v6,  16LL,  "%s%.30s:%-4d Bad XPC type found in policy traffic class message %@ from %@",  "",  "handleDevicePreferences_block_invoke",  1081LL,  v9,  v10);
LABEL_18:

      goto LABEL_19;
    }

    goto LABEL_40;
  }

  string_ptr = xpc_string_get_string_ptr(v4);
  if (!string_ptr)
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      id v6 = (NSString *)(id)qword_1001DC770;
      id v21 = *(id *)(a1 + 32);
      if (v21) {
        id v21 = objc_getProperty(v21, v20, 16LL, 1);
      }
      id v9 = v21;
      id v10 = *(void **)(a1 + 32);
      if (v10)
      {
        id v23 = (void *)v10[4];
        if (!v23)
        {
          id v24 = (_xpc_connection_s *)objc_getProperty(v10, v22, 8LL, 1);
          uint64_t v25 = xpc_connection_get_pid(v24);
          id v26 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"unknown:%d",  v25);
          bzero(buffer, 0x400uLL);
          if ((int)v25 >= 1 && proc_pidpath(v25, buffer, 0x400u) >= 1 && buffer[0])
          {
            uint64_t v27 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"%s:%d",  buffer,  v25);

            id v26 = v27;
          }

          id v28 = (void *)v10[4];
          v10[4] = v26;

          id v23 = (void *)v10[4];
        }

        id v10 = v23;
      }

      _NRLogWithArgs( v6,  16LL,  "%s%.30s:%-4d Bad XPC string found in policy traffic class message %@ from %@",  "",  "handleDevicePreferences_block_invoke",  1087LL,  v9,  v10);
      goto LABEL_18;
    }

void sub_100059018(id a1)
{
  uint64_t v1 = sub_100045AB0(objc_alloc(&OBJC_CLASS___TerminusdXPCServer));
  id v2 = (void *)qword_1001DC760;
  qword_1001DC760 = (uint64_t)v1;

  sub_100059048();
}

uint64_t sub_100059048()
{
  if (dword_1001DBC58 == -1)
  {
    uint64_t result = notify_register_check("com.apple.networkrelay.endpointcache", &dword_1001DBC58);
    if ((_DWORD)result)
    {
      int v2 = result;
      dword_1001DBC58 = -1;
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      uint64_t result = _NRLogIsLevelEnabled(qword_1001DC770, 17LL);
      if ((_DWORD)result)
      {
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        return _NRLogWithArgs( qword_1001DC770,  17LL,  "notify_register_check(%s) failed: %u",  "com.apple.networkrelay.endpointcache",  v2);
      }

      return result;
    }

    if (dword_1001DBC58 == -1) {
      return result;
    }
  }

  uint64_t v0 = sub_1001015B8();
  if (qword_1001DC778 != -1) {
    dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC770, 1LL))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    _NRLogWithArgs( qword_1001DC770,  1LL,  "%s%.30s:%-4d Setting NREndpoint cache generation to %llu",  "",  "notifyNREndpointCacheChanged",  89,  v0);
  }

  if (notify_set_state(dword_1001DBC58, v0))
  {
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 17LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      _NRLogWithArgs(qword_1001DC770, 17LL, "notify_set_state(%s, %d) failed: %u");
    }
  }

  else
  {
    uint64_t result = notify_post("com.apple.networkrelay.endpointcache");
    if (!(_DWORD)result) {
      return result;
    }
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 17LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      _NRLogWithArgs(qword_1001DC770, 17LL, "notify_post(%s) failed: %u");
    }
  }

  uint64_t result = notify_cancel(dword_1001DBC58);
  dword_1001DBC58 = -1;
  return result;
}

void sub_1000592FC(uint64_t a1, void *a2)
{
  id v15 = a2;
  id Property = *(id *)(a1 + 32);
  if (Property) {
    id Property = objc_getProperty(Property, v3, 24LL, 1);
  }
  xpc_dictionary_set_int64(Property, nrXPCKeyResult, 0LL);
  id v6 = *(id *)(a1 + 32);
  if (v6) {
    id v6 = objc_getProperty(v6, v5, 24LL, 1);
  }
  BOOL v7 = (const char *)nrXPCKeyIDSDeviceID;
  id v8 = v6;
  xpc_dictionary_set_string(v8, v7, (const char *)[v15 UTF8String]);

  id v10 = *(id *)(a1 + 32);
  if (v10) {
    id v10 = objc_getProperty(v10, v9, 8LL, 1);
  }
  id v12 = (_xpc_connection_s *)v10;
  id v13 = *(void **)(a1 + 32);
  if (v13) {
    id v14 = objc_getProperty(v13, v11, 24LL, 1);
  }
  else {
    id v14 = 0LL;
  }
  xpc_connection_send_message(v12, v14);
}

void sub_1000593E8(uint64_t a1, int64_t a2, void *a3)
{
  id v18 = a3;
  id Property = *(id *)(a1 + 32);
  if (Property) {
    id Property = objc_getProperty(Property, v5, 24LL, 1);
  }
  xpc_dictionary_set_int64(Property, nrXPCKeyResult, a2);
  if (v18)
  {
    id v9 = v18;
    id v10 = *(id *)(a1 + 32);
    if (v10) {
      id v10 = objc_getProperty(v10, v8, 24LL, 1);
    }
    id v11 = (const char *)nrXPCKeyErrorDescription;
    id v12 = v10;
    xpc_dictionary_set_string(v12, v11, (const char *)[v9 UTF8String]);
  }

  id v13 = *(id *)(a1 + 32);
  if (v13) {
    id v13 = objc_getProperty(v13, v7, 8LL, 1);
  }
  id v15 = (_xpc_connection_s *)v13;
  id v16 = *(void **)(a1 + 32);
  if (v16) {
    id v17 = objc_getProperty(v16, v14, 24LL, 1);
  }
  else {
    id v17 = 0LL;
  }
  xpc_connection_send_message(v15, v17);
}

void sub_1000594F0(uint64_t a1, int64_t a2, void *a3)
{
  id v18 = a3;
  id Property = *(id *)(a1 + 32);
  if (Property) {
    id Property = objc_getProperty(Property, v5, 24LL, 1);
  }
  xpc_dictionary_set_int64(Property, nrXPCKeyResult, a2);
  if (v18)
  {
    id v9 = v18;
    id v10 = *(id *)(a1 + 32);
    if (v10) {
      id v10 = objc_getProperty(v10, v8, 24LL, 1);
    }
    id v11 = (const char *)nrXPCKeyErrorDescription;
    id v12 = v10;
    xpc_dictionary_set_string(v12, v11, (const char *)[v9 UTF8String]);
  }

  id v13 = *(id *)(a1 + 32);
  if (v13) {
    id v13 = objc_getProperty(v13, v7, 8LL, 1);
  }
  id v15 = (_xpc_connection_s *)v13;
  id v16 = *(void **)(a1 + 32);
  if (v16) {
    id v17 = objc_getProperty(v16, v14, 24LL, 1);
  }
  else {
    id v17 = 0LL;
  }
  xpc_connection_send_message(v15, v17);
}

void sub_1000595F8(uint64_t a1, int64_t a2, void *a3)
{
  id v18 = a3;
  sub_100059048();
  id Property = *(id *)(a1 + 32);
  if (Property) {
    id Property = objc_getProperty(Property, v5, 24LL, 1);
  }
  xpc_dictionary_set_int64(Property, nrXPCKeyResult, a2);
  if (v18)
  {
    id v9 = v18;
    id v10 = *(id *)(a1 + 32);
    if (v10) {
      id v10 = objc_getProperty(v10, v8, 24LL, 1);
    }
    id v11 = (const char *)nrXPCKeyErrorDescription;
    id v12 = v10;
    xpc_dictionary_set_string(v12, v11, (const char *)[v9 UTF8String]);
  }

  id v13 = *(id *)(a1 + 32);
  if (v13) {
    id v13 = objc_getProperty(v13, v7, 8LL, 1);
  }
  id v15 = (_xpc_connection_s *)v13;
  id v16 = *(void **)(a1 + 32);
  if (v16) {
    id v17 = objc_getProperty(v16, v14, 24LL, 1);
  }
  else {
    id v17 = 0LL;
  }
  xpc_connection_send_message(v15, v17);
}

void sub_100059704(uint64_t a1, int64_t a2, void *a3)
{
  id v18 = a3;
  sub_100059048();
  id Property = *(id *)(a1 + 32);
  if (Property) {
    id Property = objc_getProperty(Property, v5, 24LL, 1);
  }
  xpc_dictionary_set_int64(Property, nrXPCKeyResult, a2);
  if (v18)
  {
    id v9 = v18;
    id v10 = *(id *)(a1 + 32);
    if (v10) {
      id v10 = objc_getProperty(v10, v8, 24LL, 1);
    }
    id v11 = (const char *)nrXPCKeyErrorDescription;
    id v12 = v10;
    xpc_dictionary_set_string(v12, v11, (const char *)[v9 UTF8String]);
  }

  id v13 = *(id *)(a1 + 32);
  if (v13) {
    id v13 = objc_getProperty(v13, v7, 8LL, 1);
  }
  id v15 = (_xpc_connection_s *)v13;
  id v16 = *(void **)(a1 + 32);
  if (v16) {
    id v17 = objc_getProperty(v16, v14, 24LL, 1);
  }
  else {
    id v17 = 0LL;
  }
  xpc_connection_send_message(v15, v17);
}

void sub_100059810(uint64_t a1, int64_t a2, void *a3)
{
  id v18 = a3;
  id Property = *(id *)(a1 + 32);
  if (Property) {
    id Property = objc_getProperty(Property, v5, 24LL, 1);
  }
  xpc_dictionary_set_int64(Property, nrXPCKeyResult, a2);
  if (v18)
  {
    id v9 = v18;
    id v10 = *(id *)(a1 + 32);
    if (v10) {
      id v10 = objc_getProperty(v10, v8, 24LL, 1);
    }
    id v11 = (const char *)nrXPCKeyErrorDescription;
    id v12 = v10;
    xpc_dictionary_set_string(v12, v11, (const char *)[v9 UTF8String]);
  }

  id v13 = *(id *)(a1 + 32);
  if (v13) {
    id v13 = objc_getProperty(v13, v7, 8LL, 1);
  }
  id v15 = (_xpc_connection_s *)v13;
  id v16 = *(void **)(a1 + 32);
  if (v16) {
    id v17 = objc_getProperty(v16, v14, 24LL, 1);
  }
  else {
    id v17 = 0LL;
  }
  xpc_connection_send_message(v15, v17);
}

BOOL sub_100059918(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  BOOL v5 = (void *)xpc_connection_copy_entitlement_value(v4, [v3 UTF8String]);

  BOOL v6 = v5 && xpc_get_type(v5) == (xpc_type_t)&_xpc_type_BOOL && xpc_BOOL_get_value(v5);
  return v6;
}

NSString *sub_1000599A4()
{
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v106 = (unsigned int *)(id)qword_1001DC870;
  if (!v106) {
    goto LABEL_147;
  }
  uint64_t v0 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v0);

  uint64_t v1 = objc_alloc(&OBJC_CLASS___NSMutableString);
  if ((_NRIsAppleInternal(v1) & 1) != 0)
  {
    int v2 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
    os_unfair_lock_lock(&stru_1001DCB20);
    uint64_t v3 = byte_1001DCB24;
    id v4 = [(id)qword_1001DCB18 count];
    if (v4)
    {
      unint64_t v5 = (unint64_t)v4;
      uint64_t v6 = 0LL;
      int v7 = 0;
      do
      {
        id v8 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1001DCB18 objectAtIndexedSubscript:(v6 + v3) % v5]);
        -[NSMutableString appendString:](v2, "appendString:", v8);

        uint64_t v6 = ++v7;
      }

      while (v5 > v7);
    }

    os_unfair_lock_unlock(&stru_1001DCB20);
    id v9 = (void *)_NRCopyTimeString();
    -[NSMutableString appendFormat:](v2, "appendFormat:", @"\n    %@ : time of this status dump", v9);
  }

  else
  {
    id v10 = objc_alloc(&OBJC_CLASS___NSString);
    id v9 = (void *)_NRCopyTimeString();
    int v2 = -[NSString initWithFormat:](v10, "initWithFormat:", @"\n    %@ : time of this status dump", v9);
  }

  id v11 = -[NSMutableString initWithString:](v1, "initWithString:", v2);
  uint64_t v12 = objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
  id v13 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v13);

  sub_100127AFC(v12);
  id v14 = [(id)qword_1001DCB78 copy];
  id v15 = objc_alloc(&OBJC_CLASS___NSMutableString);
  id v16 = [v14 count];
  id v17 = [v14 count];
  id v18 = "s";
  if (v17 == (id)1) {
    id v18 = "";
  }
  id v19 = -[NSMutableString initWithFormat:]( v15,  "initWithFormat:",  @"--------- NRD Local Device Database Status (%llu device%s) ---------\n",  v16,  v18);
  __int128 v114 = 0u;
  __int128 v115 = 0u;
  __int128 v116 = 0u;
  __int128 v117 = 0u;
  id v20 = v14;
  id v21 = [v20 countByEnumeratingWithState:&v114 objects:v119 count:16];
  if (v21)
  {
    id v22 = v21;
    uint64_t v23 = *(void *)v115;
    do
    {
      for (uint64_t i = 0LL; i != v22; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v115 != v23) {
          objc_enumerationMutation(v20);
        }
        uint64_t v25 = (id *)objc_claimAutoreleasedReturnValue( [v20 objectForKeyedSubscript:*(void *)(*((void *)&v114 + 1) + 8 * (void)i)]);
        id v26 = (void *)sub_10012C014(v25);
        -[NSMutableString appendFormat:](v19, "appendFormat:", @"\t%@\n", v26);
      }

      id v22 = [v20 countByEnumeratingWithState:&v114 objects:v119 count:16];
    }

    while (v22);
  }

  if (qword_1001DCB88)
  {
    -[NSMutableString appendFormat:](v19, "appendFormat:", @"\n--------- NRD Device Identity ---------");
    uint64_t v27 = sub_100124E58((void *)qword_1001DCB88);
    Logid String = (void *)_NRKeyCreateLogString(v27);
    -[NSMutableString appendFormat:](v19, "appendFormat:", @"\nPublic Key: %@\n", LogString);
  }

  -[NSMutableString appendFormat:](v11, "appendFormat:", @"\n\n%@", v19);
  -[NSMutableString appendFormat:](v11, "appendFormat:", @"\n--------- Director status ---------");
  -[NSMutableString appendFormat:](v11, "appendFormat:", @"\nName: %@", @"Link Director");
  id v29 = "YES";
  if (*((_BYTE *)v106 + 12)) {
    id v30 = "YES";
  }
  else {
    id v30 = "NO";
  }
  -[NSMutableString appendFormat:](v11, "appendFormat:", @"\nEnabled: %s", v30);
  if (*((_BYTE *)v106 + 8)) {
    id v31 = "YES";
  }
  else {
    id v31 = "NO";
  }
  -[NSMutableString appendFormat:](v11, "appendFormat:", @"\nFixed Interface mode: %s", v31);
  if (v106[6] == -1) {
    id v32 = "NO";
  }
  else {
    id v32 = "YES";
  }
  -[NSMutableString appendFormat:](v11, "appendFormat:", @"\nThermal watcher registered: %s", v32);
  StringFromThermalPressureLevel = (void *)createStringFromThermalPressureLevel(v106[5]);
  -[NSMutableString appendFormat:]( v11,  "appendFormat:",  @"\nThermal Pressure: %@",  StringFromThermalPressureLevel);

  -[NSMutableString appendFormat:](v11, "appendFormat:", @"\nSOCKS port: %u", 62742LL);
  -[NSMutableString appendFormat:](v11, "appendFormat:", @"\nSOCKS server: %@", *((void *)v106 + 18));
  uint64_t port = *((void *)v106 + 19);
  if (port) {
    uint64_t port = nw_masque_server_get_port();
  }
  -[NSMutableString appendFormat:](v11, "appendFormat:", @"\nMASQUE port: %u", port);
  -[NSMutableString appendFormat:](v11, "appendFormat:", @"\nMASQUE server: %@", *((void *)v106 + 19));
  __int128 v35 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  sub_1000AA9D0(v35);
  id v102 = v35;
  -[NSMutableString appendFormat:](v11, "appendFormat:", @"\nFD Usage: %@", v35);
  uint64_t v113 = 0LL;
  id v36 = *((id *)v106 + 18);
  if (v36)
  {
    uint64_t v37 = v36;
    int v38 = nw_shoes_server_fillout_statistics(*((void *)v106 + 18), &v113, 8LL, 0LL);

    if (v38) {
      -[NSMutableString appendFormat:]( v11,  "appendFormat:",  @"\nSOCKS Server Connections total: %u max simultaneous: %u",  HIDWORD(v113),  v113);
    }
  }

  objc_opt_self(&OBJC_CLASS___NRDKeyManager);
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  id v39 = (id)qword_1001DCC10;
  uint64_t v40 = (unsigned __int8 *)v39;
  if (v39)
  {
    dispatch_assert_queue_V2(*((dispatch_queue_t *)v39 + 2));
    sub_100143BB8((uint64_t)v40);
    id v41 = objc_alloc(&OBJC_CLASS___NSString);
    id String = (void *)NRDataProtectionClassCreateString(v40[8]);
    uint64_t v43 = -[NSString initWithFormat:](v41, "initWithFormat:", @"Unlocked data protection: %@", String);
  }

  else
  {
    uint64_t v43 = 0LL;
  }

  -[NSMutableString appendFormat:](v11, "appendFormat:", @"\n%@\n", v43);

  -[NSMutableString appendFormat:](v11, "appendFormat:", @"\n--------- Manager status ---------");
  objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
  if (qword_1001DCB60 != -1) {
    dispatch_once(&qword_1001DCB60, &stru_1001B0538);
  }
  id v44 = (id)qword_1001DCB58;
  int v45 = v44;
  if (v44)
  {
    dispatch_assert_queue_V2(*((dispatch_queue_t *)v44 + 1));
    uint64_t v46 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
    -[NSMutableString appendFormat:](v46, "appendFormat:", @"\nName: %@", @"Policy Session Manager");
    -[NSMutableString appendFormat:](v46, "appendFormat:", @"\nPolicy Session: %@", v45[2]);
    -[NSMutableString appendFormat:](v46, "appendFormat:", @"\nInstalled policies: %@", v45[3]);
  }

  else
  {
    uint64_t v46 = 0LL;
  }

  -[NSMutableString appendFormat:](v11, "appendFormat:", @"\n%@", v46);

  id v47 = [*((id *)v106 + 5) copyStatusString];
  -[NSMutableString appendFormat:](v11, "appendFormat:", @"\n%@", v47);

  id v48 = (void *)*((void *)v106 + 6);
  if (v48)
  {
    id v49 = [v48 copyStatusString];
    -[NSMutableString appendFormat:](v11, "appendFormat:", @"\n%@\n", v49);
  }

  uint64_t v50 = (void *)*((void *)v106 + 23);
  if (v50)
  {
    id v51 = [v50 copyStatusString];
    -[NSMutableString appendFormat:](v11, "appendFormat:", @"\n%@\n", v51);
  }

  id v52 = (void *)*((void *)v106 + 8);
  if (v52)
  {
    id v53 = [v52 copyStatusString];
    -[NSMutableString appendFormat:](v11, "appendFormat:", @"\n%@\n", v53);
  }

  uint64_t v54 = *((void *)v106 + 24);
  if (v54)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(v54 + 32));
    uint64_t v55 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
    -[NSMutableString appendFormat:]( v55,  "appendFormat:",  @"\nName: %@",  @"Link Manager - On-demand link setup");
    if (*(_BYTE *)(v54 + 8)) {
      id v56 = "YES";
    }
    else {
      id v56 = "NO";
    }
    -[NSMutableString appendFormat:](v55, "appendFormat:", @"\nstarted: %s", v56);
    if (*(_BYTE *)(v54 + 9)) {
      uint64_t v57 = "YES";
    }
    else {
      uint64_t v57 = "NO";
    }
    -[NSMutableString appendFormat:](v55, "appendFormat:", @"\ncancelled: %s", v57);
    if (*(_BYTE *)(v54 + 10)) {
      id v58 = "YES";
    }
    else {
      id v58 = "NO";
    }
    -[NSMutableString appendFormat:](v55, "appendFormat:", @"\nsubscribed for PHS updates: %s", v58);
    if (*(_BYTE *)(v54 + 11)) {
      int v59 = "YES";
    }
    else {
      int v59 = "NO";
    }
    -[NSMutableString appendFormat:](v55, "appendFormat:", @"\nPHS active: %s", v59);
    if (*(_BYTE *)(v54 + 12)) {
      uint64_t v60 = "YES";
    }
    else {
      uint64_t v60 = "NO";
    }
    -[NSMutableString appendFormat:](v55, "appendFormat:", @"\nLLPHS active: %s", v60);
    if (*(_BYTE *)(v54 + 13)) {
      uint64_t v61 = "YES";
    }
    else {
      uint64_t v61 = "NO";
    }
    -[NSMutableString appendFormat:](v55, "appendFormat:", @"\nPHS provider: %s", v61);
    if (*(_BYTE *)(v54 + 14)) {
      id v62 = "YES";
    }
    else {
      id v62 = "NO";
    }
    -[NSMutableString appendFormat:](v55, "appendFormat:", @"\nPHS client: %s", v62);
    if (*(_BYTE *)(v54 + 15)) {
      uint64_t v63 = "YES";
    }
    else {
      uint64_t v63 = "NO";
    }
    -[NSMutableString appendFormat:](v55, "appendFormat:", @"\ncellular slicing: %s", v63);
    -[NSMutableString appendFormat:]( v55,  "appendFormat:",  @"\nInternet relay valid peers: %@",  *(void *)(v54 + 88));
    -[NSMutableString appendFormat:](v11, "appendFormat:", @"\n%@\n", v55);
  }

  objc_opt_self(&OBJC_CLASS___NRApplicationServiceManager);
  if (qword_1001DC930 != -1) {
    dispatch_once(&qword_1001DC930, &stru_1001AF7E0);
  }
  int v64 = (void *)objc_claimAutoreleasedReturnValue([(id)qword_1001DC928 description]);
  -[NSMutableString appendFormat:](v11, "appendFormat:", @"\n%@\n", v64);

  objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
  if (qword_1001DC640 != -1) {
    dispatch_once(&qword_1001DC640, &stru_1001ADE98);
  }
  uint64_t v65 = (id)qword_1001DC638;
  if (v65)
  {
    int v66 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
    -[NSMutableString appendFormat:](v66, "appendFormat:", @"\n---- NRIKEv2Listener ----");
    -[NSMutableString appendFormat:](v66, "appendFormat:", @"\nIKEv2 Listener: %@", v65[2]);
    -[NSMutableString appendFormat:](v66, "appendFormat:", @"\nRegistered links: %@", v65[3]);
    -[NSMutableString appendFormat:](v66, "appendFormat:", @"\nRegistered pairing clients: %@", v65[4]);
    -[NSMutableString appendFormat:](v66, "appendFormat:", @"\nRegistered pairing manager: %@", v65[5]);
    -[NSMutableString appendFormat:](v66, "appendFormat:", @"\nPending sessions: %@", v65[6]);
  }

  else
  {
    int v66 = 0LL;
  }

  -[NSMutableString appendFormat:](v11, "appendFormat:", @"\n%@\n", v66);

  -[NSMutableString appendFormat:]( v11,  "appendFormat:",  @"\nOrphaned Device Monitor Connections: %@\n",  *((void *)v106 + 28));
  -[NSMutableString appendFormat:]( v11,  "appendFormat:",  @"\nOrphaned Device Preferences Connections: %@\n",  *((void *)v106 + 29));
  -[NSMutableString appendFormat:]( v11,  "appendFormat:",  @"\nEphemeral Device Connections: %@\n",  *((void *)v106 + 30));
  __int128 v111 = 0u;
  __int128 v112 = 0u;
  __int128 v109 = 0u;
  __int128 v110 = 0u;
  id obj = *((id *)v106 + 27);
  id v107 = [obj countByEnumeratingWithState:&v109 objects:v118 count:16];
  if (v107)
  {
    id v104 = v11;
    uint64_t v105 = *(void *)v110;
    do
    {
      for (j = 0LL; j != v107; j = (char *)j + 1)
      {
        if (*(void *)v110 != v105) {
          objc_enumerationMutation(obj);
        }
        uint64_t v68 = objc_claimAutoreleasedReturnValue( [*((id *)v106 + 27) objectForKeyedSubscript:*(void *)(*((void *)&v109 + 1) + 8 * (void)j)]);
        uint64_t v69 = v68;
        if (v68)
        {
          dispatch_assert_queue_V2(*(dispatch_queue_t *)(v68 + 104));
          uint64_t v70 = objc_alloc(&OBJC_CLASS___NSMutableString);
          id v71 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v69 + 96) UUIDString]);
          uint64_t v72 = -[NSMutableString initWithFormat:]( v70,  "initWithFormat:",  @"--------- Conductor %@ status ---------",  v71);

          -[NSMutableString appendFormat:](v72, "appendFormat:", @"\nPrimary Link: %@", *(void *)(v69 + 128));
          -[NSMutableString appendFormat:](v72, "appendFormat:", @"\nLinks: %@", *(void *)(v69 + 112));
          uint64_t v73 = *(void *)(v69 + 448);
          if (v73) {
            unint64_t v74 = (const __CFString *)NEVirtualInterfaceCopyName(v73);
          }
          else {
            unint64_t v74 = @"<nil>";
          }
          uint64_t v108 = (__CFString *)v74;
          -[NSMutableString appendFormat:](v72, "appendFormat:", @"\nCatch-All Interface: %@", v74);
          if (*(_BYTE *)(v69 + 22)) {
            uint64_t v75 = v29;
          }
          else {
            uint64_t v75 = "NO";
          }
          -[NSMutableString appendFormat:](v72, "appendFormat:", @"\nDisable Range Extension: %s", v75);
          -[NSMutableString appendFormat:]( v72,  "appendFormat:",  @"\nPending requests: %@",  *(void *)(v69 + 120));
          if (*(_BYTE *)(v69 + 14)) {
            uint64_t v76 = v29;
          }
          else {
            uint64_t v76 = "NO";
          }
          -[NSMutableString appendFormat:](v72, "appendFormat:", @"\nPrefer Wi-Fi request: %s", v76);
          id v77 = "Connected";
          if (!*(_BYTE *)(v69 + 31)) {
            id v77 = "NOT connected";
          }
          -[NSMutableString appendFormat:](v72, "appendFormat:", @"\nAPS connection status: %s", v77);
          if (*(_BYTE *)(v69 + 30)) {
            id v78 = v29;
          }
          else {
            id v78 = "NO";
          }
          -[NSMutableString appendFormat:](v72, "appendFormat:", @"\nHas quick relay request: %s", v78);
          if (*(_BYTE *)(v69 + 16)) {
            uint64_t v79 = v29;
          }
          else {
            uint64_t v79 = "NO";
          }
          -[NSMutableString appendFormat:](v72, "appendFormat:", @"\nDevice setup in progress: %s", v79);
          else {
            unsigned __int8 v80 = "NO";
          }
          -[NSMutableString appendFormat:](v72, "appendFormat:", @"\nAlways On Wi-Fi supported: %s", v80);
          if (*(_BYTE *)(v69 + 10)) {
            uint64_t v81 = v29;
          }
          else {
            uint64_t v81 = "NO";
          }
          -[NSMutableString appendFormat:](v72, "appendFormat:", @"\nAWDL supported: %s", v81);
          -[NSMutableString appendFormat:]( v72,  "appendFormat:",  @"\nDevice monitor(s): %@",  *(void *)(v69 + 168));
          -[NSMutableString appendFormat:]( v72,  "appendFormat:",  @"\nDevice Preferences Manager(s): %@",  *(void *)(v69 + 184));
          if (*(_BYTE *)(v69 + 41)) {
            unsigned int v82 = v29;
          }
          else {
            unsigned int v82 = "NO";
          }
          -[NSMutableString appendFormat:](v72, "appendFormat:", @"\nBuffer limits set: %s", v82);
          objc_opt_self(&OBJC_CLASS___NRLinkDirectorMessageManager);
          if (qword_1001DC708 != -1) {
            dispatch_once(&qword_1001DC708, &stru_1001AE488);
          }
          id v83 = (id)qword_1001DC700;
          -[NSMutableString appendFormat:](v72, "appendFormat:", @"\nNRLinkDirectorMessage Manager: %@", v83);

          -[NSMutableString appendFormat:](v72, "appendFormat:", @"\nALU Monitor: %@", *(void *)(v69 + 584));
          -[NSMutableString appendFormat:](v72, "appendFormat:", @"\nAS Client: %@", *(void *)(v69 + 632));
          unsigned int v84 = v29;
          if (*(_BYTE *)(v69 + 48)) {
            uint64_t v85 = v29;
          }
          else {
            uint64_t v85 = "NO";
          }
          -[NSMutableString appendFormat:](v72, "appendFormat:", @"\nMonitoring LS: %s", v85);
          pid_t v86 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(v69 + 96) UUIDString]);
          -[NSMutableString appendFormat:]( v72,  "appendFormat:",  @"\n\n--------- Links to %@ status ---------",  v86);

          __int128 v116 = 0u;
          __int128 v117 = 0u;
          __int128 v114 = 0u;
          __int128 v115 = 0u;
          id v87 = *(id *)(v69 + 112);
          id v88 = [v87 countByEnumeratingWithState:&v114 objects:v119 count:16];
          if (v88)
          {
            id v89 = v88;
            uint64_t v90 = *(void *)v115;
            do
            {
              for (k = 0LL; k != v89; k = (char *)k + 1)
              {
                if (*(void *)v115 != v90) {
                  objc_enumerationMutation(v87);
                }
                id v92 = [*(id *)(*((void *)&v114 + 1) + 8 * (void)k) copyStatusString];
                -[NSMutableString appendFormat:](v72, "appendFormat:", @"\n%@", v92);
              }

              id v89 = [v87 countByEnumeratingWithState:&v114 objects:v119 count:16];
            }

            while (v89);
          }

          id v11 = v104;
          id v29 = v84;
        }

        else
        {
          uint64_t v72 = 0LL;
        }

        -[NSMutableString appendFormat:](v11, "appendFormat:", @"\n\n%@", v72);
      }

      id v107 = [obj countByEnumeratingWithState:&v109 objects:v118 count:16];
    }

    while (v107);
  }

  if (qword_1001DC8A0 != -1) {
    dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC898, 2LL))
  {
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    id v93 = (id)qword_1001DC898;
    _NRLogWithArgs( v93,  2LL,  "%s%.30s:%-4d Director created status string %llu characters long",  "",  "-[NRLinkDirector copyStatusString]",  713,  -[NSMutableString length](v11, "length"));
  }

  if (v11)
  {
    if (qword_1001DC858 != -1) {
      dispatch_once(&qword_1001DC858, &stru_1001AEE78);
    }
    id v94 = (id)qword_1001DC850;
    if (v94)
    {
      id v95 = objc_alloc(&OBJC_CLASS___NSString);
      else {
        id v96 = "dis";
      }
      uint64_t v97 = -[NSString initWithFormat:]( v95,  "initWithFormat:",  @"\tCompanion link is currently %sabled on this device",  v96);
      id v98 = objc_alloc(&OBJC_CLASS___NSString);
      if (gNRPacketLoggingEnabled) {
        uint64_t v99 = "en";
      }
      else {
        uint64_t v99 = "dis";
      }
      uint64_t v100 = -[NSString initWithFormat:]( v98,  "initWithFormat:",  @"%@, packet logging %sabled\n%@\n%@",  v94,  v99,  v97,  v11);
    }

    else
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC770, 17LL))
      {
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        _NRLogWithArgs(qword_1001DC770, 17LL, "Failed to copy terminusd status");
      }

      uint64_t v100 = 0LL;
    }
  }

  else
  {
LABEL_147:
    if (qword_1001DC778 != -1) {
      dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC770, 17LL))
    {
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      _NRLogWithArgs(qword_1001DC770, 17LL, "Failed to copy status string from LinkDirector");
    }

    id v11 = 0LL;
    uint64_t v100 = 0LL;
  }

  return v100;
}

id sub_10005AB28(void *a1)
{
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    if ([v1 length])
    {
      uint64_t v3 = sub_1000599A4();
      id v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
      if (!v4)
      {
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC770, 17LL))
        {
          if (qword_1001DC778 != -1) {
            dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
          }
          _NRLogWithArgs(qword_1001DC770, 17LL, "Companion link status is empty failed");
          uint64_t v12 = 0LL;
        }

        else
        {
          uint64_t v12 = 0LL;
        }

        goto LABEL_69;
      }

      unint64_t v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
      char v25 = 0;
      if (![v5 fileExistsAtPath:v2 isDirectory:&v25] || !v25)
      {
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
        {
          if (qword_1001DC778 != -1) {
            dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
          }
          _NRLogWithArgs( qword_1001DC770,  0LL,  "%s%.30s:%-4d Creating temporary directory at %@",  "",  "dumpLinkStatusToDirectoryAt",  264LL,  v2);
        }

        id v24 = 0LL;
        [v5 createDirectoryAtPath:v2 withIntermediateDirectories:1 attributes:0 error:&v24];
        id v13 = v24;
        if (v13)
        {
          id v7 = v13;
          if (qword_1001DC778 != -1) {
            dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
          {
            if (qword_1001DC778 != -1) {
              dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
            }
            _NRLogWithArgs( qword_1001DC770,  16LL,  "%s%.30s:%-4d Failed to create directory at %@: %@",  "",  "dumpLinkStatusToDirectoryAt",  271LL,  v2,  v7);
          }

          goto LABEL_67;
        }

        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
        {
          if (qword_1001DC778 != -1) {
            dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
          }
          _NRLogWithArgs( qword_1001DC770,  0LL,  "%s%.30s:%-4d Created temporary directory at %@",  "",  "dumpLinkStatusToDirectoryAt",  274LL,  v2);
        }
      }

      uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v2 stringByAppendingPathComponent:@"companion_link_status_tv.txt"]);
      if (qword_1001DC778 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
      {
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        _NRLogWithArgs( qword_1001DC770,  0LL,  "%s%.30s:%-4d Writing companion link status to %@",  "",  "dumpLinkStatusToDirectoryAt",  281LL,  v6);
      }

      id v7 = v6;
      id v8 = v4;
      if (v7)
      {
        if ([v7 length])
        {
          id v9 = (id)objc_claimAutoreleasedReturnValue([v8 dataUsingEncoding:4]);
          char v10 = sub_1001010F0(v7, v9, 0);
          goto LABEL_15;
        }

        id v21 = sub_100100C84();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v21, 17LL);

        if (IsLevelEnabled)
        {
          id v9 = sub_100100C84();
          _NRLogWithArgs(v9, 17LL, "%s called with null filePath.length");
          goto LABEL_59;
        }
      }

      else
      {
        id v19 = sub_100100C84();
        int v20 = _NRLogIsLevelEnabled(v19, 17LL);

        if (v20)
        {
          id v9 = sub_100100C84();
          _NRLogWithArgs(v9, 17LL, "%s called with null filePath");
LABEL_59:
          char v10 = 0;
LABEL_15:

          uint64_t v11 = qword_1001DC778;
          if ((v10 & 1) != 0)
          {
            if (qword_1001DC778 != -1) {
              dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
            }
            if (_NRLogIsLevelEnabled(qword_1001DC770, 0LL))
            {
              if (qword_1001DC778 != -1) {
                dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
              }
              _NRLogWithArgs( qword_1001DC770,  0LL,  "%s%.30s:%-4d Wrote companion link status to %@",  "",  "dumpLinkStatusToDirectoryAt",  288LL,  v7);
            }

            id v26 = v7;
            uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v26,  1LL));
            goto LABEL_68;
          }

          goto LABEL_61;
        }
      }

      uint64_t v11 = qword_1001DC778;
LABEL_61:
      if (v11 != -1) {
        dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC770, 16LL))
      {
        if (qword_1001DC778 != -1) {
          dispatch_once(&qword_1001DC778, &stru_1001AE7B8);
        }
        _NRLogWithArgs( qword_1001DC770,  16LL,  "%s%.30s:%-4d Failed to write companion link status to %@",  "",  "dumpLinkStatusToDirectoryAt",  285LL,  v7);
      }

double sub_10005B18C(uint64_t a1, uint64_t a2)
{
  *(void *)&double result = 136446722LL;
  *(_DWORD *)a1 = 136446722;
  *(void *)(a1 + 4) = a2;
  *(_WORD *)(a1 + 12) = 2048;
  *(void *)(a1 + 14) = 0LL;
  *(_WORD *)(a1 + 22) = 1024;
  *(_DWORD *)(a1 + 24) = 0;
  return result;
}

void sub_10005B330(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  int v2 = (void *)qword_1001DC780;
  qword_1001DC780 = (uint64_t)v1;
}

char *sub_10005B360(id *a1, void *a2)
{
  id v4 = a2;
  unint64_t v5 = v4;
  if (!a1)
  {
LABEL_10:
    uint64_t v12 = 0LL;
    goto LABEL_11;
  }

  if ((_NRIsAppleInternal(v4) & 1) == 0)
  {
    p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    if (qword_1001DC788 == -1) {
      goto LABEL_6;
    }
    goto LABEL_15;
  }

  v22.receiver = a1;
  v22.super_class = (Class)&OBJC_CLASS___NRDTestServer;
  uint64_t v6 = (id *)objc_msgSendSuper2(&v22, "init");
  if (!v6)
  {
    id v15 = sub_10005B5AC();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v15, 16LL);

    p_class_meths = (__objc2_meth_list **)"-[NRDTestServer initTestServerWithQueue:]";
    if (IsLevelEnabled)
    {
      id v17 = sub_10005B5AC();
      _NRLogWithArgs( v17,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDTestServer initTestServerWithQueue:]",  224);
    }

    unint64_t v5 = (void *)_os_log_pack_size(12LL);
    a1 = (id *)((char *)&v21 - ((__chkstk_darwin(v5) + 15) & 0xFFFFFFFFFFFFFFF0LL));
    int v18 = __error();
    uint64_t v19 = _os_log_pack_fill(a1, v5, *v18, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)uint64_t v19 = 136446210;
    *(void *)(v19 + 4) = "-[NRDTestServer initTestServerWithQueue:]";
    id v20 = sub_10005B5AC();
    _NRLogAbortWithPack(v20, a1);
LABEL_15:
    dispatch_once(&qword_1001DC788, &stru_1001AE940);
LABEL_6:
    if (_NRLogIsLevelEnabled(qword_1001DC780, 17LL))
    {
      if (p_class_meths[241] != (__objc2_meth_list *)-1LL) {
        dispatch_once(&qword_1001DC788, &stru_1001AE940);
      }
      _NRLogWithArgs(qword_1001DC780, 17LL, "Unsupported");
    }

    goto LABEL_10;
  }

  id v7 = v6;
  objc_storeStrong(v6 + 2, a2);
  id v8 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v9 = v7[5];
  v7[5] = v8;

  char v10 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  id v11 = v7[8];
  v7[8] = v10;

  sub_10005B5EC((dispatch_source_t *)v7 + 6, v7[2], 0x464Fu);
  sub_10005B5EC((dispatch_source_t *)v7 + 7, v7[2], 0x4A37u);
  a1 = v7;
  uint64_t v12 = a1;
LABEL_11:

  return (char *)v12;
}

id sub_10005B5AC()
{
  if (qword_1001DC788 != -1) {
    dispatch_once(&qword_1001DC788, &stru_1001AE940);
  }
  return (id)qword_1001DC780;
}

void sub_10005B5EC(dispatch_source_t *a1, void *a2, unsigned int a3)
{
  unint64_t v5 = a2;
  if (a1)
  {
    if (*a1)
    {
      dispatch_source_cancel(*a1);
      dispatch_source_t v6 = *a1;
      *a1 = 0LL;
    }

    int v7 = socket(30, 2, 0);
    if ((v7 & 0x80000000) == 0)
    {
      unsigned int v8 = v7;
      int v9 = fcntl(v7, 3, 0LL);
      if (v9 < 0)
      {
        id v11 = __error();
        if (strerror_r(*v11, __strerrbuf, 0x80uLL)) {
          __strerrbuf[0] = 0;
        }
        if (qword_1001DC788 != -1) {
          dispatch_once(&qword_1001DC788, &stru_1001AE940);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC780, 17LL))
        {
          if (qword_1001DC788 != -1) {
            dispatch_once(&qword_1001DC788, &stru_1001AE940);
          }
          _NRLogWithArgs(qword_1001DC780, 17LL, "fcntl(%d, F_GETFL, 0): [%d] %s");
        }

        goto LABEL_38;
      }

      if (fcntl(v8, 4, v9 | 4u))
      {
        char v10 = __error();
        if (strerror_r(*v10, __strerrbuf, 0x80uLL)) {
          __strerrbuf[0] = 0;
        }
        if (qword_1001DC788 != -1) {
          dispatch_once(&qword_1001DC788, &stru_1001AE940);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC780, 17LL))
        {
          if (qword_1001DC788 != -1) {
            dispatch_once(&qword_1001DC788, &stru_1001AE940);
          }
          _NRLogWithArgs(qword_1001DC780, 17LL, "fcntl(%d, F_SETFL, %d): [%d] %s");
        }

        goto LABEL_38;
      }

      if (setsockopt(v8, 0xFFFF, 4, &unk_1001568A8, 4u))
      {
        uint64_t v12 = __error();
        if (strerror_r(*v12, __strerrbuf, 0x80uLL)) {
          __strerrbuf[0] = 0;
        }
        if (qword_1001DC788 != -1) {
          dispatch_once(&qword_1001DC788, &stru_1001AE940);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC780, 17LL))
        {
          if (qword_1001DC788 != -1) {
            dispatch_once(&qword_1001DC788, &stru_1001AE940);
          }
          _NRLogWithArgs(qword_1001DC780, 17LL, "SO_REUSEADDR failed: [%d] %s");
        }

        goto LABEL_38;
      }

      if (setsockopt(v8, 0xFFFF, 512, &unk_1001568A8, 4u))
      {
        id v14 = __error();
        if (strerror_r(*v14, __strerrbuf, 0x80uLL)) {
          __strerrbuf[0] = 0;
        }
        if (qword_1001DC788 != -1) {
          dispatch_once(&qword_1001DC788, &stru_1001AE940);
        }
        id v15 = sub_10005B5AC();
        _NRLogWithArgs(v15, 17LL, "SO_REUSEPORT failed: [%d] %s");
      }

      else if (setsockopt(v8, 0xFFFF, 4356, &unk_1001568A8, 4u))
      {
        id v16 = __error();
        if (strerror_r(*v16, __strerrbuf, 0x80uLL)) {
          __strerrbuf[0] = 0;
        }
        id v17 = sub_10005B5AC();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v17, 17LL);

        if (!IsLevelEnabled) {
          goto LABEL_38;
        }
        id v15 = sub_10005B5AC();
        _NRLogWithArgs(v15, 17LL, "SO_RECV_ANYIF failed: [%d] %s");
      }

      else if (setsockopt(v8, 41, 27, &unk_1001568A8, 4u))
      {
        uint64_t v19 = __error();
        if (strerror_r(*v19, __strerrbuf, 0x80uLL)) {
          __strerrbuf[0] = 0;
        }
        id v20 = sub_10005B5AC();
        int v21 = _NRLogIsLevelEnabled(v20, 17LL);

        if (!v21) {
          goto LABEL_38;
        }
        id v15 = sub_10005B5AC();
        _NRLogWithArgs(v15, 17LL, "IPV6_V6ONLY failed: [%d] %s");
      }

      else if (setsockopt(v8, 0xFFFF, 4130, &unk_1001568A8, 4u))
      {
        objc_super v22 = __error();
        if (strerror_r(*v22, __strerrbuf, 0x80uLL)) {
          __strerrbuf[0] = 0;
        }
        id v23 = sub_10005B5AC();
        int v24 = _NRLogIsLevelEnabled(v23, 17LL);

        if (!v24) {
          goto LABEL_38;
        }
        id v15 = sub_10005B5AC();
        _NRLogWithArgs(v15, 17LL, "SO_NOSIGPIPE failed: [%d] %s");
      }

      else if (setsockopt(v8, 41, 61, &unk_1001568A8, 4u))
      {
        char v25 = __error();
        if (strerror_r(*v25, __strerrbuf, 0x80uLL)) {
          __strerrbuf[0] = 0;
        }
        id v26 = sub_10005B5AC();
        int v27 = _NRLogIsLevelEnabled(v26, 17LL);

        if (!v27) {
          goto LABEL_38;
        }
        id v15 = sub_10005B5AC();
        _NRLogWithArgs(v15, 17LL, "IPV6_RECVPKTINFO failed: [%d] %s");
      }

      else
      {
        *(void *)&void v45[4] = 0LL;
        *(void *)&v45[12] = 0LL;
        uint64_t v46 = 0LL;
        *(_WORD *)int v45 = 7708;
        *(_WORD *)&void v45[2] = __rev16(a3);
        if (!bind(v8, (const sockaddr *)v45, 0x1Cu))
        {
          dispatch_source_t v34 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v8, 0LL, v5);
          dispatch_source_t v35 = *a1;
          *a1 = v34;

          id v36 = *a1;
          if (*a1)
          {
            handler[0] = _NSConcreteStackBlock;
            handler[1] = 3221225472LL;
            handler[2] = sub_10005BD7C;
            handler[3] = &unk_1001AE960;
            unsigned int v44 = v8;
            dispatch_source_set_event_handler(v36, handler);
            uint64_t v37 = *a1;
            v41[0] = _NSConcreteStackBlock;
            v41[1] = 3221225472LL;
            v41[2] = sub_10005C394;
            v41[3] = &unk_1001AE960;
            unsigned int v42 = v8;
            dispatch_source_set_cancel_handler(v37, v41);
            dispatch_activate(*a1);
            goto LABEL_41;
          }

          id v38 = sub_10005B5AC();
          int v39 = _NRLogIsLevelEnabled(v38, 17LL);

          if (v39)
          {
            id v40 = sub_10005B5AC();
            _NRLogWithArgs(v40, 17LL, "dispatch_source_create failed");
          }

          goto LABEL_38;
        }

        id v31 = __error();
        if (strerror_r(*v31, __strerrbuf, 0x80uLL)) {
          __strerrbuf[0] = 0;
        }
        id v32 = sub_10005B5AC();
        int v33 = _NRLogIsLevelEnabled(v32, 17LL);

        if (!v33)
        {
LABEL_38:
          if (*a1)
          {
            dispatch_source_cancel(*a1);
            dispatch_source_t v13 = *a1;
            *a1 = 0LL;
          }

          else
          {
            close(v8);
          }

          goto LABEL_41;
        }

        id v15 = sub_10005B5AC();
        _NRLogWithArgs(v15, 17LL, "bind failed: [%d] %s");
      }

      goto LABEL_38;
    }

    if (qword_1001DC788 != -1) {
      dispatch_once(&qword_1001DC788, &stru_1001AE940);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC780, 17LL))
    {
      if (qword_1001DC788 != -1) {
        dispatch_once(&qword_1001DC788, &stru_1001AE940);
      }
      _NRLogWithArgs(qword_1001DC780, 17LL, "socket(AF_INET6, SOCK_DGRAM, 0) failed");
    }
  }

  else
  {
    id v28 = sub_10005B5AC();
    int v29 = _NRLogIsLevelEnabled(v28, 17LL);

    if (v29)
    {
      id v30 = sub_10005B5AC();
      _NRLogWithArgs(v30, 17LL, "%s called with null udpInputSourcePtr", "NRDTSCreateUDPListeningSocket");
    }
  }

int *sub_10005BD7C(uint64_t a1)
{
  while (1)
  {
    memset(v14, 0, sizeof(v14));
    v10[0] = v13;
    v10[1] = 2000LL;
    v9.msg_name = &v11;
    v9.msg_namelen = 28;
    v9.msg_iov = (iovec *)v10;
    v9.msg_iovlen = 1;
    v9.msg_control = v14;
    *(void *)&v9.msg_controllen = 32LL;
    ssize_t v2 = recvmsg(*(_DWORD *)(a1 + 32), &v9, 0);
    if (v2 < 0) {
      break;
    }
    if (!v2)
    {
      if (qword_1001DC788 != -1) {
        dispatch_once(&qword_1001DC788, &stru_1001AE940);
      }
      double result = (int *)_NRLogIsLevelEnabled(qword_1001DC780, 16LL);
      if ((_DWORD)result)
      {
        if (qword_1001DC788 != -1) {
          dispatch_once(&qword_1001DC788, &stru_1001AE940);
        }
        return (int *)_NRLogWithArgs(qword_1001DC780, 16LL, "%s%.30s:%-4d Received empty UDP datagram");
      }

      return result;
    }

    if (v9.msg_namelen >= 0x1C && (msg_name = (unsigned __int8 *)v9.msg_name) != 0LL)
    {
      if (*((_BYTE *)v9.msg_name + 1) == 30)
      {
        socklen_t v4 = *(unsigned __int8 *)v9.msg_name;
        if (v4 > 0x1B)
        {
          if (v9.msg_controllen - 33 >= 0xFFFFFFF3 && v9.msg_control == v14)
          {
            if (DWORD2(v14[0]) == 46)
            {
              v8[0] = v13;
              v8[1] = v2;
              v7.msg_name = v9.msg_name;
              v7.msg_namelen = v4;
              v7.msg_iov = (iovec *)v8;
              v7.msg_iovlen = 1;
              v7.msg_control = v14;
              *(void *)&v7.msg_controllen = 32LL;
              if (sendmsg(*(_DWORD *)(a1 + 32), &v7, 0) <= 0)
              {
                int v5 = *__error();
                if (strerror_r(v5, __strerrbuf, 0x80uLL)) {
                  __strerrbuf[0] = 0;
                }
                if (qword_1001DC788 != -1) {
                  dispatch_once(&qword_1001DC788, &stru_1001AE940);
                }
                if (_NRLogIsLevelEnabled(qword_1001DC780, 17LL))
                {
                  if (qword_1001DC788 != -1) {
                    dispatch_once(&qword_1001DC788, &stru_1001AE940);
                  }
                  _NRLogWithArgs(qword_1001DC780, 17LL, "sendmsg failed: [%d] %s", v5, __strerrbuf);
                }
              }
            }

            else
            {
              if (qword_1001DC788 != -1) {
                dispatch_once(&qword_1001DC788, &stru_1001AE940);
              }
              if (_NRLogIsLevelEnabled(qword_1001DC780, 16LL))
              {
                if (qword_1001DC788 != -1) {
                  dispatch_once(&qword_1001DC788, &stru_1001AE940);
                }
                _NRLogWithArgs( qword_1001DC780,  16LL,  "%s%.30s:%-4d Invalid cmsg_type %d",  "",  "NRDTSCreateUDPListeningSocket_block_invoke",  162,  DWORD2(v14[0]));
              }
            }
          }

          else
          {
            if (qword_1001DC788 != -1) {
              dispatch_once(&qword_1001DC788, &stru_1001AE940);
            }
            if (_NRLogIsLevelEnabled(qword_1001DC780, 16LL))
            {
              if (qword_1001DC788 != -1) {
                dispatch_once(&qword_1001DC788, &stru_1001AE940);
              }
              _NRLogWithArgs( qword_1001DC780,  16LL,  "%s%.30s:%-4d missing control message %u %p %p",  "",  "NRDTSCreateUDPListeningSocket_block_invoke",  157,  v9.msg_controllen,  v9.msg_control,  v14);
            }
          }
        }

        else
        {
          if (qword_1001DC788 != -1) {
            dispatch_once(&qword_1001DC788, &stru_1001AE940);
          }
          if (_NRLogIsLevelEnabled(qword_1001DC780, 16LL))
          {
            if (qword_1001DC788 != -1) {
              dispatch_once(&qword_1001DC788, &stru_1001AE940);
            }
            _NRLogWithArgs( qword_1001DC780,  16LL,  "%s%.30s:%-4d packet source sin6_len too short %u < %zu",  "",  "NRDTSCreateUDPListeningSocket_block_invoke",  152,  *msg_name,  0x1CuLL);
          }
        }
      }

      else
      {
        if (qword_1001DC788 != -1) {
          dispatch_once(&qword_1001DC788, &stru_1001AE940);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC780, 16LL))
        {
          if (qword_1001DC788 != -1) {
            dispatch_once(&qword_1001DC788, &stru_1001AE940);
          }
          _NRLogWithArgs( qword_1001DC780,  16LL,  "%s%.30s:%-4d packet came from wrong address family %u",  "",  "NRDTSCreateUDPListeningSocket_block_invoke",  148,  msg_name[1]);
        }
      }
    }

    else
    {
      if (qword_1001DC788 != -1) {
        dispatch_once(&qword_1001DC788, &stru_1001AE940);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC780, 16LL))
      {
        if (qword_1001DC788 != -1) {
          dispatch_once(&qword_1001DC788, &stru_1001AE940);
        }
        _NRLogWithArgs( qword_1001DC780,  16LL,  "%s%.30s:%-4d missing name message %u %p",  "",  "NRDTSCreateUDPListeningSocket_block_invoke",  142,  v9.msg_namelen,  v9.msg_name);
      }
    }
  }

  double result = __error();
  if (*result != 35)
  {
    if (strerror_r(*result, __strerrbuf, 0x80uLL)) {
      __strerrbuf[0] = 0;
    }
    if (qword_1001DC788 != -1) {
      dispatch_once(&qword_1001DC788, &stru_1001AE940);
    }
    double result = (int *)_NRLogIsLevelEnabled(qword_1001DC780, 17LL);
    if ((_DWORD)result)
    {
      if (qword_1001DC788 != -1) {
        dispatch_once(&qword_1001DC788, &stru_1001AE940);
      }
      return (int *)_NRLogWithArgs(qword_1001DC780, 17LL, "recvmsg failed: [%d] %s");
    }
  }

  return result;
}

uint64_t sub_10005C394(uint64_t a1)
{
  return close(*(_DWORD *)(a1 + 32));
}

id sub_10005C39C(uint64_t a1, int a2)
{
  nw_parameters_t v4 = nw_parameters_create();
  nw_parameters_set_required_interface_subtype(v4, 5001LL);
  id v5 = *(id *)(a1 + 16);
  if (a2) {
    uint64_t v6 = 18999LL;
  }
  else {
    uint64_t v6 = 17999LL;
  }
  uint64_t v7 = nw_service_connector_create(v6, v4, v5);
  unsigned int v8 = (void *)objc_claimAutoreleasedReturnValue(v7);

  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472LL;
  _OWORD v14[2] = sub_10005C474;
  v14[3] = &unk_1001AE880;
  id v9 = v8;
  id v15 = v9;
  uint64_t v16 = a1;
  nw_service_connector_set_service_available_block(v9, v14, v10, v11);
  nw_service_connector_start(v9);
  id v12 = v9;

  return v12;
}

void sub_10005C474(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  if (qword_1001DC788 != -1) {
    dispatch_once(&qword_1001DC788, &stru_1001AE940);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC780, 1LL))
  {
    if (qword_1001DC788 != -1) {
      dispatch_once(&qword_1001DC788, &stru_1001AE940);
    }
    _NRLogWithArgs( qword_1001DC780,  1LL,  "%s%.30s:%-4d Received service connection request: %s(%@)",  "",  "-[NRDTestServer createServiceConnector:]_block_invoke",  295LL,  a3,  v5);
  }

  uint64_t v6 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", a3);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472LL;
  void v10[2] = sub_10005C5F0;
  v10[3] = &unk_1001AE858;
  uint64_t v7 = *(void **)(a1 + 32);
  v10[4] = *(void *)(a1 + 40);
  id v11 = v5;
  uint64_t v14 = a3;
  id v12 = v6;
  id v13 = v7;
  unsigned int v8 = v6;
  id v9 = v5;
  nw_service_connector_start_request(v13, v9, a3, 0LL, v10);
}

void sub_10005C5F0(void *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v41 = v5;
  if (a3)
  {
    if (qword_1001DC788 != -1) {
      dispatch_once(&qword_1001DC788, &stru_1001AE940);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC780, 16LL))
    {
      if (qword_1001DC788 != -1) {
        dispatch_once(&qword_1001DC788, &stru_1001AE940);
      }
      _NRLogWithArgs( qword_1001DC780,  16LL,  "%s%.30s:%-4d Cannot establish connection for service %s: %@",  "",  "-[NRDTestServer createServiceConnector:]_block_invoke_2",  301LL,  a1[8],  a3);
    }
  }

  else
  {
    uint64_t v7 = a1[4];
    uint64_t v6 = (void *)a1[5];
    id v9 = (void *)a1[6];
    unsigned int v8 = (void *)a1[7];
    uint64_t v10 = (nw_connection *)v5;
    id v11 = v6;
    id v12 = v9;
    id v13 = v8;
    if (v7)
    {
      nw_path_t v14 = nw_connection_copy_current_path(v10);
      uint64_t v15 = nw_path_copy_interface(v14);
      nw_path_t v40 = v14;
      if (qword_1001DC788 != -1) {
        dispatch_once(&qword_1001DC788, &stru_1001AE940);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC780, 1LL))
      {
        if (qword_1001DC788 != -1) {
          dispatch_once(&qword_1001DC788, &stru_1001AE940);
        }
        _NRLogWithArgs( qword_1001DC780,  1LL,  "%s%.30s:%-4d Established connection on interface: %@ for service: %@",  "",  "-[NRDTestServer handleNewConnection:forPeerEndpoint:forService:forServiceConnector:]",  333LL,  v15,  v12);
      }

      [*(id *)(v7 + 40) setObject:v10 forKeyedSubscript:v12];
      if ([v12 containsString:@"-urgent"])
      {
        nw_connection_reset_traffic_class(v10, 700LL);
        uint64_t v16 = 2LL;
      }

      else
      {
        uint64_t v16 = 5LL;
      }

      int v39 = (void *)v15;
      if ([v12 containsString:@"-awdl"])
      {
        id v38 = v10;
        id v17 = [[NRCompanionLinkPreferences alloc] initForHighThroughputWithServiceClass:v16 includeP2P:1];
        uint64_t v37 = v11;
        int v18 = nw_endpoint_copy_address_string(v11);
        uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v18));
        if (v18) {
          free(v18);
        }
        __int128 v53 = 0u;
        __int128 v54 = 0u;
        __int128 v51 = 0u;
        __int128 v52 = 0u;
        id v20 = sub_1001314D4((uint64_t)&OBJC_CLASS___NRDLocalDevice);
        id v21 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v20,  "countByEnumeratingWithState:objects:count:",  &v51,  v55,  16LL);
        if (v21)
        {
          id v34 = v17;
          id v35 = v13;
          id v36 = v12;
          uint64_t v22 = *(void *)v52;
LABEL_23:
          uint64_t v23 = 0LL;
          while (1)
          {
            if (*(void *)v52 != v22) {
              objc_enumerationMutation(v20);
            }
            int v24 = *(void **)(*((void *)&v51 + 1) + 8 * v23);
            char v25 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v24);
            id v26 = sub_100136E34(v25);

            if (v21 == (id)++v23)
            {
              id v21 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v20,  "countByEnumeratingWithState:objects:count:",  &v51,  v55,  16LL);
              if (v21) {
                goto LABEL_23;
              }
              id v13 = v35;
              id v12 = v36;
              id v17 = v34;
              goto LABEL_35;
            }
          }

          id v21 = v24;

          if (!v21)
          {
            id v13 = v35;
            id v12 = v36;
            id v17 = v34;
            goto LABEL_37;
          }

          id v20 = (NSMutableArray *)objc_claimAutoreleasedReturnValue([*(id *)(v7 + 64) objectForKeyedSubscript:v21]);
          id v12 = v36;
          id v17 = v34;
          if (!v20)
          {
            id v27 = [[NRDeviceIdentifier alloc] initWithUUID:v21];
            id v20 = (NSMutableArray *)[[NRDevicePreferences alloc] initWithDeviceIdentifier:v27];
          }

          -[NSMutableArray setIsNRDTestServer:](v20, "setIsNRDTestServer:", 1LL);
          -[NSMutableArray setCompanionLinkPreferences:](v20, "setCompanionLinkPreferences:", v34);
          [*(id *)(v7 + 64) setObject:v20 forKeyedSubscript:v21];
          id v13 = v35;
        }

void sub_10005CB3C(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (qword_1001DC788 != -1) {
    dispatch_once(&qword_1001DC788, &stru_1001AE940);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC780, 1LL))
  {
    if (qword_1001DC788 != -1) {
      dispatch_once(&qword_1001DC788, &stru_1001AE940);
    }
    uint64_t v6 = *(void *)(a1 + 32);
    id v7 = (id)qword_1001DC780;
    uint64_t v8 = nw_connection_state_to_string(a2);
    _NRLogWithArgs( v7,  1LL,  "%s%.30s:%-4d Connection for service %@ entered state %swith error %@",  "",  "-[NRDTestServer handleNewConnection:forPeerEndpoint:forService:forServiceConnector:]_block_invoke",  376LL,  v6,  v8,  v5);
  }

  if ((a2 & 0xFFFFFFFE) == 4)
  {
    if (qword_1001DC788 != -1) {
      dispatch_once(&qword_1001DC788, &stru_1001AE940);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC780, 1LL))
    {
      if (qword_1001DC788 != -1) {
        dispatch_once(&qword_1001DC788, &stru_1001AE940);
      }
      _NRLogWithArgs( qword_1001DC780,  1LL,  "%s%.30s:%-4d Cancelling connection for key: %@",  "",  "-[NRDTestServer handleNewConnection:forPeerEndpoint:forService:forServiceConnector:]_block_invoke",  378LL,  *(void *)(a1 + 32));
    }

    if (*(void *)(a1 + 40))
    {
      uint64_t v9 = *(void *)(a1 + 48);
      if (v9) {
        uint64_t v10 = *(void **)(v9 + 64);
      }
      else {
        uint64_t v10 = 0LL;
      }
      id v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:"));
      id v12 = v11;
      if (v11) {
        [v11 setCompanionLinkPreferences:0];
      }
    }

    uint64_t v13 = *(void *)(a1 + 56);
    uint64_t v14 = *(void *)(a1 + 64);
    id v15 = [*(id *)(a1 + 32) UTF8String];
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472LL;
    v19[2] = sub_10005CEB0;
    v19[3] = &unk_1001B0A88;
    id v20 = *(id *)(a1 + 32);
    nw_service_connector_cancel_active_connection(v13, v14, v15, v19);
    uint64_t v16 = *(void *)(a1 + 48);
    if (v16) {
      id v17 = *(void **)(v16 + 40);
    }
    else {
      id v17 = 0LL;
    }
    [v17 removeObjectForKey:*(void *)(a1 + 32)];
  }

  else if ((_DWORD)a2 == 3)
  {
    sub_10005CF70(*(void *)(a1 + 48), *(void **)(a1 + 72), *(void **)(a1 + 32));
    if ([*(id *)(a1 + 32) hasPrefix:@"Terminus download service"])
    {
      uint64_t v18 = *(void *)(a1 + 48);
      if (v18) {
        sub_10005D020(v18, 0LL, *(void **)(a1 + 72));
      }
    }
  }
}

id sub_10005CDD0(uint64_t a1)
{
  if (qword_1001DC788 != -1) {
    dispatch_once(&qword_1001DC788, &stru_1001AE940);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC780, 1LL))
  {
    if (qword_1001DC788 != -1) {
      dispatch_once(&qword_1001DC788, &stru_1001AE940);
    }
    _NRLogWithArgs( qword_1001DC780,  1LL,  "%s%.30s:%-4d Connection for service %@ got READ_CLOSE event",  "",  "-[NRDTestServer handleNewConnection:forPeerEndpoint:forService:forServiceConnector:]_block_invoke_3",  399LL,  *(void *)(a1 + 32));
  }

  nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
  uint64_t v2 = *(void *)(a1 + 48);
  if (v2) {
    uint64_t v3 = *(void **)(v2 + 40);
  }
  else {
    uint64_t v3 = 0LL;
  }
  return [v3 removeObjectForKey:*(void *)(a1 + 32)];
}

uint64_t sub_10005CEB0(uint64_t a1)
{
  if (qword_1001DC788 != -1) {
    dispatch_once(&qword_1001DC788, &stru_1001AE940);
  }
  uint64_t result = _NRLogIsLevelEnabled(qword_1001DC780, 1LL);
  if ((_DWORD)result)
  {
    if (qword_1001DC788 != -1) {
      dispatch_once(&qword_1001DC788, &stru_1001AE940);
    }
    return _NRLogWithArgs( qword_1001DC780,  1LL,  "%s%.30s:%-4d Cancelled connection for key: %@",  "",  "-[NRDTestServer handleNewConnection:forPeerEndpoint:forService:forServiceConnector:]_block_invoke_2",  387LL,  *(void *)(a1 + 32));
  }

  return result;
}

void sub_10005CF70(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    completion[0] = _NSConcreteStackBlock;
    completion[1] = 3221225472LL;
    completion[2] = sub_10005D394;
    completion[3] = &unk_1001AE8F8;
    uint64_t v8 = (nw_connection *)v5;
    id v9 = v6;
    uint64_t v10 = a1;
    nw_connection_receive(v8, 1u, 0xFFFFFFFF, completion);
  }
}

void sub_10005D020(uint64_t a1, void *a2, void *a3)
{
  dispatch_data_t v5 = a2;
  id v6 = a3;
  if (a1)
  {
    if (!v5)
    {
      id v7 = (char *)malloc(0x40000uLL);
      if (!v7)
      {
        id v14 = sub_10005B5AC();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v14, 16LL);

        if (IsLevelEnabled)
        {
          id v16 = sub_10005B5AC();
          _NRLogWithArgs( v16,  16LL,  "%s%.30s:%-4d ABORTING: strict_malloc(%zu) failed",  "",  "strict_malloc",  79,  0x40000uLL);
        }

        uint64_t v17 = _os_log_pack_size(22LL);
        uint64_t v18 = (char *)completion - ((__chkstk_darwin(v17) + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v19 = __error();
        uint64_t v20 = _os_log_pack_fill( v18,  v17,  *v19,  &_mh_execute_header,  "%{public}s strict_malloc(%zu) failed");
        *(_DWORD *)uint64_t v20 = 136446466;
        *(void *)(v20 + 4) = "strict_malloc";
        *(_WORD *)(v20 + 12) = 2048;
        *(void *)(v20 + 14) = 0x40000LL;
        id v21 = sub_10005B5AC();
        _NRLogAbortWithPack(v21, v18);
      }

      uint64_t v8 = v7;
      uint64_t v9 = 0LL;
      int8x16_t v10 = (int8x16_t)xmmword_100156960;
      v11.i64[0] = 0x1010101010101010LL;
      v11.i64[1] = 0x1010101010101010LL;
      v12.i64[0] = 0x2020202020202020LL;
      v12.i64[1] = 0x2020202020202020LL;
      do
      {
        uint64_t v13 = (int8x16_t *)&v7[v9];
        int8x16_t *v13 = v10;
        v13[1] = vaddq_s8(v10, v11);
        v9 += 32LL;
        int8x16_t v10 = vaddq_s8(v10, v12);
      }

      while (v9 != 0x40000);
      dispatch_data_t v5 = dispatch_data_create(v7, 0x40000uLL, *(dispatch_queue_t *)(a1 + 16), 0LL);
      free(v8);
    }

    completion[0] = _NSConcreteStackBlock;
    completion[1] = 3221225472LL;
    completion[2] = sub_10005D254;
    completion[3] = &unk_1001AE920;
    dispatch_data_t v5 = v5;
    dispatch_data_t v23 = v5;
    uint64_t v24 = a1;
    char v25 = (nw_connection *)v6;
    nw_connection_send(v25, v5, _nw_content_context_default_stream, 0, completion);
  }
}

void sub_10005D254(void *a1, void *a2)
{
  uint64_t v3 = a2;
  nw_parameters_t v4 = v3;
  if (v3 && (uint64_t error_code = nw_error_get_error_code(v3), (_DWORD)error_code))
  {
    uint64_t v6 = error_code;
    if (strerror_r(error_code, __strerrbuf, 0x80uLL)) {
      __strerrbuf[0] = 0;
    }
    if (qword_1001DC788 != -1) {
      dispatch_once(&qword_1001DC788, &stru_1001AE940);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC780, 16LL))
    {
      if (qword_1001DC788 != -1) {
        dispatch_once(&qword_1001DC788, &stru_1001AE940);
      }
      _NRLogWithArgs( qword_1001DC780,  16LL,  "%s%.30s:%-4d Failed to write data: %@: [%d] %s",  "",  "-[NRDTestServer sendTokenOnConnection:connection:]_block_invoke",  498LL,  a1[4],  v6,  __strerrbuf);
    }
  }

  else
  {
    sub_10005D020(a1[5], a1[4], a1[6]);
  }
}

void sub_10005D394(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v8 = a2;
  id v9 = a3;
  int8x16_t v10 = a5;
  int8x16_t v11 = v10;
  if (v10)
  {
    int error_code = nw_error_get_error_code(v10);
    if (!v8) {
      goto LABEL_14;
    }
  }

  else
  {
    int error_code = 0;
    if (!v8)
    {
LABEL_14:
      if (strerror_r(error_code, __strerrbuf, 0x80uLL)) {
        __strerrbuf[0] = 0;
      }
      if (qword_1001DC788 != -1) {
        dispatch_once(&qword_1001DC788, &stru_1001AE940);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC780, 16LL))
      {
        if (qword_1001DC788 != -1) {
          dispatch_once(&qword_1001DC788, &stru_1001AE940);
        }
        _NRLogWithArgs( qword_1001DC780,  16LL,  "%s%.30s:%-4d Failed to read data: [%d] %s",  "",  "-[NRDTestServer setReadHandlerOnConnection:forService:]_block_invoke",  415,  error_code,  __strerrbuf);
      }

      nw_connection_cancel(*(nw_connection_t *)(a1 + 32));
      goto LABEL_46;
    }
  }

  if (error_code) {
    goto LABEL_14;
  }
  uint64_t v13 = (dispatch_data_s *)v8;
  if ([*(id *)(a1 + 40) hasPrefix:@"Terminus ping service"])
  {
    if (qword_1001DC788 != -1) {
      dispatch_once(&qword_1001DC788, &stru_1001AE940);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC780, 2LL))
    {
      if (qword_1001DC788 != -1) {
        dispatch_once(&qword_1001DC788, &stru_1001AE940);
      }
      uint64_t v14 = qword_1001DC780;
      size_t size = dispatch_data_get_size(v13);
      _NRLogWithArgs( v14,  2LL,  "%s%.30s:%-4d Service ping server echoing %zu bytes on %@",  "",  "-[NRDTestServer setReadHandlerOnConnection:forService:]_block_invoke",  423LL,  size,  *(void *)(a1 + 40));
    }

    id v16 = *(nw_connection **)(a1 + 32);
    completion[0] = _NSConcreteStackBlock;
    completion[1] = 3221225472LL;
    completion[2] = sub_10005D914;
    completion[3] = &unk_1001AE8D0;
    int v37 = 0;
    dispatch_data_t v33 = v13;
    id v34 = *(id *)(a1 + 40);
    id v17 = *(id *)(a1 + 32);
    uint64_t v18 = *(void *)(a1 + 48);
    id v35 = v17;
    uint64_t v36 = v18;
    nw_connection_send(v16, v33, _nw_content_context_default_stream, 0, completion);
  }

  else if ([*(id *)(a1 + 40) hasPrefix:@"Terminus read write service"])
  {
    if (qword_1001DC788 != -1) {
      dispatch_once(&qword_1001DC788, &stru_1001AE940);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC780, 2LL))
    {
      if (qword_1001DC788 != -1) {
        dispatch_once(&qword_1001DC788, &stru_1001AE940);
      }
      uint64_t v19 = qword_1001DC780;
      size_t v20 = dispatch_data_get_size(v13);
      _NRLogWithArgs( v19,  2LL,  "%s%.30s:%-4d Read-write server echoing %zu bytes on %@",  "",  "-[NRDTestServer setReadHandlerOnConnection:forService:]_block_invoke",  444LL,  v20,  *(void *)(a1 + 40));
    }

    id v21 = *(nw_connection **)(a1 + 32);
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 3221225472LL;
    v26[2] = sub_10005DA64;
    v26[3] = &unk_1001AE8D0;
    int v31 = 0;
    dispatch_data_t v27 = v13;
    id v28 = *(id *)(a1 + 40);
    id v22 = *(id *)(a1 + 32);
    uint64_t v23 = *(void *)(a1 + 48);
    id v29 = v22;
    uint64_t v30 = v23;
    nw_connection_send(v21, v27, _nw_content_context_default_stream, 0, v26);
  }

  else
  {
    if ([*(id *)(a1 + 40) hasPrefix:@"Terminus download service"])
    {
      if (qword_1001DC788 != -1) {
        dispatch_once(&qword_1001DC788, &stru_1001AE940);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC780, 1LL))
      {
        if (qword_1001DC788 != -1) {
          dispatch_once(&qword_1001DC788, &stru_1001AE940);
        }
        uint64_t v24 = qword_1001DC780;
        size_t v25 = dispatch_data_get_size(v13);
        _NRLogWithArgs( v24,  1LL,  "%s%.30s:%-4d Download server received %zu bytes on %@",  "",  "-[NRDTestServer setReadHandlerOnConnection:forService:]_block_invoke",  464LL,  v25,  *(void *)(a1 + 40));
      }
    }

    else
    {
      if (qword_1001DC788 != -1) {
        dispatch_once(&qword_1001DC788, &stru_1001AE940);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC780, 16LL))
      {
        if (qword_1001DC788 != -1) {
          dispatch_once(&qword_1001DC788, &stru_1001AE940);
        }
        _NRLogWithArgs( qword_1001DC780,  16LL,  "%s%.30s:%-4d No service to write into for connection: %@, %@",  "",  "-[NRDTestServer setReadHandlerOnConnection:forService:]_block_invoke",  468LL,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
      }
    }

    sub_10005CF70(*(void *)(a1 + 48), *(void *)(a1 + 32), *(void *)(a1 + 40));
  }

LABEL_46:
}

void sub_10005D914(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  nw_parameters_t v4 = v3;
  if (v3 && nw_error_get_error_code(v3))
  {
    uint64_t v5 = *(unsigned int *)(a1 + 64);
    if (strerror_r(*(_DWORD *)(a1 + 64), __strerrbuf, 0x80uLL)) {
      __strerrbuf[0] = 0;
    }
    if (qword_1001DC788 != -1) {
      dispatch_once(&qword_1001DC788, &stru_1001AE940);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC780, 16LL))
    {
      if (qword_1001DC788 != -1) {
        dispatch_once(&qword_1001DC788, &stru_1001AE940);
      }
      _NRLogWithArgs( qword_1001DC780,  16LL,  "%s%.30s:%-4d Failed to write data: %@ on %@: [%d] %s",  "",  "-[NRDTestServer setReadHandlerOnConnection:forService:]_block_invoke_2",  435LL,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  v5,  __strerrbuf);
    }

    nw_connection_cancel(*(nw_connection_t *)(a1 + 48));
  }

  else
  {
    sub_10005CF70(*(void *)(a1 + 56), *(void *)(a1 + 48), *(void *)(a1 + 40));
  }
}

void sub_10005DA64(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  nw_parameters_t v4 = v3;
  if (v3 && nw_error_get_error_code(v3))
  {
    uint64_t v5 = *(unsigned int *)(a1 + 64);
    if (strerror_r(*(_DWORD *)(a1 + 64), __strerrbuf, 0x80uLL)) {
      __strerrbuf[0] = 0;
    }
    if (qword_1001DC788 != -1) {
      dispatch_once(&qword_1001DC788, &stru_1001AE940);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC780, 16LL))
    {
      if (qword_1001DC788 != -1) {
        dispatch_once(&qword_1001DC788, &stru_1001AE940);
      }
      _NRLogWithArgs( qword_1001DC780,  16LL,  "%s%.30s:%-4d Failed to write data: %@ on %@: [%d] %s",  "",  "-[NRDTestServer setReadHandlerOnConnection:forService:]_block_invoke_3",  455LL,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  v5,  __strerrbuf);
    }

    nw_connection_cancel(*(nw_connection_t *)(a1 + 48));
  }

  else
  {
    sub_10005CF70(*(void *)(a1 + 56), *(void *)(a1 + 48), *(void *)(a1 + 40));
  }
}

uint64_t sub_10005DE28(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0LL;
  }
  if (*(_BYTE *)(a1 + 15))
  {
    uint64_t v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
      size_t v25 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 agentDescription]);
      uint64_t v24 = "";
      _NRLogWithArgs(v6, 0LL, "%s%.30s:%-4d unregisterAgent: %@");
    }

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v7 = (id)qword_1001DCB58;
    sub_10012114C((uint64_t)v7, *(void **)(a1 + 88));

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v8 = (id)qword_1001DCB58;
    id v9 = (id *)v8;
    if (v8)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v8 + 1));
      if (([v9[2] apply] & 1) == 0) {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v10,  v11,  v12,  (uint64_t)v24);
      }
    }

    id v14 = [*(id *)(a1 + 48) unregisterNetworkAgent];
    if ((v14 & 1) != 0)
    {
      *(_BYTE *)(a1 + 15) = 0;
      [(id)a1 setActive:0];
      id v15 = *(id *)(a1 + 32);
      id v16 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 agentUUID]);
      id v17 = (void *)objc_claimAutoreleasedReturnValue([v16 UUIDString]);
      sub_10011BB18(v15, 12003, 0LL, v17);

      [*(id *)(a1 + 72) unregisterNetworkAgent];
      [*(id *)(a1 + 64) setActive:0];
      uint64_t v18 = *(void **)(a1 + 64);
      *(void *)(a1 + 64) = 0LL;

      uint64_t v19 = *(void **)(a1 + 72);
      *(void *)(a1 + 72) = 0LL;
LABEL_17:

      return (uint64_t)v14;
    }

    size_t v20 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v13);
    int v21 = _NRLogIsLevelEnabled(v20, 16LL);

    if (v21)
    {
      uint64_t v19 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v22);
      _NRLogWithArgs( v19,  16LL,  "%s%.30s:%-4d unable to unregister agent",  "",  "-[NRCompanionProxyAgent unregisterAgent]",  254);
      goto LABEL_17;
    }

    return 0LL;
  }

  return 1LL;
}

void sub_10005E374(uint64_t a1, uint64_t a2)
{
  if (a1 && *(_BYTE *)(a1 + 14))
  {
    uint64_t v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 agentDescription]);
      uint64_t v18 = "";
      _NRLogWithArgs(v6, 0LL, "%s%.30s:%-4d unregisterAgent: %@");
    }

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v7 = (id)qword_1001DCB58;
    sub_10012114C((uint64_t)v7, *(void **)(a1 + 64));

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v8 = (id)qword_1001DCB58;
    id v9 = (id *)v8;
    if (v8)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v8 + 1));
      if (([v9[2] apply] & 1) == 0) {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v10,  v11,  v12,  (uint64_t)v18);
      }
    }

    if ([*(id *)(a1 + 48) unregisterNetworkAgent])
    {
      *(_BYTE *)(a1 + 14) = 0;
      [(id)a1 setActive:0];
      id v14 = *(id *)(a1 + 32);
      id v20 = (id)objc_claimAutoreleasedReturnValue([(id)a1 agentDescription]);
      sub_10011BB18(v14, 20003, 0LL, v20);
    }

    else
    {
      id v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v13);
      int v16 = _NRLogIsLevelEnabled(v15, 16LL);

      if (!v16) {
        return;
      }
      id v20 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v17);
      _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d unable to unregister agent",  "",  "-[NRCompanionProxyConfigAgent unregisterAgent]",  424);
    }
  }

id *sub_10005E638(id *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v10 = a2;
  id v11 = a3;
  id v12 = a4;
  id v13 = a5;
  if (a1)
  {
    v31.receiver = a1;
    v31.super_class = (Class)&OBJC_CLASS___NRCompanionProxyAgent;
    id v14 = (id *)objc_msgSendSuper2(&v31, "init");
    if (!v14)
    {
      id v22 = sub_10005E8D4();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v22, 16LL);

      if (IsLevelEnabled)
      {
        id v24 = sub_10005E8D4();
        _NRLogWithArgs( v24,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRCompanionProxyAgent initWithQueue:interfaceName:remoteDeviceName:nrUUID:]",  59);
      }

      uint64_t v25 = _os_log_pack_size(12LL);
      id v26 = (char *)&v30 - ((v25 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      dispatch_data_t v27 = __error();
      uint64_t v28 = _os_log_pack_fill(v26, v25, *v27, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v28 = 136446210;
      *(void *)(v28 + 4) = "-[NRCompanionProxyAgent initWithQueue:interfaceName:remoteDeviceName:nrUUID:]";
      id v29 = sub_10005E8D4();
      _NRLogAbortWithPack(v29, v26);
    }

    a1 = v14;
    objc_storeStrong(v14 + 4, a5);
    [a1 setActive:0];
    [a1 setKernelActivated:1];
    [a1 setUserActivated:1];
    [a1 setVoluntary:1];
    [a1 setNetworkProvider:1];
    id v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
    [a1 setAgentUUID:v15];

    objc_storeStrong(a1 + 7, a3);
    int v16 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"CompanionProxy via %@",  v12);
    [a1 setAgentDescription:v16];

    objc_storeStrong(a1 + 5, a2);
    a1[10] = (id)1;
    uint64_t v17 = objc_alloc(&OBJC_CLASS___NSString);
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([a1 agentUUID]);
    uint64_t v19 = -[NSString initWithFormat:](v17, "initWithFormat:", @"CmpnProxy-%@", v18);
    id v20 = a1[11];
    a1[11] = v19;
  }

  return a1;
}

id sub_10005E8D4()
{
  if (qword_1001DC798 != -1) {
    dispatch_once(&qword_1001DC798, &stru_1001AE980);
  }
  return (id)qword_1001DC790;
}

void sub_10005E914(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC790;
  qword_1001DC790 = (uint64_t)v1;
}

uint64_t sub_10005E944(uint64_t result, uint64_t a2)
{
  if (!result) {
    return result;
  }
  uint64_t v2 = result;
  if (*(_BYTE *)(result + 15)) {
    return 1LL;
  }
  uint64_t v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(result + 32), a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0LL);

  if (IsLevelEnabled)
  {
    uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v2 + 32), v5);
    id v7 = (void *)objc_claimAutoreleasedReturnValue([(id)v2 agentDescription]);
    _NRLogWithArgs(v6, 0LL, "%s%.30s:%-4d registerAgent: %@", "", "-[NRCompanionProxyAgent registerAgent]", 187LL, v7);
  }

  id v8 = -[NWNetworkAgentRegistration initWithNetworkAgentClass:]( objc_alloc(&OBJC_CLASS___NWNetworkAgentRegistration),  "initWithNetworkAgentClass:",  objc_opt_class(v2));
  id v9 = *(void **)(v2 + 48);
  *(void *)(v2 + 4_Block_object_dispose((const void *)(v1 + 128), 8) = v8;

  id v11 = *(void **)(v2 + 48);
  if (v11)
  {
    if ([v11 registerNetworkAgent:v2])
    {
      uint64_t v13 = *(void *)(v2 + 56);
      id v14 = *(id *)(v2 + 48);
      LOBYTE(v13) = [v14 addNetworkAgentToInterfaceNamed:v13];

      if ((v13 & 1) == 0)
      {
        id v35 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v2 + 32), v15);
        int v36 = _NRLogIsLevelEnabled(v35, 16LL);

        if (v36)
        {
          id v37 = *(id *)(v2 + 32);
          int v39 = (void *)_NRCopyLogObjectForNRUUID(v37, v38);
          _NRLogWithArgs( v39,  16LL,  "%s%.30s:%-4d unable to add network agent to interface %@",  "",  "-[NRCompanionProxyAgent registerAgent]",  201LL,  *(void *)(v2 + 56));
        }

        goto LABEL_20;
      }

      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      int v16 = (unsigned __int8 *)(id)qword_1001DC870;
      if (v16)
      {
        int v17 = v16[8];

        if (v17)
        {
          uint64_t v19 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v2 + 32), v18);
          int v20 = _NRLogIsLevelEnabled(v19, 0LL);

          if (v20)
          {
            id v22 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v2 + 32), v21);
            _NRLogWithArgs( v22,  0LL,  "%s%.30s:%-4d Not registering fallback agents as fixed interface mode is enabled",  "",  "-[NRCompanionProxyAgent registerAgent]",  206);
          }

          *(_BYTE *)(v2 + 15) = 1;
          [(id)v2 setActive:1];
          [*(id *)(v2 + 48) updateNetworkAgent:v2];
          goto LABEL_20;
        }
      }

      *(_BYTE *)(v2 + 15) = 1;
      [(id)v2 setActive:1];
      [*(id *)(v2 + 48) updateNetworkAgent:v2];
      nw_path_t v40 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(v2 + 32));
      if (v40)
      {
        id v26 = (id *)v40;
        id v41 = *((id *)v40 + 16);
        if (v41)
        {
          id v42 = v41;
          id v43 = v26[16];
          unsigned int v44 = [v43 allowsDirectToCloud];

          if (!v44) {
            goto LABEL_70;
          }
        }

        objc_opt_self(&OBJC_CLASS___NRLinkDirector);
        if (qword_1001DC878 == -1)
        {
LABEL_34:
          id v45 = (id *)(id)qword_1001DC870;
          id v46 = *(id *)(v2 + 32);
          if (v45)
          {
            uint64_t v47 = sub_100146AFC();
            dispatch_assert_queue_V2((dispatch_queue_t)v47);

            if (v46)
            {
              id v48 = (void *)objc_claimAutoreleasedReturnValue([v45[27] objectForKeyedSubscript:v46]);

              if (v48)
              {
                uint64_t v49 = objc_claimAutoreleasedReturnValue([v45[27] objectForKeyedSubscript:v46]);
                id v50 = (id)v49;
                if (v49)
                {
                  uint64_t v51 = *(void *)(v49 + 448);
                  if (v51)
                  {
                    __int128 v52 = (void *)NEVirtualInterfaceCopyName(v51);
                    goto LABEL_47;
                  }
                }

LABEL_70:
                  id v104 = *(id *)(v2 + 32);
                  uint64_t v105 = (void *)objc_claimAutoreleasedReturnValue([(id)v2 agentUUID]);
                  id v106 = (void *)objc_claimAutoreleasedReturnValue([v105 UUIDString]);
                  sub_10011BB18(v104, 12002, 0LL, v106);

                  goto LABEL_19;
                }

    dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    goto LABEL_36;
  }

  if (qword_1001DC8A0 != -1) {
    dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC898, 0LL))
  {
    if (qword_1001DC8A0 != -1) {
      dispatch_once(&qword_1001DC8A0, &stru_1001AF158);
    }
    _NRLogWithArgs( qword_1001DC898,  0LL,  "%s%.30s:%-4d ne_session_add_necp_drop_dest_from_path: success",  "",  "-[NRLinkDirector addTerminusPrefixDropPolicy]",  1739);
  }

      uint64_t v3 = v83;
    }
  }

void sub_10005F3F0(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    ++*(void *)(a1 + 80);
    uint64_t v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0LL);

    if (IsLevelEnabled)
    {
      id v5 = *(id *)(a1 + 32);
      id v7 = (void *)_NRCopyLogObjectForNRUUID(v5, v6);
      uint64_t v8 = *(void *)(a1 + 80);
      id v9 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 agentDescription]);

      _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d refreshGeneration to %llu: %@",  "",  "-[NRCompanionProxyAgent refreshGeneration]",  272LL,  v8,  v9);
    }

    if (*(_BYTE *)(a1 + 15) && ([*(id *)(a1 + 48) updateNetworkAgent:a1] & 1) == 0)
    {
      id v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v10);
      int v12 = _NRLogIsLevelEnabled(v11, 16LL);

      if (v12)
      {
        id v14 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v13);
        _NRLogWithArgs( v14,  16LL,  "%s%.30s:%-4d unable to update agent",  "",  "-[NRCompanionProxyAgent refreshGeneration]",  277);
      }
    }
  }

id *sub_10005F548(id *a1, void *a2, void *a3, void *a4)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  if (a1)
  {
    v30.receiver = a1;
    v30.super_class = (Class)&OBJC_CLASS___NRCompanionProxyConfigAgent;
    id v11 = (id *)objc_msgSendSuper2(&v30, "init");
    if (!v11)
    {
      id v21 = sub_10005E8D4();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v21, 16LL);

      if (IsLevelEnabled)
      {
        id v23 = sub_10005E8D4();
        _NRLogWithArgs( v23,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRCompanionProxyConfigAgent initWithQueue:parameters:nrUUID:]",  314);
      }

      uint64_t v24 = _os_log_pack_size(12LL);
      uint64_t v25 = (char *)&v29 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v26 = __error();
      uint64_t v27 = _os_log_pack_fill(v25, v24, *v26, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v27 = 136446210;
      *(void *)(v27 + 4) = "-[NRCompanionProxyConfigAgent initWithQueue:parameters:nrUUID:]";
      id v28 = sub_10005E8D4();
      _NRLogAbortWithPack(v28, v25);
    }

    a1 = v11;
    objc_storeStrong(v11 + 4, a4);
    objc_storeStrong(a1 + 7, a3);
    [a1 setKernelActivated:1];
    [a1 setUserActivated:1];
    [a1 setVoluntary:1];
    int v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
    [a1 setAgentUUID:v12];

    uint64_t v13 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"CompanionProxyConfig for %@",  v10);
    [a1 setAgentDescription:v13];

    id v14 = objc_alloc(&OBJC_CLASS___NSString);
    id v15 = a1[4];
    int v16 = -[NSString initWithFormat:](v14, "initWithFormat:", @"NRCompanionProxyConfigAgent-%@", v15);
    id v17 = a1[8];
    a1[8] = v16;

    objc_storeStrong(a1 + 5, a2);
    id v18 = a1[4];
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([a1 agentDescription]);
    sub_10011BB18(v18, 20001, 0LL, v19);
  }

  return a1;
}

uint64_t sub_10005F7E0(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v7 = result;
    int v8 = *(unsigned __int8 *)(result + 14);
    if (*(_BYTE *)(result + 14)) {
      return v8 != 0;
    }
    id v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(result + 32), a2);
    int IsLevelEnabled = (void *)_NRLogIsLevelEnabled(v9, 0LL);

    if ((_DWORD)IsLevelEnabled)
    {
      int v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v7 + 32), v11);
      int IsLevelEnabled = (void *)objc_claimAutoreleasedReturnValue([(id)v7 agentDescription]);
      _NRLogWithArgs( v12,  0LL,  "%s%.30s:%-4d registerAgent: %@",  "",  "-[NRCompanionProxyConfigAgent registerAgent]",  372LL,  IsLevelEnabled);
    }

    uint64_t v13 = -[NWNetworkAgentRegistration initWithNetworkAgentClass:]( objc_alloc(&OBJC_CLASS___NWNetworkAgentRegistration),  "initWithNetworkAgentClass:",  objc_opt_class(v7));
    id v14 = *(void **)(v7 + 48);
    *(void *)(v7 + 4_Block_object_dispose((const void *)(v1 + 128), 8) = v13;

    int v16 = *(void **)(v7 + 48);
    if (!v16)
    {
      int v36 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v7 + 32), v15);
      int v37 = _NRLogIsLevelEnabled(v36, 16LL);

      if (!v37) {
        goto LABEL_20;
      }
      uint64_t v19 = (char *)_NRCopyLogObjectForNRUUID(*(void *)(v7 + 32), v38);
      _NRLogWithArgs(v19, 16LL, "%s%.30s:%-4d unable to allocate registration object");
      goto LABEL_19;
    }

    if (([v16 registerNetworkAgent:v7] & 1) == 0)
    {
      int v39 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v7 + 32), v17);
      int v40 = _NRLogIsLevelEnabled(v39, 16LL);

      if (!v40) {
        goto LABEL_20;
      }
      uint64_t v19 = (char *)_NRCopyLogObjectForNRUUID(*(void *)(v7 + 32), v41);
      _NRLogWithArgs(v19, 16LL, "%s%.30s:%-4d unable register network agent");
LABEL_19:

LABEL_20:
      int v8 = *(unsigned __int8 *)(v7 + 14);
      if (!*(_BYTE *)(v7 + 14))
      {
        id v42 = *(void **)(v7 + 48);
        if (v42)
        {
          [v42 unregisterNetworkAgent];
          id v43 = *(void **)(v7 + 48);
          *(void *)(v7 + 4_Block_object_dispose((const void *)(v1 + 128), 8) = 0LL;

          int v8 = *(unsigned __int8 *)(v7 + 14);
        }

        else
        {
          int v8 = 0;
        }
      }

      return v8 != 0;
    }

    *(_BYTE *)(v7 + 14) = 1;
    [(id)v7 setActive:1];
    [*(id *)(v7 + 48) updateNetworkAgent:v7];
    id v18 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(v7 + 32));
    if (v18)
    {
      uint64_t v19 = v18;
      int v20 = (void *)objc_claimAutoreleasedReturnValue([(id)v7 agentUUID]);
      int IsLevelEnabled = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult netAgentUUID:](&OBJC_CLASS___NEPolicyResult, "netAgentUUID:", v20));

      id v21 = sub_100146AFC();
      dispatch_assert_queue_V2((dispatch_queue_t)v21);

      id v22 = sub_10012D254(v19, @"0");
      uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition flowRemoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "flowRemoteAddress:prefix:",  v22,  128LL));

      id v23 = sub_10012CD2C(v19, @"62742");
      uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition flowLocalAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "flowLocalAddress:prefix:",  v23,  128LL));

      id v24 = objc_alloc(&OBJC_CLASS___NEPolicy);
      v50[0] = (uint64_t)v2;
      v50[1] = (uint64_t)v3;
      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      v50[2] = (uint64_t)v25;
      id v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v50, 3LL));
      id v4 = [v24 initWithOrder:10 result:IsLevelEnabled conditions:v26];

      id v5 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
      if (qword_1001DCB60 == -1)
      {
LABEL_9:
        id v27 = (id)qword_1001DCB58;
        id v28 = sub_100120E44((uint64_t)v27, *(void **)(v7 + 64), v4);

        objc_opt_self(&v5[63]);
        if (p_class_meths[364] != (__objc2_meth_list *)-1LL) {
          dispatch_once(&qword_1001DCB60, &stru_1001B0538);
        }
        id v29 = (id)qword_1001DCB58;
        objc_super v30 = (id *)v29;
        if (v29)
        {
          dispatch_assert_queue_V2(*((dispatch_queue_t *)v29 + 1));
          if (([v30[2] apply] & 1) == 0) {
            sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v31,  v32,  v33,  v50[0]);
          }
        }

        id v34 = *(id *)(v7 + 32);
        id v35 = (void *)objc_claimAutoreleasedReturnValue([(id)v7 agentDescription]);
        sub_10011BB18(v34, 20002, 0LL, v35);

        goto LABEL_19;
      }
    }

    else
    {
      id v44 = sub_10005E8D4();
      int v45 = _NRLogIsLevelEnabled(v44, 16LL);

      if (v45)
      {
        id v46 = sub_10005E8D4();
        _NRLogWithArgs( v46,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRCompanionProxyConfigAgent registerAgent]",  390);
      }

      uint64_t v7 = _os_log_pack_size(12LL);
      uint64_t v19 = (char *)v50 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v47 = __error();
      uint64_t v48 = _os_log_pack_fill( v19,  v7,  *v47,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)uint64_t v48 = 136446210;
      *(void *)(v48 + 4) = "-[NRCompanionProxyConfigAgent registerAgent]";
      id v49 = sub_10005E8D4();
      _NRLogAbortWithPack(v49, v19);
    }

    dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    goto LABEL_9;
  }

  return result;
}

void sub_1000602C8(_Unwind_Exception *a1)
{
}

void sub_100060460(id a1)
{
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  id v1 = (id)qword_1001DCC10;
  if (!v1) {
    goto LABEL_9;
  }
  uint64_t v2 = v1;
  dispatch_assert_queue_V2(*((dispatch_queue_t *)v1 + 2));
  if (!v2[10])
  {
    v2[10] = 1;
    if (v2[8] == 4)
    {
      sub_100143DD4((uint64_t)v2);
      if (v2[9])
      {
        v2[8] = 3;
        sub_100144044((uint64_t)v2);
      }
    }
  }

  int v3 = v2[8] & 0xFD;

  if (v3 != 1)
  {
LABEL_9:
    if (qword_1001DC7A8 != -1) {
      dispatch_once(&qword_1001DC7A8, &stru_1001AE9E0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC7A0, 17LL))
    {
      if (qword_1001DC7A8 != -1) {
        dispatch_once(&qword_1001DC7A8, &stru_1001AE9E0);
      }
      _NRLogWithArgs(qword_1001DC7A0, 17LL, "Wi-Fi agent unassert before class C unlock");
    }
  }

void sub_100060598(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC7A0;
  qword_1001DC7A0 = (uint64_t)v1;
}

void sub_1000605C8(id a1)
{
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  id v1 = (id)qword_1001DCC10;
  if (!v1) {
    goto LABEL_9;
  }
  uint64_t v2 = v1;
  dispatch_assert_queue_V2(*((dispatch_queue_t *)v1 + 2));
  if (!v2[10])
  {
    v2[10] = 1;
    if (v2[8] == 4)
    {
      sub_100143DD4((uint64_t)v2);
      if (v2[9])
      {
        v2[8] = 3;
        sub_100144044((uint64_t)v2);
      }
    }
  }

  int v3 = v2[8] & 0xFD;

  if (v3 != 1)
  {
LABEL_9:
    if (qword_1001DC7A8 != -1) {
      dispatch_once(&qword_1001DC7A8, &stru_1001AE9E0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC7A0, 17LL))
    {
      if (qword_1001DC7A8 != -1) {
        dispatch_once(&qword_1001DC7A8, &stru_1001AE9E0);
      }
      _NRLogWithArgs(qword_1001DC7A0, 17LL, "Wi-Fi agent assert before class C unlock");
    }
  }

id sub_100060700()
{
  if (qword_1001DC7A8 != -1) {
    dispatch_once(&qword_1001DC7A8, &stru_1001AE9E0);
  }
  return (id)qword_1001DC7A0;
}

void sub_1000607C0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v2 = WeakRetained;
  if (WeakRetained)
  {
    if (WeakRetained[15])
    {
      if (qword_1001DC7A8 != -1) {
        dispatch_once(&qword_1001DC7A8, &stru_1001AE9E0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC7A0, 1LL))
      {
        if (qword_1001DC7A8 != -1) {
          dispatch_once(&qword_1001DC7A8, &stru_1001AE9E0);
        }
        uint64_t v3 = qword_1001DC7A0;
        uint64_t v30 = 112LL;
        id v28 = "";
        id v29 = "-[NRPreferWiFiAgent registerAgentOnQueue:]_block_invoke";
        id v4 = "%s%.30s:%-4d Ignoring prefer Wi-Fi agent registration as it is invalidated";
LABEL_15:
        uint64_t v5 = 1LL;
LABEL_16:
        _NRLogWithArgs(v3, v5, v4, v28, v29, v30);
        goto LABEL_17;
      }

      goto LABEL_17;
    }

    uint64_t v6 = -[NWNetworkAgentRegistration initWithNetworkAgentClass:]( objc_alloc(&OBJC_CLASS___NWNetworkAgentRegistration),  "initWithNetworkAgentClass:",  objc_opt_class(WeakRetained));
    uint64_t v7 = (void *)*((void *)v2 + 6);
    *((void *)v2 + 6) = v6;

    int v8 = (void *)*((void *)v2 + 6);
    if (!v8)
    {
      if (qword_1001DC7A8 != -1) {
        dispatch_once(&qword_1001DC7A8, &stru_1001AE9E0);
      }
      if (qword_1001DC7A8 != -1) {
        dispatch_once(&qword_1001DC7A8, &stru_1001AE9E0);
      }
      uint64_t v3 = qword_1001DC7A0;
      id v4 = "[[NWNetworkAgentRegistration alloc] initWithNetworkAgentClass:] failed";
LABEL_42:
      uint64_t v5 = 17LL;
      goto LABEL_16;
    }

    if ([v8 registerNetworkAgent:v2])
    {
      id v9 = (void *)objc_claimAutoreleasedReturnValue(+[NRPreferWiFiAgent agentDomain](&OBJC_CLASS___NRPreferWiFiAgent, "agentDomain"));
      id v10 = (void *)objc_claimAutoreleasedReturnValue(+[NRPreferWiFiAgent agentType](&OBJC_CLASS___NRPreferWiFiAgent, "agentType"));
      uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition requiredAgentDomain:agentType:]( &OBJC_CLASS___NEPolicyCondition,  "requiredAgentDomain:agentType:",  v9,  v10));

      int v12 = (void *)objc_claimAutoreleasedReturnValue([v2 agentUUID]);
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult netAgentUUID:](&OBJC_CLASS___NEPolicyResult, "netAgentUUID:", v12));

      id v14 = objc_alloc(&OBJC_CLASS___NEPolicy);
      v34[0] = v11;
      uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      v34[1] = v15;
      int v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v34, 2LL));
      id v17 = [v14 initWithOrder:10 result:v13 conditions:v16];

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v18 = (id)qword_1001DCB58;
      id v19 = sub_100120E44((uint64_t)v18, *((void **)v2 + 7), v17);

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      id v20 = (id)qword_1001DCB58;
      id v21 = (id *)v20;
      if (v20)
      {
        dispatch_assert_queue_V2(*((dispatch_queue_t *)v20 + 1));
        if (([v21[2] apply] & 1) == 0) {
          sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v22,  v23,  v24,  (uint64_t)v28);
        }
      }

      *((_BYTE *)v2 + 14) = 1;
      uint64_t v25 = (void *)objc_claimAutoreleasedReturnValue([v2 agentUUID]);
      id v26 = (void *)objc_claimAutoreleasedReturnValue([v25 UUIDString]);
      sub_10011BB18(0LL, 15002, 0LL, v26);

      objc_initWeak(&location, v2);
      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      id v27 = (id)qword_1001DC870;
      v31[0] = _NSConcreteStackBlock;
      v31[1] = 3221225472LL;
      v31[2] = sub_100060D68;
      v31[3] = &unk_1001AFED0;
      objc_copyWeak(&v32, &location);
      sub_1000AEA84((uint64_t)v27, v31);

      objc_destroyWeak(&v32);
      objc_destroyWeak(&location);

      goto LABEL_17;
    }

    if (qword_1001DC7A8 != -1) {
      dispatch_once(&qword_1001DC7A8, &stru_1001AE9E0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC7A0, 17LL))
    {
      if (qword_1001DC7A8 != -1) {
        dispatch_once(&qword_1001DC7A8, &stru_1001AE9E0);
      }
      uint64_t v3 = qword_1001DC7A0;
      id v4 = "-registerNetworkAgent: failed";
      goto LABEL_42;
    }
  }

  else
  {
    if (qword_1001DC7A8 != -1) {
      dispatch_once(&qword_1001DC7A8, &stru_1001AE9E0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC7A0, 1LL))
    {
      if (qword_1001DC7A8 != -1) {
        dispatch_once(&qword_1001DC7A8, &stru_1001AE9E0);
      }
      uint64_t v3 = qword_1001DC7A0;
      uint64_t v30 = 107LL;
      id v28 = "";
      id v29 = "-[NRPreferWiFiAgent registerAgentOnQueue:]_block_invoke";
      id v4 = "%s%.30s:%-4d Ignoring prefer Wi-Fi agent registration as it is dealloc'd";
      goto LABEL_15;
    }
  }

void sub_100060D3C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
}

void sub_100060D68(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  id v4 = WeakRetained;
  if (WeakRetained)
  {
    if (*((_BYTE *)WeakRetained + 15))
    {
      if (qword_1001DC7A8 != -1) {
        dispatch_once(&qword_1001DC7A8, &stru_1001AE9E0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC7A0, 1LL))
      {
        if (qword_1001DC7A8 != -1) {
          dispatch_once(&qword_1001DC7A8, &stru_1001AE9E0);
        }
        _NRLogWithArgs(qword_1001DC7A0, 1LL, "%s%.30s:%-4d Ignoring prefer Wi-Fi agent activation as it is invalidated");
      }
    }

    else if (([WeakRetained isActive] & 1) == 0)
    {
      [v4 setActive:1];
      objc_msgSend(v4[6], "updateNetworkAgent:");
      id v2 = (void *)objc_claimAutoreleasedReturnValue([v4 agentUUID]);
      uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([v2 UUIDString]);
      sub_10011BB18(0LL, 15004, 0LL, v3);
    }
  }

  else
  {
    if (qword_1001DC7A8 != -1) {
      dispatch_once(&qword_1001DC7A8, &stru_1001AE9E0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC7A0, 1LL))
    {
      if (qword_1001DC7A8 != -1) {
        dispatch_once(&qword_1001DC7A8, &stru_1001AE9E0);
      }
      _NRLogWithArgs(qword_1001DC7A0, 1LL, "%s%.30s:%-4d Ignoring prefer Wi-Fi agent activation as it is dealloc'd");
    }
  }
}

void sub_100060F1C(uint64_t a1)
{
  *(_BYTE *)(a1 + 15) = 1;
  if (*(_BYTE *)(a1 + 14))
  {
    *(_BYTE *)(a1 + 14) = 0;
    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v2 = (id)qword_1001DCB58;
    sub_10012114C((uint64_t)v2, *(void **)(a1 + 56));

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v3 = (id)qword_1001DCB58;
    id v4 = (id *)v3;
    if (v3)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v3 + 1));
      if (([v4[2] apply] & 1) == 0) {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v5,  v6,  v7,  v10);
      }
    }

    int v8 = *(void **)(a1 + 48);
    if (v8)
    {
      if ([v8 unregisterNetworkAgent])
      {
        [(id)a1 setActive:0];
        id v11 = (id)objc_claimAutoreleasedReturnValue([(id)a1 agentUUID]);
        id v9 = (void *)objc_claimAutoreleasedReturnValue([v11 UUIDString]);
        sub_10011BB18(0LL, 15003, 0LL, v9);
      }
    }
  }

uint64_t sub_100061098(uint64_t a1, BOOL *a2)
{
  if (a1)
  {
    __int128 v16 = 0u;
    __int128 v17 = 0u;
    __int128 v14 = 0u;
    __int128 v15 = 0u;
    id v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 64), "allValues", 0));
    id v4 = [v3 countByEnumeratingWithState:&v14 objects:v18 count:16];
    if (v4)
    {
      id v5 = v4;
      BOOL v6 = 0;
      char v7 = 0;
      uint64_t v8 = *(void *)v15;
      do
      {
        for (uint64_t i = 0LL; i != v5; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v15 != v8) {
            objc_enumerationMutation(v3);
          }
          uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(*((void *)&v14 + 1) + 8 * (void)i) parameters]);
          id v11 = [v10 copyCParameters];

          char use_p2p = nw_parameters_get_use_p2p(v11);
          BOOL v6 = v6 || nw_parameters_get_traffic_class(v11) > 0x12B;
          v7 |= use_p2p;
        }

        id v5 = [v3 countByEnumeratingWithState:&v14 objects:v18 count:16];
      }

      while (v5);
    }

    else
    {
      BOOL v6 = 0;
      char v7 = 0;
    }

    if (a2) {
      *a2 = v6;
    }
  }

  else
  {
    char v7 = 0;
  }

  return v7 & 1;
}

void sub_10006194C(_Unwind_Exception *a1)
{
}

void sub_100062428( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

id sub_1000627F8()
{
  if (qword_1001DC7B8 != -1) {
    dispatch_once(&qword_1001DC7B8, &stru_1001AEA00);
  }
  return (id)qword_1001DC7B0;
}

void sub_100062838(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v13 = WeakRetained;
    uint64_t v5 = _NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    BOOL v6 = (void *)v5;
    if (a2)
    {
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

      id WeakRetained = v13;
      if (IsLevelEnabled)
      {
        id v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v8);
        id v10 = [v13 copyDescription];
        _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: Received response to control notify",  "",  "-[NRLinkFixedInterface sendControlData:]_block_invoke",  625LL,  v10);
LABEL_7:

        id WeakRetained = v13;
      }
    }

    else
    {
      int v11 = _NRLogIsLevelEnabled(v5, 16LL);

      id WeakRetained = v13;
      if (v11)
      {
        id v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v12);
        id v10 = [v13 copyDescription];
        _NRLogWithArgs( v9,  16LL,  "%s%.30s:%-4d %@: Did not receive response to control notify",  "",  "-[NRLinkFixedInterface sendControlData:]_block_invoke",  627LL,  v10);
        goto LABEL_7;
      }
    }
  }
}

void sub_100062948(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC7B0;
  qword_1001DC7B0 = (uint64_t)v1;
}

void sub_100062978(void *a1)
{
  if (a1)
  {
    id String = (void *)NRDataProtectionClassCreateString(4LL);
    id v3 = *(void **)((char *)a1 + 231);
    if (v3)
    {
      id v4 = v3;
      [v4 setClientQueue:a1[1]];
      objc_initWeak(location, a1);
      v53[0] = _NSConcreteStackBlock;
      v53[1] = 3221225472LL;
      id v53[2] = sub_100062E50;
      v53[3] = &unk_1001AF2D8;
      objc_copyWeak(&v56, location);
      char v57 = 4;
      id v5 = String;
      id v54 = v5;
      id v6 = v4;
      id v55 = v6;
      [v6 setStateUpdateBlock:v53];
      v48[0] = _NSConcreteStackBlock;
      v48[1] = 3221225472LL;
      v48[2] = sub_10006360C;
      v48[3] = &unk_1001AF300;
      objc_copyWeak(&v51, location);
      id v7 = v5;
      id v49 = v7;
      id v8 = v6;
      id v50 = v8;
      char v52 = 4;
      [v8 setChildStateUpdateBlock:v48];
      v44[0] = _NSConcreteStackBlock;
      v44[1] = 3221225472LL;
      v44[2] = sub_100063730;
      v44[3] = &unk_1001AF328;
      objc_copyWeak(&v47, location);
      id v9 = v7;
      id v45 = v9;
      id v10 = v8;
      id v46 = v10;
      [v10 setConfigurationUpdateBlock:v44];
      v40[0] = _NSConcreteStackBlock;
      v40[1] = 3221225472LL;
      v40[2] = sub_1000637FC;
      v40[3] = &unk_1001AF350;
      objc_copyWeak(&v43, location);
      id v11 = v9;
      id v41 = v11;
      id v12 = v10;
      id v42 = v12;
      [v12 setTrafficSelectorUpdateBlock:v40];
      v36[0] = _NSConcreteStackBlock;
      v36[1] = 3221225472LL;
      v36[2] = sub_1000638E8;
      v36[3] = &unk_1001AF378;
      objc_copyWeak(&v39, location);
      id v13 = v11;
      id v37 = v13;
      id v14 = v12;
      id v38 = v14;
      [v14 setAdditionalAddressesUpdateBlock:v36];
      v32[0] = _NSConcreteStackBlock;
      v32[1] = 3221225472LL;
      v32[2] = sub_1000639B4;
      v32[3] = &unk_1001AF3A0;
      objc_copyWeak(&v35, location);
      id v15 = v13;
      id v33 = v15;
      id v16 = v14;
      id v34 = v16;
      [v16 setShortDPDEventBlock:v32];
      v28[0] = _NSConcreteStackBlock;
      v28[1] = 3221225472LL;
      v28[2] = sub_100063A74;
      v28[3] = &unk_1001AF378;
      objc_copyWeak(&v31, location);
      id v17 = v15;
      id v29 = v17;
      id v18 = v16;
      id v30 = v18;
      [v18 setPrivateNotifyStatusEvent:v28];
      id v20 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v19);
      char IsLevelEnabled = _NRLogIsLevelEnabled(v20, 0LL);

      if ((IsLevelEnabled & 1) != 0)
      {
        uint64_t v23 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v22);
        id v24 = [a1 copyDescription];
        _NRLogWithArgs( v23,  0LL,  "%s%.30s:%-4d %@: Setup IKE %@ %@ callbacks",  "",  "-[NRLinkFixedInterface setupIKECallbacks:]",  457LL,  v24,  v17,  v18);
      }

      objc_destroyWeak(&v31);
      objc_destroyWeak(&v35);

      objc_destroyWeak(&v39);
      objc_destroyWeak(&v43);

      objc_destroyWeak(&v47);
      objc_destroyWeak(&v51);

      objc_destroyWeak(&v56);
      objc_destroyWeak(location);
    }

    else
    {
      id v25 = sub_1000627F8();
      int v26 = _NRLogIsLevelEnabled(v25, 17LL);

      if (v26)
      {
        id v27 = sub_1000627F8();
        _NRLogWithArgs(v27, 17LL, "%s called with null _ikeSessionClassD", "-[NRLinkFixedInterface setupIKECallbacks:]");
      }

      id v18 = 0LL;
    }
  }

void sub_100062DD0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id *location, id *a17)
{
}

void sub_100062E50(uint64_t a1, uint64_t a2, void *a3)
{
  id v82 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v6 = WeakRetained;
  if (WeakRetained)
  {
    id v7 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained linkDelegate]);
    id v8 = v82;
    if (!v82)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = *(void *)(a1 + 40);
      SessionStateid String = (void *)NEIKEv2CreateSessionStateString(a2);
      [v6 reportEvent:3009, @"%@ session %@ changed state to %@", v16, v17, SessionStateString detailsFormat];

      switch(a2)
      {
        case 1LL:
          if ([v6 state] == 1)
          {
            id v21 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v20);
            int IsLevelEnabled = _NRLogIsLevelEnabled(v21, 0LL);

            if (IsLevelEnabled)
            {
              id v24 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v23);
              id v25 = [v6 copyDescription];
              _NRLogWithArgs( v24,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ now connecting",  "",  "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke",  313LL,  v25,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
            }

            [v6 changeStateTo:5];
          }

          else
          {
            unsigned int v41 = [v6 state];
            uint64_t v43 = _NRCopyLogObjectForNRUUID(v6[4], v42);
            id v44 = (void *)v43;
            if (v41 == 5)
            {
              int v45 = _NRLogIsLevelEnabled(v43, 0LL);

              if (!v45) {
                goto LABEL_31;
              }
              id v47 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v46);
              id v48 = [v6 copyDescription];
              _NRLogWithArgs( v47,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ already connecting",  "",  "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke",  316LL,  v48,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
            }

            else
            {
              int v74 = _NRLogIsLevelEnabled(v43, 16LL);

              if (!v74) {
                goto LABEL_31;
              }
              id v47 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v75);
              id v48 = [v6 copyDescription];
              _NRLogWithArgs( v47,  16LL,  "%s%.30s:%-4d %@: %@ IKE %@ connecting but weird state",  "",  "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke",  318LL,  v48,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
            }
          }

          goto LABEL_31;
        case 2LL:
          id v29 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v19);
          int v30 = _NRLogIsLevelEnabled(v29, 0LL);

          if (v30)
          {
            id v32 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v31);
            id v33 = [v6 copyDescription];
            _NRLogWithArgs( v32,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ now connected from started",  "",  "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke",  321LL,  v33,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
          }

          if ([v6 state] == 8)
          {
            id v35 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v34);
            int v36 = _NRLogIsLevelEnabled(v35, 0LL);

            if (v36)
            {
              id v38 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v37);
              id v39 = [v6 copyDescription];
              _NRLogWithArgs( v38,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ already ready",  "",  "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke",  323LL,  v39,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
            }

            if (*(_BYTE *)(a1 + 56) == 4)
            {
              [v6 setIkeClassDEstablished:1];
              [v6 setIkeClassCEstablished:1];
            }

            [v7 linkIsReady:v6];
          }

          else
          {
            if ([v6 state] != 5)
            {
              id v50 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v49);
              int v51 = _NRLogIsLevelEnabled(v50, 0LL);

              if (v51)
              {
                id v53 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v52);
                id v54 = [v6 copyDescription];
                _NRLogWithArgs( v53,  0LL,  "%s%.30s:%-4d %@: %@ IKE %@ ready but weird state",  "",  "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke",  331LL,  v54,  *(void *)(a1 + 32),  *(void *)(a1 + 40));
              }
            }

            [v6 changeStateTo:8];
            if (*(_BYTE *)(a1 + 56) == 4)
            {
              [v6 setIkeClassDEstablished:1];
              [v6 setIkeClassCEstablished:1];
            }

            [v7 linkIsReady:v6];
            if ([v6 shouldCreateCompanionProxyAgent])
            {
              id v55 = (void *)objc_claimAutoreleasedReturnValue([v6 companionProxyAgent]);

              if (!v55)
              {
                id v56 = sub_1000627F8();
                int v57 = _NRLogIsLevelEnabled(v56, 0LL);

                if (v57)
                {
                  id v58 = sub_1000627F8();
                  _NRLogWithArgs( v58,  0LL,  "%s%.30s:%-4d Adding companion proxy agent",  "",  "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke",  341);
                }

                id v59 = (void *)NEVirtualInterfaceCopyName([v6 virtualInterface]);
                int v60 = (void *)objc_claimAutoreleasedReturnValue([v6 nrUUID]);
                uint64_t v61 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v60);
                id v62 = v61;
                if (v61) {
                  id v63 = (void *)*((void *)v61 + 14);
                }
                else {
                  id v63 = 0LL;
                }
                id v64 = v63;

                if (v59 && v64)
                {
                  uint64_t v65 = objc_alloc(&OBJC_CLASS___NRCompanionProxyAgent);
                  int v66 = (void *)objc_claimAutoreleasedReturnValue([v6 queue]);
                  int v67 = (void *)objc_claimAutoreleasedReturnValue([v6 nrUUID]);
                  uint64_t v68 = sub_10005E638((id *)&v65->super.isa, v66, v59, v64, v67);
                  uint64_t v69 = (void *)v6[11];
                  v6[11] = v68;

                  [v6 reportEvent:12001];
                }
              }

              uint64_t v70 = (void *)objc_claimAutoreleasedReturnValue([v6 companionProxyAgent]);
              char v72 = sub_10005E944((uint64_t)v70, v71);

              if ((v72 & 1) != 0)
              {
                [v6 reportEvent:12002];
                goto LABEL_31;
              }

              id v76 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v73);
              int v77 = _NRLogIsLevelEnabled(v76, 16LL);

              if (v77)
              {
                id v15 = (void *)_NRCopyLogObjectForNRUUID(v6[4], v78);
                id v79 = [v6 copyDescription];
                _NRLogWithArgs( v15,  16LL,  "%s%.30s:%-4d %@: failed to register companion agent",  "",  "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke",  353LL,  v79);

                goto LABEL_30;
              }
            }
          }

          break;
        case 3LL:
          if (*(_BYTE *)(a1 + 56) == 4)
          {
            [v6 setIkeClassDEstablished:0];
            [v6 setIkeClassCEstablished:0];
          }

          [v6 reportEvent:3018, @"%@ session %@ cancelled by peer", *(void *)(a1 + 32), *(void *)(a1 + 40) detailsFormat];
          goto LABEL_27;
        case 4LL:
          [v6 cancelWithReason:@"%@ session %@ got unexpected MOBIKE state", *(void *)(a1 + 32), *(void *)(a1 + 40)];
          goto LABEL_31;
        default:
          uint64_t v40 = *(void *)(a1 + 32);
          id v15 = (void *)NEIKEv2CreateSessionStateString(a2);
          [v6 cancelWithReason:@"%@ session %@ got bad IKE state %@", v40, v15, v80, v81];
          goto LABEL_30;
      }

      goto LABEL_31;
    }

    uint64_t v9 = *(unsigned __int8 *)(a1 + 56);
    if ((_DWORD)v9 == 4)
    {
      [v6 setIkeClassDEstablished:0];
      [v6 setIkeClassCEstablished:0];
      id v8 = v82;
      uint64_t v9 = *(unsigned __int8 *)(a1 + 56);
    }

    [v6 processIKEDisconnection:v9 error:v8];
    if ([v6 state] != 255)
    {
      id v10 = v82;
      if ([v10 code] == (id)4)
      {
        uint64_t v11 = NEIKEv2ErrorDomain;
        id v12 = (void *)objc_claimAutoreleasedReturnValue([v10 domain]);
        LODWORD(v11) = [v12 isEqualToString:v11];

        if ((_DWORD)v11)
        {
          uint64_t v13 = *(void *)(a1 + 32);
          uint64_t v14 = *(void *)(a1 + 40);
          id v15 = (void *)NEIKEv2CreateSessionStateString(a2);
          [v6 cancelWithReason:@"%@ session %@ got IKE error %@ with state %@", v13, v14, v10, v15];
LABEL_30:

          goto LABEL_31;
        }
      }

      else
      {
      }

      uint64_t v26 = *(void *)(a1 + 32);
      uint64_t v27 = *(void *)(a1 + 40);
      id v28 = (void *)NEIKEv2CreateSessionStateString(a2);
      [v6 reportEvent:3018, @"%@ session %@ got IKE error %@ with state %@", v26, v27, v10, v28 detailsFormat];

LABEL_27:
      sub_100063D2C((uint64_t)v6, *(unsigned __int8 *)(a1 + 56));
    }

void sub_10006360C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v14 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    if (v14)
    {
      uint64_t v8 = *(void *)(a1 + 32);
      uint64_t v9 = *(void *)(a1 + 40);
      SessionStateid String = (void *)NEIKEv2CreateSessionStateString(a3);
      [WeakRetained reportEvent:3018, @"%@ session %@ got child %u state update %@ error %@", v8, v9, a2, SessionStateString, v14 detailsFormat];

      [WeakRetained processIKEDisconnection:*(unsigned __int8 *)(a1 + 56) error:v14];
    }

    else
    {
      uint64_t v11 = *(void *)(a1 + 32);
      uint64_t v12 = *(void *)(a1 + 40);
      if (a3 != 3)
      {
        uint64_t v13 = (void *)NEIKEv2CreateSessionStateString(a3);
        [WeakRetained reportEvent:3009, @"%@ session %@ child %u state update %@", v11, v12, a2, v13 detailsFormat];

        goto LABEL_9;
      }

      [WeakRetained reportEvent:3018, @"%@ session %@ got child %u Disconnected state with no error", v11, *(void *)(a1 + 40), a2 detailsFormat];
    }

    sub_100063D2C((uint64_t)WeakRetained, *(unsigned __int8 *)(a1 + 56));
  }

void sub_100063730(uint64_t a1, void *a2)
{
  id v11 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v5 = WeakRetained;
  if (WeakRetained)
  {
    id v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      id v10 = [v5 copyDescription];
      _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got config update %@",  "",  "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke_3",  413LL,  v10,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  v11);
    }
  }
}

void sub_1000637FC(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v16 = a3;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v10 = WeakRetained;
  if (WeakRetained)
  {
    id v11 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v9);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0LL);

    if (IsLevelEnabled)
    {
      id v14 = (void *)_NRCopyLogObjectForNRUUID(v10[4], v13);
      id v15 = [v10 copyDescription];
      _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got child %u traffic selector update local %@ remote %@",  "",  "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke_4",  424LL,  v15,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  a2,  v16,  v7);
    }
  }
}

void sub_1000638E8(uint64_t a1, void *a2)
{
  id v11 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v5 = WeakRetained;
  if (WeakRetained)
  {
    id v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      id v10 = [v5 copyDescription];
      _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got additional addresses %@",  "",  "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke_5",  433LL,  v10,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  v11);
    }
  }
}

void sub_1000639B4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    uint64_t v9 = WeakRetained;
    uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v3);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

    id WeakRetained = v9;
    if (IsLevelEnabled)
    {
      id v7 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v6);
      id v8 = [v9 copyDescription];
      _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got short DPD",  "",  "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke_6",  441LL,  v8,  *(void *)(a1 + 32),  *(void *)(a1 + 40));

      id WeakRetained = v9;
    }
  }
}

void sub_100063A74(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = (void **)objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    id v27 = v3;
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v3 sortedArrayUsingComparator:&stru_1001AFCC8]);
    id v7 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v6);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0LL);

    if (IsLevelEnabled)
    {
      id v10 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v9);
      id v11 = [WeakRetained copyDescription];
      _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got private notifies %@",  "",  "-[NRLinkFixedInterface setupIKECallbacks:]_block_invoke_7",  451LL,  v11,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  v5);
    }

    __int128 v30 = 0u;
    __int128 v31 = 0u;
    __int128 v28 = 0u;
    __int128 v29 = 0u;
    id v12 = v5;
    id v13 = [v12 countByEnumeratingWithState:&v28 objects:v32 count:16];
    if (v13)
    {
      id v14 = v13;
      uint64_t v15 = *(void *)v29;
      do
      {
        for (uint64_t i = 0LL; i != v14; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v29 != v15) {
            objc_enumerationMutation(v12);
          }
          uint64_t v17 = *(void **)(*((void *)&v28 + 1) + 8LL * (void)i);
          unsigned int v18 = [v17 notifyStatus];
          id v19 = (id)objc_claimAutoreleasedReturnValue([v17 notifyData]);
          id v21 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v20);
          int v22 = _NRLogIsLevelEnabled(v21, 1LL);

          if (v22)
          {
            id v24 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v23);
            id v25 = [WeakRetained copyDescription];
            _NRLogWithArgs( v24,  1LL,  "%s%.30s:%-4d %@: Received notify code %u %@",  "",  "-[NRLinkFixedInterface handleNotifyCode:payload:]",  635LL,  v25,  v18,  v19);
          }

          if (v18 == 50701)
          {
            sub_100136084((uint64_t)&OBJC_CLASS___NRDLocalDevice, v19, WeakRetained[4]);
            [WeakRetained checkProxyAgentWithForceUpdate:0];
          }

          else if (v18 == 50702)
          {
            uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained linkDelegate]);
            [v26 linkDidReceiveData:WeakRetained data:v19];
          }
        }

        id v14 = [v12 countByEnumeratingWithState:&v28 objects:v32 count:16];
      }

      while (v14);
    }

    id v3 = v27;
  }
}

void sub_100063D2C(uint64_t a1, uint64_t a2)
{
  id String = (id)NRDataProtectionClassCreateString(a2);
  if (*(unsigned __int8 *)(a1 + 16) == 255)
  {
    id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 0LL);

    if (!IsLevelEnabled) {
      goto LABEL_11;
    }
    uint64_t v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v14);
    id v16 = [(id)a1 copyDescription];
    _NRLogWithArgs( v15,  0LL,  "%s%.30s:%-4d %@: Not restarting %@ session because cancelled",  "",  "-[NRLinkFixedInterface restartIKESessionForDataProtectionClass:]",  249LL,  v16,  String);
LABEL_10:

    goto LABEL_11;
  }

  [(id)a1 invalidateIKESessionForClass:a2];
  uint64_t v6 = _NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
  id v7 = (void *)v6;
  if ((_DWORD)a2 != 4)
  {
    int v17 = _NRLogIsLevelEnabled(v6, 17LL);

    if (!v17) {
      goto LABEL_11;
    }
    uint64_t v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v18);
    id v16 = [(id)a1 copyDescription];
    _NRLogWithArgs(v15, 17LL, "%@: %@ session as unsupported", v16, String);
    goto LABEL_10;
  }

  int v8 = _NRLogIsLevelEnabled(v6, 0LL);

  if (v8)
  {
    id v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v9);
    id v11 = [(id)a1 copyDescription];
    _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d %@: Restarting %@ session",  "",  "-[NRLinkFixedInterface restartIKESessionForDataProtectionClass:]",  257LL,  v11,  String);
  }

  sub_100063ED0(a1);
LABEL_11:
}

void sub_100063ED0(char *a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = (void **)a1;
    int v3 = a1[112];
    if ((v3 - 1) < 2)
    {
      if (v3 == 1)
      {
        objc_opt_self(&OBJC_CLASS___NRIKEv2Listener);
        if (qword_1001DC640 != -1) {
          dispatch_once(&qword_1001DC640, &stru_1001ADE98);
        }
        id String = (id)qword_1001DC638;
        uint64_t v4 = (char *)objc_claimAutoreleasedReturnValue([v2 localInterfaceName]);
        id v5 = (id)objc_claimAutoreleasedReturnValue([v2 localOuterEndpoint]);
        sub_10000F230((uint64_t)String, v2, v4, v5);
        goto LABEL_7;
      }

      if (v3 == 2)
      {
        if (*(void *)(a1 + 231)) {
          return;
        }
        id String = (id)NRDataProtectionClassCreateString(4LL);
        if (*((unsigned __int8 *)v2 + 16) == 255)
        {
          __int128 v29 = (void *)_NRCopyLogObjectForNRUUID(v2[4], v9);
          int IsLevelEnabled = _NRLogIsLevelEnabled(v29, 0LL);

          if (!IsLevelEnabled) {
            goto LABEL_11;
          }
          uint64_t v4 = (char *)_NRCopyLogObjectForNRUUID(v2[4], v31);
          id v5 = [v2 copyDescription];
          _NRLogWithArgs( v4,  0LL,  "%s%.30s:%-4d %@: Not starting %@ initiator session because cancelled",  "",  "-[NRLinkFixedInterface setupIPsecIfNecessary:]",  482LL,  v5,  String);
          goto LABEL_7;
        }

        id v10 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v2[4]);
        uint64_t v4 = v10;
        if (v10)
        {
          id v12 = *((id *)v10 + 9);

          if (v12)
          {
            id v5 = sub_10010C0B8();
            [v5 setRandomizeLocalPort:1];
            uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v2 localInterfaceName]);
            [v5 setOutgoingInterfaceName:v14];

            uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v2 remoteOuterEndpoint]);
            [v5 setRemoteEndpoint:v15];

            objc_msgSend(v5, "setRequestChildlessSA:", objc_msgSend(v2, "hasCompanionDatapath") ^ 1);
            id v16 = sub_10010C6B8(1, v4, 4LL);
            [v2 invalidateIKESessionForClass:4];
            int v17 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"terminus-FixedInterface-%@",  String);
            uint64_t v18 = objc_alloc(&OBJC_CLASS___NEIKEv2Session);
            id v19 = sub_10010C340();
            -[NEIKEv2ChildSAConfiguration setMode:](v19, "setMode:", 2LL);
            -[NEIKEv2ChildSAConfiguration setReplayWindowSize:](v19, "setReplayWindowSize:", 4LL);
            uint64_t v20 = -[NEIKEv2Session initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessionName:packetDelegate:]( v18,  "initWithIKEConfig:firstChildConfig:sessionConfig:queue:ipsecInterface:ikeSocketHandler:kernelSASessi onName:packetDelegate:",  v5,  v19,  v16,  v2[1],  [v2 virtualInterface],  0,  v17,  0);
            id v21 = *(void **)((char *)v2 + 231);
            *(void **)((char *)v2 + 231) = v20;

            if (*(void **)((char *)v2 + 231))
            {
              [v2 reportEvent:3015, @"%@ %@", String, *(void **)((char *)v2 + 231) detailsFormat];
              sub_100062978(v2);
              id v24 = (void *)_NRCopyLogObjectForNRUUID(v2[4], v23);
              int v25 = _NRLogIsLevelEnabled(v24, 0LL);

              if (v25)
              {
                id v27 = (void *)_NRCopyLogObjectForNRUUID(v2[4], v26);
                id v28 = [v2 copyDescription];
                _NRLogWithArgs( v27,  0LL,  "%s%.30s:%-4d %@: Connecting initiator %@ session %@",  "",  "-[NRLinkFixedInterface setupIPsecIfNecessary:]",  520LL,  v28,  String,  *(void **)((char *)v2 + 231));
              }

              objc_msgSend(*(void **)((char *)v2 + 231), "connect", String);
            }

            else
            {
              id v44 = (void *)_NRCopyLogObjectForNRUUID(v2[4], v22);
              int v45 = _NRLogIsLevelEnabled(v44, 17LL);

              if (v45)
              {
                id v47 = (void *)_NRCopyLogObjectForNRUUID(v2[4], v46);
                id v48 = [v2 copyDescription];
                _NRLogWithArgs(v47, 17LL, "%@: Failed to create initiator %@ IKE session", v48, String);
              }
            }
          }

          else
          {
            id v32 = (void *)_NRCopyLogObjectForNRUUID(v2[4], v13);
            int v33 = _NRLogIsLevelEnabled(v32, 0LL);

            if (!v33) {
              goto LABEL_10;
            }
            id v5 = (id)_NRCopyLogObjectForNRUUID(v2[4], v34);
            id v16 = (NEIKEv2SessionConfiguration *)[v2 copyDescription];
            _NRLogWithArgs( v5,  0LL,  "%s%.30s:%-4d %@: Not starting %@ IKE initiator session because we do not have keys %@",  "",  "-[NRLinkFixedInterface setupIPsecIfNecessary:]",  491LL,  v16,  String,  v4);
          }

          goto LABEL_27;
        }
      }

      else
      {
        id v35 = sub_1000627F8();
        int v36 = _NRLogIsLevelEnabled(v35, 16LL);

        if (v36)
        {
          id v37 = sub_1000627F8();
          _NRLogWithArgs( v37,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: _ikev2Role == NRIKEv2RoleInitiator",  "",  "-[NRLinkFixedInterface setupIPsecIfNecessary:]",  475);
        }

        uint64_t v4 = (char *)_os_log_pack_size(12LL);
        uint64_t v2 = (id *)((char *)&String - ((__chkstk_darwin(v4) + 15) & 0xFFFFFFFFFFFFFFF0LL));
        id v38 = __error();
        uint64_t v39 = _os_log_pack_fill( v2,  v4,  *v38,  &_mh_execute_header,  "%{public}s Assertion Failed: _ikev2Role == NRIKEv2RoleInitiator");
        *(_DWORD *)uint64_t v39 = 136446210;
        *(void *)(v39 + 4) = "-[NRLinkFixedInterface setupIPsecIfNecessary:]";
        id v40 = sub_1000627F8();
        _NRLogAbortWithPack(v40, v2);
      }

      unsigned int v41 = (void *)_NRCopyLogObjectForNRUUID(v2[4], v11);
      int v42 = _NRLogIsLevelEnabled(v41, 17LL);

      if (!v42)
      {
        uint64_t v4 = 0LL;
        goto LABEL_10;
      }

      id v5 = (id)_NRCopyLogObjectForNRUUID(v2[4], v43);
      id v16 = (NEIKEv2SessionConfiguration *)[v2 copyDescription];
      _NRLogWithArgs(v5, 17LL, "%@: Not starting %@ IKE initiator session because localDevice is missing", v16, String);
LABEL_27:

LABEL_7:
LABEL_10:

LABEL_11:
      return;
    }

    uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), a2);
    int v7 = _NRLogIsLevelEnabled(v6, 17LL);

    if (v7)
    {
      id String = (id)_NRCopyLogObjectForNRUUID(v2[4], v8);
      uint64_t v4 = (char *)[v2 copyDescription];
      _NRLogWithArgs(String, 17LL, "%@: Unsupported ikev2 role %u", v4, *((unsigned __int8 *)v2 + 112));
      goto LABEL_10;
    }
  }

uint64_t sub_100064550(uint64_t result, int a2)
{
  if (result)
  {
    if (a2 != 4)
    {
      HIDWORD(v12) = a2;
      id v2 = sub_1000627F8();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v2, 16LL);

      if (IsLevelEnabled)
      {
        id v4 = sub_1000627F8();
        id String = (void *)NRDataProtectionClassCreateString(HIDWORD(v12));
        _NRLogWithArgs( v4,  16LL,  "%s%.30s:%-4d ABORTING: Cannot copy IKE session pointer for %@",  "",  "-[NRLinkFixedInterface ikeSessionPointerForDataProtectionClass:]",  232LL,  String);
      }

      uint64_t v6 = _os_log_pack_size(22LL);
      int v7 = (char *)&v12 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v8 = __error();
      uint64_t v9 = _os_log_pack_fill( v7,  v6,  *v8,  &_mh_execute_header,  "%{public}s Cannot copy IKE session pointer for %@");
      uint64_t v10 = NRDataProtectionClassCreateString(HIDWORD(v12));
      *(_DWORD *)uint64_t v9 = 136446466;
      *(void *)(v9 + 4) = "-[NRLinkFixedInterface ikeSessionPointerForDataProtectionClass:]";
      *(_WORD *)(v9 + 12) = 2112;
      *(void *)(v9 + 14) = v10;
      id v11 = sub_1000627F8();
      _NRLogAbortWithPack(v11, v7);
    }

    result += 231LL;
  }

  return result;
}

void sub_1000646A8(uint64_t a1, void *a2)
{
  path = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v4 = WeakRetained;
  if (WeakRetained)
  {
    unsigned int v5 = [WeakRetained state];
    if (path)
    {
      if (v5 != 255 && nw_path_get_status(path) == nw_path_status_satisfied)
      {
        int v7 = (void *)_NRCopyLogObjectForNRUUID(v4[4], v6);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0LL);

        if (IsLevelEnabled)
        {
          uint64_t v10 = (void *)_NRCopyLogObjectForNRUUID(v4[4], v9);
          id v11 = [v4 copyDescription];
          _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d %@: Restarting IKE session as path is satisfied",  "",  "-[NRLinkFixedInterface start]_block_invoke",  182LL,  v11);
        }

        sub_100063ED0((char *)v4, v9);
      }
    }
  }
}

void sub_1000649FC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 && *(_BYTE *)(v2 + 14))
  {
    if (*(_DWORD *)(v2 + 16))
    {
      id WeakRetained = objc_loadWeakRetained((id *)(v2 + 64));
      uint64_t v5 = *(void *)(a1 + 32);
      if (v5 && (--*(_DWORD *)(v5 + 16), (uint64_t v6 = *(void *)(a1 + 32)) != 0)) {
        uint64_t v7 = *(void *)(v6 + 40);
      }
      else {
        uint64_t v7 = 0LL;
      }
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(v7, v4);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 0LL);

      if (IsLevelEnabled)
      {
        uint64_t v10 = *(void **)(a1 + 32);
        if (v10) {
          uint64_t v10 = (void *)v10[5];
        }
        id v11 = v10;
        uint64_t v13 = _NRCopyLogObjectForNRUUID(v11, v12);
        uint64_t v14 = (void *)v13;
        uint64_t v15 = *(void *)(a1 + 32);
        if (v15) {
          LODWORD(v15) = *(_DWORD *)(v15 + 16);
        }
        _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d Link preferences agent un-asserted (Total remaining assertions: %u)",  "",  "-[NRBTLinkPreferencesAgent unassertAgentWithOptions:]_block_invoke",  220,  v15);
      }

      uint64_t v16 = *(void *)(a1 + 32);
      if (!v16 || !*(_DWORD *)(v16 + 16)) {
        [WeakRetained deviceHasBTLinkUpgradeRequest:0];
      }
      int v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) objectForKeyedSubscript:NWNetworkAgentStartOptionClientUUID]);
      if (v17)
      {
        uint64_t v18 = *(void *)(a1 + 32);
        id v19 = v18 ? *(void **)(v18 + 80) : 0LL;
        uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([v19 objectForKeyedSubscript:v17]);

        if (v20)
        {
          uint64_t v21 = *(void *)(a1 + 32);
          if (v21) {
            uint64_t v22 = *(void **)(v21 + 80);
          }
          else {
            uint64_t v22 = 0LL;
          }
          uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([v22 objectForKeyedSubscript:v17]);
          uint64_t v24 = *(void *)(a1 + 32);
          if (v24) {
            int v25 = *(void **)(v24 + 88);
          }
          else {
            int v25 = 0LL;
          }
          if ([v25 countForObject:v17])
          {
            uint64_t v26 = *(void *)(a1 + 32);
            id v27 = v26 ? *(void **)(v26 + 88) : 0LL;
            [v27 removeObject:v17];
            uint64_t v28 = *(void *)(a1 + 32);
            __int128 v29 = v28 ? *(void **)(v28 + 88) : 0LL;
            if (![v29 countForObject:v17])
            {
              uint64_t v30 = *(void *)(a1 + 32);
              if (v30) {
                uint64_t v31 = *(void **)(v30 + 80);
              }
              else {
                uint64_t v31 = 0LL;
              }
              [v31 setObject:0 forKeyedSubscript:v17];
              [WeakRetained reportBTLinkUpgradeClientRemoved:v23];
            }
          }
        }
      }

      uint64_t v32 = *(void *)(a1 + 32);
      if (v32)
      {
        if (*(_DWORD *)(v32 + 16)) {
          goto LABEL_63;
        }
        uint64_t v32 = *(void *)(v32 + 88);
      }

      id v33 = (id)v32;
      if ([v33 count])
      {

LABEL_47:
        uint64_t v43 = *(void *)(a1 + 32);
        if (v43) {
          uint64_t v44 = *(void *)(v43 + 40);
        }
        else {
          uint64_t v44 = 0LL;
        }
        int v45 = (void *)_NRCopyLogObjectForNRUUID(v44, v34);
        int v46 = _NRLogIsLevelEnabled(v45, 16LL);

        if (v46)
        {
          id v48 = *(void **)(a1 + 32);
          if (v48) {
            id v48 = (void *)v48[5];
          }
          uint64_t v49 = v48;
          int v51 = (void *)_NRCopyLogObjectForNRUUID(v49, v50);
          uint64_t v52 = *(void **)(a1 + 32);
          if (v52) {
            uint64_t v52 = (void *)v52[11];
          }
          id v53 = v52;
          id v54 = [v53 count];
          uint64_t v55 = *(void *)(a1 + 32);
          if (v55) {
            id v56 = *(void **)(v55 + 80);
          }
          else {
            id v56 = 0LL;
          }
          _NRLogWithArgs( v51,  16,  "%s%.30s:%-4d non-empty client dictionaries without valid agent assert count (%zu/%zu)",  "",  "-[NRBTLinkPreferencesAgent unassertAgentWithOptions:]_block_invoke",  239,  (size_t)v54,  (size_t)[v56 count]);
        }

        uint64_t v57 = *(void *)(a1 + 32);
        if (v57) {
          uint64_t v58 = *(void *)(v57 + 40);
        }
        else {
          uint64_t v58 = 0LL;
        }
        id v59 = (void *)_NRCopyLogObjectForNRUUID(v58, v47);
        int v60 = _NRLogIsLevelEnabled(v59, 17LL);

        if (v60)
        {
          uint64_t v62 = *(void *)(a1 + 32);
          if (v62) {
            uint64_t v63 = *(void *)(v62 + 40);
          }
          else {
            uint64_t v63 = 0LL;
          }
          id v64 = (void *)_NRCopyLogObjectForNRUUID(v63, v61);
          _NRLogWithArgs(v64, 17LL, "non-empty client dictionaries without valid agent assert count");
        }

        goto LABEL_63;
      }

      uint64_t v40 = *(void *)(a1 + 32);
      if (v40) {
        unsigned int v41 = *(void **)(v40 + 80);
      }
      else {
        unsigned int v41 = 0LL;
      }
      id v42 = [v41 count];

      if (v42) {
        goto LABEL_47;
      }
LABEL_63:

LABEL_64:
      return;
    }

    id v35 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v2 + 40), a2);
    int v36 = _NRLogIsLevelEnabled(v35, 17LL);

    if (v36)
    {
      uint64_t v38 = *(void *)(a1 + 32);
      if (v38) {
        uint64_t v39 = *(void *)(v38 + 40);
      }
      else {
        uint64_t v39 = 0LL;
      }
      id WeakRetained = (id)_NRCopyLogObjectForNRUUID(v39, v37);
      _NRLogWithArgs(WeakRetained, 17LL, "Received an unexpected unassertAgent call");
      goto LABEL_64;
    }
  }

void sub_100064DF0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1 && *(_BYTE *)(v1 + 14))
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v1 + 64));
    uint64_t v4 = *(void *)(a1 + 32);
    if (!v4 || (int v5 = *(_DWORD *)(v4 + 16)) == 0)
    {
      [WeakRetained deviceHasBTLinkUpgradeRequest:1];
      uint64_t v4 = *(void *)(a1 + 32);
      if (!v4) {
        goto LABEL_51;
      }
      int v5 = *(_DWORD *)(v4 + 16);
    }

    *(_DWORD *)(v4 + 16) = v5 + 1;
    uint64_t v6 = *(void *)(a1 + 32);
    if (v6)
    {
      uint64_t v7 = *(void *)(v6 + 40);
      goto LABEL_9;
    }

LABEL_51:
    uint64_t v7 = 0LL;
LABEL_9:
    uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(v7, v3);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v10 = *(void **)(a1 + 32);
      if (v10) {
        uint64_t v10 = (void *)v10[5];
      }
      id v11 = v10;
      uint64_t v13 = _NRCopyLogObjectForNRUUID(v11, v12);
      uint64_t v14 = (void *)v13;
      uint64_t v15 = *(void *)(a1 + 32);
      if (v15) {
        LODWORD(v15) = *(_DWORD *)(v15 + 16);
      }
      _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d Link preferences agent asserted (Total active assertions: %u)",  "",  "-[NRBTLinkPreferencesAgent assertAgentWithOptions:]_block_invoke",  186,  v15);
    }

    uint64_t v16 = NWNetworkAgentStartOptionClientUUID;
    int v17 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) objectForKeyedSubscript:NWNetworkAgentStartOptionClientUUID]);
    uint64_t v18 = *(void *)(a1 + 32);
    id v19 = *(id *)(a1 + 40);
    uint64_t v20 = v19;
    if (v18)
    {
      if (v19)
      {
        id v21 = (id)objc_claimAutoreleasedReturnValue([v19 objectForKeyedSubscript:NWNetworkAgentStartOptionPID]);
        if (v21) {
          goto LABEL_18;
        }
        uint64_t v22 = (NSString *)objc_claimAutoreleasedReturnValue([v20 objectForKeyedSubscript:v16]);
        if (!v22)
        {
          id v21 = 0LL;
          goto LABEL_19;
        }

        uint64_t v32 = (void *)objc_claimAutoreleasedReturnValue(+[NWPath pathForClientID:](&OBJC_CLASS___NWPath, "pathForClientID:", v22));
        id v33 = (void *)objc_claimAutoreleasedReturnValue([v32 parameters]);
        id v34 = [v33 copyCParameters];

        else {
          id v21 = 0LL;
        }

        if (v21) {
LABEL_18:
        }
          uint64_t v22 = sub_10010393C((uint64_t)[v21 intValue], 0);
        else {
          uint64_t v22 = 0LL;
        }
LABEL_19:

        if (v22 && v17)
        {
          uint64_t v23 = *(void *)(a1 + 32);
          if (v23) {
            uint64_t v24 = *(void **)(v23 + 80);
          }
          else {
            uint64_t v24 = 0LL;
          }
          int v25 = (void *)objc_claimAutoreleasedReturnValue([v24 objectForKeyedSubscript:v17]);

          if (!v25)
          {
            uint64_t v26 = *(void *)(a1 + 32);
            if (v26) {
              id v27 = *(void **)(v26 + 80);
            }
            else {
              id v27 = 0LL;
            }
            [v27 setObject:v22 forKeyedSubscript:v17];
          }

          uint64_t v28 = *(void *)(a1 + 32);
          if (v28) {
            __int128 v29 = *(void **)(v28 + 88);
          }
          else {
            __int128 v29 = 0LL;
          }
          if (![v29 countForObject:v17]) {
            [WeakRetained reportBTLinkUpgradeClientAdded:v22];
          }
          uint64_t v30 = *(void *)(a1 + 32);
          if (v30) {
            uint64_t v31 = *(void **)(v30 + 88);
          }
          else {
            uint64_t v31 = 0LL;
          }
          [v31 addObject:v17];
        }

        goto LABEL_34;
      }

      id v36 = sub_100065130();
      int v37 = _NRLogIsLevelEnabled(v36, 17LL);

      if (v37)
      {
        id v21 = sub_100065130();
        _NRLogWithArgs( v21,  17LL,  "%s called with null options",  "-[NRBTLinkPreferencesAgent retrieveClientNameFromOptions:]");
        uint64_t v22 = 0LL;
        goto LABEL_19;
      }
    }

    uint64_t v22 = 0LL;

LABEL_34:
  }

  -[NSMutableArray addObject:](v8, "addObject:", @"BatteryPercentageBest");
  if ((reason & 0x100000000000000LL) == 0)
  {
LABEL_26:
    if ((reason & 0x200000000000000LL) == 0) {
      goto LABEL_27;
    }
    goto LABEL_53;
  }

    uint64_t v32 = 0LL;
    goto LABEL_35;
  }

  v56.receiver = a1;
  v56.super_class = (Class)&OBJC_CLASS___NRLinkBluetooth;
  uint64_t v16 = (char *)objc_msgSendSuper2(&v56, "initLinkWithQueue:linkDelegate:nrUUID:", v11, v12, v13);
  if (v16)
  {
    a1 = v16;
    id v53 = v15;
    uint64_t v55 = v11;
    [v16 setType:1];
    objc_storeStrong((id *)(a1 + 335), a5);
    id v54 = v14;
    int v17 = (void *)objc_claimAutoreleasedReturnValue([v14 peer]);
    uint64_t v18 = objc_claimAutoreleasedReturnValue([v17 identifier]);
    id v19 = *(void **)(a1 + 327);
    *(void *)(a1 + 327) = v18;

    objc_storeStrong((id *)(a1 + 343), a6);
    uint64_t v20 = objc_alloc_init(&OBJC_CLASS___NRAnalyticsCmpnLinkBluetooth);
    id v21 = *(void **)(a1 + 1863);
    *(void *)(a1 + 1863) = v20;

    uint64_t v22 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
    *(_DWORD *)(a1 + 263) = 0xFFFF;
    uint64_t v14 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
    *(_DWORD *)(a1 + 271) = (*(_DWORD *)(a1 + 263) + 1) >> 1;
    *(_DWORD *)(a1 + 267) = *(_DWORD *)(a1 + 263);
    *(_DWORD *)(a1 + 275) = (*(_DWORD *)(a1 + 267) + 1) >> 1;
    *(_DWORD *)(a1 + 279) = 0x4000;
    *(_DWORD *)(a1 + 283) = *(_DWORD *)(a1 + 279);
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    uint64_t v23 = v12;
    uint64_t v24 = (unsigned __int8 *)(id)qword_1001DC870;
    if (v24)
    {
      uint64_t v12 = (id)v24[10];

      if ((_DWORD)v12)
      {
        a1[246] = 1;
        *(_DWORD *)(a1 + 263) = 48;
        *(_DWORD *)(a1 + 271) = (*(_DWORD *)(a1 + 263) + 1) >> 1;
        *(_DWORD *)(a1 + 267) = *(_DWORD *)(a1 + 263);
        *(_DWORD *)(a1 + 275) = (*(_DWORD *)(a1 + 267) + 1) >> 1;
        *(_DWORD *)(a1 + 279) = 48;
        *(_DWORD *)(a1 + 283) = *(_DWORD *)(a1 + 279);
      }
    }

    int v25 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v13);
    if (v25)
    {
      uint64_t v22 = (int *)v25;
      if (v25[15])
      {
        uint64_t v26 = 1;
      }

      else
      {
        if (v25[14]) {
          id v27 = 1;
        }
        else {
          id v27 = *((unsigned __int16 *)v25 + 14) > 0x12u;
        }
        uint64_t v26 = v27;
      }

      uint64_t v12 = v23;
      uint64_t v14 = v54;
      id v11 = v55;
      uint64_t v15 = v53;
      if (v25[12])
      {
        if (!v25[13]) {
          uint64_t v26 = 0;
        }
        if (v26 == 1)
        {
          a1[208] = 20;
LABEL_33:
          sub_10012E070(v25, a1 + 1951);
          sub_10012D7C8(v22, a1 + 1967);
          sub_1001368D4(v22, a1 + 1983);
          __int128 v29 = objc_msgSend(v13, "UUIDString", sub_100136A64(v22, a1 + 1999));
          uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
          [a1 reportEvent:3000 details:v30];

          uint64_t v31 = (void *)objc_claimAutoreleasedReturnValue([a1 linkDelegate]);
          [v31 linkIsAvailable:a1];

          uint64_t v32 = a1;
LABEL_34:

          goto LABEL_35;
        }
      }

      if (*((void *)v25 + 19))
      {
        if (v25[15]) {
          uint64_t v28 = 12;
        }
        else {
          uint64_t v28 = 10;
        }
        a1[208] = v28;
        goto LABEL_33;
      }

      if (v25[15])
      {
        a1[208] = 11;
        goto LABEL_33;
      }

      [a1 reportEvent:3017, @"Local device without pairing keys %@", v25 detailsFormat];
      p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
      if (qword_1001DC840 == -1)
      {
LABEL_37:
        if (_NRLogIsLevelEnabled(qword_1001DC838, 17LL))
        {
          if (p_class_meths[264] != (__objc2_meth_list *)-1LL) {
            dispatch_once(&qword_1001DC840, &stru_1001AEE08);
          }
          _NRLogWithArgs(qword_1001DC838, 17LL, "Local device without pairing keys %@", v22);
        }

        uint64_t v32 = 0LL;
        goto LABEL_34;
      }
    }

    else
    {
      uint64_t v47 = sub_100070554();
      id v48 = _NRLogIsLevelEnabled(v47, 16LL);

      uint64_t v15 = "-[NRLinkBluetooth initLinkWithQueue:linkDelegate:nrUUID:pipe:remoteDeviceName:]";
      if (v48)
      {
        uint64_t v49 = sub_100070554();
        _NRLogWithArgs( v49,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRLinkBluetooth initLinkWithQueue:linkDelegate:nrUUID:pipe:remoteDeviceName:]",  1050);
      }

      id v11 = (dispatch_queue_s *)_os_log_pack_size(12LL);
      p_class_meths = (__objc2_meth_list **)((char *)&v53 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL));
      uint64_t v50 = __error();
      int v51 = _os_log_pack_fill( p_class_meths,  v11,  *v50,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)int v51 = 136446210;
      *(void *)(v51 + 4) = "-[NRLinkBluetooth initLinkWithQueue:linkDelegate:nrUUID:pipe:remoteDeviceName:]";
      uint64_t v52 = sub_100070554();
      _NRLogAbortWithPack(v52, p_class_meths);
    }

    dispatch_once(&qword_1001DC840, &stru_1001AEE08);
    goto LABEL_37;
  }

  uint64_t v44 = sub_100070554();
  int v45 = _NRLogIsLevelEnabled(v44, 17LL);

  if (v45)
  {
    int v46 = sub_100070554();
    _NRLogWithArgs(v46, 17LL, "[NRLink initLinkWithQueue:] failed");
  }

  a1 = 0LL;
  uint64_t v32 = 0LL;
LABEL_35:

  return v32;
}
  }

            uint64_t v43 = _os_log_pack_size(38LL);
            uint64_t v44 = (char *)&v50 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
            int v45 = __error();
            int v46 = _os_log_pack_fill( v44,  v43,  *v45,  &_mh_execute_header,  "%{public}s xpc_dictionary_create(%p, %p, %u) failed");
            sub_1000DB1A0(v46);
            uint64_t v47 = sub_1000D54AC();
            _NRLogAbortWithPack(v47, v44);
          }
        }

        id v27 = v26;
        uint64_t v58 = (id)_CFXPCCreateXPCObjectFromCFObject(v51);
        xpc_dictionary_set_value(v27, kNRXPCCommNotificationTypeXPCommDictionary, v58);
        id v59 = v27;
        xpc_dictionary_set_value(v25, nrXPCKeyXPCCommNotification, v27);
        uint64_t v62 = 0u;
        uint64_t v63 = 0u;
        int v60 = 0u;
        uint64_t v61 = 0u;
        uint64_t v28 = *(id *)(a1 + 152);
        __int128 v29 = [v28 countByEnumeratingWithState:&v60 objects:v72 count:16];
        if (v29)
        {
          uint64_t v30 = v29;
          uint64_t v31 = *(void *)v61;
          do
          {
            for (j = 0LL; j != v30; j = (char *)j + 1)
            {
              if (*(void *)v61 != v31) {
                objc_enumerationMutation(v28);
              }
              xpc_connection_send_message(*(xpc_connection_t *)(*((void *)&v60 + 1) + 8LL * (void)j), v25);
              id v34 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v33);
              id v35 = _NRLogIsLevelEnabled(v34, 0LL);

              if (v35)
              {
                int v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v36);
                _NRLogWithArgs( v37,  0LL,  "%s%.30s:%-4d sending xpcComm message",  "",  "-[NRDDeviceConductor sendXPCCommDictionary:]",  7431);
              }
            }

            uint64_t v30 = [v28 countByEnumeratingWithState:&v60 objects:v72 count:16];
          }

          while (v30);
        }

        uint64_t v3 = v51;
      }
    }

    else
    {
      int v5 = *(void **)(a1 + 160);
      if (!v5)
      {
        uint64_t v6 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        uint64_t v7 = *(void **)(a1 + 160);
        *(void *)(a1 + 160) = v6;

        int v5 = *(void **)(a1 + 160);
      }

      [v5 addObject:v3];
    }
  }
}

            if (qword_1001DC978 != -1) {
              dispatch_once(&qword_1001DC978, &stru_1001AFA38);
            }
            if (_NRLogIsLevelEnabled(qword_1001DC970, 16LL))
            {
              if (qword_1001DC978 != -1) {
                dispatch_once(&qword_1001DC978, &stru_1001AFA38);
              }
              _NRLogWithArgs( qword_1001DC970,  16LL,  "%s%.30s:%-4d %@ Control session received unexpected notify code %u",  "",  "-[NRDevicePairingCandidateContext handleNotifyCode:payload:controlSession:]",  1749LL,  WeakRetained,  v10);
            }

            goto LABEL_57;
          }

          if ((int)v10 <= 50350)
          {
            if (((_DWORD)v10 - 48601) >= 7 && (_DWORD)v10)
            {
              uint64_t v13 = 48701;
LABEL_42:
              if ((_DWORD)v10 != v13) {
                goto LABEL_43;
              }
            }

            goto LABEL_51;
          }

          switch((int)v10)
          {
            case 50401:
            case 50402:
            case 50403:
            case 50411:
            case 50412:
            case 50413:
            case 50503:
            case 50504:
            case 50505:
              goto LABEL_51;
            case 50404:
            case 50405:
            case 50406:
            case 50407:
            case 50408:
            case 50409:
            case 50410:
            case 50414:
            case 50415:
            case 50416:
            case 50417:
            case 50418:
            case 50419:
            case 50420:
            case 50421:
            case 50422:
            case 50423:
            case 50424:
            case 50425:
            case 50426:
            case 50427:
            case 50428:
            case 50429:
            case 50430:
            case 50431:
            case 50432:
            case 50433:
            case 50434:
            case 50435:
            case 50436:
            case 50437:
            case 50438:
            case 50439:
            case 50440:
            case 50441:
            case 50442:
            case 50443:
            case 50444:
            case 50445:
            case 50446:
            case 50447:
            case 50448:
            case 50449:
            case 50450:
            case 50451:
            case 50452:
            case 50453:
            case 50454:
            case 50455:
            case 50456:
            case 50457:
            case 50458:
            case 50459:
            case 50460:
            case 50461:
            case 50462:
            case 50463:
            case 50464:
            case 50465:
            case 50466:
            case 50467:
            case 50468:
            case 50469:
            case 50470:
            case 50471:
            case 50472:
            case 50473:
            case 50474:
            case 50475:
            case 50476:
            case 50477:
            case 50478:
            case 50479:
            case 50480:
            case 50481:
            case 50482:
            case 50483:
            case 50484:
            case 50485:
            case 50486:
            case 50487:
            case 50488:
            case 50489:
            case 50490:
            case 50491:
            case 50492:
            case 50493:
            case 50494:
            case 50495:
            case 50496:
            case 50497:
            case 50498:
            case 50499:
            case 50500:
              goto LABEL_43;
            case 50501:
            case 50502:
              v24[0] = 0LL;
              v24[1] = v24;
              v24[2] = 0x2020000000LL;
              v24[3] = 0LL;
              v22[0] = 0LL;
              v22[1] = v22;
              v22[2] = 0x3032000000LL;
              v22[3] = sub_1000FCD08;
              v22[4] = sub_1000FCD18;
              uint64_t v23 = 0LL;
              v21[0] = _NSConcreteStackBlock;
              v21[1] = 3221225472LL;
              v21[2] = sub_1000FCD20;
              v21[3] = &unk_1001AFE20;
              void v21[4] = v24;
              v21[5] = v22;
              NRTLVParse(v11, v21);
              _Block_object_dispose(v22, 8);

              _Block_object_dispose(v24, 8);
              break;
            default:
              uint64_t v14 = -50351;
              goto LABEL_50;
          }

            uint64_t v30 = 1;
LABEL_59:

LABEL_60:
            a1 = v30;
            goto LABEL_61;
          }

          if (qword_1001DCC28 != -1) {
            dispatch_once(&qword_1001DCC28, &stru_1001B0980);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCC20, 17LL))
          {
            if (qword_1001DCC28 != -1) {
              dispatch_once(&qword_1001DCC28, &stru_1001B0980);
            }
            _NRLogWithArgs( qword_1001DCC20,  17LL,  "Failed to delete %@ keychain item %@: %d",  String,  v14,  v20,  v28,  v29);
          }
        }

        uint64_t v30 = 0;
        goto LABEL_59;
      }

id sub_100065130()
{
  if (qword_1001DC7C8 != -1) {
    dispatch_once(&qword_1001DC7C8, &stru_1001AEA20);
  }
  return (id)qword_1001DC7C0;
}

void sub_100065170(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC7C0;
  qword_1001DC7C0 = (uint64_t)v1;
}

void sub_1000651A0(uint64_t a1)
{
  if (a1 && *(_BYTE *)(a1 + 14))
  {
    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v2 = (id)qword_1001DCB58;
    sub_10012114C((uint64_t)v2, *(void **)(a1 + 72));

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v3 = (id)qword_1001DCB58;
    uint64_t v4 = (id *)v3;
    if (v3)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v3 + 1));
      if (([v4[2] apply] & 1) == 0) {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v5,  v6,  v7,  v16);
      }
    }

    if (([*(id *)(a1 + 56) unregisterNetworkAgent] & 1) == 0)
    {
      uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 40), v8);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 17LL);

      if (IsLevelEnabled)
      {
        uint64_t v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 40), v11);
        _NRLogWithArgs(v12, 17LL, "Failed to unregister BTLinkPreferences agent");
      }
    }

    uint64_t v13 = *(void **)(a1 + 56);
    *(void *)(a1 + 56) = 0LL;

    *(_BYTE *)(a1 + 14) = 0;
    id v14 = *(id *)(a1 + 40);
    id v17 = (id)objc_claimAutoreleasedReturnValue([(id)a1 agentUUID]);
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v17 UUIDString]);
    sub_10011BB18(v14, 18003, 0LL, v15);
  }

id *sub_1000653D0(id *a1, void *a2, void *a3, void *a4)
{
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  if (a1)
  {
    v35.receiver = a1;
    v35.super_class = (Class)&OBJC_CLASS___NRBTLinkPreferencesAgent;
    uint64_t v11 = (id *)objc_msgSendSuper2(&v35, "init");
    if (!v11)
    {
      id v26 = sub_100065130();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v26, 16LL);

      if (IsLevelEnabled)
      {
        id v28 = sub_100065130();
        _NRLogWithArgs( v28,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRBTLinkPreferencesAgent initWithNRUUID:queue:delegate:]",  41);
      }

      uint64_t v29 = _os_log_pack_size(12LL);
      uint64_t v30 = (char *)&v34 - ((v29 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v31 = __error();
      uint64_t v32 = _os_log_pack_fill(v30, v29, *v31, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v32 = 136446210;
      *(void *)(v32 + 4) = "-[NRBTLinkPreferencesAgent initWithNRUUID:queue:delegate:]";
      id v33 = sub_100065130();
      _NRLogAbortWithPack(v33, v30);
    }

    a1 = v11;
    objc_storeStrong(v11 + 6, a3);
    objc_storeStrong(a1 + 5, a2);
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
    [a1 setAgentUUID:v12];

    [a1 setUserActivated:1];
    [a1 setAgentDescription:@"Link preferences netagent"];
    objc_storeWeak(a1 + 8, v10);
    uint64_t v13 = objc_alloc(&OBJC_CLASS___NSString);
    id v14 = (void *)objc_claimAutoreleasedReturnValue([a1 agentUUID]);
    uint64_t v15 = (void *)objc_claimAutoreleasedReturnValue([v14 UUIDString]);
    uint64_t v16 = -[NSString initWithFormat:](v13, "initWithFormat:", @"NRBTLinkPreferencesAgent-%@", v15);
    id v17 = a1[9];
    a1[9] = v16;

    uint64_t v18 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    id v19 = a1[10];
    a1[10] = v18;

    uint64_t v20 = objc_alloc_init(&OBJC_CLASS___NSCountedSet);
    id v21 = a1[11];
    a1[11] = v20;

    id v22 = a1[5];
    uint64_t v23 = (void *)objc_claimAutoreleasedReturnValue([a1 agentUUID]);
    uint64_t v24 = (void *)objc_claimAutoreleasedReturnValue([v23 UUIDString]);
    sub_10011BB18(v22, 18001, 0LL, v24);
  }

  return a1;
}

void sub_100065688()
{
  uint64_t v0 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v0);

  if (!qword_1001DC7D0)
  {
    uint64_t v1 = os_transaction_create("com.apple.terminusd.keepalive");
    id v2 = (void *)qword_1001DC7D0;
    qword_1001DC7D0 = v1;
  }

  id v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
  unsigned __int8 v4 = [v3 fileExistsAtPath:@"/var/mobile/Library/terminus/com.apple.terminusd.keepalive"];

  if ((v4 & 1) == 0)
  {
    sub_1001010F0(@"/var/mobile/Library/terminus/com.apple.terminusd.keepalive", 0LL, 0);
    if (qword_1001DC7E0 != -1) {
      dispatch_once(&qword_1001DC7E0, &stru_1001AEAA0);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC7D8, 0LL))
    {
      if (qword_1001DC7E0 != -1) {
        dispatch_once(&qword_1001DC7E0, &stru_1001AEAA0);
      }
      _NRLogWithArgs(qword_1001DC7D8, 0LL, "%s%.30s:%-4d new keepalive file added", "", "terminusdKeepAliveEnable", 37);
    }
  }

  objc_opt_self(&OBJC_CLASS___NRDKeyManager);
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  id v5 = (id)qword_1001DCC10;
  sub_100144478((uint64_t)v5, &stru_1001AEA80);
}

void sub_100065800(id a1)
{
}

void sub_10006580C(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  id v2 = (void *)qword_1001DC7D8;
  qword_1001DC7D8 = (uint64_t)v1;
}

void sub_10006583C(id a1)
{
  if (sub_10009F9C0((uint64_t)a1) && sub_10013139C((uint64_t)&OBJC_CLASS___NRDLocalDevice))
  {
    sub_100065688();
  }

  else
  {
    os_log_t v1 = sub_100146AFC();
    dispatch_assert_queue_V2((dispatch_queue_t)v1);

    if ((byte_1001DC7E8 & 1) == 0)
    {
      byte_1001DC7E8 = 1;
      dispatch_time_t v2 = dispatch_time(0LL, 2000000000LL);
      id v3 = sub_100146AFC();
      dispatch_after(v2, (dispatch_queue_t)v3, &stru_1001AEAC0);
    }
  }

void sub_1000658EC(id a1)
{
  os_log_t v1 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v1);

  byte_1001DC7E8 = 0;
  if (!sub_10009F9C0(v2) || (sub_10013139C((uint64_t)&OBJC_CLASS___NRDLocalDevice) & 1) == 0)
  {
    id v3 = (id)qword_1001DC7D0;
    unsigned __int8 v4 = (void *)qword_1001DC7D0;
    qword_1001DC7D0 = 0LL;

    ne_session_clear_caches();
    id v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](&OBJC_CLASS___NSFileManager, "defaultManager"));
    id v12 = 0LL;
    unsigned __int8 v6 = [v5 removeItemAtPath:@"/var/mobile/Library/terminus/com.apple.terminusd.keepalive" error:&v12];
    id v7 = v12;

    if ((v6 & 1) == 0)
    {
      id v8 = v7;
      id v9 = v8;
      if (v8 && [v8 code] == (id)4)
      {
        id v10 = (void *)objc_claimAutoreleasedReturnValue([v9 domain]);
        unsigned __int8 v11 = [v10 isEqualToString:NSCocoaErrorDomain];

        if ((v11 & 1) != 0) {
          goto LABEL_15;
        }
      }

      else
      {
      }

      if (qword_1001DC7E0 != -1) {
        dispatch_once(&qword_1001DC7E0, &stru_1001AEAA0);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC7D8, 17LL))
      {
        if (qword_1001DC7E0 != -1) {
          dispatch_once(&qword_1001DC7E0, &stru_1001AEAA0);
        }
        _NRLogWithArgs( qword_1001DC7D8,  17LL,  "Deleting empty keep alive file %s failed: %@",  "/var/mobile/Library/terminus/com.apple.terminusd.keepalive",  v9);
      }
    }

LABEL_42:
  -[NSMutableArray addObject:](v8, "addObject:", @"RadioConditionGood");
  if ((reason & 0x200000) == 0)
  {
LABEL_17:
    if ((reason & 0x400000) == 0) {
      goto LABEL_18;
    }
    goto LABEL_44;
  }

  -[NSMutableArray addObject:](v3, "addObject:", @"BtryFair");
  if ((a1 & 0x10000000) == 0)
  {
LABEL_17:
    if ((a1 & 0x20000000) == 0) {
      goto LABEL_18;
    }
    goto LABEL_44;
  }

  sub_1000E475C((void **)&self->super.isa);
  sub_1000E4DAC((char *)self, v104);
  unsigned int v41 = v104;
  dispatch_assert_queue_V2((dispatch_queue_t)self->_queue);
  if (!self->_helloMessageSent)
  {
    id v42 = (id *)sub_100021C64(objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage), self->_nrUUID);
    uint64_t v43 = v42;
    if (v42)
    {
      objc_storeStrong(v42 + 3, a3);
      sub_1000222F4((uint64_t)v43, 1, 0LL);
    }

    sub_100023824((uint64_t)v43);
    self->_helloMessageSent = 1;
  }

  sub_1000E160C((uint64_t)self);
  sub_1000E8470((uint64_t)self);
  if ([v41 type] == 1 && (sub_1000D4B98((uint64_t)self, 1) & 1) == 0)
  {
    sub_1000DAAA4((uint64_t)self, 1);
  }

  else
  {
    int v45 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v44);
    int v46 = _NRLogIsLevelEnabled(v45, 0LL);

    if (v46)
    {
      id v48 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v47);
      _NRLogWithArgs( v48,  0LL,  "%s%.30s:%-4d Update WiFi request already present",  "",  "-[NRDDeviceConductor linkIsReady:]",  5749);
    }
  }

  sub_1000E9E10((uint64_t)self);
  sub_1000DAF94((uint64_t)self);
  sub_1000E1878((uint64_t)self, v41);
  sub_1000DBDAC((uint64_t)self, v41);
  sub_1000DBA08((uint64_t)self, v41);
  sub_1000DBBF8((uint64_t)self, v41);
  if (self->_hasPendingImmediateNetInfoUpdateMessage) {
    sub_1000DD7C4((uint64_t)self);
  }
  sub_1000DFF48((unsigned int *)self);
  sub_1000DFA94((uint64_t)self);
  isCurrentlyPairing = self->_isCurrentlyPairing;
  self->_isCurrentlyPairing = 0;
  if (isCurrentlyPairing && [v41 subtype] != 103)
  {
    discoveredEndpoint = self->_discoveredEndpoint;
    self->_discoveredEndpoint = 0LL;

    discoveryClient = self->_discoveryClient;
    if (discoveryClient)
    {
      sub_100113E44((uint64_t)discoveryClient, v86);
      id v88 = self->_discoveryClient;
      self->_discoveryClient = 0LL;
    }

    sub_1000D55D0((uint64_t)self, [v41 type], (char)objc_msgSend(v41, "subtype"));
LABEL_95:
    sub_1000EA2AC((uint64_t)self);
    if (!self->_isProxyClient) {
      goto LABEL_110;
    }
    goto LABEL_96;
  }

  __int128 v114 = 0u;
  __int128 v115 = 0u;
  __int128 v112 = 0u;
  uint64_t v113 = 0u;
  id obj = self->_availableLinks;
  uint64_t v50 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v112,  &newValue,  16LL);
  if (v50)
  {
    int v51 = v50;
    uint64_t v52 = &APSConnectionOverrideNamedDelegatePort_ptr;
    id v53 = *(void *)v113;
    uint64_t v105 = *(void *)v113;
    id v106 = self;
    do
    {
      for (uint64_t i = 0LL; i != v51; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v113 != v53) {
          objc_enumerationMutation(obj);
        }
        uint64_t v55 = *(void **)(*((void *)&v112 + 1) + 8LL * (void)i);
        if ([v55 state] != 8)
        {
          id v56 = v51;
          uint64_t v57 = v52;
          __int128 v110 = 0u;
          __int128 v111 = 0u;
          uint64_t v108 = 0u;
          __int128 v109 = 0u;
          uint64_t v58 = self->_availableLinks;
          id v59 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v58,  "countByEnumeratingWithState:objects:count:",  &v108,  v116,  16LL);
          if (v59)
          {
            int v60 = v59;
            uint64_t v61 = *(void *)v109;
LABEL_68:
            uint64_t v62 = 0LL;
            while (1)
            {
              if (*(void *)v109 != v61) {
                objc_enumerationMutation(v58);
              }
              uint64_t v63 = *(void **)(*((void *)&v108 + 1) + 8 * v62);
              id v64 = [v63 type];
              if (v64 == [v55 type])
              {
                uint64_t v65 = [v63 subtype];
              }

              if (v60 == (id)++v62)
              {
                int v60 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( v58,  "countByEnumeratingWithState:objects:count:",  &v108,  v116,  16LL);
                if (!v60) {
                  goto LABEL_76;
                }
                goto LABEL_68;
              }
            }

            uint64_t v52 = v57;
            int v51 = v56;
            id v53 = v105;
            self = v106;
          }

          else
          {
LABEL_76:

            int v66 = [v55 type];
            int v67 = [v55 subtype];
            self = v106;
            uint64_t v52 = v57;
            int v51 = v56;
            id v53 = v105;
            uint64_t v69 = (v67 - 101);
            if (v69 >= 4)
            {
              if (v66 >= 6 || (uint64_t v70 = 0x40300020100uLL >> (8 * v66), !(_BYTE)v70))
              {
LABEL_87:
                uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v106->_nrUUID, v68);
                id v82 = _NRLogIsLevelEnabled(v81, 16LL);

                if (v82)
                {
                  unsigned int v84 = (void *)_NRCopyLogObjectForNRUUID(v106->_nrUUID, v83);
                  _NRLogWithArgs( v84,  16LL,  "%s%.30s:%-4d invalid link type/subtype %u/%u",  "",  "-[NRDDeviceConductor stopDiscoveryOverLinkType:subtype:]",  7546,  v66,  v67);
                }

                continue;
              }
            }

            else
            {
              LODWORD(v70) = 0x7060502u >> (8 * v69);
              if (!(_BYTE)v70) {
                goto LABEL_87;
              }
            }

            uint64_t v71 = (uint64_t)v106->_discoveryClient;
            if (v71)
            {
              char v72 = *(void **)(v71 + 104);
              uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue([v52[149] numberWithUnsignedChar:v70]);
              [v72 removeObject:v73];

              if (*(_BYTE *)(v71 + 19))
              {
                if (*(_BYTE *)(v71 + 20))
                {
                  int v74 = v52[149];
                  uint64_t v75 = *(id *)(v71 + 168);
                  id v76 = (void *)objc_claimAutoreleasedReturnValue([v74 numberWithUnsignedChar:v70]);
                  int v77 = (nw_browser *)objc_claimAutoreleasedReturnValue([v75 objectForKeyedSubscript:v76]);

                  if (v77)
                  {
                    nw_browser_cancel(v77);
                    uint64_t v78 = v52[149];
                    id v79 = *(id *)(v71 + 168);
                    uint64_t v80 = (void *)objc_claimAutoreleasedReturnValue([v78 numberWithUnsignedChar:v70]);
                    [v79 setObject:0 forKeyedSubscript:v80];
                  }

                  sub_100117794(v71, v70);
                  self = v106;
                }
              }
            }
          }
        }
      }

      int v51 = -[NSMutableSet countByEnumeratingWithState:objects:count:]( obj,  "countByEnumeratingWithState:objects:count:",  &v112,  &newValue,  16LL);
    }

    while (v51);
  }

  sub_1000EA2AC((uint64_t)self);
  if (self && self->_isProxyClient)
  {
LABEL_96:
    uint64_t v89 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, self->_nrUUID);
    uint64_t v30 = v89;
    if (v89) {
      uint64_t v90 = (void *)*((void *)v89 + 16);
    }
    else {
      uint64_t v90 = 0LL;
    }
    id v91 = v90;
    int v92 = [v91 usesTLS];

    if (v92)
    {
      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      uint64_t v93 = (id)qword_1001DC870;
      id v94 = v93;
      if (v93) {
        uint64_t v95 = (void *)*((void *)v93 + 13);
      }
      else {
        uint64_t v95 = 0LL;
      }
      uint64_t v96 = v95;

      if (v96)
      {
        uint64_t v97 = sub_100021C64(objc_alloc(&OBJC_CLASS___NRLinkDirectorMessage), self->_nrUUID);
        objc_opt_self(&OBJC_CLASS___NRLinkDirector);
        if (qword_1001DC878 != -1) {
          dispatch_once(&qword_1001DC878, &stru_1001AEED0);
        }
        int v98 = (id)qword_1001DC870;
        uint64_t v99 = v98;
        if (v98) {
          uint64_t v100 = (void *)*((void *)v98 + 13);
        }
        else {
          uint64_t v100 = 0LL;
        }
        id v101 = v100;
        sub_1000222F4((uint64_t)v97, 23, v101);

        sub_100023824((uint64_t)v97);
      }
    }

    goto LABEL_109;
  }
}

    goto LABEL_43;
  }

  if ([v4 type] == 1)
  {
    unsigned __int8 v6 = 800;
  }

  else if ([v4 type] == 2)
  {
    if ([v4 subtype] == 102)
    {
      unsigned __int8 v6 = 1100;
    }

    else if ([v4 subtype] == 103)
    {
      unsigned __int8 v6 = 1000;
    }

    else if ([v4 subtype] == 104)
    {
      unsigned __int8 v6 = 950;
    }

    else
    {
      unsigned __int8 v6 = 900;
    }
  }

  else if ([v4 type] == 4)
  {
    unsigned __int8 v6 = 1200;
  }

  else
  {
    if ([v4 type] != 5)
    {
      __int128 v115 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v44);
      __int128 v116 = _NRLogIsLevelEnabled(v115, 17LL);

      if (v116)
      {
        __int128 v118 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v117);
        StringFromNRLinkType = (void *)createStringFromNRLinkType([v4 type]);
        _NRLogWithArgs(v118, 17LL, "Received unexpected link type %@", StringFromNRLinkType);
      }

      goto LABEL_92;
    }

    unsigned __int8 v6 = 700;
  }

  LODWORD(v547) = v6;
  if ([v4 virtualInterface])
  {
    id v64 = (id)NEVirtualInterfaceCopyName([v4 virtualInterface]);
    if (!v64)
    {
      dispatch_group_t v268 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v63);
      v269 = _NRLogIsLevelEnabled(v268, 16LL);

      if (v269)
      {
        v271 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v270);
        _NRLogWithArgs( v271,  16LL,  "%s%.30s:%-4d %@ failed to get virtual interface name to set IP tunnel policies",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3531LL,  v4);
      }

      v272 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v270);
      v273 = _NRLogIsLevelEnabled(v272, 17LL);

      if (v273)
      {
        dispatch_source_t v275 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v274);
        _NRLogWithArgs(v275, 17LL, "Failed to get virtual interface name to set IP tunnel policies");
      }

      [v4 cancelWithReason:@"Failed to get virtual interface name to set IP tunnel policies"];
      goto LABEL_91;
    }

    uint64_t v65 = &APSConnectionOverrideNamedDelegatePort_ptr;
    int v66 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    if (v66)
    {
      uint64_t v2 = v66;
      int v67 = *((id *)a1 + 12);
      uint64_t v68 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v67);

      v548 = v68;
      if (v68)
      {
        sub_1000EB164((uint64_t)a1);
        if (!a1[45] && a1[47] && ([v4 hasRouteRulePolicy] & 1) == 0)
        {
          uint64_t v86 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
          v567 = v86;
          uint64_t v87 = (NSString *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v567,  1LL));

          v546 = v64;
          uint64_t v71 = (id)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forInterfaceName:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forInterfaceName:",  2LL,  v64));
          v566 = v71;
          id v88 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  &v566,  1LL));
          uint64_t v89 = objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v88));

          v545 = v87;
          uint64_t v90 = [[NEPolicy alloc] initWithOrder:210 result:v89 conditions:v87];
          objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
          id v91 = (void *)v89;
          if (qword_1001DCB60 != -1) {
            dispatch_once(&qword_1001DCB60, &stru_1001B0538);
          }
          int v92 = (id)qword_1001DCB58;
          uint64_t v93 = *((id *)a1 + 34);
          id v94 = sub_100120E44((uint64_t)v92, v93, v90);
          uint64_t v95 = (void *)objc_claimAutoreleasedReturnValue(v94);

          if (![v95 unsignedIntegerValue])
          {
            id v306 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v96);
            int v307 = _NRLogIsLevelEnabled(v306, 16LL);

            if (v307)
            {
              uint64_t v309 = *((id *)a1 + 12);
              v311 = (void *)_NRCopyLogObjectForNRUUID(v309, v310);
              _NRLogWithArgs( v311,  16LL,  "%s%.30s:%-4d %@ failed to add generalPolicy %@ to session %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3560LL,  v4,  v90,  *((void *)a1 + 34));
            }

            uint64_t v312 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v308);
            id v313 = _NRLogIsLevelEnabled(v312, 17LL);

            if (v313)
            {
              char v315 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v314);
              _NRLogWithArgs(v315, 17LL, "Failed to add generalPolicy");
            }

            [v4 cancelWithReason:@"Failed to add generalPolicy %@ to session %@", v90, *((void *)a1 + 34)];

            int v102 = v545;
            id v64 = v546;
            goto LABEL_88;
          }

          -[NSMutableArray addObject:](v2, "addObject:", v95);

          [v4 setHasRouteRulePolicy:1];
          id v64 = v546;
          uint64_t v65 = &APSConnectionOverrideNamedDelegatePort_ptr;
        }

        v549 = v2;
        if ([v4 type] == 1
          || [v4 type] == 2
          || [v4 type] == 5)
        {
          if ([v4 ikeClassDEstablished]
            && ([v4 hasClassDPolicies] & 1) == 0)
          {
            uint64_t v69 = v65;
            uint64_t v70 = sub_100146AFC();
            dispatch_assert_queue_V2((dispatch_queue_t)v70);

            v545 = (NSString *)sub_10012D254(v548, @"0");
            uint64_t v71 = (id)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:"));
            v565[0] = v71;
            char v72 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
            v565[1] = v72;
            uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v565,  2LL));

            v546 = v64;
            int v74 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v64,  0LL));
            uint64_t v75 = [[NEPolicy alloc] initWithOrder:v547 result:v74 conditions:v73];
            objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
            if (qword_1001DCB60 != -1) {
              dispatch_once(&qword_1001DCB60, &stru_1001B0538);
            }
            id v76 = (id)qword_1001DCB58;
            int v77 = sub_100120E44((uint64_t)v76, *((void **)a1 + 34), v75);
            uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue(v77);

            if (![v78 unsignedIntegerValue])
            {
              v286 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v79);
              id v287 = _NRLogIsLevelEnabled(v286, 16LL);

              if (v287)
              {
                int v289 = *((id *)a1 + 12);
                v291 = (void *)_NRCopyLogObjectForNRUUID(v289, v290);
                _NRLogWithArgs( v291,  16LL,  "%s%.30s:%-4d %@ failed to add generalPolicyClassD %@ to session %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3580LL,  v4,  v75,  *((void *)a1 + 34));
              }

              id v292 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v288);
              v293 = _NRLogIsLevelEnabled(v292, 17LL);

              if (v293)
              {
                uint64_t v295 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v294);
                _NRLogWithArgs(v295, 17LL, "Failed to add generalPolicyClassD");
              }

              [v4 cancelWithReason:@"Failed to add generalPolicyClassD %@ to session %@", v75, *((void *)a1 + 34)];
              goto LABEL_170;
            }

            -[NSMutableArray addObject:](v549, "addObject:", v78);

            [v4 setHasClassDPolicies:1];
            id v64 = v546;
            uint64_t v65 = v69;
          }

          if ([v4 ikeClassCEstablished]
            && ([v4 hasClassCPolicies] & 1) == 0)
          {
            uint64_t v80 = v65;
            uint64_t v81 = sub_100146AFC();
            dispatch_assert_queue_V2((dispatch_queue_t)v81);

            v545 = (NSString *)sub_10012D610(v548, @"0");
            uint64_t v71 = (id)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:"));
            v564[0] = v71;
            id v82 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
            v564[1] = v82;
            uint64_t v73 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v564,  2LL));

            v546 = v64;
            int v74 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v64,  0LL));
            uint64_t v75 = [[NEPolicy alloc] initWithOrder:v547 result:v74 conditions:v73];
            objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
            if (qword_1001DCB60 != -1) {
              dispatch_once(&qword_1001DCB60, &stru_1001B0538);
            }
            id v83 = (id)qword_1001DCB58;
            unsigned int v84 = sub_100120E44((uint64_t)v83, *((void **)a1 + 34), v75);
            uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue(v84);

            if ([v78 unsignedIntegerValue])
            {
              -[NSMutableArray addObject:](v549, "addObject:", v78);

              [v4 setHasClassCPolicies:1];
              id v64 = v546;
              uint64_t v65 = v80;
              goto LABEL_79;
            }

            v296 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v85);
            id v297 = _NRLogIsLevelEnabled(v296, 16LL);

            if (v297)
            {
              int v299 = *((id *)a1 + 12);
              uint64_t v301 = (void *)_NRCopyLogObjectForNRUUID(v299, v300);
              _NRLogWithArgs( v301,  16LL,  "%s%.30s:%-4d %@ failed to add generalPolicyClassC %@ to session %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3597LL,  v4,  v75,  *((void *)a1 + 34));
            }

            v302 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v298);
            v303 = _NRLogIsLevelEnabled(v302, 17LL);

            if (v303)
            {
              id v305 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 12), v304);
              _NRLogWithArgs(v305, 17LL, "Failed to add generalPolicyClassC");
            }

            [v4 cancelWithReason:@"Failed to add generalPolicyClassC %@ to session %@", v75, *((void *)a1 + 34)];
LABEL_170:

            int v102 = v545;
            id v64 = v546;
            uint64_t v2 = v549;
LABEL_88:

LABEL_89:
            goto LABEL_90;
          }

  (*((void (**)(id, NEIKEv2SessionConfiguration *, void, void))v19 + 2))(v19, v30, 0LL, 0LL);
}

          close((int)v3);
          goto LABEL_43;
        }

        p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
        if (qword_1001DCA58 == -1)
        {
LABEL_22:
          if (_NRLogIsLevelEnabled(qword_1001DCA50, 0LL))
          {
            if (p_class_meths[331] != (__objc2_meth_list *)-1LL) {
              dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
            }
            unsigned __int8 v6 = (id)qword_1001DCA50;
            [v1 UTF8String];
            _NRLogWithArgs( v6,  0LL,  "%s%.30s:%-4d Set interface availability on interface %s to %d (0 implies 'available')");
LABEL_41:

            goto LABEL_42;
          }

          goto LABEL_42;
        }
      }

      else
      {
        uint64_t v13 = sub_100100C84();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v13, 16LL);

        p_class_meths = (__objc2_meth_list **)"_strict_strlcpy";
        if (IsLevelEnabled)
        {
          uint64_t v15 = sub_100100C84();
          _NRLogWithArgs( v15,  16LL,  "%s%.30s:%-4d ABORTING: strict_strlcpy called with NULL src",  "",  "_strict_strlcpy",  240);
        }

        os_log_t v1 = (id)_os_log_pack_size(12LL);
        id v3 = &__strerrbuf[-((__chkstk_darwin(v1) + 15) & 0xFFFFFFFFFFFFFFF0LL)];
        uint64_t v16 = __error();
        id v17 = _os_log_pack_fill( v3,  v1,  *v16,  &_mh_execute_header,  "%{public}s strict_strlcpy called with NULL src");
        *(_DWORD *)id v17 = 136446210;
        *(void *)(v17 + 4) = "_strict_strlcpy";
        uint64_t v18 = sub_100100C84();
        _NRLogAbortWithPack(v18, v3);
      }

      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      goto LABEL_22;
    }

    if (qword_1001DCA58 != -1) {
      dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
    }
    if (_NRLogIsLevelEnabled(qword_1001DCA50, 17LL))
    {
      if (qword_1001DCA58 != -1) {
        dispatch_once(&qword_1001DCA58, &stru_1001AFCE8);
      }
      _NRLogWithArgs(qword_1001DCA50, 17LL, "Failed to create socket");
    }
  }

  else
  {
    id v10 = sub_100100C84();
    unsigned __int8 v11 = _NRLogIsLevelEnabled(v10, 17LL);

    if (v11)
    {
      id v12 = sub_100100C84();
      _NRLogWithArgs(v12, 17LL, "%s called with null intfName", "NRDSetInterfaceAvailabilityForInterfaceName");
    }
  }

LABEL_50:
  -[NSMutableArray addObject:](v8, "addObject:", @"BatteryPercentageGood");
  if ((reason & 0x20000000) == 0)
  {
LABEL_25:
    if ((reason & 0x100000000000000LL) == 0) {
      goto LABEL_26;
    }
    goto LABEL_52;
  }

  -[NSMutableArray addObject:](v3, "addObject:", @"BtryDtr");
  if ((a1 & 0x4000000000000000LL) != 0) {
LABEL_25:
  }
    -[NSMutableArray addObject:](v3, "addObject:", @"LnkSwtchFlr");
LABEL_26:
  if (-[NSMutableArray count](v3, "count")) {
    unsigned __int8 v4 = (__CFString *)objc_claimAutoreleasedReturnValue(-[NSMutableArray componentsJoinedByString:](v3, "componentsJoinedByString:", @"_"));
  }
  else {
    unsigned __int8 v4 = @"<none>";
  }

  return v4;
}

    id v42 = _os_log_pack_size(28LL);
    uint64_t v43 = (char *)&v47 - ((__chkstk_darwin(v42) + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v44 = __error();
    int v45 = _os_log_pack_fill( v43,  v42,  *v44,  &_mh_execute_header,  "%{public}s xpc_array_create(%p, %u) failed");
    sub_10005B18C(v45, (uint64_t)"nr_xpc_array_create");
    int v46 = sub_1000B07C8();
    _NRLogAbortWithPack(v46, v43);
    goto LABEL_51;
  }

  xpc_array_append_value(v15, v14);
  nw_parameters_set_prohibited_interface_types(v11, v14);
  id v54 = 0u;
  uint64_t v55 = 0u;
  uint64_t v52 = 0u;
  id v53 = 0u;
  id v17 = self->_interfaces;
  uint64_t v18 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v17,  "countByEnumeratingWithState:objects:count:",  &v52,  v60,  16LL);
  if (v18)
  {
    id v19 = *(void *)v53;
    do
    {
      for (j = 0LL; j != v18; j = (char *)j + 1)
      {
        if (*(void *)v53 != v19) {
          objc_enumerationMutation(v17);
        }
        [*(id *)(*((void *)&v52 + 1) + 8 * (void)j) addToProhibited:v11];
      }

      uint64_t v18 = -[NSMutableArray countByEnumeratingWithState:objects:count:]( v17,  "countByEnumeratingWithState:objects:count:",  &v52,  v60,  16LL);
    }

    while (v18);
  }

  ifBringupPathEvaluator = self->_ifBringupPathEvaluator;
  if (ifBringupPathEvaluator) {
    nw_path_evaluator_cancel(ifBringupPathEvaluator, v21);
  }
  evaluator_for_endpoint = (OS_nw_path_evaluator *)nw_path_create_evaluator_for_endpoint(0LL, v11);
  uint64_t v24 = self->_ifBringupPathEvaluator;
  self->_ifBringupPathEvaluator = evaluator_for_endpoint;

  int v25 = (void *)nw_path_evaluator_copy_path(self->_ifBringupPathEvaluator);
  -[NRBabelInstance handleIfBringupPathUpdate:](self, "handleIfBringupPathUpdate:", v25);

  objc_initWeak(&v51, self);
  id v26 = self->_ifBringupPathEvaluator;
  queue = self->_queue;
  v49[0] = _NSConcreteStackBlock;
  v49[1] = 3221225472LL;
  v49[2] = sub_1000BFA64;
  v49[3] = &unk_1001AF8C0;
  objc_copyWeak(&v50, &v51);
  nw_path_evaluator_set_update_handler(v26, queue, v49);
  -[NRBabelInstance updateRoutes](self, "updateRoutes");
  objc_destroyWeak(&v50);
  objc_destroyWeak(&v51);
}

              id v28 = v151;
LABEL_51:
              id v27 = v155;
              goto LABEL_21;
            }
          }

          else
          {
            uint64_t v30 = v153;
            if (v31[3])
            {
              uint64_t v81 = sub_1000B07C8();
              id v82 = _NRLogIsLevelEnabled(v81, 16LL);

              if (v82)
              {
                int v45 = sub_1000B07C8();
                _NRLogWithArgs(v45, 16LL, "%s%.30s:%-4d Received invalid RouteReq with AE=0 and plen=%u");
                goto LABEL_132;
              }

              goto LABEL_50;
            }

            uint64_t v71 = 0;
            id v156 = 0;
            __int128 v157 = (in6_addr)0LL;
          }

          if ((sub_1000BF1F0((unsigned __int8 *)&v31[v71 + 4], v69 - v71) & 1) == 0) {
            -[NRBabelInstance handleRouteReqFromAddr:babelInterface:ForPrefix:plen:]( v30,  "handleRouteReqFromAddr:babelInterface:ForPrefix:plen:",  a5,  v15,  &v157,  v156);
          }
          goto LABEL_51;
        }

        uint64_t v140 = sub_1000B07C8();
        id v141 = _NRLogIsLevelEnabled(v140, 16LL);

        if (!v141) {
          goto LABEL_202;
        }
        uint64_t v124 = sub_1000B07C8();
        SEL v125 = @"RouteReq";
        _NRLogWithArgs( v124,  16LL,  "%s%.30s:%-4d insufficient TLV length %u < %u for type %@",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3809LL,  v34,  2LL,  @"RouteReq");
        break;
      case 10:
        if (v34 > 0xD)
        {
          int v74 = *((unsigned __int8 *)v31 + 2);
          if (v31[2])
          {
            if (v31[6])
            {
              uint64_t v75 = v34 - 14;
              id v156 = v31[3];
              id v76 = sub_1000BF4D0(&v157, v74, (void *)(v31 + 16), (int)v34 - 14, 0LL, 0LL, (unsigned __int8 *)&v156);
              if ((v76 & 0x80000000) == 0)
              {
                uint64_t v30 = v153;
                if ((sub_1000BF1F0((unsigned __int8 *)&v31[v76 + 16], v75 - v76) & 1) == 0)
                {
                  LOBYTE(v144) = v31[6];
                  -[NRBabelInstance handleSeqnoReqFromAddr:babelInterface:ForPrefix:plen:routerID:seqno:hopCount:]( v153,  "handleSeqnoReqFromAddr:babelInterface:ForPrefix:plen:routerID:seqno:hopCount:",  a5,  v15,  &v157,  v156,  *((void *)v31 + 1),  bswap32(*((unsigned __int16 *)v31 + 2)) >> 16,  v144);
                }

                goto LABEL_50;
              }

              int v102 = sub_1000B07C8();
              uint64_t v103 = _NRLogIsLevelEnabled(v102, 16LL);

              uint64_t v30 = v153;
              if (v103)
              {
                int v45 = sub_1000B07C8();
                _NRLogWithArgs( v45,  16LL,  "%s%.30s:%-4d %@failed to decompress SeqnoReq",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3824LL,  v153,  v145);
                goto LABEL_132;
              }
            }

            else
            {
              uint64_t v93 = sub_1000B07C8();
              id v94 = _NRLogIsLevelEnabled(v93, 16LL);

              uint64_t v30 = v153;
              if (v94)
              {
                int v45 = sub_1000B07C8();
                _NRLogWithArgs(v45, 16LL, "%s%.30s:%-4d Received invalid SeqnoReq with HopCount=0");
                goto LABEL_132;
              }
            }
          }

          else
          {
            id v83 = sub_1000B07C8();
            unsigned int v84 = _NRLogIsLevelEnabled(v83, 16LL);

            if (!v84) {
              goto LABEL_138;
            }
            uint64_t v85 = sub_1000B07C8();
            _NRLogWithArgs( v85,  16LL,  "%s%.30s:%-4d Received invalid SeqnoReq with AE=0",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3812);

            uint64_t v30 = v153;
          }

          goto LABEL_50;
        }

        id v142 = sub_1000B07C8();
        id v143 = _NRLogIsLevelEnabled(v142, 16LL);

        if (!v143) {
          goto LABEL_202;
        }
        uint64_t v124 = sub_1000B07C8();
        SEL v125 = @"SeqnoReq";
        _NRLogWithArgs( v124,  16LL,  "%s%.30s:%-4d insufficient TLV length %u < %u for type %@",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3837LL,  v34,  14LL,  @"SeqnoReq");
        break;
      default:
        goto LABEL_78;
    }

    uint64_t v30 = v153;
    goto LABEL_182;
  }

  if (qword_1001DC8B0 != -1) {
    dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC8A8, 16LL))
  {
    if (qword_1001DC8B0 != -1) {
      dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
    }
    uint64_t v124 = (id)qword_1001DC8A8;
    if (v32 >= 0x10) {
      SEL v125 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Unknown[%u]",  v32);
    }
    else {
      SEL v125 = off_1001AF1C0[v35];
    }
    int v147 = v34;
    uint64_t v30 = v153;
    _NRLogWithArgs( v124,  16LL,  "%s%.30s:%-4d %@TLV type %@ + len %u hanging off edge %u > %u",  "",  "-[NRBabelInstance handlePacket:length:remoteAddr:localAddr:babelInterface:dtls:]",  3594LL,  v153,  v125,  v147,  v29,  v151);
    goto LABEL_182;
  }

                    -[NRLink invalidateVirtualInterface](self, "invalidateVirtualInterface");
LABEL_51:

                    return 0;
                  }

                  id v59 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v22);
                  int v60 = _NRLogIsLevelEnabled(v59, 17LL);

                  if (!v60) {
                    goto LABEL_50;
                  }
                  id v48 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v61);
                  uint64_t v49 = -[NRLink copyDescription](self, "copyDescription");
                  _NRLogWithArgs(v48, 17LL, "%@: failed to add ClassD route", v49);
                }

                else
                {
                  id v56 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v19);
                  uint64_t v57 = _NRLogIsLevelEnabled(v56, 17LL);

                  if (!v57) {
                    goto LABEL_50;
                  }
                  id v48 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v58);
                  uint64_t v49 = -[NRLink copyDescription](self, "copyDescription");
                  _NRLogWithArgs(v48, 17LL, "%@: failed to add bogus IPv4 address", v49);
                }
              }

              else
              {
                id v53 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v18);
                id v54 = _NRLogIsLevelEnabled(v53, 17LL);

                if (!v54) {
                  goto LABEL_50;
                }
                id v48 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v55);
                uint64_t v49 = -[NRLink copyDescription](self, "copyDescription");
                _NRLogWithArgs(v48, 17LL, "%@: failed to add link-local address", v49);
              }
            }

            else
            {
              uint64_t v50 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v15);
              int v51 = _NRLogIsLevelEnabled(v50, 17LL);

              if (!v51) {
                goto LABEL_50;
              }
              id v48 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v52);
              uint64_t v49 = -[NRLink copyDescription](self, "copyDescription");
              _NRLogWithArgs(v48, 17LL, "%@: failed to add ClassC address", v49);
            }
          }

          else
          {
            int v45 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v12);
            int v46 = _NRLogIsLevelEnabled(v45, 17LL);

            if (!v46) {
              goto LABEL_50;
            }
            id v48 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v47);
            uint64_t v49 = -[NRLink copyDescription](self, "copyDescription");
            _NRLogWithArgs(v48, 17LL, "%@: failed to add ClassD address", v49);
          }

LABEL_57:
  -[NSMutableArray addObject:](v8, "addObject:", @"BatteryConditionsDeteriorated");
  if ((reason & 0x4000000000000000LL) != 0) {
LABEL_32:
  }
    -[NSMutableArray addObject:](v8, "addObject:", @"LinkSwitchFailure");
LABEL_33:
  if (-[NSMutableArray count](v8, "count")) {
    id v9 = (__CFString *)objc_claimAutoreleasedReturnValue(-[NSMutableArray componentsJoinedByString:](v8, "componentsJoinedByString:", @", "));
  }
  else {
    id v9 = @"<none>";
  }

  id v10 = -[NSString initWithFormat:]( v3,  "initWithFormat:",  @"[%@ %@ since:%.2f rate:%llu/hr]",  v5,  v9,  *(void *)&self->_timeSinceLastAdvice,  self->_rateOfAdvicePerHour);
  return v10;
}

          uint64_t v49 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v20);
          uint64_t v50 = _NRLogIsLevelEnabled(v49, 1LL);

          if (v50)
          {
            id v27 = (NSString *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v51);
            id v28 = [(id)a1 copyDescription];
            int v252 = v28;
            v254 = a2;
            v251 = 7960LL;
            uint64_t v52 = "%s%.30s:%-4d %@: Received unexpected notify code %u";
LABEL_59:
            id v53 = v27;
            id v54 = 1LL;
LABEL_60:
            _NRLogWithArgs( v53,  v54,  v52,  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  v251,  v252,  v254);
LABEL_61:

LABEL_62:
          }

    goto LABEL_37;
  }

  uint64_t v31 = sub_1000FBEC0();
  uint64_t v32 = _NRLogIsLevelEnabled(v31, 17LL);

  if (!v32) {
    goto LABEL_40;
  }
  id v8 = sub_1000FBEC0();
  _NRLogWithArgs(v8, 17LL, "%s called with null pipeManager");
LABEL_39:

LABEL_40:
}

          id v8 = (char *)v8 + 1;
        }

        while (v6 != v8);
        unsigned __int8 v6 = [v5 countByEnumeratingWithState:&v17 objects:v25 count:16];
      }

      while (v6);
    }
  }
}

              if (a3 == 3 && !v4)
              {
                v85[0] = _NSConcreteStackBlock;
                v85[1] = 3221225472LL;
                v85[2] = sub_100132A60;
                v85[3] = &unk_1001B05F0;
                id v82 = v12;
                uint64_t v86 = v82;
                int v92 = v84;
                uint64_t v87 = v9;
                uint64_t v93 = 3;
                id v91 = v10;
                id v88 = v11;
                uint64_t v89 = 0LL;
                uint64_t v90 = v5;
                sub_10012B7E0((char *)v82, v85);

                goto LABEL_61;
              }

void sub_1000666E0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v3 = WeakRetained;
  if (WeakRetained)
  {
    id v22 = WeakRetained;
    unsigned __int8 v4 = [WeakRetained cancelled];
    id v3 = v22;
    if ((v4 & 1) == 0)
    {
      id v5 = (void *)objc_claimAutoreleasedReturnValue([v22 aggregateStatsTimerSource]);
      unsigned __int8 v6 = *(void **)(a1 + 32);

      id v3 = v22;
      if (v5 == v6)
      {
        id v7 = [v22 totalReceivedUpdates];
        id v3 = v22;
        if (v7)
        {
          id v8 = objc_alloc_init(&OBJC_CLASS___NRAnalyticsALUAdviceAggregateStats);
          id v9 = [v22 totalReceivedUpdates];
          if (v8)
          {
            v8->_totalAdviceCount = (unint64_t)v9;
            v8->_totalAdviceCountForWiFuint64_t i = (unint64_t)[v22 totalCountForWiFiAdvice];
            v8->_totalAdviceCountForBTClassic = (unint64_t)[v22 totalCountForBTClassicAdvice];
          }

          else
          {
            [v22 totalCountForWiFiAdvice];
            [v22 totalCountForBTClassicAdvice];
          }

          [v22 totalDurationForWiFiAdvice];
          if (v10 > 0.0)
          {
            if ([v22 totalCountForWiFiAdvice])
            {
              [v22 totalDurationForWiFiAdvice];
              double v12 = v11;
              id v13 = [v22 totalCountForWiFiAdvice];
              if (v8) {
                v8->_avgDurationForWiFiAdvice = v12 / (double)(unint64_t)v13;
              }
            }
          }

          [v22 totalDurationForBTClassicAdvice];
          if (v14 > 0.0)
          {
            if ([v22 totalCountForBTClassicAdvice])
            {
              [v22 totalDurationForBTClassicAdvice];
              double v16 = v15;
              id v17 = [v22 totalCountForBTClassicAdvice];
              if (v8) {
                v8->_avgDurationForBTClassicAdvice = v16 / (double)(unint64_t)v17;
              }
            }
          }

          [v22 totalIntervalForNonDefaultAdvice];
          if (v18 > 0.0)
          {
            if ([v22 totalCountForNonDefaultAdvice])
            {
              [v22 totalIntervalForNonDefaultAdvice];
              double v20 = v19;
              id v21 = [v22 totalCountForNonDefaultAdvice];
              if (v8) {
                v8->_avgIntervalForNonDefaultAdvice = v20 / (double)(unint64_t)v21;
              }
            }
          }

          -[NRAnalyticsALUAdviceAggregateStats submit](v8, "submit");
          [v22 setTotalReceivedUpdates:0];
          [v22 setTotalCountForWiFiAdvice:0];
          [v22 setTotalDurationForWiFiAdvice:0.0];
          [v22 setTotalCountForBTClassicAdvice:0];
          [v22 setTotalDurationForBTClassicAdvice:0.0];
          [v22 setTotalCountForNonDefaultAdvice:0];
          [v22 setTotalIntervalForNonDefaultAdvice:0.0];

          id v3 = v22;
        }
      }
    }
  }
}

void sub_100066904(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v3 = WeakRetained;
  if (WeakRetained)
  {
    double v11 = WeakRetained;
    unsigned __int8 v4 = [WeakRetained cancelled];
    id v3 = v11;
    if ((v4 & 1) == 0)
    {
      id v5 = (void *)objc_claimAutoreleasedReturnValue([v11 wifiAdviceMonitorTimerSource]);
      unsigned __int8 v6 = *(void **)(a1 + 32);

      id v3 = v11;
      if (v5 == v6)
      {
        id v7 = -[NSString initWithFormat:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:",  @"Advice exceeds %u seconds");
        sub_1001030D0(@"NRAutoLinkUpgrade", @"WiFiAdvice", v7, 0, 0LL, v8, v9, v10, 1800LL);

        id v3 = v11;
      }
    }
  }
}

uint64_t sub_1000669BC(void *a1, char a2)
{
  if (!a1) {
    return 0LL;
  }
  v24.receiver = a1;
  v24.super_class = (Class)&OBJC_CLASS___NRLinkUpgradeReport;
  id v3 = objc_msgSendSuper2(&v24, "init");
  if (!v3)
  {
    id v18 = sub_100066C2C();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 16LL);

    p_class_meths = (__objc2_meth_list **)"-[NRLinkUpgradeReport initWithUpgradeType:]";
    if (IsLevelEnabled)
    {
      id v20 = sub_100066C2C();
      _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRLinkUpgradeReport initWithUpgradeType:]",  226);
    }

    uint64_t v4 = _os_log_pack_size(12LL);
    id v5 = (__objc2_class *)((char *)&v24 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL));
    id v21 = __error();
    uint64_t v22 = _os_log_pack_fill(v5, v4, *v21, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)uint64_t v22 = 136446210;
    *(void *)(v22 + 4) = "-[NRLinkUpgradeReport initWithUpgradeType:]";
    id v23 = sub_100066C2C();
    _NRLogAbortWithPack(v23, v5);
    goto LABEL_30;
  }

  uint64_t v4 = (uint64_t)v3;
  v3[8] = a2;
  id v5 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  if (qword_1001DC878 != -1) {
LABEL_30:
  }
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  id v7 = (id)qword_1001DC870;
  if (v7)
  {
    unsigned int v8 = v7[5];

    if (v8 >= 0x29) {
      char v9 = 50;
    }
    else {
      char v9 = 40;
    }
    if (v8 >= 0x1F) {
      char v10 = v9;
    }
    else {
      char v10 = 30;
    }
    if (v8 >= 0x15) {
      char v11 = v10;
    }
    else {
      char v11 = 20;
    }
    if (v8 >= 0xB) {
      char v12 = v11;
    }
    else {
      char v12 = 10;
    }
    if (!v8) {
      char v12 = 0;
    }
  }

  else
  {
    char v12 = 0;
  }

  *(_BYTE *)(v4 + 9) = v12;
  int v25 = 0;
  int v13 = IOPSGetPercentRemaining(&v25, 0LL, 0LL);
  char v14 = v25;
  if (v13) {
    char v14 = 0;
  }
  *(_BYTE *)(v4 + 10) = v14;
  objc_opt_self(&v5[54]);
  if (p_class_meths[271] != (__objc2_meth_list *)-1LL) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  double v15 = (unsigned __int8 *)(id)qword_1001DC870;
  if (v15)
  {
    int v16 = v15[11];

    if (v16) {
      *(_DWORD *)(v4 + 16) |= 0x20u;
    }
  }

  return v4;
}

id sub_100066C2C()
{
  if (qword_1001DC7F8 != -1) {
    dispatch_once(&qword_1001DC7F8, &stru_1001AEAE0);
  }
  return (id)qword_1001DC7F0;
}

void sub_100066C6C(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC7F0;
  qword_1001DC7F0 = (uint64_t)v1;
}

__CFString *sub_100066C9C(uint64_t a1)
{
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
  id v3 = v2;
  if ((a1 & 0x100) != 0)
  {
    -[NSMutableArray addObject:](v2, "addObject:", @"TxSml");
    if ((a1 & 0x200) == 0)
    {
LABEL_3:
      if ((a1 & 0x400) == 0) {
        goto LABEL_4;
      }
      goto LABEL_30;
    }
  }

  else if ((a1 & 0x200) == 0)
  {
    goto LABEL_3;
  }

  -[NSMutableArray addObject:](v3, "addObject:", @"TxMed");
  if ((a1 & 0x400) == 0)
  {
LABEL_4:
    if ((a1 & 0x4000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_31;
  }

LABEL_33:
  -[NSMutableArray addObject:](v3, "addObject:", @"RdPoor");
  if ((a1 & 0x80000) == 0)
  {
LABEL_8:
    if ((a1 & 0x100000) == 0) {
      goto LABEL_9;
    }
    goto LABEL_35;
  }

    uint64_t v61 = 0LL;
    goto LABEL_34;
  }

  uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v16 remoteIdentifier]);
  uint64_t v31 = [v30 identifierType];

  if (v31 != (id)11)
  {
    uint64_t v58 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v32);
    id v59 = _NRLogIsLevelEnabled(v58, 16LL);

    if (v59)
    {
      uint64_t v55 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v60);
      id v56 = -[NRLink copyDescription](self, "copyDescription");
      uint64_t v57 = (void *)objc_claimAutoreleasedReturnValue([v16 remoteIdentifier]);
      _NRLogWithArgs( v55,  16,  "%s%.30s:%-4d %@: Remote identifier has wrong type %zu",  "",  "-[NRLinkBluetooth requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  9250,  v56,  [v57 identifierType]);
      goto LABEL_32;
    }

    goto LABEL_33;
  }

  __int128 v157 = v17;
  id v33 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
  uint64_t v34 = (void *)objc_claimAutoreleasedReturnValue([v16 remoteIdentifier]);
  objc_super v35 = [v33 isEqual:v34];

  id v36 = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
  id v156 = v18;
  p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
  if ((v35 & 1) != 0) {
    goto LABEL_20;
  }
  uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
  if (qword_1001DCA68 != -1) {
    dispatch_once(&qword_1001DCA68, &stru_1001AFD30);
  }
  uint64_t v39 = (id)qword_1001DCA60;
  id v155 = v38;
  uint64_t v40 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
  if (qword_1001DCA78 != -1) {
    dispatch_once(&qword_1001DCA78, &stru_1001AFD50);
  }
  unsigned int v41 = (id)qword_1001DCA70;
  if ([v40 isEqual:v41])
  {

    uint64_t v38 = v155;
LABEL_19:

    id v36 = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
    goto LABEL_20;
  }

  __int128 v153 = v14;
  uint64_t v87 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
  id v88 = sub_10010B930();
  __int128 v154 = [v87 isEqual:v88];

  p_class_meths = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
  char v14 = v153;

  id v36 = (__objc2_meth_list **)(&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate + 32);
  if ((v154 & 1) == 0)
  {
    uint64_t v90 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v89);
    id v91 = _NRLogIsLevelEnabled(v90, 16LL);

    if (v91)
    {
      uint64_t v93 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v92);
      id v94 = -[NRLink copyDescription](self, "copyDescription");
      uint64_t v95 = (void *)objc_claimAutoreleasedReturnValue([v16 localIdentifier]);
      uint64_t v96 = (void *)objc_claimAutoreleasedReturnValue([v16 remoteIdentifier]);
      _NRLogWithArgs( v93,  16LL,  "%s%.30s:%-4d %@: Local identifier %@ does not match remote identifier %@",  "",  "-[NRLinkBluetooth requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  9260LL,  v94,  v95,  v96);
    }

    goto LABEL_71;
  }
}

    id v26 = 0LL;
    id v27 = v33;
    goto LABEL_34;
  }

  uint64_t v31 = sub_1000FBEC0();
  int IsLevelEnabled = _NRLogIsLevelEnabled(v31, 16LL);

  if (!IsLevelEnabled) {
    goto LABEL_33;
  }
  objc_super v24 = sub_1000FBEC0();
  _NRLogWithArgs( v24,  16LL,  "%s%.30s:%-4d Unexpectedly received child config %@",  "",  "-[NRDevicePairingCandidateContext requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBloc k:responseBlock:]",  1960LL,  v16);
LABEL_27:
  id v26 = 0LL;
  id v27 = v33;
LABEL_30:

LABEL_34:
  (*((void (**)(id, NEIKEv2SessionConfiguration *, void, void))v17 + 2))(v17, v26, 0LL, 0LL);
}

  uint64_t v58 = 0u;
  id v59 = 0u;
  id v56 = 0u;
  uint64_t v57 = 0u;
  int v51 = *(id *)(a1 + 104);
  uint64_t v52 = [v51 countByEnumeratingWithState:&v56 objects:v60 count:16];
  if (v52)
  {
    id v53 = v52;
    id v54 = *(void *)v57;
    do
    {
      for (uint64_t i = 0LL; i != v53; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v57 != v54) {
          objc_enumerationMutation(v51);
        }
        sub_10011439C( a1,  [*(id *)(*((void *)&v56 + 1) + 8 * (void)i) unsignedShortValue]);
      }

      id v53 = [v51 countByEnumeratingWithState:&v56 objects:v60 count:16];
    }

    while (v53);
  }
}

                  uint64_t v22 = (NSData *)objc_claimAutoreleasedReturnValue([v17 localInnerIPv6AddressBytesClassD]);

                  id v3 = v33;
                  goto LABEL_34;
                }

                if (qword_1001DCBD8 != -1) {
                  dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
                }
                if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
                {
                  if (qword_1001DCBD8 != -1) {
                    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
                  }
                  char v14 = (id)qword_1001DCBD0;
                  double v15 = (void *)objc_claimAutoreleasedReturnValue([v17 localInnerIPv6AddressBytesClassD]);
                  int v16 = (void *)createIPv6AddrStringFromData();
                  _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d ignoring invalid address from %@ : %@",  "",  "+[NRDLocalDevice createNewLocalClassDAddrData:]",  3715LL,  v17,  v16);
                }
              }
            }

            char v11 = [v9 countByEnumeratingWithState:&v36 objects:v41 count:16];
            if (v11) {
              continue;
            }
            break;
          }
        }

        sub_10012E200(v7, &v40);
        id v3 = v33;
      }

      else
      {
        HIBYTE(v40) = 1;
      }

      uint64_t v22 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v40, 16LL);
LABEL_34:
      [v2 setLocalInnerIPv6AddressBytesClassD:v22];

      id v26 = objc_opt_self(&OBJC_CLASS___NRDLocalDevice);
      sub_100128908(v26);
      if (qword_1001DCBD8 != -1) {
        dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCBD0, 0LL))
      {
        if (qword_1001DCBD8 != -1) {
          dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
        }
        id v27 = (id)qword_1001DCBD0;
        id v28 = (void *)objc_claimAutoreleasedReturnValue([v2 localInnerIPv6AddressBytesClassD]);
        uint64_t v29 = (void *)createIPv6AddrStringFromData();
        _NRLogWithArgs( v27,  0LL,  "%s%.30s:%-4d Generated new local classD inner address %@ for %@",  "",  "-[NRDLocalDevice copyLocalClassDInnerEndpointWithPort:]",  3854LL,  v29,  v2);
      }
    }

    uint64_t v30 = (void *)objc_claimAutoreleasedReturnValue([v2 localInnerIPv6AddressBytesClassD]);
    uint64_t v31 = sub_10012D958((uint64_t)&OBJC_CLASS___NRDLocalDevice, v30, v3);
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue(v31);
  }

  return v2;
}

id *sub_100066F40(id *a1, void *a2, void *a3)
{
  id v6 = a2;
  id v7 = a3;
  if (a1)
  {
    v20.receiver = a1;
    v20.super_class = (Class)&OBJC_CLASS___NRAutoLinkUpgradeMonitor;
    unsigned int v8 = (id *)objc_msgSendSuper2(&v20, "init");
    if (!v8)
    {
      id v11 = sub_100066C2C();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 16LL);

      if (IsLevelEnabled)
      {
        id v13 = sub_100066C2C();
        _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRAutoLinkUpgradeMonitor initWithQueue:nrUUID:]",  379);
      }

      uint64_t v14 = _os_log_pack_size(12LL);
      double v15 = (char *)&v19 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      int v16 = __error();
      uint64_t v17 = _os_log_pack_fill(v15, v14, *v16, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v17 = 136446210;
      *(void *)(v17 + 4) = "-[NRAutoLinkUpgradeMonitor initWithQueue:nrUUID:]";
      id v18 = sub_100066C2C();
      _NRLogAbortWithPack(v18, v15);
    }

    a1 = v8;
    do
      unint64_t v9 = __ldxr(&qword_1001DBC60);
    while (__stxr(v9 + 1, &qword_1001DBC60));
    v8[4] = (id)v9;
    objc_storeStrong(v8 + 5, a2);
    objc_storeStrong(a1 + 2, a3);
    [a1 reportEvent:30001];
  }

  return a1;
}

void sub_1000670E8(void *a1, void *a2)
{
  id v12 = a2;
  if (a1)
  {
    if ([a1 cancelled])
    {
      uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(a1[2], v3);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 2LL);

      if (IsLevelEnabled)
      {
        id v7 = (void *)_NRCopyLogObjectForNRUUID(a1[2], v6);
        _NRLogWithArgs( v7,  2LL,  "%s%.30s:%-4d %@: cancelled, ignoring request",  "",  "-[NRAutoLinkUpgradeMonitor reportWiFiAdviceUpgraded:forAdviceID:]",  495LL,  a1);
LABEL_8:
      }
    }

    else
    {
      if (![a1 hasReportedUpgradeStatusToSymptoms])
      {
        [a1 setHasReportedUpgradeStatusToSymptoms:1];
        goto LABEL_10;
      }

      unint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(a1[2], v8);
      int v10 = _NRLogIsLevelEnabled(v9, 1LL);

      if (v10)
      {
        id v7 = (void *)_NRCopyLogObjectForNRUUID(a1[2], v11);
        _NRLogWithArgs( v7,  1LL,  "%s%.30s:%-4d %@: already reported upgrade status, returning",  "",  "-[NRAutoLinkUpgradeMonitor reportWiFiAdviceUpgraded:forAdviceID:]",  500LL,  a1);
        goto LABEL_8;
      }
    }
  }

void sub_1000675AC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3) {
    uint64_t v4 = *(void *)(v3 + 32);
  }
  else {
    uint64_t v4 = 0LL;
  }
  id v5 = (void *)_NRCopyLogObjectForNRUUID(v4, a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 17LL);

  if (IsLevelEnabled)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      uint64_t v9 = *(void *)(v8 + 32);
    }
    else {
      uint64_t v9 = 0LL;
    }
    id v10 = (id)_NRCopyLogObjectForNRUUID(v9, v7);
    _NRLogWithArgs(v10, 17LL, "Unexpected un-assert received");
  }

void sub_10006764C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3) {
    uint64_t v4 = *(void *)(v3 + 32);
  }
  else {
    uint64_t v4 = 0LL;
  }
  id v5 = (void *)_NRCopyLogObjectForNRUUID(v4, a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 17LL);

  if (IsLevelEnabled)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      uint64_t v9 = *(void *)(v8 + 32);
    }
    else {
      uint64_t v9 = 0LL;
    }
    id v10 = (id)_NRCopyLogObjectForNRUUID(v9, v7);
    _NRLogWithArgs(v10, 17LL, "Unexpected assert received");
  }

id *sub_10006776C(id *a1, void *a2, void *a3)
{
  id v6 = a2;
  id v7 = a3;
  uint64_t v8 = v7;
  if (a1)
  {
    if (v6)
    {
      if (v7)
      {
        v52.receiver = a1;
        v52.super_class = (Class)&OBJC_CLASS___NRCompanionLinkViabilityAgent;
        uint64_t v9 = (id *)objc_msgSendSuper2(&v52, "init");
        if (v9)
        {
          id v10 = v9;
          objc_storeStrong(v9 + 5, a3);
          objc_storeStrong(v10 + 4, a2);
          uint64_t v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
          [v10 setAgentUUID:v11];

          [v10 setAgentDescription:@"Companion link viability netagent"];
          id v12 = objc_alloc(&OBJC_CLASS___NSString);
          id v13 = (void *)objc_claimAutoreleasedReturnValue([v10 agentUUID]);
          uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue([v13 UUIDString]);
          double v15 = -[NSString initWithFormat:](v12, "initWithFormat:", @"NRCompanionLinkViabilityAgent-%@", v14);
          id v16 = v10[7];
          v10[7] = v15;

          uint64_t v17 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v10[4]);
          if (v17)
          {
            id v18 = v17;
            uint64_t v19 = -[NSString initWithFormat:](objc_alloc(&OBJC_CLASS___NSString), "initWithFormat:", @"%@", v17);
            id v20 = v10[8];
            v10[8] = v19;

            id v21 = v10[4];
            id v22 = v10[8];
            id v23 = v21;
            objc_super v24 = (void *)objc_claimAutoreleasedReturnValue([v10 agentUUID]);
            int v25 = (void *)objc_claimAutoreleasedReturnValue([v24 UUIDString]);
            sub_10011BB18(v23, 19001, v22, v25);

            a1 = v10;
            goto LABEL_7;
          }

          id v44 = sub_100067C1C();
          int IsLevelEnabled = _NRLogIsLevelEnabled(v44, 16LL);

          if (IsLevelEnabled)
          {
            id v46 = sub_100067C1C();
            _NRLogWithArgs( v46,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRCompanionLinkViabilityAgent initWithNRUUID:queue:]",  54);
          }

          uint64_t v47 = _os_log_pack_size(12LL);
          uint64_t v31 = (char *)&v51 - ((v47 + 15) & 0xFFFFFFFFFFFFFFF0LL);
          id v48 = __error();
          uint64_t v49 = _os_log_pack_fill( v31,  v47,  *v48,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
          *(_DWORD *)uint64_t v49 = 136446210;
          *(void *)(v49 + 4) = "-[NRCompanionLinkViabilityAgent initWithNRUUID:queue:]";
LABEL_21:
          id v50 = sub_100067C1C();
          _NRLogAbortWithPack(v50, v31);
        }

        id v39 = sub_100067C1C();
        int v40 = _NRLogIsLevelEnabled(v39, 16LL);

        if (v40)
        {
          id v41 = sub_100067C1C();
          _NRLogWithArgs( v41,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRCompanionLinkViabilityAgent initWithNRUUID:queue:]",  43);
        }

        uint64_t v42 = _os_log_pack_size(12LL);
        uint64_t v31 = (char *)&v51 - ((v42 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v43 = *__error();
        uint64_t v33 = _os_log_pack_fill(v31, v42, v43, &_mh_execute_header, "%{public}s [super init] failed");
      }

      else
      {
        id v34 = sub_100067C1C();
        int v35 = _NRLogIsLevelEnabled(v34, 16LL);

        if (v35)
        {
          id v36 = sub_100067C1C();
          _NRLogWithArgs( v36,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (queue) != ((void *)0)",  "",  "-[NRCompanionLinkViabilityAgent initWithNRUUID:queue:]",  41);
        }

        uint64_t v37 = _os_log_pack_size(12LL);
        uint64_t v31 = (char *)&v51 - ((v37 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v38 = *__error();
        uint64_t v33 = _os_log_pack_fill( v31,  v37,  v38,  &_mh_execute_header,  "%{public}s Assertion Failed: (queue) != ((void *)0)");
      }
    }

    else
    {
      id v27 = sub_100067C1C();
      int v28 = _NRLogIsLevelEnabled(v27, 16LL);

      if (v28)
      {
        id v29 = sub_100067C1C();
        _NRLogWithArgs( v29,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (nrUUID) != ((void *)0)",  "",  "-[NRCompanionLinkViabilityAgent initWithNRUUID:queue:]",  40);
      }

      uint64_t v30 = _os_log_pack_size(12LL);
      uint64_t v31 = (char *)&v51 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v32 = *__error();
      uint64_t v33 = _os_log_pack_fill( v31,  v30,  v32,  &_mh_execute_header,  "%{public}s Assertion Failed: (nrUUID) != ((void *)0)");
    }

    *(_DWORD *)uint64_t v33 = 136446210;
    *(void *)(v33 + 4) = "-[NRCompanionLinkViabilityAgent initWithNRUUID:queue:]";
    goto LABEL_21;
  }

id sub_100067C1C()
{
  if (qword_1001DC808 != -1) {
    dispatch_once(&qword_1001DC808, &stru_1001AEB00);
  }
  return (id)qword_1001DC800;
}

void sub_100067C5C(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC800;
  qword_1001DC800 = (uint64_t)v1;
}

void sub_100067C8C(uint64_t a1)
{
  if (a1)
  {
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 40));
    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v2 = (id)qword_1001DCB58;
    sub_10012114C((uint64_t)v2, *(void **)(a1 + 56));

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    id v3 = (id)qword_1001DCB58;
    uint64_t v4 = (id *)v3;
    if (v3)
    {
      dispatch_assert_queue_V2(*((dispatch_queue_t *)v3 + 1));
      if (([v4[2] apply] & 1) == 0) {
        sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v5,  v6,  v7,  v20);
      }
    }

    uint64_t v8 = *(void **)(a1 + 48);
    if (v8)
    {
      if (([v8 unregisterNetworkAgent] & 1) == 0)
      {
        id v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v9);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 17LL);

        if (IsLevelEnabled)
        {
          id v13 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v12);
          _NRLogWithArgs(v13, 17LL, "Failed to unregister CompanionLinkViability agent");
        }
      }

      uint64_t v14 = *(void **)(a1 + 48);
      *(void *)(a1 + 4_Block_object_dispose((const void *)(v1 + 128), 8) = 0LL;

      double v15 = *(void **)(a1 + 32);
      id v16 = *(id *)(a1 + 64);
      id v17 = v15;
      id v18 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 agentUUID]);
      uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v18 UUIDString]);
      sub_10011BB18(v17, 19003, v16, v19);
    }

    *(_BYTE *)(a1 + 14) = 0;
  }

void sub_100068158(uint64_t a1)
{
  uint64_t v2 = objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) objectForKeyedSubscript:NWNetworkAgentStartOptionClientUUID]);
  id v36 = (id)v2;
  if (!v2)
  {
    if (qword_1001DC818 != -1) {
      dispatch_once(&qword_1001DC818, &stru_1001AEB48);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC810, 17LL))
    {
      if (qword_1001DC818 != -1) {
        dispatch_once(&qword_1001DC818, &stru_1001AEB48);
      }
      _NRLogWithArgs(qword_1001DC810, 17LL, "Unassert message did not contain client UUID");
    }

    goto LABEL_73;
  }

  uint64_t v3 = v2;
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4) {
    uint64_t v5 = *(void **)(v4 + 56);
  }
  else {
    uint64_t v5 = 0LL;
  }
  uint64_t v6 = *(void *)(a1 + 40);
  if (v6) {
    uint64_t v7 = *(void **)(v6 + 56);
  }
  else {
    uint64_t v7 = 0LL;
  }
  if (![v7 count])
  {
    if (qword_1001DC818 != -1) {
      dispatch_once(&qword_1001DC818, &stru_1001AEB48);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC810, 17LL))
    {
      if (qword_1001DC818 != -1) {
        dispatch_once(&qword_1001DC818, &stru_1001AEB48);
      }
      _NRLogWithArgs(qword_1001DC810, 17LL, "Unexpected agent unassert received");
    }

    goto LABEL_73;
  }

  uint64_t v8 = *(void *)(a1 + 40);
  if (v8) {
    uint64_t v9 = *(void **)(v8 + 56);
  }
  else {
    uint64_t v9 = 0LL;
  }
  [v9 removeObject:v36];
  uint64_t v10 = *(void *)(a1 + 40);
  if (v10)
  {
    uint64_t v11 = *(void **)(v10 + 64);
    if (v11) {
      [v11 removeObjectForKey:v36];
    }
  }

  if (qword_1001DC818 != -1) {
    dispatch_once(&qword_1001DC818, &stru_1001AEB48);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC810, 1LL))
  {
    if (qword_1001DC818 != -1) {
      dispatch_once(&qword_1001DC818, &stru_1001AEB48);
    }
    id v12 = (id)qword_1001DC810;
    uint64_t v13 = *(void *)(a1 + 40);
    if (v13)
    {
      id v14 = *(id *)(v13 + 64);
      uint64_t v13 = *(void *)(a1 + 40);
      if (v14)
      {
        double v15 = v14;
        if (v13) {
          uint64_t v13 = *(void *)(v13 + 64);
        }
        _NRLogWithArgs( v12,  1LL,  "%s%.30s:%-4d Direct to cloud request went away. Remaining clients: %@",  "",  "-[NRDirectToCloudAgent unassertAgentWithOptions:]_block_invoke",  274LL,  v13);

        goto LABEL_38;
      }

      if (v13) {
        uint64_t v13 = *(void *)(v13 + 56);
      }
    }

    _NRLogWithArgs( v12,  1LL,  "%s%.30s:%-4d Direct to cloud request went away. Remaining clients: %@",  "",  "-[NRDirectToCloudAgent unassertAgentWithOptions:]_block_invoke",  274LL,  v13);
LABEL_38:
  }

  uint64_t v16 = *(void *)(a1 + 40);
  if (v16)
  {
    if ([*(id *)(v16 + 56) count])
    {
LABEL_41:
      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      id v17 = (id)qword_1001DC870;
      id v18 = v17;
      if (v17) {
        uint64_t v19 = (void *)*((void *)v17 + 6);
      }
      else {
        uint64_t v19 = 0LL;
      }
      uint64_t v20 = v19;
      id v21 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) agentUUID]);
      uint64_t v22 = *(void *)(a1 + 40);
      if (v22) {
        id v23 = *(void **)(v22 + 64);
      }
      else {
        id v23 = 0LL;
      }
      objc_super v24 = (void *)objc_claimAutoreleasedReturnValue([v23 allValues]);
      sub_1001424C8(v20, 64LL, v21, v24);

      goto LABEL_73;
    }
  }

  else if ([0 count])
  {
    goto LABEL_41;
  }

  if (qword_1001DC818 != -1) {
    dispatch_once(&qword_1001DC818, &stru_1001AEB48);
  }
  if (_NRLogIsLevelEnabled(qword_1001DC810, 0LL))
  {
    if (qword_1001DC818 != -1) {
      dispatch_once(&qword_1001DC818, &stru_1001AEB48);
    }
    _NRLogWithArgs( qword_1001DC810,  0LL,  "%s%.30s:%-4d Direct To Cloud requests went away",  "",  "-[NRDirectToCloudAgent unassertAgentWithOptions:]_block_invoke",  276);
  }

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v25 = (id)qword_1001DC870;
  id v26 = v25;
  if (v25) {
    id v27 = (void *)*((void *)v25 + 6);
  }
  else {
    id v27 = 0LL;
  }
  id v28 = v27;
  sub_100142640((uint64_t)v28, 0);

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v29 = (id)qword_1001DC870;
  uint64_t v30 = v29;
  if (v29) {
    uint64_t v31 = (void *)*((void *)v29 + 6);
  }
  else {
    uint64_t v31 = 0LL;
  }
  uint64_t v32 = v31;
  uint64_t v33 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) agentUUID]);
  sub_100142404(v32, v33);

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v34 = (id)qword_1001DC870;
  [v34 directToCloudRequestUnavailable];

  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v35 = (id)qword_1001DC870;
  if (v35) {
    sub_10011BB18(0LL, 14005, 0LL, 0LL);
  }

LABEL_73:
}

void sub_1000686DC(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  uint64_t v2 = (void *)qword_1001DC810;
  qword_1001DC810 = (uint64_t)v1;
}

void sub_10006870C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = *(id *)(a1 + 40);
  if (!v2) {
    goto LABEL_54;
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 32));
  uint64_t v4 = objc_claimAutoreleasedReturnValue([v3 objectForKeyedSubscript:NWNetworkAgentStartOptionClientUUID]);
  if (!v4)
  {
    if (qword_1001DC818 != -1) {
      dispatch_once(&qword_1001DC818, &stru_1001AEB48);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC810, 17LL))
    {
      if (qword_1001DC818 != -1) {
        dispatch_once(&qword_1001DC818, &stru_1001AEB48);
      }
      _NRLogWithArgs(qword_1001DC810, 17LL, "no client UUID");
    }

    goto LABEL_54;
  }

  uint64_t v5 = (void *)v4;
  if ([*(id *)(v2 + 56) containsObject:v4])
  {

    goto LABEL_5;
  }

  uint64_t v43 = 0LL;
  id v44 = &v43;
  uint64_t v45 = 0x2020000000LL;
  char v46 = 0;
  id v25 = (void *)objc_claimAutoreleasedReturnValue(+[NWPath pathForClientID:](&OBJC_CLASS___NWPath, "pathForClientID:", v5));
  id v26 = (void *)objc_claimAutoreleasedReturnValue([v25 parameters]);
  id v27 = [v26 copyCParameters];

  if (!v27)
  {
LABEL_53:

    _Block_object_dispose(&v43, 8);
LABEL_54:

    return;
  }

  id v28 = (void *)nw_parameters_copy_avoided_netagent_types(v27);
  id v29 = v28;
  if (!v28)
  {

    goto LABEL_53;
  }

  applier[0] = _NSConcreteStackBlock;
  applier[1] = 3221225472LL;
  applier[2] = sub_100068D84;
  applier[3] = &unk_1001AEB28;
  void applier[4] = &v43;
  xpc_array_apply(v28, applier);
  if (*((_BYTE *)v44 + 24))
  {
    id v30 = *(id *)(v2 + 56);
    [v30 addObject:v5];

    if (_NRIsAppleInternal(v31))
    {
      if (!*(void *)(v2 + 64))
      {
        uint64_t v32 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
        uint64_t v33 = *(void **)(v2 + 64);
        *(void *)(v2 + 64) = v32;
      }

      uint64_t pid = nw_parameters_get_pid(v27);
      id v35 = sub_10010393C(pid, 0);
      id v36 = (void *)objc_claimAutoreleasedReturnValue([v25 effectiveRemoteEndpoint]);

      if (v36)
      {
        uint64_t v37 = -[NSMutableString initWithString:](objc_alloc(&OBJC_CLASS___NSMutableString), "initWithString:", v35);
        uint64_t v38 = (void *)objc_claimAutoreleasedReturnValue([v25 effectiveRemoteEndpoint]);
        -[NSMutableString appendFormat:](v37, "appendFormat:", @" (%@)", v38);
      }

      else
      {
        uint64_t v37 = (NSMutableString *)v35;
      }

      id v39 = *(id *)(v2 + 64);
      [v39 setObject:v37 forKeyedSubscript:v5];
    }
  }

  int v40 = *((unsigned __int8 *)v44 + 24);

  _Block_object_dispose(&v43, 8);
  if (v40)
  {
LABEL_5:
    uint64_t v6 = *(void *)(a1 + 32);
    if (v6) {
      uint64_t v7 = *(void **)(v6 + 56);
    }
    else {
      uint64_t v7 = 0LL;
    }
    if ([v7 count] == (id)1)
    {
      if (qword_1001DC818 != -1) {
        dispatch_once(&qword_1001DC818, &stru_1001AEB48);
      }
      if (_NRLogIsLevelEnabled(qword_1001DC810, 0LL))
      {
        if (qword_1001DC818 != -1) {
          dispatch_once(&qword_1001DC818, &stru_1001AEB48);
        }
        _NRLogWithArgs( qword_1001DC810,  0LL,  "%s%.30s:%-4d Direct To Cloud request received",  "",  "-[NRDirectToCloudAgent assertAgentWithOptions:]_block_invoke",  235);
      }

      objc_opt_self(&OBJC_CLASS___NRLinkDirector);
      if (qword_1001DC878 != -1) {
        dispatch_once(&qword_1001DC878, &stru_1001AEED0);
      }
      id v8 = (id)qword_1001DC870;
      uint64_t v9 = v8;
      if (v8) {
        uint64_t v10 = (void *)*((void *)v8 + 6);
      }
      else {
        uint64_t v10 = 0LL;
      }
      id v11 = v10;
      sub_100142640((uint64_t)v11, 1);
    }

    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v12 = (id)qword_1001DC870;
    uint64_t v13 = v12;
    if (v12) {
      id v14 = (void *)*((void *)v12 + 6);
    }
    else {
      id v14 = 0LL;
    }
    double v15 = v14;
    uint64_t v16 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) agentUUID]);
    uint64_t v17 = *(void *)(a1 + 32);
    if (v17) {
      id v18 = *(void **)(v17 + 64);
    }
    else {
      id v18 = 0LL;
    }
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue([v18 allValues]);
    sub_1001424C8(v15, 64LL, v16, v19);

    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v20 = (id)qword_1001DC870;
    [v20 directToCloudRequestAvailable];

    if (qword_1001DC818 != -1) {
      dispatch_once(&qword_1001DC818, &stru_1001AEB48);
    }
    if (qword_1001DC818 != -1) {
      dispatch_once(&qword_1001DC818, &stru_1001AEB48);
    }
    id v21 = (id)qword_1001DC810;
    uint64_t v22 = *(void *)(a1 + 32);
    if (v22)
    {
      id v23 = *(id *)(v22 + 64);
      uint64_t v22 = *(void *)(a1 + 32);
      if (v23)
      {
        objc_super v24 = v23;
        if (v22) {
          uint64_t v22 = *(void *)(v22 + 64);
        }
        _NRLogWithArgs( v21,  1LL,  "%s%.30s:%-4d Direct To Cloud clients: %@",  "",  "-[NRDirectToCloudAgent assertAgentWithOptions:]_block_invoke",  245LL,  v22);

        goto LABEL_58;
      }

      if (v22) {
        uint64_t v22 = *(void *)(v22 + 56);
      }
    }

    _NRLogWithArgs( v21,  1LL,  "%s%.30s:%-4d Direct To Cloud clients: %@",  "",  "-[NRDirectToCloudAgent assertAgentWithOptions:]_block_invoke",  245LL,  v22);
LABEL_58:

LABEL_59:
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v41 = (id)qword_1001DC870;
    if (v41) {
      sub_10011BB18(0LL, 14004, 0LL, 0LL);
    }
  }

void sub_100068D58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t sub_100068D84(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(v4);
    uint64_t v5 = 1LL;
    if (!strcmp("CompanionProxy", string_ptr))
    {
      *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
      uint64_t v5 = 0LL;
    }
  }

  else
  {
    uint64_t v5 = 1LL;
  }

  return v5;
}

uint64_t sub_100068E04(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (!*(_BYTE *)(result + 14)) {
      return 1LL;
    }
    if (qword_1001DC818 != -1) {
      dispatch_once(&qword_1001DC818, &stru_1001AEB48);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC810, 0LL))
    {
      if (qword_1001DC818 != -1) {
        dispatch_once(&qword_1001DC818, &stru_1001AEB48);
      }
      id v2 = (id)qword_1001DC810;
      id v3 = (void *)objc_claimAutoreleasedReturnValue([(id)v1 agentDescription]);
      _NRLogWithArgs( v2,  0LL,  "%s%.30s:%-4d unregisterAgent: %@",  "",  "-[NRDirectToCloudAgent invalidateAgent]",  139LL,  v3);
    }

    [(id)v1 setActive:0];
    uint64_t v4 = *(void *)(v1 + 48);
    id v5 = *(id *)(v1 + 40);
    [v5 removeNetworkAgentFromInterfaceNamed:v4];

    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v6 = (id)qword_1001DC870;
    uint64_t v7 = v6;
    if (v6) {
      id v8 = (void *)*((void *)v6 + 6);
    }
    else {
      id v8 = 0LL;
    }
    id v9 = v8;
    sub_100142640((uint64_t)v9, 0);

    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v10 = (id)qword_1001DC870;
    id v11 = v10;
    if (v10) {
      id v12 = (void *)*((void *)v10 + 6);
    }
    else {
      id v12 = 0LL;
    }
    uint64_t v13 = v12;
    id v14 = (void *)objc_claimAutoreleasedReturnValue([(id)v1 agentUUID]);
    sub_100142404(v13, v14);

    if ([*(id *)(v1 + 40) unregisterNetworkAgent])
    {
      *(_BYTE *)(v1 + 14) = 0;
      double v15 = *(void **)(v1 + 40);
      *(void *)(v1 + 40) = 0LL;

      uint64_t v16 = *(void **)(v1 + 56);
      *(void *)(v1 + 56) = 0LL;

      sub_10011BB18(0LL, 14003, 0LL, 0LL);
      return 1LL;
    }

    if (qword_1001DC818 != -1) {
      dispatch_once(&qword_1001DC818, &stru_1001AEB48);
    }
    uint64_t result = _NRLogIsLevelEnabled(qword_1001DC810, 17LL);
    if ((_DWORD)result)
    {
      if (qword_1001DC818 != -1) {
        dispatch_once(&qword_1001DC818, &stru_1001AEB48);
      }
      _NRLogWithArgs(qword_1001DC810, 17LL, "unable to unregister agent");
      return 0LL;
    }
  }

  return result;
}

id *sub_10006913C(id *a1, void *a2)
{
  uint64_t v4 = a2;
  if (a1)
  {
    v26.receiver = a1;
    v26.super_class = (Class)&OBJC_CLASS___NRDirectToCloudAgent;
    id v5 = (id *)objc_msgSendSuper2(&v26, "init");
    if (v5)
    {
      if (v4)
      {
        a1 = v5;
        dispatch_assert_queue_V2(v4);
        [a1 setActive:0];
        [a1 setKernelActivated:1];
        [a1 setUserActivated:1];
        [a1 setVoluntary:1];
        [a1 setNetworkProvider:0];
        [a1 setSpecificUseOnly:0];
        id v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSUUID UUID](&OBJC_CLASS___NSUUID, "UUID"));
        [a1 setAgentUUID:v6];

        uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithFormat:]( &OBJC_CLASS___NSString,  "stringWithFormat:",  @"Direct-To-Cloud agent"));
        [a1 setAgentDescription:v7];

        objc_storeStrong(a1 + 4, a2);
        id v8 = objc_alloc_init(&OBJC_CLASS___NSMutableSet);
        id v9 = a1[7];
        a1[7] = v8;

        goto LABEL_5;
      }

      id v18 = sub_100069410();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v18, 16LL);

      if (IsLevelEnabled)
      {
        id v20 = sub_100069410();
        _NRLogWithArgs( v20,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: queue",  "",  "-[NRDirectToCloudAgent initWithQueue:]",  49);
      }

      uint64_t v21 = _os_log_pack_size(12LL);
      double v15 = (char *)&v25 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v22 = __error();
      uint64_t v23 = _os_log_pack_fill(v15, v21, *v22, &_mh_execute_header, "%{public}s Assertion Failed: queue");
      *(_DWORD *)uint64_t v23 = 136446210;
      *(void *)(v23 + 4) = "-[NRDirectToCloudAgent initWithQueue:]";
    }

    else
    {
      id v11 = sub_100069410();
      int v12 = _NRLogIsLevelEnabled(v11, 16LL);

      if (v12)
      {
        id v13 = sub_100069410();
        _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDirectToCloudAgent initWithQueue:]",  48);
      }

      uint64_t v14 = _os_log_pack_size(12LL);
      double v15 = (char *)&v25 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v16 = __error();
      uint64_t v17 = _os_log_pack_fill(v15, v14, *v16, &_mh_execute_header, "%{public}s [super init] failed");
      *(_DWORD *)uint64_t v17 = 136446210;
      *(void *)(v17 + 4) = "-[NRDirectToCloudAgent initWithQueue:]";
    }

    id v24 = sub_100069410();
    _NRLogAbortWithPack(v24, v15);
  }

LABEL_5:
  return a1;
}
  }

  if (qword_1001DC8B0 != -1) {
    dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
  }
  id v5 = 1LL;
  if (_NRLogIsLevelEnabled(qword_1001DC8A8, 1LL))
  {
    if (qword_1001DC8B0 != -1) {
      dispatch_once(&qword_1001DC8B0, &stru_1001AF1A0);
    }
    _NRLogWithArgs( qword_1001DC8A8,  1LL,  "%s%.30s:%-4d Found unknown mandatory Sub-TLV %u",  "",  "nrBabelTLVHasUnknownMandatoryTLV",  2363,  v4);
  }

  return v5;
}

  return a1;
}

  return a1;
}
}
}
}

  return v5;
}
      }

      id v6 = [v4 countByEnumeratingWithState:&v15 objects:v19 count:16];
    }

    while (v6);
  }

  return v3;
}

id sub_100069410()
{
  if (qword_1001DC818 != -1) {
    dispatch_once(&qword_1001DC818, &stru_1001AEB48);
  }
  return (id)qword_1001DC810;
}

LABEL_115:
                          v170 = sub_100070554();
                          id v141 = _NRLogAbortWithPack(v170, v6);
LABEL_116:
                          id v171 = _NRLogIsLevelEnabled(v141, 2LL);

                          if (v171)
                          {
                            uint64_t v173 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v172);
                            v174 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v173,  2LL,  "%s%.30s:%-4d %@: Link Channel RX_SLOTS = %llu",  "",  "-[NRLinkBluetooth start]",  1218LL,  v174,  __memptr[0]);
                          }

                          __memptr[0] = 0LL;
                          id v175 = os_channel_attr_get(v376, 4LL, __memptr);
                          uint64_t v177 = _NRCopyLogObjectForNRUUID(v6->super._nrUUID, v176);
                          uint64_t v178 = (void *)v177;
                          if ((_DWORD)v175)
                          {
                            v179 = _NRLogIsLevelEnabled(v177, 17LL);

                            if (!v179) {
                              goto LABEL_200;
                            }
                            uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v180);
                            id v82 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs(v81, 17LL, "%@: os_channel_attr_get(SLOT_BUF_SIZE) returned %d", v82, v175);
                            goto LABEL_199;
                          }

                          uint64_t v181 = _NRLogIsLevelEnabled(v177, 2LL);

                          if (v181)
                          {
                            id v183 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v182);
                            int v184 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v183,  2LL,  "%s%.30s:%-4d %@: Link Channel SLOT_BUF_SIZE = %llu",  "",  "-[NRLinkBluetooth start]",  1219LL,  v184,  __memptr[0]);
                          }

                          __memptr[0] = 0LL;
                          uint64_t v185 = os_channel_attr_get(v376, 5LL, __memptr);
                          id v187 = _NRCopyLogObjectForNRUUID(v6->super._nrUUID, v186);
                          uint64_t v188 = (void *)v187;
                          if ((_DWORD)v185)
                          {
                            uint64_t v189 = _NRLogIsLevelEnabled(v187, 17LL);

                            if (!v189) {
                              goto LABEL_200;
                            }
                            uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v190);
                            id v82 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs(v81, 17LL, "%@: os_channel_attr_get(SLOT_META_SIZE) returned %d", v82, v185);
                            goto LABEL_199;
                          }

                          v191 = _NRLogIsLevelEnabled(v187, 2LL);

                          if (v191)
                          {
                            uint64_t v193 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v192);
                            v194 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v193,  2LL,  "%s%.30s:%-4d %@: Link Channel SLOT_META_SIZE = %llu",  "",  "-[NRLinkBluetooth start]",  1220LL,  v194,  __memptr[0]);
                          }

                          __memptr[0] = 0LL;
                          id v195 = os_channel_attr_get(v376, 6LL, __memptr);
                          uint64_t v197 = _NRCopyLogObjectForNRUUID(v6->super._nrUUID, v196);
                          v198 = (void *)v197;
                          if ((_DWORD)v195)
                          {
                            id v199 = _NRLogIsLevelEnabled(v197, 17LL);

                            if (!v199) {
                              goto LABEL_200;
                            }
                            uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v200);
                            id v82 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs(v81, 17LL, "%@: os_channel_attr_get(EXCLUSIVE) returned %d", v82, v195);
                            goto LABEL_199;
                          }

                          uint64_t v201 = _NRLogIsLevelEnabled(v197, 2LL);

                          if (v201)
                          {
                            v203 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v202);
                            int v204 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v203,  2LL,  "%s%.30s:%-4d %@: Link Channel EXCLUSIVE = %llu",  "",  "-[NRLinkBluetooth start]",  1221LL,  v204,  __memptr[0]);
                          }

                          __memptr[0] = 0LL;
                          uint64_t v205 = os_channel_attr_get(v376, 7LL, __memptr);
                          id v207 = _NRCopyLogObjectForNRUUID(v6->super._nrUUID, v206);
                          int v208 = (void *)v207;
                          if ((_DWORD)v205)
                          {
                            uint64_t v209 = _NRLogIsLevelEnabled(v207, 17LL);

                            if (!v209) {
                              goto LABEL_200;
                            }
                            uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v210);
                            id v82 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs(v81, 17LL, "%@: os_channel_attr_get(NO_AUTO_SYNC) returned %d", v82, v205);
                            goto LABEL_199;
                          }

                          id v211 = _NRLogIsLevelEnabled(v207, 2LL);

                          if (v211)
                          {
                            uint64_t v213 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v212);
                            uint64_t v214 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v213,  2LL,  "%s%.30s:%-4d %@: Link Channel NO_AUTO_SYNC = %llu",  "",  "-[NRLinkBluetooth start]",  1222LL,  v214,  __memptr[0]);
                          }

                          __memptr[0] = 0LL;
                          v215 = os_channel_attr_get(v376, 8LL, __memptr);
                          uint64_t v217 = _NRCopyLogObjectForNRUUID(v6->super._nrUUID, v216);
                          v218 = (void *)v217;
                          if ((_DWORD)v215)
                          {
                            id v219 = _NRLogIsLevelEnabled(v217, 17LL);

                            if (!v219) {
                              goto LABEL_200;
                            }
                            uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v220);
                            id v82 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs(v81, 17LL, "%@: os_channel_attr_get(MONITOR) returned %d", v82, v215);
                            goto LABEL_199;
                          }

                          uint64_t v221 = _NRLogIsLevelEnabled(v217, 2LL);

                          if (v221)
                          {
                            id v223 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v222);
                            uint64_t v224 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v223,  2LL,  "%s%.30s:%-4d %@: Link Channel MONITOR = %llu",  "",  "-[NRLinkBluetooth start]",  1223LL,  v224,  __memptr[0]);
                          }

                          __memptr[0] = 0LL;
                          uint64_t v225 = os_channel_attr_get(v376, 9LL, __memptr);
                          v227 = _NRCopyLogObjectForNRUUID(v6->super._nrUUID, v226);
                          int v228 = (void *)v227;
                          if ((_DWORD)v225)
                          {
                            uint64_t v229 = _NRLogIsLevelEnabled(v227, 17LL);

                            if (!v229) {
                              goto LABEL_200;
                            }
                            uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v230);
                            id v82 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs(v81, 17LL, "%@: os_channel_attr_get(TX_LOWAT_UNIT) returned %d", v82, v225);
                            goto LABEL_199;
                          }

                          id v231 = _NRLogIsLevelEnabled(v227, 2LL);

                          if (v231)
                          {
                            uint64_t v233 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v232);
                            v234 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v233,  2LL,  "%s%.30s:%-4d %@: Link Channel TX_LOWAT_UNIT = %llu",  "",  "-[NRLinkBluetooth start]",  1224LL,  v234,  __memptr[0]);
                          }

                          __memptr[0] = 0LL;
                          id v235 = os_channel_attr_get(v376, 10LL, __memptr);
                          uint64_t v237 = _NRCopyLogObjectForNRUUID(v6->super._nrUUID, v236);
                          uint64_t v238 = (void *)v237;
                          if ((_DWORD)v235)
                          {
                            v239 = _NRLogIsLevelEnabled(v237, 17LL);

                            if (!v239) {
                              goto LABEL_200;
                            }
                            uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v240);
                            id v82 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs(v81, 17LL, "%@: os_channel_attr_get(TX_LOWAT_VALUE) returned %d", v82, v235);
                            goto LABEL_199;
                          }

                          v246 = _NRLogIsLevelEnabled(v237, 2LL);

                          if (v246)
                          {
                            uint64_t v248 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v247);
                            uint64_t v249 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v248,  2LL,  "%s%.30s:%-4d %@: Link Channel TX_LOWAT_VALUE = %llu",  "",  "-[NRLinkBluetooth start]",  1225LL,  v249,  __memptr[0]);
                          }

                          __memptr[0] = 0LL;
                          uint64_t v250 = os_channel_attr_get(v376, 11LL, __memptr);
                          int v252 = _NRCopyLogObjectForNRUUID(v6->super._nrUUID, v251);
                          uint64_t v253 = (void *)v252;
                          if ((_DWORD)v250)
                          {
                            v254 = _NRLogIsLevelEnabled(v252, 17LL);

                            if (!v254) {
                              goto LABEL_200;
                            }
                            uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v255);
                            id v82 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs(v81, 17LL, "%@: os_channel_attr_get(RX_LOWAT_UNIT) returned %d", v82, v250);
                            goto LABEL_199;
                          }

                          int v256 = _NRLogIsLevelEnabled(v252, 2LL);

                          if (v256)
                          {
                            v258 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v257);
                            id v259 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v258,  2LL,  "%s%.30s:%-4d %@: Link Channel RX_LOWAT_UNIT = %llu",  "",  "-[NRLinkBluetooth start]",  1226LL,  v259,  __memptr[0]);
                          }

                          __memptr[0] = 0LL;
                          uint64_t v260 = os_channel_attr_get(v376, 12LL, __memptr);
                          uint64_t v262 = _NRCopyLogObjectForNRUUID(v6->super._nrUUID, v261);
                          uint64_t v263 = (void *)v262;
                          if ((_DWORD)v260)
                          {
                            uint64_t v264 = _NRLogIsLevelEnabled(v262, 17LL);

                            if (!v264) {
                              goto LABEL_200;
                            }
                            uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v265);
                            id v82 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs(v81, 17LL, "%@: os_channel_attr_get(RX_LOWAT_VALUE) returned %d", v82, v260);
                            goto LABEL_199;
                          }

                          uint64_t v266 = _NRLogIsLevelEnabled(v262, 2LL);

                          if (v266)
                          {
                            dispatch_group_t v268 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v267);
                            v269 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v268,  2LL,  "%s%.30s:%-4d %@: Link Channel RX_LOWAT_VALUE = %llu",  "",  "-[NRLinkBluetooth start]",  1227LL,  v269,  __memptr[0]);
                          }

                          __memptr[0] = 0LL;
                          dispatch_source_t v270 = os_channel_attr_get(v376, 13LL, __memptr);
                          v272 = _NRCopyLogObjectForNRUUID(v6->super._nrUUID, v271);
                          v273 = (void *)v272;
                          if ((_DWORD)v270)
                          {
                            v274 = _NRLogIsLevelEnabled(v272, 17LL);

                            if (!v274) {
                              goto LABEL_200;
                            }
                            uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v275);
                            id v82 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs(v81, 17LL, "%@: os_channel_attr_get(NEXUS_TYPE) returned %d", v82, v270);
                            goto LABEL_199;
                          }

                          v276 = _NRLogIsLevelEnabled(v272, 2LL);

                          if (v276)
                          {
                            v278 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v277);
                            v279 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v278,  2LL,  "%s%.30s:%-4d %@: Link Channel NEXUS_TYPE = %llu",  "",  "-[NRLinkBluetooth start]",  1228LL,  v279,  __memptr[0]);
                          }

                          __memptr[0] = 0LL;
                          v280 = os_channel_attr_get(v376, 14LL, __memptr);
                          v282 = _NRCopyLogObjectForNRUUID(v6->super._nrUUID, v281);
                          v283 = (void *)v282;
                          if ((_DWORD)v280)
                          {
                            int v284 = _NRLogIsLevelEnabled(v282, 17LL);

                            if (!v284) {
                              goto LABEL_200;
                            }
                            uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v285);
                            id v82 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v81,  17LL,  "%@: os_channel_attr_get(NEXUS_EXTENSIONS) returned %d",  v82,  v280);
                            goto LABEL_199;
                          }

                          v286 = _NRLogIsLevelEnabled(v282, 2LL);

                          if (v286)
                          {
                            v288 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v287);
                            int v289 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v288,  2LL,  "%s%.30s:%-4d %@: Link Channel NEXUS_EXTENSIONS = %llu",  "",  "-[NRLinkBluetooth start]",  1229LL,  v289,  __memptr[0]);
                          }

                          __memptr[0] = 0LL;
                          uint64_t v290 = os_channel_attr_get(v376, 15LL, __memptr);
                          id v292 = _NRCopyLogObjectForNRUUID(v6->super._nrUUID, v291);
                          v293 = (void *)v292;
                          if ((_DWORD)v290)
                          {
                            int v294 = _NRLogIsLevelEnabled(v292, 17LL);

                            if (!v294) {
                              goto LABEL_200;
                            }
                            uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v295);
                            id v82 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs(v81, 17LL, "%@: os_channel_attr_get(NEXUS_MHINTS) returned %d", v82, v290);
                            goto LABEL_199;
                          }

                          v296 = _NRLogIsLevelEnabled(v292, 2LL);

                          if (v296)
                          {
                            id v298 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v297);
                            int v299 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v298,  2LL,  "%s%.30s:%-4d %@: Link Channel NEXUS_MHINTS = %llu",  "",  "-[NRLinkBluetooth start]",  1230LL,  v299,  __memptr[0]);
                          }

                          __memptr[0] = 0LL;
                          id v300 = os_channel_attr_get(v376, 18LL, __memptr);
                          v302 = _NRCopyLogObjectForNRUUID(v6->super._nrUUID, v301);
                          v303 = (void *)v302;
                          if ((_DWORD)v300)
                          {
                            uint64_t v304 = _NRLogIsLevelEnabled(v302, 17LL);

                            if (!v304) {
                              goto LABEL_200;
                            }
                            uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v305);
                            id v82 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs(v81, 17LL, "%@: os_channel_attr_get(NEXUS_IFINDEX) returned %d", v82, v300);
                            goto LABEL_199;
                          }

                          id v306 = _NRLogIsLevelEnabled(v302, 2LL);

                          if (v306)
                          {
                            id v308 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v307);
                            uint64_t v309 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v308,  2LL,  "%s%.30s:%-4d %@: Link Channel NEXUS_IFINDEX = %llu",  "",  "-[NRLinkBluetooth start]",  1231LL,  v309,  __memptr[0]);
                          }

                          __memptr[0] = 0LL;
                          v310 = os_channel_attr_get(v376, 19LL, __memptr);
                          uint64_t v312 = _NRCopyLogObjectForNRUUID(v6->super._nrUUID, v311);
                          id v313 = (void *)v312;
                          if ((_DWORD)v310)
                          {
                            id v314 = _NRLogIsLevelEnabled(v312, 17LL);

                            if (!v314) {
                              goto LABEL_200;
                            }
                            uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v315);
                            id v82 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v81,  17LL,  "%@: os_channel_attr_get(NEXUS_STATS_SIZE) returned %d",  v82,  v310);
                            goto LABEL_199;
                          }

                          id v316 = _NRLogIsLevelEnabled(v312, 2LL);

                          if (v316)
                          {
                            v318 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v317);
                            v319 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v318,  2LL,  "%s%.30s:%-4d %@: Link Channel NEXUS_STATS_SIZE = %llu",  "",  "-[NRLinkBluetooth start]",  1232LL,  v319,  __memptr[0]);
                          }

                          __memptr[0] = 0LL;
                          uint64_t v320 = os_channel_attr_get(v376, 20LL, __memptr);
                          v322 = _NRCopyLogObjectForNRUUID(v6->super._nrUUID, v321);
                          v323 = (void *)v322;
                          if ((_DWORD)v320)
                          {
                            v324 = _NRLogIsLevelEnabled(v322, 17LL);

                            if (!v324) {
                              goto LABEL_200;
                            }
                            uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v325);
                            id v82 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v81,  17LL,  "%@: os_channel_attr_get(NEXUS_FLOWADV_MAX) returned %d",  v82,  v320);
                            goto LABEL_199;
                          }

                          v326 = _NRLogIsLevelEnabled(v322, 2LL);

                          if (v326)
                          {
                            v328 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v327);
                            v329 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v328,  2LL,  "%s%.30s:%-4d %@: Link Channel NEXUS_FLOWADV_MAX = %llu",  "",  "-[NRLinkBluetooth start]",  1233LL,  v329,  __memptr[0]);
                          }

                          __memptr[0] = 0LL;
                          v330 = os_channel_attr_get(v376, 2LL, __memptr);
                          if ((_DWORD)v330)
                          {
                            v332 = v330;
                            v333 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v331);
                            v334 = _NRLogIsLevelEnabled(v333, 17LL);

                            if (!v334) {
                              goto LABEL_200;
                            }
                            uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v335);
                            id v82 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs(v81, 17LL, "%@: link os_channel_attr_get(TX_SLOTS) returned %d", v82, v332);
                            goto LABEL_199;
                          }

                          v336 = (unint64_t)__memptr[0] >> 1;
                          v337 = os_channel_attr_set(v376, 10LL, (unint64_t)__memptr[0] >> 1);
                          if ((_DWORD)v337)
                          {
                            v339 = v337;
                            v340 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v338);
                            v341 = _NRLogIsLevelEnabled(v340, 17LL);

                            if (!v341) {
                              goto LABEL_200;
                            }
                            uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v342);
                            id v82 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v81,  17LL,  "%@: link os_channel_attr_set(TX_LOWAT_VALUE, %llu) returned %d",  v82,  v336,  v339);
                            goto LABEL_199;
                          }

                          v343 = os_channel_write_attr(*(Class *)((char *)&v6->super.super.isa + v2), v376);
                          if ((_DWORD)v343)
                          {
                            v345 = v343;
                            v346 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v344);
                            v347 = _NRLogIsLevelEnabled(v346, 17LL);

                            if (!v347) {
                              goto LABEL_200;
                            }
                            uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v348);
                            id v82 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v81,  17LL,  "%@: link os_channel_write_attr returned %d (linkOutputLowat=%llu)",  v82,  v345,  v336);
                            goto LABEL_199;
                          }

                          os_channel_attr_destroy(v376);
                          v350 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v349);
                          v351 = _NRLogIsLevelEnabled(v350, 1LL);

                          if (v351)
                          {
                            v353 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v352);
                            v354 = -[NRLink copyDescription](v6, "copyDescription");
                            _NRLogWithArgs( v353,  1LL,  "%s%.30s:%-4d %@: Successfully set linkOutputLowat to %llu (linkOutputSlotCount=%llu)",  "",  "-[NRLinkBluetooth start]",  1267LL,  v354,  v336,  __memptr[0]);
                          }

                          v355 = (dispatch_queue_s *)v6->super._queue;
                          v378 = v378;
                          v356 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_read,  v378,  0LL,  v355);
                          v357 = *(channel_ring_desc **)((char *)&v6->_linkOutputRing + 7);
                          *(channel_ring_desc **)((char *)&v6->_linkOutputRing + 7) = (channel_ring_desc *)v356;

                          v359 = *(dispatch_source_s **)((char *)&v6->_linkOutputRing + 7);
                          if (!v359) {
                            break;
                          }
                          handler[0] = _NSConcreteStackBlock;
                          handler[1] = 3221225472LL;
                          handler[2] = sub_10009DF40;
                          handler[3] = &unk_1001B0A88;
                          void handler[4] = v6;
                          dispatch_source_set_event_handler(v359, handler);
                          v360 = *(dispatch_source_s **)((char *)&v6->_linkOutputRing + 7);
                          v386[0] = _NSConcreteStackBlock;
                          v386[1] = 3221225472LL;
                          v386[2] = nullsub_10;
                          v386[3] = &unk_1001B0A88;
                          id v2 = (uint64_t)(id)v16;
                          v387 = (id)v2;
                          dispatch_source_set_cancel_handler(v360, v386);
                          dispatch_activate(*(dispatch_object_t *)((char *)&v6->_linkOutputRing + 7));
                          v361 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_write,  v378,  0LL,  (dispatch_queue_t)v6->super._queue);
                          v362 = *(OS_dispatch_source **)((char *)&v6->_dLinkInputSource + 7);
                          *(OS_dispatch_source **)((char *)&v6->_dLinkInputSource + 7) = (OS_dispatch_source *)v361;

                          v364 = *(dispatch_source_s **)((char *)&v6->_dLinkInputSource + 7);
                          if (!v364)
                          {
                            v369 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v363);
                            v370 = _NRLogIsLevelEnabled(v369, 17LL);

                            if (v370)
                            {
                              v372 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v371);
                              v373 = -[NRLink copyDescription](v6, "copyDescription");
                              _NRLogWithArgs(v372, 17LL, "%@: _dLinkOutputSource is NULL", v373);
                            }

                            goto LABEL_200;
                          }

                          v385[0] = _NSConcreteStackBlock;
                          v385[1] = 3221225472LL;
                          v385[2] = sub_10009E168;
                          v385[3] = &unk_1001B0A88;
                          v385[4] = v6;
                          dispatch_source_set_event_handler(v364, v385);
                          v365 = *(dispatch_source_s **)((char *)&v6->_dLinkInputSource + 7);
                          v383[0] = _NSConcreteStackBlock;
                          v383[1] = 3221225472LL;
                          v383[2] = nullsub_11;
                          v383[3] = &unk_1001B0A88;
                          v384 = (id)v2;
                          dispatch_source_set_cancel_handler(v365, v383);
                          v6->_dLinkOutputSourceSuspended = 1;

                          uint64_t v25 = v381;
                          uint64_t v19 = v377;
                        }

                        v366 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v358);
                        v367 = _NRLogIsLevelEnabled(v366, 17LL);

                        if (!v367) {
                          goto LABEL_200;
                        }
                        uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v368);
                        id v82 = -[NRLink copyDescription](v6, "copyDescription");
                        _NRLogWithArgs(v81, 17LL, "%@: _dLinkInputSource is NULL", v82, v374);
                        goto LABEL_199;
                      }

                      uint64_t v62 = [v24 channel];
                      id v2 = 959LL;
                      *(unint64_t *)((char *)&v6->_writeCounter + 7) = (unint64_t)v62;
                      if (!v62)
                      {
                        id v83 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v63);
                        unsigned int v84 = _NRLogIsLevelEnabled(v83, 17LL);

                        if (!v84) {
                          goto LABEL_200;
                        }
                        uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v85);
                        id v82 = -[NRLink copyDescription](v6, "copyDescription");
                        _NRLogWithArgs(v81, 17LL, "%@: pipe.channel is NULL", v82);
                        goto LABEL_199;
                      }

                      id v64 = os_channel_ring_id(v62, 2LL);
                      uint64_t v65 = os_channel_rx_ring(*(unint64_t *)((char *)&v6->_writeCounter + 7), v64);
                      *(channel **)((char *)&v6->_linkChannel + 7) = (channel *)v65;
                      if (!v65)
                      {
                        uint64_t v86 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v66);
                        uint64_t v87 = _NRLogIsLevelEnabled(v86, 17LL);

                        if (!v87) {
                          goto LABEL_200;
                        }
                        uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v88);
                        id v82 = -[NRLink copyDescription](v6, "copyDescription");
                        _NRLogWithArgs(v81, 17LL, "%@: _linkInputRing is NULL", v82);
                        goto LABEL_199;
                      }

                      int v67 = os_channel_ring_id(*(unint64_t *)((char *)&v6->_writeCounter + 7), 0LL);
                      uint64_t v68 = os_channel_tx_ring(*(unint64_t *)((char *)&v6->_writeCounter + 7), v67);
                      *(channel_ring_desc **)((char *)&v6->_linkInputRing + 7) = (channel_ring_desc *)v68;
                      if (!v68)
                      {
                        uint64_t v89 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v69);
                        uint64_t v90 = _NRLogIsLevelEnabled(v89, 17LL);

                        if (!v90) {
                          goto LABEL_200;
                        }
                        uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v91);
                        id v82 = -[NRLink copyDescription](v6, "copyDescription");
                        _NRLogWithArgs(v81, 17LL, "%@: _linkOutputRing is NULL", v82);
                        goto LABEL_199;
                      }

                      unsigned int fd = os_channel_get_fd(*(unint64_t *)((char *)&v6->_writeCounter + 7));
                      if ((fd & 0x80000000) != 0)
                      {
                        int v92 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v71);
                        uint64_t v93 = _NRLogIsLevelEnabled(v92, 17LL);

                        if (!v93) {
                          goto LABEL_200;
                        }
                        uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v94);
                        id v82 = -[NRLink copyDescription](v6, "copyDescription");
                        _NRLogWithArgs(v81, 17LL, "%@: os_channel_get_fd failed", v82);
                        goto LABEL_199;
                      }

                      LODWORD(v37_Block_object_dispose(va, 8) = fd;
                      char v72 = os_channel_attr_create(fd);
                      if (!v72)
                      {
                        uint64_t v95 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v73);
                        uint64_t v96 = _NRLogIsLevelEnabled(v95, 17LL);

                        if (!v96) {
                          goto LABEL_200;
                        }
                        uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v97);
                        id v82 = -[NRLink copyDescription](v6, "copyDescription");
                        _NRLogWithArgs(v81, 17LL, "%@: os_channel_attr_create failed", v82);
                        goto LABEL_199;
                      }

                      int v74 = v72;
                      v377 = 279LL;
                      attr = os_channel_read_attr(*(unint64_t *)((char *)&v6->_writeCounter + 7), v72);
                      if ((_DWORD)attr)
                      {
                        int v77 = attr;
                        uint64_t v78 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v76);
                        id v79 = _NRLogIsLevelEnabled(v78, 17LL);

                        if (!v79) {
                          goto LABEL_200;
                        }
                        uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v80);
                        id v82 = -[NRLink copyDescription](v6, "copyDescription");
                        _NRLogWithArgs(v81, 17LL, "%@: os_channel_read_attr returned %d", v82, v77);
                        goto LABEL_199;
                      }

                      v381 = 246LL;
                      __memptr[0] = 0LL;
                      int v98 = os_channel_attr_get(v74, 0LL, __memptr);
                      uint64_t v100 = _NRCopyLogObjectForNRUUID(v6->super._nrUUID, v99);
                      id v101 = (void *)v100;
                      if ((_DWORD)v98)
                      {
                        int v102 = _NRLogIsLevelEnabled(v100, 17LL);

                        if (!v102) {
                          goto LABEL_200;
                        }
                        uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v103);
                        id v82 = -[NRLink copyDescription](v6, "copyDescription");
                        _NRLogWithArgs(v81, 17LL, "%@: os_channel_attr_get(TX_RINGS) returned %d", v82, v98);
                        goto LABEL_199;
                      }

                      v376 = v74;
                      id v104 = _NRLogIsLevelEnabled(v100, 2LL);

                      if (v104)
                      {
                        id v106 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v105);
                        uint64_t v107 = -[NRLink copyDescription](v6, "copyDescription");
                        _NRLogWithArgs( v106,  2LL,  "%s%.30s:%-4d %@: Link Channel TX_RINGS = %llu",  "",  "-[NRLinkBluetooth start]",  1215LL,  v107,  __memptr[0]);
                      }

                      __memptr[0] = 0LL;
                      uint64_t v108 = os_channel_attr_get(v376, 1LL, __memptr);
                      __int128 v110 = _NRCopyLogObjectForNRUUID(v6->super._nrUUID, v109);
                      __int128 v111 = (void *)v110;
                      if ((_DWORD)v108)
                      {
                        __int128 v112 = _NRLogIsLevelEnabled(v110, 17LL);

                        if (!v112) {
                          goto LABEL_200;
                        }
                        uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v113);
                        id v82 = -[NRLink copyDescription](v6, "copyDescription");
                        _NRLogWithArgs(v81, 17LL, "%@: os_channel_attr_get(RX_RINGS) returned %d", v82, v108);
                        goto LABEL_199;
                      }

                      __int128 v114 = _NRLogIsLevelEnabled(v110, 2LL);

                      if (v114)
                      {
                        __int128 v116 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v115);
                        __int128 v117 = -[NRLink copyDescription](v6, "copyDescription");
                        _NRLogWithArgs( v116,  2LL,  "%s%.30s:%-4d %@: Link Channel RX_RINGS = %llu",  "",  "-[NRLinkBluetooth start]",  1216LL,  v117,  __memptr[0]);
                      }

                      __memptr[0] = 0LL;
                      __int128 v118 = os_channel_attr_get(v376, 2LL, __memptr);
                      id v120 = _NRCopyLogObjectForNRUUID(v6->super._nrUUID, v119);
                      sentPreludeState = (int *)v120;
                      if ((_DWORD)v118)
                      {
                        unsigned int v121 = _NRLogIsLevelEnabled(v120, 17LL);

                        if (!v121) {
                          goto LABEL_200;
                        }
                        uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(v6->super._nrUUID, v122);
                        id v82 = -[NRLink copyDescription](v6, "copyDescription");
                        _NRLogWithArgs(v81, 17LL, "%@: os_channel_attr_get(TX_SLOTS) returned %d", v82, v118);
                        goto LABEL_199;
                      }

void sub_10006ED30( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

LABEL_60:
  if (v61)
  {
    if (v77)
    {
      nrUUID = self->super._nrUUID;
      v163[0] = _NSConcreteStackBlock;
      v163[1] = 3221225472LL;
      v163[2] = sub_100075658;
      v163[3] = &unk_1001AEDC0;
      v163[4] = self;
      uint64_t v61 = v61;
      uint64_t v164 = v61;
      __int128 v166 = v21;
      uint64_t v17 = v157;
      __int128 v165 = v157;
      uint64_t v80 = nrUUID;
      id v18 = v156;
      sub_1001320DC((uint64_t)&OBJC_CLASS___NRDLocalDevice, v80, 1, v163);
    }

    else if (v78)
    {
      uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v71);
      id v82 = _NRLogIsLevelEnabled(v81, 0LL);

      if (v82)
      {
        unsigned int v84 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v83);
        uint64_t v85 = -[NRLink copyDescription](self, "copyDescription");
        _NRLogWithArgs( v84,  0LL,  "%s%.30s:%-4d %@: Responder %@ querying IDS keys for pairing",  "",  "-[NRLinkBluetooth requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBlock:]",  9406LL,  v85,  v15);
      }

      uint64_t v86 = self->super._nrUUID;
      v158[0] = _NSConcreteStackBlock;
      v158[1] = 3221225472LL;
      v158[2] = sub_1000759B0;
      v158[3] = &unk_1001AEDE8;
      v158[4] = self;
      __int128 v162 = v21;
      size_t v159 = v15;
      uint64_t v61 = v61;
      __int128 v160 = v61;
      uint64_t v17 = v157;
      __int128 v161 = v157;
      sub_100132BC0((uint64_t)&OBJC_CLASS___NRDLocalDevice, v86, 4, v158);

      id v18 = v156;
    }

    else
    {
      uint64_t v97 = (void *)objc_claimAutoreleasedReturnValue(-[NRLink nrUUID](self, "nrUUID"));
      int v98 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v97);

      uint64_t v99 = sub_10010C340();
      -[NEIKEv2ChildSAConfiguration setSequencePerTrafficClass:](v99, "setSequencePerTrafficClass:", 1LL);
      -[NEIKEv2ChildSAConfiguration setReplayWindowSize:](v99, "setReplayWindowSize:", 16LL);
      if ((v76 & 1) != 0) {
        virtualInterface = 0LL;
      }
      else {
        virtualInterface = self->super._virtualInterface;
      }
      id v18 = v156;
      ((void (**)(void, NEIKEv2SessionConfiguration *, NEIKEv2ChildSAConfiguration *, NEVirtualInterface_s *))v21)[2]( v21,  v61,  v99,  virtualInterface);

      uint64_t v17 = v157;
    }

    goto LABEL_35;
  }

  uint64_t v17 = v157;
LABEL_34:
  v21[2](v21, 0LL, 0LL, 0LL);
LABEL_35:

LABEL_36:
}
}

LABEL_3:
}

              (*((void (**)(char *, NSMutableData *, NSMutableData *, NSMutableData *))v10 + 2))( v10,  v11,  v4,  v5);
              goto LABEL_61;
            }

LABEL_8:
    id v13 = 0;
    goto LABEL_9;
  }

  id v9 = _NRLogIsLevelEnabled(v7, 0LL);

  if (v9)
  {
    id v11 = (void *)_NRCopyLogObjectForNRUUID(self->super._nrUUID, v10);
    int v12 = -[NRLink copyDescription](self, "copyDescription");
    _NRLogWithArgs( v11,  0,  "%s%.30s:%-4d %@: Sending IKEv2 data of length %llu",  "",  "-[NRLinkBluetooth sendPacketData:]",  9493,  v12,  [v5 length]);
  }

  id v13 = sub_1000705C4((uint64_t)self, v5);
LABEL_9:

  return v13;
}

      if (*(_BYTE *)(v6 + 244)) {
        goto LABEL_13;
      }
      goto LABEL_9;
    }

    id v2 = v9;
  }

  else
  {
    id v6 = *(void *)(a1 + 32);
    if (v6)
    {
      id v5 = 0LL;
      if (*(_BYTE *)(v6 + 243)) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }

    id v5 = 0LL;
  }

      int v12 = (char *)v12 + 1;
    }

    while (v7 != v12);
    uint64_t v7 = [v5 countByEnumeratingWithState:&v31 objects:v35 count:16];
    if (v7) {
      continue;
    }
    break;
  }

  if ((v8 & 1) != 0) {
    id v27 = v4;
  }
  else {
    id v27 = 0LL;
  }
LABEL_24:
  id v28 = v27;

  return v28;
}

      LOBYTE(self) = 1;
      goto LABEL_12;
    }

  return a1;
}
}

  (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
LABEL_9:
}

        (*((void (**)(char *, void *))v9 + 2))(v9, v11);

        goto LABEL_9;
      }
    }

    else
    {
      uint64_t v23 = sub_100121F34();
      id v24 = _NRLogIsLevelEnabled(v23, 16LL);

      if (v24)
      {
        uint64_t v25 = sub_100121F34();
        _NRLogWithArgs( v25,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "+[NRDLocalDevice ingestRemoteDeviceIdentity:nrUUID:deviceCompletionBlock:]",  3167);
      }

      id v8 = (id)_os_log_pack_size(12LL);
      id v9 = (char *)&v32 - (((unint64_t)v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
      objc_super v26 = __error();
      id v27 = _os_log_pack_fill( v9,  v8,  *v26,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)id v27 = 136446210;
      *(void *)(v27 + 4) = "+[NRDLocalDevice ingestRemoteDeviceIdentity:nrUUID:deviceCompletionBlock:]";
      id v28 = sub_100121F34();
      id v13 = (void *)_NRLogAbortWithPack(v28, v9);
    }

    if ((objc_msgSend(v13, "isEqual:", v4, v32) & 1) == 0)
    {
      id v29 = sub_100121F34();
      id v30 = _NRLogIsLevelEnabled(v29, 17LL);

      if (v30)
      {
        uint64_t v31 = sub_100121F34();
        _NRLogWithArgs(v31, 17LL, "Ingested remote device identity doesn't match existing one!");
      }
    }

    goto LABEL_8;
  }

  uint64_t v17 = sub_100121F34();
  id v18 = _NRLogIsLevelEnabled(v17, 17LL);

  if (!v18) {
    goto LABEL_10;
  }
  id v11 = sub_100121F34();
  _NRLogWithArgs( v11,  17LL,  "%s called with null remoteDeviceIdentityData.length == sizeof(uuid_t) + sizeof(ccec25519pubkey)");
LABEL_9:

LABEL_10:
}

          id v9 = v71 + 1;
        }

        while ((id)(v71 + 1) != v4);
        uint64_t v4 = [obj countByEnumeratingWithState:&v95 objects:v102 count:16];
      }

      while (v4);
    }
  }
}

id sub_100070554()
{
  if (qword_1001DC840 != -1) {
    dispatch_once(&qword_1001DC840, &stru_1001AEE08);
  }
  return (id)qword_1001DC838;
}

void sub_100070594(id a1)
{
  os_log_t v1 = os_log_create("com.apple.networkrelay", "");
  id v2 = (void *)qword_1001DC838;
  qword_1001DC838 = (uint64_t)v1;
}

uint64_t sub_1000705C4(uint64_t a1, void *a2)
{
  id v4 = a2;
  id v5 = v4;
  if (a1)
  {
    id v6 = [v4 length];
    uint64_t v7 = *(void *)(a1 + 1583);
    IKEv2Packetid String = (void *)createIKEv2PacketString(v5);
    size_t v9 = (unsigned __int16)v6;
    [(id)a1 reportEvent:3006, @"Sending IKEv2 packet #%llu %@ len %llu", v7, IKEv2PacketString, (unsigned __int16)v6 detailsFormat];

    ++*(void *)(a1 + 1583);
    id v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v10);
    int IsLevelEnabled = (int *)_NRLogIsLevelEnabled(v11, 1LL);

    if ((_DWORD)IsLevelEnabled)
    {
      size_t v53 = (unsigned __int16)v6;
      id v51 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v13);
      id v14 = [(id)a1 copyDescription];
      uint64_t v49 = *(void *)(a1 + 1583);
      id v50 = v14;
      id v52 = v6;
      uint64_t v48 = (unsigned __int16)v6;
      id v54 = v5;
      id v15 = v5;
      unsigned int v16 = [v15 length];
      id v47 = v15;
      id v17 = [v15 bytes];
      id v18 = objc_alloc_init(&OBJC_CLASS___NSMutableString);
      if (v16)
      {
        int IsLevelEnabled = 0LL;
        id v2 = @" ";
        do
        {
          -[NSMutableString appendFormat:]( v18,  "appendFormat:",  @"%02X",  *((unsigned __int8 *)IsLevelEnabled + (void)v17));
          if ((~(_DWORD)IsLevelEnabled & 0xF) == 0 || (~(_DWORD)IsLevelEnabled & 3) == 0) {
            -[NSMutableString appendString:](v18, "appendString:");
          }
          int IsLevelEnabled = (int *)((char *)IsLevelEnabled + 1);
        }

        while ((int *)v16 != IsLevelEnabled);
      }

      _NRLogWithArgs( v51,  1LL,  "%s%.30s:%-4d %@: IKE #%llu SENDING dataLen=%u data=[\n%@]",  "",  "-[NRLinkBluetooth sendIKEData:]",  7196LL,  v50,  v49,  v48,  v18);
      size_t v9 = v53;
      id v5 = v54;
      LODWORD(v6) = (_DWORD)v52;
    }

    if (*(_BYTE *)(a1 + 246))
    {
      __int16 v56 = bswap32(v6) >> 16;
      uint64_t v19 = -[NSMutableData initWithCapacity:](objc_alloc(&OBJC_CLASS___NSMutableData), "initWithCapacity:", v9 + 5);
      -[NSMutableData appendBytes:length:](v19, "appendBytes:length:", &unk_1001568B4, 1LL);
      -[NSMutableData appendBytes:length:](v19, "appendBytes:length:", &v56, 2LL);
      -[NSMutableData appendData:](v19, "appendData:", v5);
      id v20 = -[NSMutableData bytes](v19, "bytes");
      NSUInteger v21 = -[NSMutableData length](v19, "length");
      if ((_DWORD)v21)
      {
        __int16 v55 = ~(unsigned __int16)os_inet_checksum(v20, v21, 0LL);
        -[NSMutableData appendBytes:length:](v19, "appendBytes:length:", &v55, 2LL);
        else {
          uint64_t v22 = &off_1001BC628;
        }
        sub_100070C18(a1, v19, v22);

        goto LABEL_25;
      }

      id v35 = sub_100070554();
      int v36 = _NRLogIsLevelEnabled(v35, 16LL);

      if (v36)
      {
        id v37 = sub_100070554();
        _NRLogWithArgs(v37, 16LL, "%s%.30s:%-4d ABORTING: Assertion Failed: dataLen > 0", "", "nrChecksumFull", 109);
      }

      uint64_t v38 = _os_log_pack_size(12LL);
      a1 = (uint64_t)&v47 - ((__chkstk_darwin(v38) + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v39 = __error();
      uint64_t v40 = _os_log_pack_fill( a1,  v38,  *v39,  &_mh_execute_header,  "%{public}s Assertion Failed: dataLen > 0");
      *(_DWORD *)uint64_t v40 = 136446210;
      *(void *)(v40 + 4) = "nrChecksumFull";
      id v41 = sub_100070554();
      _NRLogAbortWithPack(v41, a1);
      goto LABEL_30;
    }

    int IsLevelEnabled = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
    uint64_t v23 = *(unsigned int *)(a1 + 287);
    id v2 = (const __CFString *)(unsigned __int16)v6;
    if (*(_DWORD *)(a1 + 279) >= (unsigned __int16)v6 + 5 + v23)
    {
      uint64_t v29 = *(void *)(a1 + 447) + v23;
      *(_BYTE *)uint64_t v29 = 4;
      *(_WORD *)(v29 + 1) = bswap32(v6) >> 16;
      memcpy((void *)(*(void *)(a1 + 447) + (*(_DWORD *)(a1 + 287) + 3)), [v5 bytes], v9);
      uint64_t v30 = (unsigned __int16)v6 + 3;
      uint64_t v31 = *(void *)(a1 + 447);
      unsigned int v32 = v30 + *(_DWORD *)(a1 + 287);
      *(_WORD *)(v31 + v32) = ~(unsigned __int16)os_inet_checksum(v29, v30, 0LL);
      *(_DWORD *)(a1 + 287) += (unsigned __int16)v6 + 5;
      if (!gNRPacketLoggingEnabled)
      {
LABEL_24:
        sub_100070E0C((void *)a1, *(void *)(a1 + 367));
LABEL_25:
        a1 = 1LL;
        goto LABEL_26;
      }

void sub_100070C18(uint64_t a1, void *a2, void *a3)
{
  if (a1)
  {
    id v5 = a3;
    id v6 = a2;
    uint64_t v19 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    -[NSMutableDictionary setObject:forKeyedSubscript:](v19, "setObject:forKeyedSubscript:", v6, @"message-data");

    -[NSMutableDictionary setObject:forKeyedSubscript:](v19, "setObject:forKeyedSubscript:", v5, @"channel-id");
    uint64_t v7 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v19, @"message");
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v8 = (id)qword_1001DC870;
    size_t v9 = v8;
    if (v8) {
      BOOL v10 = *((_BYTE *)v8 + 9) != 0;
    }
    else {
      BOOL v10 = 0LL;
    }
    id v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", v10));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v11, @"test-wake-pkt");

    int v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](&OBJC_CLASS___NSNumber, "numberWithBool:", gNRPacketLoggingEnabled));
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v7,  "setObject:forKeyedSubscript:",  v12,  @"packet-logging");

    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v13 = (id)qword_1001DC870;
    id v14 = v13;
    if (v13)
    {
      uint64_t v15 = *(void *)(a1 + 32);
      unsigned int v16 = (void *)*((void *)v13 + 27);
      id v17 = v7;
      id v18 = (void *)objc_claimAutoreleasedReturnValue([v16 objectForKeyedSubscript:v15]);
      sub_1000EFBC8((uint64_t)v18, v17);
    }
  }

void sub_100070E0C(void *a1, uint64_t a2)
{
  id v3 = a1;
  id v5 = (char *)v3;
  if (v3[16] == 255)
  {
    id v8 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 16LL);

    if (!IsLevelEnabled) {
      goto LABEL_266;
    }
    id v11 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v10);
    id v12 = [v5 copyDescription];
    _NRLogWithArgs( v11,  16LL,  "%s%.30s:%-4d %@: nexusToLinkLoop but cancelled",  "",  "NRLinkNexusToLinkLoop",  3578LL,  v12);
    goto LABEL_10;
  }

  id v6 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
  if (!*(void *)(v3 + 975))
  {
    if (v3[246]) {
      goto LABEL_266;
    }
    id v13 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v4);
    int v14 = _NRLogIsLevelEnabled(v13, 17LL);

    if (!v14) {
      goto LABEL_266;
    }
    id v11 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v15);
    id v12 = [v5 copyDescription];
    _NRLogWithArgs(v11, 17LL, "%@: Tried to nexusToLinkLoop but _linkOutputRing is NULL", v12);
LABEL_10:

    goto LABEL_266;
  }

  uint64_t v349 = *(void *)(v3 + 527);
  uint64_t v350 = a2;
  v353 = (char *)v3;
  if (v349 == a2)
  {
    if (gNRPacketLoggingEnabled)
    {
      int v284 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v4);
      int v285 = _NRLogIsLevelEnabled(v284, 1LL);

      if (v285)
      {
        v286 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
        id v287 = [v5 copyDescription];
        _NRLogWithArgs(v286, 1LL, "%s%.30s:%-4d %@: Serving voice channel", "", "NRLinkNexusToLinkLoop", 3603LL, v287);
        v343 = sub_1000748C4;
        v338 = sub_1000744A8;
        unsigned int v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusVOInput;
        id v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusVO;
        id v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusVO;
        uint64_t v19 = &OBJC_IVAR___NRLinkBluetooth__nexusVOInputRing;
        goto LABEL_338;
      }
    }

    v343 = sub_1000748C4;
    v338 = sub_1000744A8;
    unsigned int v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusVOInput;
    id v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusVO;
    id v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusVO;
    uint64_t v19 = &OBJC_IVAR___NRLinkBluetooth__nexusVOInputRing;
  }

  else if (*(void *)(v3 + 671) == a2)
  {
    if (gNRPacketLoggingEnabled)
    {
      v288 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v4);
      int v289 = _NRLogIsLevelEnabled(v288, 1LL);

      if (!v289)
      {
        v343 = sub_1000747BC;
        v338 = sub_1000743A4;
        unsigned int v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusVIInput;
        id v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusVI;
        id v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusVI;
        uint64_t v19 = &OBJC_IVAR___NRLinkBluetooth__nexusVIInputRing;
        id v5 = v353;
        goto LABEL_22;
      }

      id v5 = v353;
      v286 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v353 + 4), v4);
      id v287 = [v353 copyDescription];
      _NRLogWithArgs(v286, 1LL, "%s%.30s:%-4d %@: Serving video channel", "", "NRLinkNexusToLinkLoop", 3614LL, v287);
      v343 = sub_1000747BC;
      v338 = sub_1000743A4;
      unsigned int v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusVIInput;
      id v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusVI;
      id v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusVI;
      uint64_t v19 = &OBJC_IVAR___NRLinkBluetooth__nexusVIInputRing;
      goto LABEL_338;
    }

    v343 = sub_1000747BC;
    v338 = sub_1000743A4;
    unsigned int v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusVIInput;
    id v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusVI;
    id v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusVI;
    uint64_t v19 = &OBJC_IVAR___NRLinkBluetooth__nexusVIInputRing;
  }

  else
  {
    if (*(void *)(v3 + 815) != a2)
    {
      if (*(void *)(v3 + 367) != a2)
      {
        uint64_t v332 = 0LL;
        uint64_t v333 = 0LL;
        v337 = 0LL;
        v338 = 0LL;
        v343 = 0LL;
        v335 = 0LL;
        v336 = 0LL;
        uint64_t v7 = 0LL;
        goto LABEL_23;
      }

      if (!gNRPacketLoggingEnabled)
      {
        v343 = sub_1000745AC;
        v338 = sub_10007419C;
        unsigned int v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusInput;
        id v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexus;
        id v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexus;
        uint64_t v19 = &OBJC_IVAR___NRLinkBluetooth__nexusInputRing;
        goto LABEL_22;
      }

      v310 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v4);
      int v311 = _NRLogIsLevelEnabled(v310, 1LL);

      if (!v311)
      {
        v343 = sub_1000745AC;
        v338 = sub_10007419C;
        unsigned int v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusInput;
        id v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexus;
        id v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexus;
        uint64_t v19 = &OBJC_IVAR___NRLinkBluetooth__nexusInputRing;
        id v5 = v353;
        goto LABEL_22;
      }

      id v5 = v353;
      v286 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v353 + 4), v4);
      id v287 = [v353 copyDescription];
      _NRLogWithArgs( v286,  1LL,  "%s%.30s:%-4d %@: Serving BestEffort channel",  "",  "NRLinkNexusToLinkLoop",  3634LL,  v287);
      v343 = sub_1000745AC;
      v338 = sub_10007419C;
      unsigned int v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusInput;
      id v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexus;
      id v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexus;
      uint64_t v19 = &OBJC_IVAR___NRLinkBluetooth__nexusInputRing;
LABEL_338:

      goto LABEL_22;
    }

    if (gNRPacketLoggingEnabled)
    {
      uint64_t v290 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v3 + 4), v4);
      int v291 = _NRLogIsLevelEnabled(v290, 1LL);

      if (!v291)
      {
        v343 = sub_1000746B4;
        v338 = sub_1000742A0;
        unsigned int v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusBKInput;
        id v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusBK;
        id v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusBK;
        uint64_t v19 = &OBJC_IVAR___NRLinkBluetooth__nexusBKInputRing;
        id v5 = v353;
        goto LABEL_22;
      }

      id v5 = v353;
      v286 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v353 + 4), v4);
      id v287 = [v353 copyDescription];
      _NRLogWithArgs( v286,  1LL,  "%s%.30s:%-4d %@: Serving Background channel",  "",  "NRLinkNexusToLinkLoop",  3624LL,  v287);
      v343 = sub_1000746B4;
      v338 = sub_1000742A0;
      unsigned int v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusBKInput;
      id v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusBK;
      id v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusBK;
      uint64_t v19 = &OBJC_IVAR___NRLinkBluetooth__nexusBKInputRing;
      goto LABEL_338;
    }

    v343 = sub_1000746B4;
    v338 = sub_1000742A0;
    unsigned int v16 = &OBJC_IVAR___NRLinkBluetooth__syncNexusBKInput;
    id v17 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusBK;
    id v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusBK;
    uint64_t v19 = &OBJC_IVAR___NRLinkBluetooth__nexusBKInputRing;
  }

LABEL_321:
                uint64_t v281 = _os_log_pack_size(18LL);
                id v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                uint64_t v282 = *__error();
                uint64_t v283 = _os_log_pack_fill( v235,  v281,  v282,  &_mh_execute_header,  "%{public}s os_packet_finalize returned %d");
                *(_DWORD *)uint64_t v283 = 136446466;
                *(void *)(v283 + 4) = "NRLinkNexusToLinkLoop";
                *(_WORD *)(v283 + 12) = 1024;
                *(_DWORD *)(v283 + 14) = v277;
                goto LABEL_306;
              }
            }

            else
            {
              uint64_t ESPSequenceNumberFromPacket = 0LL;
              if (v35) {
                goto LABEL_74;
              }
            }

            uint64_t v26 = v33;
            uint64_t v25 = v351;
            id v6 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          }
        }

        else
        {
          LODWORD(v24) = v30;
        }
      }

      uint64_t v23 = v29;
      if ((_WORD)v29)
      {
        *(void *)&v5[v360] |= 0x40uLL;
        if (!v26) {
          goto LABEL_177;
        }
        goto LABEL_51;
      }

      int v39 = v24;
      uint64_t v40 = os_channel_get_next_slot(*(void *)&v5[v6[121]], v25, v367);
      if (!v40) {
        break;
      }
      uint64_t v26 = v40;
      *(void *)&v5[v360] |= 0x20uLL;
      uint64_t v357 = os_channel_slot_get_packet(*(void *)&v5[v6[121]], v40);
      uint64_t v41 = os_packet_get_next_buflet(v357, 0LL);
      v355 = (char *)os_buflet_get_object_address();
      uint64_t v356 = v41;
      unsigned int v42 = os_buflet_get_data_limit(v41);
      if (v42 >= 0x10000)
      {
        id v238 = sub_100070554();
        int v239 = _NRLogIsLevelEnabled(v238, 16LL);

        if (v239)
        {
          id v240 = sub_100070554();
          _NRLogWithArgs( v240,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: outputBufferLength <= 65535",  "",  "NRLinkNexusToLinkLoop",  3809);
        }

        goto LABEL_284;
      }

      LODWORD(v24) = v42;
LABEL_51:
      int v43 = v5[222];
      LODWORD(v359) = v24;
      if (!v43 && *(void *)(v5 + 991))
      {
        v5[222] = 1;
        ++*(void *)(v5 + 1007);
        if (gNRPacketLoggingEnabled)
        {
          uint64_t v58 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
          int v59 = _NRLogIsLevelEnabled(v58, 1LL);

          uint64_t v22 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          if (v59)
          {
            uint64_t v61 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v60);
            id v62 = [v5 copyDescription];
            _NRLogWithArgs( v61,  1LL,  "%s%.30s:%-4d %@: source-suspend: LinkOutput",  "",  "NRLinkSuspendLinkOutputSource",  815LL,  v62);

            uint64_t v22 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          }
        }

        dispatch_suspend(*(dispatch_object_t *)(v5 + 991));
        LODWORD(v24) = v359;
      }

      unint64_t v44 = (unsigned __int16)v24;
      unsigned int v45 = *(_DWORD *)(v5 + 287);
      uint64_t v46 = *(unsigned int *)&v5[v22[168]];
      unsigned int v47 = v45 - v46;
      else {
        unsigned int v48 = v47;
      }
      int v49 = v24;
      memcpy(v355, (const void *)(*(void *)(v5 + 447) + v46), (unsigned __int16)v48);
      *(_DWORD *)&v5[v22[168]] += (unsigned __int16)v48;
      *(void *)(v5 + 1383) += (unsigned __int16)v48;
      ++*(_DWORD *)(v5 + 295);
      uint64_t v50 = v25;
      uint64_t v25 = v26;
      uint64_t v51 = v358;
      if (v50 != v26) {
        uint64_t v51 = v358 + 1;
      }
      *(void *)&v5[v360] |= 0x100uLL;
      uint64_t v358 = v51;
      if (gNRPacketLoggingEnabled)
      {
        id v54 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v353 + 4), v4);
        int v55 = _NRLogIsLevelEnabled(v54, 1LL);

        uint64_t v51 = v358;
        if (v55)
        {
          __int16 v56 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v353 + 4), v4);
          id v57 = [v353 copyDescription];
          _NRLogWithArgs( v56,  1LL,  "%s%.30s:%-4d %@: wrote %u bytes from linkWriteBuffer to link, filledIn=%u handled=%u",  "",  "NRLinkNexusToLinkLoop",  3865LL,  v57,  (unsigned __int16)v48,  *(unsigned int *)(v353 + 287),  *(unsigned int *)(v353 + 291));

          uint64_t v51 = v358;
        }
      }

      uint64_t v23 = v48 + v23;
      BOOL v52 = (unsigned __int16)v23 == (unsigned __int16)v49;
      if ((unsigned __int16)v23 < (unsigned __int16)v49)
      {
        LODWORD(v24) = v49;
        id v6 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
        id v5 = v353;
        uint64_t v28 = v354;
        uint64_t v22 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
LABEL_84:
        if (!v28)
        {
          int v175 = v5[16];
          uint64_t v345 = v26;
          if (v175 == 8)
          {
            uint64_t v176 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
            int v177 = _NRLogIsLevelEnabled(v176, 17LL);

            if (v177)
            {
              uint64_t v178 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
              id v179 = [v5 copyDescription];
              _NRLogWithArgs(v178, 17LL, "%@: Tried to nexusToLinkLoop but _nexusInputRing is NULL", v179);
            }

            id v76 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            uint64_t v161 = v347;
            LODWORD(v24) = v359;
          }

          else
          {
            *(void *)&v5[v360] |= 0x400uLL;
            id v76 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
LABEL_225:
            uint64_t v161 = v347;
          }

          goto LABEL_184;
        }

        uint64_t v77 = os_channel_get_next_slot(v28, v352, v364);
        if (!v77)
        {
          ((void (*)(char *))v338)(v5);
          *(void *)&v5[v360] |= 0x800uLL;
          LODWORD(v75) = 31;
          int v339 = 1;
          id v76 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          uint64_t v24 = v359;
          goto LABEL_154;
        }

        int v78 = (unsigned __int16)v23;
        BOOL v340 = (unsigned __int16)v23 == 0;
        v341 = (void *)v77;
        uint64_t v79 = v358;
        if (!(_WORD)v23) {
          uint64_t v79 = v358 + 1;
        }
        uint64_t v344 = v79;
        ((void (*)(char *))v343)(v5);
        uint64_t v342 = v23;
        if (!gNRPacketLoggingEnabled)
        {
          uint64_t ESPSequenceNumberFromPacket = 0LL;
          goto LABEL_90;
        }

        uint64_t v351 = v25;
        uint64_t ESPSequenceNumberFromPacket = getESPSequenceNumberFromPacket(v366, v365);
        if (!gNRPacketLoggingEnabled) {
          goto LABEL_175;
        }
        uint64_t v123 = v26;
        getESPSPIFromPacket(v366, v365);
        if (!gNRPacketLoggingEnabled)
        {
          uint64_t v22 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
LABEL_175:
          uint64_t v25 = v351;
          LOWORD(v23) = v342;
          id v5 = v353;
          goto LABEL_90;
        }

        uint64_t v125 = v365;
        id v5 = v353;
        id v126 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v353 + 4), v124);
        int v127 = _NRLogIsLevelEnabled(v126, 1LL);

        LOWORD(v23) = v342;
        if (v127)
        {
          BOOL v129 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v353 + 4), v128);
          id v130 = [v353 copyDescription];
          _NRLogWithArgs( v129,  1LL,  "%s%.30s:%-4d %@: Sending ESP sequence number - to be sent: %u (%u bytes)",  "",  "NRLinkNexusToLinkLoop",  3918LL,  v130,  ESPSequenceNumberFromPacket,  v125);
        }

        uint64_t v22 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
        uint64_t v26 = v123;
        uint64_t v25 = v351;
LABEL_90:
        uint64_t v346 = nrMaxTLVLengthForPacket(v366, v365);
        __int128 v382 = 0u;
        __int128 v383 = 0u;
        __int128 v380 = 0u;
        __int128 v381 = 0u;
        __int128 v378 = 0u;
        __int128 v379 = 0u;
        __int128 v376 = 0u;
        __int128 v377 = 0u;
        __int128 v374 = 0u;
        __int128 v375 = 0u;
        __int128 v372 = 0u;
        __int128 v373 = 0u;
        __int128 v370 = 0u;
        __int128 v371 = 0u;
        uint64_t v24 = v359;
        __int128 v368 = 0u;
        __int128 v369 = 0u;
        if ((unsigned __int16)v359 <= (unsigned __int16)v23)
        {
          unsigned int v80 = 0;
          unsigned int v81 = 0;
        }

        else
        {
          *(void *)&__int128 v368 = &v355[(unsigned __int16)v23];
          unsigned int v80 = v44 - v78;
          DWORD2(v36_Block_object_dispose(va, 8) = v44 - v78;
          unsigned int v81 = 1;
        }

        if (v80 < v346)
        {
          uint64_t v351 = v25;
          uint64_t v82 = v26;
          uint64_t v83 = v81;
          uint64_t v345 = v82;
          unsigned int v84 = (unsigned int *)&v334[16 * v81];
          unsigned int v85 = v346;
          do
          {
            uint64_t v86 = os_channel_get_next_slot(*(void *)(v5 + 975), v82, &v361);
            if (!v86) {
              break;
            }
            uint64_t v82 = v86;
            uint64_t v87 = os_channel_slot_get_packet(*(void *)(v5 + 975), v86);
            uint64_t v88 = os_packet_get_next_buflet(v87, 0LL);
            uint64_t v89 = os_buflet_get_object_address();
            unsigned int v90 = os_buflet_get_data_limit(v88);
            if (v90 >= 0x10000)
            {
              if (qword_1001DC840 != -1) {
                dispatch_once(&qword_1001DC840, &stru_1001AEE08);
              }
              if (_NRLogIsLevelEnabled(qword_1001DC838, 16LL))
              {
                id v247 = sub_100070554();
                _NRLogWithArgs( v247,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: lookAheadLinkOutputBufferLength <= 65535",  "",  "NRLinkNexusToLinkLoop",  3946);
              }

              uint64_t v248 = _os_log_pack_size(12LL);
              id v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v249 = *__error();
              uint64_t i = _os_log_pack_fill( v235,  v248,  v249,  &_mh_execute_header,  "%{public}s Assertion Failed: lookAheadLinkOutputBufferLength <= 65535");
              goto LABEL_305;
            }

            *((void *)v84 - 1) = v89;
            if (!v90)
            {
              if (qword_1001DC840 != -1) {
                dispatch_once(&qword_1001DC840, &stru_1001AEE08);
              }
              if (_NRLogIsLevelEnabled(qword_1001DC838, 16LL))
              {
                id v250 = sub_100070554();
                _NRLogWithArgs( v250,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: lookAheadLinkOutputBufferLength > 0",  "",  "NRLinkNexusToLinkLoop",  3949);
              }

              uint64_t v251 = _os_log_pack_size(12LL);
              id v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v252 = *__error();
              uint64_t i = _os_log_pack_fill( v235,  v251,  v252,  &_mh_execute_header,  "%{public}s Assertion Failed: lookAheadLinkOutputBufferLength > 0");
              goto LABEL_305;
            }

            *unsigned int v84 = v90;
            *(void *)&v5[v360] |= 0x1000uLL;
            if (v83 == 15)
            {
              uint64_t v96 = (void *)createIOVecString(&v368, 16LL);
              sub_1000749CC(v5, @"NtL not enough ioVecs %@ for %u", v97, v98, v99, v100, v101, v102, (uint64_t)v96);

              LODWORD(v75) = 1;
              id v6 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              uint64_t v22 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              id v76 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              uint64_t v26 = v345;
              uint64_t v25 = v351;
              uint64_t v24 = v359;
              uint64_t v23 = v342;
              goto LABEL_153;
            }

            ++v83;
            v80 += v90;
            v84 += 4;
          }

          while (v80 < v85);
          LOWORD(v81) = v83;
          uint64_t v22 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          uint64_t v26 = v345;
          uint64_t v25 = v351;
          uint64_t v24 = v359;
        }

        if (v80 < v346)
        {
          *(void *)&v5[v360] |= 0x2000uLL;
          id v6 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          if (v5[222])
          {
            id v76 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            uint64_t v23 = v342;
            if (*(void *)(v5 + 991))
            {
              v5[222] = 0;
              ++*(void *)(v5 + 1007);
              if (gNRPacketLoggingEnabled)
              {
                id v142 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
                int v143 = _NRLogIsLevelEnabled(v142, 1LL);

                uint64_t v22 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                if (v143)
                {
                  BOOL v145 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v144);
                  id v146 = [v5 copyDescription];
                  _NRLogWithArgs( v145,  1LL,  "%s%.30s:%-4d %@: source-resume: LinkOutput",  "",  "NRLinkResumeLinkOutputSource",  823LL,  v146);

                  uint64_t v22 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                }
              }

              dispatch_resume(*(dispatch_object_t *)(v5 + 991));
              LODWORD(v75) = 31;
              uint64_t v24 = v359;
            }

            else
            {
              LODWORD(v75) = 31;
            }
          }

          else
          {
            LODWORD(v75) = 31;
            id v76 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            uint64_t v23 = v342;
          }

          goto LABEL_153;
        }

        if (!(void)v368)
        {
          id v259 = sub_100070554();
          int v260 = _NRLogIsLevelEnabled(v259, 16LL);

          if (v260)
          {
            id v261 = sub_100070554();
            uint64_t v262 = (void *)createIOVecString(&v368, (unsigned __int16)v81);
            _NRLogWithArgs( v261,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[0].buf != ((void *)0); We have enough content but first ioVec is NULL: %@",
              "",
              "NRLinkNexusToLinkLoop",
              3978LL,
              v262);
          }

          uint64_t v263 = _os_log_pack_size(22LL);
          id v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v264 = __error();
          uint64_t v265 = _os_log_pack_fill( v235,  v263,  *v264,  &_mh_execute_header,  "%{public}s Assertion Failed: ioVecs[0].buf != ((void *)0); We have enough content but first ioVec is NULL: %@");
          uint64_t v266 = createIOVecString(&v368, (unsigned __int16)v81);
          *(_DWORD *)uint64_t v265 = 136446466;
          *(void *)(v265 + 4) = "NRLinkNexusToLinkLoop";
          *(_WORD *)(v265 + 12) = 2112;
          *(void *)(v265 + 14) = v266;
          goto LABEL_306;
        }

        if (gNRPacketLoggingEnabled)
        {
          id v131 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
          int v132 = _NRLogIsLevelEnabled(v131, 1LL);

          if (v132)
          {
            id v134 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v133);
            id v135 = [v5 copyDescription];
            unsigned int v136 = getDSCPFromPacket(v366, v365);
            _NRLogWithArgs(v134, 1LL, "%s%.30s:%-4d %@: DSCP: %u", "", "NRLinkNexusToLinkLoop", 3982LL, v135, v136);
          }
        }

        unsigned int v91 = nrPacketToTLV(v366, v365, &v368, (unsigned __int16)v81, v5 + 1951, v5 + 1967);
        unsigned int v92 = v91;
        int v93 = *(unsigned __int8 *)v368;
        uint64_t v94 = v344;
        uint64_t v24 = v359;
        switch(*(_BYTE *)v368)
        {
          case 'd':
            uint64_t v95 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_ESP;
            goto LABEL_128;
          case 'e':
            uint64_t v95 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_ESP_ECT0;
            goto LABEL_128;
          case 'f':
            uint64_t v95 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_TCP;
            goto LABEL_128;
          case 'g':
            uint64_t v95 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_TCP_ECT0;
            goto LABEL_128;
          case 'h':
            uint64_t v95 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_ESP_ClassC;
            goto LABEL_128;
          case 'i':
            uint64_t v95 = &OBJC_IVAR___NRLinkBluetooth__sentKnownIPv6Hdr_ESP_ClassC_ECT0;
            goto LABEL_128;
          default:
            uint64_t v24 = v359;
            if (v93 == 2)
            {
              uint64_t v95 = &OBJC_IVAR___NRLinkBluetooth__sentUncompressedIP;
            }

            else
            {
              if (v93 != 3) {
                goto LABEL_129;
              }
              uint64_t v95 = &OBJC_IVAR___NRLinkBluetooth__sentEncapsulated6LoWPAN;
            }

LABEL_128:
            ++*(void *)&v5[*v95];
LABEL_129:
            *(void *)(v5 + 1383) += v91;
            unsigned int v103 = (unsigned __int16)(v24 - v342);
            if (v91 <= v103)
            {
              uint64_t v114 = v342 + v91;
              goto LABEL_143;
            }

            uint64_t v104 = v26;
            *(void *)&v5[v360] |= 0x4000uLL;
            if (gNRPacketLoggingEnabled)
            {
              id v137 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
              int v138 = _NRLogIsLevelEnabled(v137, 1LL);

              if (v138)
              {
                uint64_t v140 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v139);
                id v141 = [v5 copyDescription];
                _NRLogWithArgs( v140,  1LL,  "%s%.30s:%-4d %@: Sending ESP sequence number %u (2)",  "",  "NRLinkNexusToLinkLoop",  4025LL,  v141,  ESPSequenceNumberFromPacket);
              }
            }

            uint64_t v385 = v94;
            os_buflet_set_data_length(v356, v44);
            os_packet_set_flow_uuid(v357, &v384);
            int v105 = os_packet_finalize(v357);
            if (v105)
            {
              int v292 = v105;
              id v325 = sub_100070554();
              int v326 = _NRLogIsLevelEnabled(v325, 16LL);

              if (v326)
              {
                id v327 = sub_100070554();
                _NRLogWithArgs( v327,  16LL,  "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d",  "",  "NRLinkNexusToLinkLoop",  4029,  v292);
              }

LABEL_331:
              id v5 = (char *)_os_log_pack_size(18LL);
              v296 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v297 = *__error();
              uint64_t v298 = _os_log_pack_fill(v296, v5, v297, &_mh_execute_header, "%{public}s os_packet_finalize returned %d");
              *(_DWORD *)uint64_t v298 = 136446466;
              *(void *)(v298 + 4) = "NRLinkNexusToLinkLoop";
              *(_WORD *)(v298 + 12) = 1024;
              *(_DWORD *)(v298 + 14) = v292;
              id v299 = sub_100070554();
              _NRLogAbortWithPack(v299, v296);
LABEL_332:
              id v300 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
              int v301 = _NRLogIsLevelEnabled(v300, 1LL);

              if (v301)
              {
                v303 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v302);
                id v304 = [v5 copyDescription];
                _NRLogWithArgs( v303,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusInput",  "",  "NRLinkResumeNexusInputSource",  842LL,  v304);
              }

LABEL_261:
              dispatch_resume(*(dispatch_object_t *)&v5[*(int *)(v44 + 1004)]);
              goto LABEL_262;
            }

            uint64_t v94 = v358 + v340 + 1;
            while (1)
            {
              uint64_t v106 = os_channel_get_next_slot(*(void *)(v5 + 975), v104, v367);
              if (!v106)
              {
                if (qword_1001DC840 != -1) {
                  dispatch_once(&qword_1001DC840, &stru_1001AEE08);
                }
                if (_NRLogIsLevelEnabled(qword_1001DC838, 16LL))
                {
                  id v243 = sub_100070554();
                  _NRLogWithArgs( v243,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (curLinkOutputSlot) != ((void *)0)",  "",  "NRLinkNexusToLinkLoop",  4037);
                }

                uint64_t v244 = _os_log_pack_size(12LL);
                id v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                uint64_t v245 = *__error();
                uint64_t i = _os_log_pack_fill( v235,  v244,  v245,  &_mh_execute_header,  "%{public}s Assertion Failed: (curLinkOutputSlot) != ((void *)0)");
                goto LABEL_305;
              }

              uint64_t v26 = v106;
              uint64_t v357 = os_channel_slot_get_packet(*(void *)(v5 + 975), v106);
              unint64_t v44 = os_packet_get_next_buflet(v357, 0LL);
              v355 = (char *)os_buflet_get_object_address();
              uint64_t v356 = v44;
              uint64_t v107 = os_buflet_get_data_limit(v44);
              if (v107 >= 0x10000)
              {
                if (qword_1001DC840 != -1) {
                  dispatch_once(&qword_1001DC840, &stru_1001AEE08);
                }
                if (_NRLogIsLevelEnabled(qword_1001DC838, 16LL))
                {
                  id v246 = sub_100070554();
                  _NRLogWithArgs( v246,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: outputBufferLength <= 65535",  "",  "NRLinkNexusToLinkLoop",  4044);
                }

LABEL_284:
                uint64_t v241 = _os_log_pack_size(12LL);
                id v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                uint64_t v242 = *__error();
                uint64_t i = _os_log_pack_fill( v235,  v241,  v242,  &_mh_execute_header,  "%{public}s Assertion Failed: outputBufferLength <= 65535");
                goto LABEL_305;
              }

              uint64_t v24 = v107;
              unsigned int v108 = v107 + v103;
              uint64_t v104 = v26;
              *(void *)&v5[v360] |= 0x8000uLL;
              if (gNRPacketLoggingEnabled)
              {
                uint64_t v110 = v107;
                unint64_t v44 = _NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
                int v111 = _NRLogIsLevelEnabled(v44, 1LL);

                uint64_t v24 = v110;
                if (v111)
                {
                  unint64_t v44 = _NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v112);
                  id v113 = [v5 copyDescription];
                  _NRLogWithArgs( v44,  1LL,  "%s%.30s:%-4d %@: Sending ESP sequence number %u (3)",  "",  "NRLinkNexusToLinkLoop",  4057LL,  v113,  ESPSequenceNumberFromPacket);

                  uint64_t v24 = v110;
                }
              }

              uint64_t v385 = v94;
              os_buflet_set_data_length(v356, v24);
              os_packet_set_flow_uuid(v357, &v384);
              int v109 = os_packet_finalize(v357);
              ++v94;
              unsigned int v103 = v108;
              if (v109)
              {
                int v292 = v109;
                id v293 = sub_100070554();
                int v294 = _NRLogIsLevelEnabled(v293, 16LL);

                if (v294)
                {
                  id v295 = sub_100070554();
                  _NRLogWithArgs( v295,  16LL,  "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d",  "",  "NRLinkNexusToLinkLoop",  4061,  v292);
                }

                goto LABEL_331;
              }
            }

            uint64_t v114 = v92 - v103;
LABEL_143:
            uint64_t v344 = v94;
            __int128 v115 = v335;
            ++*(void *)v336;
            *(void *)v115 += v365;
            *(void *)&v5[v360] |= 0x10000uLL;
            uint64_t v75 = *(void *)(v5 + 1919);
            uint64_t v22 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            id v6 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            if (!v75)
            {
              uint64_t v25 = v26;
              id v352 = v341;
              id v76 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              uint64_t v23 = v114;
              goto LABEL_153;
            }

            id v76 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            uint64_t v75 = *(void *)(v5 + 1927);
            uint64_t v23 = v114;
            if (!v75) {
              goto LABEL_152;
            }
            v5[257] = v5[257] % v5[256];
            uint64_t v116 = *(void *)(v5 + 1927);
            __int128 v117 = (void *)(v116 + 8LL * v5[257]);
            if ((unint64_t)(v117 + 1) <= v116 + 8 * (unint64_t)v5[256])
            {
              LODWORD(v75) = 0;
              if ((v117 & 7) == 0)
              {
                void *v117 = *(void *)(v5 + 1919);
                ++v5[257];
                *(void *)(v5 + 1919) = 0LL;
              }

LABEL_152:
              uint64_t v25 = v26;
              id v352 = v341;
              goto LABEL_153;
            }

            uint64_t v118 = v24;
            __int128 v119 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
            int v120 = _NRLogIsLevelEnabled(v119, 17LL);

            if (v120)
            {
              unsigned int v121 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
              id v122 = [v5 copyDescription];
              _NRLogWithArgs( v121,  17LL,  "%@: invalid index for ntl log list (curIdx: %u)",  v122,  v5[257]);
            }

            LODWORD(v75) = 0;
            uint64_t v25 = v26;
            id v352 = v341;
            uint64_t v22 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            uint64_t v24 = v118;
            uint64_t v23 = v114;
LABEL_153:
            uint64_t v358 = v344;
LABEL_154:
            if ((_DWORD)v75 && (_DWORD)v75 != 30)
            {
              if ((_DWORD)v75 == 31)
              {
                uint64_t v345 = v26;
                goto LABEL_225;
              }

              goto LABEL_25;
            }

            break;
        }

        goto LABEL_27;
      }

      id v6 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      id v5 = v353;
      uint64_t v28 = v354;
      if (!v52)
      {
        if (qword_1001DC840 != -1) {
          dispatch_once(&qword_1001DC840, &stru_1001AEE08);
        }
        id v231 = (id)qword_1001DC838;
        int v232 = _NRLogIsLevelEnabled(v231, 16LL);

        if (v232)
        {
          if (qword_1001DC840 != -1) {
            dispatch_once(&qword_1001DC840, &stru_1001AEE08);
          }
          id v233 = (id)qword_1001DC838;
          _NRLogWithArgs( v233,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: curLinkOutputSlotPartialBytesAlreadyWritten == linkOutputBufferLength",  "",  "NRLinkNexusToLinkLoop",  3868);
        }

        uint64_t v234 = _os_log_pack_size(12LL);
        id v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v236 = *__error();
        uint64_t i = _os_log_pack_fill( v235,  v234,  v236,  &_mh_execute_header,  "%{public}s Assertion Failed: curLinkOutputSlotPartialBytesAlreadyWritten == linkOutputBufferLength");
        goto LABEL_305;
      }

      os_buflet_set_data_length(v356, v44);
      uint64_t v385 = v51;
      os_packet_set_flow_uuid(v357, &v384);
      int v53 = os_packet_finalize(v357);
      if (v53)
      {
        int v277 = v53;
        id v278 = sub_100070554();
        int v279 = _NRLogIsLevelEnabled(v278, 16LL);

        if (v279)
        {
          id v280 = sub_100070554();
          _NRLogWithArgs( v280,  16LL,  "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d",  "",  "NRLinkNexusToLinkLoop",  3876,  v277);
        }

        goto LABEL_321;
      }

      uint64_t v23 = 0LL;
      *(void *)&v353[v360] |= 0x200uLL;
      uint64_t v22 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      uint64_t v24 = v359;
    }

    LODWORD(v29) = 0;
    LODWORD(v24) = v39;
LABEL_177:
    int v160 = v24;
    uint64_t v161 = v347;
    if (v5[222] && *(void *)(v5 + 991))
    {
      v5[222] = 0;
      ++*(void *)(v5 + 1007);
      if (gNRPacketLoggingEnabled)
      {
        uint64_t v217 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
        int v218 = _NRLogIsLevelEnabled(v217, 1LL);

        uint64_t v161 = v347;
        if (v218)
        {
          int v220 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v219);
          id v221 = [v5 copyDescription];
          _NRLogWithArgs( v220,  1LL,  "%s%.30s:%-4d %@: source-resume: LinkOutput",  "",  "NRLinkResumeLinkOutputSource",  823LL,  v221);

          uint64_t v161 = v347;
        }
      }

      dispatch_resume(*(dispatch_object_t *)(v5 + 991));
    }

    ((void (*)(char *))v343)(v5);
    *(void *)&v5[v360] |= 0x80uLL;
    if (gNRPacketLoggingEnabled)
    {
      int v180 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
      int v181 = _NRLogIsLevelEnabled(v180, 1LL);

      id v76 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      if (v181)
      {
        v182 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
        id v183 = [v5 copyDescription];
        _NRLogWithArgs(v182, 1LL, "%s%.30s:%-4d %@: no link output slot", "", "NRLinkNexusToLinkLoop", 3823LL, v183);
      }

      uint64_t v345 = 0LL;
      uint64_t v161 = v347;
    }

    else
    {
      uint64_t v345 = 0LL;
      id v76 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
    }

    LODWORD(v24) = v160;
    LODWORD(v23) = v29;
LABEL_184:
    if (v25)
    {
      if (v345 != v25) {
        goto LABEL_307;
      }
      uint64_t v347 = v161;
      uint64_t v162 = 0x40000LL;
      if ((unsigned __int16)v23 != (unsigned __int16)v24 && (unsigned __int16)v23 != 0)
      {
        uint64_t v162 = 0x20000LL;
        unint64_t v44 = v23;
      }

      else
      {
        unint64_t v44 = v24;
      }

      *(void *)(v5 + 1919) |= v162;
      if (gNRPacketLoggingEnabled)
      {
        int v196 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
        int v197 = _NRLogIsLevelEnabled(v196, 1LL);

        if (v197)
        {
          id v199 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v198);
          id v200 = [v5 copyDescription];
          _NRLogWithArgs( v199,  1LL,  "%s%.30s:%-4d %@: Sending ESP sequence number %u (4)",  "",  "NRLinkNexusToLinkLoop",  4094LL,  v200,  ESPSequenceNumberFromPacket);
        }
      }

      uint64_t v385 = v358;
      os_buflet_set_data_length(v356, (unsigned __int16)v44);
      os_packet_set_flow_uuid(v357, &v384);
      int v163 = os_packet_finalize(v357);
      if (v163)
      {
        int v292 = v163;
        id v322 = sub_100070554();
        int v323 = _NRLogIsLevelEnabled(v322, 16LL);

        if (v323)
        {
          id v324 = sub_100070554();
          _NRLogWithArgs( v324,  16LL,  "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d",  "",  "NRLinkNexusToLinkLoop",  4098,  v292);
        }

        goto LABEL_331;
      }

      unsigned int v165 = *(_DWORD *)(v5 + 287);
      unsigned int v166 = *(_DWORD *)(v5 + 291);
      if (v165 <= v166)
      {
        if (v165 != v166)
        {
          id v267 = sub_100070554();
          int v268 = _NRLogIsLevelEnabled(v267, 16LL);

          if (v268)
          {
            id v269 = sub_100070554();
            _NRLogWithArgs( v269,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: self->_filledInLinkWriteBufferBytes == self->_handledLinkWriteBufferBytes",  "",  "NRLinkNexusToLinkLoop",  4112);
          }

          uint64_t v270 = _os_log_pack_size(12LL);
          id v235 = (char *)&v331 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v271 = *__error();
          uint64_t i = _os_log_pack_fill( v235,  v270,  v271,  &_mh_execute_header,  "%{public}s Assertion Failed: self->_filledInLinkWriteBufferBytes == self->_handledLinkWriteBufferBytes");
          goto LABEL_305;
        }

        if (gNRPacketLoggingEnabled)
        {
          if (v165)
          {
            *(void *)(v5 + 1919) |= 0x100000uLL;
            v227 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v164);
            int v228 = _NRLogIsLevelEnabled(v227, 1LL);

            if (v228)
            {
              uint64_t v229 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v164);
              id v230 = [v5 copyDescription];
              _NRLogWithArgs( v229,  1LL,  "%s%.30s:%-4d %@: resetting the linkWriteBuffer from filledIn=%u handled=%u",  "",  "NRLinkNexusToLinkLoop",  4115LL,  v230,  *(unsigned int *)(v5 + 287),  *(unsigned int *)(v5 + 291));
            }
          }
        }

        *(_DWORD *)(v5 + 287) = 0;
      }

      else
      {
        *(void *)(v5 + 1919) |= 0x80000uLL;
        if (gNRPacketLoggingEnabled)
        {
          v222 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v164);
          int v223 = _NRLogIsLevelEnabled(v222, 1LL);

          if (v223)
          {
            uint64_t v225 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v224);
            id v226 = [v5 copyDescription];
            _NRLogWithArgs( v225,  1LL,  "%s%.30s:%-4d %@: memmoving the linkWriteBuffer from filledIn=%u handled=%u",  "",  "NRLinkNexusToLinkLoop",  4106LL,  v226,  *(unsigned int *)(v5 + 287),  *(unsigned int *)(v5 + 291));
          }
        }

        memmove( *(void **)(v5 + 447),  (const void *)(*(void *)(v5 + 447) + *(unsigned int *)(v5 + 291)),  (*(_DWORD *)(v5 + 287) - *(_DWORD *)(v5 + 291)));
        *(_DWORD *)(v5 + 287) -= *(_DWORD *)(v5 + 291);
      }

      *(_DWORD *)(v5 + 291) = 0;
      *(void *)(v5 + 1919) |= 0x200000uLL;
      uint64_t v167 = v345;
      if (gNRPacketLoggingEnabled)
      {
        uint64_t v201 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v164);
        int v202 = _NRLogIsLevelEnabled(v201, 1LL);

        if (v202)
        {
          int v204 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v203);
          id v205 = [v5 copyDescription];
          _NRLogWithArgs( v204,  1LL,  "%s%.30s:%-4d %@: advancing past linkOutputSlot=%p and syncing link output",  "",  "NRLinkNexusToLinkLoop",  4121LL,  v205,  v345);
        }

        uint64_t v167 = v345;
        if (gNRPacketLoggingEnabled)
        {
          uint64_t v206 = objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
          id v207 = *(void **)(v5 + 1687);
          *(void *)(v5 + 1687) = v206;
        }
      }

      os_channel_advance_slot(*(void *)&v5[v6[121]], v167);
      os_channel_sync(*(void *)(v5 + 959), 0LL);
      ++*(void *)(v5 + 1431);
      uint64_t v161 = v347;
    }

    if (v161)
    {
      *(void *)(v5 + 1919) |= 0x800000uLL;
      if (gNRPacketLoggingEnabled)
      {
        uint64_t v184 = v161;
        uint64_t v185 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
        int v186 = _NRLogIsLevelEnabled(v185, 1LL);

        if (v186)
        {
          uint64_t v188 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v187);
          id v189 = [v5 copyDescription];
          _NRLogWithArgs( v188,  1LL,  "%s%.30s:%-4d %@: DatagramLink:advancing past linkOutputSlot=%p and syncing datagram link output",  "",  "NRLinkNexusToLinkLoop",  4132LL,  v189,  v184);
        }

        uint64_t v161 = v184;
        if (gNRPacketLoggingEnabled)
        {
          uint64_t v190 = objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
          v191 = *(void **)(v5 + 1703);
          *(void *)(v5 + 1703) = v190;
        }
      }

      os_channel_advance_slot(*(void *)(v5 + 1055), v161);
      os_channel_sync(*(void *)(v5 + 1039), 0LL);
      ++*(void *)(v5 + 1447);
    }

    uint64_t v168 = v161;
    if (v352)
    {
      if (v354)
      {
        *(void *)(v5 + 1919) |= 0x1000000uLL;
        if (gNRPacketLoggingEnabled)
        {
          int v208 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
          int v209 = _NRLogIsLevelEnabled(v208, 1LL);

          if (v209)
          {
            id v211 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v210);
            id v212 = [v5 copyDescription];
            _NRLogWithArgs( v211,  1LL,  "%s%.30s:%-4d %@: advancing past nexusInputSlot=%p and syncing nexus input",  "",  "NRLinkNexusToLinkLoop",  4142LL,  v212,  v352);
          }

          if (gNRPacketLoggingEnabled)
          {
            uint64_t v213 = objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
            uint64_t v214 = *(void **)(v5 + 1663);
            *(void *)(v5 + 1663) = v213;
          }
        }

        os_channel_advance_slot(v354, v352);
        os_channel_sync(v350, 1LL);
        ++*(void *)v337;
        if (gNRPacketLoggingEnabled)
        {
          v215 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
          int v216 = _NRLogIsLevelEnabled(v215, 1LL);

          if (v216)
          {
            v194 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
            id v195 = [v5 copyDescription];
            _NRLogWithArgs( v194,  1LL,  "%s%.30s:%-4d %@: Served %llu packets, %llu bytes",  "",  "NRLinkNexusToLinkLoop",  4148LL,  v195,  *(void *)v336 - v332,  *(void *)v335 - v333);
LABEL_247:
          }
        }
      }

      else
      {
        int v192 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
        int v193 = _NRLogIsLevelEnabled(v192, 17LL);

        if (v193)
        {
          v194 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
          id v195 = [v5 copyDescription];
          _NRLogWithArgs(v194, 17LL, "%@: Tried to sync nexus input but _nexusInputRing is NULL", v195);
          goto LABEL_247;
        }
      }
    }

    *(void *)(v5 + 951) = v358;
    if (*(void *)(v5 + 1919) && *(void *)&v5[v76[244]])
    {
      v5[257] = v5[257] % v5[256];
      uint64_t v169 = *(void *)&v5[v76[244]];
      v170 = (void *)(v169 + 8LL * v5[257]);
      if ((unint64_t)(v170 + 1) <= v169 + 8 * (unint64_t)v5[256])
      {
        if ((v170 & 7) == 0)
        {
          void *v170 = *(void *)(v5 + 1919);
          ++v5[257];
          *(void *)(v5 + 1919) = 0LL;
        }
      }

      else
      {
        id v171 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
        int v172 = _NRLogIsLevelEnabled(v171, 17LL);

        if (v172)
        {
          uint64_t v173 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
          id v174 = [v5 copyDescription];
          _NRLogWithArgs(v173, 17LL, "%@: invalid index for ntl log list (curIdx: %u)", v174, v5[257]);
        }
      }
    }

    LODWORD(v75) = 0;
    if (v352)
    {
      uint64_t v22 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      goto LABEL_25;
    }

    uint64_t v22 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
    if (v25 || v168)
    {
LABEL_25:
      if ((_DWORD)v75) {
        goto LABEL_266;
      }
      continue;
    }

    break;
  }

  if ((v339 & 1) != 0)
  {
    if (!*(void *)(v5 + 1111))
    {
      if (v5[214] && *(void *)(v5 + 551))
      {
        v5[214] = 0;
        ++*(void *)(v5 + 567);
        if (gNRPacketLoggingEnabled)
        {
          uint64_t v312 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
          int v313 = _NRLogIsLevelEnabled(v312, 1LL);

          if (v313)
          {
            char v315 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v314);
            id v316 = [v5 copyDescription];
            _NRLogWithArgs( v315,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusVOInput",  "",  "NRLinkResumeNexusVOInputSource",  844LL,  v316);
          }
        }

        dispatch_resume(*(dispatch_object_t *)(v5 + 551));
      }

      if (v5[216] && *(void *)(v5 + 695))
      {
        v5[216] = 0;
        ++*(void *)(v5 + 711);
        if (gNRPacketLoggingEnabled)
        {
          uint64_t v317 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
          int v318 = _NRLogIsLevelEnabled(v317, 1LL);

          if (v318)
          {
            uint64_t v320 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v319);
            id v321 = [v5 copyDescription];
            _NRLogWithArgs( v320,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusVIInput",  "",  "NRLinkResumeNexusVIInputSource",  846LL,  v321);
          }
        }

        dispatch_resume(*(dispatch_object_t *)(v5 + 695));
      }
    }

    if (v5[212])
    {
      unint64_t v44 = (unint64_t)&OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      if (*(void *)(v5 + 391))
      {
        v5[212] = 0;
        ++*(void *)(v5 + 415);
        if (gNRPacketLoggingEnabled) {
          goto LABEL_332;
        }
        goto LABEL_261;
      }
    }

LABEL_262:
    if (v5[218] && *(void *)(v5 + 839))
    {
      v5[218] = 0;
      ++*(void *)(v5 + 855);
      if (gNRPacketLoggingEnabled)
      {
        id v305 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v4);
        int v306 = _NRLogIsLevelEnabled(v305, 1LL);

        if (v306)
        {
          id v308 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v5 + 4), v307);
          id v309 = [v5 copyDescription];
          _NRLogWithArgs( v308,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusBKInput",  "",  "NRLinkResumeNexusBKInputSource",  848LL,  v309);
        }
      }

      dispatch_resume(*(dispatch_object_t *)(v5 + 839));
    }
  }

LABEL_266:
}
                        }

                        else
                        {
                          int v313 = v287;
                          if (v285[296] != (__objc2_meth_list *)-1LL) {
                            dispatch_once(&qword_1001DC940, &stru_1001AF878);
                          }
                          uint64_t v314 = (id)qword_1001DC938;
                          char v315 = _NRLogIsLevelEnabled(v314, 17LL);

                          id v287 = v313;
                          if (v315)
                          {
                            if (v285[296] != (__objc2_meth_list *)-1LL) {
                              dispatch_once(&qword_1001DC940, &stru_1001AF878);
                            }
                            v303 = (id)qword_1001DC938;
                            _NRLogWithArgs( v303,  17LL,  "%s called with null resolvedEndpoints",  "-[NRApplicationServiceManager reportResolveResultForASName:endpoint:]");
                            goto LABEL_266;
                          }
                        }
                      }

                      int v289 = v446;
                      v215 = v449;
                      int v284 = v438;
                      int v277 = v440;
                    }
                  }

                  v286 = v462 + 1;
                }

                while ((id)(v462 + 1) != v456);
                v456 = [v284 countByEnumeratingWithState:&v502 objects:&v498 count:16];
              }

              while (v456);
            }

            sub_1000DED4C((uint64_t)self, 1);
            uint64_t v7 = v437;
            uint64_t v276 = v432;
          }

          uint64_t v106 = v434;
        }

        id v316 = sub_1000229A0(v106, 23LL);
        uint64_t v317 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v316, "firstObject"));

        if (v317)
        {
          int v318 = sub_1000229A0(v106, 23LL);
          uint64_t v319 = (void *)objc_claimAutoreleasedReturnValue(-[NSMutableArray firstObject](v318, "firstObject"));

          objc_opt_self(&OBJC_CLASS___NRLinkDirector);
          if (qword_1001DC878 != -1) {
            dispatch_once(&qword_1001DC878, &stru_1001AEED0);
          }
          uint64_t v320 = (id)qword_1001DC870;
          id v321 = self->_nrUUID;
          sub_1000AF930((uint64_t)v320, v319, v321);
        }

        goto LABEL_318;
      }

      block = 0LL;
      [v108 getBytes:&block length:8];
      int v109 = (char)block;
      uint64_t v110 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, self->_nrUUID);
      int v111 = v110;
      if (v110 && *((unsigned __int16 *)v110 + 14) >= 0x16u)
      {
        if ((v109 & 4) == 0)
        {
          if ((v109 & 8) == 0) {
            goto LABEL_108;
          }
          if (qword_1001DC8F0 != -1) {
            dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
          }
          if (qword_1001DC8F0 != -1) {
            dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
          }
          uint64_t v112 = qword_1001DC8E8;
          id v113 = 3977;
          goto LABEL_89;
        }

        if (qword_1001DC8F0 != -1) {
          dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC8E8, 1LL))
        {
          if (qword_1001DC8F0 != -1) {
            dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
          }
          uint64_t v116 = qword_1001DC8E8;
          __int128 v117 = 3974;
LABEL_104:
          _NRLogWithArgs( v116,  1LL,  "%s%.30s:%-4d processing request flag for starting immediate net-info updates",  "",  "-[NRDDeviceConductor processReceivedRequestFlags:]",  v117);
        }
      }

      else
      {
        if ((v109 & 2) == 0)
        {
          if ((v109 & 4) == 0) {
            goto LABEL_108;
          }
          if (qword_1001DC8F0 != -1) {
            dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
          }
          if (qword_1001DC8F0 != -1) {
            dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
          }
          uint64_t v112 = qword_1001DC8E8;
          id v113 = 3985;
LABEL_89:
          _NRLogWithArgs( v112,  1LL,  "%s%.30s:%-4d processing request flag for stopping immediate net-info updates",  "",  "-[NRDDeviceConductor processReceivedRequestFlags:]",  v113);
LABEL_90:
          netInfo = self->_netInfo;
          if (netInfo)
          {
            __int128 v115 = 0;
LABEL_107:
            netInfo->_disableCoalescing = v115;
            goto LABEL_108;
          }

          goto LABEL_108;
        }

        if (qword_1001DC8F0 != -1) {
          dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC8E8, 1LL))
        {
          if (qword_1001DC8F0 != -1) {
            dispatch_once(&qword_1001DC8F0, &stru_1001AF698);
          }
          uint64_t v116 = qword_1001DC8E8;
          __int128 v117 = 3982;
          goto LABEL_104;
        }
      }

      netInfo = self->_netInfo;
      if (netInfo)
      {
        __int128 v115 = 1;
        goto LABEL_107;
      }

void sub_10007419C(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 212) && *(void *)(a1 + 391))
  {
    *(_BYTE *)(a1 + 212) = 0;
    ++*(void *)(a1 + 415);
    if (gNRPacketLoggingEnabled)
    {
      id v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1LL);

      if (IsLevelEnabled)
      {
        id v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
        id v7 = [(id)a1 copyDescription];
        _NRLogWithArgs( v6,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusInput",  "",  "NRLinkResumeNexusInputSource",  842LL,  v7);
      }
    }

    dispatch_resume(*(dispatch_object_t *)(a1 + 391));
  }

void sub_1000742A0(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 218) && *(void *)(a1 + 839))
  {
    *(_BYTE *)(a1 + 21_Block_object_dispose(va, 8) = 0;
    ++*(void *)(a1 + 855);
    if (gNRPacketLoggingEnabled)
    {
      id v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1LL);

      if (IsLevelEnabled)
      {
        id v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
        id v7 = [(id)a1 copyDescription];
        _NRLogWithArgs( v6,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusBKInput",  "",  "NRLinkResumeNexusBKInputSource",  848LL,  v7);
      }
    }

    dispatch_resume(*(dispatch_object_t *)(a1 + 839));
  }

void sub_1000743A4(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 216) && *(void *)(a1 + 695))
  {
    *(_BYTE *)(a1 + 216) = 0;
    ++*(void *)(a1 + 711);
    if (gNRPacketLoggingEnabled)
    {
      id v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1LL);

      if (IsLevelEnabled)
      {
        id v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
        id v7 = [(id)a1 copyDescription];
        _NRLogWithArgs( v6,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusVIInput",  "",  "NRLinkResumeNexusVIInputSource",  846LL,  v7);
      }
    }

    dispatch_resume(*(dispatch_object_t *)(a1 + 695));
  }

void sub_1000744A8(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 214) && *(void *)(a1 + 551))
  {
    *(_BYTE *)(a1 + 214) = 0;
    ++*(void *)(a1 + 567);
    if (gNRPacketLoggingEnabled)
    {
      id v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1LL);

      if (IsLevelEnabled)
      {
        id v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
        id v7 = [(id)a1 copyDescription];
        _NRLogWithArgs( v6,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusVOInput",  "",  "NRLinkResumeNexusVOInputSource",  844LL,  v7);
      }
    }

    dispatch_resume(*(dispatch_object_t *)(a1 + 551));
  }

void sub_1000745AC(uint64_t a1, uint64_t a2)
{
  if (!*(_BYTE *)(a1 + 212) && *(void *)(a1 + 391))
  {
    *(_BYTE *)(a1 + 212) = 1;
    ++*(void *)(a1 + 415);
    if (gNRPacketLoggingEnabled)
    {
      id v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1LL);

      if (IsLevelEnabled)
      {
        id v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
        id v7 = [(id)a1 copyDescription];
        _NRLogWithArgs( v6,  1LL,  "%s%.30s:%-4d %@: source-suspend: NexusInput",  "",  "NRLinkSuspendNexusInputSource",  832LL,  v7);
      }
    }

    dispatch_suspend(*(dispatch_object_t *)(a1 + 391));
  }

void sub_1000746B4(uint64_t a1, uint64_t a2)
{
  if (!*(_BYTE *)(a1 + 218) && *(void *)(a1 + 839))
  {
    *(_BYTE *)(a1 + 21_Block_object_dispose(va, 8) = 1;
    ++*(void *)(a1 + 855);
    if (gNRPacketLoggingEnabled)
    {
      id v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1LL);

      if (IsLevelEnabled)
      {
        id v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
        id v7 = [(id)a1 copyDescription];
        _NRLogWithArgs( v6,  1LL,  "%s%.30s:%-4d %@: source-suspend: NexusBKInput",  "",  "NRLinkSuspendNexusBKInputSource",  838LL,  v7);
      }
    }

    dispatch_suspend(*(dispatch_object_t *)(a1 + 839));
  }

void sub_1000747BC(uint64_t a1, uint64_t a2)
{
  if (!*(_BYTE *)(a1 + 216) && *(void *)(a1 + 695))
  {
    *(_BYTE *)(a1 + 216) = 1;
    ++*(void *)(a1 + 711);
    if (gNRPacketLoggingEnabled)
    {
      id v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1LL);

      if (IsLevelEnabled)
      {
        id v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
        id v7 = [(id)a1 copyDescription];
        _NRLogWithArgs( v6,  1LL,  "%s%.30s:%-4d %@: source-suspend: NexusVIInput",  "",  "NRLinkSuspendNexusVIInputSource",  836LL,  v7);
      }
    }

    dispatch_suspend(*(dispatch_object_t *)(a1 + 695));
  }

void sub_1000748C4(uint64_t a1, uint64_t a2)
{
  if (!*(_BYTE *)(a1 + 214) && *(void *)(a1 + 551))
  {
    *(_BYTE *)(a1 + 214) = 1;
    ++*(void *)(a1 + 567);
    if (gNRPacketLoggingEnabled)
    {
      id v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1LL);

      if (IsLevelEnabled)
      {
        id v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
        id v7 = [(id)a1 copyDescription];
        _NRLogWithArgs( v6,  1LL,  "%s%.30s:%-4d %@: source-suspend: NexusVOInput",  "",  "NRLinkSuspendNexusVOInputSource",  834LL,  v7);
      }
    }

    dispatch_suspend(*(dispatch_object_t *)(a1 + 551));
  }

void sub_1000749CC( void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1)
  {
    id v10 = a2;
    id v11 = -[NSString initWithFormat:arguments:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithFormat:arguments:",  v10,  &a9);

    [a1 cancelWithReason:@"flushing pipe: %@", v11];
  }

NSMutableArray *sub_100074A48(NSMutableArray *a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  if (a1)
  {
    uint64_t String = NRDataProtectionClassCreateString(a4);
    id v12 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, a1[4].super.super.isa);
    id v13 = sub_10012ADD4(v12, a4);
    int v14 = sub_10010C6B8(0, v12, a4);
    if (v13) {
      uint64_t v15 = (void *)v13[1];
    }
    else {
      uint64_t v15 = 0LL;
    }
    id v16 = v15;

    if (!v16)
    {
      id v20 = (void *)String;
      -[NSMutableArray reportEvent:detailsFormat:]( a1,  "reportEvent:detailsFormat:",  3019LL,  @"%@ %@ %@",  String,  v9,  v12);
LABEL_24:
      a1 = 0LL;
      goto LABEL_38;
    }

    unsigned int v80 = v11;
    unsigned int v81 = v14;
    id v17 = (void *)objc_claimAutoreleasedReturnValue([v10 localIdentifier]);
    id v18 = (void *)objc_claimAutoreleasedReturnValue([v10 remoteIdentifier]);
    unsigned __int8 v19 = [v17 isEqual:v18];

    if ((v19 & 1) != 0)
    {
      if (v12 && _os_feature_enabled_impl("terminus", "EncryptedIdentity") && v12[11])
      {
        id v20 = (void *)String;
        -[NSMutableArray reportEvent:detailsFormat:]( a1,  "reportEvent:detailsFormat:",  3022LL,  @"%@ %@ %@",  String,  v9,  v12);
LABEL_10:
        a1 = 0LL;
        id v11 = v80;
        int v14 = v81;
LABEL_38:

        goto LABEL_39;
      }

      id v11 = v80;
      int v14 = v81;
      if ((v80[2](v80, v81) & 1) != 0)
      {
LABEL_20:
        if ((_DWORD)a4 == 4)
        {
          if (v12)
          {
            uint64_t v41 = sub_100146AFC();
            dispatch_assert_queue_V2((dispatch_queue_t)v41);

            unsigned int v42 = sub_10012CD2C(v12, @"0");
            int v43 = sub_100146AFC();
            dispatch_assert_queue_V2((dispatch_queue_t)v43);

            unint64_t v44 = sub_10012D254(v12, @"0");
LABEL_28:
            unsigned int v47 = v44;
            int v78 = v44;
            if (v42 && v44)
            {
              id v48 = objc_alloc(&OBJC_CLASS___NEIKEv2ConfigurationMessage);
              id v76 = [[NEIKEv2InitiatorTransportIPv6Address alloc] initWithAddress:v47];
              v83[0] = v76;
              id v49 = [[NEIKEv2ResponderTransportIPv6Address alloc] initWithAddress:v42];
              v83[1] = v49;
              uint64_t v50 = v42;
              id v51 = v9;
              BOOL v52 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v83,  2LL));
              id v53 = [v48 initWithWithAttributes:v52];
              -[NEIKEv2SessionConfiguration setConfigurationReply:](v81, "setConfigurationReply:", v53);

              id v9 = v51;
              unsigned int v42 = v50;
            }

            goto LABEL_32;
          }

          unsigned int v42 = 0LL;
          int v78 = 0LL;
        }

        else
        {
          unsigned int v42 = 0LL;
          if ((_DWORD)a4 == 3)
          {
            int v78 = 0LL;
            if (v12)
            {
              unsigned int v45 = sub_100146AFC();
              dispatch_assert_queue_V2((dispatch_queue_t)v45);

              unsigned int v42 = (void *)sub_10012D45C(v12, @"0");
              uint64_t v46 = sub_100146AFC();
              dispatch_assert_queue_V2((dispatch_queue_t)v46);

              unint64_t v44 = sub_10012D610(v12, @"0");
              goto LABEL_28;
            }
          }

          else
          {
            int v78 = 0LL;
          }
        }

void sub_1000751DC(uint64_t a1)
{
  if (a1)
  {
    id v2 = *(void **)(a1 + 1247);
    if (v2)
    {
      uint64_t v3 = objc_claimAutoreleasedReturnValue([v2 description]);
      [*(id *)(a1 + 1247) setClientQueue:*(void *)(a1 + 8)];
      objc_initWeak(location, (id)a1);
      v41[0] = _NSConcreteStackBlock;
      v41[1] = 3221225472LL;
      v41[2] = sub_10007CDFC;
      v41[3] = &unk_1001AEC80;
      id v18 = &v43;
      objc_copyWeak(&v43, location);
      id v4 = (id)v3;
      id v42 = v4;
      [*(id *)(a1 + 1247) setStateUpdateBlock:v41];
      v38[0] = _NSConcreteStackBlock;
      v38[1] = 3221225472LL;
      v38[2] = sub_10007D39C;
      v38[3] = &unk_1001AECA8;
      objc_copyWeak(&v40, location);
      id v5 = v4;
      id v39 = v5;
      [*(id *)(a1 + 1247) setChildStateUpdateBlock:v38];
      v35[0] = _NSConcreteStackBlock;
      v35[1] = 3221225472LL;
      v35[2] = sub_10007D4EC;
      v35[3] = &unk_1001AECD0;
      objc_copyWeak(&v37, location);
      id v6 = v5;
      id v36 = v6;
      [*(id *)(a1 + 1247) setConfigurationUpdateBlock:v35];
      v32[0] = _NSConcreteStackBlock;
      v32[1] = 3221225472LL;
      v32[2] = sub_10007D5B4;
      v32[3] = &unk_1001AECF8;
      objc_copyWeak(&v34, location);
      id v7 = v6;
      id v33 = v7;
      [*(id *)(a1 + 1247) setTrafficSelectorUpdateBlock:v32];
      v29[0] = _NSConcreteStackBlock;
      v29[1] = 3221225472LL;
      v29[2] = sub_10007D6A0;
      v29[3] = &unk_1001AED20;
      objc_copyWeak(&v31, location);
      id v8 = v7;
      id v30 = v8;
      [*(id *)(a1 + 1247) setAdditionalAddressesUpdateBlock:v29];
      v26[0] = _NSConcreteStackBlock;
      v26[1] = 3221225472LL;
      v26[2] = sub_10007D768;
      v26[3] = &unk_1001B0798;
      objc_copyWeak(&v28, location);
      id v9 = v8;
      id v27 = v9;
      [*(id *)(a1 + 1247) setShortDPDEventBlock:v26];
      id v20 = _NSConcreteStackBlock;
      uint64_t v21 = 3221225472LL;
      uint64_t v22 = sub_10007D828;
      uint64_t v23 = &unk_1001AED20;
      objc_copyWeak(&v25, location);
      id v10 = v9;
      id v24 = v10;
      [*(id *)(a1 + 1247) setPrivateNotifyStatusEvent:&v20];
      id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v11);
      LOBYTE(v3) = _NRLogIsLevelEnabled(v12, 0LL);

      if ((v3 & 1) != 0)
      {
        int v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v13);
        id v15 = [(id)a1 copyDescription];
        _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d %@: Setup IKE pairing %@ callbacks",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]",  8722LL,  v15,  v10,  &v43,  v20,  v21,  v22,  v23);
      }

      objc_destroyWeak(&v25);
      objc_destroyWeak(&v28);

      objc_destroyWeak(&v31);
      objc_destroyWeak(&v34);

      objc_destroyWeak(&v37);
      objc_destroyWeak(&v40);

      objc_destroyWeak(v18);
      objc_destroyWeak(location);
    }

    else
    {
      id v16 = sub_100070554();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v16, 17LL);

      if (IsLevelEnabled)
      {
        id v19 = sub_100070554();
        _NRLogWithArgs( v19,  17LL,  "%s called with null _ikeSessionPairing",  "-[NRLinkBluetooth setupIKECallbacksPairing]");
      }
    }
  }

void sub_1000755D8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id *location)
{
}

void sub_100075658(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v30 = a2;
  id v7 = a3;
  id v8 = a4;
  unsigned int v10 = [*(id *)(a1 + 32) state];
  uint64_t v11 = *(NSMutableArray **)(a1 + 32);
  if (v10 != 255)
  {
    id v12 = sub_100075D34(v11, 0);
    if (_os_feature_enabled_impl("terminus", "EncryptedIdentity"))
    {
      uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) nrUUID]);
      int v14 = sub_100132028((uint64_t)&OBJC_CLASS___NRDLocalDevice, v13);

      if (v14)
      {
        id v15 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50351 notifyData:v14];
        -[NSMutableArray addObject:](v12, "addObject:", v15);
      }
    }

    if (v30)
    {
      id v16 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50411 notifyData:v30];
      -[NSMutableArray addObject:](v12, "addObject:", v16);
    }

    if (v7)
    {
      id v17 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50412 notifyData:v7];
      -[NSMutableArray addObject:](v12, "addObject:", v17);
    }

    if (v8)
    {
      id v18 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50413 notifyData:v8];
      -[NSMutableArray addObject:](v12, "addObject:", v18);
    }

    [*(id *)(a1 + 40) setCustomIKEAuthPrivateNotifies:v12];
    if (qword_1001DC840 != -1) {
      dispatch_once(&qword_1001DC840, &stru_1001AEE08);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC838, 0LL))
    {
      if (qword_1001DC840 != -1) {
        dispatch_once(&qword_1001DC840, &stru_1001AEE08);
      }
      _NRLogWithArgs( qword_1001DC838,  0LL,  "%s%.30s:%-4d Responding to session for pairing with OOBK",  "",  "-[NRLinkBluetooth requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBl ock:]_block_invoke",  9397);
    }

    id v19 = *(void **)(a1 + 32);
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 40) sharedSecret]);
    Loguint64_t String = (void *)_NRKeyCreateLogString(v20);
    [v19 reportEvent:3014 details:LogString];

    uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) nrUUID]);
    uint64_t v23 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v22);

    uint64_t v24 = *(void *)(a1 + 56);
    uint64_t v25 = *(void *)(a1 + 40);
    if (*(void *)(a1 + 48))
    {
      uint64_t v26 = sub_10010C340();
      -[NEIKEv2ChildSAConfiguration setSequencePerTrafficClass:](v26, "setSequencePerTrafficClass:", 1LL);
      -[NEIKEv2ChildSAConfiguration setReplayWindowSize:](v26, "setReplayWindowSize:", 16LL);
      (*(void (**)(uint64_t, uint64_t, NEIKEv2ChildSAConfiguration *, void))(v24 + 16))(v24, v25, v26, 0LL);
    }

    else
    {
      (*(void (**)(void, void, void, void))(v24 + 16))( *(void *)(a1 + 56),  *(void *)(a1 + 40),  0LL,  0LL);
    }

    goto LABEL_23;
  }

  id v27 = (void *)_NRCopyLogObjectForNRUUID(v11[4].super.super.isa, v9);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v27, 0LL);

  if (IsLevelEnabled)
  {
    id v12 = (NSMutableArray *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v29);
    uint64_t v23 = (char *)[*(id *)(a1 + 32) copyDescription];
    _NRLogWithArgs( v12,  0LL,  "%s%.30s:%-4d %@: Ignoring result as link is cancelled",  "",  "-[NRLinkBluetooth requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBloc k:]_block_invoke",  9360LL,  v23);
LABEL_23:
  }
}

void sub_1000759B0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5, void *a6)
{
  id v37 = a4;
  id v11 = a5;
  id v12 = a6;
  if ([*(id *)(a1 + 32) state] != 255)
  {
    if (!a2 || !a3 || !v37)
    {
      (*(void (**)(void))(*(void *)(a1 + 64) + 16LL))();
      goto LABEL_23;
    }

    int v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v13);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v14, 0LL);

    if (IsLevelEnabled)
    {
      id v17 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v16);
      id v18 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v17,  0LL,  "%s%.30s:%-4d %@: Responder %@ queried IDS keys for pairing",  "",  "-[NRLinkBluetooth requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBl ock:]_block_invoke_2",  9428LL,  v18,  *(void *)(a1 + 40));
    }

    [*(id *)(a1 + 48) setLocalPrivateKeyRef:a3];
    [*(id *)(a1 + 48) setRemotePublicKeyRef:a2];
    id v19 = sub_100075D34(*(NSMutableArray **)(a1 + 32), 0);
    if (_os_feature_enabled_impl("terminus", "EncryptedIdentity"))
    {
      uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) nrUUID]);
      uint64_t v21 = sub_100132028((uint64_t)&OBJC_CLASS___NRDLocalDevice, v20);

      if (v21)
      {
        id v22 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50351 notifyData:v21];
        -[NSMutableArray addObject:](v19, "addObject:", v22);
      }
    }

    id v23 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50401 notifyData:v37];
    -[NSMutableArray addObject:](v19, "addObject:", v23);

    if (v11)
    {
      id v25 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50402 notifyData:v11];
      -[NSMutableArray addObject:](v19, "addObject:", v25);

      if (v12)
      {
LABEL_13:
        id v27 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50403 notifyData:v12];
        -[NSMutableArray addObject:](v19, "addObject:", v27);

LABEL_18:
        [*(id *)(a1 + 48) setCustomIKEAuthPrivateNotifies:v19];
        [*(id *)(a1 + 32) reportEvent:3012];
        id v32 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) nrUUID]);
        id v33 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v32);

        uint64_t v34 = *(void *)(a1 + 64);
        uint64_t v35 = *(void *)(a1 + 48);
        if (*(void *)(a1 + 56))
        {
          id v36 = sub_10010C340();
          -[NEIKEv2ChildSAConfiguration setSequencePerTrafficClass:](v36, "setSequencePerTrafficClass:", 1LL);
          -[NEIKEv2ChildSAConfiguration setReplayWindowSize:](v36, "setReplayWindowSize:", 16LL);
          (*(void (**)(uint64_t, uint64_t, NEIKEv2ChildSAConfiguration *, void))(v34 + 16))( v34,  v35,  v36,  0LL);
        }

        else
        {
          (*(void (**)(void, void, void, void))(v34 + 16))( *(void *)(a1 + 64),  *(void *)(a1 + 48),  0LL,  0LL);
        }

        goto LABEL_22;
      }
    }

    else
    {
      sub_1000764AC(*(void *)(a1 + 32), v24);
      if (v12) {
        goto LABEL_13;
      }
    }

    sub_10007669C(*(void *)(a1 + 32), v26);
    goto LABEL_18;
  }

  id v28 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v13);
  int v29 = _NRLogIsLevelEnabled(v28, 0LL);

  if (v29)
  {
    id v19 = (NSMutableArray *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v30);
    id v31 = [*(id *)(a1 + 32) copyDescription];
    _NRLogWithArgs( v19,  0LL,  "%s%.30s:%-4d %@: Ignoring result as link is cancelled",  "",  "-[NRLinkBluetooth requestConfigurationForListener:session:sessionConfig:childConfig:validateAuthBlock:responseBloc k:]_block_invoke_2",  9417LL,  v31);

LABEL_22:
  }

NSMutableArray *sub_100075D34(NSMutableArray *a1, int a2)
{
  id v2 = a1;
  if (a1)
  {
    id v4 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
    LOWORD(v55) = 5632;
    id v5 = -[NSMutableData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSMutableData),  "initWithBytes:length:",  &v55,  2LL);
    id v6 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:48602 notifyData:v5];
    -[NSMutableArray addObject:](v4, "addObject:", v6);

    if (qword_1001DC9A8 != -1) {
      dispatch_once(&qword_1001DC9A8, &stru_1001AFAF8);
    }
    id v7 = (id)qword_1001DC9A0;
    id v8 = (void *)objc_claimAutoreleasedReturnValue([v7 dataUsingEncoding:4]);

    id v9 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:48603 notifyData:v8];
    -[NSMutableArray addObject:](v4, "addObject:", v9);

    if (qword_1001DC998 != -1) {
      dispatch_once(&qword_1001DC998, &stru_1001AFAD8);
    }
    id v10 = (id)qword_1001DC990;
    id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 dataUsingEncoding:4]);

    id v12 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:48604 notifyData:v11];
    -[NSMutableArray addObject:](v4, "addObject:", v12);

    if (qword_1001DCA28 != -1) {
      dispatch_once(&qword_1001DCA28, &stru_1001AFC48);
    }
    LOBYTE(v55) = byte_1001DCA20;
    uint64_t v13 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v55, 1LL);
    id v14 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:48606 notifyData:v13];
    -[NSMutableArray addObject:](v4, "addObject:", v14);

    id v15 = sub_10010CD5C();
    -[NSMutableArray addObject:](v4, "addObject:", v15);

    uint64_t v16 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v2[4].super.super.isa);
    if (v16)
    {
      id v17 = v16;
      *(void *)&__int128 v55 = *((void *)v16 + 17);
      id v18 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v55, 8LL);
      id v19 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:48605 notifyData:v18];

      -[NSMutableArray addObject:](v4, "addObject:", v19);
      objc_opt_self(&OBJC_CLASS___NRLinkManagerWiFi);
      LOBYTE(v55) = 1;
      uint64_t v20 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v55, 1LL);
      id v21 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:51401 notifyData:v20];
      -[NSMutableArray addObject:](v4, "addObject:", v21);

      if (!*(Class *)((char *)&v2[43].super.super.isa + 7))
      {
        -[NSMutableArray cancelWithReason:]( v2,  "cancelWithReason:",  @"Trying to generate notify payloads but sentPrelude is nil");
        id v2 = 0LL;
        goto LABEL_18;
      }

      id v22 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:48601 notifyData:*(Class *)((char *)&v2[43].super.super.isa + 7)];
      -[NSMutableArray addObject:](v4, "addObject:", v22);

      if (!a2) {
        goto LABEL_13;
      }
      id v23 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v2[4].super.super.isa);
      if (v23)
      {
        uint64_t v24 = v23;
        id v25 = sub_10010CEF4(v23, 0LL);
        -[NSMutableArray addObject:](v4, "addObject:", v25);

LABEL_13:
        if (!BYTE2(v2[30].super.super.isa))
        {
LABEL_16:
          id v2 = v4;
LABEL_18:

          return v2;
        }

        uint64_t v26 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v2[4].super.super.isa);
        if (v26)
        {
          id v27 = v26;
          __int128 v55 = 0uLL;
          sub_10012D7C8(v26, &v55);
          id v28 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v55, 16LL);
          id v29 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50801 notifyData:v28];
          -[NSMutableArray addObject:](v4, "addObject:", v29);

          __int128 v55 = 0uLL;
          sub_10012E070(v27, &v55);
          uint64_t v30 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v55, 16LL);
          id v31 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50802 notifyData:v30];
          -[NSMutableArray addObject:](v4, "addObject:", v31);

          __int128 v55 = 0uLL;
          sub_100136A64(v27, &v55);
          id v32 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v55, 16LL);
          id v33 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50811 notifyData:v32];
          -[NSMutableArray addObject:](v4, "addObject:", v33);

          __int128 v55 = 0uLL;
          sub_1001368D4(v27, &v55);
          uint64_t v34 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", &v55, 16LL);
          id v35 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50812 notifyData:v34];
          -[NSMutableArray addObject:](v4, "addObject:", v35);

          goto LABEL_16;
        }

        id v40 = sub_100070554();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v40, 16LL);

        if (IsLevelEnabled)
        {
          id v42 = sub_100070554();
          _NRLogWithArgs( v42,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRLinkBluetooth copyNotifyPayloadsToSendWithProxy:]",  7415);
        }

        uint64_t v43 = _os_log_pack_size(12LL);
        unint64_t v44 = (char *)&v54 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        unsigned int v45 = __error();
        uint64_t v46 = _os_log_pack_fill( v44,  v43,  *v45,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
        *(_DWORD *)uint64_t v46 = 136446210;
        *(void *)(v46 + 4) = "-[NRLinkBluetooth copyNotifyPayloadsToSendWithProxy:]";
LABEL_29:
        id v53 = sub_100070554();
        _NRLogAbortWithPack(v53, v44);
      }

      id v47 = sub_100070554();
      int v48 = _NRLogIsLevelEnabled(v47, 16LL);

      if (v48)
      {
        id v49 = sub_100070554();
        _NRLogWithArgs( v49,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRLinkBluetooth copyNotifyPayloadsToSendWithProxy:]",  7409);
      }
    }

    else
    {
      id v37 = sub_100070554();
      int v38 = _NRLogIsLevelEnabled(v37, 16LL);

      if (v38)
      {
        id v39 = sub_100070554();
        _NRLogWithArgs( v39,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRLinkBluetooth copyNotifyPayloadsToSendWithProxy:]",  7359);
      }
    }

    uint64_t v50 = _os_log_pack_size(12LL);
    unint64_t v44 = (char *)&v54 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v51 = *__error();
    uint64_t v52 = _os_log_pack_fill( v44,  v50,  v51,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
    *(_DWORD *)uint64_t v52 = 136446210;
    *(void *)(v52 + 4) = "-[NRLinkBluetooth copyNotifyPayloadsToSendWithProxy:]";
    goto LABEL_29;
  }

  return v2;
}

void sub_1000764AC(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (*(unsigned __int8 *)(a1 + 16) == 255)
    {
      id v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v8, 0LL);

      if (IsLevelEnabled)
      {
        id v13 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v10);
        id v11 = [(id)a1 copyDescription];
        _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d %@: Not sending encrypted classC because cancelled",  "",  "-[NRLinkBluetooth sendlocalPublicClassCKeysEncryptedWithIDS]",  8289LL,  v11);
      }
    }

    else if (*(void *)(a1 + 1295))
    {
      [(id)a1 reportEvent:3402 details:@"ClassC"];
      uint64_t v3 = sub_100075D34((NSMutableArray *)a1, 0);
      id v4 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50402 notifyData:*(void *)(a1 + 1295)];
      -[NSMutableArray addObject:](v3, "addObject:", v4);
      id v5 = *(void **)(a1 + 1295);
      *(void *)(a1 + 1295) = 0LL;

      id v6 = *(void **)(a1 + 1247);
      uint64_t v7 = *(void *)(a1 + 8);
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 3221225472LL;
      _OWORD v14[2] = sub_10007CCAC;
      v14[3] = &unk_1001AEEF8;
      void v14[4] = a1;
      [v6 sendPrivateNotifies:v3 maxRetries:10 retryIntervalInMilliseconds:10000 callbackQueue:v7 callback:v14];
    }

    else if (!*(_BYTE *)(a1 + 240))
    {
      *(_BYTE *)(a1 + 240) = 1;
      id v12 = *(void **)(a1 + 32);
      v15[0] = _NSConcreteStackBlock;
      v15[1] = 3221225472LL;
      v15[2] = sub_10007CB68;
      v15[3] = &unk_1001AEC30;
      void v15[4] = a1;
      sub_100132BC0((uint64_t)&OBJC_CLASS___NRDLocalDevice, v12, 3, v15);
    }
  }

void sub_10007669C(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (*(unsigned __int8 *)(a1 + 16) != 255)
    {
      uint64_t v3 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 nrUUID]);
      id v4 = (unsigned __int16 *)sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v3);

      if (v4 && v4[14] >= 0x13u)
      {
        id v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

        if (!IsLevelEnabled)
        {
LABEL_12:

          return;
        }

        id v9 = (NSMutableArray *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v8);
        id v10 = [(id)a1 copyDescription];
        _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: Not sending encrypted ClassA because peer supports skipping ClassA pairing",  "",  "-[NRLinkBluetooth sendlocalPublicClassAKeysEncryptedWithIDS]",  8346LL,  v10);
      }

      else
      {
        if (!*(void *)(a1 + 1303))
        {
          if (!*(_BYTE *)(a1 + 241))
          {
            *(_BYTE *)(a1 + 241) = 1;
            id v19 = *(void **)(a1 + 32);
            v22[0] = _NSConcreteStackBlock;
            v22[1] = 3221225472LL;
            v22[2] = sub_100076944;
            v22[3] = &unk_1001AEC30;
            v22[4] = a1;
            sub_100132BC0((uint64_t)&OBJC_CLASS___NRDLocalDevice, v19, 1, v22);
          }

          goto LABEL_12;
        }

        [(id)a1 reportEvent:3402 details:@"ClassA"];
        id v9 = sub_100075D34((NSMutableArray *)a1, 0);
        id v15 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50403 notifyData:*(void *)(a1 + 1303)];
        -[NSMutableArray addObject:](v9, "addObject:", v15);
        uint64_t v16 = *(void **)(a1 + 1303);
        *(void *)(a1 + 1303) = 0LL;

        id v17 = *(void **)(a1 + 1247);
        uint64_t v18 = *(void *)(a1 + 8);
        v21[0] = _NSConcreteStackBlock;
        v21[1] = 3221225472LL;
        v21[2] = sub_100076A88;
        v21[3] = &unk_1001AEEF8;
        void v21[4] = a1;
        [v17 sendPrivateNotifies:v9 maxRetries:10 retryIntervalInMilliseconds:10000 callbackQueue:v18 callback:v21];
      }

      goto LABEL_12;
    }

    id v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
    int v12 = _NRLogIsLevelEnabled(v11, 0LL);

    if (v12)
    {
      id v20 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v13);
      id v14 = [(id)a1 copyDescription];
      _NRLogWithArgs( v20,  0LL,  "%s%.30s:%-4d %@: Not sending encrypted ClassA because cancelled",  "",  "-[NRLinkBluetooth sendlocalPublicClassAKeysEncryptedWithIDS]",  8341LL,  v14);
    }
  }

void sub_100076944(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  id v19 = a6;
  if ([*(id *)(a1 + 32) state] == 255)
  {
    id v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v8);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0LL);

    if (IsLevelEnabled)
    {
      id v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v13);
      id v15 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d %@: Ignoring result as link is cancelled",  "",  "-[NRLinkBluetooth sendlocalPublicClassAKeysEncryptedWithIDS]_block_invoke",  8364LL,  v15);
    }
  }

  else if (v19)
  {
    uint64_t v9 = *(void *)(a1 + 32);
    if (v9)
    {
      objc_storeStrong((id *)(v9 + 1303), a6);
      uint64_t v10 = *(void *)(a1 + 32);
    }

    else
    {
      uint64_t v10 = 0LL;
    }

    sub_10007669C(v10);
  }

  else
  {
    id v16 = sub_100070554();
    int v17 = _NRLogIsLevelEnabled(v16, 17LL);

    if (v17)
    {
      id v18 = sub_100070554();
      _NRLogWithArgs( v18,  17LL,  "%s called with null localPublicClassAKeysEncryptedWithIDS",  "-[NRLinkBluetooth sendlocalPublicClassAKeysEncryptedWithIDS]_block_invoke");
    }
  }
}

void sub_100076A88(uint64_t a1, uint64_t a2)
{
  int v2 = a2;
  uint64_t v4 = _NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), a2);
  uint64_t v5 = (void *)v4;
  if (v2)
  {
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v7);
      id v9 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v8,  0LL,  "%s%.30s:%-4d %@: localPublicClassAKeysEncryptedWithIDS was received",  "",  "-[NRLinkBluetooth sendlocalPublicClassAKeysEncryptedWithIDS]_block_invoke_2",  8387LL,  v9);
    }

    uint64_t v10 = *(void *)(a1 + 32);
    if (v10) {
      sub_100076BD8(v10, 1LL, 0, 0);
    }
  }

  else
  {
    int v11 = _NRLogIsLevelEnabled(v4, 16LL);

    if (v11)
    {
      id v14 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v12);
      id v13 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v14,  16LL,  "%s%.30s:%-4d %@: localPublicClassAKeysEncryptedWithIDS was not received",  "",  "-[NRLinkBluetooth sendlocalPublicClassAKeysEncryptedWithIDS]_block_invoke_2",  8390LL,  v13);
    }
  }

void sub_100076BD8(uint64_t a1, uint64_t a2, int a3, int a4)
{
  id String = (id)NRDataProtectionClassCreateString(a2);
  if (*(unsigned __int8 *)(a1 + 16) == 255)
  {
    id v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v8);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v15, 0LL);

    if (IsLevelEnabled)
    {
      id v13 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v17);
      id v14 = [(id)a1 copyDescription];
      _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d %@: Not restarting %@ session because cancelled",  "",  "-[NRLinkBluetooth restartIKESessionForDataProtectionClass:authFailure:afterDisconnection:]",  9007LL,  v14,  String);
      goto LABEL_20;
    }
  }

  else
  {
    [(id)a1 invalidateIKESessionForClass:a2];
    if ((_DWORD)a2 == 4 || !a3 || *(_BYTE *)(a1 + 236))
    {
      if ((_DWORD)a2 == 1 && *(_BYTE *)(a1 + 235))
      {
        uint64_t v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v9);
        int v11 = _NRLogIsLevelEnabled(v10, 0LL);

        if (v11)
        {
          id v13 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v12);
          id v14 = [(id)a1 copyDescription];
          _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d %@: Not restarting ClassA session because attempt failed once. Will retry at next unlock",  "",  "-[NRLinkBluetooth restartIKESessionForDataProtectionClass:authFailure:afterDisconnection:]",  9018LL,  v14);
LABEL_20:
        }
      }

      else
      {
        id v18 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v9);
        int v19 = _NRLogIsLevelEnabled(v18, 0LL);

        if (v19)
        {
          id v21 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v20);
          id v22 = [(id)a1 copyDescription];
          _NRLogWithArgs( v21,  0LL,  "%s%.30s:%-4d %@: Restarting %@ session",  "",  "-[NRLinkBluetooth restartIKESessionForDataProtectionClass:authFailure:afterDisconnection:]",  9023LL,  v22,  String);
        }

        sub_100076FE0(a1, a2);
        if (a4 && *(_BYTE *)(a1 + 242))
        {
          if ((_DWORD)a2 == 4)
          {
            id v23 = &OBJC_IVAR___NRLinkBluetooth__reconnectionTimerStartedClassD;
          }

          else
          {
            if ((_DWORD)a2 != 3) {
              goto LABEL_21;
            }
            id v23 = &OBJC_IVAR___NRLinkBluetooth__reconnectionTimerStartedClassC;
          }

          id v27 = (_BYTE *)(a1 + *v23);
          if (!*v27)
          {
            id v28 = (void *)NRDataProtectionClassCreateString(a2);
            uint64_t v30 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v29);
            int v31 = _NRLogIsLevelEnabled(v30, 0LL);

            if (v31)
            {
              id v33 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v32);
              id v34 = [(id)a1 copyDescription];
              _NRLogWithArgs( v33,  0LL,  "%s%.30s:%-4d %@: Starting %@ reconnection timer",  "",  "-[NRLinkBluetooth startReconnectionTimer:]",  9049LL,  v34,  v28);
            }

            _BYTE *v27 = 1;
            [(id)a1 setPowerAssertionState:1];
            objc_initWeak(&location, (id)a1);
            dispatch_time_t v35 = dispatch_time(0x8000000000000000LL, 10000000000LL);
            id v36 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue([(id)a1 queue]);
            block[0] = _NSConcreteStackBlock;
            block[1] = 3221225472LL;
            block[2] = sub_100077650;
            block[3] = &unk_1001AED98;
            objc_copyWeak(v41, &location);
            v41[1] = v27;
            id v40 = v28;
            id v37 = v28;
            dispatch_after(v35, v36, block);

            objc_destroyWeak(v41);
            objc_destroyWeak(&location);
          }
        }
      }
    }

    else
    {
      uint64_t v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v9);
      int v25 = _NRLogIsLevelEnabled(v24, 0LL);

      if (v25)
      {
        id v13 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v26);
        id v14 = [(id)a1 copyDescription];
        _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d %@: Not restarting %@ session because remote not unlocked",  "",  "-[NRLinkBluetooth restartIKESessionForDataProtectionClass:authFailure:afterDisconnection:]",  9012LL,  v14,  String);
        goto LABEL_20;
      }
    }
  }

void sub_100076FCC(_Unwind_Exception *a1)
{
}

void sub_100076FE0(uint64_t a1, uint64_t a2)
{
  if (!*(_BYTE *)(a1 + 242))
  {
    uint64_t v4 = (id *)sub_1000776BC(a1, a2);
    if (!*v4)
    {
      uint64_t v5 = v4;
      id String = (void *)NRDataProtectionClassCreateString(a2);
      if (*(unsigned __int8 *)(a1 + 16) == 255)
      {
        uint64_t v17 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v6);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v17, 0LL);

        if (!IsLevelEnabled)
        {
LABEL_44:

          return;
        }

        uint64_t v10 = (char *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v19);
        id v20 = [(id)a1 copyDescription];
        _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d %@: Not starting %@ initiator session because cancelled",  "",  "-[NRLinkBluetooth setupIPsecInitiatorIfNecessary:]",  8873LL,  v20,  String);

        goto LABEL_43;
      }

      uint64_t v8 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 32));
      uint64_t v10 = v8;
      if (!v8)
      {
        unsigned int v58 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v9);
        int v59 = _NRLogIsLevelEnabled(v58, 17LL);

        if (!v59) {
          goto LABEL_43;
        }
        id v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v60);
        id v15 = [(id)a1 copyDescription];
        _NRLogWithArgs( v14,  17LL,  "%@: Not starting %@ IKE initiator session because localDevice is missing",  v15,  String);
        goto LABEL_21;
      }

      if ((_DWORD)a2 == 1)
      {
        if (*((unsigned __int16 *)v8 + 14) > 0x12u)
        {
          int v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v9);
          int v12 = _NRLogIsLevelEnabled(v11, 0LL);

          if (v12)
          {
            id v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v13);
            id v15 = [(id)a1 copyDescription];
            id v67 = v15;
            uint64_t v68 = v10;
            uint64_t v66 = 8883LL;
            id v16 = "%s%.30s:%-4d %@: Not starting ClassA IKE initiator session because peer supports skipping ClassA pairing %@";
LABEL_20:
            _NRLogWithArgs(v14, 0LL, v16, "", "-[NRLinkBluetooth setupIPsecInitiatorIfNecessary:]", v66, v67, v68, v69);
LABEL_21:

            goto LABEL_43;
          }

          goto LABEL_43;
        }

        id v21 = *((id *)v8 + 11);
      }

      else
      {
        id v21 = sub_10012ADD4(v8, a2);
      }

      id v22 = v21;

      if (!v22)
      {
        id v34 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v23);
        int v35 = _NRLogIsLevelEnabled(v34, 0LL);

        if (v35)
        {
          id v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v36);
          id v15 = [(id)a1 copyDescription];
          uint64_t v68 = (char *)String;
          uint64_t v69 = v10;
          uint64_t v66 = 8887LL;
          id v67 = v15;
          id v16 = "%s%.30s:%-4d %@: Not starting %@ IKE initiator session because we do not have keys %@";
          goto LABEL_20;
        }

void sub_100077650(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v10 = WeakRetained;
    BOOL v3 = [WeakRetained state] == 255;
    id WeakRetained = v10;
    if (!v3)
    {
      if (**(_BYTE **)(a1 + 48))
      {
        sub_1000749CC(v10, @"%@ reconnection timed out", v4, v5, v6, v7, v8, v9, *(void *)(a1 + 32));
        id WeakRetained = v10;
      }
    }
  }
}

uint64_t sub_1000776BC(uint64_t result, int a2)
{
  if (result)
  {
    switch(a2)
    {
      case 1:
        int v2 = &OBJC_IVAR___NRLinkBluetooth__ikeSessionClassA;
        goto LABEL_8;
      case 4:
        int v2 = &OBJC_IVAR___NRLinkBluetooth__ikeSessionClassD;
        goto LABEL_8;
      case 3:
        int v2 = &OBJC_IVAR___NRLinkBluetooth__ikeSessionClassC;
LABEL_8:
        result += *v2;
        return result;
    }

    HIDWORD(v14) = a2;
    id v3 = sub_100070554();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 16LL);

    if (IsLevelEnabled)
    {
      id v5 = sub_100070554();
      id String = (void *)NRDataProtectionClassCreateString(HIDWORD(v14));
      _NRLogWithArgs( v5,  16LL,  "%s%.30s:%-4d ABORTING: Cannot copy IKE session pointer for %@",  "",  "-[NRLinkBluetooth ikeSessionPointerForDataProtectionClass:]",  1460LL,  String);
    }

    uint64_t v7 = _os_log_pack_size(22LL);
    uint64_t v8 = (char *)&v14 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v9 = __error();
    uint64_t v10 = _os_log_pack_fill( v8,  v7,  *v9,  &_mh_execute_header,  "%{public}s Cannot copy IKE session pointer for %@");
    uint64_t v11 = NRDataProtectionClassCreateString(HIDWORD(v14));
    *(_DWORD *)uint64_t v10 = 136446466;
    *(void *)(v10 + 4) = "-[NRLinkBluetooth ikeSessionPointerForDataProtectionClass:]";
    *(_WORD *)(v10 + 12) = 2112;
    *(void *)(v10 + 14) = v11;
    id v12 = sub_100070554();
    uint64_t v13 = _NRLogAbortWithPack(v12, v8);
    return sub_100077840(v13);
  }

  return result;
}

void sub_100077840(void *a1, uint64_t a2)
{
  int v2 = a2;
  id String = (void *)NRDataProtectionClassCreateString(a2);
  if (v2 == 1)
  {
    id v5 = *(void **)((char *)a1 + 1239);
    if (!v5)
    {
      id v9 = sub_100070554();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v9, 17LL);

      if (IsLevelEnabled)
      {
        id v8 = sub_100070554();
        _NRLogWithArgs(v8, 17LL, "%s called with null _ikeSessionClassA");
        goto LABEL_24;
      }

      goto LABEL_20;
    }

    goto LABEL_11;
  }

  if (v2 == 3)
  {
    id v5 = *(void **)((char *)a1 + 1231);
    if (v5) {
      goto LABEL_11;
    }
    id v32 = sub_100070554();
    int v33 = _NRLogIsLevelEnabled(v32, 17LL);

    if (v33)
    {
      id v8 = sub_100070554();
      _NRLogWithArgs(v8, 17LL, "%s called with null _ikeSessionClassC");
      goto LABEL_24;
    }

void sub_100077DCC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id *location, id *a18, id *a19)
{
}

void sub_100077E4C(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  id WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 56));
  int v7 = WeakRetained;
  if (WeakRetained)
  {
    id v8 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained linkDelegate]);
    if (v5)
    {
      int v9 = *(unsigned __int8 *)(a1 + 64);
      if (v9 == 1)
      {
        sub_10007BE6C(v7);
        goto LABEL_18;
      }

      if (v9 == 3)
      {
        [v7 setIkeClassCEstablished:0];
        uint64_t v10 = mach_absolute_time();
        uint64_t v11 = *(void *)(v7 + 1863);
        if (!v11) {
          goto LABEL_18;
        }
        uint64_t v12 = 40LL;
      }

      else
      {
        if (v9 != 4
          || ([v7 setIkeClassDEstablished:0],
              uint64_t v10 = mach_absolute_time(),
              (uint64_t v11 = *(void *)(v7 + 1863)) == 0))
        {
LABEL_18:
          uint64_t v23 = *(void *)(a1 + 32);
          uint64_t v24 = *(void *)(a1 + 40);
          SessionStateid String = (void *)NEIKEv2CreateSessionStateString(a2);
          [v7 reportEvent:3018, @"%@ session %@ got IKE error %@ with state %@", v23, v24, v5, SessionStateString detailsFormat];

          [v7 processIKEDisconnection:*(unsigned __int8 *)(a1 + 64) error:v5];
          if ([v7 state] != 255)
          {
            id v26 = v5;
            if ([v26 code] == (id)24)
            {
              uint64_t v27 = NEIKEv2ProtocolErrorDomain;
              char v28 = (void *)objc_claimAutoreleasedReturnValue([v26 domain]);
              LOBYTE(v27) = [v28 isEqualToString:v27];

              if ((v27 & 1) != 0) {
                goto LABEL_25;
              }
            }

            else
            {
            }

            id v29 = v26;
            if ([v29 code] == (id)8)
            {
              uint64_t v30 = NEIKEv2ErrorDomain;
              id v31 = (void *)objc_claimAutoreleasedReturnValue([v29 domain]);
              LODWORD(v30) = [v31 isEqualToString:v30];

              if ((_DWORD)v30)
              {
LABEL_25:
                int v32 = 1;
                goto LABEL_28;
              }
            }

            else
            {
            }

            int v32 = 0;
LABEL_28:
            uint64_t v33 = *(unsigned __int8 *)(a1 + 64);
            uint64_t v34 = (uint64_t)v7;
LABEL_29:
            sub_100076BD8(v34, v33, v32, 1);
          }

void sub_100078970( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, id location)
{
}

void sub_1000789A8(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v23 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    if (v23)
    {
      uint64_t v8 = *(void *)(a1 + 32);
      uint64_t v9 = *(void *)(a1 + 40);
      SessionStateid String = (void *)NEIKEv2CreateSessionStateString(a3);
      [WeakRetained reportEvent:3018, @"%@ session %@ got child %u state update %@ error %@", v8, v9, a2, SessionStateString, v23 detailsFormat];

      [WeakRetained processIKEDisconnection:*(unsigned __int8 *)(a1 + 56) error:v23];
      if ([WeakRetained state] != 255)
      {
        id v11 = v23;
        if ([v11 code] == (id)24)
        {
          uint64_t v12 = NEIKEv2ProtocolErrorDomain;
          uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue([v11 domain]);
          LOBYTE(v12) = [v13 isEqualToString:v12];

          if ((v12 & 1) != 0) {
            goto LABEL_12;
          }
        }

        else
        {
        }

        id v19 = v11;
        if ([v19 code] == (id)8)
        {
          uint64_t v20 = NEIKEv2ErrorDomain;
          id v21 = (void *)objc_claimAutoreleasedReturnValue([v19 domain]);
          LODWORD(v20) = [v21 isEqualToString:v20];

          if ((_DWORD)v20)
          {
LABEL_12:
            int v18 = 1;
LABEL_16:
            uint64_t v16 = *(unsigned __int8 *)(a1 + 56);
            uint64_t v17 = (uint64_t)WeakRetained;
            goto LABEL_17;
          }
        }

        else
        {
        }

        int v18 = 0;
        goto LABEL_16;
      }
    }

    else
    {
      uint64_t v14 = *(void *)(a1 + 32);
      uint64_t v15 = *(void *)(a1 + 40);
      if (a3 == 3)
      {
        [WeakRetained reportEvent:3018, @"%@ session %@ got child %u Disconnected state with no error", v14, *(void *)(a1 + 40), a2 detailsFormat];
        uint64_t v16 = *(unsigned __int8 *)(a1 + 56);
        uint64_t v17 = (uint64_t)WeakRetained;
        int v18 = 0;
LABEL_17:
        sub_100076BD8(v17, v16, v18, 1);
        goto LABEL_18;
      }

      id v22 = (void *)NEIKEv2CreateSessionStateString(a3);
      [WeakRetained reportEvent:3009, @"%@ session %@ child %u state update %@", v14, v15, a2, v22 detailsFormat];
    }
  }

void sub_100078B88(uint64_t a1, void *a2)
{
  id v11 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v5 = WeakRetained;
  if (WeakRetained)
  {
    id v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      id v10 = [v5 copyDescription];
      _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got config update %@",  "",  "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke_5",  8222LL,  v10,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  v11);
    }
  }
}

void sub_100078C54(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v16 = a3;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v10 = WeakRetained;
  if (WeakRetained)
  {
    id v11 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v9);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(v10[4], v13);
      id v15 = [v10 copyDescription];
      _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got child %u traffic selector update local %@ remote %@",  "",  "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke_6",  8233LL,  v15,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  a2,  v16,  v7);
    }
  }
}

void sub_100078D40(uint64_t a1, void *a2)
{
  id v11 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v5 = WeakRetained;
  if (WeakRetained)
  {
    id v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      id v10 = [v5 copyDescription];
      _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got additional addresses %@",  "",  "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke_7",  8242LL,  v10,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  v11);
    }
  }
}

void sub_100078E0C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    uint64_t v9 = WeakRetained;
    uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v3);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

    id WeakRetained = v9;
    if (IsLevelEnabled)
    {
      id v7 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v6);
      id v8 = [v9 copyDescription];
      _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got short DPD",  "",  "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke_8",  8250LL,  v8,  *(void *)(a1 + 32),  *(void *)(a1 + 40));

      id WeakRetained = v9;
    }
  }
}

void sub_100078ECC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v3 sortedArrayUsingComparator:&stru_1001AFCC8]);
    id v7 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v6);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0LL);

    if (IsLevelEnabled)
    {
      id v10 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v9);
      id v11 = [WeakRetained copyDescription];
      _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d %@: %@ session %@ got private notifies %@",  "",  "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke_9",  8260LL,  v11,  *(void *)(a1 + 32),  *(void *)(a1 + 40),  v5);
    }

    __int128 v22 = 0u;
    __int128 v23 = 0u;
    __int128 v20 = 0u;
    __int128 v21 = 0u;
    id v12 = v5;
    id v13 = [v12 countByEnumeratingWithState:&v20 objects:v24 count:16];
    if (v13)
    {
      id v14 = v13;
      uint64_t v15 = *(void *)v21;
      do
      {
        for (uint64_t i = 0LL; i != v14; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v21 != v15) {
            objc_enumerationMutation(v12);
          }
          uint64_t v17 = *(void **)(*((void *)&v20 + 1) + 8LL * (void)i);
          int v18 = (char *)[v17 notifyStatus];
          id v19 = (void *)objc_claimAutoreleasedReturnValue([v17 notifyData]);
          sub_1000790B8((uint64_t)WeakRetained, v18, v19, *(unsigned __int8 *)(a1 + 56));
        }

        id v14 = [v12 countByEnumeratingWithState:&v20 objects:v24 count:16];
      }

      while (v14);
    }
  }
}

void sub_1000790B8(uint64_t a1, char *a2, void *a3, int a4)
{
  LODWORD(v5) = a4;
  id v8 = a3;
  int v9 = *(unsigned __int8 *)(a1 + 16);
  id v11 = (__objc2_class *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v10);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0LL);

  if (v9 == 255)
  {
    if (IsLevelEnabled)
    {
      uint64_t v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v13);
      id v16 = [(id)a1 copyDescription];
      _NRLogWithArgs( v15,  0LL,  "%s%.30s:%-4d %@: Cancelled, ignoring notify code %u %@",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7671LL,  v16,  a2,  v8);
LABEL_12:
    }
  }

  else
  {
    if ((IsLevelEnabled & 1) != 0)
    {
      id v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v13);
      id v11 = (__objc2_class *)[(id)a1 copyDescription];
      _NRLogWithArgs( v14,  0,  "%s%.30s:%-4d %@: Received notify code %u len %llu",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7674,  v11,  a2,  [v8 length]);
    }

    if ((_DWORD)a2 == 50901 && (_DWORD)v5 == 4)
    {
      [(id)a1 setSuspendWhenReady:1];
      goto LABEL_13;
    }

    if ((_DWORD)a2 != 50000)
    {
LABEL_13:
      __int128 v21 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 linkDelegate]);
      int v22 = *(unsigned __int8 *)(a1 + 16);
      if ((v22 - 5) <= 1)
      {
        if (v22 == 5)
        {
          [(id)a1 changeStateTo:7];
        }

        else if (v22 == 6)
        {
          [(id)a1 changeStateTo:8 details:@"(IKE received first notify after connected)"];
          [v21 linkIsReady:a1];
          [(id)a1 checkProxyAgentWithForceUpdate:0];
        }
      }

      if ((int)a2 <= 50500)
      {
        if ((int)a2 <= 50350)
        {
          switch((int)a2)
          {
            case 48601:
              if (([v8 isEqual:*(void *)(a1 + 359)] & 1) == 0)
              {
                [(id)a1 cancelWithReason:@"Received encrypted payload %@ does not match unencrypted %@", v8, *(void *)(a1 + 359)];
                goto LABEL_63;
              }

              uint64_t v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v23);
              int v25 = _NRLogIsLevelEnabled(v24, 0LL);

              if (!v25) {
                goto LABEL_63;
              }
              uint64_t v27 = (NSString *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v26);
              id v28 = [(id)a1 copyDescription];
              _NRLogWithArgs( v27,  0LL,  "%s%.30s:%-4d %@: Validated encrypted remote prelude",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7807LL,  v28);
              goto LABEL_61;
            case 48602:
              LOWORD(location) = 0;
              if ((unint64_t)[v8 length] <= 1)
              {
                [(id)a1 cancelWithReason:@"Private notify Terminus Version too short %@", v8, v255];
                goto LABEL_63;
              }

              [v8 getBytes:&location length:2];
              uint64_t v4 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              *(_WORD *)(a1 + 261) = bswap32((unsigned __int16)location) >> 16;
              uint64_t v99 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v98);
              int v100 = _NRLogIsLevelEnabled(v99, 0LL);

              if (v100)
              {
                uint64_t v102 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v101);
                id v103 = [(id)a1 copyDescription];
                _NRLogWithArgs( v102,  0LL,  "%s%.30s:%-4d %@: Received remote terminus version %u",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7706LL,  v103,  *(unsigned __int16 *)(a1 + 261));
              }

              id v11 = &OBJC_CLASS___NRAnalyticsCmpnLinkWiFi;
              uint64_t v104 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 32));
              a2 = v104;
              if (v104)
              {
                unsigned int v105 = *((unsigned __int16 *)v104 + 14);
                goto LABEL_95;
              }

              goto LABEL_184;
            case 48603:
              int v83 = -[NSString initWithData:encoding:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithData:encoding:",  v8,  4LL);
              sub_10007B2EC(a1, v83);

              unsigned int v85 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v84);
              int v86 = _NRLogIsLevelEnabled(v85, 0LL);

              if (v86)
              {
                int v88 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v87);
                id v89 = [(id)a1 copyDescription];
                _NRLogWithArgs( v88,  0LL,  "%s%.30s:%-4d %@: Received remote device name %@",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7730LL,  v89,  *(void *)(a1 + 343));
              }

              id v90 = *(id *)(a1 + 343);
              id v91 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 nrUUID]);
              sub_100135A50((uint64_t)&OBJC_CLASS___NRDLocalDevice, v90, v91);

              goto LABEL_63;
            case 48604:
              uint64_t v27 = -[NSString initWithData:encoding:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithData:encoding:",  v8,  4LL);
              int v93 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v92);
              int v94 = _NRLogIsLevelEnabled(v93, 0LL);

              if (v94)
              {
                uint64_t v96 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v95);
                id v97 = [(id)a1 copyDescription];
                _NRLogWithArgs( v96,  0LL,  "%s%.30s:%-4d %@: Received remote build version %@",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7736LL,  v97,  v27);
              }

              id v28 = (id)objc_claimAutoreleasedReturnValue([(id)a1 nrUUID]);
              sub_100135C80((uint64_t)&OBJC_CLASS___NRDLocalDevice, v27, v28);
              goto LABEL_61;
            case 48605:
              if ([v8 length] == (id)8)
              {
                [v8 getBytes:&location length:8];
                id v76 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v75);
                int v77 = _NRLogIsLevelEnabled(v76, 0LL);

                if (v77)
                {
                  uint64_t v79 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v78);
                  id v80 = [(id)a1 copyDescription];
                  _NRLogWithArgs( v79,  0LL,  "%s%.30s:%-4d %@: Received remote device flags %#llx",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7941LL,  v80,  location);
                }

                id v81 = location;
                uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 nrUUID]);
                sub_100136708((uint64_t)&OBJC_CLASS___NRDLocalDevice, (uint64_t)v81, v82);

                goto LABEL_63;
              }

              id v131 = sub_100070554();
              int v132 = _NRLogIsLevelEnabled(v131, 16LL);

              if (!v132) {
                goto LABEL_63;
              }
              uint64_t v27 = (NSString *)sub_100070554();
              _NRLogWithArgs( v27,  16,  "%s%.30s:%-4d %@: Invalid NRLinkIKEPrivateNotifyCodeDeviceFlags payload length %zu",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7937,  a1,  [v8 length]);
              break;
            case 48606:
              LOBYTE(location) = 0;
              if ([v8 length] == (id)1)
              {
                [v8 getBytes:&location length:1];
                __int128 v117 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v116);
                int v118 = _NRLogIsLevelEnabled(v117, 0LL);

                if (v118)
                {
                  int v120 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v119);
                  id v121 = [(id)a1 copyDescription];
                  _NRLogWithArgs( v120,  0LL,  "%s%.30s:%-4d %@: Received remote device type %u",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7744LL,  v121,  location);
                }

                uint64_t v122 = location;
                uint64_t v123 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 nrUUID]);
                sub_100135884((uint64_t)&OBJC_CLASS___NRDLocalDevice, v122, v123);
              }

              goto LABEL_63;
            case 48607:
              uint64_t v27 = -[NSString initWithData:encoding:]( objc_alloc(&OBJC_CLASS___NSString),  "initWithData:encoding:",  v8,  4LL);
              uint64_t v125 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v124);
              int v126 = _NRLogIsLevelEnabled(v125, 0LL);

              if (v126)
              {
                uint64_t v128 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v127);
                id v129 = [(id)a1 copyDescription];
                Logid String = (void *)_NRKeyCreateLogString(v8);
                _NRLogWithArgs( v128,  0LL,  "%s%.30s:%-4d %@: Received remote IDS device ID %@",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7751LL,  v129,  LogString);
              }

              id v28 = (id)objc_claimAutoreleasedReturnValue([(id)a1 nrUUID]);
              sub_100138494((uint64_t)&OBJC_CLASS___NRDLocalDevice, v27, v28);
              goto LABEL_61;
            default:
              if (!(_DWORD)a2) {
                goto LABEL_57;
              }
              if ((_DWORD)a2 != 48701) {
                goto LABEL_75;
              }
              char v262 = 0;
              if ([v8 length])
              {
                [v8 getBytes:&v262 length:1];
                if (v262 < 0 && !*(_BYTE *)(a1 + 236))
                {
                  *(_BYTE *)(a1 + 236) = 1;
                  objc_initWeak(&location, (id)a1);
                  id v47 = sub_1001438EC((uint64_t)&OBJC_CLASS___NRDKeyManager);
                  v260[0] = _NSConcreteStackBlock;
                  v260[1] = 3221225472LL;
                  v260[2] = sub_10007B2FC;
                  v260[3] = &unk_1001AFED0;
                  objc_copyWeak(&v261, &location);
                  sub_100144478((uint64_t)v47, v260);

                  objc_destroyWeak(&v261);
                  objc_destroyWeak(&location);
                }
              }

              goto LABEL_63;
          }

          goto LABEL_62;
        }

        uint64_t v33 = ((_DWORD)a2 - 50351);
        if (((1LL << (a2 + 81)) & 0x701C000000000000LL) == 0)
        {
          if ((_DWORD)a2 == 50351)
          {
            [(id)a1 reportEvent:3401 details:@"Identity"];
            __int128 v115 = *(void **)(a1 + 32);
            v257[0] = _NSConcreteStackBlock;
            v257[1] = 3221225472LL;
            v257[2] = sub_10007B6C4;
            v257[3] = &unk_1001AEBB8;
            v257[4] = a1;
            sub_100133320((uint64_t)&OBJC_CLASS___NRDLocalDevice, v8, v115, v257);
            goto LABEL_63;
          }

          if (v33 == 1)
          {
            uint64_t v34 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v20);
            int v35 = _NRLogIsLevelEnabled(v34, 0LL);

            if (v35)
            {
              uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v36);
              id v38 = [(id)a1 copyDescription];
              _NRLogWithArgs( v37,  0LL,  "%s%.30s:%-4d %@: Received request for device identity",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7930LL,  v38);
            }

            sub_10007B918((void *)a1);
            goto LABEL_63;
          }

          goto LABEL_75;
        }

        goto LABEL_57;
      }

      if ((int)a2 <= 50800)
      {
        if ((_DWORD)a2 == 50701)
        {
          sub_100136084((uint64_t)&OBJC_CLASS___NRDLocalDevice, v8, *(void **)(a1 + 32));
          [(id)a1 checkProxyAgentWithForceUpdate:0];
          goto LABEL_63;
        }

        if ((_DWORD)a2 == 50702)
        {
          [v21 linkDidReceiveData:a1 data:v8];
          goto LABEL_63;
        }
      }

      else
      {
        if ((int)a2 <= 51300)
        {
          switch((int)a2)
          {
            case 50801:
              if (*(_BYTE *)(a1 + 242))
              {
                id v29 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v20);
                int v30 = _NRLogIsLevelEnabled(v29, 16LL);

                if (!v30) {
                  goto LABEL_63;
                }
                uint64_t v27 = (NSString *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v31);
                id v28 = [(id)a1 copyDescription];
                uint64_t v253 = 7817LL;
                id v256 = v28;
                int v32 = "%s%.30s:%-4d %@: Did not expect InnerAddressInitiatorClassD as responder";
                goto LABEL_74;
              }

              id location = 0LL;
              uint64_t v259 = 0LL;
              if ((unint64_t)[v8 length] <= 0xF)
              {
                id v142 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v141);
                int v143 = _NRLogIsLevelEnabled(v142, 16LL);

                if (!v143) {
                  goto LABEL_63;
                }
                uint64_t v27 = (NSString *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v144);
                id v28 = [(id)a1 copyDescription];
                id v252 = v28;
                id v254 = v8;
                uint64_t v251 = 7822LL;
                uint64_t v52 = "%s%.30s:%-4d %@: InnerAddressInitiatorClassD payload too short %@";
                goto LABEL_136;
              }

              [v8 getBytes:&location length:16];
              if (!sub_100137184( (uint64_t)&OBJC_CLASS___NRDLocalDevice,  (uint64_t)&location,  *(void **)(a1 + 32)))
              {
                v222 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v179);
                int v223 = _NRLogIsLevelEnabled(v222, 0LL);

                if (v223)
                {
                  uint64_t v225 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v224);
                  id v226 = [(id)a1 copyDescription];
                  int v228 = (void *)createIPv6AddrString(&location, v227);
                  _NRLogWithArgs( v225,  0LL,  "%s%.30s:%-4d %@: received local classD address %@",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7838LL,  v226,  v228);
                }

                goto LABEL_63;
              }

              id v5 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 32));
              if (v5)
              {
                int v181 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v180);
                int v182 = _NRLogIsLevelEnabled(v181, 0LL);

                if (v182)
                {
                  uint64_t v184 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v183);
                  id v185 = [(id)a1 copyDescription];
                  IPv6Addrid String = (void *)createIPv6AddrString(a1 + 1951, v186);
                  id v189 = (void *)createIPv6AddrString(&location, v188);
                  _NRLogWithArgs( v184,  0LL,  "%s%.30s:%-4d %@: updated local classD address from %@ to %@",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7830LL,  v185,  IPv6AddrString,  v189);
                }

                sub_10012E070(v5, (_OWORD *)(a1 + 1951));
                sub_10007B330(a1);
                id v171 = (void *)sub_100137060(v5);
                [*(id *)(a1 + 1335) setLocalAddresses:v171];
                v191 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v190);
                int v192 = _NRLogIsLevelEnabled(v191, 0LL);

                if (v192)
                {
                  v194 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v193);
                  id v195 = [(id)a1 copyDescription];
                  int v196 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 1335) interfaceName]);
                  _NRLogWithArgs( v194,  0LL,  "%s%.30s:%-4d %@: updated interface %@ with addresses %@ (classD)",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7836LL,  v195,  v196,  v171);
                }

                goto LABEL_148;
              }

              id v242 = sub_100070554();
              int v243 = _NRLogIsLevelEnabled(v242, 16LL);

              if (v243)
              {
                id v244 = sub_100070554();
                _NRLogWithArgs( v244,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7828);
              }

              goto LABEL_183;
            case 50802:
              if (*(_BYTE *)(a1 + 242))
              {
                int v55 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v20);
                int v56 = _NRLogIsLevelEnabled(v55, 16LL);

                if (!v56) {
                  goto LABEL_63;
                }
                uint64_t v27 = (NSString *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v57);
                id v28 = [(id)a1 copyDescription];
                uint64_t v253 = 7870LL;
                id v256 = v28;
                int v32 = "%s%.30s:%-4d %@: Did not expect InnerAddressResponderClassD as responder";
                goto LABEL_74;
              }

              id location = 0LL;
              uint64_t v259 = 0LL;
              if ((unint64_t)[v8 length] <= 0xF)
              {
                id v134 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v133);
                int v135 = _NRLogIsLevelEnabled(v134, 16LL);

                if (!v135) {
                  goto LABEL_63;
                }
                uint64_t v27 = (NSString *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v136);
                id v28 = [(id)a1 copyDescription];
                id v252 = v28;
                id v254 = v8;
                uint64_t v251 = 7875LL;
                uint64_t v52 = "%s%.30s:%-4d %@: InnerAddressResponderClassD payload too short %@";
                goto LABEL_136;
              }

              [v8 getBytes:&location length:16];
              if (!sub_1001379CC( (uint64_t)&OBJC_CLASS___NRDLocalDevice,  (uint64_t)&location,  *(void **)(a1 + 32)))
              {
                int v208 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v149);
                int v209 = _NRLogIsLevelEnabled(v208, 0LL);

                if (v209)
                {
                  id v211 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v210);
                  id v212 = [(id)a1 copyDescription];
                  uint64_t v214 = (void *)createIPv6AddrString(&location, v213);
                  _NRLogWithArgs( v211,  0LL,  "%s%.30s:%-4d %@: received remote classD address %@",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7888LL,  v212,  v214);
                }

                goto LABEL_63;
              }

              id v5 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 32));
              if (v5)
              {
                int v151 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v150);
                int v152 = _NRLogIsLevelEnabled(v151, 0LL);

                if (v152)
                {
                  id v154 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v153);
                  id v155 = [(id)a1 copyDescription];
                  uint64_t v157 = (void *)createIPv6AddrString(a1 + 1967, v156);
                  id v159 = (void *)createIPv6AddrString(&location, v158);
                  _NRLogWithArgs( v154,  0LL,  "%s%.30s:%-4d %@: updated remote classD address from %@ to %@",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7883LL,  v155,  v157,  v159);
                }

                sub_10012D7C8(v5, (_OWORD *)(a1 + 1967));
                sub_10007B330(a1);
                sub_10007B498(a1);

                goto LABEL_63;
              }

              id v236 = sub_100070554();
              int v237 = _NRLogIsLevelEnabled(v236, 16LL);

              if (v237)
              {
                id v238 = sub_100070554();
                _NRLogWithArgs( v238,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7881);
              }

              goto LABEL_183;
            case 50803:
            case 50804:
            case 50805:
            case 50806:
            case 50807:
            case 50808:
            case 50809:
            case 50810:
              goto LABEL_75;
            case 50811:
              if (*(_BYTE *)(a1 + 242))
              {
                uint64_t v58 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v20);
                int v59 = _NRLogIsLevelEnabled(v58, 16LL);

                if (!v59) {
                  goto LABEL_63;
                }
                uint64_t v27 = (NSString *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v60);
                id v28 = [(id)a1 copyDescription];
                uint64_t v253 = 7844LL;
                id v256 = v28;
                int v32 = "%s%.30s:%-4d %@: Did not expect InnerAddressInitiatorClassC as responder";
                goto LABEL_74;
              }

              id location = 0LL;
              uint64_t v259 = 0LL;
              if ((unint64_t)[v8 length] <= 0xF)
              {
                int v138 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v137);
                int v139 = _NRLogIsLevelEnabled(v138, 16LL);

                if (!v139) {
                  goto LABEL_63;
                }
                uint64_t v27 = (NSString *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v140);
                id v28 = [(id)a1 copyDescription];
                id v252 = v28;
                id v254 = v8;
                uint64_t v251 = 7849LL;
                uint64_t v52 = "%s%.30s:%-4d %@: InnerAddressInitiatorClassC payload too short %@";
                goto LABEL_136;
              }

              [v8 getBytes:&location length:16];
              if (sub_1001375A8( (uint64_t)&OBJC_CLASS___NRDLocalDevice,  (uint64_t)&location,  *(void **)(a1 + 32)))
              {
                id v5 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 32));
                if (!v5)
                {
                  id v239 = sub_100070554();
                  int v240 = _NRLogIsLevelEnabled(v239, 16LL);

                  if (v240)
                  {
                    id v241 = sub_100070554();
                    _NRLogWithArgs( v241,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7855);
                  }

                  goto LABEL_183;
                }

                uint64_t v162 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v161);
                int v163 = _NRLogIsLevelEnabled(v162, 0LL);

                if (v163)
                {
                  unsigned int v165 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v164);
                  id v166 = [(id)a1 copyDescription];
                  uint64_t v168 = (void *)createIPv6AddrString(a1 + 1983, v167);
                  v170 = (void *)createIPv6AddrString(&location, v169);
                  _NRLogWithArgs( v165,  0LL,  "%s%.30s:%-4d %@: updated local classC address from %@ to %@",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7857LL,  v166,  v168,  v170);
                }

                sub_1001368D4(v5, (_OWORD *)(a1 + 1983));
                id v171 = (void *)sub_100137060(v5);
                [*(id *)(a1 + 1335) setLocalAddresses:v171];
                uint64_t v173 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v172);
                int v174 = _NRLogIsLevelEnabled(v173, 0LL);

                if (v174)
                {
                  uint64_t v176 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v175);
                  id v177 = [(id)a1 copyDescription];
                  uint64_t v178 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 1335) interfaceName]);
                  _NRLogWithArgs( v176,  0LL,  "%s%.30s:%-4d %@: updated interface %@ with addresses %@ (classC)",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7862LL,  v177,  v178,  v171);
                }

LABEL_148:
              }

              else
              {
                v215 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v160);
                int v216 = _NRLogIsLevelEnabled(v215, 0LL);

                if (v216)
                {
                  int v218 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v217);
                  id v219 = [(id)a1 copyDescription];
                  id v221 = (void *)createIPv6AddrString(&location, v220);
                  _NRLogWithArgs( v218,  0LL,  "%s%.30s:%-4d %@: received local classC address %@",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7864LL,  v219,  v221);
                }
              }

              goto LABEL_63;
            case 50812:
              if (*(_BYTE *)(a1 + 242))
              {
                int v61 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v20);
                int v62 = _NRLogIsLevelEnabled(v61, 16LL);

                if (!v62) {
                  goto LABEL_63;
                }
                uint64_t v27 = (NSString *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v63);
                id v28 = [(id)a1 copyDescription];
                uint64_t v253 = 7894LL;
                id v256 = v28;
                int v32 = "%s%.30s:%-4d %@: Did not expect InnerAddressResponderClassC as responder";
LABEL_74:
                _NRLogWithArgs( v27,  16LL,  v32,  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  v253,  v256);
                goto LABEL_61;
              }

              id location = 0LL;
              uint64_t v259 = 0LL;
              if ((unint64_t)[v8 length] <= 0xF)
              {
                id v146 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v145);
                int v147 = _NRLogIsLevelEnabled(v146, 16LL);

                if (!v147) {
                  goto LABEL_63;
                }
                uint64_t v27 = (NSString *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v148);
                id v28 = [(id)a1 copyDescription];
                id v252 = v28;
                id v254 = v8;
                uint64_t v251 = 7899LL;
                uint64_t v52 = "%s%.30s:%-4d %@: InnerAddressResponderClassC payload too short %@";
LABEL_136:
                id v53 = v27;
                uint64_t v54 = 16LL;
                goto LABEL_60;
              }

              [v8 getBytes:&location length:16];
              if (!sub_100137DF0( (uint64_t)&OBJC_CLASS___NRDLocalDevice,  (uint64_t)&location,  *(void **)(a1 + 32)))
              {
                uint64_t v229 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v197);
                int v230 = _NRLogIsLevelEnabled(v229, 0LL);

                if (v230)
                {
                  int v232 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v231);
                  id v233 = [(id)a1 copyDescription];
                  id v235 = (void *)createIPv6AddrString(&location, v234);
                  _NRLogWithArgs( v232,  0LL,  "%s%.30s:%-4d %@: received remote classC address %@",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7912LL,  v233,  v235);
                }

                goto LABEL_63;
              }

              id v5 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 32));
              if (v5)
              {
                id v199 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v198);
                int v200 = _NRLogIsLevelEnabled(v199, 0LL);

                if (v200)
                {
                  int v202 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v201);
                  id v203 = [(id)a1 copyDescription];
                  id v205 = (void *)createIPv6AddrString(a1 + 1999, v204);
                  id v207 = (void *)createIPv6AddrString(&location, v206);
                  _NRLogWithArgs( v202,  0LL,  "%s%.30s:%-4d %@: updated remote classC address from %@ to %@",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7907LL,  v203,  v205,  v207);
                }

                sub_10012D7C8(v5, (_OWORD *)(a1 + 1999));
                sub_10007B498(a1);

                goto LABEL_63;
              }

              id v245 = sub_100070554();
              int v246 = _NRLogIsLevelEnabled(v245, 16LL);

              if (v246)
              {
                id v247 = sub_100070554();
                _NRLogWithArgs( v247,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7905);
              }

LABEL_183:
              __int128 v21 = (void *)_os_log_pack_size(12LL);
              id v8 = (char *)v257 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v248 = __error();
              uint64_t v249 = _os_log_pack_fill( v8,  v21,  *v248,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
              *(_DWORD *)uint64_t v249 = 136446210;
              *(void *)(v249 + 4) = "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]";
              id v250 = sub_100070554();
              _NRLogAbortWithPack(v250, v8);
              __break(1u);
LABEL_184:
              unsigned int v105 = 0;
LABEL_95:
              uint64_t v106 = (uint64_t)&v11[64];
              uint64_t v107 = *(unsigned __int16 *)(a1 + v4[347]);
              unsigned int v108 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 nrUUID]);
              sub_1001356B8(v106, v107, v108);

              if (a2)
              {
                unsigned int v109 = *((unsigned __int16 *)a2 + 14);
                if (v105 >= v109) {
                  unsigned int v110 = *((unsigned __int16 *)a2 + 14);
                }
                else {
                  unsigned int v110 = v105;
                }
                if (v105 <= v109) {
                  unsigned int v105 = *((unsigned __int16 *)a2 + 14);
                }
                if ((_DWORD)v5 != 4) {
                  goto LABEL_171;
                }
              }

              else
              {
                unsigned int v110 = 0;
                if ((_DWORD)v5 != 4)
                {
LABEL_171:

                  goto LABEL_63;
                }
              }

              if (v110 <= 0x10 && v105 >= 0x11)
              {
                int v111 = a2 ? (void *)*((void *)a2 + 16) : 0LL;
                id v112 = v111;
                BOOL v113 = [v112 proxyCapability] == (id)1;

                if (v113) {
                  sub_10007AF10(a1);
                }
              }

              if (a2)
              {
                id v114 = *((id *)a2 + 8);
                if (v114)
                {
                }

                else if (*((unsigned __int16 *)a2 + 14) >= 0x14u)
                {
                  sub_10007B0FC((void *)a1);
                }
              }

              goto LABEL_171;
            default:
              int v48 = 50901;
              goto LABEL_56;
          }
        }

        if ((int)a2 <= 51500)
        {
          if ((_DWORD)a2 != 51301)
          {
            if ((_DWORD)a2 == 51401)
            {
              LOBYTE(location) = 0;
              [v8 getBytes:&location length:1];
              uint64_t v40 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v39);
              int v41 = _NRLogIsLevelEnabled(v40, 0LL);

              if (v41)
              {
                uint64_t v43 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v42);
                id v44 = [(id)a1 copyDescription];
                _NRLogWithArgs( v43,  0LL,  "%s%.30s:%-4d %@: Received Always On Wi-Fi supported: %u",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7758LL,  v44,  location);
              }

              BOOL v45 = location == 1;
              int v46 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 nrUUID]);
              sub_100135EB0((uint64_t)&OBJC_CLASS___NRDLocalDevice, v45, v46);

              goto LABEL_63;
            }

            goto LABEL_75;
          }

LABEL_63:
          goto LABEL_64;
        }

        if ((_DWORD)a2 == 51501)
        {
          LOBYTE(location) = 0;
          [v8 getBytes:&location length:1];
          int v68 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v67);
          int v69 = _NRLogIsLevelEnabled(v68, 0LL);

          if (v69)
          {
            id v71 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v70);
            id v72 = [(id)a1 copyDescription];
            _NRLogWithArgs( v71,  0LL,  "%s%.30s:%-4d %@: Received IsAltAccount: %u",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]",  7768LL,  v72,  location);
          }

          BOOL v73 = location == 1;
          uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 nrUUID]);
          sub_100136370((uint64_t)&OBJC_CLASS___NRDLocalDevice, v73, v74);

          goto LABEL_63;
        }

        int v48 = 51601;
LABEL_56:
        if ((_DWORD)a2 == v48) {
          goto LABEL_57;
        }
      }

    return;
  }

  int v18 = os_channel_attr_create();
  if (!v18)
  {
    uint64_t v36 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v19);
    uint64_t v37 = _NRLogIsLevelEnabled(v36, 17LL);

    if (v37)
    {
      uint64_t v27 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v38);
      id v28 = [(id)a1 copyDescription];
      _NRLogWithArgs(v27, 17LL, "%@: os_channel_attr_create failed", v28, v134);
      goto LABEL_62;
    }

    goto LABEL_63;
  }

  uint64_t v20 = v18;
  attr = os_channel_read_attr(*(void *)(a1 + 1039), v18);
  if ((_DWORD)attr)
  {
    uint64_t v23 = attr;
    uint64_t v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v22);
    int v25 = _NRLogIsLevelEnabled(v24, 17LL);

    if (v25)
    {
      uint64_t v27 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v26);
      id v28 = [(id)a1 copyDescription];
      _NRLogWithArgs(v27, 17LL, "%@: os_channel_read_attr returned %d", v28, v23);
LABEL_62:

      goto LABEL_63;
    }

    goto LABEL_63;
  }

  uint64_t v39 = sub_1000821D4((void *)a1, v20);
  os_channel_attr_destroy(v20);
  if (!v39) {
    goto LABEL_63;
  }
  uint64_t v40 = os_channel_ring_id(*(void *)(a1 + 1039), 2LL);
  int v41 = os_channel_rx_ring(*(void *)(a1 + 1039), v40);
  *(void *)(a1 + 1047) = v41;
  if (!v41)
  {
    int v62 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v42);
    uint64_t v63 = _NRLogIsLevelEnabled(v62, 17LL);

    if (!v63) {
      goto LABEL_63;
    }
    uint64_t v27 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v64);
    id v28 = [(id)a1 copyDescription];
    _NRLogWithArgs(v27, 17LL, "%@: _datagramLinkInputRing is NULL", v28, v134);
    goto LABEL_62;
  }

  uint64_t v43 = os_channel_ring_id(*(void *)(a1 + 1039), 0LL);
  id v44 = os_channel_tx_ring(*(void *)(a1 + 1039), v43);
  *(void *)(a1 + 1055) = v44;
  if (!v44)
  {
    int v65 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v45);
    uint64_t v66 = _NRLogIsLevelEnabled(v65, 17LL);

    if (!v66) {
      goto LABEL_63;
    }
    uint64_t v27 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v67);
    id v28 = [(id)a1 copyDescription];
    _NRLogWithArgs(v27, 17LL, "%@: _datagramLinkOutputRing is NULL", v28, v134);
    goto LABEL_62;
  }

  unsigned int fd = os_channel_get_fd(*(void *)(a1 + 1039));
  if ((fd & 0x80000000) != 0)
  {
    int v68 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v47);
    int v69 = _NRLogIsLevelEnabled(v68, 17LL);

    if (!v69) {
      goto LABEL_63;
    }
    uint64_t v27 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v70);
    id v28 = [(id)a1 copyDescription];
    _NRLogWithArgs(v27, 17LL, "%@: os_channel_get_fd failed", v28, v134);
    goto LABEL_62;
  }

  int v48 = fd;
  id v49 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_read,  fd,  0LL,  *(dispatch_queue_t *)(a1 + 8));
  int v50 = *(void **)(a1 + 1063);
  *(void *)(a1 + 1063) = v49;

  uint64_t v52 = *(dispatch_source_s **)(a1 + 1063);
  if (!v52)
  {
    id v71 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v51);
    id v72 = _NRLogIsLevelEnabled(v71, 17LL);

    if (!v72) {
      goto LABEL_63;
    }
    uint64_t v27 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v73);
    id v28 = [(id)a1 copyDescription];
    _NRLogWithArgs(v27, 17LL, "%@: _dDatagramLinkInputSource is NULL", v28, v134);
    goto LABEL_62;
  }

  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  int v135 = v48;
  handler[2] = sub_10009DBD0;
  handler[3] = &unk_1001B0A88;
  void handler[4] = a1;
  dispatch_source_set_event_handler(v52, handler);
  id v53 = *(dispatch_source_s **)(a1 + 1063);
  v139[0] = _NSConcreteStackBlock;
  v139[1] = 3221225472LL;
  v139[2] = nullsub_8;
  v139[3] = &unk_1001B0A88;
  uint64_t v54 = v6;
  uint64_t v140 = v54;
  dispatch_source_set_cancel_handler(v53, v139);
  dispatch_activate(*(dispatch_object_t *)(a1 + 1063));
  int v55 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_write,  v48,  0LL,  *(dispatch_queue_t *)(a1 + 8));
  int v56 = *(void **)(a1 + 1071);
  *(void *)(a1 + 1071) = v55;

  uint64_t v58 = *(dispatch_source_s **)(a1 + 1071);
  if (!v58)
  {
    uint64_t v74 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v57);
    uint64_t v75 = _NRLogIsLevelEnabled(v74, 17LL);

    if (v75)
    {
      int v77 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v76);
      uint64_t v78 = [(id)a1 copyDescription];
      _NRLogWithArgs(v77, 17LL, "%@: _dDatagramLinkOutputSource is NULL", v78);
    }

    goto LABEL_63;
  }

  v138[0] = _NSConcreteStackBlock;
  v138[1] = 3221225472LL;
  v138[2] = sub_10009DDB4;
  v138[3] = &unk_1001B0A88;
  v138[4] = a1;
  dispatch_source_set_event_handler(v58, v138);
  int v59 = *(dispatch_source_s **)(a1 + 1071);
  v136[0] = _NSConcreteStackBlock;
  v136[1] = 3221225472LL;
  v136[2] = nullsub_9;
  v136[3] = &unk_1001B0A88;
  uint64_t v137 = v54;
  dispatch_source_set_cancel_handler(v59, v136);
  *(_BYTE *)(a1 + 224) = 1;
  *(_BYTE *)(a1 + 254) = 10;
  uint64_t v60 = *(unsigned __int8 *)(a1 + 254);
  if (!*(_BYTE *)(a1 + 254))
  {
LABEL_74:

    goto LABEL_4;
  }

  int v61 = 8 * v60;
  __memptr = 0LL;
  if (!posix_memalign(&__memptr, 8uLL, 8 * v60) && __memptr)
  {
    *(void *)(a1 + 1911) = __memptr;
    goto LABEL_74;
  }

  uint64_t v124 = sub_100070554();
  uint64_t v125 = _NRLogIsLevelEnabled(v124, 16LL);

  if (v125)
  {
    int v126 = sub_100070554();
    _NRLogWithArgs( v126,  16LL,  "%s%.30s:%-4d ABORTING: posix_memalign(..., %zu, %zu) failed",  "",  "strict_memalign",  183,  8uLL,  v61);
  }

  uint64_t v127 = _os_log_pack_size(32LL);
  uint64_t v128 = (char *)&v136[-1] - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
  id v129 = __error();
  id v130 = _os_log_pack_fill( v128,  v127,  *v129,  &_mh_execute_header,  "%{public}s posix_memalign(..., %zu, %zu) failed");
  *(_DWORD *)id v130 = 136446722;
  *(void *)(v130 + 4) = "strict_memalign";
  *(_WORD *)(v130 + 12) = 2048;
  *(void *)(v130 + 14) = 8LL;
  *(_WORD *)(v130 + 22) = 2048;
  *(void *)(v130 + 24) = v61;
  id v131 = sub_100070554();
  int v132 = (char *)_NRLogAbortWithPack(v131, v128);
  sub_100080D40(v132, v133);
}

    uint64_t v40 = (void *)v27[5];
    _WORD v27[5] = p_class_meths;

    goto LABEL_64;
  }

  uint64_t v84 = sub_1000A2100();
  unsigned int v85 = _NRLogIsLevelEnabled(v84, 0LL);

  if (!v85) {
    goto LABEL_65;
  }
  uint64_t v26 = (dispatch_queue_s *)sub_1000A2100();
  _NRLogWithArgs( v26,  0LL,  "%s%.30s:%-4d Skipping initialization of NRLinkManagerBluetooth for unsupported device",  "",  "-[NRLinkDirector setupManagers]",  500);
LABEL_64:

LABEL_65:
  objc_opt_self(&OBJC_CLASS___NRDKeyManager);
  if (qword_1001DCC18 != -1) {
    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
  }
  int v41 = (id)qword_1001DCC10;
  v93[0] = _NSConcreteStackBlock;
  v93[1] = 3221225472LL;
  v93[2] = sub_1000ADBEC;
  v93[3] = &unk_1001B0A88;
  v93[4] = a1;
  sub_100144478((uint64_t)v41, v93);

  sub_1000ADAF0(a1);
  if (!*(void *)(a1 + 192))
  {
    uint64_t v42 = objc_alloc(&OBJC_CLASS___NROnDemandLinkSetupManager);
    uint64_t v43 = *(id *)(a1 + 136);
    id v44 = sub_100012CC0((id *)&v42->super.isa, v43);
    BOOL v45 = *(void **)(a1 + 192);
    *(void *)(a1 + 192) = v44;

    int v46 = *(void *)(a1 + 192);
    if (v46)
    {
      if (!*(_BYTE *)(v46 + 8))
      {
        *(_BYTE *)(v46 + _Block_object_dispose(va, 8) = 1;
        id v47 = (_DWORD *)(v46 + 20);
        if (*(_DWORD *)(v46 + 20) == -1)
        {
          objc_initWeak(&location, (id)v46);
          block.receiver = _NSConcreteStackBlock;
          block.super_class = (Class)3221225472LL;
          uint64_t v95 = sub_1000144F0;
          uint64_t v96 = &unk_1001B0938;
          objc_copyWeak(v97, &location);
          int v48 = objc_retainBlock(&block);
          id v49 = (dispatch_queue_s *)*(id *)(v46 + 32);
          int v50 = notify_register_dispatch("com.apple.CoreTelephony.Slicing.LLPHS.State", (int *)(v46 + 20), v49, v48);

          if (v50)
          {
            *id v47 = -1;
            p_class_meths = (_UNKNOWN **)&OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
            if (qword_1001DC680 != -1) {
              dispatch_once(&qword_1001DC680, &stru_1001AE190);
            }
            uint64_t v51 = (id)qword_1001DC678;
            uint64_t v52 = _NRLogIsLevelEnabled(v51, 17LL);

            if ((v52 & 1) != 0)
            {
              if (qword_1001DC680 != -1) {
                dispatch_once(&qword_1001DC680, &stru_1001AE190);
              }
              id v53 = (id)qword_1001DC678;
              _NRLogWithArgs( v53,  17LL,  "notify_register_check(%s) failed: %u",  "com.apple.CoreTelephony.Slicing.LLPHS.State",  v50);
            }
          }

          else
          {
            ((void (*)(objc_super *, void))v48[1].receiver)(v48, *v47);
          }

          objc_destroyWeak(v97);
          objc_destroyWeak(&location);
        }

        objc_initWeak(&location, (id)v46);
        uint64_t v70 = *(void **)(v46 + 32);
        block.receiver = _NSConcreteStackBlock;
        block.super_class = (Class)3221225472LL;
        uint64_t v95 = sub_100012E68;
        uint64_t v96 = &unk_1001AFED0;
        id v71 = v70;
        objc_copyWeak(v97, &location);
        dispatch_async(v71, &block);

        objc_destroyWeak(v97);
        objc_destroyWeak(&location);
      }
    }
  }

      if (v10) {
        [v10 setIsPrimary:0];
      }
      if (*v9)
      {
        [*v9 setIsPrimary:1];
        sub_1000E1878(a1, *(void **)(a1 + 128));
        unsigned int v108 = NEVirtualInterfaceCopyName([*(id *)(a1 + 128) virtualInterface]);
        unsigned int v109 = *(void **)(a1 + 408);
        *(void *)(a1 + 40_Block_object_dispose(va, 8) = v108;
      }

      else
      {
        unsigned int v109 = *(void **)(a1 + 408);
        *(void *)(a1 + 40_Block_object_dispose(va, 8) = 0LL;
      }

      unsigned int v110 = [v10 type];
      if (v170 && v110 == 1)
      {
        int v111 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v170);
        id v112 = _NRLogIsLevelEnabled(v111, 1LL);

        if (v112)
        {
          id v114 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v113);
          _NRLogWithArgs( v114,  1LL,  "%s%.30s:%-4d Suspending bluetooth link",  "",  "-[NRDDeviceConductor setPrimaryLink:]",  1579);
        }

        [v10 suspend];
      }

      else if ([*v9 type] == 1 && objc_msgSend(*v9, "state") != 8)
      {
        uint64_t v116 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v115);
        __int128 v117 = _NRLogIsLevelEnabled(v116, 1LL);

        if (v117)
        {
          uint64_t v119 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v118);
          _NRLogWithArgs( v119,  1LL,  "%s%.30s:%-4d Resuming bluetooth link",  "",  "-[NRDDeviceConductor setPrimaryLink:]",  1582);
        }

        [v10 resume];
      }

      sub_1000DDA30(a1, 0);
      sub_1000D2088(a1, 1, 1);
      if (*(void *)(a1 + 664))
      {
        if (!*(void *)(a1 + 680))
        {
LABEL_82:
          int v120 = objc_alloc(&OBJC_CLASS___NSString);
          id v155 = (char *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 96) UUIDString]);
          id v121 = -[NSString initWithFormat:](v120, "initWithFormat:", @"NRDDC-%@-%@");

          uint64_t v122 = *(void **)(a1 + 680);
          *(void *)(a1 + 680) = v121;
        }
      }

      else
      {
        uint64_t v140 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 96));
        if (sub_1001319A0((BOOL)v140))
        {
          uint64_t v141 = "CmpLnkAvailability";
        }

        else
        {
          if (v140) {
            id v142 = (void *)*((void *)v140 + 16);
          }
          else {
            id v142 = 0LL;
          }
          int v143 = v142;
          uint64_t v144 = [v143 activeOperationalScope];

          if ((v144 & 1) == 0)
          {

LABEL_95:
            goto LABEL_96;
          }

          if (v140) {
            uint64_t v145 = (void *)*((void *)v140 + 16);
          }
          else {
            uint64_t v145 = 0LL;
          }
          id v146 = v145;
          int v147 = (void *)objc_claimAutoreleasedReturnValue([v146 allowedLinkSubtypes]);
          uint64_t v148 = [v147 containsObject:&off_1001BC760];

          if (v148) {
            uint64_t v141 = "LowLatencyTetheringAvailability";
          }
          else {
            uint64_t v141 = "TetheringAvailability";
          }
        }

        uint64_t v149 = *(id *)(a1 + 104);
        uint64_t v150 = nw_agent_create("com.apple.networkrelay", v141, "", v149);
        int v151 = *(void **)(a1 + 664);
        *(void *)(a1 + 664) = v150;

        nw_agent_change_state(*(void *)(a1 + 664), 1LL, 2LL, 0LL);
        int v152 = objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](&OBJC_CLASS___NSString, "stringWithUTF8String:", v141));
        uint64_t v153 = *(void **)(a1 + 672);
        *(void *)(a1 + 672) = v152;

        if (!*(void *)(a1 + 680)) {
          goto LABEL_82;
        }
      }

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      uint64_t v123 = (id)qword_1001DCB58;
      sub_10012114C((uint64_t)v123, *(void **)(a1 + 680));

      if ([*(id *)(a1 + 128) state] == 8)
      {
        *(void *)__strerrbuf = 0LL;
        uint64_t v180 = 0LL;
        nw_agent_get_uuid(*(void *)(a1 + 664), __strerrbuf);
        uint64_t v124 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", __strerrbuf);
        uint64_t v125 = objc_alloc_init(&OBJC_CLASS___NSMutableArray);
        int v126 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
        -[NSMutableArray addObject:](v125, "addObject:", v126);

        uint64_t v127 = (void *)objc_claimAutoreleasedReturnValue( +[NSString stringWithUTF8String:]( &OBJC_CLASS___NSString,  "stringWithUTF8String:",  nrXPCEntitlementDeviceMonitor));
        uint64_t v128 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition customEntitlement:]( &OBJC_CLASS___NEPolicyCondition,  "customEntitlement:",  v127));
        -[NSMutableArray addObject:](v125, "addObject:", v128);

        id v129 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition requiredAgentDomain:agentType:]( &OBJC_CLASS___NEPolicyCondition,  "requiredAgentDomain:agentType:",  @"com.apple.networkrelay",  *(void *)(a1 + 672)));
        -[NSMutableArray addObject:](v125, "addObject:", v129);

        id v130 = objc_alloc(&OBJC_CLASS___NEPolicy);
        id v131 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult netAgentUUID:](&OBJC_CLASS___NEPolicyResult, "netAgentUUID:", v124));
        int v132 = [v130 initWithOrder:10 result:v131 conditions:v125];

        objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
        if (qword_1001DCB60 != -1) {
          dispatch_once(&qword_1001DCB60, &stru_1001B0538);
        }
        uint64_t v133 = (id)qword_1001DCB58;
        id v134 = sub_100120E44((uint64_t)v133, *(void **)(a1 + 680), v132);
      }

      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      int v135 = (id)qword_1001DCB58;
      uint64_t v136 = (id *)v135;
      if (v135)
      {
        dispatch_assert_queue_V2(*((dispatch_queue_t *)v135 + 1));
        if (([v136[2] apply] & 1) == 0) {
          sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v137,  v138,  v139,  (uint64_t)v155);
        }
      }

      goto LABEL_95;
    }

    objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
    if (qword_1001DCB60 != -1) {
      dispatch_once(&qword_1001DCB60, &stru_1001B0538);
    }
    int v32 = (id)qword_1001DCB58;
    sub_10012114C((uint64_t)v32, *(void **)(a1 + 296));

    uint64_t v33 = [*(id *)(a1 + 128) state];
    if (v18) {
      uint64_t v34 = (void *)*((void *)v18 + 16);
    }
    else {
      uint64_t v34 = 0LL;
    }
    int v35 = v34;
    uint64_t v36 = [v35 hasCompanionDatapath];

    uint64_t v37 = *v9;
    if (v36) {
      id v38 = NEVirtualInterfaceCopyName([v37 virtualInterface]);
    }
    else {
      id v38 = objc_claimAutoreleasedReturnValue([v37 localInterfaceName]);
    }
    uint64_t v39 = (void *)v38;
    if (v33 != 8)
    {
LABEL_41:
      objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
      if (qword_1001DCB60 != -1) {
        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
      }
      int v100 = (id)qword_1001DCB58;
      uint64_t v101 = (id *)v100;
      if (v100)
      {
        dispatch_assert_queue_V2(*((dispatch_queue_t *)v100 + 1));
        if (([v101[2] apply] & 1) == 0) {
          sub_1001030D0( @"NRPolicySessionManager",  @"ApplyPolicy Failed",  0LL,  1,  @"Failed to apply policies",  v102,  v103,  v104,  (uint64_t)v155);
        }
      }

      goto LABEL_47;
    }

    unsigned int v165 = (void *)v38;
    uint64_t v40 = objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
    int v41 = objc_claimAutoreleasedReturnValue(+[NEPolicyCondition usesModernNetworkAPI](&OBJC_CLASS___NEPolicyCondition, "usesModernNetworkAPI"));
    uint64_t v42 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition allowsUnsafeSocketAccess]( &OBJC_CLASS___NEPolicyCondition,  "allowsUnsafeSocketAccess"));
    [v42 setNegative:1];
    uint64_t v43 = objc_claimAutoreleasedReturnValue(+[NEPolicyResult skipWithOrder:](&OBJC_CLASS___NEPolicyResult, "skipWithOrder:", 620LL));
    id v44 = objc_alloc(&OBJC_CLASS___NEPolicy);
    *(void *)__strerrbuf = v40;
    uint64_t v180 = v41;
    uint64_t v161 = v42;
    uint64_t v162 = (void *)v41;
    int v181 = v42;
    BOOL v45 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  __strerrbuf,  3LL));
    int v46 = [v44 initWithOrder:600 result:v43 conditions:v45];

    id v47 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
    int v48 = sub_100120E44((uint64_t)v47, *(void **)(a1 + 296), v46);

    id v49 = +[NEPolicyCondition effectivePID:](&OBJC_CLASS___NEPolicyCondition, "effectivePID:", getpid());
    int v50 = objc_claimAutoreleasedReturnValue(v49);
    uint64_t v51 = objc_alloc(&OBJC_CLASS___NEPolicy);
    uint64_t v169 = (void *)v40;
    v178[0] = v40;
    v178[1] = v50;
    uint64_t v160 = (void *)v50;
    uint64_t v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v178, 2LL));
    uint64_t v168 = (void *)v43;
    id v53 = [v51 initWithOrder:600 result:v43 conditions:v52];

    uint64_t v54 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
    int v55 = sub_100120E44((uint64_t)v54, *(void **)(a1 + 296), v53);

    if (v18) {
      int v56 = (void *)*((void *)v18 + 16);
    }
    else {
      int v56 = 0LL;
    }
    uint64_t v57 = v56;
    uint64_t v58 = [v57 usesTLS];

    if (v58)
    {
      int v59 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 128) remoteOuterEndpoint]);
      int v163 = v53;
      uint64_t v60 = [v59 addressFamily];

      int v61 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 128) remoteOuterEndpoint]);
      int v62 = (void *)objc_claimAutoreleasedReturnValue([v61 hostname]);
      uint64_t v63 = objc_claimAutoreleasedReturnValue( +[NWAddressEndpoint endpointWithHostname:port:]( &OBJC_CLASS___NWAddressEndpoint,  "endpointWithHostname:port:",  v62,  @"0"));

      if (v60 == 30) {
        id v64 = 128LL;
      }
      else {
        id v64 = 32LL;
      }
      id v166 = (void *)v63;
      int v65 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition flowRemoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "flowRemoteAddress:prefix:",  v63,  v64));
      uint64_t v176 = v65;
      uint64_t v66 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      id v177 = v66;
      uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v176, 2LL));

      int v68 = [[NEPolicy alloc] initWithOrder:600 result:v168 conditions:v67];
      int v69 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
      uint64_t v70 = sub_100120E44((uint64_t)v69, *(void **)(a1 + 296), v68);
    }

    else
    {
      id v71 = sub_10012E41C(v18);
      id v166 = v71;
      if (v71)
      {
        id v72 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition flowRemoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "flowRemoteAddress:prefix:",  v71,  128LL));
        uint64_t v176 = v72;
        BOOL v73 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
        id v177 = v73;
        uint64_t v74 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v176, 2LL));

        uint64_t v75 = [[NEPolicy alloc] initWithOrder:600 result:v168 conditions:v74];
        id v76 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
        int v77 = sub_100120E44((uint64_t)v76, *(void **)(a1 + 296), v75);

        id v53 = v75;
      }

      int v65 = sub_10012E45C(v18);
      if (!v65)
      {
        uint64_t v164 = v53;
        goto LABEL_38;
      }

      uint64_t v67 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition flowRemoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "flowRemoteAddress:prefix:",  v65,  128LL));
      v175[0] = v67;
      uint64_t v78 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
      v175[1] = v78;
      int v69 = (id)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v175, 2LL));

      int v68 = [[NEPolicy alloc] initWithOrder:600 result:v168 conditions:v69];
      uint64_t v79 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
      id v80 = sub_100120E44((uint64_t)v79, *(void **)(a1 + 296), v68);
    }

    uint64_t v164 = v68;

LABEL_38:
    uint64_t v167 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyRouteRule routeRuleWithAction:forInterfaceName:]( &OBJC_CLASS___NEPolicyRouteRule,  "routeRuleWithAction:forInterfaceName:",  7LL,  v165));
    [v167 setControlUnit:0xFFFFFFFLL];
    id v81 = objc_claimAutoreleasedReturnValue(+[NEPolicyCondition flowIPProtocol:](&OBJC_CLASS___NEPolicyCondition, "flowIPProtocol:", 17LL));
    uint64_t v157 = objc_alloc(&OBJC_CLASS___NEPolicy);
    int v174 = v167;
    uint64_t v82 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v174, 1LL));
    int v83 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v82));
    v173[0] = v169;
    v173[1] = v81;
    id v159 = (void *)v81;
    uint64_t v84 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v173, 2LL));
    uint64_t v156 = [v157 initWithOrder:610 result:v83 conditions:v84];

    unsigned int v85 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
    int v86 = sub_100120E44((uint64_t)v85, *(void **)(a1 + 296), v156);

    uint64_t v87 = objc_claimAutoreleasedReturnValue(+[NEPolicyCondition flowIPProtocol:](&OBJC_CLASS___NEPolicyCondition, "flowIPProtocol:", 6LL));
    int v88 = objc_alloc(&OBJC_CLASS___NEPolicy);
    uint64_t v172 = v167;
    id v89 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v172, 1LL));
    id v90 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult routeRules:](&OBJC_CLASS___NEPolicyResult, "routeRules:", v89));
    v171[0] = v169;
    v171[1] = v87;
    uint64_t v158 = (void *)v87;
    id v91 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v171, 2LL));
    uint64_t v92 = [v88 initWithOrder:610 result:v90 conditions:v91];

    int v93 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
    int v94 = sub_100120E44((uint64_t)v93, *(void **)(a1 + 296), v92);

    uint64_t v96 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v95);
    id v97 = _NRLogIsLevelEnabled(v96, 0LL);

    if (v97)
    {
      uint64_t v99 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v98);
      id v155 = "";
      _NRLogWithArgs(v99, 0LL, "%s%.30s:%-4d %@: installed flow divert policies");
    }

    uint64_t v39 = v165;
    goto LABEL_41;
  }

        dispatch_once(&qword_1001DCB60, &stru_1001B0538);
        goto LABEL_48;
      }

      uint64_t v95 = sub_1000D54AC();
      uint64_t v96 = _NRLogIsLevelEnabled(v95, 16LL);

      if (v96)
      {
        id v97 = sub_1000D54AC();
        _NRLogWithArgs( v97,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (policyPrefix) != ((void *)0)",  "",  "-[NRDDeviceConductor setupCatchAllInterfaceIfApplicable]",  7895);
      }

      goto LABEL_69;
    }

    uint64_t v92 = sub_1000D54AC();
    int v93 = _NRLogIsLevelEnabled(v92, 16LL);

    if (v93)
    {
      int v94 = sub_1000D54AC();
      _NRLogWithArgs( v94,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (conditionPrefix) != ((void *)0)",  "",  "-[NRDDeviceConductor setupCatchAllInterfaceIfApplicable]",  7890);
    }

            [v25 addObject:v24];
          }
}

void sub_10007AEE4(_Unwind_Exception *a1)
{
}

void sub_10007AF10(uint64_t a1)
{
  uint64_t v2 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 32));
  if (sub_10010CE6C(v2))
  {
    uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v3);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

    if (IsLevelEnabled)
    {
      id v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v6);
      id v8 = [(id)a1 copyDescription];
      _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d %@: Sending proxy config to peer",  "",  "-[NRLinkBluetooth sendProxyConfig]",  7556LL,  v8);
    }

    objc_initWeak(&location, (id)a1);
    int v9 = *(void **)(a1 + 1223);
    id v10 = sub_10010CEF4(v2, 0LL);
    id v16 = v10;
    id v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v16, 1LL));
    id v12 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 queue]);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472LL;
    v13[2] = sub_10007BD5C;
    v13[3] = &unk_1001AF950;
    objc_copyWeak(&v14, &location);
    [v9 sendPrivateNotifies:v11 maxRetries:10 retryIntervalInMilliseconds:10000 callbackQueue:v12 callback:v13];

    objc_destroyWeak(&v14);
    objc_destroyWeak(&location);
  }
}

void sub_10007B0D0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
}

void sub_10007B0FC(void *a1)
{
  if (_os_feature_enabled_impl("terminus", "EncryptedIdentity"))
  {
    uint64_t v3 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v5);
      id v7 = [a1 copyDescription];
      _NRLogWithArgs( v6,  0LL,  "%s%.30s:%-4d %@: Requesting device identity from peer",  "",  "-[NRLinkBluetooth sendDeviceIdentityRequest]",  7611LL,  v7);
    }

    objc_initWeak(&location, a1);
    id v8 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50352 notifyData:0];
    int v9 = *(void **)((char *)a1 + 1223);
    id v15 = v8;
    id v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v15, 1LL));
    id v11 = (void *)objc_claimAutoreleasedReturnValue([a1 queue]);
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472LL;
    v12[2] = sub_10007BC4C;
    v12[3] = &unk_1001AF950;
    objc_copyWeak(&v13, &location);
    [v9 sendPrivateNotifies:v10 maxRetries:10 retryIntervalInMilliseconds:10000 callbackQueue:v11 callback:v12];

    objc_destroyWeak(&v13);
    objc_destroyWeak(&location);
  }

void sub_10007B2C0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
}

void sub_10007B2EC(uint64_t a1, void *a2)
{
}

void sub_10007B2FC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v2 = WeakRetained;
    sub_100076FE0(WeakRetained, 3LL);
    id WeakRetained = v2;
  }
}

void sub_10007B330(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 246))
  {
    id v10 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
    id v2 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a1 + 1951, 16LL);
    uint64_t v3 = -[NSData initWithBytes:length:](objc_alloc(&OBJC_CLASS___NSData), "initWithBytes:length:", a1 + 1967, 16LL);
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v10,  "setObject:forKeyedSubscript:",  v2,  @"source-address-bytes");
    -[NSMutableDictionary setObject:forKeyedSubscript:]( v10,  "setObject:forKeyedSubscript:",  v3,  @"destination-address-bytes");
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v4 = (id)qword_1001DC870;
    uint64_t v5 = v4;
    if (v4)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      id v7 = (void *)*((void *)v4 + 27);
      id v8 = v10;
      int v9 = (void *)objc_claimAutoreleasedReturnValue([v7 objectForKeyedSubscript:v6]);
      sub_1000EFBC8((uint64_t)v9, v8);
    }
  }

void sub_10007B498(uint64_t a1)
{
  uint64_t v20 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, *(void **)(a1 + 32));
  if (!v20)
  {
    id v12 = sub_100070554();
    int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 16LL);

    if (IsLevelEnabled)
    {
      id v14 = sub_100070554();
      _NRLogWithArgs( v14,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRLinkBluetooth addVirtualInterfaceRoutes]",  5800);
    }

    uint64_t v15 = _os_log_pack_size(12LL);
    id v16 = (char *)&v20 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v17 = __error();
    uint64_t v18 = _os_log_pack_fill( v16,  v15,  *v17,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)",  v20);
    *(_DWORD *)uint64_t v18 = 136446210;
    *(void *)(v18 + 4) = "-[NRLinkBluetooth addVirtualInterfaceRoutes]";
    id v19 = sub_100070554();
    _NRLogAbortWithPack(v19, v16);
  }

  NEVirtualInterfaceRemoveAllRoutes(*(void *)(a1 + 56), 1LL, 0LL);
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v3 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v3);

  id v4 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v4);

  uint64_t v5 = sub_10012D254(v20, @"0");
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v5 hostname]);

  NEVirtualInterfaceAddIPv6Route(v2, v6, &off_1001BC670, 0LL, 0LL);
  uint64_t v7 = *(void *)(a1 + 56);
  id v8 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v8);

  int v9 = sub_100146AFC();
  dispatch_assert_queue_V2((dispatch_queue_t)v9);

  id v10 = sub_10012D610(v20, @"0");
  id v11 = (void *)objc_claimAutoreleasedReturnValue([v10 hostname]);

  NEVirtualInterfaceAddIPv6Route(v7, v11, &off_1001BC670, 0LL, 0LL);
  NEVirtualInterfaceUpdateAdHocService(*(void *)(a1 + 56));
  [(id)a1 checkProxyAgentWithForceUpdate:1];
}

void sub_10007B6C4(uint64_t a1, void *a2)
{
  id v29 = a2;
  id v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v3);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

  if (IsLevelEnabled)
  {
    uint64_t v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
    id v8 = [*(id *)(a1 + 32) copyDescription];
    _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d %@: Plumbed device identity %@",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]_block_invoke",  7921LL,  v8,  v29);
  }

  int v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
  int v10 = _NRLogIsLevelEnabled(v9, 0LL);

  if (v10)
  {
    id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v11);
    id v13 = [*(id *)(a1 + 32) copyDescription];
    if (v29)
    {
      id v14 = v29[8];
      uint64_t v15 = v14;
      if (v14) {
        id v16 = (void *)*((void *)v14 + 1);
      }
      else {
        id v16 = 0LL;
      }
    }

    else
    {
      uint64_t v15 = 0LL;
      id v16 = 0LL;
    }

    id v17 = v16;
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v17 UUIDString]);
    _NRLogWithArgs( v12,  0LL,  "%s%.30s:%-4d %@: deviceIdentityUUID=%@",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]_block_invoke",  7923LL,  v13,  v18);
  }

  id v19 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v11);
  int v20 = _NRLogIsLevelEnabled(v19, 0LL);

  if (v20)
  {
    int v22 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v21);
    id v23 = [*(id *)(a1 + 32) copyDescription];
    if (v29)
    {
      id v24 = v29[8];
      int v25 = v24;
      if (v24) {
        uint64_t v26 = (void *)*((void *)v24 + 2);
      }
      else {
        uint64_t v26 = 0LL;
      }
    }

    else
    {
      int v25 = 0LL;
      uint64_t v26 = 0LL;
    }

    id v27 = v26;
    Logid String = (void *)_NRKeyCreateLogString(v27);
    _NRLogWithArgs( v22,  0LL,  "%s%.30s:%-4d %@: deviceIdentityPublicKey=%@",  "",  "-[NRLinkBluetooth handleNotifyCode:payload:dataProtectionClass:]_block_invoke",  7925LL,  v23,  LogString);
  }
}

void sub_10007B918(void *a1)
{
  if (_os_feature_enabled_impl("terminus", "EncryptedIdentity"))
  {
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([a1 nrUUID]);
    uint64_t v3 = sub_100132028((uint64_t)&OBJC_CLASS___NRDLocalDevice, v2);

    if (v3)
    {
      uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v4);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

      if (IsLevelEnabled)
      {
        id v8 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v7);
        id v9 = [a1 copyDescription];
        _NRLogWithArgs( v8,  0LL,  "%s%.30s:%-4d %@: Sending device identity to peer",  "",  "-[NRLinkBluetooth sendDeviceIdentity]",  7644LL,  v9);
      }

      objc_initWeak(&location, a1);
      id v10 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:50351 notifyData:v3];
      uint64_t v11 = *(void **)((char *)a1 + 1223);
      id v17 = v10;
      id v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v17, 1LL));
      id v13 = (void *)objc_claimAutoreleasedReturnValue([a1 queue]);
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 3221225472LL;
      _OWORD v14[2] = sub_10007BB3C;
      v14[3] = &unk_1001AF950;
      objc_copyWeak(&v15, &location);
      [v11 sendPrivateNotifies:v12 maxRetries:10 retryIntervalInMilliseconds:10000 callbackQueue:v13 callback:v14];

      objc_destroyWeak(&v15);
      objc_destroyWeak(&location);
    }
  }

void sub_10007BB10( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
}

void sub_10007BB3C(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v13 = WeakRetained;
    uint64_t v5 = _NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    uint64_t v6 = (void *)v5;
    if (a2)
    {
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

      id WeakRetained = v13;
      if (IsLevelEnabled)
      {
        id v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v8);
        id v10 = [v13 copyDescription];
        _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: Received response to device identity message",  "",  "-[NRLinkBluetooth sendDeviceIdentity]_block_invoke",  7659LL,  v10);
LABEL_7:

        id WeakRetained = v13;
      }
    }

    else
    {
      int v11 = _NRLogIsLevelEnabled(v5, 16LL);

      id WeakRetained = v13;
      if (v11)
      {
        id v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v12);
        id v10 = [v13 copyDescription];
        _NRLogWithArgs( v9,  16LL,  "%s%.30s:%-4d %@: Did not receive response to device identity message",  "",  "-[NRLinkBluetooth sendDeviceIdentity]_block_invoke",  7661LL,  v10);
        goto LABEL_7;
      }
    }
  }
}

void sub_10007BC4C(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v13 = WeakRetained;
    uint64_t v5 = _NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    uint64_t v6 = (void *)v5;
    if (a2)
    {
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

      id WeakRetained = v13;
      if (IsLevelEnabled)
      {
        id v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v8);
        id v10 = [v13 copyDescription];
        _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: Received response to device identity request",  "",  "-[NRLinkBluetooth sendDeviceIdentityRequest]_block_invoke",  7627LL,  v10);
LABEL_7:

        id WeakRetained = v13;
      }
    }

    else
    {
      int v11 = _NRLogIsLevelEnabled(v5, 16LL);

      id WeakRetained = v13;
      if (v11)
      {
        id v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v12);
        id v10 = [v13 copyDescription];
        _NRLogWithArgs( v9,  16LL,  "%s%.30s:%-4d %@: Did not receive response to device identity request",  "",  "-[NRLinkBluetooth sendDeviceIdentityRequest]_block_invoke",  7629LL,  v10);
        goto LABEL_7;
      }
    }
  }
}

void sub_10007BD5C(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v13 = WeakRetained;
    uint64_t v5 = _NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    uint64_t v6 = (void *)v5;
    if (a2)
    {
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

      id WeakRetained = v13;
      if (IsLevelEnabled)
      {
        id v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v8);
        id v10 = [v13 copyDescription];
        _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: Received response to proxy notify payload",  "",  "-[NRLinkBluetooth sendProxyConfig]_block_invoke",  7568LL,  v10);
LABEL_7:

        id WeakRetained = v13;
      }
    }

    else
    {
      int v11 = _NRLogIsLevelEnabled(v5, 16LL);

      id WeakRetained = v13;
      if (v11)
      {
        id v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v12);
        id v10 = [v13 copyDescription];
        _NRLogWithArgs( v9,  16LL,  "%s%.30s:%-4d %@: Did not receive response to proxy notify payload",  "",  "-[NRLinkBluetooth sendProxyConfig]_block_invoke",  7570LL,  v10);
        goto LABEL_7;
      }
    }
  }
}

void sub_10007BE6C(_BYTE *a1)
{
  if (!a1[242])
  {
    a1[235] = 1;
    uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue([a1 nrUUID]);
    uint64_t v3 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v2);

    if (v3)
    {
      objc_initWeak(&location, a1);
      objc_opt_self(&OBJC_CLASS___NRDKeyManager);
      if (qword_1001DCC18 == -1)
      {
LABEL_6:
        id v4 = (id)qword_1001DCC10;
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 3221225472LL;
        v13[2] = sub_10007C9D0;
        v13[3] = &unk_1001AFED0;
        objc_copyWeak(&v14, &location);
        sub_1001448A8((uint64_t)v4, v13);

        objc_destroyWeak(&v14);
        objc_destroyWeak(&location);
LABEL_7:

        return;
      }
    }

    else
    {
      id v5 = sub_100070554();
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16LL);

      if (IsLevelEnabled)
      {
        id v7 = sub_100070554();
        _NRLogWithArgs( v7,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRLinkBluetooth scheduleIKESessionClassADueToConnectFailure]",  8982);
      }

      uint64_t v3 = (char *)_os_log_pack_size(12LL);
      uint64_t v8 = (char *)&v13[-1] - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      id v9 = __error();
      uint64_t v10 = _os_log_pack_fill( v8,  v3,  *v9,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
      *(_DWORD *)uint64_t v10 = 136446210;
      *(void *)(v10 + 4) = "-[NRLinkBluetooth scheduleIKESessionClassADueToConnectFailure]";
      id v11 = sub_100070554();
      _NRLogAbortWithPack(v11, v8);
      __break(1u);
    }

    dispatch_once(&qword_1001DCC18, &stru_1001B0910);
    goto LABEL_6;
  }

void sub_10007C0A8(_Unwind_Exception *a1)
{
}

void sub_10007C0D4(uint64_t a1)
{
  id WeakRetained = (unsigned __int8 *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = (char *)WeakRetained;
  if (WeakRetained && WeakRetained[16] != 255 && *(void *)(WeakRetained + 1223))
  {
    objc_initWeak(&location, WeakRetained);
    uint64_t v3 = *(void **)(v2 + 1223);
    id v4 = sub_10010CD5C();
    id v10 = v4;
    id v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v10, 1LL));
    uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue([v2 queue]);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472LL;
    v7[2] = sub_10007C8C0;
    v7[3] = &unk_1001AF950;
    objc_copyWeak(&v8, &location);
    [v3 sendPrivateNotifies:v5 maxRetries:10 retryIntervalInMilliseconds:10000 callbackQueue:v6 callback:v7];

    objc_destroyWeak(&v8);
    objc_destroyWeak(&location);
  }
}

void sub_10007C224( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

id sub_10007C250(void *a1)
{
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  uint64_t v2 = (id)qword_1001DC870;
  uint64_t v3 = sub_1000AFCFC(v2, 0LL);

  if (v3)
  {
    id v4 = (void *)objc_claimAutoreleasedReturnValue([v3 dataUsingEncoding:4]);
    id v5 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:48607 notifyData:v4];
  }

  else
  {
    objc_initWeak(&location, a1);
    objc_opt_self(&OBJC_CLASS___NRLinkDirector);
    if (qword_1001DC878 != -1) {
      dispatch_once(&qword_1001DC878, &stru_1001AEED0);
    }
    id v7 = (id)qword_1001DC870;
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472LL;
    void v8[2] = sub_10007C514;
    v8[3] = &unk_1001AEB90;
    objc_copyWeak(&v9, &location);
    v8[4] = a1;

    objc_destroyWeak(&v9);
    objc_destroyWeak(&location);
    id v5 = 0LL;
  }

  return v5;
}

void sub_10007C3E0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_10007C404(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v13 = WeakRetained;
    uint64_t v5 = _NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    uint64_t v6 = (void *)v5;
    if (a2)
    {
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

      id WeakRetained = v13;
      if (IsLevelEnabled)
      {
        id v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v8);
        id v10 = [v13 copyDescription];
        _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: Received response to notify payloads",  "",  "-[NRLinkBluetooth sendNotifyPayload]_block_invoke",  7599LL,  v10);
LABEL_7:

        id WeakRetained = v13;
      }
    }

    else
    {
      int v11 = _NRLogIsLevelEnabled(v5, 16LL);

      id WeakRetained = v13;
      if (v11)
      {
        id v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v12);
        id v10 = [v13 copyDescription];
        _NRLogWithArgs( v9,  16LL,  "%s%.30s:%-4d %@: Did not receive response to notify payloads",  "",  "-[NRLinkBluetooth sendNotifyPayload]_block_invoke",  7601LL,  v10);
        goto LABEL_7;
      }
    }
  }
}

void sub_10007C514(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = (id *)(a1 + 40);
  id WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v6 = WeakRetained;
  if (WeakRetained && [WeakRetained state] != 255)
  {
    if (v3)
    {
      uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue([v3 dataUsingEncoding:4]);
      id v9 = [[NEIKEv2PrivateNotify alloc] initWithNotifyStatus:48607 notifyData:v8];
      int v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v10);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0LL);

      if (IsLevelEnabled)
      {
        id v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v13);
        id v15 = [*(id *)(a1 + 32) copyDescription];
        _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d %@: Sending IDS device ID to peer",  "",  "-[NRLinkBluetooth getOrSendIDSDeviceID]_block_invoke",  7529LL,  v15);
      }

      id v16 = *(id *)(v6 + 1223);
      id v26 = v9;
      id v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", &v26, 1LL));
      uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue([v6 queue]);
      v24[0] = _NSConcreteStackBlock;
      v24[1] = 3221225472LL;
      v24[2] = sub_10007C7B0;
      v24[3] = &unk_1001AF950;
      objc_copyWeak(&v25, v4);
      [v16 sendPrivateNotifies:v17 maxRetries:10 retryIntervalInMilliseconds:10000 callbackQueue:v18 callback:v24];

      objc_destroyWeak(&v25);
    }

    else
    {
      id v19 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v6 + 4), v7);
      int v20 = _NRLogIsLevelEnabled(v19, 16LL);

      if (v20)
      {
        int v22 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v6 + 4), v21);
        id v23 = [v6 copyDescription];
        _NRLogWithArgs( v22,  16LL,  "%s%.30s:%-4d %@: No IDS Device ID to send to peer",  "",  "-[NRLinkBluetooth getOrSendIDSDeviceID]_block_invoke",  7522LL,  v23);
      }
    }
  }
}

void sub_10007C794(_Unwind_Exception *a1)
{
}

void sub_10007C7B0(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v13 = WeakRetained;
    uint64_t v5 = _NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    uint64_t v6 = (void *)v5;
    if (a2)
    {
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

      id WeakRetained = v13;
      if (IsLevelEnabled)
      {
        id v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v8);
        id v10 = [v13 copyDescription];
        _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: Received response to IDS device ID notify payload",  "",  "-[NRLinkBluetooth getOrSendIDSDeviceID]_block_invoke_2",  7540LL,  v10);
LABEL_7:

        id WeakRetained = v13;
      }
    }

    else
    {
      int v11 = _NRLogIsLevelEnabled(v5, 16LL);

      id WeakRetained = v13;
      if (v11)
      {
        id v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v12);
        id v10 = [v13 copyDescription];
        _NRLogWithArgs( v9,  16LL,  "%s%.30s:%-4d %@: Did not receive response to IDS device ID notify payload",  "",  "-[NRLinkBluetooth getOrSendIDSDeviceID]_block_invoke_2",  7542LL,  v10);
        goto LABEL_7;
      }
    }
  }
}

void sub_10007C8C0(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v13 = WeakRetained;
    uint64_t v5 = _NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    uint64_t v6 = (void *)v5;
    if (a2)
    {
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 0LL);

      id WeakRetained = v13;
      if (IsLevelEnabled)
      {
        id v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v8);
        id v10 = [v13 copyDescription];
        _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: Received response to classC unlock",  "",  "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke_3",  8113LL,  v10);
LABEL_7:

        id WeakRetained = v13;
      }
    }

    else
    {
      int v11 = _NRLogIsLevelEnabled(v5, 16LL);

      id WeakRetained = v13;
      if (v11)
      {
        id v9 = (void *)_NRCopyLogObjectForNRUUID(v13[4], v12);
        id v10 = [v13 copyDescription];
        _NRLogWithArgs( v9,  16LL,  "%s%.30s:%-4d %@: Did not receive response to classC unlock",  "",  "-[NRLinkBluetooth setupIKECallbacks:]_block_invoke_3",  8115LL,  v10);
        goto LABEL_7;
      }
    }
  }
}

void sub_10007C9D0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v13 = WeakRetained;
    BOOL v2 = [WeakRetained state] == 255;
    id WeakRetained = v13;
    if (!v2)
    {
      v13[235] = 0;
      id v3 = (void *)objc_claimAutoreleasedReturnValue([WeakRetained nrUUID]);
      uint64_t v4 = sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v3);

      if (!v4)
      {
        id v5 = sub_100070554();
        int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16LL);

        if (IsLevelEnabled)
        {
          id v7 = sub_100070554();
          _NRLogWithArgs( v7,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice2) != ((void *)0)",  "",  "-[NRLinkBluetooth scheduleIKESessionClassADueToConnectFailure]_block_invoke",  8993);
        }

        uint64_t v8 = _os_log_pack_size(12LL);
        id v9 = (char *)&v13 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        id v10 = __error();
        uint64_t v11 = _os_log_pack_fill( v9,  v8,  *v10,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice2) != ((void *)0)");
        *(_DWORD *)uint64_t v11 = 136446210;
        *(void *)(v11 + 4) = "-[NRLinkBluetooth scheduleIKESessionClassADueToConnectFailure]_block_invoke";
        id v12 = sub_100070554();
        _NRLogAbortWithPack(v12, v9);
      }

      id WeakRetained = v13;
    }
  }
}

void sub_10007CB68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  id v18 = a5;
  if ([*(id *)(a1 + 32) state] == 255)
  {
    id v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v7);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v12);
      id v14 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d %@: Ignoring result as link is cancelled",  "",  "-[NRLinkBluetooth sendlocalPublicClassCKeysEncryptedWithIDS]_block_invoke",  8307LL,  v14);
    }
  }

  else if (v18)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
      objc_storeStrong((id *)(v8 + 1295), a5);
      uint64_t v9 = *(void *)(a1 + 32);
    }

    else
    {
      uint64_t v9 = 0LL;
    }

    sub_1000764AC(v9);
  }

  else
  {
    id v15 = sub_100070554();
    int v16 = _NRLogIsLevelEnabled(v15, 17LL);

    if (v16)
    {
      id v17 = sub_100070554();
      _NRLogWithArgs( v17,  17LL,  "%s called with null localPublicClassCKeysEncryptedWithIDS",  "-[NRLinkBluetooth sendlocalPublicClassCKeysEncryptedWithIDS]_block_invoke");
    }
  }
}

void sub_10007CCAC(uint64_t a1, uint64_t a2)
{
  int v2 = a2;
  uint64_t v4 = _NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), a2);
  id v5 = (void *)v4;
  if (v2)
  {
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v7);
      id v9 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v8,  0LL,  "%s%.30s:%-4d %@: localPublicClassCKeysEncryptedWithIDS was received",  "",  "-[NRLinkBluetooth sendlocalPublicClassCKeysEncryptedWithIDS]_block_invoke_2",  8330LL,  v9);
    }

    uint64_t v10 = *(void *)(a1 + 32);
    if (v10) {
      sub_100076BD8(v10, 3LL, 0, 0);
    }
  }

  else
  {
    int v11 = _NRLogIsLevelEnabled(v4, 16LL);

    if (v11)
    {
      id v14 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v12);
      id v13 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v14,  16LL,  "%s%.30s:%-4d %@: localPublicClassCKeysEncryptedWithIDS was not received",  "",  "-[NRLinkBluetooth sendlocalPublicClassCKeysEncryptedWithIDS]_block_invoke_2",  8333LL,  v13);
    }
  }

void sub_10007CDFC(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  id WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    if (v5)
    {
      uint64_t v7 = objc_alloc(&OBJC_CLASS___NSString);
      uint64_t v8 = *(void *)(a1 + 32);
      SessionStateid String = (void *)NEIKEv2CreateSessionStateString(a2);
      uint64_t v10 = -[NSString initWithFormat:]( v7,  "initWithFormat:",  @"pairing session %@ got IKE error %@ with state %@",  v8,  v5,  SessionStateString);

LABEL_4:
      uint64_t v11 = mach_absolute_time();
      uint64_t v12 = *(void *)(WeakRetained + 1863);
      if (v12) {
        *(void *)(v12 + 120) = v11;
      }
      if (WeakRetained[234])
      {
        [WeakRetained reportEvent:3009 details:v10];
      }

      else
      {
        sub_1001306B8((uint64_t)&OBJC_CLASS___NRDLocalDevice, -2013LL, v10, *((void **)WeakRetained + 4));
        [WeakRetained cancelWithReason:@"%@", v10];
      }

void sub_10007D39C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v18 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v9 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v10 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v8);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v10, 0LL);

    if (v18)
    {
      if (IsLevelEnabled)
      {
        uint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v12);
        id v14 = [v9 copyDescription];
        uint64_t v15 = *(void *)(a1 + 32);
        SessionStateid String = (void *)NEIKEv2CreateSessionStateString(a3);
        _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d %@: pairing session %@ got child %u state update %@ error %@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_4",  8556LL,  v14,  v15,  a2,  SessionStateString,  v18);
LABEL_7:
      }
    }

    else if (IsLevelEnabled)
    {
      uint64_t v13 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v12);
      id v14 = [v9 copyDescription];
      uint64_t v17 = *(void *)(a1 + 32);
      SessionStateid String = (void *)NEIKEv2CreateSessionStateString(a3);
      _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d %@: pairing session %@ got child %u state update %@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_4",  8559LL,  v14,  v17,  a2,  SessionStateString);
      goto LABEL_7;
    }
  }
}

void sub_10007D4EC(uint64_t a1, void *a2)
{
  id v11 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v5 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

    if (IsLevelEnabled)
    {
      id v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      id v10 = [v5 copyDescription];
      _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: pairing session %@ got config update %@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_5",  8569LL,  v10,  *(void *)(a1 + 32),  v11);
    }
  }
}

void sub_10007D5B4(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v16 = a3;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v10 = WeakRetained;
  if (WeakRetained)
  {
    id v11 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v9);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 0LL);

    if (IsLevelEnabled)
    {
      id v14 = (void *)_NRCopyLogObjectForNRUUID(v10[4], v13);
      id v15 = [v10 copyDescription];
      _NRLogWithArgs( v14,  0LL,  "%s%.30s:%-4d %@: pairing session %@ got child %u traffic selector update local %@ remote %@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_6",  8580LL,  v15,  *(void *)(a1 + 32),  a2,  v16,  v7);
    }
  }
}

void sub_10007D6A0(uint64_t a1, void *a2)
{
  id v11 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v5 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 0LL);

    if (IsLevelEnabled)
    {
      uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(v5[4], v8);
      id v10 = [v5 copyDescription];
      _NRLogWithArgs( v9,  0LL,  "%s%.30s:%-4d %@: pairing session %@ got additional addresses %@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_7",  8589LL,  v10,  *(void *)(a1 + 32),  v11);
    }
  }
}

void sub_10007D768(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    uint64_t v9 = WeakRetained;
    uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v3);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

    id WeakRetained = v9;
    if (IsLevelEnabled)
    {
      id v7 = (void *)_NRCopyLogObjectForNRUUID(v9[4], v6);
      id v8 = [v9 copyDescription];
      _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d %@: pairing session %@ got short DPD",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_8",  8597LL,  v8,  *(void *)(a1 + 32));

      id WeakRetained = v9;
    }
  }
}

void sub_10007D828(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v34 = v3;
    id v5 = (void *)objc_claimAutoreleasedReturnValue([v3 sortedArrayUsingComparator:&stru_1001AFCC8]);
    id v7 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v6);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0LL);

    if (IsLevelEnabled)
    {
      id v10 = (void *)_NRCopyLogObjectForNRUUID(WeakRetained[4], v9);
      id v11 = [WeakRetained copyDescription];
      _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d %@: pairing session %@ got private notifies %@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_9",  8607LL,  v11,  *(void *)(a1 + 32),  v5);
    }

    __int128 v51 = 0u;
    __int128 v52 = 0u;
    __int128 v49 = 0u;
    __int128 v50 = 0u;
    id v12 = v5;
    id v13 = [v12 countByEnumeratingWithState:&v49 objects:v53 count:16];
    if (v13)
    {
      id v14 = v13;
      uint64_t v15 = *(void *)v50;
      do
      {
        for (uint64_t i = 0LL; i != v14; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v50 != v15) {
            objc_enumerationMutation(v12);
          }
          int v20 = *(void **)(*((void *)&v49 + 1) + 8LL * (void)i);
          if ([v20 notifyStatus] == 50351)
          {
            [WeakRetained reportEvent:3401 details:@"Identity"];
            uint64_t v17 = (void *)objc_claimAutoreleasedReturnValue([v20 notifyData]);
            id v18 = (void *)WeakRetained[4];
            v47[0] = _NSConcreteStackBlock;
            v47[1] = 3221225472LL;
            void v47[2] = sub_10007DDB8;
            v47[3] = &unk_1001AEBB8;
            int v48 = WeakRetained;
            sub_100133320((uint64_t)&OBJC_CLASS___NRDLocalDevice, v17, v18, v47);

            id v19 = v48;
          }

          else if ([v20 notifyStatus] == 50411)
          {
            [WeakRetained reportEvent:3401 details:@"ClassD"];
            id v21 = (void *)objc_claimAutoreleasedReturnValue([v20 notifyData]);
            int v22 = (void *)WeakRetained[4];
            v45[0] = _NSConcreteStackBlock;
            v45[1] = 3221225472LL;
            void v45[2] = sub_10007E00C;
            v45[3] = &unk_1001AEBB8;
            int v46 = WeakRetained;
            sub_100133664((uint64_t)&OBJC_CLASS___NRDLocalDevice, v21, v22, v45);

            id v19 = v46;
          }

          else if ([v20 notifyStatus] == 50412)
          {
            [WeakRetained reportEvent:3401 details:@"ClassC"];
            id v23 = (void *)objc_claimAutoreleasedReturnValue([v20 notifyData]);
            uint64_t v24 = (void *)WeakRetained[4];
            v43[0] = _NSConcreteStackBlock;
            v43[1] = 3221225472LL;
            v43[2] = sub_10007E330;
            v43[3] = &unk_1001AEBB8;
            id v44 = WeakRetained;
            sub_1001339F8((uint64_t)&OBJC_CLASS___NRDLocalDevice, v23, v24, v43);

            id v19 = v44;
          }

          else if ([v20 notifyStatus] == 50413)
          {
            [WeakRetained reportEvent:3401 details:@"ClassA"];
            id v25 = (void *)objc_claimAutoreleasedReturnValue([v20 notifyData]);
            id v26 = (void *)WeakRetained[4];
            v41[0] = _NSConcreteStackBlock;
            v41[1] = 3221225472LL;
            id v41[2] = sub_10007E650;
            v41[3] = &unk_1001AEBB8;
            id v42 = WeakRetained;
            sub_100133E78((uint64_t)&OBJC_CLASS___NRDLocalDevice, v25, v26, v41);

            id v19 = v42;
          }

          else if ([v20 notifyStatus] == 50401)
          {
            [WeakRetained reportEvent:3403 details:@"ClassD"];
            uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue([v20 notifyData]);
            uint64_t v28 = (void *)WeakRetained[4];
            v39[0] = _NSConcreteStackBlock;
            v39[1] = 3221225472LL;
            v39[2] = sub_10007E970;
            v39[3] = &unk_1001AEBB8;
            uint64_t v40 = WeakRetained;
            sub_1001342F8((uint64_t)&OBJC_CLASS___NRDLocalDevice, v27, v28, v39);

            id v19 = v40;
          }

          else if ([v20 notifyStatus] == 50402)
          {
            [WeakRetained reportEvent:3403 details:@"ClassC"];
            id v29 = (void *)objc_claimAutoreleasedReturnValue([v20 notifyData]);
            id v30 = (void *)WeakRetained[4];
            v37[0] = _NSConcreteStackBlock;
            v37[1] = 3221225472LL;
            v37[2] = sub_10007EC94;
            v37[3] = &unk_1001AEBB8;
            id v38 = WeakRetained;
            sub_100134794((uint64_t)&OBJC_CLASS___NRDLocalDevice, v29, v30, v37);

            id v19 = v38;
          }

          else if ([v20 notifyStatus] == 50403)
          {
            [WeakRetained reportEvent:3403 details:@"ClassA"];
            id v31 = (void *)objc_claimAutoreleasedReturnValue([v20 notifyData]);
            int v32 = (void *)WeakRetained[4];
            v35[0] = _NSConcreteStackBlock;
            v35[1] = 3221225472LL;
            v35[2] = sub_10007EFB8;
            v35[3] = &unk_1001AEBB8;
            uint64_t v36 = WeakRetained;
            sub_100134DDC((uint64_t)&OBJC_CLASS___NRDLocalDevice, v31, v32, v35);

            id v19 = v36;
          }

          else
          {
            uint64_t v33 = (char *)[v20 notifyStatus];
            id v19 = (void *)objc_claimAutoreleasedReturnValue([v20 notifyData]);
            sub_1000790B8((uint64_t)WeakRetained, v33, v19, 0);
          }
        }

        id v14 = [v12 countByEnumeratingWithState:&v49 objects:v53 count:16];
      }

      while (v14);
    }

    id v3 = v34;
  }
}

void sub_10007DDB8(uint64_t a1, void *a2)
{
  id v29 = a2;
  uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v3);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

  if (IsLevelEnabled)
  {
    id v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
    id v8 = [*(id *)(a1 + 32) copyDescription];
    _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d %@: Plumbed device identity %@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_10",  8614LL,  v8,  v29);
  }

  uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
  int v10 = _NRLogIsLevelEnabled(v9, 0LL);

  if (v10)
  {
    id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v11);
    id v13 = [*(id *)(a1 + 32) copyDescription];
    if (v29)
    {
      id v14 = v29[8];
      uint64_t v15 = v14;
      if (v14) {
        id v16 = (void *)*((void *)v14 + 1);
      }
      else {
        id v16 = 0LL;
      }
    }

    else
    {
      uint64_t v15 = 0LL;
      id v16 = 0LL;
    }

    id v17 = v16;
    id v18 = (void *)objc_claimAutoreleasedReturnValue([v17 UUIDString]);
    _NRLogWithArgs( v12,  0LL,  "%s%.30s:%-4d %@: deviceIdentityUUID=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_10",  8616LL,  v13,  v18);
  }

  id v19 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v11);
  int v20 = _NRLogIsLevelEnabled(v19, 0LL);

  if (v20)
  {
    int v22 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v21);
    id v23 = [*(id *)(a1 + 32) copyDescription];
    if (v29)
    {
      id v24 = v29[8];
      id v25 = v24;
      if (v24) {
        id v26 = (void *)*((void *)v24 + 2);
      }
      else {
        id v26 = 0LL;
      }
    }

    else
    {
      id v25 = 0LL;
      id v26 = 0LL;
    }

    id v27 = v26;
    Logid String = (void *)_NRKeyCreateLogString(v27);
    _NRLogWithArgs( v22,  0LL,  "%s%.30s:%-4d %@: deviceIdentityPublicKey=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_10",  8618LL,  v23,  LogString);
  }
}

void sub_10007E00C(uint64_t a1, void *a2)
{
  int v41 = a2;
  uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v3);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

  if (IsLevelEnabled)
  {
    id v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
    id v8 = [*(id *)(a1 + 32) copyDescription];
    _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d %@: Plumbed classD keys with OOBK %@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_11",  8625LL,  v8,  v41);
  }

  if (v41) {
    uint64_t v9 = (void *)v41[9];
  }
  else {
    uint64_t v9 = 0LL;
  }
  id v10 = v9;
  id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v11);
  int v13 = _NRLogIsLevelEnabled(v12, 0LL);

  if (v13)
  {
    uint64_t v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v14);
    id v16 = [*(id *)(a1 + 32) copyDescription];
    if (v10) {
      id v17 = (void *)*((void *)v10 + 1);
    }
    else {
      id v17 = 0LL;
    }
    id v18 = v17;
    id v19 = sub_100124E58(v18);
    Logid String = (void *)_NRKeyCreateLogString(v19);
    _NRLogWithArgs( v15,  0LL,  "%s%.30s:%-4d %@: classDRemotePublicKey=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_11",  8628LL,  v16,  LogString);
  }

  uint64_t v21 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v14);
  int v22 = _NRLogIsLevelEnabled(v21, 0LL);

  if (v22)
  {
    id v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v23);
    id v25 = [*(id *)(a1 + 32) copyDescription];
    if (v10) {
      id v26 = (void *)*((void *)v10 + 2);
    }
    else {
      id v26 = 0LL;
    }
    id v27 = v26;
    uint64_t v28 = sub_100124E58(v27);
    id v29 = (void *)_NRKeyCreateLogString(v28);
    _NRLogWithArgs( v24,  0LL,  "%s%.30s:%-4d %@: classDLocalPublicKey=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_11",  8630LL,  v25,  v29);
  }

  id v30 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v23);
  int v31 = _NRLogIsLevelEnabled(v30, 0LL);

  if (v31)
  {
    uint64_t v33 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v32);
    id v34 = [*(id *)(a1 + 32) copyDescription];
    if (v10)
    {
      id v35 = *((id *)v10 + 3);
      uint64_t v36 = v35;
      if (v35)
      {
        uint64_t v37 = (void *)*((void *)v35 + 2);
LABEL_17:
        id v38 = v37;
        uint64_t v39 = (void *)_NRKeyCreateLogString(v38);
        _NRLogWithArgs( v33,  0LL,  "%s%.30s:%-4d %@: classDSharedSecret=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_11",  8632LL,  v34,  v39);

        goto LABEL_18;
      }
    }

    else
    {
      uint64_t v36 = 0LL;
    }

    uint64_t v37 = 0LL;
    goto LABEL_17;
  }

void sub_10007E330(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v41 = v3;
  if (v3) {
    uint64_t v4 = (void *)*((void *)v3 + 10);
  }
  else {
    uint64_t v4 = 0LL;
  }
  id v5 = v4;
  id v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0LL);

  if (IsLevelEnabled)
  {
    id v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v9);
    id v11 = [*(id *)(a1 + 32) copyDescription];
    _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d %@: Plumbed classC keys with OOBK %@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_12",  8641LL,  v11,  v41);
  }

  id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v9);
  int v13 = _NRLogIsLevelEnabled(v12, 0LL);

  if (v13)
  {
    uint64_t v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v14);
    id v16 = [*(id *)(a1 + 32) copyDescription];
    if (v5) {
      id v17 = (void *)*((void *)v5 + 1);
    }
    else {
      id v17 = 0LL;
    }
    id v18 = v17;
    id v19 = sub_100124E58(v18);
    Logid String = (void *)_NRKeyCreateLogString(v19);
    _NRLogWithArgs( v15,  0LL,  "%s%.30s:%-4d %@: classCRemotePublicKey=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_12",  8643LL,  v16,  LogString);
  }

  uint64_t v21 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v14);
  int v22 = _NRLogIsLevelEnabled(v21, 0LL);

  if (v22)
  {
    id v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v23);
    id v25 = [*(id *)(a1 + 32) copyDescription];
    if (v5) {
      id v26 = (void *)*((void *)v5 + 2);
    }
    else {
      id v26 = 0LL;
    }
    id v27 = v26;
    uint64_t v28 = sub_100124E58(v27);
    id v29 = (void *)_NRKeyCreateLogString(v28);
    _NRLogWithArgs( v24,  0LL,  "%s%.30s:%-4d %@: classCLocalPublicKey=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_12",  8645LL,  v25,  v29);
  }

  id v30 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v23);
  int v31 = _NRLogIsLevelEnabled(v30, 0LL);

  if (v31)
  {
    uint64_t v33 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v32);
    id v34 = [*(id *)(a1 + 32) copyDescription];
    if (v5)
    {
      id v35 = *((id *)v5 + 3);
      uint64_t v36 = v35;
      if (v35)
      {
        uint64_t v37 = (void *)*((void *)v35 + 2);
LABEL_17:
        id v38 = v37;
        uint64_t v39 = (void *)_NRKeyCreateLogString(v38);
        _NRLogWithArgs( v33,  0LL,  "%s%.30s:%-4d %@: classCSharedSecret=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_12",  8647LL,  v34,  v39);

        goto LABEL_18;
      }
    }

    else
    {
      uint64_t v36 = 0LL;
    }

    uint64_t v37 = 0LL;
    goto LABEL_17;
  }

void sub_10007E650(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v41 = v3;
  if (v3) {
    uint64_t v4 = (void *)*((void *)v3 + 11);
  }
  else {
    uint64_t v4 = 0LL;
  }
  id v5 = v4;
  id v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0LL);

  if (IsLevelEnabled)
  {
    id v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v9);
    id v11 = [*(id *)(a1 + 32) copyDescription];
    _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d %@: Plumbed classA keys with OOBK %@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_13",  8656LL,  v11,  v41);
  }

  id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v9);
  int v13 = _NRLogIsLevelEnabled(v12, 0LL);

  if (v13)
  {
    uint64_t v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v14);
    id v16 = [*(id *)(a1 + 32) copyDescription];
    if (v5) {
      id v17 = (void *)*((void *)v5 + 1);
    }
    else {
      id v17 = 0LL;
    }
    id v18 = v17;
    id v19 = sub_100124E58(v18);
    Logid String = (void *)_NRKeyCreateLogString(v19);
    _NRLogWithArgs( v15,  0LL,  "%s%.30s:%-4d %@: classARemotePublicKey=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_13",  8658LL,  v16,  LogString);
  }

  uint64_t v21 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v14);
  int v22 = _NRLogIsLevelEnabled(v21, 0LL);

  if (v22)
  {
    id v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v23);
    id v25 = [*(id *)(a1 + 32) copyDescription];
    if (v5) {
      id v26 = (void *)*((void *)v5 + 2);
    }
    else {
      id v26 = 0LL;
    }
    id v27 = v26;
    uint64_t v28 = sub_100124E58(v27);
    id v29 = (void *)_NRKeyCreateLogString(v28);
    _NRLogWithArgs( v24,  0LL,  "%s%.30s:%-4d %@: classALocalPublicKey=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_13",  8660LL,  v25,  v29);
  }

  id v30 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v23);
  int v31 = _NRLogIsLevelEnabled(v30, 0LL);

  if (v31)
  {
    uint64_t v33 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v32);
    id v34 = [*(id *)(a1 + 32) copyDescription];
    if (v5)
    {
      id v35 = *((id *)v5 + 3);
      uint64_t v36 = v35;
      if (v35)
      {
        uint64_t v37 = (void *)*((void *)v35 + 2);
LABEL_17:
        id v38 = v37;
        uint64_t v39 = (void *)_NRKeyCreateLogString(v38);
        _NRLogWithArgs( v33,  0LL,  "%s%.30s:%-4d %@: classASharedSecret=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_13",  8662LL,  v34,  v39);

        goto LABEL_18;
      }
    }

    else
    {
      uint64_t v36 = 0LL;
    }

    uint64_t v37 = 0LL;
    goto LABEL_17;
  }

void sub_10007E970(uint64_t a1, void *a2)
{
  id v41 = a2;
  uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v3);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

  if (IsLevelEnabled)
  {
    id v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
    id v8 = [*(id *)(a1 + 32) copyDescription];
    _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d %@: Plumbed classD keys with IDS keys %@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_14",  8671LL,  v8,  v41);
  }

  if (v41) {
    uint64_t v9 = (void *)v41[9];
  }
  else {
    uint64_t v9 = 0LL;
  }
  id v10 = v9;
  id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v11);
  int v13 = _NRLogIsLevelEnabled(v12, 0LL);

  if (v13)
  {
    uint64_t v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v14);
    id v16 = [*(id *)(a1 + 32) copyDescription];
    if (v10) {
      id v17 = (void *)*((void *)v10 + 1);
    }
    else {
      id v17 = 0LL;
    }
    id v18 = v17;
    id v19 = sub_100124E58(v18);
    Logid String = (void *)_NRKeyCreateLogString(v19);
    _NRLogWithArgs( v15,  0LL,  "%s%.30s:%-4d %@: classDRemotePublicKey=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_14",  8674LL,  v16,  LogString);
  }

  uint64_t v21 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v14);
  int v22 = _NRLogIsLevelEnabled(v21, 0LL);

  if (v22)
  {
    id v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v23);
    id v25 = [*(id *)(a1 + 32) copyDescription];
    if (v10) {
      id v26 = (void *)*((void *)v10 + 2);
    }
    else {
      id v26 = 0LL;
    }
    id v27 = v26;
    uint64_t v28 = sub_100124E58(v27);
    id v29 = (void *)_NRKeyCreateLogString(v28);
    _NRLogWithArgs( v24,  0LL,  "%s%.30s:%-4d %@: classDLocalPublicKey=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_14",  8676LL,  v25,  v29);
  }

  id v30 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v23);
  int v31 = _NRLogIsLevelEnabled(v30, 0LL);

  if (v31)
  {
    uint64_t v33 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v32);
    id v34 = [*(id *)(a1 + 32) copyDescription];
    if (v10)
    {
      id v35 = *((id *)v10 + 3);
      uint64_t v36 = v35;
      if (v35)
      {
        uint64_t v37 = (void *)*((void *)v35 + 2);
LABEL_17:
        id v38 = v37;
        uint64_t v39 = (void *)_NRKeyCreateLogString(v38);
        _NRLogWithArgs( v33,  0LL,  "%s%.30s:%-4d %@: classDSharedSecret=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_14",  8678LL,  v34,  v39);

        goto LABEL_18;
      }
    }

    else
    {
      uint64_t v36 = 0LL;
    }

    uint64_t v37 = 0LL;
    goto LABEL_17;
  }

void sub_10007EC94(uint64_t a1, void *a2)
{
  id v41 = a2;
  uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v3);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

  if (IsLevelEnabled)
  {
    id v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
    id v8 = [*(id *)(a1 + 32) copyDescription];
    _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d %@: Plumbed classC keys with IDS keys %@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_15",  8687LL,  v8,  v41);
  }

  if (v41) {
    uint64_t v9 = (void *)v41[10];
  }
  else {
    uint64_t v9 = 0LL;
  }
  id v10 = v9;
  id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v11);
  int v13 = _NRLogIsLevelEnabled(v12, 0LL);

  if (v13)
  {
    uint64_t v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v14);
    id v16 = [*(id *)(a1 + 32) copyDescription];
    if (v10) {
      id v17 = (void *)*((void *)v10 + 1);
    }
    else {
      id v17 = 0LL;
    }
    id v18 = v17;
    id v19 = sub_100124E58(v18);
    Logid String = (void *)_NRKeyCreateLogString(v19);
    _NRLogWithArgs( v15,  0LL,  "%s%.30s:%-4d %@: classCRemotePublicKey=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_15",  8690LL,  v16,  LogString);
  }

  uint64_t v21 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v14);
  int v22 = _NRLogIsLevelEnabled(v21, 0LL);

  if (v22)
  {
    id v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v23);
    id v25 = [*(id *)(a1 + 32) copyDescription];
    if (v10) {
      id v26 = (void *)*((void *)v10 + 2);
    }
    else {
      id v26 = 0LL;
    }
    id v27 = v26;
    uint64_t v28 = sub_100124E58(v27);
    id v29 = (void *)_NRKeyCreateLogString(v28);
    _NRLogWithArgs( v24,  0LL,  "%s%.30s:%-4d %@: classCLocalPublicKey=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_15",  8692LL,  v25,  v29);
  }

  id v30 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v23);
  int v31 = _NRLogIsLevelEnabled(v30, 0LL);

  if (v31)
  {
    uint64_t v33 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v32);
    id v34 = [*(id *)(a1 + 32) copyDescription];
    if (v10)
    {
      id v35 = *((id *)v10 + 3);
      uint64_t v36 = v35;
      if (v35)
      {
        uint64_t v37 = (void *)*((void *)v35 + 2);
LABEL_17:
        id v38 = v37;
        uint64_t v39 = (void *)_NRKeyCreateLogString(v38);
        _NRLogWithArgs( v33,  0LL,  "%s%.30s:%-4d %@: classCSharedSecret=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_15",  8694LL,  v34,  v39);

        goto LABEL_18;
      }
    }

    else
    {
      uint64_t v36 = 0LL;
    }

    uint64_t v37 = 0LL;
    goto LABEL_17;
  }

void sub_10007EFB8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v42 = v3;
  if (v3) {
    uint64_t v4 = (void *)*((void *)v3 + 11);
  }
  else {
    uint64_t v4 = 0LL;
  }
  id v5 = v4;
  id v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 0LL);

  if (IsLevelEnabled)
  {
    id v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v9);
    id v11 = [*(id *)(a1 + 32) copyDescription];
    _NRLogWithArgs( v10,  0LL,  "%s%.30s:%-4d %@: Plumbed classA keys with IDS keys %@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_16",  8704LL,  v11,  v42);
  }

  id v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v9);
  int v13 = _NRLogIsLevelEnabled(v12, 0LL);

  if (v13)
  {
    uint64_t v15 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v14);
    id v16 = [*(id *)(a1 + 32) copyDescription];
    if (v5) {
      id v17 = (void *)*((void *)v5 + 1);
    }
    else {
      id v17 = 0LL;
    }
    id v18 = v17;
    id v19 = sub_100124E58(v18);
    Logid String = (void *)_NRKeyCreateLogString(v19);
    _NRLogWithArgs( v15,  0LL,  "%s%.30s:%-4d %@: classARemotePublicKey=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_16",  8706LL,  v16,  LogString);
  }

  uint64_t v21 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v14);
  int v22 = _NRLogIsLevelEnabled(v21, 0LL);

  if (v22)
  {
    id v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v23);
    id v25 = [*(id *)(a1 + 32) copyDescription];
    if (v5) {
      id v26 = (void *)*((void *)v5 + 2);
    }
    else {
      id v26 = 0LL;
    }
    id v27 = v26;
    uint64_t v28 = sub_100124E58(v27);
    id v29 = (void *)_NRKeyCreateLogString(v28);
    _NRLogWithArgs( v24,  0LL,  "%s%.30s:%-4d %@: classALocalPublicKey=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_16",  8708LL,  v25,  v29);
  }

  id v30 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v23);
  int v31 = _NRLogIsLevelEnabled(v30, 0LL);

  if (v31)
  {
    uint64_t v33 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v32);
    id v34 = [*(id *)(a1 + 32) copyDescription];
    if (v5)
    {
      id v35 = *((id *)v5 + 3);
      uint64_t v36 = v35;
      if (v35)
      {
        uint64_t v37 = (void *)*((void *)v35 + 2);
LABEL_17:
        id v38 = v37;
        uint64_t v39 = (void *)_NRKeyCreateLogString(v38);
        _NRLogWithArgs( v33,  0LL,  "%s%.30s:%-4d %@: classASharedSecret=%@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_16",  8710LL,  v34,  v39);

        goto LABEL_18;
      }
    }

    else
    {
      uint64_t v36 = 0LL;
    }

    uint64_t v37 = 0LL;
    goto LABEL_17;
  }

void sub_10007F2EC(uint64_t a1)
{
}

void sub_10007F300(uint64_t a1, uint64_t a2)
{
  id v3 = *(void **)(a1 + 32);
  if ((_DWORD)a2)
  {
    uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(v3[4], a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

    if (IsLevelEnabled)
    {
      id v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
      id v8 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d %@: initiatorLocalPublicClassDKeysEncryptedWithIDS was received on %@",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_2",  8464LL,  v8,  *(void *)(a1 + 40));
    }

    uint64_t v9 = *(void *)(a1 + 32);
    if (v9) {
      sub_100076BD8(v9, 4LL, 0, 0);
    }
  }

  else
  {
    [v3 cancelWithReason:@"initiatorLocalPublicClassDKeysEncryptedWithIDS was not received on %@", *(void *)(a1 + 40)];
  }

void sub_10007F3EC(uint64_t a1)
{
}

void sub_10007F400(uint64_t a1)
{
}

void sub_10007F414(uint64_t a1)
{
}

void sub_10007F428(uint64_t a1, uint64_t a2)
{
  int v2 = a2;
  uint64_t v4 = _NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), a2);
  id v5 = (void *)v4;
  if (v2)
  {
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

    if (IsLevelEnabled)
    {
      id v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v7);
      id v9 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v8,  0LL,  "%s%.30s:%-4d %@: initiatorLocalPublicKeys were received",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_3",  8523LL,  v9);
    }

    uint64_t v10 = *(void *)(a1 + 32);
    if (v10) {
      sub_100076BD8(v10, 4LL, 0, 0);
    }
  }

  else
  {
    int v11 = _NRLogIsLevelEnabled(v4, 16LL);

    if (v11)
    {
      id v14 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v12);
      id v13 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v14,  16LL,  "%s%.30s:%-4d %@: initiatorLocalPublicKeys were not received",  "",  "-[NRLinkBluetooth setupIKECallbacksPairing]_block_invoke_3",  8528LL,  v13);
    }
  }

void sub_10007F578(uint64_t a1, int a2)
{
  id WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    --*(_DWORD *)(WeakRetained + 307);
    id v19 = WeakRetained;
    if ((*(_DWORD *)(WeakRetained + 307) & 0x80000000) != 0)
    {
      id v5 = (void *)_NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v4);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 17LL);

      if (IsLevelEnabled)
      {
        uint64_t v7 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v19 + 4), v4);
        id v8 = [v19 copyDescription];
        _NRLogWithArgs(v7, 17LL, "%@: Invalid control data send queue length: %d", v8, *(unsigned int *)(v19 + 307));
      }

      id WeakRetained = v19;
      *(_DWORD *)(v19 + 307) = 0;
    }

    uint64_t v9 = _NRCopyLogObjectForNRUUID(*((void *)WeakRetained + 4), v4);
    uint64_t v10 = (void *)v9;
    if (a2)
    {
      int v11 = _NRLogIsLevelEnabled(v9, 0LL);

      if (v11)
      {
        id v13 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v19 + 4), v12);
        id v14 = [v19 copyDescription];
        _NRLogWithArgs( v13,  0LL,  "%s%.30s:%-4d %@: Received response to control notify",  "",  "-[NRLinkBluetooth sendControlData:]_block_invoke",  7295LL,  v14);
      }

      id WeakRetained = v19;
      if (v19[231] && !*(_DWORD *)(v19 + 307))
      {
        sub_10007F760((uint64_t)v19, 1LL);
LABEL_14:
        id WeakRetained = v19;
      }
    }

    else
    {
      int v15 = _NRLogIsLevelEnabled(v9, 16LL);

      id WeakRetained = v19;
      if (v15)
      {
        id v17 = (void *)_NRCopyLogObjectForNRUUID(*((void *)v19 + 4), v16);
        id v18 = [v19 copyDescription];
        _NRLogWithArgs( v17,  16LL,  "%s%.30s:%-4d %@: Did not receive response to control notify",  "",  "-[NRLinkBluetooth sendControlData:]_block_invoke",  7302LL,  v18);

        goto LABEL_14;
      }
    }
  }
}

void sub_10007F760(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    *(_BYTE *)(a1 + 231) = 0;
    if (*(unsigned __int8 *)(a1 + 232) != (_DWORD)a2)
    {
      uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 0LL);

      if (IsLevelEnabled)
      {
        uint64_t v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v6);
        id v8 = [(id)a1 copyDescription];
        _NRLogWithArgs( v7,  0LL,  "%s%.30s:%-4d %@: Setting isSuspended: %d -> %d",  "",  "-[NRLinkBluetooth setIsSuspended:]",  1743LL,  v8,  *(unsigned __int8 *)(a1 + 232),  a2);
      }

      *(_BYTE *)(a1 + 232) = a2;
      sub_10007F85C(a1, v6);
    }
  }

void sub_10007F85C(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (*(_BYTE *)(a1 + 232))
    {
      id v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 0LL);

      if (IsLevelEnabled)
      {
        uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
        id v7 = [(id)a1 copyDescription];
        _NRLogWithArgs( v6,  0,  "%s%.30s:%-4d %@: Setting packetNexus.availability: %zu -> %zu",  "",  "-[NRLinkBluetooth setPacketNexusAvailability]",  5838,  v7,  [*(id *)(a1 + 1335) availability],  0);
      }

      [*(id *)(a1 + 1335) setAvailability:0];
    }

    else
    {
      uint64_t v8 = objc_claimAutoreleasedReturnValue([(id)a1 proxyAgentRegistration]);
      if (v8)
      {
        uint64_t v9 = (void *)v8;
        BOOL v10 = [(id)a1 state] == 8;
      }

      else
      {
        BOOL v10 = 0;
      }

      int v11 = (void *)objc_claimAutoreleasedReturnValue([(id)a1 nrUUID]);
      uint64_t v32 = (id *)sub_100129B30((uint64_t)&OBJC_CLASS___NRDLocalDevice, v11);

      if (v32)
      {
        id v12 = v32[16];

        if (v12 && (id v14 = v32[16]) != 0LL)
        {
          int v15 = v14;
          id v16 = v32[16];
          char v17 = [v16 requiresReachability] & v10;

          if ((v17 & 1) != 0) {
            uint64_t v18 = 2LL;
          }
          else {
            uint64_t v18 = 1LL;
          }
        }

        else
        {
          uint64_t v18 = 1LL;
        }

        id v19 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v13);
        int v20 = _NRLogIsLevelEnabled(v19, 0LL);

        if (v20)
        {
          int v22 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v21);
          id v23 = [(id)a1 copyDescription];
          _NRLogWithArgs( v22,  0,  "%s%.30s:%-4d %@: Setting packetNexus.availability: %zu -> %zu",  "",  "-[NRLinkBluetooth setPacketNexusAvailability]",  5870,  v23,  [*(id *)(a1 + 1335) availability],  v18);
        }

        objc_msgSend(*(id *)(a1 + 1335), "setAvailability:", v18, v32);
      }

      else
      {
        id v24 = sub_100070554();
        int v25 = _NRLogIsLevelEnabled(v24, 16LL);

        if (v25)
        {
          id v26 = sub_100070554();
          _NRLogWithArgs( v26,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (localDevice) != ((void *)0)",  "",  "-[NRLinkBluetooth setPacketNexusAvailability]",  5854);
        }

        uint64_t v27 = _os_log_pack_size(12LL);
        uint64_t v28 = (char *)&v32 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0LL);
        id v29 = __error();
        uint64_t v30 = _os_log_pack_fill( v28,  v27,  *v29,  &_mh_execute_header,  "%{public}s Assertion Failed: (localDevice) != ((void *)0)");
        *(_DWORD *)uint64_t v30 = 136446210;
        *(void *)(v30 + 4) = "-[NRLinkBluetooth setPacketNexusAvailability]";
        id v31 = sub_100070554();
        _NRLogAbortWithPack(v31, v28);
      }
    }
  }

void sub_10007FBE0(uint64_t a1)
{
  int v2 = (void *)objc_claimAutoreleasedReturnValue([*(id *)(a1 + 32) linkDelegate]);
  if (!v2) {
    goto LABEL_13;
  }
  id v3 = *(void **)(a1 + 40);
  uint64_t v9 = v2;
  if (v3)
  {
    id v4 = [v3 hostState];
    BOOL v5 = v4 == (id)1;
    uint64_t v6 = *(void *)(a1 + 32);
    if (v6)
    {
      int v2 = v9;
      if ((v4 == (id)1) != (*(_BYTE *)(v6 + 243) != 0))
      {
LABEL_9:
        *(_BYTE *)(v6 + 243) = v5;
        uint64_t v7 = *(void *)(a1 + 32);
        if (v7) {
          *(_BYTE *)(v7 + 244) = 1;
        }
        goto LABEL_11;
      }

void sub_10007FCF8(uint64_t a1, void *a2)
{
  id v4 = a2;
  uint64_t v6 = v4;
  if (!a1 || *(id *)(a1 + 1031) == v4) {
    goto LABEL_63;
  }
  if (*(_BYTE *)(a1 + 246))
  {
LABEL_4:
    uint64_t v7 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v7, 1LL);

    if (IsLevelEnabled)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v9);
      id v11 = [(id)a1 copyDescription];
      _NRLogWithArgs( v10,  1LL,  "%s%.30s:%-4d %@: Updating datagram pipe: %@ -> %@",  "",  "-[NRLinkBluetooth updateDatagramPipe:]",  2790LL,  v11,  *(void *)(a1 + 1031),  v6);
    }

    objc_storeStrong((id *)(a1 + 1031), a2);
    *(_BYTE *)(a1 + 225) = *(void *)(a1 + 1031) != 0LL;
    if (*(_BYTE *)(a1 + 246))
    {
      if (*(_BYTE *)(a1 + 225)) {
        sub_10008F364((void *)a1, 0LL, &off_1001BC658);
      }
      else {
        sub_1000836BC(a1, &off_1001BC658);
      }
    }

    goto LABEL_63;
  }

  id v12 = *(dispatch_source_s **)(a1 + 1063);
  if (!v6)
  {
    if (v12)
    {
      if (*(_BYTE *)(a1 + 223))
      {
        *(_BYTE *)(a1 + 223) = 0;
        ++*(void *)(a1 + 1079);
        if (gNRPacketLoggingEnabled)
        {
          id v89 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
          int v90 = _NRLogIsLevelEnabled(v89, 1LL);

          if (v90)
          {
            uint64_t v92 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v91);
            id v93 = [(id)a1 copyDescription];
            _NRLogWithArgs( v92,  1LL,  "%s%.30s:%-4d %@: source-resume: DatagramLinkInput",  "",  "NRLinkResumeDatagramLinkInputSource",  824LL,  v93);
          }
        }

        dispatch_resume(*(dispatch_object_t *)(a1 + 1063));
        id v12 = *(dispatch_source_s **)(a1 + 1063);
      }

      dispatch_source_cancel(v12);
      id v29 = *(void **)(a1 + 1063);
      *(void *)(a1 + 1063) = 0LL;
    }

    uint64_t v30 = *(dispatch_source_s **)(a1 + 1071);
    if (v30)
    {
      if (*(_BYTE *)(a1 + 224))
      {
        *(_BYTE *)(a1 + 224) = 0;
        ++*(void *)(a1 + 1087);
        if (gNRPacketLoggingEnabled)
        {
          int v94 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
          int v95 = _NRLogIsLevelEnabled(v94, 1LL);

          if (v95)
          {
            id v97 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v96);
            id v98 = [(id)a1 copyDescription];
            _NRLogWithArgs( v97,  1LL,  "%s%.30s:%-4d %@: source-resume: DatagramLinkOutput",  "",  "NRLinkResumeDatagramLinkOutputSource",  825LL,  v98);
          }
        }

        dispatch_resume(*(dispatch_object_t *)(a1 + 1071));
        uint64_t v30 = *(dispatch_source_s **)(a1 + 1071);
      }

      dispatch_source_cancel(v30);
      id v31 = *(void **)(a1 + 1071);
      *(void *)(a1 + 1071) = 0LL;
    }

    if (!*(_BYTE *)(a1 + 215) && *(void *)(a1 + 559))
    {
      *(_BYTE *)(a1 + 215) = 1;
      ++*(void *)(a1 + 575);
      if (gNRPacketLoggingEnabled)
      {
        uint64_t v119 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
        int v120 = _NRLogIsLevelEnabled(v119, 1LL);

        if (v120)
        {
          uint64_t v122 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v121);
          id v123 = [(id)a1 copyDescription];
          _NRLogWithArgs( v122,  1LL,  "%s%.30s:%-4d %@: source-suspend: NexusVOOutput",  "",  "NRLinkSuspendNexusVOOutputSource",  835LL,  v123);
        }
      }

      dispatch_suspend(*(dispatch_object_t *)(a1 + 559));
    }

    if (*(_BYTE *)(a1 + 212) && *(void *)(a1 + 391))
    {
      *(_BYTE *)(a1 + 212) = 0;
      ++*(void *)(a1 + 415);
      if (gNRPacketLoggingEnabled)
      {
        uint64_t v99 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
        int v100 = _NRLogIsLevelEnabled(v99, 1LL);

        if (v100)
        {
          uint64_t v102 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v101);
          id v103 = [(id)a1 copyDescription];
          _NRLogWithArgs( v102,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusInput",  "",  "NRLinkResumeNexusInputSource",  842LL,  v103);
        }
      }

      dispatch_resume(*(dispatch_object_t *)(a1 + 391));
    }

    if (*(_BYTE *)(a1 + 216) && *(void *)(a1 + 695))
    {
      *(_BYTE *)(a1 + 216) = 0;
      ++*(void *)(a1 + 711);
      if (gNRPacketLoggingEnabled)
      {
        uint64_t v104 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
        int v105 = _NRLogIsLevelEnabled(v104, 1LL);

        if (v105)
        {
          uint64_t v107 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v106);
          id v108 = [(id)a1 copyDescription];
          _NRLogWithArgs( v107,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusVIInput",  "",  "NRLinkResumeNexusVIInputSource",  846LL,  v108);
        }
      }

      dispatch_resume(*(dispatch_object_t *)(a1 + 695));
    }

    if (*(_BYTE *)(a1 + 218) && *(void *)(a1 + 839))
    {
      *(_BYTE *)(a1 + 21_Block_object_dispose(va, 8) = 0;
      ++*(void *)(a1 + 855);
      if (gNRPacketLoggingEnabled)
      {
        unsigned int v109 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
        int v110 = _NRLogIsLevelEnabled(v109, 1LL);

        if (v110)
        {
          id v112 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v111);
          id v113 = [(id)a1 copyDescription];
          _NRLogWithArgs( v112,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusBKInput",  "",  "NRLinkResumeNexusBKInputSource",  848LL,  v113);
        }
      }

      dispatch_resume(*(dispatch_object_t *)(a1 + 839));
    }

    if (*(_BYTE *)(a1 + 214) && *(void *)(a1 + 551))
    {
      *(_BYTE *)(a1 + 214) = 0;
      ++*(void *)(a1 + 567);
      if (gNRPacketLoggingEnabled)
      {
        id v114 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
        int v115 = _NRLogIsLevelEnabled(v114, 1LL);

        if (v115)
        {
          __int128 v117 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v116);
          id v118 = [(id)a1 copyDescription];
          _NRLogWithArgs( v117,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusVOInput",  "",  "NRLinkResumeNexusVOInputSource",  844LL,  v118);
        }
      }

      dispatch_resume(*(dispatch_object_t *)(a1 + 551));
    }

    *(void *)(a1 + 1039) = 0LL;
    *(void *)(a1 + 1055) = 0LL;
    *(void *)(a1 + 1047) = 0LL;
    *(void *)(a1 + 1079) = 0LL;
    *(void *)(a1 + 1087) = 0LL;
    uint64_t v32 = *(void **)(a1 + 1911);
    if (v32)
    {
      free(v32);
      *(void *)(a1 + 1911) = 0LL;
    }

    goto LABEL_4;
  }

  if (v12)
  {
    if (*(_BYTE *)(a1 + 223))
    {
      *(_BYTE *)(a1 + 223) = 0;
      ++*(void *)(a1 + 1079);
      if (gNRPacketLoggingEnabled)
      {
        uint64_t v79 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
        int v80 = _NRLogIsLevelEnabled(v79, 1LL);

        if (v80)
        {
          uint64_t v82 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v81);
          id v83 = [(id)a1 copyDescription];
          _NRLogWithArgs( v82,  1LL,  "%s%.30s:%-4d %@: source-resume: DatagramLinkInput",  "",  "NRLinkResumeDatagramLinkInputSource",  824LL,  v83);
        }
      }

      dispatch_resume(*(dispatch_object_t *)(a1 + 1063));
      id v12 = *(dispatch_source_s **)(a1 + 1063);
    }

    dispatch_source_cancel(v12);
    uint64_t v13 = *(void **)(a1 + 1063);
    *(void *)(a1 + 1063) = 0LL;
  }

  id v14 = *(dispatch_source_s **)(a1 + 1071);
  if (v14)
  {
    if (*(_BYTE *)(a1 + 224))
    {
      *(_BYTE *)(a1 + 224) = 0;
      ++*(void *)(a1 + 1087);
      if (gNRPacketLoggingEnabled)
      {
        uint64_t v84 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v5);
        int v85 = _NRLogIsLevelEnabled(v84, 1LL);

        if (v85)
        {
          uint64_t v87 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v86);
          id v88 = [(id)a1 copyDescription];
          _NRLogWithArgs( v87,  1LL,  "%s%.30s:%-4d %@: source-resume: DatagramLinkOutput",  "",  "NRLinkResumeDatagramLinkOutputSource",  825LL,  v88);
        }
      }

      dispatch_resume(*(dispatch_object_t *)(a1 + 1071));
      id v14 = *(dispatch_source_s **)(a1 + 1071);
    }

    dispatch_source_cancel(v14);
    int v15 = *(void **)(a1 + 1071);
    *(void *)(a1 + 1071) = 0LL;
  }

  *(void *)(a1 + 1039) = 0LL;
  *(void *)(a1 + 1055) = 0LL;
  *(void *)(a1 + 1047) = 0LL;
  id v16 = [v6 channel];
  *(void *)(a1 + 1039) = v16;
  if (!v16)
  {
    uint64_t v33 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v17);
    int v34 = _NRLogIsLevelEnabled(v33, 17LL);

    if (v34)
    {
      uint64_t v27 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v35);
      id v28 = [(id)a1 copyDescription];
      _NRLogWithArgs(v27, 17LL, "%@: _datagramLinkChannel is NULL", v28, v134);
      goto LABEL_62;
    }

void sub_100080D40(char *a1, char *a2)
{
  id v3 = a2;
  uint64_t v5 = a2;
  uint64_t v7 = v5;
  if (!v5)
  {
    if ([a1 state] != 255)
    {
      uint64_t v21 = *(id *)(a1 + 1863);
      if (v21) {
        ++v21[16];
      }
    }

    sub_100081D6C((uint64_t)a1, v20);
    goto LABEL_21;
  }

  sub_100081D6C((uint64_t)a1, v6);
  if ([v7 priority] != (id)2)
  {
    uint64_t v27 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v8);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v27, 17LL);

    if (!IsLevelEnabled) {
      goto LABEL_29;
    }
    uint64_t v30 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v29);
    id v31 = [a1 copyDescription];
    _NRLogWithArgs(v30, 17LL, "%@: invalid urgent pipe: %@", v31, v7);
LABEL_28:

    goto LABEL_29;
  }

  if (a1[246]) {
    goto LABEL_6;
  }
  id v32 = [v7 channel];
  *(void *)(a1 + 1119) = v32;
  if (!v32)
  {
    uint64_t v43 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v33);
    int v44 = _NRLogIsLevelEnabled(v43, 17LL);

    if (!v44) {
      goto LABEL_29;
    }
    uint64_t v30 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v45);
    id v31 = [a1 copyDescription];
    _NRLogWithArgs(v30, 17LL, "%@: _urgentLinkChannel is NULL", v31);
    goto LABEL_28;
  }

  uint64_t v34 = os_channel_attr_create();
  if (!v34)
  {
    int v46 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v35);
    int v47 = _NRLogIsLevelEnabled(v46, 17LL);

    if (!v47) {
      goto LABEL_29;
    }
    uint64_t v30 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v48);
    id v31 = [a1 copyDescription];
    _NRLogWithArgs(v30, 17LL, "%@: os_channel_attr_create failed", v31);
    goto LABEL_28;
  }

  uint64_t v36 = v34;
  uint64_t attr = os_channel_read_attr(*(void *)(a1 + 1119), v34);
  if ((_DWORD)attr)
  {
    uint64_t v39 = attr;
    uint64_t v40 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v38);
    int v41 = _NRLogIsLevelEnabled(v40, 17LL);

    if (!v41) {
      goto LABEL_29;
    }
    uint64_t v30 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v42);
    id v31 = [a1 copyDescription];
    _NRLogWithArgs(v30, 17LL, "%@: os_channel_read_attr returned %d", v31, v39);
    goto LABEL_28;
  }

  int v49 = sub_1000821D4(a1, v36);
  os_channel_attr_destroy(v36);
  if (!v49) {
    goto LABEL_29;
  }
  uint64_t v50 = os_channel_ring_id(*(void *)(a1 + 1119), 2LL);
  uint64_t v51 = os_channel_rx_ring(*(void *)(a1 + 1119), v50);
  *(void *)(a1 + 1127) = v51;
  if (!v51)
  {
    int v72 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v52);
    int v73 = _NRLogIsLevelEnabled(v72, 17LL);

    if (!v73) {
      goto LABEL_29;
    }
    uint64_t v30 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v74);
    id v31 = [a1 copyDescription];
    _NRLogWithArgs(v30, 17LL, "%@: _urgentLinkInputRing is NULL", v31);
    goto LABEL_28;
  }

  uint64_t v53 = os_channel_ring_id(*(void *)(a1 + 1119), 0LL);
  uint64_t v54 = os_channel_tx_ring(*(void *)(a1 + 1119), v53);
  *(void *)(a1 + 1135) = v54;
  if (!v54)
  {
    int v75 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v55);
    int v76 = _NRLogIsLevelEnabled(v75, 17LL);

    if (!v76) {
      goto LABEL_29;
    }
    uint64_t v30 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v77);
    id v31 = [a1 copyDescription];
    _NRLogWithArgs(v30, 17LL, "%@: _urgentLinkOutputRing is NULL", v31);
    goto LABEL_28;
  }

  unsigned int fd = os_channel_get_fd(*(void *)(a1 + 1119));
  if ((fd & 0x80000000) != 0)
  {
    id v78 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v57);
    int v79 = _NRLogIsLevelEnabled(v78, 17LL);

    if (!v79) {
      goto LABEL_29;
    }
    uint64_t v30 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v80);
    id v31 = [a1 copyDescription];
    _NRLogWithArgs(v30, 17LL, "%@: os_channel_get_fd failed", v31);
    goto LABEL_28;
  }

  uintptr_t v58 = fd;
  dispatch_source_t v59 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_read,  fd,  0LL,  *((dispatch_queue_t *)a1 + 1));
  uint64_t v60 = *(void **)(a1 + 1143);
  *(void *)(a1 + 1143) = v59;

  int v62 = *(dispatch_source_s **)(a1 + 1143);
  if (!v62)
  {
    uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v61);
    int v82 = _NRLogIsLevelEnabled(v81, 17LL);

    if (!v82) {
      goto LABEL_29;
    }
    uint64_t v30 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v83);
    id v31 = [a1 copyDescription];
    _NRLogWithArgs(v30, 17LL, "%@: _dUrgentLinkInputSource is NULL", v31);
    goto LABEL_28;
  }

  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472LL;
  handler[2] = sub_1000831A4;
  handler[3] = &unk_1001B0A88;
  void handler[4] = a1;
  dispatch_source_set_event_handler(v62, handler);
  int v63 = *(dispatch_source_s **)(a1 + 1143);
  v132[0] = _NSConcreteStackBlock;
  v132[1] = 3221225472LL;
  v132[2] = nullsub_6;
  v132[3] = &unk_1001B0A88;
  uint64_t v64 = v7;
  uint64_t v133 = v64;
  dispatch_source_set_cancel_handler(v63, v132);
  dispatch_activate(*(dispatch_object_t *)(a1 + 1143));
  dispatch_source_t v65 = dispatch_source_create( (dispatch_source_type_t)&_dispatch_source_type_write,  v58,  0LL,  *((dispatch_queue_t *)a1 + 1));
  int v66 = *(void **)(a1 + 1151);
  *(void *)(a1 + 1151) = v65;

  int v68 = *(dispatch_source_s **)(a1 + 1151);
  if (v68)
  {
    v131[0] = _NSConcreteStackBlock;
    v131[1] = 3221225472LL;
    v131[2] = sub_1000833C4;
    v131[3] = &unk_1001B0A88;
    v131[4] = a1;
    dispatch_source_set_event_handler(v68, v131);
    int v69 = *(dispatch_source_s **)(a1 + 1151);
    v129[0] = _NSConcreteStackBlock;
    v129[1] = 3221225472LL;
    v129[2] = nullsub_7;
    v129[3] = &unk_1001B0A88;
    uint64_t v130 = v64;
    dispatch_source_set_cancel_handler(v69, v129);
    a1[228] = 1;
    int v2 = (NSData *)10;
    a1[252] = 10;
    uint64_t v70 = a1[252];
    if (a1[252])
    {
      uint64_t v9 = 8 * v70;
      __memptr[0] = 0LL;
      if (posix_memalign(__memptr, 8uLL, 8 * v70) || !__memptr[0])
      {
        id v114 = sub_100070554();
        int v115 = _NRLogIsLevelEnabled(v114, 16LL);

        id v3 = "strict_memalign";
        if (v115)
        {
          id v116 = sub_100070554();
          _NRLogWithArgs( v116,  16LL,  "%s%.30s:%-4d ABORTING: posix_memalign(..., %zu, %zu) failed",  "",  "strict_memalign",  183,  8uLL,  v9);
        }

        uint64_t v7 = (char *)_os_log_pack_size(32LL);
        a1 = (char *)block - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        __int128 v117 = __error();
        uint64_t v101 = _os_log_pack_fill( a1,  v7,  *v117,  &_mh_execute_header,  "%{public}s posix_memalign(..., %zu, %zu) failed");
        *(_DWORD *)uint64_t v101 = 136446722;
        *(void *)(v101 + 4) = "strict_memalign";
        goto LABEL_87;
      }

      *(void **)(a1 + 1895) = __memptr[0];
    }

    a1[258] = 10;
    uint64_t v71 = a1[258];
    if (!a1[258])
    {
LABEL_53:

LABEL_6:
      uint64_t v9 = *(unsigned int *)(a1 + 267);
      if ((_DWORD)v9)
      {
        int v2 = (NSData *)block;
        BOOL v10 = calloc(1uLL, *(unsigned int *)(a1 + 267));
        if (!v10)
        {
          id v94 = sub_100070554();
          int v95 = _NRLogIsLevelEnabled(v94, 16LL);

          if (v95)
          {
            id v96 = sub_100070554();
            _NRLogWithArgs( v96,  16LL,  "%s%.30s:%-4d ABORTING: strict_calloc(%zu, %zu) failed",  "",  "strict_calloc",  108,  1uLL,  v9);
          }

LABEL_73:
          uint64_t v7 = (char *)_os_log_pack_size(32LL);
          a1 = (char *)block - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          int v100 = __error();
          uint64_t v101 = _os_log_pack_fill( a1,  v7,  *v100,  &_mh_execute_header,  "%{public}s strict_calloc(%zu, %zu) failed");
          *(_DWORD *)uint64_t v101 = 136446722;
          *(void *)(v101 + 4) = "strict_calloc";
          *(_WORD *)(v101 + 12) = 2048;
          uint64_t v102 = 1LL;
LABEL_74:
          *(void *)(v101 + 14) = v102;
          *(_WORD *)(v101 + 22) = 2048;
          *(void *)(v101 + 24) = v9;
          goto LABEL_78;
        }

        *(void *)(a1 + 1319) = v10;
        *(_DWORD *)(a1 + 323) = 0;
        *(_DWORD *)(a1 + 319) = 0;
        uint64_t v9 = *(unsigned int *)(a1 + 283);
        if ((_DWORD)v9)
        {
          int v2 = (NSData *)block;
          id v11 = calloc(1uLL, *(unsigned int *)(a1 + 283));
          if (v11)
          {
            *(void *)(a1 + 1191) = v11;
            *(_DWORD *)(a1 + 299) = 0;
            *(_DWORD *)(a1 + 303) = 0;
            char v12 = a1[208];
            uint64_t v9 = a1;
            uint64_t v13 = (char *)malloc(0x21uLL);
            if (v13)
            {
              int v2 = (NSData *)v13;
              *(void *)uint64_t v13 = 0x53554E494D524554LL;
              v13[8] = 1;
              v13[9] = v12;
              *((_WORD *)v13 + 5) = 4864;
              v13[12] = 4;
              *(_WORD *)(v13 + 13) = 4096;
              [*(id *)(v9 + 1359) getUUIDBytes:__memptr];
              *(_OWORD *)((char *)&v2[1].super.isa + 7) = *(_OWORD *)__memptr;
              *(_WORD *)((char *)&v2[3].super.isa + 7) = ~(unsigned __int16)os_inet_checksum(v2, 31LL, 0LL);

              if (*(_DWORD *)(v9 + 283) > 0x20u)
              {
                uint64_t v14 = *(void *)(v9 + 1191);
                char isa = (char)v2[4].super.isa;
                __int128 v16 = *(_OWORD *)&v2[2].super.isa;
                *(_OWORD *)uint64_t v14 = *(_OWORD *)&v2->super.isa;
                *(_OWORD *)(v14 + 16) = v16;
                *(_BYTE *)(v14 + 32) = isa;
                free(v2);
                *(_DWORD *)(v9 + 299) += 33;
                int v2 = -[NSData initWithBytes:length:]( objc_alloc(&OBJC_CLASS___NSData),  "initWithBytes:length:",  *(void *)(v9 + 1191),  33LL);
                if (!gNRPacketLoggingEnabled)
                {
LABEL_13:
                  if (*(_BYTE *)(v9 + 246)) {
                    sub_100070C18(v9, v2, &off_1001BC640);
                  }
                  uint64_t v18 = *(dispatch_queue_s **)(v9 + 8);
                  block[0] = _NSConcreteStackBlock;
                  block[1] = 3221225472LL;
                  block[2] = sub_100083564;
                  block[3] = &unk_1001B0720;
                  void block[4] = v9;
                  uint64_t v128 = v7;
                  dispatch_async(v18, block);

LABEL_21:
                  uint64_t v22 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v19);
                  int v23 = _NRLogIsLevelEnabled(v22, 1LL);

                  if (v23)
                  {
                    int v25 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v24);
                    id v26 = [a1 copyDescription];
                    _NRLogWithArgs( v25,  1LL,  "%s%.30s:%-4d %@: Updating urgent pipe: %@ -> %@",  "",  "-[NRLinkBluetooth updateUrgentPipe:]",  2623LL,  v26,  *(void *)(a1 + 1111),  v7);
                  }

                  objc_storeStrong((id *)(a1 + 1111), v3);
                  if (!*(void *)(a1 + 1111) && a1[246]) {
                    sub_1000836BC((uint64_t)a1, &off_1001BC640);
                  }
                  goto LABEL_29;
                }

                      uint64_t v39 = (char *)v39 + 1;
                    }

                    while (v37 != v39);
                    int v49 = [v36 countByEnumeratingWithState:&v104 objects:v119 count:16];
                    int v37 = v49;
                  }

                  while (v49);
                }

                uint64_t v50 = *((unsigned __int8 *)v116 + 24);
                uint64_t v51 = v33[1];
                if (v50) {
                  uint64_t v52 = -2005LL;
                }
                else {
                  uint64_t v52 = 0LL;
                }
                sub_1000FE6B8((uint64_t)&OBJC_CLASS___NRDevicePairingDirector, v52, v96, v51);
              }

              _Block_object_dispose(&v109, 8);
              _Block_object_dispose(&v115, 8);
              goto LABEL_87;
            }

            int v69 = sub_1000FBEC0();
            uint64_t v70 = _NRLogIsLevelEnabled(v69, 17LL);

            if (v70)
            {
              uint64_t v71 = sub_1000FBEC0();
              _NRLogWithArgs(v71, 17LL, "Failed to get pairing manager UUID array from message");
            }

            sub_1000FE6B8((uint64_t)&OBJC_CLASS___NRDevicePairingDirector, -2005LL, v96, v33[1]);
LABEL_87:

            break;
          case 3uLL:
            uint64_t v53 = v102;
            uint64_t v54 = xdict;
            if (qword_1001DC9B8 != -1) {
              goto LABEL_119;
            }
            goto LABEL_103;
          case 4uLL:
            uint64_t v53 = v102;
            uint64_t v54 = xdict;
            if (qword_1001DC9B8 == -1) {
              goto LABEL_103;
            }
            goto LABEL_119;
          case 6uLL:
          case 9uLL:
            goto LABEL_109;
          case 0xAuLL:
            uint64_t v54 = xdict;
            uint64_t v55 = v102;
            uuid = xpc_dictionary_get_uuid(v54, nrXPCKeyPairingManager);
            if (uuid && (uint64_t v57 = uuid, !uuid_is_null(uuid)))
            {
              dispatch_source_t v59 = -[NSUUID initWithUUIDBytes:](objc_alloc(&OBJC_CLASS___NSUUID), "initWithUUIDBytes:", v57);
              uint64_t v60 = (void *)objc_claimAutoreleasedReturnValue([v55[2] objectForKeyedSubscript:v59]);
              if (!v60)
              {
                uint64_t v87 = sub_1000FBEC0();
                id v88 = _NRLogIsLevelEnabled(v87, 17LL);

                if (v88)
                {
                  id v89 = sub_1000FBEC0();
                  _NRLogWithArgs(v89, 17LL, "%@ is not registered", v59);
                }

                sub_1000FE6B8((uint64_t)&OBJC_CLASS___NRDevicePairingDirector, -2005LL, v54, v55[1]);
              }
            }

            else
            {
              sub_1000FE6B8((uint64_t)&OBJC_CLASS___NRDevicePairingDirector, -2005LL, v54, v55[1]);
            }

            goto LABEL_108;
          case 0xBuLL:
            uint64_t v53 = v102;
            uint64_t v54 = xdict;
            if (qword_1001DC9B8 == -1) {
              goto LABEL_103;
            }
LABEL_119:
            dispatch_once(&qword_1001DC9B8, &stru_1001AFB18);
LABEL_103:
            uintptr_t v58 = v53[1];

            sub_1000FE6B8((uint64_t)&OBJC_CLASS___NRDevicePairingDirector, -9999LL, v54, v58);
LABEL_108:

            goto LABEL_109;
          case 0xDuLL:
            sub_1000FEB34(xdict, v102);
            goto LABEL_109;
          default:
            if (qword_1001DC978 != -1) {
              dispatch_once(&qword_1001DC978, &stru_1001AFA38);
            }
            if (_NRLogIsLevelEnabled(qword_1001DC970, 17LL))
            {
              if (qword_1001DC978 != -1) {
                dispatch_once(&qword_1001DC978, &stru_1001AFA38);
              }
              _NRLogWithArgs(qword_1001DC970, 17LL, "Received unexpected operation code %llu", v10);
            }

            sub_1000FE6B8((uint64_t)&OBJC_CLASS___NRDevicePairingDirector, -2003LL, xdict, v102[1]);
            goto LABEL_109;
        }

        goto LABEL_109;
      }

      uint64_t v64 = sub_1000FBEC0();
      dispatch_source_t v65 = _NRLogIsLevelEnabled(v64, 17LL);

      if (v65)
      {
        int v63 = sub_1000FBEC0();
        _NRLogWithArgs(v63, 17LL, "Received invalid operation code type");
        goto LABEL_117;
      }
    }

    else
    {
      uint64_t v61 = sub_1000FBEC0();
      int v62 = _NRLogIsLevelEnabled(v61, 17LL);

      if (v62)
      {
        int v63 = sub_1000FBEC0();
        _NRLogWithArgs(v63, 17LL, "Received request without operation code");
LABEL_117:
      }
    }

    sub_1000FE928(v5, v100);
LABEL_109:

LABEL_110:
    uint64_t v6 = v100;
LABEL_111:

    goto LABEL_112;
  }

  if (type == (xpc_type_t)&_xpc_type_error)
  {
    if (qword_1001DC978 != -1) {
      dispatch_once(&qword_1001DC978, &stru_1001AFA38);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC970, 16LL))
    {
      if (qword_1001DC978 != -1) {
        dispatch_once(&qword_1001DC978, &stru_1001AFA38);
      }
      _NRLogWithArgs( qword_1001DC970,  16LL,  "%s%.30s:%-4d Received XPC error: %@, invalidating connection %@",  "",  "-[NRDevicePairingDirector addDevicePairingConnection:]_block_invoke",  3067LL,  v103,  *(void *)(a1 + 40));
    }
  }

  else
  {
    if (qword_1001DC978 != -1) {
      dispatch_once(&qword_1001DC978, &stru_1001AFA38);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC970, 16LL))
    {
      if (qword_1001DC978 != -1) {
        dispatch_once(&qword_1001DC978, &stru_1001AFA38);
      }
      _NRLogWithArgs( qword_1001DC970,  16LL,  "%s%.30s:%-4d Received unexpected XPC object: %@, invalidating connection %@",  "",  "-[NRDevicePairingDirector addDevicePairingConnection:]_block_invoke",  3070LL,  v103,  *(void *)(a1 + 40));
    }

    if (qword_1001DC978 != -1) {
      dispatch_once(&qword_1001DC978, &stru_1001AFA38);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC970, 17LL))
    {
      if (qword_1001DC978 != -1) {
        dispatch_once(&qword_1001DC978, &stru_1001AFA38);
      }
      _NRLogWithArgs(qword_1001DC970, 17LL, "Received unexpected XPC object", v90, v91, v92, v93, v94);
    }
  }

  sub_1000FE928(*(void *)(a1 + 32), *(void **)(a1 + 40));
LABEL_112:
}

    uint64_t v21 = 0LL;
    goto LABEL_66;
  }

  v43.receiver = a1;
  v43.super_class = (Class)&OBJC_CLASS___NRDLDKeychainItemSecKey;
  uint64_t v9 = (char *)objc_msgSendSuper2(&v43, "init");
  if (v9)
  {
    a1 = v9;
    objc_opt_self(&OBJC_CLASS___NRDKeyManager);
    if (qword_1001DCC18 == -1) {
      goto LABEL_5;
    }
  }

  else
  {
    id v31 = sub_100121F34();
    id v32 = _NRLogIsLevelEnabled(v31, 16LL);

    if (v32)
    {
      uint64_t v33 = sub_100121F34();
      _NRLogWithArgs( v33,  16LL,  "%s%.30s:%-4d ABORTING: [super init] failed",  "",  "-[NRDLDKeychainItemSecKey initFromKeychainWithName:nrUUID:dataProtectionClass:]",  327);
    }

    uint64_t v7 = (id)_os_log_pack_size(12LL);
    a1 = (char *)v42 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v34 = __error();
    uint64_t v35 = _os_log_pack_fill(a1, v7, *v34, &_mh_execute_header, "%{public}s [super init] failed");
    *(_DWORD *)uint64_t v35 = 136446210;
    *(void *)(v35 + 4) = "-[NRDLDKeychainItemSecKey initFromKeychainWithName:nrUUID:dataProtectionClass:]";
    uint64_t v36 = sub_100121F34();
    _NRLogAbortWithPack(v36, a1);
  }

  dispatch_once(&qword_1001DCC18, &stru_1001B0910);
LABEL_5:
  BOOL v10 = (dispatch_queue_t *)(id)qword_1001DCC10;
  id v11 = v7;
  char v12 = v8;
  if (v10)
  {
    dispatch_assert_queue_V2(v10[2]);
    if ((_DWORD)a4 == 3)
    {
      uint64_t v13 = &kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly;
    }

    else
    {
      if ((_DWORD)a4 != 4)
      {
        id String = (void *)NRDataProtectionClassCreateString(a4);
        goto LABEL_14;
      }

      uint64_t v13 = (const CFStringRef *)&kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate;
    }

    uint64_t v14 = *v13;
    id String = (void *)NRDataProtectionClassCreateString(a4);
    if (v14)
    {
      __int128 v16 = objc_alloc(&OBJC_CLASS___NSString);
      if (v12) {
        uint64_t v17 = -[NSString initWithFormat:]( v16,  "initWithFormat:",  @"%@/%@/%@/%@",  @"com.apple.terminusd",  v12,  String,  v11);
      }
      else {
        uint64_t v17 = -[NSString initWithFormat:](v16, "initWithFormat:", @"%@/%@", @"com.apple.terminusd", v11);
      }
      uint64_t v20 = v17;
      if (qword_1001DCC28 != -1) {
        dispatch_once(&qword_1001DCC28, &stru_1001B0980);
      }
      if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
      {
        if (qword_1001DCC28 != -1) {
          dispatch_once(&qword_1001DCC28, &stru_1001B0980);
        }
        _NRLogWithArgs( qword_1001DCC20,  0LL,  "%s%.30s:%-4d Reading %@ keychain key %@",  "",  "-[NRDKeyManager readKeyfromKeychainWithName:nrUUID:dataProtectionClass:]",  536LL,  String,  v20);
      }

      uint64_t v22 = (void *)objc_claimAutoreleasedReturnValue(-[NSString dataUsingEncoding:](v20, "dataUsingEncoding:", 4LL, v11, v8));
      v45[0] = kSecClass;
      v45[1] = kSecAttrApplicationTag;
      v46[0] = kSecClassKey;
      v46[1] = v22;
      void v45[2] = kSecAttrAccessGroup;
      v45[3] = kSecReturnRef;
      void v46[2] = @"com.apple.terminusd";
      v46[3] = &__kCFBooleanTrue;
      int v23 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue( +[NSDictionary dictionaryWithObjects:forKeys:count:]( &OBJC_CLASS___NSDictionary,  "dictionaryWithObjects:forKeys:count:",  v46,  v45,  4LL));
      uint64_t result = 0LL;
      uint64_t v24 = SecItemCopyMatching(v23, &result);
      if ((_DWORD)v24 || !result)
      {
        if (result)
        {
          CFRelease(result);
          uint64_t result = 0LL;
        }

        if ((_DWORD)v24 == -25308)
        {
          if (qword_1001DCC28 != -1) {
            dispatch_once(&qword_1001DCC28, &stru_1001B0980);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCC20, 16LL))
          {
            if (qword_1001DCC28 != -1) {
              dispatch_once(&qword_1001DCC28, &stru_1001B0980);
            }
            _NRLogWithArgs( qword_1001DCC20,  16LL,  "%s%.30s:%-4d Failed to read %@ keychain key %@: keychain locked",  "",  "-[NRDKeyManager readKeyfromKeychainWithName:nrUUID:dataProtectionClass:]",  555LL,  String,  v20);
          }
        }

        else if ((_DWORD)v24 == -25300)
        {
          if (qword_1001DCC28 != -1) {
            dispatch_once(&qword_1001DCC28, &stru_1001B0980);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCC20, 16LL))
          {
            if (qword_1001DCC28 != -1) {
              dispatch_once(&qword_1001DCC28, &stru_1001B0980);
            }
            _NRLogWithArgs( qword_1001DCC20,  16LL,  "%s%.30s:%-4d Failed to read %@ keychain key %@: not found",  "",  "-[NRDKeyManager readKeyfromKeychainWithName:nrUUID:dataProtectionClass:]",  553LL,  String,  v20);
          }
        }

        else
        {
          if (qword_1001DCC28 != -1) {
            dispatch_once(&qword_1001DCC28, &stru_1001B0980);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCC20, 17LL))
          {
            if (qword_1001DCC28 != -1) {
              dispatch_once(&qword_1001DCC28, &stru_1001B0980);
            }
            _NRLogWithArgs(qword_1001DCC20, 17LL, "Failed to read %@ keychain key %@: %d", String, v20, v24);
          }
        }
      }

      else
      {
        int v25 = CFGetTypeID(result);
        if (v25 == SecKeyGetTypeID())
        {
          if (qword_1001DCC28 != -1) {
            dispatch_once(&qword_1001DCC28, &stru_1001B0980);
          }
          if (_NRLogIsLevelEnabled(qword_1001DCC20, 0LL))
          {
            if (qword_1001DCC28 != -1) {
              dispatch_once(&qword_1001DCC28, &stru_1001B0980);
            }
            _NRLogWithArgs( qword_1001DCC20,  0LL,  "%s%.30s:%-4d Successfully read %@ keychain key %@",  "",  "-[NRDKeyManager readKeyfromKeychainWithName:nrUUID:dataProtectionClass:]",  571LL,  String,  v20);
          }

          uint64_t v21 = (void *)result;
          goto LABEL_61;
        }

        if (result)
        {
          CFRelease(result);
          uint64_t result = 0LL;
        }

        int v37 = sub_10014387C();
        uint64_t v38 = _NRLogIsLevelEnabled(v37, 17LL);

        if (v38)
        {
          uint64_t v39 = sub_10014387C();
          uint64_t v40 = CFGetTypeID(result);
          int v41 = (__CFString *)CFCopyTypeIDDescription(v40);
          _NRLogWithArgs(v39, 17LL, "Read %@ keychain key %@ with bad class %@", String, v20, v41);
        }
      }

      uint64_t v21 = 0LL;
LABEL_61:

      id v11 = (id)v42[0];
      uint64_t v8 = (id)v42[1];
      goto LABEL_62;
    }

LABEL_79:
                unsigned int v109 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v9 + 32), v17);
                int v110 = _NRLogIsLevelEnabled(v109, 1LL);

                if (v110)
                {
                  id v112 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v9 + 32), v111);
                  id v113 = [(id)v9 copyDescription];
                  _NRLogWithArgs( v112,  1LL,  "%s%.30s:%-4d %@: UrgentLink:sending urgent prelude: %@",  "",  "-[NRLinkBluetooth updateUrgentPipe:]",  2581LL,  v113,  v2);
                }

                goto LABEL_13;
              }

              id v122 = sub_100070554();
              int v123 = _NRLogIsLevelEnabled(v122, 16LL);

              if (v123)
              {
                id v124 = sub_100070554();
                _NRLogWithArgs( v124,  16LL,  "%s%.30s:%-4d ABORTING: well this is absurd & urgent %u",  "",  "-[NRLinkBluetooth updateUrgentPipe:]",  2574,  33);
              }

              uint64_t v7 = (char *)_os_log_pack_size(18LL);
              a1 = (char *)block - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
              int v125 = __error();
              uint64_t v126 = _os_log_pack_fill( a1,  v7,  *v125,  &_mh_execute_header,  "%{public}s well this is absurd & urgent %u");
              *(_DWORD *)uint64_t v126 = 136446466;
              *(void *)(v126 + 4) = "-[NRLinkBluetooth updateUrgentPipe:]";
              *(_WORD *)(v126 + 12) = 1024;
              *(_DWORD *)(v126 + 14) = 33;
            }

            else
            {
              id v103 = sub_100070554();
              int v104 = _NRLogIsLevelEnabled(v103, 16LL);

              id v3 = "strict_malloc";
              if (v104)
              {
                id v105 = sub_100070554();
                _NRLogWithArgs( v105,  16LL,  "%s%.30s:%-4d ABORTING: strict_malloc(%zu) failed",  "",  "strict_malloc",  79,  0x21uLL);
              }

              uint64_t v7 = (char *)_os_log_pack_size(22LL);
              a1 = (char *)block - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v106 = __error();
              uint64_t v107 = _os_log_pack_fill( a1,  v7,  *v106,  &_mh_execute_header,  "%{public}s strict_malloc(%zu) failed");
              *(_DWORD *)uint64_t v107 = 136446466;
              *(void *)(v107 + 4) = "strict_malloc";
              *(_WORD *)(v107 + 12) = 2048;
              *(void *)(v107 + 14) = 33LL;
            }

          [v4 setLinkMTU:1400];
          int v2 = v549;
          if (!-[NSMutableArray count](v549, "count"))
          {
            int v110 = *((id *)a1 + 12);
            id v112 = (void *)_NRCopyLogObjectForNRUUID(v110, v111);
            id v113 = _NRLogIsLevelEnabled(v112, 0LL);

            if (!v113)
            {
LABEL_90:

LABEL_91:
              goto LABEL_92;
            }

            uint64_t v102 = (NSString *)*((id *)a1 + 12);
            uint64_t v71 = (id)_NRCopyLogObjectForNRUUID(v102, v114);
            _NRLogWithArgs( v71,  0LL,  "%s%.30s:%-4d No new policies added for link: %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3861LL,  v4);
            goto LABEL_88;
          }

          objc_opt_self(&OBJC_CLASS___NRDPolicySessionManager);
          if (qword_1001DCB60 == -1) {
            goto LABEL_81;
          }
          goto LABEL_159;
        }

        if ([v4 ikeClassDEstablished]
          && ([v4 hasClassDPolicies] & 1) == 0)
        {
          v545 = (NSString *)sub_10012CD2C(v548, @"61315");
          v544 = (id)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition localAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "localAddress:prefix:"));
          v563[0] = v544;
          id v120 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
          v563[1] = v120;
          uint64_t v121 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v563,  2LL));

          v546 = v64;
          id v122 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v64,  0LL));
          int v123 = [[NEPolicy alloc] initWithOrder:v547 result:v122 conditions:v121];
          id v124 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
          int v125 = *((id *)a1 + 34);
          uint64_t v126 = sub_100120E44((uint64_t)v124, v125, v123);
          uint64_t v127 = (void *)objc_claimAutoreleasedReturnValue(v126);

          uint64_t v128 = [v127 unsignedIntegerValue];
          if (v128)
          {
            -[NSMutableArray addObject:](v549, "addObject:", v127);
          }

          else
          {
            v335 = *((id *)a1 + 12);
            v337 = (void *)_NRCopyLogObjectForNRUUID(v335, v336);
            LODWORD(v543) = _NRLogIsLevelEnabled(v337, 16LL);

            if ((_DWORD)v543)
            {
              v543 = *((id *)a1 + 12);
              int v339 = (void *)_NRCopyLogObjectForNRUUID(v543, v338);
              BOOL v340 = *((id *)a1 + 34);
              _NRLogWithArgs( v339,  16LL,  "%s%.30s:%-4d %@ failed to add localConditionPolicy %@ to session %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3616LL,  v4,  v123,  v340);
            }

            v341 = *((id *)a1 + 12);
            v343 = (void *)_NRCopyLogObjectForNRUUID(v341, v342);
            LODWORD(v543) = _NRLogIsLevelEnabled(v343, 17LL);

            if ((_DWORD)v543)
            {
              uint64_t v344 = *((id *)a1 + 12);
              uint64_t v346 = (void *)_NRCopyLogObjectForNRUUID(v344, v345);
              _NRLogWithArgs(v346, 17LL, "Failed to add localConditionPolicy");
            }

            uint64_t v347 = *((id *)a1 + 34);
            [v4 cancelWithReason:@"Failed to add localConditionPolicy %@ to session %@", v123, v347];
          }

          uint64_t v64 = v546;
          int v2 = v549;
          if (!v128) {
            goto LABEL_90;
          }
          v545 = (NSString *)sub_10012D254(v548, @"61315");
          v544 = (id)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:"));
          v562[0] = v544;
          id v129 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
          v562[1] = v129;
          uint64_t v130 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v562,  2LL));

          id v131 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v546,  0LL));
          int v132 = [[NEPolicy alloc] initWithOrder:v547 result:v131 conditions:v130];
          uint64_t v133 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
          uint64_t v134 = *((id *)a1 + 34);
          uintptr_t v135 = sub_100120E44((uint64_t)v133, v134, v132);
          uint64_t v136 = (void *)objc_claimAutoreleasedReturnValue(v135);

          id v137 = [v136 unsignedIntegerValue];
          if (v137)
          {
            -[NSMutableArray addObject:](v549, "addObject:", v136);
          }

          else
          {
            uint64_t v361 = *((id *)a1 + 12);
            int v363 = (void *)_NRCopyLogObjectForNRUUID(v361, v362);
            LODWORD(v543) = _NRLogIsLevelEnabled(v363, 16LL);

            if ((_DWORD)v543)
            {
              v543 = *((id *)a1 + 12);
              unsigned __int16 v365 = (void *)_NRCopyLogObjectForNRUUID(v543, v364);
              uint64_t v366 = *((id *)a1 + 34);
              _NRLogWithArgs( v365,  16LL,  "%s%.30s:%-4d %@ failed to add remoteConditionPolicy %@ to session %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3630LL,  v4,  v132,  v366);
            }

            v367 = *((id *)a1 + 12);
            __int128 v369 = (void *)_NRCopyLogObjectForNRUUID(v367, v368);
            LODWORD(v543) = _NRLogIsLevelEnabled(v369, 17LL);

            if ((_DWORD)v543)
            {
              __int128 v370 = *((id *)a1 + 12);
              __int128 v372 = (void *)_NRCopyLogObjectForNRUUID(v370, v371);
              _NRLogWithArgs(v372, 17LL, "Failed to add remoteConditionPolicy");
            }

            __int128 v373 = *((id *)a1 + 34);
            [v4 cancelWithReason:@"Failed to add remoteConditionPolicy %@ to session %@", v132, v373];
          }

          uint64_t v64 = v546;
          int v2 = v549;
          if (!v137) {
            goto LABEL_90;
          }
          v545 = (NSString *)sub_10012E41C(v548);
          int v138 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:"));
          v543 = (id)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition ipProtocol:](&OBJC_CLASS___NEPolicyCondition, "ipProtocol:", 58LL));
          v544 = v138;
          v561[0] = v138;
          v561[1] = v543;
          int v139 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
          v561[2] = v139;
          id v140 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v561,  3LL));

          uint64_t v141 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v546,  0LL));
          id v142 = [[NEPolicy alloc] initWithOrder:v547 result:v141 conditions:v140];
          int v143 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
          uint64_t v144 = *((id *)a1 + 34);
          uint64_t v145 = sub_100120E44((uint64_t)v143, v144, v142);
          id v146 = (void *)objc_claimAutoreleasedReturnValue(v145);

          int v147 = [v146 unsignedIntegerValue];
          if (v147)
          {
            -[NSMutableArray addObject:](v549, "addObject:", v146);
          }

          else
          {
            v387 = *((id *)a1 + 12);
            v389 = (void *)_NRCopyLogObjectForNRUUID(v387, v388);
            LODWORD(v542) = _NRLogIsLevelEnabled(v389, 16LL);

            if ((_DWORD)v542)
            {
              v542 = *((id *)a1 + 12);
              v391 = (void *)_NRCopyLogObjectForNRUUID(v542, v390);
              v392 = *((id *)a1 + 34);
              _NRLogWithArgs( v391,  16LL,  "%s%.30s:%-4d %@ failed to add icmpConditionPolicy %@ to session %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3645LL,  v4,  v142,  v392);
            }

            v393 = *((id *)a1 + 12);
            v395 = (void *)_NRCopyLogObjectForNRUUID(v393, v394);
            LODWORD(v542) = _NRLogIsLevelEnabled(v395, 17LL);

            if ((_DWORD)v542)
            {
              v396 = *((id *)a1 + 12);
              v398 = (void *)_NRCopyLogObjectForNRUUID(v396, v397);
              _NRLogWithArgs(v398, 17LL, "Failed to add icmpConditionPolicy");
            }

            v399 = *((id *)a1 + 34);
            [v4 cancelWithReason:@"Failed to add icmpConditionPolicy %@ to session %@", v142, v399];
          }

          uint64_t v64 = v546;
          int v2 = v549;
          if (!v147) {
            goto LABEL_90;
          }
          if (_NRIsAppleInternal(v148))
          {
            v545 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", "18999");
            v544 = sub_10012CD2C(v548, v545);
            v543 = (id)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition localAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "localAddress:prefix:"));
            v560[0] = v543;
            uint64_t v149 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
            v560[1] = v149;
            uint64_t v150 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v560,  2LL));

            int v151 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v546,  0LL));
            v542 = v150;
            int v152 = [[NEPolicy alloc] initWithOrder:v547 result:v151 conditions:v150];
            uint64_t v153 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
            id v154 = *((id *)a1 + 34);
            id v155 = sub_100120E44((uint64_t)v153, v154, v152);
            uint64_t v156 = (void *)objc_claimAutoreleasedReturnValue(v155);

            uint64_t v157 = [v156 unsignedIntegerValue];
            if (v157)
            {
              -[NSMutableArray addObject:](v549, "addObject:", v156);
            }

            else
            {
              v413 = *((id *)a1 + 12);
              v415 = (void *)_NRCopyLogObjectForNRUUID(v413, v414);
              v416 = _NRLogIsLevelEnabled(v415, 16LL);

              if (v416)
              {
                v417 = *((id *)a1 + 12);
                v419 = (void *)_NRCopyLogObjectForNRUUID(v417, v418);
                v420 = *((id *)a1 + 34);
                _NRLogWithArgs( v419,  16LL,  "%s%.30s:%-4d %@ failed to add localConditionPolicyForTest %@ to session %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3667LL,  v4,  v152,  v420);
              }

              v421 = *((id *)a1 + 12);
              v423 = (void *)_NRCopyLogObjectForNRUUID(v421, v422);
              v424 = _NRLogIsLevelEnabled(v423, 17LL);

              if (v424)
              {
                v425 = *((id *)a1 + 12);
                v427 = (void *)_NRCopyLogObjectForNRUUID(v425, v426);
                _NRLogWithArgs(v427, 17LL, "Failed to add localConditionPolicyForTest");
              }

              v428 = *((id *)a1 + 34);
              [v4 cancelWithReason:@"Failed to add localConditionPolicyForTest %@ to session %@", v152, v428];

              int v2 = v549;
            }

            if (!v157) {
              goto LABEL_141;
            }
            v544 = sub_10012D254(v548, v545);
            v543 = (id)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:"));
            v559[0] = v543;
            uint64_t v158 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
            v559[1] = v158;
            id v159 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v559,  2LL));

            uint64_t v160 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v546,  0LL));
            v542 = v159;
            uint64_t v161 = [[NEPolicy alloc] initWithOrder:v547 result:v160 conditions:v159];
            uint64_t v162 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
            int v163 = *((id *)a1 + 34);
            uint64_t v164 = sub_100120E44((uint64_t)v162, v163, v161);
            unsigned int v165 = (void *)objc_claimAutoreleasedReturnValue(v164);

            id v166 = [v165 unsignedIntegerValue];
            if (v166)
            {
              -[NSMutableArray addObject:](v2, "addObject:", v165);
            }

            else
            {
              v445 = *((id *)a1 + 12);
              v447 = (void *)_NRCopyLogObjectForNRUUID(v445, v446);
              v448 = _NRLogIsLevelEnabled(v447, 16LL);

              if (v448)
              {
                v449 = *((id *)a1 + 12);
                v451 = (void *)_NRCopyLogObjectForNRUUID(v449, v450);
                v452 = *((id *)a1 + 34);
                _NRLogWithArgs( v451,  16LL,  "%s%.30s:%-4d %@ failed to add remoteConditionPolicyForTest %@ to session %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3684LL,  v4,  v161,  v452);
              }

              v453 = *((id *)a1 + 12);
              v455 = (void *)_NRCopyLogObjectForNRUUID(v453, v454);
              v456 = _NRLogIsLevelEnabled(v455, 17LL);

              if (v456)
              {
                v457 = *((id *)a1 + 12);
                v459 = (void *)_NRCopyLogObjectForNRUUID(v457, v458);
                _NRLogWithArgs(v459, 17LL, "Failed to add remoteConditionPolicyForTest");
              }

              v460 = *((id *)a1 + 34);
              [v4 cancelWithReason:@"Failed to add remoteConditionPolicyForTest %@ to session %@", v161, v460];

              int v2 = v549;
            }

            if (!v166) {
              goto LABEL_141;
            }
            uint64_t v167 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", "19999");
            uint64_t v168 = sub_10012CD2C(v548, v167);

            v544 = v168;
            v543 = (id)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition localAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "localAddress:prefix:",  v168,  128LL));
            v558[0] = v543;
            uint64_t v169 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
            v558[1] = v169;
            v170 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v558,  2LL));

            id v171 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v546,  0LL));
            v542 = v170;
            uint64_t v172 = [[NEPolicy alloc] initWithOrder:v547 result:v171 conditions:v170];
            uint64_t v173 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
            int v174 = *((id *)a1 + 34);
            uint64_t v175 = sub_100120E44((uint64_t)v173, v174, v172);
            uint64_t v176 = (void *)objc_claimAutoreleasedReturnValue(v175);

            id v177 = [v176 unsignedIntegerValue];
            if (v177)
            {
              -[NSMutableArray addObject:](v2, "addObject:", v176);
            }

            else
            {
              v477 = *((id *)a1 + 12);
              v479 = (void *)_NRCopyLogObjectForNRUUID(v477, v478);
              v480 = _NRLogIsLevelEnabled(v479, 16LL);

              if (v480)
              {
                v481 = *((id *)a1 + 12);
                v483 = (void *)_NRCopyLogObjectForNRUUID(v481, v482);
                v484 = *((id *)a1 + 34);
                _NRLogWithArgs( v483,  16LL,  "%s%.30s:%-4d %@ failed to add localConditionPolicyForTest %@ to session %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3701LL,  v4,  v172,  v484);
              }

              v485 = *((id *)a1 + 12);
              v487 = (void *)_NRCopyLogObjectForNRUUID(v485, v486);
              v488 = _NRLogIsLevelEnabled(v487, 17LL);

              if (v488)
              {
                v489 = *((id *)a1 + 12);
                v491 = (void *)_NRCopyLogObjectForNRUUID(v489, v490);
                _NRLogWithArgs(v491, 17LL, "Failed to add localConditionPolicyForTest");
              }

              v492 = *((id *)a1 + 34);
              [v4 cancelWithReason:@"Failed to add localConditionPolicyForTest %@ to session %@", v172, v492];

              int v2 = v549;
            }

            if (!v177) {
              goto LABEL_141;
            }
            uint64_t v178 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", "19999");
            uint64_t v179 = sub_10012D254(v548, v178);

            v544 = v179;
            v543 = (id)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:",  v179,  128LL));
            v557[0] = v543;
            uint64_t v180 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
            v557[1] = v180;
            int v181 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v557,  2LL));

            int v182 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v546,  0LL));
            v542 = v181;
            uint64_t v183 = [[NEPolicy alloc] initWithOrder:v547 result:v182 conditions:v181];
            uint64_t v184 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
            id v185 = *((id *)a1 + 34);
            uint64_t v186 = sub_100120E44((uint64_t)v184, v185, v183);
            uint64_t v187 = (void *)objc_claimAutoreleasedReturnValue(v186);

            uint64_t v188 = [v187 unsignedIntegerValue];
            if (v188)
            {
              -[NSMutableArray addObject:](v2, "addObject:", v187);
            }

            else
            {
              v509 = *((id *)a1 + 12);
              v511 = (void *)_NRCopyLogObjectForNRUUID(v509, v510);
              v512 = _NRLogIsLevelEnabled(v511, 16LL);

              if (v512)
              {
                v513 = *((id *)a1 + 12);
                v515 = (void *)_NRCopyLogObjectForNRUUID(v513, v514);
                v516 = *((id *)a1 + 34);
                _NRLogWithArgs( v515,  16LL,  "%s%.30s:%-4d %@ failed to add remoteConditionPolicyForTest %@ to session %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3718LL,  v4,  v183,  v516);
              }

              v517 = *((id *)a1 + 12);
              v519 = (void *)_NRCopyLogObjectForNRUUID(v517, v518);
              v520 = _NRLogIsLevelEnabled(v519, 17LL);

              if (v520)
              {
                v521 = *((id *)a1 + 12);
                v523 = (void *)_NRCopyLogObjectForNRUUID(v521, v522);
                _NRLogWithArgs(v523, 17LL, "Failed to add remoteConditionPolicyForTest");
              }

              v524 = *((id *)a1 + 34);
              [v4 cancelWithReason:@"Failed to add remoteConditionPolicyForTest %@ to session %@", v183, v524];

              int v2 = v549;
            }

            uint64_t v64 = v546;
            if (!v188) {
              goto LABEL_90;
            }
          }

          sub_1000DED4C((uint64_t)a1, 0);
          [v4 setHasClassDPolicies:1];
          dispatch_source_t v65 = &APSConnectionOverrideNamedDelegatePort_ptr;
        }

        if (![v4 ikeClassCEstablished]
          || ([v4 hasClassCPolicies] & 1) != 0)
        {
          goto LABEL_79;
        }

        v545 = (NSString *)sub_10012D45C(v548, @"61315");
        v544 = (id)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition localAddress:prefix:](&OBJC_CLASS___NEPolicyCondition, "localAddress:prefix:"));
        v556[0] = v544;
        id v189 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
        v556[1] = v189;
        uint64_t v190 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v556, 2LL));

        v546 = v64;
        v191 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v64,  0LL));
        int v192 = [[NEPolicy alloc] initWithOrder:v547 result:v191 conditions:v190];
        uint64_t v193 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
        v194 = *((id *)a1 + 34);
        id v195 = sub_100120E44((uint64_t)v193, v194, v192);
        int v196 = (void *)objc_claimAutoreleasedReturnValue(v195);

        uint64_t v197 = [v196 unsignedIntegerValue];
        if (v197)
        {
          -[NSMutableArray addObject:](v549, "addObject:", v196);
        }

        else
        {
          v348 = *((id *)a1 + 12);
          uint64_t v350 = (void *)_NRCopyLogObjectForNRUUID(v348, v349);
          LODWORD(v543) = _NRLogIsLevelEnabled(v350, 16LL);

          if ((_DWORD)v543)
          {
            v543 = *((id *)a1 + 12);
            id v352 = (void *)_NRCopyLogObjectForNRUUID(v543, v351);
            v353 = *((id *)a1 + 34);
            _NRLogWithArgs( v352,  16LL,  "%s%.30s:%-4d %@ failed to add localConditionPolicy %@ to session %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3739LL,  v4,  v192,  v353);
          }

          uint64_t v354 = *((id *)a1 + 12);
          uint64_t v356 = (void *)_NRCopyLogObjectForNRUUID(v354, v355);
          LODWORD(v543) = _NRLogIsLevelEnabled(v356, 17LL);

          if ((_DWORD)v543)
          {
            uint64_t v357 = *((id *)a1 + 12);
            uint64_t v359 = (void *)_NRCopyLogObjectForNRUUID(v357, v358);
            _NRLogWithArgs(v359, 17LL, "Failed to add localConditionPolicy");
          }

          uint64_t v360 = *((id *)a1 + 34);
          [v4 cancelWithReason:@"Failed to add localConditionPolicy %@ to session %@", v192, v360];
        }

        uint64_t v64 = v546;
        int v2 = v549;
        if (!v197) {
          goto LABEL_90;
        }
        v545 = (NSString *)sub_10012D610(v548, @"61315");
        v544 = (id)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:"));
        v555[0] = v544;
        uint64_t v198 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
        v555[1] = v198;
        id v199 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v555, 2LL));

        int v200 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v546,  0LL));
        uint64_t v201 = [[NEPolicy alloc] initWithOrder:v547 result:v200 conditions:v199];
        int v202 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
        id v203 = *((id *)a1 + 34);
        uint64_t v204 = sub_100120E44((uint64_t)v202, v203, v201);
        id v205 = (void *)objc_claimAutoreleasedReturnValue(v204);

        uint64_t v206 = [v205 unsignedIntegerValue];
        if (v206)
        {
          -[NSMutableArray addObject:](v549, "addObject:", v205);
        }

        else
        {
          __int128 v374 = *((id *)a1 + 12);
          __int128 v376 = (void *)_NRCopyLogObjectForNRUUID(v374, v375);
          LODWORD(v543) = _NRLogIsLevelEnabled(v376, 16LL);

          if ((_DWORD)v543)
          {
            v543 = *((id *)a1 + 12);
            __int128 v378 = (void *)_NRCopyLogObjectForNRUUID(v543, v377);
            __int128 v379 = *((id *)a1 + 34);
            _NRLogWithArgs( v378,  16LL,  "%s%.30s:%-4d %@ failed to add remoteConditionPolicy %@ to session %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3753LL,  v4,  v201,  v379);
          }

          __int128 v380 = *((id *)a1 + 12);
          __int128 v382 = (void *)_NRCopyLogObjectForNRUUID(v380, v381);
          LODWORD(v543) = _NRLogIsLevelEnabled(v382, 17LL);

          if ((_DWORD)v543)
          {
            __int128 v383 = *((id *)a1 + 12);
            uint64_t v385 = (void *)_NRCopyLogObjectForNRUUID(v383, v384);
            _NRLogWithArgs(v385, 17LL, "Failed to add remoteConditionPolicy");
          }

          v386 = *((id *)a1 + 34);
          [v4 cancelWithReason:@"Failed to add remoteConditionPolicy %@ to session %@", v201, v386];
        }

        uint64_t v64 = v546;
        int v2 = v549;
        if (!v206) {
          goto LABEL_90;
        }
        v545 = (NSString *)sub_10012E45C(v548);
        id v207 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:"));
        v543 = (id)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition ipProtocol:](&OBJC_CLASS___NEPolicyCondition, "ipProtocol:", 58LL));
        v544 = v207;
        v554[0] = v207;
        v554[1] = v543;
        int v208 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
        v554[2] = v208;
        int v209 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v554, 3LL));

        uint64_t v210 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v546,  0LL));
        id v211 = [[NEPolicy alloc] initWithOrder:v547 result:v210 conditions:v209];
        id v212 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
        uint64_t v213 = *((id *)a1 + 34);
        uint64_t v214 = sub_100120E44((uint64_t)v212, v213, v211);
        v215 = (void *)objc_claimAutoreleasedReturnValue(v214);

        int v216 = [v215 unsignedIntegerValue];
        if (v216)
        {
          -[NSMutableArray addObject:](v549, "addObject:", v215);
        }

        else
        {
          v400 = *((id *)a1 + 12);
          v402 = (void *)_NRCopyLogObjectForNRUUID(v400, v401);
          LODWORD(v542) = _NRLogIsLevelEnabled(v402, 16LL);

          if ((_DWORD)v542)
          {
            v542 = *((id *)a1 + 12);
            v404 = (void *)_NRCopyLogObjectForNRUUID(v542, v403);
            v405 = *((id *)a1 + 34);
            _NRLogWithArgs( v404,  16LL,  "%s%.30s:%-4d %@ failed to add icmpConditionPolicy %@ to session %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3768LL,  v4,  v211,  v405);
          }

          v406 = *((id *)a1 + 12);
          v408 = (void *)_NRCopyLogObjectForNRUUID(v406, v407);
          LODWORD(v542) = _NRLogIsLevelEnabled(v408, 17LL);

          if ((_DWORD)v542)
          {
            v409 = *((id *)a1 + 12);
            v411 = (void *)_NRCopyLogObjectForNRUUID(v409, v410);
            _NRLogWithArgs(v411, 17LL, "Failed to add icmpConditionPolicy");
          }

          v412 = *((id *)a1 + 34);
          [v4 cancelWithReason:@"Failed to add icmpConditionPolicy %@ to session %@", v211, v412];
        }

        uint64_t v64 = v546;
        int v2 = v549;
        if (!v216) {
          goto LABEL_90;
        }
        if (!_NRIsAppleInternal(v217))
        {
LABEL_140:
          [v4 setHasClassCPolicies:1];
          dispatch_source_t v65 = &APSConnectionOverrideNamedDelegatePort_ptr;
          goto LABEL_79;
        }

        v545 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", "18999");
        v544 = (id)sub_10012D45C(v548, v545);
        v543 = (id)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition localAddress:prefix:](&OBJC_CLASS___NEPolicyCondition, "localAddress:prefix:"));
        v553[0] = v543;
        int v218 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
        v553[1] = v218;
        id v219 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](&OBJC_CLASS___NSArray, "arrayWithObjects:count:", v553, 2LL));

        uint64_t v220 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v546,  0LL));
        v542 = v219;
        id v221 = [[NEPolicy alloc] initWithOrder:v547 result:v220 conditions:v219];
        v222 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
        int v223 = *((id *)a1 + 34);
        uint64_t v224 = sub_100120E44((uint64_t)v222, v223, v221);
        uint64_t v225 = (void *)objc_claimAutoreleasedReturnValue(v224);

        id v226 = [v225 unsignedIntegerValue];
        if (v226)
        {
          -[NSMutableArray addObject:](v549, "addObject:", v225);
        }

        else
        {
          v429 = *((id *)a1 + 12);
          v431 = (void *)_NRCopyLogObjectForNRUUID(v429, v430);
          v432 = _NRLogIsLevelEnabled(v431, 16LL);

          if (v432)
          {
            v433 = *((id *)a1 + 12);
            v435 = (void *)_NRCopyLogObjectForNRUUID(v433, v434);
            v436 = *((id *)a1 + 34);
            _NRLogWithArgs( v435,  16LL,  "%s%.30s:%-4d %@ failed to add localConditionPolicyForTest %@ to session %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3790LL,  v4,  v221,  v436);
          }

          v437 = *((id *)a1 + 12);
          v439 = (void *)_NRCopyLogObjectForNRUUID(v437, v438);
          v440 = _NRLogIsLevelEnabled(v439, 17LL);

          if (v440)
          {
            v441 = *((id *)a1 + 12);
            v443 = (void *)_NRCopyLogObjectForNRUUID(v441, v442);
            _NRLogWithArgs(v443, 17LL, "Failed to add localConditionPolicyForTest");
          }

          v444 = *((id *)a1 + 34);
          [v4 cancelWithReason:@"Failed to add localConditionPolicyForTest %@ to session %@", v221, v444];

          int v2 = v549;
        }

        if (v226)
        {
          v544 = sub_10012D610(v548, v545);
          v543 = (id)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:"));
          v552[0] = v543;
          uint64_t v227 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
          v552[1] = v227;
          int v228 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v552,  2LL));

          uint64_t v229 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v546,  0LL));
          v542 = v228;
          int v230 = [[NEPolicy alloc] initWithOrder:v547 result:v229 conditions:v228];
          uint64_t v231 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
          int v232 = *((id *)a1 + 34);
          id v233 = sub_100120E44((uint64_t)v231, v232, v230);
          uint64_t v234 = (void *)objc_claimAutoreleasedReturnValue(v233);

          id v235 = [v234 unsignedIntegerValue];
          if (v235)
          {
            -[NSMutableArray addObject:](v2, "addObject:", v234);
          }

          else
          {
            v461 = *((id *)a1 + 12);
            v463 = (void *)_NRCopyLogObjectForNRUUID(v461, v462);
            v464 = _NRLogIsLevelEnabled(v463, 16LL);

            if (v464)
            {
              v465 = *((id *)a1 + 12);
              v467 = (void *)_NRCopyLogObjectForNRUUID(v465, v466);
              v468 = *((id *)a1 + 34);
              _NRLogWithArgs( v467,  16LL,  "%s%.30s:%-4d %@ failed to add remoteConditionPolicyForTest %@ to session %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3807LL,  v4,  v230,  v468);
            }

            v469 = *((id *)a1 + 12);
            v471 = (void *)_NRCopyLogObjectForNRUUID(v469, v470);
            v472 = _NRLogIsLevelEnabled(v471, 17LL);

            if (v472)
            {
              v473 = *((id *)a1 + 12);
              v475 = (void *)_NRCopyLogObjectForNRUUID(v473, v474);
              _NRLogWithArgs(v475, 17LL, "Failed to add remoteConditionPolicyForTest");
            }

            v476 = *((id *)a1 + 34);
            [v4 cancelWithReason:@"Failed to add remoteConditionPolicyForTest %@ to session %@", v230, v476];

            int v2 = v549;
          }

          if (v235)
          {
            id v236 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", "19999");
            int v237 = (void *)sub_10012D45C(v548, v236);

            v544 = v237;
            v543 = (id)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition localAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "localAddress:prefix:",  v237,  128LL));
            v551[0] = v543;
            id v238 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
            v551[1] = v238;
            id v239 = (void *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v551,  2LL));

            int v240 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v546,  0LL));
            v542 = v239;
            id v241 = [[NEPolicy alloc] initWithOrder:v547 result:v240 conditions:v239];
            id v242 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
            int v243 = *((id *)a1 + 34);
            id v244 = sub_100120E44((uint64_t)v242, v243, v241);
            id v245 = (void *)objc_claimAutoreleasedReturnValue(v244);

            int v246 = [v245 unsignedIntegerValue];
            if (v246)
            {
              -[NSMutableArray addObject:](v2, "addObject:", v245);
            }

            else
            {
              v493 = *((id *)a1 + 12);
              v495 = (void *)_NRCopyLogObjectForNRUUID(v493, v494);
              v496 = _NRLogIsLevelEnabled(v495, 16LL);

              if (v496)
              {
                v497 = *((id *)a1 + 12);
                v499 = (void *)_NRCopyLogObjectForNRUUID(v497, v498);
                v500 = *((id *)a1 + 34);
                _NRLogWithArgs( v499,  16LL,  "%s%.30s:%-4d %@ failed to add localConditionPolicyForTest %@ to session %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3824LL,  v4,  v241,  v500);
              }

              v501 = *((id *)a1 + 12);
              v503 = (void *)_NRCopyLogObjectForNRUUID(v501, v502);
              v504 = _NRLogIsLevelEnabled(v503, 17LL);

              if (v504)
              {
                v505 = *((id *)a1 + 12);
                v507 = (void *)_NRCopyLogObjectForNRUUID(v505, v506);
                _NRLogWithArgs(v507, 17LL, "Failed to add localConditionPolicyForTest");
              }

              v508 = *((id *)a1 + 34);
              [v4 cancelWithReason:@"Failed to add localConditionPolicyForTest %@ to session %@", v241, v508];

              int v2 = v549;
            }

            if (v246)
            {
              id v247 = -[NSString initWithUTF8String:](objc_alloc(&OBJC_CLASS___NSString), "initWithUTF8String:", "19999");
              uint64_t v248 = sub_10012D610(v548, v247);

              v544 = v248;
              v543 = (id)objc_claimAutoreleasedReturnValue( +[NEPolicyCondition remoteAddress:prefix:]( &OBJC_CLASS___NEPolicyCondition,  "remoteAddress:prefix:",  v248,  128LL));
              v550[0] = v543;
              uint64_t v249 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](&OBJC_CLASS___NEPolicyCondition, "allInterfaces"));
              v550[1] = v249;
              id v250 = (char *)objc_claimAutoreleasedReturnValue( +[NSArray arrayWithObjects:count:]( &OBJC_CLASS___NSArray,  "arrayWithObjects:count:",  v550,  2LL));

              uint64_t v251 = (void *)objc_claimAutoreleasedReturnValue( +[NEPolicyResult tunnelIPToInterfaceName:secondaryResultType:]( &OBJC_CLASS___NEPolicyResult,  "tunnelIPToInterfaceName:secondaryResultType:",  v546,  0LL));
              id v252 = objc_alloc(&OBJC_CLASS___NEPolicy);
              uint64_t v253 = v547;
              v547 = v250;
              id v254 = [v252 initWithOrder:v253 result:v251 conditions:v250];
              uint64_t v255 = sub_100120A64((uint64_t)&OBJC_CLASS___NRDPolicySessionManager);
              id v256 = *((id *)a1 + 34);
              uint64_t v257 = sub_100120E44((uint64_t)v255, v256, v254);
              uint64_t v258 = (void *)objc_claimAutoreleasedReturnValue(v257);

              uint64_t v259 = [v258 unsignedIntegerValue];
              if (v259)
              {
                -[NSMutableArray addObject:](v2, "addObject:", v258);
              }

              else
              {
                v525 = *((id *)a1 + 12);
                v527 = (void *)_NRCopyLogObjectForNRUUID(v525, v526);
                v528 = _NRLogIsLevelEnabled(v527, 16LL);

                if (v528)
                {
                  v529 = *((id *)a1 + 12);
                  v531 = (void *)_NRCopyLogObjectForNRUUID(v529, v530);
                  v532 = *((id *)a1 + 34);
                  _NRLogWithArgs( v531,  16LL,  "%s%.30s:%-4d %@ failed to add remoteConditionPolicyForTest %@ to session %@",  "",  "-[NRDDeviceConductor setIPTunnelPolicyForLink:]",  3841LL,  v4,  v254,  v532);
                }

                v533 = *((id *)a1 + 12);
                v535 = (void *)_NRCopyLogObjectForNRUUID(v533, v534);
                v536 = _NRLogIsLevelEnabled(v535, 17LL);

                if (v536)
                {
                  v537 = *((id *)a1 + 12);
                  v539 = (void *)_NRCopyLogObjectForNRUUID(v537, v538);
                  _NRLogWithArgs(v539, 17LL, "Failed to add remoteConditionPolicyForTest");
                }

                v540 = *((id *)a1 + 34);
                [v4 cancelWithReason:@"Failed to add remoteConditionPolicyForTest %@ to session %@", v254, v540];

                int v2 = v549;
              }

              uint64_t v64 = v546;
              if (!v259) {
                goto LABEL_90;
              }
              goto LABEL_140;
            }
          }
        }

  return a1;
}

LABEL_78:
            id v108 = sub_100070554();
            _NRLogAbortWithPack(v108, a1);
            goto LABEL_79;
          }

          id v97 = sub_100070554();
          int v98 = _NRLogIsLevelEnabled(v97, 16LL);

          id v3 = "strict_calloc";
          if (v98)
          {
            id v99 = sub_100070554();
            _NRLogWithArgs( v99,  16LL,  "%s%.30s:%-4d ABORTING: strict_calloc(%zu, %zu) failed",  "",  "strict_calloc",  108,  1uLL,  v9);
          }

          goto LABEL_73;
        }
      }

      id v89 = sub_100070554();
      int v90 = _NRLogIsLevelEnabled(v89, 16LL);

      if (v90)
      {
        id v91 = sub_100070554();
        _NRLogWithArgs(v91, 16LL, "%s%.30s:%-4d ABORTING: strict_calloc called with size 0", "", "strict_calloc", 100);
      }

      uint64_t v7 = (char *)_os_log_pack_size(12LL);
      a1 = (char *)block - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      uint64_t v92 = __error();
      uint64_t v93 = _os_log_pack_fill( a1,  v7,  *v92,  &_mh_execute_header,  "%{public}s strict_calloc called with size 0");
      *(_DWORD *)uint64_t v93 = 136446210;
      *(void *)(v93 + 4) = "strict_calloc";
      goto LABEL_78;
    }

    int v2 = (NSData *)block;
    uint64_t v9 = 8 * v71;
    __memptr[0] = 0LL;
    if (!posix_memalign(__memptr, 8uLL, 8 * v71) && __memptr[0])
    {
      *(void **)(a1 + 1943) = __memptr[0];
      goto LABEL_53;
    }

    id v118 = sub_100070554();
    int v119 = _NRLogIsLevelEnabled(v118, 16LL);

    if (v119)
    {
      id v120 = sub_100070554();
      _NRLogWithArgs( v120,  16LL,  "%s%.30s:%-4d ABORTING: posix_memalign(..., %zu, %zu) failed",  "",  "strict_memalign",  183,  8uLL,  v9);
    }

    uint64_t v7 = (char *)_os_log_pack_size(32LL);
    a1 = (char *)block - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    uint64_t v121 = __error();
    uint64_t v101 = _os_log_pack_fill( a1,  v7,  *v121,  &_mh_execute_header,  "%{public}s posix_memalign(..., %zu, %zu) failed");
    *(_DWORD *)uint64_t v101 = 136446722;
    *(void *)(v101 + 4) = "strict_memalign";
LABEL_87:
    *(_WORD *)(v101 + 12) = 2048;
    uint64_t v102 = 8LL;
    goto LABEL_74;
  }

  uint64_t v84 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v67);
  int v85 = _NRLogIsLevelEnabled(v84, 17LL);

  if (v85)
  {
    uint64_t v87 = (void *)_NRCopyLogObjectForNRUUID(*((void *)a1 + 4), v86);
    id v88 = [a1 copyDescription];
    _NRLogWithArgs(v87, 17LL, "%@: _dUrgentLinkOutputSource is NULL", v88);
  }

LABEL_29:
}

      uint64_t v67 = 0;
      BOOL v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      int v72 = v649;
      int v73 = v653;
      goto LABEL_98;
    }

    if (v51)
    {
      uint64_t v64 = v647;
    }

    int v68 = v62;
    *((void *)&v675 + 2 * v63) = v657 + (unsigned __int16)v64;
    if ((unsigned __int16)v658 == (unsigned __int16)v64)
    {
      v479 = sub_100070554();
      v480 = _NRLogIsLevelEnabled(v479, 16LL);

      if (v480)
      {
        v481 = sub_100070554();
        _NRLogWithArgs( v481,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: clisIOVecLen > 0; urgentLinkInputBufferLength=%u curLinkInputSlotPart"
          "ialBytesAlreadyRead=%u",
          "",
          "NRLinkLinkToNexusLoopUrgent",
          4612,
          v66,
          v65);
      }

      v482 = _os_log_pack_size(24LL);
      v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      v483 = __error();
      v484 = _os_log_pack_fill( v399,  v482,  *v483,  &_mh_execute_header,  "%{public}s Assertion Failed: clisIOVecLen > 0; urgentLinkInputBufferLength=%u curLinkInputSlotPartialBytesAlreadyRead=%u");
      *(_DWORD *)v484 = 136446722;
      *(void *)(v484 + 4) = "NRLinkLinkToNexusLoopUrgent";
      *(_WORD *)(v484 + 12) = 1024;
      *(_DWORD *)(v484 + 14) = v66;
      *(_WORD *)(v484 + 1_Block_object_dispose(va, 8) = 1024;
      *(_DWORD *)(v484 + 20) = v65;
      goto LABEL_485;
    }

    int v69 = (unint64_t)(&v675 + v63);
    *(_DWORD *)(v69 + _Block_object_dispose(va, 8) = v47 - v65;
    int v62 = v62 + v47 - v65;
    *(void *)(v3 + 1887) = v59 | 0x2000;
    uint64_t v70 = v63 + 1;
    else {
      uint64_t v71 = v51;
    }
    if ((v71 & 1) == 0)
    {
      int v72 = v649;
      if (DWORD2(v675) >= 3)
      {
        uint64_t v74 = *(unsigned __int16 *)(v675 + 1);
        goto LABEL_91;
      }

      if (DWORD2(v675) == 2)
      {
        int v76 = *(unsigned __int8 *)(v675 + 1);
        uint64_t v77 = *(unsigned __int8 *)v676;
        goto LABEL_92;
      }

      if (DWORD2(v675) == 1)
      {
        if (DWORD2(v676) < 2)
        {
          v628 = sub_100070554();
          v629 = _NRLogIsLevelEnabled(v628, 16LL);

          if (v629)
          {
            v630 = sub_100070554();
            v631 = (void *)createIOVecString(&v675, (v63 + 1));
            _NRLogWithArgs( v630,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 2; %@",
              "",
              "nrReadTLVLenHBOFromIOVec",
              274LL,
              v631);
          }

          v632 = _os_log_pack_size(22LL);
          v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          v633 = *__error();
          v589 = _os_log_pack_fill( v399,  v632,  v633,  &_mh_execute_header,  "%{public}s Assertion Failed: numIOVecs > 2; %@");
        }

        else
        {
          if (v643 > v645)
          {
            uint64_t v74 = *(unsigned __int16 *)v676;
LABEL_91:
            int v76 = v74;
            uint64_t v77 = v74 >> 8;
LABEL_92:
            id v78 = bswap32(v76 | (v77 << 8));
            int v49 = BYTE2(v78);
            int v73 = HIBYTE(v78);
LABEL_93:
            int v79 = (v49 | ((unint64_t)v73 << 8)) + 5;
            if (v79 >= v62)
            {
              dispatch_source_t v59 = *(void *)(v3 + 1887) | 0x8000LL;
              *(void *)(v3 + 1887) = v59;
              uint64_t v67 = 1;
              uint64_t v64 = v658;
              int v63 = (v63 + 1);
            }

            else
            {
              uint64_t v80 = (_DWORD *)(v69 | 8);
              uint64_t v81 = v3;
              id v3 = (v62 - v79);
              dispatch_source_t v59 = *(void *)(v81 + 1887) | 0x4000LL;
              *(void *)(v81 + 1887) = v59;
              int v82 = *v80 == (_DWORD)v3;
              *v80 -= v3;
              if (v82)
              {
                v569 = v68 + v47 - v65;
                v570 = sub_100070554();
                v571 = _NRLogIsLevelEnabled(v570, 16LL);

                if (v571)
                {
                  v572 = sub_100070554();
                  v573 = (void *)createIOVecString(&v675, (v63 + 1));
                  _NRLogWithArgs( v572,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[iovecIndex - 1].len > 0; Shrunk ioVecs[%u] down by %"
                    "u to 0 - %@ ioVecContentLen=%u alreadyRead=%u",
                    "",
                    "NRLinkLinkToNexusLoopUrgent",
                    4636LL,
                    v63,
                    v3,
                    v573,
                    v569,
                    v66);
                }

                v574 = _os_log_pack_size(46LL);
                v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                v575 = __error();
                v576 = _os_log_pack_fill( v399,  v574,  *v575,  &_mh_execute_header,  "%{public}s Assertion Failed: ioVecs[iovecIndex - 1].len > 0; Shrunk ioVecs[%u] down by %u to 0 "
                         "- %@ ioVecContentLen=%u alreadyRead=%u");
                v577 = createIOVecString(&v675, (v63 + 1));
                sub_10008BB8C(v576, (uint64_t)"NRLinkLinkToNexusLoopUrgent", v63, v3, v577, v569, v66);
                goto LABEL_485;
              }

              uint64_t v64 = (v658 - v3);
              uint64_t v67 = 1;
              int v63 = (v63 + 1);
              int v62 = (v49 | ((unint64_t)v73 << 8)) + 5;
              id v3 = v648;
            }

            BOOL v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
LABEL_98:
            v656 = v62;
            if (v72 - 100 < 6 || v72 - 2 < 4)
            {
              uint64_t v83 = 2000;
              goto LABEL_101;
            }

            if (v72 == 1)
            {
              uint64_t v83 = 255;
LABEL_101:
              uint64_t v84 = v49 | ((_DWORD)v73 << 8);
              if (v84 > v83)
              {
                uint64_t v8 = (void *)((uint64_t (*)(void))createStringFromNRTLVType)();
                uint64_t v9 = (id)createIOVecStringWithContents(&v675, v63);
                sub_1000749CC( (void *)v3,  @"Received invalid TLV len %u for %@ (max=%u) %@",  v379,  v380,  v381,  v382,  v383,  v384,  v84);
                goto LABEL_461;
              }
            }

            v647 = v64;
            int v85 = v63;
            if ((v49 | ((unint64_t)v73 << 8)) + 5 > v656)
            {
              v653 = v73;
              v654 = v49;
              v651 = v63;
              LODWORD(v75) = 1;
              uint64_t v20 = v655;
              goto LABEL_104;
            }

            int v95 = v652;
            id v96 = v652;
            uint64_t v20 = v655;
LABEL_109:
            id v97 = v95;
            uint64_t v17 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            goto LABEL_186;
          }

          v590 = sub_100070554();
          v591 = _NRLogIsLevelEnabled(v590, 16LL);

          if (v591)
          {
            v592 = sub_100070554();
            v593 = (void *)createIOVecString(&v675, (v63 + 1));
            _NRLogWithArgs( v592,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 1; %@",
              "",
              "nrReadTLVLenHBOFromIOVec",
              271LL,
              v593);
          }

          v594 = _os_log_pack_size(22LL);
          v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          v595 = *__error();
          v589 = _os_log_pack_fill( v399,  v594,  v595,  &_mh_execute_header,  "%{public}s Assertion Failed: numIOVecs > 1; %@");
        }
      }

      else
      {
        v583 = sub_100070554();
        v584 = _NRLogIsLevelEnabled(v583, 16LL);

        if (v584)
        {
          v585 = sub_100070554();
          v586 = (void *)createIOVecString(&v675, (v63 + 1));
          _NRLogWithArgs( v585,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[0].len == 1; %@",
            "",
            "nrReadTLVLenHBOFromIOVec",
            269LL,
            v586);
        }

        v587 = _os_log_pack_size(22LL);
        v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        v588 = *__error();
        v589 = _os_log_pack_fill( v399,  v587,  v588,  &_mh_execute_header,  "%{public}s Assertion Failed: ioVecs[0].len == 1; %@");
      }

      v503 = v589;
      v504 = (v63 + 1);
      goto LABEL_533;
    }

    if (v51)
    {
      int v72 = v649;
      int v73 = v653;
      goto LABEL_93;
    }

    v654 = v49;
    v656 = v68 + v47 - v65;
    *(void *)(v3 + 1887) = v59 | 0xA000;
    v647 = v658;
LABEL_83:
    BOOL v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
    LODWORD(v75) = 0;
    v651 = v70;
    LODWORD(v63) = v70;
LABEL_104:
    uint64_t v86 = v652;
    uint64_t v87 = os_channel_get_next_slot(*(void *)(v3 + v10[280]), v652, &v659);
    if (v87)
    {
      id v88 = v87;
      id v89 = os_channel_slot_get_packet(*(void *)(v3 + v10[280]), v87);
      int v90 = v3;
      id v3 = os_packet_get_next_buflet(v89, 0LL);
      id v91 = os_buflet_get_object_address();
      uint64_t v92 = os_buflet_get_data_offset(v3);
      uint64_t v93 = os_buflet_get_data_length(v3);
      if (WORD1(v93))
      {
LABEL_469:
        if (qword_1001DC840 != -1) {
          dispatch_once(&qword_1001DC840, &stru_1001AEE08);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC838, 16LL))
        {
          if (qword_1001DC840 != -1) {
            dispatch_once(&qword_1001DC840, &stru_1001AEE08);
          }
          _NRLogWithArgs( qword_1001DC838,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: inputBufferLength <= 65535",  "",  "NRLinkLinkToNexusLoopUrgent",  4677);
        }

            BOOL v10 = 0LL;
LABEL_79:

            close(v5);
            return v10;
          }

          int v25 = sub_100070554();
          int IsLevelEnabled = _NRLogIsLevelEnabled(v25, 16LL);

          p_class_meths = (__objc2_meth_list **)"_strict_strlcpy";
          if (IsLevelEnabled)
          {
            uint64_t v27 = sub_100070554();
            _NRLogWithArgs( v27,  16LL,  "%s%.30s:%-4d ABORTING: strict_strlcpy called with NULL src",  "",  "_strict_strlcpy",  240);
          }

          uint64_t v5 = _os_log_pack_size(12LL);
          uint64_t v7 = &v31 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          id v28 = __error();
          uint64_t v29 = _os_log_pack_fill( v7,  v5,  *v28,  &_mh_execute_header,  "%{public}s strict_strlcpy called with NULL src");
          *(_DWORD *)uint64_t v29 = 136446210;
          *(void *)(v29 + 4) = "_strict_strlcpy";
        }

        else
        {
          uint64_t v20 = sub_100070554();
          uint64_t v21 = _NRLogIsLevelEnabled(v20, 16LL);

          if (v21)
          {
            uint64_t v22 = sub_100070554();
            _NRLogWithArgs( v22,  16LL,  "%s%.30s:%-4d ABORTING: strict_strlcpy called with NULL src",  "",  "_strict_strlcpy",  240);
          }

          uint64_t v5 = _os_log_pack_size(12LL);
          uint64_t v7 = &v31 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          int v23 = __error();
          uint64_t v24 = _os_log_pack_fill( v7,  v5,  *v23,  &_mh_execute_header,  "%{public}s strict_strlcpy called with NULL src");
          *(_DWORD *)uint64_t v24 = 136446210;
          *(void *)(v24 + 4) = "_strict_strlcpy";
        }

        uint64_t v30 = sub_100070554();
        _NRLogAbortWithPack(v30, v7);
      }

      else
      {
        p_class_meths = &OBJC_PROTOCOL___NRBTLinkPreferencesAgentDelegate.class_meths;
        if (qword_1001DC840 == -1) {
          goto LABEL_58;
        }
      }

      dispatch_once(&qword_1001DC840, &stru_1001AEE08);
LABEL_58:
      if (_NRLogIsLevelEnabled(qword_1001DC838, 17LL))
      {
        if (p_class_meths[264] != (__objc2_meth_list *)-1LL) {
          dispatch_once(&qword_1001DC840, &stru_1001AEE08);
        }
        _NRLogWithArgs(qword_1001DC838, 17LL, "Failed to copy virtual interface name");
      }

      goto LABEL_78;
    }

    __int128 v16 = *__error();
    if (strerror_r(v16, __strerrbuf, 0x80uLL)) {
      __strerrbuf[0] = 0;
    }
    if (qword_1001DC840 != -1) {
      dispatch_once(&qword_1001DC840, &stru_1001AEE08);
    }
    if (_NRLogIsLevelEnabled(qword_1001DC838, 17LL))
    {
      if (qword_1001DC840 != -1) {
        dispatch_once(&qword_1001DC840, &stru_1001AEE08);
      }
      _NRLogWithArgs( qword_1001DC838,  17LL,  "Failed to create socket for setting QoS marking flags: [%d] %s",  v16,  __strerrbuf);
    }

    return 0LL;
  }

  else
  {
    char v12 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v3);
    BOOL v10 = _NRLogIsLevelEnabled(v12, 17LL);

    if ((_DWORD)v10)
    {
      uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v13);
      int v15 = [a1 copyDescription];
      _NRLogWithArgs(v14, 17LL, "%@: No virtualInterface to set QoS marking mode enabled", v15);

      return 0LL;
    }
  }

  return v10;
}

              if (self->_pendingPreferWiFiRequest || self->_preferWiFiRequest || self->_bringUpWiFiImmediately)
              {
                int v76 = sub_1000D4CD4((uint64_t)self);
                uint64_t v77 = (void *)objc_claimAutoreleasedReturnValue(v76);
                id v78 = sub_100140B30((uint64_t)v77, self->_nrUUID);
                int v79 = (void *)objc_claimAutoreleasedReturnValue(v78);

                if (v79)
                {
                  sub_1000D8670((uint64_t)self);
                }

                else
                {
                  uint64_t v81 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v80);
                  int v82 = _NRLogIsLevelEnabled(v81, 1LL);

                  if (v82)
                  {
                    uint64_t v84 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v83);
                    _NRLogWithArgs( v84,  1LL,  "%s%.30s:%-4d Enable WiFi without peer address. Ignoring availability",  "",  "-[NRDDeviceConductor linkIsAvailable:]",  5629);
                  }
                }
              }

              else
              {
                int v85 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v55);
                uint64_t v86 = _NRLogIsLevelEnabled(v85, 1LL);

                if (!v86) {
                  goto LABEL_43;
                }
                int v79 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v87);
                _NRLogWithArgs( v79,  1LL,  "%s%.30s:%-4d Neither do we have a prefer Wi-Fi request, nor do we need to bring up Wi-Fi immediately. Ignoring availability",  "",  "-[NRDDeviceConductor linkIsAvailable:]",  5623);
              }
            }

            else
            {
              int v49 = (void *)_NRCopyLogObjectForNRUUID(self->_nrUUID, v41);
              uint64_t v50 = _NRLogIsLevelEnabled(v49, 17LL);

              if (v50)
              {
                uint64_t v51 = self->_nrUUID;
                uint64_t v53 = (void *)_NRCopyLogObjectForNRUUID(v51, v52);
                _NRLogWithArgs(v53, 17LL, "unsupported link subtype %@", v35);

                goto LABEL_59;
              }
            }

    a1 = 0LL;
  }

    dispatch_once(&qword_1001DCBD8, &stru_1001B06D8);
    goto LABEL_45;
  }

  if (!v8[13])
  {
    [v8 setHasConfirmedClassCKeys:1];
    if (!*((_BYTE *)v9 + 15)) {
      goto LABEL_15;
    }
    goto LABEL_11;
  }

void sub_100081D6C(uint64_t a1, uint64_t a2)
{
  id v3 = *(dispatch_source_s **)(a1 + 1143);
  if (v3)
  {
    if (*(_BYTE *)(a1 + 227))
    {
      *(_BYTE *)(a1 + 227) = 0;
      ++*(void *)(a1 + 1159);
      if (gNRPacketLoggingEnabled)
      {
        id v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
        int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 1LL);

        if (IsLevelEnabled)
        {
          uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v13);
          id v15 = [(id)a1 copyDescription];
          _NRLogWithArgs( v14,  1LL,  "%s%.30s:%-4d %@: source-resume: UrgentLinkInput",  "",  "NRLinkResumeUrgentLinkInputSource",  826LL,  v15);
        }
      }

      dispatch_resume(*(dispatch_object_t *)(a1 + 1143));
      id v3 = *(dispatch_source_s **)(a1 + 1143);
    }

    dispatch_source_cancel(v3);
    id v4 = *(void **)(a1 + 1143);
    *(void *)(a1 + 1143) = 0LL;
  }

  uint64_t v5 = *(dispatch_source_s **)(a1 + 1151);
  if (v5)
  {
    if (*(_BYTE *)(a1 + 228))
    {
      *(_BYTE *)(a1 + 22_Block_object_dispose(va, 8) = 0;
      ++*(void *)(a1 + 1167);
      if (gNRPacketLoggingEnabled)
      {
        __int128 v16 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
        int v17 = _NRLogIsLevelEnabled(v16, 1LL);

        if (v17)
        {
          uint64_t v19 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v18);
          id v20 = [(id)a1 copyDescription];
          _NRLogWithArgs( v19,  1LL,  "%s%.30s:%-4d %@: source-resume: UrgentLinkOutput",  "",  "NRLinkResumeUrgentLinkOutputSource",  827LL,  v20);
        }
      }

      dispatch_resume(*(dispatch_object_t *)(a1 + 1151));
      uint64_t v5 = *(dispatch_source_s **)(a1 + 1151);
    }

    dispatch_source_cancel(v5);
    uint64_t v6 = *(void **)(a1 + 1151);
    *(void *)(a1 + 1151) = 0LL;
  }

  if (*(_BYTE *)(a1 + 216) && *(void *)(a1 + 695))
  {
    *(_BYTE *)(a1 + 216) = 0;
    ++*(void *)(a1 + 711);
    if (gNRPacketLoggingEnabled)
    {
      uint64_t v21 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      int v22 = _NRLogIsLevelEnabled(v21, 1LL);

      if (v22)
      {
        uint64_t v24 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v23);
        id v25 = [(id)a1 copyDescription];
        _NRLogWithArgs( v24,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusVIInput",  "",  "NRLinkResumeNexusVIInputSource",  846LL,  v25);
      }
    }

    dispatch_resume(*(dispatch_object_t *)(a1 + 695));
  }

  if (*(_BYTE *)(a1 + 214) && *(void *)(a1 + 551))
  {
    *(_BYTE *)(a1 + 214) = 0;
    ++*(void *)(a1 + 567);
    if (gNRPacketLoggingEnabled)
    {
      id v26 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
      int v27 = _NRLogIsLevelEnabled(v26, 1LL);

      if (v27)
      {
        uint64_t v29 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v28);
        id v30 = [(id)a1 copyDescription];
        _NRLogWithArgs( v29,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusVOInput",  "",  "NRLinkResumeNexusVOInputSource",  844LL,  v30);
      }
    }

    dispatch_resume(*(dispatch_object_t *)(a1 + 551));
  }

  *(void *)(a1 + 1119) = 0LL;
  *(void *)(a1 + 1135) = 0LL;
  *(void *)(a1 + 1127) = 0LL;
  *(_BYTE *)(a1 + 229) = 0;
  *(void *)(a1 + 1159) = 0LL;
  *(void *)(a1 + 1167) = 0LL;
  uint64_t v7 = *(void **)(a1 + 1895);
  if (v7)
  {
    free(v7);
    *(void *)(a1 + 1895) = 0LL;
  }

  uint64_t v8 = *(void **)(a1 + 1943);
  if (v8)
  {
    free(v8);
    *(void *)(a1 + 1943) = 0LL;
  }

  uint64_t v9 = *(void **)(a1 + 1319);
  if (v9)
  {
    free(v9);
    *(void *)(a1 + 1319) = 0LL;
  }

  *(_DWORD *)(a1 + 323) = 0;
  *(_DWORD *)(a1 + 319) = 0;
  BOOL v10 = *(void **)(a1 + 1191);
  if (v10)
  {
    free(v10);
    *(void *)(a1 + 1191) = 0LL;
  }

  *(_DWORD *)(a1 + 323) = 0;
  *(_DWORD *)(a1 + 299) = 0;
}

uint64_t sub_1000821D4(void *a1, uint64_t a2)
{
  uint64_t v199 = 0LL;
  uint64_t v4 = os_channel_attr_get(a2, 0LL, &v199);
  uint64_t v6 = _NRCopyLogObjectForNRUUID(a1[4], v5);
  uint64_t v7 = (void *)v6;
  if ((_DWORD)v4)
  {
    int IsLevelEnabled = _NRLogIsLevelEnabled(v6, 17LL);

    if (IsLevelEnabled)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v9);
      id v11 = [a1 copyDescription];
      _NRLogWithArgs(v10, 17LL, "%@: os_channel_attr_get(TX_RINGS) returned %d", v11, v4);
LABEL_89:

      return 0LL;
    }

    return 0LL;
  }

  int v12 = _NRLogIsLevelEnabled(v6, 2LL);

  if (v12)
  {
    uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v13);
    id v15 = [a1 copyDescription];
    _NRLogWithArgs( v14,  2LL,  "%s%.30s:%-4d %@: Nexus Channel TX_RINGS = %llu",  "",  "-[NRLinkBluetooth validateChannelAttributes:]",  1880LL,  v15,  v199);
  }

  uint64_t v199 = 0LL;
  uint64_t v16 = os_channel_attr_get(a2, 1LL, &v199);
  uint64_t v18 = _NRCopyLogObjectForNRUUID(a1[4], v17);
  uint64_t v19 = (void *)v18;
  if ((_DWORD)v16)
  {
    int v20 = _NRLogIsLevelEnabled(v18, 17LL);

    if (v20)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v21);
      id v11 = [a1 copyDescription];
      _NRLogWithArgs(v10, 17LL, "%@: os_channel_attr_get(RX_RINGS) returned %d", v11, v16);
      goto LABEL_89;
    }

    return 0LL;
  }

  int v22 = _NRLogIsLevelEnabled(v18, 2LL);

  if (v22)
  {
    uint64_t v24 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v23);
    id v25 = [a1 copyDescription];
    _NRLogWithArgs( v24,  2LL,  "%s%.30s:%-4d %@: Nexus Channel RX_RINGS = %llu",  "",  "-[NRLinkBluetooth validateChannelAttributes:]",  1881LL,  v25,  v199);
  }

  uint64_t v199 = 0LL;
  uint64_t v26 = os_channel_attr_get(a2, 2LL, &v199);
  uint64_t v28 = _NRCopyLogObjectForNRUUID(a1[4], v27);
  uint64_t v29 = (void *)v28;
  if ((_DWORD)v26)
  {
    int v30 = _NRLogIsLevelEnabled(v28, 17LL);

    if (v30)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v31);
      id v11 = [a1 copyDescription];
      _NRLogWithArgs(v10, 17LL, "%@: os_channel_attr_get(TX_SLOTS) returned %d", v11, v26);
      goto LABEL_89;
    }

    return 0LL;
  }

  int v32 = _NRLogIsLevelEnabled(v28, 2LL);

  if (v32)
  {
    uint64_t v34 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v33);
    id v35 = [a1 copyDescription];
    _NRLogWithArgs( v34,  2LL,  "%s%.30s:%-4d %@: Nexus Channel TX_SLOTS = %llu",  "",  "-[NRLinkBluetooth validateChannelAttributes:]",  1882LL,  v35,  v199);
  }

  uint64_t v199 = 0LL;
  uint64_t v36 = os_channel_attr_get(a2, 3LL, &v199);
  uint64_t v38 = _NRCopyLogObjectForNRUUID(a1[4], v37);
  uint64_t v39 = (void *)v38;
  if ((_DWORD)v36)
  {
    int v40 = _NRLogIsLevelEnabled(v38, 17LL);

    if (v40)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v41);
      id v11 = [a1 copyDescription];
      _NRLogWithArgs(v10, 17LL, "%@: os_channel_attr_get(RX_SLOTS) returned %d", v11, v36);
      goto LABEL_89;
    }

    return 0LL;
  }

  int v42 = _NRLogIsLevelEnabled(v38, 2LL);

  if (v42)
  {
    int v44 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v43);
    id v45 = [a1 copyDescription];
    _NRLogWithArgs( v44,  2LL,  "%s%.30s:%-4d %@: Nexus Channel RX_SLOTS = %llu",  "",  "-[NRLinkBluetooth validateChannelAttributes:]",  1883LL,  v45,  v199);
  }

  uint64_t v199 = 0LL;
  uint64_t v46 = os_channel_attr_get(a2, 4LL, &v199);
  uint64_t v48 = _NRCopyLogObjectForNRUUID(a1[4], v47);
  int v49 = (void *)v48;
  if ((_DWORD)v46)
  {
    int v50 = _NRLogIsLevelEnabled(v48, 17LL);

    if (v50)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v51);
      id v11 = [a1 copyDescription];
      _NRLogWithArgs(v10, 17LL, "%@: os_channel_attr_get(SLOT_BUF_SIZE) returned %d", v11, v46);
      goto LABEL_89;
    }

    return 0LL;
  }

  int v52 = _NRLogIsLevelEnabled(v48, 2LL);

  if (v52)
  {
    uint64_t v54 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v53);
    id v55 = [a1 copyDescription];
    _NRLogWithArgs( v54,  2LL,  "%s%.30s:%-4d %@: Nexus Channel SLOT_BUF_SIZE = %llu",  "",  "-[NRLinkBluetooth validateChannelAttributes:]",  1884LL,  v55,  v199);
  }

  uint64_t v199 = 0LL;
  uint64_t v56 = os_channel_attr_get(a2, 5LL, &v199);
  uint64_t v58 = _NRCopyLogObjectForNRUUID(a1[4], v57);
  dispatch_source_t v59 = (void *)v58;
  if ((_DWORD)v56)
  {
    int v60 = _NRLogIsLevelEnabled(v58, 17LL);

    if (v60)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v61);
      id v11 = [a1 copyDescription];
      _NRLogWithArgs(v10, 17LL, "%@: os_channel_attr_get(SLOT_META_SIZE) returned %d", v11, v56);
      goto LABEL_89;
    }

    return 0LL;
  }

  int v62 = _NRLogIsLevelEnabled(v58, 2LL);

  if (v62)
  {
    uint64_t v64 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v63);
    id v65 = [a1 copyDescription];
    _NRLogWithArgs( v64,  2LL,  "%s%.30s:%-4d %@: Nexus Channel SLOT_META_SIZE = %llu",  "",  "-[NRLinkBluetooth validateChannelAttributes:]",  1885LL,  v65,  v199);
  }

  uint64_t v199 = 0LL;
  uint64_t v66 = os_channel_attr_get(a2, 6LL, &v199);
  uint64_t v68 = _NRCopyLogObjectForNRUUID(a1[4], v67);
  int v69 = (void *)v68;
  if ((_DWORD)v66)
  {
    int v70 = _NRLogIsLevelEnabled(v68, 17LL);

    if (v70)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v71);
      id v11 = [a1 copyDescription];
      _NRLogWithArgs(v10, 17LL, "%@: os_channel_attr_get(EXCLUSIVE) returned %d", v11, v66);
      goto LABEL_89;
    }

    return 0LL;
  }

  int v72 = _NRLogIsLevelEnabled(v68, 2LL);

  if (v72)
  {
    uint64_t v74 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v73);
    id v75 = [a1 copyDescription];
    _NRLogWithArgs( v74,  2LL,  "%s%.30s:%-4d %@: Nexus Channel EXCLUSIVE = %llu",  "",  "-[NRLinkBluetooth validateChannelAttributes:]",  1886LL,  v75,  v199);
  }

  uint64_t v199 = 0LL;
  uint64_t v76 = os_channel_attr_get(a2, 7LL, &v199);
  uint64_t v78 = _NRCopyLogObjectForNRUUID(a1[4], v77);
  int v79 = (void *)v78;
  if ((_DWORD)v76)
  {
    int v80 = _NRLogIsLevelEnabled(v78, 17LL);

    if (v80)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v81);
      id v11 = [a1 copyDescription];
      _NRLogWithArgs(v10, 17LL, "%@: os_channel_attr_get(NO_AUTO_SYNC) returned %d", v11, v76);
      goto LABEL_89;
    }

    return 0LL;
  }

  int v82 = _NRLogIsLevelEnabled(v78, 2LL);

  if (v82)
  {
    uint64_t v84 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v83);
    id v85 = [a1 copyDescription];
    _NRLogWithArgs( v84,  2LL,  "%s%.30s:%-4d %@: Nexus Channel NO_AUTO_SYNC = %llu",  "",  "-[NRLinkBluetooth validateChannelAttributes:]",  1887LL,  v85,  v199);
  }

  uint64_t v199 = 0LL;
  uint64_t v86 = os_channel_attr_get(a2, 8LL, &v199);
  uint64_t v88 = _NRCopyLogObjectForNRUUID(a1[4], v87);
  id v89 = (void *)v88;
  if ((_DWORD)v86)
  {
    int v90 = _NRLogIsLevelEnabled(v88, 17LL);

    if (v90)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v91);
      id v11 = [a1 copyDescription];
      _NRLogWithArgs(v10, 17LL, "%@: os_channel_attr_get(MONITOR) returned %d", v11, v86);
      goto LABEL_89;
    }

    return 0LL;
  }

  int v92 = _NRLogIsLevelEnabled(v88, 2LL);

  if (v92)
  {
    id v94 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v93);
    id v95 = [a1 copyDescription];
    _NRLogWithArgs( v94,  2LL,  "%s%.30s:%-4d %@: Nexus Channel MONITOR = %llu",  "",  "-[NRLinkBluetooth validateChannelAttributes:]",  1888LL,  v95,  v199);
  }

  uint64_t v199 = 0LL;
  uint64_t v96 = os_channel_attr_get(a2, 9LL, &v199);
  uint64_t v98 = _NRCopyLogObjectForNRUUID(a1[4], v97);
  id v99 = (void *)v98;
  if ((_DWORD)v96)
  {
    int v100 = _NRLogIsLevelEnabled(v98, 17LL);

    if (v100)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v101);
      id v11 = [a1 copyDescription];
      _NRLogWithArgs(v10, 17LL, "%@: os_channel_attr_get(TX_LOWAT_UNIT) returned %d", v11, v96);
      goto LABEL_89;
    }

    return 0LL;
  }

  int v102 = _NRLogIsLevelEnabled(v98, 2LL);

  if (v102)
  {
    int v104 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v103);
    id v105 = [a1 copyDescription];
    _NRLogWithArgs( v104,  2LL,  "%s%.30s:%-4d %@: Nexus Channel TX_LOWAT_UNIT = %llu",  "",  "-[NRLinkBluetooth validateChannelAttributes:]",  1889LL,  v105,  v199);
  }

  uint64_t v199 = 0LL;
  uint64_t v106 = os_channel_attr_get(a2, 10LL, &v199);
  uint64_t v108 = _NRCopyLogObjectForNRUUID(a1[4], v107);
  unsigned int v109 = (void *)v108;
  if ((_DWORD)v106)
  {
    int v110 = _NRLogIsLevelEnabled(v108, 17LL);

    if (v110)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v111);
      id v11 = [a1 copyDescription];
      _NRLogWithArgs(v10, 17LL, "%@: os_channel_attr_get(TX_LOWAT_VALUE) returned %d", v11, v106);
      goto LABEL_89;
    }

    return 0LL;
  }

  int v112 = _NRLogIsLevelEnabled(v108, 2LL);

  if (v112)
  {
    id v114 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v113);
    id v115 = [a1 copyDescription];
    _NRLogWithArgs( v114,  2LL,  "%s%.30s:%-4d %@: Nexus Channel TX_LOWAT_VALUE = %llu",  "",  "-[NRLinkBluetooth validateChannelAttributes:]",  1890LL,  v115,  v199);
  }

  uint64_t v199 = 0LL;
  uint64_t v116 = os_channel_attr_get(a2, 11LL, &v199);
  uint64_t v118 = _NRCopyLogObjectForNRUUID(a1[4], v117);
  int v119 = (void *)v118;
  if ((_DWORD)v116)
  {
    int v120 = _NRLogIsLevelEnabled(v118, 17LL);

    if (v120)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v121);
      id v11 = [a1 copyDescription];
      _NRLogWithArgs(v10, 17LL, "%@: os_channel_attr_get(RX_LOWAT_UNIT) returned %d", v11, v116);
      goto LABEL_89;
    }

    return 0LL;
  }

  int v122 = _NRLogIsLevelEnabled(v118, 2LL);

  if (v122)
  {
    id v124 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v123);
    id v125 = [a1 copyDescription];
    _NRLogWithArgs( v124,  2LL,  "%s%.30s:%-4d %@: Nexus Channel RX_LOWAT_UNIT = %llu",  "",  "-[NRLinkBluetooth validateChannelAttributes:]",  1891LL,  v125,  v199);
  }

  uint64_t v199 = 0LL;
  uint64_t v126 = os_channel_attr_get(a2, 12LL, &v199);
  uint64_t v128 = _NRCopyLogObjectForNRUUID(a1[4], v127);
  id v129 = (void *)v128;
  if ((_DWORD)v126)
  {
    int v130 = _NRLogIsLevelEnabled(v128, 17LL);

    if (v130)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v131);
      id v11 = [a1 copyDescription];
      _NRLogWithArgs(v10, 17LL, "%@: os_channel_attr_get(RX_LOWAT_VALUE) returned %d", v11, v126);
      goto LABEL_89;
    }

    return 0LL;
  }

  int v132 = _NRLogIsLevelEnabled(v128, 2LL);

  if (v132)
  {
    uint64_t v134 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v133);
    id v135 = [a1 copyDescription];
    _NRLogWithArgs( v134,  2LL,  "%s%.30s:%-4d %@: Nexus Channel RX_LOWAT_VALUE = %llu",  "",  "-[NRLinkBluetooth validateChannelAttributes:]",  1892LL,  v135,  v199);
  }

  uint64_t v199 = 0LL;
  uint64_t v136 = os_channel_attr_get(a2, 13LL, &v199);
  uint64_t v138 = _NRCopyLogObjectForNRUUID(a1[4], v137);
  int v139 = (void *)v138;
  if ((_DWORD)v136)
  {
    int v140 = _NRLogIsLevelEnabled(v138, 17LL);

    if (v140)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v141);
      id v11 = [a1 copyDescription];
      _NRLogWithArgs(v10, 17LL, "%@: os_channel_attr_get(NEXUS_TYPE) returned %d", v11, v136);
      goto LABEL_89;
    }

    return 0LL;
  }

  int v142 = _NRLogIsLevelEnabled(v138, 2LL);

  if (v142)
  {
    uint64_t v144 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v143);
    id v145 = [a1 copyDescription];
    _NRLogWithArgs( v144,  2LL,  "%s%.30s:%-4d %@: Nexus Channel NEXUS_TYPE = %llu",  "",  "-[NRLinkBluetooth validateChannelAttributes:]",  1893LL,  v145,  v199);
  }

  uint64_t v199 = 0LL;
  uint64_t v146 = os_channel_attr_get(a2, 14LL, &v199);
  uint64_t v148 = _NRCopyLogObjectForNRUUID(a1[4], v147);
  uint64_t v149 = (void *)v148;
  if ((_DWORD)v146)
  {
    int v150 = _NRLogIsLevelEnabled(v148, 17LL);

    if (v150)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v151);
      id v11 = [a1 copyDescription];
      _NRLogWithArgs(v10, 17LL, "%@: os_channel_attr_get(NEXUS_EXTENSIONS) returned %d", v11, v146);
      goto LABEL_89;
    }

    return 0LL;
  }

  int v152 = _NRLogIsLevelEnabled(v148, 2LL);

  if (v152)
  {
    id v154 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v153);
    id v155 = [a1 copyDescription];
    _NRLogWithArgs( v154,  2LL,  "%s%.30s:%-4d %@: Nexus Channel NEXUS_EXTENSIONS = %llu",  "",  "-[NRLinkBluetooth validateChannelAttributes:]",  1894LL,  v155,  v199);
  }

  uint64_t v199 = 0LL;
  uint64_t v156 = os_channel_attr_get(a2, 15LL, &v199);
  uint64_t v158 = _NRCopyLogObjectForNRUUID(a1[4], v157);
  id v159 = (void *)v158;
  if ((_DWORD)v156)
  {
    int v160 = _NRLogIsLevelEnabled(v158, 17LL);

    if (v160)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v161);
      id v11 = [a1 copyDescription];
      _NRLogWithArgs(v10, 17LL, "%@: os_channel_attr_get(NEXUS_MHINTS) returned %d", v11, v156);
      goto LABEL_89;
    }

    return 0LL;
  }

  int v162 = _NRLogIsLevelEnabled(v158, 2LL);

  if (v162)
  {
    uint64_t v164 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v163);
    id v165 = [a1 copyDescription];
    _NRLogWithArgs( v164,  2LL,  "%s%.30s:%-4d %@: Nexus Channel NEXUS_MHINTS = %llu",  "",  "-[NRLinkBluetooth validateChannelAttributes:]",  1895LL,  v165,  v199);
  }

  uint64_t v199 = 0LL;
  uint64_t v166 = os_channel_attr_get(a2, 18LL, &v199);
  uint64_t v168 = _NRCopyLogObjectForNRUUID(a1[4], v167);
  uint64_t v169 = (void *)v168;
  if ((_DWORD)v166)
  {
    int v170 = _NRLogIsLevelEnabled(v168, 17LL);

    if (v170)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v171);
      id v11 = [a1 copyDescription];
      _NRLogWithArgs(v10, 17LL, "%@: os_channel_attr_get(NEXUS_IFINDEX) returned %d", v11, v166);
      goto LABEL_89;
    }

    return 0LL;
  }

  int v172 = _NRLogIsLevelEnabled(v168, 2LL);

  if (v172)
  {
    int v174 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v173);
    id v175 = [a1 copyDescription];
    _NRLogWithArgs( v174,  2LL,  "%s%.30s:%-4d %@: Nexus Channel NEXUS_IFINDEX = %llu",  "",  "-[NRLinkBluetooth validateChannelAttributes:]",  1896LL,  v175,  v199);
  }

  uint64_t v199 = 0LL;
  uint64_t v176 = os_channel_attr_get(a2, 19LL, &v199);
  uint64_t v178 = _NRCopyLogObjectForNRUUID(a1[4], v177);
  uint64_t v179 = (void *)v178;
  if ((_DWORD)v176)
  {
    int v180 = _NRLogIsLevelEnabled(v178, 17LL);

    if (v180)
    {
      BOOL v10 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v181);
      id v11 = [a1 copyDescription];
      _NRLogWithArgs(v10, 17LL, "%@: os_channel_attr_get(NEXUS_STATS_SIZE) returned %d", v11, v176);
      goto LABEL_89;
    }

    return 0LL;
  }

  int v183 = _NRLogIsLevelEnabled(v178, 2LL);

  if (v183)
  {
    id v185 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v184);
    id v186 = [a1 copyDescription];
    _NRLogWithArgs( v185,  2LL,  "%s%.30s:%-4d %@: Nexus Channel NEXUS_STATS_SIZE = %llu",  "",  "-[NRLinkBluetooth validateChannelAttributes:]",  1897LL,  v186,  v199);
  }

  uint64_t v199 = 0LL;
  uint64_t v187 = os_channel_attr_get(a2, 20LL, &v199);
  uint64_t v189 = _NRCopyLogObjectForNRUUID(a1[4], v188);
  uint64_t v190 = (void *)v189;
  if ((_DWORD)v187)
  {
    int v191 = _NRLogIsLevelEnabled(v189, 17LL);

    if (v191)
    {
      uint64_t v193 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v192);
      id v194 = [a1 copyDescription];
      _NRLogWithArgs(v193, 17LL, "%@: os_channel_attr_get(NEXUS_FLOWADV_MAX) returned %d", v194, v187);
    }

    return 0LL;
  }

  int v195 = _NRLogIsLevelEnabled(v189, 2LL);

  if (v195)
  {
    uint64_t v197 = (void *)_NRCopyLogObjectForNRUUID(a1[4], v196);
    id v198 = [a1 copyDescription];
    _NRLogWithArgs( v197,  2LL,  "%s%.30s:%-4d %@: Nexus Channel NEXUS_FLOWADV_MAX = %llu",  "",  "-[NRLinkBluetooth validateChannelAttributes:]",  1898LL,  v198,  v199);
  }

  return 1LL;
}

void sub_1000831A4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v5, 16LL);

    if (IsLevelEnabled)
    {
      id v19 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v7);
      id v8 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v19,  16LL,  "%s%.30s:%-4d %@: Urgent link input available but cancelled",  "",  "-[NRLinkBluetooth updateUrgentPipe:]_block_invoke",  2510LL,  v8);
    }
  }

  else
  {
    ++*(void *)(v3 + 1503);
    uint64_t v4 = *(void *)(a1 + 32);
    if (*(_BYTE *)(v4 + 229))
    {
      if (gNRPacketLoggingEnabled)
      {
        uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), a2);
        int v15 = _NRLogIsLevelEnabled(v14, 1LL);

        uint64_t v4 = *(void *)(a1 + 32);
        if (v15)
        {
          uint64_t v17 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), v16);
          id v18 = [*(id *)(a1 + 32) copyDescription];
          _NRLogWithArgs( v17,  1LL,  "%s%.30s:%-4d %@: Urgent link input available after prelude",  "",  "-[NRLinkBluetooth updateUrgentPipe:]_block_invoke",  2518LL,  v18);

          uint64_t v4 = *(void *)(a1 + 32);
        }
      }

      sub_1000869EC((void *)v4);
    }

    else
    {
      uint64_t v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v4 + 32), a2);
      int v10 = _NRLogIsLevelEnabled(v9, 1LL);

      if (v10)
      {
        int v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v11);
        id v13 = [*(id *)(a1 + 32) copyDescription];
        _NRLogWithArgs( v12,  1LL,  "%s%.30s:%-4d %@: Urgent link input available before prelude",  "",  "-[NRLinkBluetooth updateUrgentPipe:]_block_invoke",  2515LL,  v13);
      }

      sub_10008673C(*(void *)(a1 + 32), 1LL);
    }
  }

void sub_1000833C4(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v3 + 16) == 255)
  {
    uint64_t v4 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v4, 16LL);

    if (IsLevelEnabled)
    {
      id v13 = (id)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v6);
      id v7 = [*(id *)(a1 + 32) copyDescription];
      _NRLogWithArgs( v13,  16LL,  "%s%.30s:%-4d %@: Urgent link output available but cancelled",  "",  "-[NRLinkBluetooth updateUrgentPipe:]_block_invoke_3",  2538LL,  v7);
    }
  }

  else
  {
    ++*(void *)(v3 + 1511);
    if (gNRPacketLoggingEnabled)
    {
      id v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), a2);
      int v9 = _NRLogIsLevelEnabled(v8, 1LL);

      if (v9)
      {
        uint64_t v11 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v10);
        id v12 = [*(id *)(a1 + 32) copyDescription];
        _NRLogWithArgs( v11,  1LL,  "%s%.30s:%-4d %@: Urgent link output available",  "",  "-[NRLinkBluetooth updateUrgentPipe:]_block_invoke_3",  2542LL,  v12);
      }
    }

    sub_100083874(*(void **)(a1 + 32), *(void *)(*(void *)(a1 + 32) + 527LL));
    sub_100083874(*(void **)(a1 + 32), *(void *)(*(void *)(a1 + 32) + 671LL));
  }

void sub_100083564(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), a2);
  int IsLevelEnabled = _NRLogIsLevelEnabled(v3, 1LL);

  if (IsLevelEnabled)
  {
    uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(*(void *)(a1 + 32) + 32LL), v5);
    id v7 = [*(id *)(a1 + 32) copyDescription];
    _NRLogWithArgs( v6,  1LL,  "%s%.30s:%-4d %@: NtL-U LOOP async start after async",  "",  "-[NRLinkBluetooth updateUrgentPipe:]_block_invoke",  2589LL,  v7);
  }

  sub_100083874(*(void **)(a1 + 32), *(void *)(*(void *)(a1 + 32) + 671LL));
  objc_initWeak(&location, *(id *)(a1 + 32));
  dispatch_time_t v8 = dispatch_time(0x8000000000000000LL, 10000000000LL);
  int v9 = *(dispatch_queue_s **)(*(void *)(a1 + 32) + 8LL);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472LL;
  block[2] = sub_100086684;
  block[3] = &unk_1001B0798;
  objc_copyWeak(&v12, &location);
  id v11 = *(id *)(a1 + 40);
  dispatch_after(v8, v9, block);

  objc_destroyWeak(&v12);
  objc_destroyWeak(&location);
}

void sub_1000836BC(uint64_t a1, void *a2)
{
  id v18 = a2;
  uint64_t v3 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  -[NSMutableDictionary setObject:forKeyedSubscript:](v3, "setObject:forKeyedSubscript:", v18, @"channel-id");
  uint64_t v4 = objc_alloc_init(&OBJC_CLASS___NSMutableDictionary);
  -[NSMutableDictionary setObject:forKeyedSubscript:]( v4,  "setObject:forKeyedSubscript:",  v3,  @"deactivate-datapath");
  objc_opt_self(&OBJC_CLASS___NRLinkDirector);
  if (qword_1001DC878 != -1) {
    dispatch_once(&qword_1001DC878, &stru_1001AEED0);
  }
  id v5 = (id)qword_1001DC870;
  uint64_t v6 = v5;
  if (v5)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    dispatch_time_t v8 = (void *)*((void *)v5 + 27);
    int v9 = v4;
    uint64_t v10 = (void *)objc_claimAutoreleasedReturnValue([v8 objectForKeyedSubscript:v7]);
    sub_1000EFBC8((uint64_t)v10, v9);
  }

  id v11 = [v18 integerValue];
  if (v11 == (id)3)
  {
    *(_BYTE *)(a1 + 249) = 0;
  }

  else if (v11 == (id)2)
  {
    *(_BYTE *)(a1 + 24_Block_object_dispose(va, 8) = 0;
  }

  else if (v11 == (id)1)
  {
    *(_BYTE *)(a1 + 247) = 0;
  }

  else
  {
    id v13 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v12);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v13, 17LL);

    if (IsLevelEnabled)
    {
      uint64_t v16 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v15);
      id v17 = [(id)a1 copyDescription];
      _NRLogWithArgs(v16, 17LL, "%@: unsupported channel id %@", v17, v18);
    }
  }
}

void sub_100083874(void *a1, uint64_t a2)
{
  uint64_t v3 = a1;
  uint64_t v5 = (uint64_t)v3;
  if (*((unsigned __int8 *)v3 + 16) == 255)
  {
    id v11 = (void *)_NRCopyLogObjectForNRUUID(v3[4], v4);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v11, 16LL);

    if (IsLevelEnabled)
    {
      int v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v13);
      id v10 = [(id)v5 copyDescription];
      _NRLogWithArgs( v9,  16LL,  "%s%.30s:%-4d %@: nexusToLinkLoopUrgent but cancelled",  "",  "NRLinkNexusToLinkLoopUrgent",  3004LL,  v10);
      goto LABEL_14;
    }

    goto LABEL_257;
  }

  if (!*(void *)((char *)v3 + 1111))
  {
    sub_100070E0C(v3, a2);
    goto LABEL_257;
  }

  if (*(void *)((char *)v3 + 1135))
  {
    uint64_t v333 = *(void *)((char *)v3 + 527);
    uint64_t v334 = a2;
    if (v333 == a2)
    {
      if (gNRPacketLoggingEnabled)
      {
        id v274 = (void *)_NRCopyLogObjectForNRUUID(v3[4], v4);
        int v275 = _NRLogIsLevelEnabled(v274, 1LL);

        if (v275)
        {
          uint64_t v276 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
          id v277 = [(id)v5 copyDescription];
          _NRLogWithArgs( v276,  1LL,  "%s%.30s:%-4d %@: UrgentLink:Serving voice channel",  "",  "NRLinkNexusToLinkLoopUrgent",  3035LL,  v277);
          id v17 = &OBJC_IVAR___NRLinkBluetooth__nexusVOInputRing;
          id v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusVO;
          id v19 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusVO;
          int v20 = &OBJC_IVAR___NRLinkBluetooth__syncNexusVOInput;
          int v329 = sub_1000748C4;
          id v278 = sub_1000744A8;
LABEL_299:
          id v324 = v278;

LABEL_20:
          int v325 = 0;
          uint64_t v22 = *(void *)(v5 + *v17);
          uint64_t v322 = *v19;
          uint64_t v23 = *(void *)(v5 + v322);
          uint64_t v321 = *v18;
          uint64_t v318 = *(void *)(v5 + v321);
          uint64_t v319 = v23;
          uint64_t v320 = (char *)&v350 + 8;
          uint64_t v323 = *v20;
          uint64_t v24 = v22;
          id v25 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          uint64_t v336 = v22;
LABEL_23:
          uint64_t v26 = 0LL;
          uint64_t v330 = 0LL;
          uint64_t ESPSequenceNumberFromPacket = 0LL;
          uint64_t v27 = 0LL;
          uint64_t object_address = 0LL;
          uint64_t v338 = 0LL;
          uint64_t packet = 0LL;
          id v340 = 0LL;
          uint64_t v335 = 0LL;
          id v28 = 0LL;
          uint64_t v366 = 0LL;
          uint64_t v367 = 0LL;
          uint64_t v342 = *(void *)(v5 + 951);
          while (1)
          {
            while (1)
            {
              uint64_t v29 = v27;
              *(void *)(v5 + 1935) = 2LL;
              __int128 v352 = 0u;
              __int128 v353 = 0u;
              __int128 v350 = 0u;
              __int128 v351 = 0u;
              if (v24)
              {
                uint64_t next_slot = os_channel_get_next_slot(v24, v335, &v350);
                if (next_slot)
                {
                  if (v333 == v334 && *(_BYTE *)(v5 + 225)) {
                    break;
                  }
                }
              }

LABEL_252:
                    if (*(_BYTE *)(v5 + 214) && *(void *)(v5 + 551))
                    {
                      *(_BYTE *)(v5 + 214) = 0;
                      ++*(void *)(v5 + 567);
                      if (gNRPacketLoggingEnabled)
                      {
                        id v304 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                        int v305 = _NRLogIsLevelEnabled(v304, 1LL);

                        if (v305)
                        {
                          uint64_t v307 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v306);
                          id v308 = [(id)v5 copyDescription];
                          _NRLogWithArgs( v307,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusVOInput",  "",  "NRLinkResumeNexusVOInputSource",  844LL,  v308);
                        }
                      }

                      dispatch_resume(*(dispatch_object_t *)(v5 + 551));
                    }
                  }

                  if (gNRPacketLoggingEnabled)
                  {
                    int v279 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                    int v280 = _NRLogIsLevelEnabled(v279, 1LL);

                    if (v280)
                    {
                      int v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v281);
                      id v10 = [(id)v5 copyDescription];
                      _NRLogWithArgs( v9,  1LL,  "%s%.30s:%-4d %@: UrgentLink:out of NtL-U outer loop",  "",  "NRLinkNexusToLinkLoopUrgent",  3566LL,  v10);
LABEL_14:
                    }
                  }

                  goto LABEL_257;
                }

                id v28 = (id)v37;
                *(void *)(v5 + 1935) |= 0x20uLL;
                uint64_t packet = os_channel_slot_get_packet(*(void *)(v5 + 1135), v37);
                uint64_t next_buflet = os_packet_get_next_buflet(packet, 0LL);
                uint64_t object_address = (char *)os_buflet_get_object_address();
                uint64_t v338 = next_buflet;
                uint64_t data_limit = os_buflet_get_data_limit(next_buflet);
                if (data_limit >= 0x10000)
                {
                  id v227 = sub_100070554();
                  int v228 = _NRLogIsLevelEnabled(v227, 16LL);

                  if (v228)
                  {
                    id v229 = sub_100070554();
                    _NRLogWithArgs( v229,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: outputBufferLength <= 65535",  "",  "NRLinkNexusToLinkLoopUrgent",  3210);
                  }

LABEL_263:
                  uint64_t v230 = _os_log_pack_size(12LL);
                  uint64_t v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                  uint64_t v231 = *__error();
                  uint64_t v226 = _os_log_pack_fill( v224,  v230,  v231,  &_mh_execute_header,  "%{public}s Assertion Failed: outputBufferLength <= 65535",  v318,  v319);
                  goto LABEL_276;
                }

                uint64_t v27 = data_limit;
                uint64_t v40 = v342;
                if (v340 != v28) {
                  uint64_t v40 = v342 + 1;
                }
                uint64_t v342 = v40;
              }

              if (!*(_BYTE *)(v5 + 228) && *(void *)(v5 + 1151))
              {
                *(_BYTE *)(v5 + 22_Block_object_dispose(va, 8) = 1;
                ++*(void *)(v5 + 1167);
                if (gNRPacketLoggingEnabled)
                {
                  uint64_t v111 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                  int v112 = _NRLogIsLevelEnabled(v111, 1LL);

                  if (v112)
                  {
                    id v114 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v113);
                    id v115 = [(id)v5 copyDescription];
                    _NRLogWithArgs( v114,  1LL,  "%s%.30s:%-4d %@: source-suspend: UrgentLinkOutput",  "",  "NRLinkSuspendUrgentLinkOutputSource",  819LL,  v115);
                  }
                }

                dispatch_suspend(*(dispatch_object_t *)(v5 + 1151));
                id v25 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              }

              id v341 = v28;
              uint64_t v41 = (unsigned __int16)v27;
              unsigned int v42 = *(_DWORD *)(v5 + 299);
              uint64_t v43 = *(unsigned int *)(v5 + v25[170]);
              if (v42 <= v43)
              {
                uint64_t v24 = v336;
                if (!v336)
                {
LABEL_210:
                  if (*(_BYTE *)(v5 + 16) != 8)
                  {
                    *(void *)(v5 + 1935) |= 0x400uLL;
                    uint64_t v61 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                    id v28 = v341;
                    goto LABEL_174;
                  }

                  int v162 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                  int v163 = _NRLogIsLevelEnabled(v162, 17LL);

                  id v28 = v341;
                  if (v163)
                  {
                    uint64_t v164 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                    id v165 = [(id)v5 copyDescription];
                    _NRLogWithArgs(v164, 17LL, "%@: Tried to nexusToLinkLoopUrgent but _nexusInputRing is NULL", v165);
                  }
}

LABEL_173:
                  uint64_t v61 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                  goto LABEL_174;
                }

LABEL_302:
                      uint64_t v5 = _os_log_pack_size(18LL);
                      id v295 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                      uint64_t v296 = *__error();
                      uint64_t v297 = _os_log_pack_fill( v295,  v5,  v296,  &_mh_execute_header,  "%{public}s os_packet_finalize returned %d",  v318,  v319);
                      *(_DWORD *)uint64_t v297 = 136446466;
                      *(void *)(v297 + 4) = "NRLinkNexusToLinkLoopUrgent";
                      *(_WORD *)(v297 + 12) = 1024;
                      *(_DWORD *)(v297 + 14) = v291;
                      id v298 = sub_100070554();
                      _NRLogAbortWithPack(v298, v295);
LABEL_303:
                      id v299 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                      int v300 = _NRLogIsLevelEnabled(v299, 1LL);

                      if (v300)
                      {
                        uint64_t v302 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v301);
                        id v303 = [(id)v5 copyDescription];
                        _NRLogWithArgs( v302,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusVIInput",  "",  "NRLinkResumeNexusVIInputSource",  846LL,  v303);
                      }

LABEL_251:
                      dispatch_resume(*(dispatch_object_t *)(v5 + *(int *)(v88 + 1024)));
                      goto LABEL_252;
                    }

                    while (1)
                    {
                      uint64_t v89 = os_channel_get_next_slot(*(void *)(v5 + *(int *)(v88 + 1116)), v28, v349);
                      if (!v89) {
                        break;
                      }
                      id v28 = (id)v89;
                      uint64_t v90 = v342;
                      if (v86 != (id)v89) {
                        uint64_t v90 = v342 + 1;
                      }
                      uint64_t v342 = v90;
                      uint64_t packet = os_channel_slot_get_packet(*(void *)(v5 + *(int *)(v88 + 1116)), v89);
                      uint64_t v91 = os_packet_get_next_buflet(packet, 0LL);
                      uint64_t object_address = (char *)os_buflet_get_object_address();
                      uint64_t v338 = v91;
                      uint64_t v92 = os_buflet_get_data_limit(v91);
                      if (v92 >= 0x10000)
                      {
                        id v237 = sub_100070554();
                        int v238 = _NRLogIsLevelEnabled(v237, 16LL);

                        if (v238)
                        {
                          id v239 = sub_100070554();
                          _NRLogWithArgs( v239,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: outputBufferLength <= 65535",  "",  "NRLinkNexusToLinkLoopUrgent",  3437);
                        }

                        goto LABEL_263;
                      }

                      uint64_t v27 = v92;
                      unsigned int v93 = v92 + v85;
                      if (v92 + v85 >= v64)
                      {
                        uint64_t v26 = v64 - v85;
                        uint64_t v48 = v327;
LABEL_134:
                        uint64_t v100 = v322;
                        ++*(void *)(v5 + v321);
                        *(void *)(v5 + v100) += v347;
                        *(void *)(v5 + 1935) |= 0x10000uLL;
                        uint64_t v51 = *(void *)(v5 + 1935);
                        uint64_t v24 = v336;
                        id v25 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                        if (!v51)
                        {
                          id v340 = v28;
                          uint64_t v335 = v48;
                          uint64_t v61 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                          goto LABEL_101;
                        }

                        uint64_t v61 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                        uint64_t v51 = *(void *)(v5 + 1943);
                        if (v51)
                        {
                          *(_BYTE *)(v5 + 259) %= *(_BYTE *)(v5 + 258);
                          uint64_t v101 = *(void *)(v5 + 1943);
                          int v102 = (void *)(v101 + 8LL * *(unsigned __int8 *)(v5 + 259));
                          if ((unint64_t)(v102 + 1) > v101
                                                            + 8 * (unint64_t)*(unsigned __int8 *)(v5 + 258))
                          {
                            uint64_t v103 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                            int v104 = _NRLogIsLevelEnabled(v103, 17LL);

                            if (v104)
                            {
                              id v105 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                              id v106 = [(id)v5 copyDescription];
                              _NRLogWithArgs( v105,  17LL,  "%@: invalid index for ntl log list (curIdx: %u)",  v106,  *(unsigned __int8 *)(v5 + 259));
                            }

                            LODWORD(v51) = 0;
                            id v340 = v28;
                            uint64_t v335 = v48;
                            id v25 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                            goto LABEL_101;
                          }

                          LODWORD(v51) = 0;
                          if ((v102 & 7) == 0)
                          {
                            *int v102 = *(void *)(v5 + 1935);
                            ++*(_BYTE *)(v5 + 259);
                            *(void *)(v5 + 1935) = 0LL;
                          }
                        }

                        id v340 = v28;
                        uint64_t v335 = v48;
                        goto LABEL_101;
                      }

                      *(void *)(v5 + 1935) |= 0x8000uLL;
                      if (gNRPacketLoggingEnabled)
                      {
                        id v95 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                        int v96 = _NRLogIsLevelEnabled(v95, 1LL);

                        if (v96)
                        {
                          uint64_t v98 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v97);
                          id v99 = [(id)v5 copyDescription];
                          _NRLogWithArgs( v98,  1LL,  "%s%.30s:%-4d %@: UrgentLink:Sending ESP sequence number %u (3)",  "",  "NRLinkNexusToLinkLoopUrgent",  3450LL,  v99,  ESPSequenceNumberFromPacket);
                        }
                      }

                      uint64_t v367 = v342;
                      os_buflet_set_data_length(v338, v27);
                      os_packet_set_flow_uuid(packet, &v366);
                      int v94 = os_packet_finalize(packet);
                      unsigned int v85 = v93;
                      unint64_t v88 = 0x1001D8000LL;
                      if (v94)
                      {
                        int v291 = v94;
                        id v292 = sub_100070554();
                        int v293 = _NRLogIsLevelEnabled(v292, 16LL);

                        if (v293)
                        {
                          id v294 = sub_100070554();
                          _NRLogWithArgs( v294,  16LL,  "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d",  "",  "NRLinkNexusToLinkLoopUrgent",  3457,  v291);
                        }

                        goto LABEL_302;
                      }
                    }

                    id v232 = sub_100070554();
                    int v233 = _NRLogIsLevelEnabled(v232, 16LL);

                    if (v233)
                    {
                      id v234 = sub_100070554();
                      _NRLogWithArgs( v234,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: (curLinkOutputSlot) != ((void *)0)",  "",  "NRLinkNexusToLinkLoopUrgent",  3427);
                    }

                    uint64_t v235 = _os_log_pack_size(12LL);
                    uint64_t v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                    uint64_t v236 = *__error();
                    uint64_t v226 = _os_log_pack_fill( v224,  v235,  v236,  &_mh_execute_header,  "%{public}s Assertion Failed: (curLinkOutputSlot) != ((void *)0)",  v318,  v319);
                    break;
                }

                while (1)
                {
LABEL_276:
                  *(_DWORD *)uint64_t v226 = 136446210;
                  *(void *)(v226 + 4) = "NRLinkNexusToLinkLoopUrgent";
LABEL_277:
                  id v250 = sub_100070554();
                  _NRLogAbortWithPack(v250, v224);
LABEL_278:
                  id v251 = sub_100070554();
                  int v252 = _NRLogIsLevelEnabled(v251, 16LL);

                  if (v252)
                  {
                    id v253 = sub_100070554();
                    _NRLogWithArgs( v253,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: curLinkOutputSlot == highestLinkOutputSlotWrittenTo",  "",  "NRLinkNexusToLinkLoopUrgent",  3473);
                  }

                  uint64_t v254 = _os_log_pack_size(12LL);
                  uint64_t v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                  uint64_t v255 = *__error();
                  uint64_t v226 = _os_log_pack_fill( v224,  v254,  v255,  &_mh_execute_header,  "%{public}s Assertion Failed: curLinkOutputSlot == highestLinkOutputSlotWrittenTo",  v318,  v319);
                }
              }

              unsigned int v44 = v42 - v43;
              else {
                unsigned int v45 = v44;
              }
              memcpy(object_address, (const void *)(*(void *)(v5 + 1191) + v43), (unsigned __int16)v45);
              *(_DWORD *)(v5 + v25[170]) += (unsigned __int16)v45;
              *(void *)(v5 + 1415) += (unsigned __int16)v45;
              ++*(_DWORD *)(v5 + 295);
              *(void *)(v5 + 1935) |= 0x100uLL;
              if (gNRPacketLoggingEnabled)
              {
                uint64_t v107 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                int v108 = _NRLogIsLevelEnabled(v107, 1LL);

                if (v108)
                {
                  unsigned int v109 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
                  id v110 = [(id)v5 copyDescription];
                  _NRLogWithArgs( v109,  1LL,  "%s%.30s:%-4d %@: wrote %u bytes from linkWriteBuffer to link, filledIn=%u handled=%u",  "",  "NRLinkNexusToLinkLoopUrgent",  3260LL,  v110,  (unsigned __int16)v45,  *(unsigned int *)(v5 + 299),  *(unsigned int *)(v5 + 303));
                }
              }

              uint64_t v26 = v45 + v26;
              if ((unsigned __int16)v26 < (unsigned __int16)v27)
              {
                id v340 = v341;
                uint64_t v24 = v336;
                id v25 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                if (!v336) {
                  goto LABEL_210;
                }
                goto LABEL_65;
              }

              uint64_t v24 = v336;
              if ((unsigned __int16)v26 != (unsigned __int16)v27)
              {
                id v220 = sub_100070554();
                int v221 = _NRLogIsLevelEnabled(v220, 16LL);

                if (v221)
                {
                  id v222 = sub_100070554();
                  _NRLogWithArgs( v222,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: curLinkOutputSlotPartialBytesAlreadyWritten == linkOutputBufferLength",  "",  "NRLinkNexusToLinkLoopUrgent",  3263);
                }

                uint64_t v223 = _os_log_pack_size(12LL);
                uint64_t v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                uint64_t v225 = *__error();
                uint64_t v226 = _os_log_pack_fill( v224,  v223,  v225,  &_mh_execute_header,  "%{public}s Assertion Failed: curLinkOutputSlotPartialBytesAlreadyWritten == linkOutputBufferLength",  v318,  v319);
                goto LABEL_276;
              }

              os_buflet_set_data_length(v338, (unsigned __int16)v27);
              uint64_t v367 = v342;
              os_packet_set_flow_uuid(packet, &v366);
              int v46 = os_packet_finalize(packet);
              if (v46)
              {
                int v282 = v46;
                id v283 = sub_100070554();
                int v284 = _NRLogIsLevelEnabled(v283, 16LL);

                if (v284)
                {
                  id v285 = sub_100070554();
                  _NRLogWithArgs( v285,  16LL,  "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d",  "",  "NRLinkNexusToLinkLoopUrgent",  3271,  v282);
                }

                goto LABEL_296;
              }

              uint64_t v26 = 0LL;
              *(void *)(v5 + 1935) |= 0x200uLL;
              id v28 = v341;
              id v340 = v341;
              id v25 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            }

            uint64_t v31 = next_slot;
            uint64_t v32 = 0LL;
            if ((void)v351)
            {
              uint64_t v4 = WORD1(v350);
              BOOL v33 = 0;
              if (WORD1(v350))
              {
                if (isPacketValidIPv6())
                {
                  unsigned int DSCPFromPacket = getDSCPFromPacket(v351, WORD1(v350));
                  BOOL v35 = DSCPFromPacket == 46;
                  BOOL v36 = WORD1(v350) < 0x2A4u;
                  BOOL v33 = v35 && v36;
                  if (v35 && v36) {
                    uint64_t v32 = 46LL;
                  }
                  else {
                    uint64_t v32 = DSCPFromPacket;
                  }
                }

                else
                {
                  uint64_t v32 = 0LL;
                  BOOL v33 = 0;
                }
              }
            }

            else
            {
              BOOL v33 = 0;
            }

            if (gNRPacketLoggingEnabled)
            {
              uint64_t ESPSequenceNumberFromPacket = getESPSequenceNumberFromPacket(v351, WORD1(v350));
              if (gNRPacketLoggingEnabled) {
                getESPSPIFromPacket(v351, WORD1(v350));
              }
            }

            else
            {
              uint64_t ESPSequenceNumberFromPacket = 0LL;
            }

            if (!v33)
            {
              id v25 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              goto LABEL_40;
            }

            uint64_t v67 = os_channel_get_next_slot(*(void *)(v5 + 1055), v330, v346);
            if (v67)
            {
              uint64_t v69 = v67;
              if (!*(_BYTE *)(v5 + 224) && *(void *)(v5 + 1071))
              {
                uint64_t v70 = v67;
                *(_BYTE *)(v5 + 224) = 1;
                ++*(void *)(v5 + 1087);
                if (gNRPacketLoggingEnabled)
                {
                  uint64_t v138 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v68);
                  LODWORD(v341) = _NRLogIsLevelEnabled(v138, 1LL);

                  if ((_DWORD)v341)
                  {
                    int v140 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v139);
                    id v341 = [(id)v5 copyDescription];
                    _NRLogWithArgs( v140,  1LL,  "%s%.30s:%-4d %@: source-suspend: DatagramLinkOutput",  "",  "NRLinkSuspendDatagramLinkOutputSource",  817LL,  v341);
                  }
                }

                dispatch_suspend(*(dispatch_object_t *)(v5 + 1071));
                uint64_t v69 = v70;
              }

              uint64_t v71 = *(void *)(v5 + 1055);
              uint64_t v335 = v69;
              id v341 = (id)os_channel_slot_get_packet(v71, v69);
              uint64_t v72 = os_packet_get_next_buflet(v341, 0LL);
              uint64_t v73 = os_buflet_get_object_address();
              unsigned int v74 = os_buflet_get_data_limit(v72);
              if (v74 < 0x10000)
              {
                uint64_t v343 = v73;
                unsigned int v344 = v74;
                int v345 = 0;
                uint64_t v75 = nrPacketToTLV(v351, WORD1(v350), &v343, 1LL, v5 + 1951, v5 + 1967);
                *(void *)(v5 + 1399) += v75;
                *(void *)(v5 + v322) += WORD1(v350);
                ++*(void *)(v5 + v321);
                *(void *)(v5 + 1935) |= 0x10uLL;
                if (gNRPacketLoggingEnabled)
                {
                  uint64_t v332 = v75;
                  uint64_t v133 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v76);
                  int v134 = _NRLogIsLevelEnabled(v133, 1LL);

                  LOWORD(v75) = v332;
                  if (v134)
                  {
                    uint64_t v136 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v135);
                    id v137 = [(id)v5 copyDescription];
                    _NRLogWithArgs( v136,  1LL,  "%s%.30s:%-4d %@: wrote payload of length: %u, dscp: %u, uncompressedLen = %u",  "",  "NRLinkNexusToLinkLoopUrgent",  3180LL,  v137,  v332,  v32,  WORD1(v350));

                    LOWORD(v75) = v332;
                  }
                }

                os_buflet_set_data_length(v72, (unsigned __int16)v75);
                uint64_t v367 = ++v342;
                os_packet_set_flow_uuid(v341, &v366);
                int v77 = os_packet_finalize(v341);
                if (!v77)
                {
                  LODWORD(v51) = 24;
                  uint64_t v24 = v336;
                  uint64_t v330 = v335;
                  uint64_t v335 = v31;
                  id v25 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                  uint64_t v61 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                  uint64_t v27 = v29;
                  goto LABEL_101;
                }

                int v282 = v77;
                id v315 = sub_100070554();
                int v316 = _NRLogIsLevelEnabled(v315, 16LL);

                if (v316)
                {
                  id v317 = sub_100070554();
                  _NRLogWithArgs( v317,  16LL,  "%s%.30s:%-4d ABORTING: os_packet_finalize returned %d",  "",  "NRLinkNexusToLinkLoopUrgent",  3184,  v282);
                }

LABEL_296:
                uint64_t v286 = _os_log_pack_size(18LL);
                uint64_t v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
                uint64_t v287 = *__error();
                uint64_t v288 = _os_log_pack_fill( v224,  v286,  v287,  &_mh_execute_header,  "%{public}s os_packet_finalize returned %d",  v318,  v319);
                *(_DWORD *)uint64_t v288 = 136446466;
                *(void *)(v288 + 4) = "NRLinkNexusToLinkLoopUrgent";
                *(_WORD *)(v288 + 12) = 1024;
                *(_DWORD *)(v288 + 14) = v282;
                goto LABEL_277;
              }

              id v269 = sub_100070554();
              int v270 = _NRLogIsLevelEnabled(v269, 16LL);

              if (v270)
              {
                id v271 = sub_100070554();
                _NRLogWithArgs( v271,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: datagramBufferLength <= 65535",  "",  "NRLinkNexusToLinkLoopUrgent",  3160);
              }

              uint64_t v272 = _os_log_pack_size(12LL);
              uint64_t v224 = (char *)&v318 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v273 = *__error();
              uint64_t v226 = _os_log_pack_fill( v224,  v272,  v273,  &_mh_execute_header,  "%{public}s Assertion Failed: datagramBufferLength <= 65535",  v318,  v319);
              goto LABEL_276;
            }

            id v25 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            uint64_t v27 = v29;
            if (*(_BYTE *)(v5 + 224) && *(void *)(v5 + 1071))
            {
              *(_BYTE *)(v5 + 224) = 0;
              ++*(void *)(v5 + 1087);
              if (gNRPacketLoggingEnabled)
              {
                uint64_t v141 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v68);
                int v142 = _NRLogIsLevelEnabled(v141, 1LL);

                if (v142)
                {
                  uint64_t v144 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v143);
                  id v145 = [(id)v5 copyDescription];
                  _NRLogWithArgs( v144,  1LL,  "%s%.30s:%-4d %@: source-resume: DatagramLinkOutput",  "",  "NRLinkResumeDatagramLinkOutputSource",  825LL,  v145);
                }
              }

              dispatch_resume(*(dispatch_object_t *)(v5 + 1071));
              id v25 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            }

            ((void (*)(uint64_t))v329)(v5);
            *(void *)(v5 + 1935) |= 4uLL;
            LODWORD(v51) = 25;
            uint64_t v61 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
LABEL_101:
            if ((_DWORD)v51 && (_DWORD)v51 != 24)
            {
              if ((_DWORD)v51 == 25) {
                goto LABEL_174;
              }
              goto LABEL_22;
            }
          }
        }
      }

      id v17 = &OBJC_IVAR___NRLinkBluetooth__nexusVOInputRing;
      id v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusVO;
      id v19 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusVO;
      int v20 = &OBJC_IVAR___NRLinkBluetooth__syncNexusVOInput;
      int v329 = sub_1000748C4;
      uint64_t v21 = sub_1000744A8;
    }

    else
    {
      if (*(void *)((char *)v3 + 671) != a2)
      {
        uint64_t v6 = (void *)_NRCopyLogObjectForNRUUID(v3[4], v4);
        int v7 = _NRLogIsLevelEnabled(v6, 17LL);

        if (v7)
        {
          int v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v8);
          id v10 = [(id)v5 copyDescription];
          _NRLogWithArgs(v9, 17LL, "%@: channel %p not eligible for urgent link", v10, a2);
          goto LABEL_14;
        }

        goto LABEL_257;
      }

      if (gNRPacketLoggingEnabled)
      {
        int v289 = (void *)_NRCopyLogObjectForNRUUID(v3[4], v4);
        int v290 = _NRLogIsLevelEnabled(v289, 1LL);

        if (v290)
        {
          uint64_t v276 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v4);
          id v277 = [(id)v5 copyDescription];
          _NRLogWithArgs( v276,  1LL,  "%s%.30s:%-4d %@: UrgentLink:Serving video channel",  "",  "NRLinkNexusToLinkLoopUrgent",  3046LL,  v277);
          id v17 = &OBJC_IVAR___NRLinkBluetooth__nexusVIInputRing;
          id v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusVI;
          id v19 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusVI;
          int v20 = &OBJC_IVAR___NRLinkBluetooth__syncNexusVIInput;
          int v329 = sub_1000747BC;
          id v278 = sub_1000743A4;
          goto LABEL_299;
        }
      }

      id v17 = &OBJC_IVAR___NRLinkBluetooth__nexusVIInputRing;
      id v18 = &OBJC_IVAR___NRLinkBluetooth__packetsFromNexusVI;
      id v19 = &OBJC_IVAR___NRLinkBluetooth__bytesFromNexusVI;
      int v20 = &OBJC_IVAR___NRLinkBluetooth__syncNexusVIInput;
      int v329 = sub_1000747BC;
      uint64_t v21 = sub_1000743A4;
    }

    id v324 = v21;
    goto LABEL_20;
  }

  if (!*((_BYTE *)v3 + 246))
  {
    uint64_t v14 = (void *)_NRCopyLogObjectForNRUUID(v3[4], v4);
    int v15 = _NRLogIsLevelEnabled(v14, 17LL);

    if (v15)
    {
      int v9 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v5 + 32), v16);
      id v10 = [(id)v5 copyDescription];
      _NRLogWithArgs(v9, 17LL, "%@: Tried to nexusToLinkLoop but _urgentLinkOutputRing is NULL", v10);
      goto LABEL_14;
    }
  }

LABEL_257:
}

void sub_100086684(uint64_t a1)
{
  id WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v3 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v13 = (uint64_t)WeakRetained;
    id v4 = *(id *)(WeakRetained + 1111);
    uint64_t v3 = (void *)v13;
    if (v4)
    {
      uint64_t v5 = *(void *)(v13 + 1111);
      uint64_t v6 = *(void *)(a1 + 32);

      uint64_t v3 = (void *)v13;
      if (v5 == v6 && !*(_BYTE *)(v13 + 229))
      {
        uint64_t v12 = *(void *)(v13 + 1863);
        if (v12) {
          *(_BYTE *)(v12 + 102) = 1;
        }
        sub_1000749CC( (void *)v13,  @"Did not receive prelude after %ds on urgent pipe",  v13,  v7,  v8,  v9,  v10,  v11,  10LL);
        uint64_t v3 = (void *)v13;
      }
    }
  }
}

void sub_10008673C(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return;
  }
  int v2 = a2;
  id v4 = &OBJC_IVAR___NRLinkBluetooth__urgentLinkInputRing;
  if (!(_DWORD)a2) {
    id v4 = &OBJC_IVAR___NRLinkBluetooth__linkInputRing;
  }
  uint64_t v5 = &OBJC_IVAR___NRLinkBluetooth__linkChannel;
  if ((_DWORD)a2) {
    uint64_t v5 = &OBJC_IVAR___NRLinkBluetooth__urgentLinkChannel;
  }
  uint64_t v6 = *(void *)(a1 + *v4);
  if (!v6)
  {
    uint64_t v12 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v12, 17LL);

    if (!IsLevelEnabled) {
      return;
    }
    id v30 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v14);
    id v15 = [(id)a1 copyDescription];
    uint64_t v16 = v15;
    id v17 = "";
    if (v2) {
      id v17 = "urgent ";
    }
    _NRLogWithArgs(v30, 17LL, "%@: Tried to read but %slinkInputRingToRead is NULL", v15, v17);
LABEL_22:

    return;
  }

  uint64_t v7 = *(void *)(a1 + *v5);
  if (!v7)
  {
    id v18 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), a2);
    int v19 = _NRLogIsLevelEnabled(v18, 17LL);

    if (!v19) {
      return;
    }
    id v30 = (id)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v20);
    id v21 = [(id)a1 copyDescription];
    uint64_t v16 = v21;
    uint64_t v22 = "";
    if (v2) {
      uint64_t v22 = "urgent ";
    }
    _NRLogWithArgs(v30, 17LL, "%@: Tried to read but %slinkChannelToRead is NULL", v21, v22);
    goto LABEL_22;
  }

  if ((a2 & 1) != 0)
  {
    uint64_t i = 0LL;
    while (1)
    {
      __int128 v33 = 0u;
      __int128 v34 = 0u;
      *(_OWORD *)__n = 0u;
      *(_OWORD *)__src = 0u;
      uint64_t next_slot = os_channel_get_next_slot(v6, i, __n);
      if (!next_slot) {
        break;
      }
      uint64_t v10 = next_slot;
      sub_10008C73C(a1, __src[0], WORD1(__n[0]), 1LL);
      uint64_t i = v10;
      if (*(_BYTE *)(a1 + 229)) {
        goto LABEL_28;
      }
    }
  }

  else
  {
    for (uint64_t i = 0LL; ; uint64_t i = v24)
    {
      __int128 v33 = 0u;
      __int128 v34 = 0u;
      *(_OWORD *)__n = 0u;
      *(_OWORD *)__src = 0u;
      uint64_t v23 = os_channel_get_next_slot(v6, i, __n);
      if (!v23) {
        break;
      }
      uint64_t v24 = v23;
      sub_10008C73C(a1, __src[0], WORD1(__n[0]), 0LL);
      if (*(unsigned __int8 *)(a1 + 16) == 255)
      {
LABEL_30:
        id v25 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v11);
        int v26 = _NRLogIsLevelEnabled(v25, 16LL);

        if (v26)
        {
          id v28 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 32), v27);
          id v29 = [(id)a1 copyDescription];
          _NRLogWithArgs( v28,  16LL,  "%s%.30s:%-4d %@: Tried to read but we are cancelled",  "",  "-[NRLinkBluetooth readDataFromChannelWithIsUrgent:]",  6963LL,  v29);
        }

        return;
      }
    }
  }

  uint64_t v10 = i;
  if (i) {
LABEL_28:
  }
    os_channel_advance_slot(v6, v10);
  os_channel_sync(v7, 1LL);
}

void sub_1000869EC(void *a1)
{
  uint64_t v1 = a1;
  uint64_t v3 = (uint64_t)v1;
  if (gNRPacketLoggingEnabled)
  {
    v441 = (void *)_NRCopyLogObjectForNRUUID(v1[4], v2);
    int IsLevelEnabled = _NRLogIsLevelEnabled(v441, 1LL);

    if (IsLevelEnabled)
    {
      v443 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
      id v444 = [(id)v3 copyDescription];
      _NRLogWithArgs( v443,  1LL,  "%s%.30s:%-4d %@: UrgentLink:start LtN-U loop function",  "",  "NRLinkLinkToNexusLoopUrgent",  4364LL,  v444);
    }
  }

  int v4 = *(unsigned __int8 *)(v3 + 16);
  if (v4 == 255)
  {
    uint64_t v5 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
    int v6 = _NRLogIsLevelEnabled(v5, 16LL);

    if (!v6) {
      goto LABEL_463;
    }
    uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v7);
    id v9 = [(id)v3 copyDescription];
    _NRLogWithArgs( v8,  16LL,  "%s%.30s:%-4d %@: LinkToNexusLoopUrgent but cancelled",  "",  "NRLinkLinkToNexusLoopUrgent",  4367LL,  v9);
    goto LABEL_461;
  }

  uint64_t v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
  if (!*(void *)(v3 + 1127))
  {
    v488 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
    int v489 = _NRLogIsLevelEnabled(v488, 17LL);

    if (!v489) {
      goto LABEL_463;
    }
    uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v490);
    id v378 = [(id)v3 copyDescription];
    _NRLogWithArgs(v8, 17LL, "%@: Tried to linkToNexusLoopUrgent but _urgentLinkInputRing is NULL", v378);
    goto LABEL_454;
  }

  if ((v4 - 1) < 2)
  {
    int v11 = *(unsigned __int8 *)(v3 + 229);
    uint64_t v12 = _NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
    uint64_t v13 = (void *)v12;
    if (v11)
    {
      int v14 = _NRLogIsLevelEnabled(v12, 0LL);

      if (!v14) {
        goto LABEL_463;
      }
      uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v15);
      id v9 = [(id)v3 copyDescription];
      _NRLogWithArgs( v8,  0LL,  "%s%.30s:%-4d %@: Tried to linkToNexusLoopUrgent after receiving urgent prelude",  "",  "NRLinkLinkToNexusLoopUrgent",  4379LL,  v9);
      goto LABEL_461;
    }

    int v376 = _NRLogIsLevelEnabled(v12, 17LL);

    if (!v376) {
      goto LABEL_463;
    }
    uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v377);
    id v378 = [(id)v3 copyDescription];
    _NRLogWithArgs(v8, 17LL, "%@: Tried to linkToNexusLoopUrgent but bad state", v378);
LABEL_454:

    goto LABEL_462;
  }

  uint64_t v639 = 0LL;
  uint64_t v640 = 0LL;
  v637 = v674;
  v638 = (char *)&v676 + 8;
  v642 = (char *)&v675 + 8;
  uint64_t v16 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
  id v17 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
  id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
  uint64_t v648 = v3;
  while (2)
  {
    uint64_t v19 = 0LL;
    LODWORD(v65_Block_object_dispose(va, 8) = 0;
    uint64_t v657 = 0LL;
    __int128 v646 = 0uLL;
    v652 = 0LL;
    v663[0] = 0LL;
    v663[1] = 0LL;
    LODWORD(v650) = *(_BYTE *)(v3 + v16[364]) != 0;
    while (1)
    {
LABEL_15:
      uint64_t v20 = 1887LL;
      *(void *)(v3 + 1887) = 4LL;
      if ((_WORD)v19 && (unsigned __int16)v19 >= (unsigned __int16)v658)
      {
        *(void *)(v3 + 1887) = 12LL;
      }

      else if ((_WORD)v19)
      {
        *(void *)(v3 + 1887) = 36LL;
        if (!v652) {
          goto LABEL_367;
        }
        goto LABEL_28;
      }

      uint64_t next_slot = os_channel_get_next_slot(*(void *)(v3 + v10[280]), *((void *)&v646 + 1), &v664);
      *(void *)(v3 + 1887) |= 0x10uLL;
      if (!next_slot)
      {
LABEL_367:
        if (*(_BYTE *)(v3 + 227) && *(void *)(v3 + 1143))
        {
          *(_BYTE *)(v3 + 227) = 0;
          ++*(void *)(v3 + 1159);
          if (gNRPacketLoggingEnabled)
          {
            __int128 v356 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
            int v357 = _NRLogIsLevelEnabled(v356, 1LL);

            id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            if (v357)
            {
              __int128 v359 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v358);
              id v360 = [(id)v3 copyDescription];
              _NRLogWithArgs( v359,  1LL,  "%s%.30s:%-4d %@: source-resume: UrgentLinkInput",  "",  "NRLinkResumeUrgentLinkInputSource",  826LL,  v360);

              id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            }
          }

          dispatch_resume(*(dispatch_object_t *)(v3 + 1143));
        }

        if (!*(_BYTE *)(v3 + 217) && *(void *)(v3 + 703))
        {
          *(_BYTE *)(v3 + 217) = 1;
          ++*(void *)(v3 + 719);
          if (gNRPacketLoggingEnabled)
          {
            uint64_t v366 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
            int v367 = _NRLogIsLevelEnabled(v366, 1LL);

            id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            if (v367)
            {
              __int128 v369 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v368);
              id v370 = [(id)v3 copyDescription];
              _NRLogWithArgs( v369,  1LL,  "%s%.30s:%-4d %@: source-suspend: NexusVIOutput",  "",  "NRLinkSuspendNexusVIOutputSource",  837LL,  v370);

              id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            }
          }

          dispatch_suspend(*(dispatch_object_t *)(v3 + 703));
        }

        *(void *)(v3 + 1887) |= 0x40uLL;
        goto LABEL_394;
      }

      uint64_t v22 = next_slot;
      uint64_t v23 = *(void *)(v3 + v10[280]);
      v652 = (uint64_t *)v22;
      uint64_t packet = os_channel_slot_get_packet(v23, v22);
      uint64_t next_buflet = os_packet_get_next_buflet(packet, 0LL);
      uint64_t object_address = os_buflet_get_object_address();
      unsigned int data_offset = os_buflet_get_data_offset(next_buflet);
      unsigned int data_length = os_buflet_get_data_length(next_buflet);
      if (data_length >= 0x10000)
      {
        id v427 = sub_100070554();
        int v428 = _NRLogIsLevelEnabled(v427, 16LL);

        if (v428)
        {
          id v429 = sub_100070554();
          _NRLogWithArgs( v429,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: inputBufferLength <= 65535",  "",  "NRLinkLinkToNexusLoopUrgent",  4436);
        }

        goto LABEL_475;
      }

      LODWORD(v65_Block_object_dispose(va, 8) = data_length;
      uint64_t v657 = object_address + data_offset;
      os_packet_get_flow_uuid(packet, v663);
      uint64_t v19 = 0LL;
      if (*(_BYTE *)(v3 + 245))
      {
        *(_BYTE *)(v3 + 245) = 0;
        LODWORD(v650) = 1;
      }

      else
      {
        LODWORD(v650) = v650 | BYTE2(v663[0]);
      }

      uint64_t v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
LABEL_28:
      if (!*(_BYTE *)(v3 + 227) && *(void *)(v3 + 1143))
      {
        uint64_t v29 = v19;
        *(_BYTE *)(v3 + 227) = 1;
        ++*(void *)(v3 + 1159);
        if (gNRPacketLoggingEnabled)
        {
          id v256 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
          int v257 = _NRLogIsLevelEnabled(v256, 1LL);

          if (v257)
          {
            uint64_t v259 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v258);
            id v260 = [(id)v3 copyDescription];
            _NRLogWithArgs( v259,  1LL,  "%s%.30s:%-4d %@: source-suspend: UrgentLinkInput",  "",  "NRLinkSuspendUrgentLinkInputSource",  818LL,  v260);
          }
        }

        dispatch_suspend(*(dispatch_object_t *)(v3 + 1143));
        uint64_t v19 = v29;
      }

      unsigned int v30 = *(_DWORD *)(v3 + v17[287]);
      uint64_t v31 = *(unsigned int *)(v3 + v18[286]);
      uint64_t v32 = v19;
      uint64_t v33 = *(void *)(v3 + 1319);
      unsigned int v34 = *(unsigned __int8 *)(v33 + v31);
      if (*(_BYTE *)(v33 + v31)) {
        goto LABEL_45;
      }
      while (1)
      {
        uint64_t v41 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
        int v42 = _NRLogIsLevelEnabled(v41, 1LL);

        if (v42)
        {
          uint64_t v43 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
          id v44 = [(id)v3 copyDescription];
          _NRLogWithArgs( v43,  1LL,  "%s%.30s:%-4d %@: Handling Pad0 in linkReadBuffer",  "",  "NRLinkLinkToNexusLoopUrgent",  4485LL,  v44);
        }

        ++*(_DWORD *)(v3 + v18[286]);
        unsigned int v30 = *(_DWORD *)(v3 + v17[287]);
        uint64_t v45 = *(unsigned int *)(v3 + v18[286]);
        uint64_t v46 = *(void *)(v3 + 1319);
        unsigned int v34 = *(unsigned __int8 *)(v46 + v45);
        if (*(_BYTE *)(v46 + v45))
        {
          uint64_t v31 = *(unsigned int *)(v3 + v18[286]);
          uint64_t v19 = v32;
          goto LABEL_45;
        }
      }

      if (v30 != (_DWORD)v45)
      {
        id v564 = sub_100070554();
        int v565 = _NRLogIsLevelEnabled(v564, 16LL);

        if (v565)
        {
          id v566 = sub_100070554();
          _NRLogWithArgs( v566,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: self->_filledInUrgentLinkReadBufferBytes == self->_handledUrgentLin kReadBufferBytes",  "",  "NRLinkLinkToNexusLoopUrgent",  4489);
        }

        uint64_t v567 = _os_log_pack_size(12LL);
        v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v568 = *__error();
        uint64_t v410 = _os_log_pack_fill( v399,  v567,  v568,  &_mh_execute_header,  "%{public}s Assertion Failed: self->_filledInUrgentLinkReadBufferBytes == self->_handledUrgentLinkReadBufferBytes");
        goto LABEL_483;
      }

      id v55 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
      int v56 = _NRLogIsLevelEnabled(v55, 1LL);

      uint64_t v19 = v32;
      if (v56)
      {
        uint64_t v57 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
        id v58 = [(id)v3 copyDescription];
        _NRLogWithArgs( v57,  1LL,  "%s%.30s:%-4d %@: Ended linkReadBuffer on a Pad0 handled=%u filledIn=%u",  "",  "NRLinkLinkToNexusLoopUrgent",  4491LL,  v58,  *(unsigned int *)(v3 + v18[286]),  *(unsigned int *)(v3 + v17[287]));

        uint64_t v19 = v32;
      }
    }

    while (1)
    {
      unsigned int v34 = *(unsigned __int8 *)(v657 + (unsigned __int16)v19);
      int v36 = v19;
      uint64_t v37 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
      int v38 = _NRLogIsLevelEnabled(v37, 1LL);

      if (v38)
      {
        uint64_t v39 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
        id v40 = [(id)v3 copyDescription];
        _NRLogWithArgs( v39,  1LL,  "%s%.30s:%-4d %@: Handling Pad0 in linkInputSlot alreadyRead=%u",  "",  "NRLinkLinkToNexusLoopUrgent",  4509LL,  v40,  (unsigned __int16)v36);
      }

      uint64_t v19 = (v36 + 1);
      unsigned int v35 = (unsigned __int16)(v36 + 1);
      if (v35 >= (unsigned __int16)v658)
      {
        if (v35 != (unsigned __int16)v658)
        {
          id v485 = sub_100070554();
          int v486 = _NRLogIsLevelEnabled(v485, 16LL);

          if (v486)
          {
            id v487 = sub_100070554();
            _NRLogWithArgs( v487,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: curLinkInputSlotPartialBytesAlreadyRead == linkInputBufferLength",  "",  "NRLinkLinkToNexusLoopUrgent",  4513);
          }

          goto LABEL_498;
        }

        uint64_t v281 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
        int v282 = _NRLogIsLevelEnabled(v281, 1LL);

        if (v282)
        {
          id v283 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
          id v284 = [(id)v3 copyDescription];
          _NRLogWithArgs( v283,  1LL,  "%s%.30s:%-4d %@: Ended linkInputSlot on a Pad0 handled=%u filledIn=%u",  "",  "NRLinkLinkToNexusLoopUrgent",  4515LL,  v284,  *(unsigned int *)(v3 + 323),  *(unsigned int *)(v3 + v17[287]));

          id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
        }

        else
        {
          id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
        }

        goto LABEL_394;
      }
    }

    uint64_t v31 = *(unsigned int *)(v3 + v18[286]);
    unsigned int v30 = *(_DWORD *)(v3 + v17[287]);
LABEL_45:
    uint64_t v647 = v19;
    unsigned __int16 v47 = v658;
    if (v30 <= (int)v31 + 2)
    {
      if (v30 == (_DWORD)v31 + 2)
      {
        size_t v50 = *(unsigned __int8 *)(*(void *)(v3 + 1319) + (v31 + 1));
        if ((unsigned __int16)v19 >= (unsigned __int16)v658)
        {
          uint64_t v49 = 0LL;
          int v51 = 0;
          uint64_t v52 = 512LL;
        }

        else
        {
          uint64_t v49 = *(unsigned __int8 *)(v657 + (unsigned __int16)v19);
          int v51 = 1;
          uint64_t v52 = 256LL;
        }
      }

      else
      {
        if (v30 == (_DWORD)v31 + 1) {
          unsigned __int16 v53 = v19;
        }
        else {
          unsigned __int16 v53 = v19 + 1;
        }
        if (v53 + 2 >= (unsigned __int16)v658)
        {
          size_t v50 = 0LL;
          uint64_t v49 = 0LL;
          int v51 = 0;
          uint64_t v52 = 2048LL;
        }

        else
        {
          unsigned int v54 = bswap32(*(unsigned __int16 *)(v657 + v53));
          uint64_t v49 = BYTE2(v54);
          size_t v50 = HIBYTE(v54);
          int v51 = 1;
          uint64_t v52 = 1024LL;
        }
      }
    }

    else
    {
      unsigned int v48 = bswap32(*(unsigned __int16 *)(*(void *)(v3 + 1319) + (v31 + 1)));
      uint64_t v49 = BYTE2(v48);
      size_t v50 = HIBYTE(v48);
      int v51 = 1;
      uint64_t v52 = 128LL;
    }

    uint64_t v59 = *(void *)(v3 + 1887) | v52;
    *(void *)(v3 + 1887) = v59;
    __int128 v689 = 0u;
    __int128 v690 = 0u;
    __int128 v687 = 0u;
    __int128 v688 = 0u;
    __int128 v685 = 0u;
    __int128 v686 = 0u;
    __int128 v683 = 0u;
    __int128 v684 = 0u;
    __int128 v681 = 0u;
    __int128 v682 = 0u;
    __int128 v679 = 0u;
    __int128 v680 = 0u;
    __int128 v677 = 0u;
    __int128 v678 = 0u;
    __int128 v675 = 0u;
    __int128 v676 = 0u;
    unint64_t v60 = v30 - v31;
    unsigned int v649 = v34;
    unsigned int v643 = v30;
    uint64_t v645 = v31;
    size_t v653 = v50;
    if (v30 <= v31)
    {
      unint64_t v62 = 0LL;
      uint64_t v63 = 0LL;
    }

    else
    {
      *(void *)&__int128 v675 = *(void *)(v3 + 1319) + v31;
      uint64_t v61 = v49 | ((_DWORD)v50 << 8);
      if (v61 + 5 < v60) {
        unint64_t v60 = v61 + 5;
      }
      if (!(_DWORD)v60)
      {
        id v452 = sub_100070554();
        char v453 = _NRLogIsLevelEnabled(v452, 16LL);

        if ((v453 & 1) != 0)
        {
          id v454 = sub_100070554();
          _NRLogWithArgs( v454,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: lrbIOVecLen > 0; tlvLen=%u filledInLinkReadBufferBytes=%u handledLi"
            "nkReadBufferBytes=%u",
            "",
            "NRLinkLinkToNexusLoopUrgent",
            4597,
            v61,
            *(_DWORD *)(v3 + v17[287]),
            *(_DWORD *)(v3 + 323));
        }

        uint64_t v506 = _os_log_pack_size(30LL);
        v507 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        v508 = __error();
        uint64_t v509 = _os_log_pack_fill( v507,  v506,  *v508,  &_mh_execute_header,  "%{public}s Assertion Failed: lrbIOVecLen > 0; tlvLen=%u filledInLinkReadBufferBytes=%u handledLinkReadBufferBytes=%u");
        sub_10008BB5C( v509,  (uint64_t)"NRLinkLinkToNexusLoopUrgent",  v61,  *(_DWORD *)(v3 + v17[287]),  *(_DWORD *)(v3 + 323));
        id v510 = sub_100070554();
        _NRLogAbortWithPack(v510, v507);
        goto LABEL_536;
      }

      unint64_t v62 = v60;
      DWORD2(v675) = v60;
      v59 |= 0x1000uLL;
      *(void *)(v3 + 1887) = v59;
      uint64_t v63 = 1LL;
    }

    uint64_t v64 = v647;
    int v65 = (unsigned __int16)v647;
    uint64_t v66 = v47;
    BOOL v67 = (unsigned __int16)v647 < v47;
    uint64_t v655 = 1887LL;
    if ((unsigned __int16)v647 >= v47)
    {
      if (!v51)
      {
        uint64_t v654 = v49;
        unint64_t v656 = v62;
        unsigned int v70 = v63;
        goto LABEL_83;
      }

LABEL_475:
        uint64_t v408 = _os_log_pack_size(12LL);
        v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v409 = *__error();
        uint64_t v410 = _os_log_pack_fill( v399,  v408,  v409,  &_mh_execute_header,  "%{public}s Assertion Failed: inputBufferLength <= 65535");
        goto LABEL_483;
      }

      uint64_t v3 = v93;
      os_packet_get_flow_uuid(v89, v663);
      if (*(_BYTE *)(v90 + 245))
      {
        *(_BYTE *)(v90 + 245) = 0;
        LOBYTE(v94) = 1;
      }

      else
      {
        LOBYTE(v94) = (v650 | BYTE2(v663[0])) & 1;
      }

      uint64_t v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      uint64_t v99 = v655;
      int v98 = v656;
      uint64_t v49 = v654;
      int v2 = (uint64_t *)v88;
      uint64_t v100 = v91 + v92;
      *((void *)&v675 + 2 * v651) = v100;
      if (!(_DWORD)v3)
      {
LABEL_476:
        if (qword_1001DC840 != -1) {
          dispatch_once(&qword_1001DC840, &stru_1001AEE08);
        }
        if (_NRLogIsLevelEnabled(qword_1001DC838, 16LL))
        {
          if (qword_1001DC840 != -1) {
            dispatch_once(&qword_1001DC840, &stru_1001AEE08);
          }
          _NRLogWithArgs( qword_1001DC838,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: lookAheadLinkInputBufferLength > 0",  "",  "NRLinkLinkToNexusLoopUrgent",  4689);
        }

        uint64_t v411 = _os_log_pack_size(12LL);
        v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v412 = *__error();
        uint64_t v410 = _os_log_pack_fill( v399,  v411,  v412,  &_mh_execute_header,  "%{public}s Assertion Failed: lookAheadLinkInputBufferLength > 0");
        goto LABEL_483;
      }

      unint64_t v101 = v651;
      *((_DWORD *)&v675 + 4 * v651 + 2) = v3;
      uint64_t v102 = *(void *)(v648 + v99) | 0x20000LL;
      *(void *)(v648 + v99) = v102;
      unint64_t v103 = v101 + 1;
      unint64_t v656 = (v3 + v98);
      else {
        char v104 = (char)v75;
      }
      if ((v104 & 1) != 0)
      {
        id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
        if ((_DWORD)v75)
        {
          size_t v73 = v653;
          goto LABEL_139;
        }

        int v108 = 0;
        size_t v73 = v653;
LABEL_141:
        uint64_t v59 = v102 | 0x80000;
        uint64_t v3 = v648;
        *(void *)(v648 + v99) = v59;
        id v95 = v652;
        v644 = v652;
        goto LABEL_144;
      }

      id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      if (DWORD2(v675) > 2)
      {
        int v105 = *(_WORD *)(v675 + 1);
        int v106 = HIBYTE(*(unsigned __int16 *)(v675 + 1));
        unsigned int v107 = v649;
LABEL_135:
        unsigned int v110 = v105 | (v106 << 8);
        unsigned int v111 = bswap32(v110);
        uint64_t v49 = BYTE2(v111);
        size_t v73 = HIBYTE(v111);
        if (v107 - 100 < 6 || v107 - 2 < 4)
        {
          unsigned int v112 = 2000;
          goto LABEL_138;
        }

        if (v107 == 1)
        {
          unsigned int v112 = 255;
LABEL_138:
          unsigned int v113 = __rev16(v110);
          if (v113 > v112)
          {
            uint64_t v3 = v648;
LABEL_460:
            uint64_t v8 = (void *)((uint64_t (*)(void))createStringFromNRTLVType)();
            id v9 = (id)createIOVecStringWithContents(&v675, (unsigned __int16)v103);
            sub_1000749CC( (void *)v3,  @"LookAhead received invalid TLV len %u for %@ (max=%u) %@",  v388,  v389,  v390,  v391,  v392,  v393,  v113);
LABEL_461:

            goto LABEL_462;
          }
        }

LABEL_139:
        unint64_t v114 = (v49 | ((unint64_t)v73 << 8)) + 5;
        uint64_t v99 = v655;
        int v115 = v656;
        uint64_t v102 = *(void *)(v648 + v655);
        if (v114 > v656)
        {
          int v108 = 1;
          goto LABEL_141;
        }

        uint64_t v59 = v102 | 0x40000;
        *(void *)(v648 + v655) = v59;
        uint64_t v116 = (v115 - v114);
        uint64_t v117 = v101;
        uint64_t v118 = &v675 + v101;
        int v119 = *((_DWORD *)v118 + 2) - v116;
        *((_DWORD *)v118 + 2) = v119;
        if (!v119) {
          goto LABEL_489;
        }
        uint64_t v647 = (v3 - v116);
        __int128 v664 = v659;
        __int128 v665 = v660;
        int v108 = 1;
        __int128 v666 = v661;
        __int128 v667 = v662;
        unint64_t v656 = (v49 | ((unint64_t)v73 << 8)) + 5;
        uint64_t v657 = v100;
        LODWORD(v65_Block_object_dispose(va, 8) = v3;
        v644 = v2;
        uint64_t v3 = v648;
        id v95 = v652;
LABEL_144:
        unint64_t v103 = v101 + 2;
        uint64_t v120 = &v638[16 * v101];
        unint64_t v121 = v656;
        while (2)
        {
          unint64_t v651 = v103 - 1;
          BOOL v122 = v94 != 0;
          unint64_t v656 = v121;
          if ((v108 & 1) != 0
            && ((unint64_t)(unsigned __int16)v73 << 8) + (unsigned __int16)v49 + 5 <= v121)
          {
            LODWORD(v650) = v94 != 0;
            BOOL v67 = 1;
            uint64_t v20 = v655;
            uint64_t v85 = v651;
            int v96 = v644;
            goto LABEL_109;
          }

          uint64_t v123 = v120;
          LODWORD(v652) = v108;
          char v124 = v94;
          size_t v653 = v73;
          uint64_t v654 = v49;
          uint64_t v75 = v2;
          uint64_t v125 = os_channel_get_next_slot(*(void *)(v3 + v10[280]), v2, &v659);
          if (!v125)
          {
            LODWORD(v650) = v122;
            BOOL v67 = 1;
            int v96 = v644;
            uint64_t v20 = v655;
            uint64_t v97 = v75;
            LOBYTE(v75) = (_BYTE)v652;
            goto LABEL_185;
          }

          uint64_t v126 = v125;
          uint64_t v127 = *(void *)(v3 + v10[280]);
          v650 = (uint64_t *)v126;
          uint64_t v128 = os_channel_slot_get_packet(v127, v126);
          uint64_t v129 = os_packet_get_next_buflet(v128, 0LL);
          uint64_t v130 = v3;
          uint64_t v3 = os_buflet_get_object_address();
          unsigned int v131 = os_buflet_get_data_offset(v129);
          unsigned int v132 = os_buflet_get_data_length(v129);
          if (v132 >= 0x10000) {
            goto LABEL_469;
          }
          unsigned int v133 = v132;
          BOOL v134 = v124 != 0;
          os_packet_get_flow_uuid(v128, v663);
          if (*(_BYTE *)(v130 + 245))
          {
            *(_BYTE *)(v130 + 245) = 0;
            int v94 = 1;
          }

          else
          {
            int v94 = (v134 | BYTE2(v663[0])) & 1;
          }

          uint64_t v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          uint64_t v135 = v655;
          int v136 = v656;
          uint64_t v49 = v654;
          uint64_t v97 = v75;
          id v137 = v123;
          uint64_t v138 = v3 + v131;
          *((void *)v123 - 1) = v138;
          char v139 = (char)v652;
          if (!v133) {
            goto LABEL_476;
          }
          *uint64_t v123 = v133;
          uint64_t v3 = v648;
          uint64_t v140 = *(void *)(v648 + v135);
          *(void *)(v648 + v135) = v140 | 0x20000;
          unint64_t v121 = v133 + v136;
          if (v139 & 1 | (v121 < 3))
          {
            if ((v139 & 1) != 0)
            {
              unsigned int v141 = v649;
              size_t v73 = v653;
              goto LABEL_176;
            }

            uint64_t v59 = v140 | 0xA0000;
            *(void *)(v3 + v135) = v59;
            if (v103 == 16) {
              goto LABEL_487;
            }
            int v108 = 0;
            id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            size_t v73 = v653;
            int v2 = v650;
LABEL_147:
            ++v103;
            uint64_t v120 = (char *)(v137 + 4);
            id v95 = v75;
            continue;
          }

          break;
        }

        if (DWORD2(v675) < 3)
        {
          unsigned int v141 = v649;
          if (DWORD2(v675) == 2)
          {
            uint64_t v144 = (unsigned __int8 *)v676;
            int v142 = *(unsigned __int8 *)(v675 + 1);
          }

          else
          {
            if (DWORD2(v675) != 1) {
              goto LABEL_501;
            }
            if (DWORD2(v676) > 1)
            {
              int v142 = *(_WORD *)v676;
              int v143 = HIBYTE(*(unsigned __int16 *)v676);
              goto LABEL_172;
            }

            if (v651 <= 1) {
              goto LABEL_526;
            }
            if (DWORD2(v676) != 1) {
              goto LABEL_529;
            }
            uint64_t v144 = (unsigned __int8 *)v677;
            int v142 = *(unsigned __int8 *)v676;
          }

          int v143 = *v144;
          goto LABEL_172;
        }

        int v142 = *(_WORD *)(v675 + 1);
        int v143 = HIBYTE(*(unsigned __int16 *)(v675 + 1));
        unsigned int v141 = v649;
LABEL_172:
        unsigned int v145 = v142 | (v143 << 8);
        unsigned int v146 = bswap32(v145);
        uint64_t v49 = BYTE2(v146);
        size_t v73 = HIBYTE(v146);
        if (v141 - 100 >= 6 && v141 - 2 >= 4)
        {
          if (v141 == 1)
          {
            unsigned int v147 = 255;
            goto LABEL_175;
          }
        }

        else
        {
          unsigned int v147 = 2000;
LABEL_175:
          unsigned int v113 = __rev16(v145);
          if (v113 > v147) {
            goto LABEL_460;
          }
        }

        unsigned int v112 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v42);
        unsigned int v113 = _NRLogIsLevelEnabled(v112, 1LL);

        uint64_t v3 = v217;
        if (!v113) {
          goto LABEL_263;
        }
        uint64_t v214 = (id *)_NRCopyLogObjectForNRUUID(*(void *)(v216 + 96), v114);
        _NRLogWithArgs( v214,  1LL,  "%s%.30s:%-4d Deferring request as there is no link that can honor",  "",  "-[NRDDeviceConductor processRequest:]",  2803);
LABEL_262:

        uint64_t v3 = v217;
        goto LABEL_263;
      }
    }

    int v115 = *(id *)(a1 + 128);
    if (v115
      && (v117 = v115, uint64_t v118 = [*(id *)(a1 + 128) state], v117, v118 == 8))
    {
      int IsLevelEnabled = (id *)*(id *)(a1 + 128);
    }

    else
    {
      if (!v3 || !*((_BYTE *)v3 + 14))
      {
LABEL_194:
        size_t v153 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(a1 + 96), v116);
        uint64_t v154 = _NRLogIsLevelEnabled(v153, 1LL);

        uint64_t v3 = v217;
        if (!v154) {
          goto LABEL_263;
        }
        uint64_t v214 = (id *)_NRCopyLogObjectForNRUUID(*(void *)(v216 + 96), v155);
        _NRLogWithArgs(v214, 1LL, "%s%.30s:%-4d No link found", "", "-[NRDDeviceConductor processRequest:]", 2820);
        goto LABEL_262;
      }

      uint64_t v236 = 0u;
      uint64_t v237 = 0u;
      id v234 = 0u;
      id v235 = 0u;
      uint64_t v135 = *(id *)(a1 + 112);
      int IsLevelEnabled = (id *)[v135 countByEnumeratingWithState:&v234 objects:v249 count:16];
      if (IsLevelEnabled)
      {
        int v136 = *(void *)v235;
        do
        {
          for (k = 0LL; k != IsLevelEnabled; k = (id *)((char *)k + 1))
          {
            if (*(void *)v235 != v136) {
              objc_enumerationMutation(v135);
            }
            uint64_t v138 = *(void **)(*((void *)&v234 + 1) + 8LL * (void)k);
            if ([v138 state] == 9 && objc_msgSend(v138, "type") != 4)
            {
              int IsLevelEnabled = v138;
              goto LABEL_192;
            }
          }

          int IsLevelEnabled = (id *)[v135 countByEnumeratingWithState:&v234 objects:v249 count:16];
        }

        while (IsLevelEnabled);
      }

LABEL_176:
        unint64_t v148 = ((unint64_t)(unsigned __int16)v73 << 8) + (unsigned __int16)v49 + 5;
        uint64_t v20 = v655;
        uint64_t v149 = *(void *)(v3 + v655);
        if (v148 <= v121)
        {
          uint64_t v59 = v149 | 0x40000;
          *(void *)(v3 + v655) = v59;
          uint64_t v116 = (v121 - v148);
          uint64_t v150 = &v675 + (int)v103 - 1;
          int v151 = *((_DWORD *)v150 + 2) - v116;
          *((_DWORD *)v150 + 2) = v151;
          if (!v151)
          {
            unint64_t v656 = v121;
            uint64_t v117 = (v103 - 1);
LABEL_489:
            id v421 = sub_100070554();
            char v422 = _NRLogIsLevelEnabled(v421, 16LL);

            if ((v422 & 1) != 0)
            {
              id v423 = sub_100070554();
              v424 = (void *)createIOVecString(&v675, (unsigned __int16)v103);
              int v425 = (unsigned __int16)v647;
              int v426 = v656;
              _NRLogWithArgs( v423,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[iovecIndex - 1].len > 0; Shrunk last ioVecs[%u] down by "
                "%u to 0 - %@ ioVecContentLen=%u alreadyRead=%u",
                "",
                "NRLinkLinkToNexusLoopUrgent",
                4726LL,
                v117,
                v116,
                v424,
                v656,
                (unsigned __int16)v647);
            }

            else
            {
              int v425 = (unsigned __int16)v647;
              int v426 = v656;
            }

            uint64_t v430 = _os_log_pack_size(46LL);
            v431 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
            v432 = __error();
            uint64_t v433 = _os_log_pack_fill( v431,  v430,  *v432,  &_mh_execute_header,  "%{public}s Assertion Failed: ioVecs[iovecIndex - 1].len > 0; Shrunk last ioVecs[%u] down by %u to 0"
                     " - %@ ioVecContentLen=%u alreadyRead=%u");
            id v434 = (id)createIOVecString(&v675, (unsigned __int16)v103);
            sub_10008BB8C(v433, (uint64_t)"NRLinkLinkToNexusLoopUrgent", v117, v116, (uint64_t)v434, v426, v425);

            id v435 = sub_100070554();
            _NRLogAbortWithPack(v435, v431);
LABEL_496:
            id v436 = sub_100070554();
            int v437 = _NRLogIsLevelEnabled(v436, 16LL);

            if (v437)
            {
              id v438 = sub_100070554();
              _NRLogWithArgs( v438,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: curLinkInputSlotPartialBytesAlreadyRead == linkInputBufferLength",  "",  "NRLinkLinkToNexusLoopUrgent",  4420);
            }

LABEL_498:
            uint64_t v439 = _os_log_pack_size(12LL);
            v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
            uint64_t v440 = *__error();
            uint64_t v410 = _os_log_pack_fill( v399,  v439,  v440,  &_mh_execute_header,  "%{public}s Assertion Failed: curLinkInputSlotPartialBytesAlreadyRead == linkInputBufferLength");
LABEL_483:
            *(_DWORD *)uint64_t v410 = 136446210;
            v413 = "NRLinkLinkToNexusLoopUrgent";
LABEL_484:
            *(void *)(v410 + 4) = v413;
            goto LABEL_485;
          }

          uint64_t v647 = v133 - v116;
          __int128 v664 = v659;
          __int128 v665 = v660;
          __int128 v666 = v661;
          __int128 v667 = v662;
          if (v103 == 16)
          {
            int v2 = v650;
            uint64_t v657 = v138;
            LODWORD(v65_Block_object_dispose(va, 8) = v133;
            unint64_t v121 = ((unint64_t)(unsigned __int16)v73 << 8) + (unsigned __int16)v49 + 5;
            id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            goto LABEL_194;
          }

          int v108 = 1;
          int v2 = v650;
          v644 = v650;
          uint64_t v657 = v138;
          LODWORD(v65_Block_object_dispose(va, 8) = v133;
          unint64_t v121 = ((unint64_t)(unsigned __int16)v73 << 8) + (unsigned __int16)v49 + 5;
          goto LABEL_146;
        }

        uint64_t v59 = v149 | 0x80000;
        *(void *)(v3 + v655) = v59;
        int v2 = v650;
        if (v103 != 16)
        {
          int v108 = 1;
LABEL_146:
          id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          goto LABEL_147;
        }

        BOOL v155 = v148 > v121;
        unint64_t v148 = v121;
        id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
        int v2 = v644;
        if (v155) {
          goto LABEL_486;
        }
LABEL_194:
        unint64_t v656 = v121;
        BOOL v156 = v94 != 0;
        size_t v153 = (unsigned __int16)(v49 | ((_WORD)v73 << 8));
        uint64_t v85 = 16LL;
        LODWORD(v650) = v156;
        if (v153 + 5 <= v148)
        {
          uint64_t v152 = v49 | ((_DWORD)v73 << 8);
          v652 = v2;
LABEL_196:
          uint64_t v154 = v59 | 0x200000;
          *((void *)&v646 + 1) = v2;
          goto LABEL_197;
        }

        id v17 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
LABEL_381:
        uint64_t v286 = v97;
        unsigned __int16 v287 = v85;
        if (gNRPacketLoggingEnabled)
        {
          unsigned __int16 v347 = v73;
          uint64_t v348 = *(void *)(v3 + 32);
          uint64_t v654 = v49;
          uint64_t v349 = (void *)_NRCopyLogObjectForNRUUID(v348, v2);
          int v350 = _NRLogIsLevelEnabled(v349, 1LL);

          id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          if (v350)
          {
            uint64_t v658 = _NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
            id v351 = [(id)v3 copyDescription];
            StringFromNRTLVType = (void *)createStringFromNRTLVType(v649);
            uint64_t v635 = (unsigned __int16)v654 | (v347 << 8);
            __int128 v353 = (void *)v658;
            _NRLogWithArgs( v658,  1LL,  "%s%.30s:%-4d %@: UrgentLink:LtN-U not enough input bytes from linkInputSlot %u to fit %@ tlvLen %u",  "",  "NRLinkLinkToNexusLoopUrgent",  4764LL,  v351,  v656,  StringFromNRTLVType,  v635);

            id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
          }
        }

        unsigned int v288 = v643;
        unsigned int v289 = v645;
        if (*(_BYTE *)(v3 + 227) && *(void *)(v3 + 1143))
        {
          *(_BYTE *)(v3 + 227) = 0;
          ++*(void *)(v3 + 1159);
          if (gNRPacketLoggingEnabled)
          {
            __int128 v361 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
            int v362 = _NRLogIsLevelEnabled(v361, 1LL);

            id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            if (v362)
            {
              __int128 v364 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v363);
              id v365 = [(id)v3 copyDescription];
              _NRLogWithArgs( v364,  1LL,  "%s%.30s:%-4d %@: source-resume: UrgentLinkInput",  "",  "NRLinkResumeUrgentLinkInputSource",  826LL,  v365);

              id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            }
          }

          dispatch_resume(*(dispatch_object_t *)(v3 + 1143));
          unsigned int v288 = v643;
          unsigned int v289 = v645;
        }

        if ((v288 > v289) < v287)
        {
          unint64_t v290 = v287 - (unint64_t)(v288 > v289);
          int v291 = (unsigned int *)&v642[16 * (v288 > v289)];
          do
          {
            if (gNRPacketLoggingEnabled)
            {
              int v293 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              int v294 = _NRLogIsLevelEnabled(v293, 1LL);

              id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              if (v294)
              {
                uint64_t v296 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v295);
                id v297 = [(id)v3 copyDescription];
                _NRLogWithArgs( v296,  1LL,  "%s%.30s:%-4d %@: partial TLV - consolidating %u bytes from linkInputSlot buf %p to linkReadBuffer fill edIn=%u handled=%u",  "",  "NRLinkLinkToNexusLoopUrgent",  4771LL,  v297,  *v291,  *((void *)v291 - 1),  *(unsigned int *)(v3 + v17[287]),  *(unsigned int *)(v3 + 323));

                id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              }
            }

            memcpy( (void *)(*(void *)(v3 + 1319) + *(unsigned int *)(v3 + v17[287])),  *((const void **)v291 - 1),  *v291);
            unsigned int v292 = *v291;
            v291 += 4;
            *(_DWORD *)(v3 + v17[287]) += v292;
            --v290;
          }

          while (v290);
        }

        *(void *)(v3 + v655) |= 0x100000uLL;
        *((void *)&v646 + 1) = v286;
LABEL_394:
        if (*((void *)&v646 + 1))
        {
          unsigned int v298 = *(_DWORD *)(v3 + v17[287]);
          unsigned int v299 = *(_DWORD *)(v3 + v18[286]);
          if (v298 <= v299)
          {
            if (v299 != v298)
            {
              id v559 = sub_100070554();
              int v560 = _NRLogIsLevelEnabled(v559, 16LL);

              if (v560)
              {
                id v561 = sub_100070554();
                _NRLogWithArgs( v561,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: self->_handledUrgentLinkReadBufferBytes == self->_filledInUrg entLinkReadBufferBytes",  "",  "NRLinkLinkToNexusLoopUrgent",  5040);
              }

              uint64_t v562 = _os_log_pack_size(12LL);
              v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
              uint64_t v563 = *__error();
              uint64_t v410 = _os_log_pack_fill( v399,  v562,  v563,  &_mh_execute_header,  "%{public}s Assertion Failed: self->_handledUrgentLinkReadBufferBytes == self->_filledInUrgentLinkReadBufferBytes");
              goto LABEL_483;
            }

            *(void *)(v3 + 1887) |= 0x400000000uLL;
            if (gNRPacketLoggingEnabled)
            {
              uint64_t v338 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              int v339 = _NRLogIsLevelEnabled(v338, 1LL);

              id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              if (v339)
              {
                id v340 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
                id v341 = [(id)v3 copyDescription];
                _NRLogWithArgs( v340,  1LL,  "%s%.30s:%-4d %@: UrgentLink:resetting the linkReadBuffer (filledIn=%u)",  "",  "NRLinkLinkToNexusLoopUrgent",  5043LL,  v341,  *(unsigned int *)(v3 + v17[287]));

                id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              }
            }

            *(_DWORD *)(v3 + v17[287]) = 0;
LABEL_402:
            *(_DWORD *)(v3 + v18[286]) = 0;
            goto LABEL_403;
          }

          if (v299 > *(_DWORD *)(v3 + 275))
          {
            *(void *)(v3 + 1887) |= 0x80000000uLL;
            if (gNRPacketLoggingEnabled)
            {
              uint64_t v342 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              int v343 = _NRLogIsLevelEnabled(v342, 1LL);

              id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              if (v343)
              {
                int v345 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v344);
                id v346 = [(id)v3 copyDescription];
                _NRLogWithArgs( v345,  1LL,  "%s%.30s:%-4d %@: UrgentLink:memmoving the linkReadBuffer by handled=%u (filledIn=%u) thresh=%u",  "",  "NRLinkLinkToNexusLoopUrgent",  5021LL,  v346,  *(unsigned int *)(v3 + 323),  *(unsigned int *)(v3 + v17[287]),  *(unsigned int *)(v3 + 275));

                id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              }
            }

            uint64_t v300 = *(unsigned int *)(v3 + v18[286]);
            memmove( *(void **)(v3 + 1319),  (const void *)(*(void *)(v3 + 1319) + v300),  (*(_DWORD *)(v3 + v17[287]) - v300));
            *(_DWORD *)(v3 + v17[287]) -= *(_DWORD *)(v3 + v18[286]);
            goto LABEL_402;
          }

          uint64_t v307 = *(void *)(v3 + 1887);
          if (v299)
          {
            unint64_t v308 = v307 | (unint64_t)&_mh_execute_header;
            *(void *)(v3 + 1887) = v307 | (unint64_t)&_mh_execute_header;
            if (gNRPacketLoggingEnabled)
            {
              id v309 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              int v310 = _NRLogIsLevelEnabled(v309, 1LL);

              id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              if (v310)
              {
                id v311 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
                id v312 = [(id)v3 copyDescription];
                _NRLogWithArgs( v311,  1LL,  "%s%.30s:%-4d %@: UrgentLink:not memmoving the linkReadBuffer thresh handled=%u filledIn=%u thresh=%u",  "",  "NRLinkLinkToNexusLoopUrgent",  5031LL,  v312,  *(unsigned int *)(v3 + 323),  *(unsigned int *)(v3 + v17[287]),  *(unsigned int *)(v3 + 275));
                goto LABEL_443;
              }

              goto LABEL_403;
            }

LABEL_411:
            *(void *)(v3 + 1887) = v308 | 0x800000000LL;
          }

          else
          {
            unint64_t v308 = v307 | 0x200000000LL;
            *(void *)(v3 + 1887) = v307 | 0x200000000LL;
            if (!gNRPacketLoggingEnabled) {
              goto LABEL_411;
            }
            __int128 v354 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
            int v355 = _NRLogIsLevelEnabled(v354, 1LL);

            id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            if (v355)
            {
              id v311 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              id v312 = [(id)v3 copyDescription];
              _NRLogWithArgs( v311,  1LL,  "%s%.30s:%-4d %@: UrgentLink:not memmoving the linkReadBuffer zero handled=%u filledIn=%u thresh=%u",  "",  "NRLinkLinkToNexusLoopUrgent",  5037LL,  v312,  *(unsigned int *)(v3 + 323),  *(unsigned int *)(v3 + v17[287]),  *(unsigned int *)(v3 + 275));
LABEL_443:

              id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            }

LABEL_403:
            int v301 = gNRPacketLoggingEnabled;
            *(void *)(v3 + 1887) |= 0x800000000uLL;
            if (v301)
            {
              uint64_t v302 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              int v303 = _NRLogIsLevelEnabled(v302, 1LL);

              id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              if (v303)
              {
                int v305 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v304);
                id v306 = [(id)v3 copyDescription];
                _NRLogWithArgs( v305,  1LL,  "%s%.30s:%-4d %@: UrgentLink:advancing past linkInputSlot=%p and syncing urgent link input",  "",  "NRLinkLinkToNexusLoopUrgent",  5049LL,  v306,  *((void *)&v646 + 1));

                id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              }
            }
          }

          if (gNRPacketLoggingEnabled)
          {
            uint64_t v323 = objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
            id v324 = *(void **)(v3 + 1711);
            *(void *)(v3 + 1711) = v323;
          }

          os_channel_advance_slot(*(void *)(v3 + v10[280]), *((void *)&v646 + 1));
          os_channel_sync(*(void *)(v3 + 1119), 1LL);
          ++*(void *)(v3 + 1455);
          if (gNRPacketLoggingEnabled)
          {
            int v325 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
            int v326 = _NRLogIsLevelEnabled(v325, 1LL);

            id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            if (v326)
            {
              uint64_t v327 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              id v328 = [(id)v3 copyDescription];
              _NRLogWithArgs( v327,  1LL,  "%s%.30s:%-4d %@: UrgentLink:read from urgent pipe",  "",  "NRLinkLinkToNexusLoopUrgent",  5054LL,  v328);

              id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            }
          }
        }

        if ((void)v646)
        {
          if (*(void *)(v3 + 687))
          {
            *(void *)(v3 + 1887) |= 0x1000000000uLL;
            if (gNRPacketLoggingEnabled)
            {
              int v329 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              int v330 = _NRLogIsLevelEnabled(v329, 1LL);

              if (v330)
              {
                uint64_t v332 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v331);
                id v333 = [(id)v3 copyDescription];
                _NRLogWithArgs( v332,  1LL,  "%s%.30s:%-4d %@: UrgentLink:advancing past nexusVIOutputSlot=%p and syncing nexus VI output",  "",  "NRLinkLinkToNexusLoopUrgent",  5061LL,  v333,  (void)v646);
              }

              id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              if (gNRPacketLoggingEnabled)
              {
                uint64_t v334 = objc_claimAutoreleasedReturnValue(+[NSDate date](&OBJC_CLASS___NSDate, "date"));
                uint64_t v335 = *(void **)(v3 + 1671);
                *(void *)(v3 + 1671) = v334;
              }
            }

            os_channel_advance_slot(*(void *)(v3 + 687), v646);
            os_channel_sync(*(void *)(v3 + 671), 0LL);
            ++*(void *)(v3 + 767);
            if (gNRPacketLoggingEnabled)
            {
              uint64_t v336 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              int v337 = _NRLogIsLevelEnabled(v336, 1LL);

              id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              if (v337)
              {
                uint64_t v321 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
                id v322 = [(id)v3 copyDescription];
                _NRLogWithArgs( v321,  1LL,  "%s%.30s:%-4d %@: UrgentLink:read from urgent pipe: %llu packets, %llu bytes",  "",  "NRLinkLinkToNexusLoopUrgent",  5066LL,  v322,  v640,  v639);
LABEL_434:

                id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
              }
            }
          }

          else
          {
            uint64_t v319 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
            int v320 = _NRLogIsLevelEnabled(v319, 17LL);

            id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            if (v320)
            {
              uint64_t v321 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              id v322 = [(id)v3 copyDescription];
              _NRLogWithArgs(v321, 17LL, "%@: Tried to sync nexus output but _nexusOutputRing is NULL", v322);
              goto LABEL_434;
            }
          }
        }

        if (*(void *)(v3 + 1887) && *(void *)(v3 + 1895))
        {
          *(_BYTE *)(v3 + 253) %= *(_BYTE *)(v3 + 252);
          uint64_t v313 = *(void *)(v3 + 1895);
          id v314 = (void *)(v313 + 8LL * *(unsigned __int8 *)(v3 + 253));
          if ((unint64_t)(v314 + 1) <= v313 + 8 * (unint64_t)*(unsigned __int8 *)(v3 + 252))
          {
            if ((v314 & 7) == 0)
            {
              *id v314 = *(void *)(v3 + 1887);
              ++*(_BYTE *)(v3 + 253);
              *(void *)(v3 + 1887) = 0LL;
            }
          }

          else
          {
            id v315 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
            int v316 = _NRLogIsLevelEnabled(v315, 17LL);

            id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            if (v316)
            {
              id v317 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
              id v318 = [(id)v3 copyDescription];
              _NRLogWithArgs( v317,  17LL,  "%@: invalid index for link log list (curIdx: %u)",  v318,  *(unsigned __int8 *)(v3 + 253));

              id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
            }
          }
        }

        *(_BYTE *)(v3 + 226) = v650 & 1;
        uint64_t v16 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
        if (v646 == 0)
        {
          if (!gNRPacketLoggingEnabled) {
            goto LABEL_463;
          }
          uint64_t v385 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
          int v386 = _NRLogIsLevelEnabled(v385, 1LL);

          if (!v386) {
            goto LABEL_463;
          }
          uint64_t v8 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v387);
          id v9 = [(id)v3 copyDescription];
          _NRLogWithArgs( v8,  1LL,  "%s%.30s:%-4d %@: UrgentLink:out of LtN-U outer loop",  "",  "NRLinkLinkToNexusLoopUrgent",  5085LL,  v9);
          goto LABEL_461;
        }

        continue;
      }

      unsigned int v107 = v649;
      if (DWORD2(v675) == 2)
      {
        if (!(_DWORD)v63)
        {
LABEL_566:
          id v578 = sub_100070554();
          int v579 = _NRLogIsLevelEnabled(v578, 16LL);

          if (v579)
          {
            id v580 = sub_100070554();
            _NRLogWithArgs( v580,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 1",  "",  "nrReadTLVLenHBOFromIOVec",  265);
          }

          uint64_t v581 = _os_log_pack_size(12LL);
          v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          v582 = __error();
          uint64_t v410 = _os_log_pack_fill( v399,  v581,  *v582,  &_mh_execute_header,  "%{public}s Assertion Failed: numIOVecs > 1");
          *(_DWORD *)uint64_t v410 = 136446210;
          v413 = "nrReadTLVLenHBOFromIOVec";
          goto LABEL_484;
        }

        unsigned int v109 = (unsigned __int8 *)v676;
        int v105 = *(unsigned __int8 *)(v675 + 1);
        goto LABEL_134;
      }

      if (DWORD2(v675) == 1)
      {
        if (DWORD2(v676) > 1)
        {
          if ((_DWORD)v63)
          {
            int v105 = *(_WORD *)v676;
            int v106 = HIBYTE(*(unsigned __int16 *)v676);
            goto LABEL_135;
          }

          id v603 = sub_100070554();
          int v604 = _NRLogIsLevelEnabled(v603, 16LL);

          if (v604)
          {
            id v605 = sub_100070554();
            v606 = (void *)createIOVecString(&v675, v103);
            _NRLogWithArgs( v605,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 1; %@",
              "",
              "nrReadTLVLenHBOFromIOVec",
              271LL,
              v606);
          }

          uint64_t v607 = _os_log_pack_size(22LL);
          v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          v608 = __error();
          uint64_t v503 = _os_log_pack_fill( v399,  v607,  *v608,  &_mh_execute_header,  "%{public}s Assertion Failed: numIOVecs > 1; %@");
          uint64_t v505 = createIOVecString(&v675, v103);
          *(_DWORD *)uint64_t v503 = 136446466;
          *(void *)(v503 + 4) = "nrReadTLVLenHBOFromIOVec";
LABEL_534:
          *(_WORD *)(v503 + 12) = 2112;
          *(void *)(v503 + 14) = v505;
          goto LABEL_485;
        }

        if (v63 < 2)
        {
LABEL_526:
          id v491 = sub_100070554();
          int v492 = _NRLogIsLevelEnabled(v491, 16LL);

          if (v492)
          {
            id v493 = sub_100070554();
            v494 = (void *)createIOVecString(&v675, (unsigned __int16)v103);
            _NRLogWithArgs( v493,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 2; %@",
              "",
              "nrReadTLVLenHBOFromIOVec",
              274LL,
              v494);
          }

          uint64_t v495 = _os_log_pack_size(22LL);
          v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v496 = *__error();
          uint64_t v451 = _os_log_pack_fill( v399,  v495,  v496,  &_mh_execute_header,  "%{public}s Assertion Failed: numIOVecs > 2; %@");
        }

        else
        {
          if (DWORD2(v676) == 1)
          {
            unsigned int v109 = (unsigned __int8 *)v677;
            int v105 = *(unsigned __int8 *)v676;
LABEL_134:
            int v106 = *v109;
            goto LABEL_135;
          }

LABEL_529:
          id v497 = sub_100070554();
          int v498 = _NRLogIsLevelEnabled(v497, 16LL);

          if (v498)
          {
            id v499 = sub_100070554();
            v500 = (void *)createIOVecString(&v675, (unsigned __int16)v103);
            _NRLogWithArgs( v499,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[1].len == 1; %@",
              "",
              "nrReadTLVLenHBOFromIOVec",
              275LL,
              v500);
          }

          uint64_t v501 = _os_log_pack_size(22LL);
          v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          uint64_t v502 = *__error();
          uint64_t v451 = _os_log_pack_fill( v399,  v501,  v502,  &_mh_execute_header,  "%{public}s Assertion Failed: ioVecs[1].len == 1; %@");
        }
      }

      else
      {
LABEL_501:
        id v445 = sub_100070554();
        int v446 = _NRLogIsLevelEnabled(v445, 16LL);

        if (v446)
        {
          id v447 = sub_100070554();
          v448 = (void *)createIOVecString(&v675, (unsigned __int16)v103);
          _NRLogWithArgs( v447,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: ioVecs[0].len == 1; %@",
            "",
            "nrReadTLVLenHBOFromIOVec",
            269LL,
            v448);
        }

        uint64_t v449 = _os_log_pack_size(22LL);
        v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v450 = *__error();
        uint64_t v451 = _os_log_pack_fill( v399,  v449,  v450,  &_mh_execute_header,  "%{public}s Assertion Failed: ioVecs[0].len == 1; %@");
      }

      uint64_t v503 = v451;
      uint64_t v504 = (unsigned __int16)v103;
LABEL_533:
      uint64_t v505 = createIOVecString(&v675, v504);
      *(_DWORD *)uint64_t v503 = 136446466;
      *(void *)(v503 + 4) = "nrReadTLVLenHBOFromIOVec";
      goto LABEL_534;
    }

    break;
  }

  uint64_t v97 = v86;
  id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
  int v96 = v86;
LABEL_185:
  uint64_t v59 = *(void *)(v3 + v20) | 0x10000LL;
  *(void *)(v3 + v20) = v59;
  id v17 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
  uint64_t v85 = v651;
  LODWORD(v73) = v653;
  uint64_t v49 = v654;
LABEL_186:
  v652 = v96;
  unint64_t v148 = v656;
  uint64_t v152 = v49 | ((_DWORD)v73 << 8);
  size_t v153 = (unsigned __int16)(v49 | ((_WORD)v73 << 8));
  if (v67)
  {
    int v2 = v652;
    unsigned int v141 = v649;
    goto LABEL_196;
  }

  uint64_t v154 = v59 | 0x400000;
  unsigned int v141 = v649;
LABEL_197:
  size_t v653 = v153;
  uint64_t v654 = v152;
  *(void *)(v3 + v20) = v154;
  *(void *)(v3 + 1407) += v148;
  unint64_t v651 = v85;
  if ((char)v141 < 100)
  {
    if (!(_WORD)v85)
    {
      id v460 = sub_100070554();
      int v461 = _NRLogIsLevelEnabled(v460, 16LL);

      if (v461)
      {
        id v462 = sub_100070554();
        _NRLogWithArgs( v462,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: numIOVecs > 0",  "",  "nrChecksumIOVecInner",  143);
      }

      uint64_t v463 = _os_log_pack_size(12LL);
      v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
      v464 = __error();
      uint64_t v410 = _os_log_pack_fill( v399,  v463,  *v464,  &_mh_execute_header,  "%{public}s Assertion Failed: numIOVecs > 0");
      *(_DWORD *)uint64_t v410 = 136446210;
      v413 = "nrChecksumIOVecInner";
      goto LABEL_484;
    }

    unsigned int v641 = (unsigned __int16)v85;
    v644 = &v636;
    uint64_t v168 = 0LL;
    unsigned int v169 = 0;
    uint64_t v3 = 0LL;
    uint64_t v170 = 0LL;
    unsigned int v171 = (unsigned __int16)v152 + 3;
    uint64_t v172 = (unsigned __int16)v85;
    uint64_t v173 = (unsigned int *)v642;
    while (2)
    {
      unsigned int v174 = v171 - v169;
      if (v171 <= v169)
      {
        uint64_t v175 = 0LL;
        goto LABEL_232;
      }

      if (*v173 >= v174) {
        uint64_t v175 = v174;
      }
      else {
        uint64_t v175 = *v173;
      }
      if (!(_DWORD)v175)
      {
        id v394 = sub_100070554();
        int v395 = _NRLogIsLevelEnabled(v394, 16LL);

        v396 = "nrChecksumUpdate";
        if (v395)
        {
          id v397 = sub_100070554();
          _NRLogWithArgs(v397, 16LL, "%s%.30s:%-4d ABORTING: Assertion Failed: dataLen > 0", "", "nrChecksumUpdate", 69);
        }

        uint64_t v398 = _os_log_pack_size(12LL);
        v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v400 = *__error();
        uint64_t v401 = _os_log_pack_fill(v399, v398, v400, &_mh_execute_header, "%{public}s Assertion Failed: dataLen > 0");
        goto LABEL_467;
      }

      uint64_t v176 = (unsigned __int8 *)*((void *)v173 - 1);
      if (!(_DWORD)v3)
      {
        uint64_t v177 = (unsigned __int8 *)*((void *)v173 - 1);
        uint64_t v178 = v175;
        goto LABEL_221;
      }

      LOWORD(v659) = *v176 << 8;
      uint64_t v170 = os_inet_checksum(&v659, 2LL, v170);
      if (v175 >= 2)
      {
        uint64_t v177 = v176 + 1;
        uint64_t v178 = (v175 - 1);
LABEL_221:
        uint64_t v170 = os_inet_checksum(v177, v178, v170);
      }

      if ((v175 & 1) != 0) {
        uint64_t v3 = v3 ^ 1;
      }
      else {
        uint64_t v3 = v3;
      }
      v169 += v175;
      ++v168;
      v173 += 4;
      if (v172 == v168)
      {
        LOWORD(v16_Block_object_dispose(va, 8) = v651;
LABEL_232:
        uint64_t v3 = v648;
        if (v169 == v171)
        {
          uint64_t v179 = (unsigned __int16)v168;
          int v180 = ~(_BYTE)v170;
          int v181 = ((unsigned __int16)~(_WORD)v170 >> 8);
          int v182 = &v675 + v179;
          unsigned int v183 = *((_DWORD *)v182 + 2);
          if (v183 < (int)v175 + 2)
          {
            unsigned __int16 v184 = v651;
            if (v183 < (int)v175 + 1)
            {
              id v514 = sub_100070554();
              int v515 = _NRLogIsLevelEnabled(v514, 16LL);

              if (v515)
              {
                id v516 = sub_100070554();
                v517 = (void *)createIOVecString(&v675, v184);
                _NRLogWithArgs( v516,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: iovecs[iovecIndex].len >= bytesToCheckThisIOVec + 1; %@, iove"
                  "cIndex=%u bytesToCheckThisIOVec=%u",
                  "",
                  "nrChecksumIOVecInner",
                  189LL,
                  v517,
                  v179,
                  v175);
              }

              uint64_t v518 = _os_log_pack_size(34LL);
              v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
              v519 = __error();
              uint64_t v520 = _os_log_pack_fill( v399,  v518,  *v519,  &_mh_execute_header,  "%{public}s Assertion Failed: iovecs[iovecIndex].len >= bytesToCheckThisIOVec + 1; %@, iovecIndex="
                       "%u bytesToCheckThisIOVec=%u");
              v521 = (void *)createIOVecString(&v675, v184);
            }

            else if ((int)v179 + 1 >= v641)
            {
              id v522 = sub_100070554();
              int v523 = _NRLogIsLevelEnabled(v522, 16LL);

              if (v523)
              {
                id v524 = sub_100070554();
                v525 = (void *)createIOVecString(&v675, v184);
                _NRLogWithArgs( v524,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: iovecIndex + 1 < numIOVecs; %@, iovecIndex=%u bytesToCheckThisIOVec=%u",
                  "",
                  "nrChecksumIOVecInner",
                  191LL,
                  v525,
                  v179,
                  v175);
              }

              uint64_t v526 = _os_log_pack_size(34LL);
              v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
              v527 = __error();
              uint64_t v520 = _os_log_pack_fill( v399,  v526,  *v527,  &_mh_execute_header,  "%{public}s Assertion Failed: iovecIndex + 1 < numIOVecs; %@, iovecIndex=%u bytesToCheckThisIOVec=%u");
              v521 = (void *)createIOVecString(&v675, v184);
            }

            else
            {
              id v185 = (unsigned __int8 **)(&v675 + (v179 + 1));
              if (*((_DWORD *)v185 + 2))
              {
                if (*(unsigned __int8 *)(*(void *)v182 + v175) != v180 || **v185 != v181)
                {
                  id v535 = sub_100070554();
                  int v536 = _NRLogIsLevelEnabled(v535, 16LL);

                  if (v536)
                  {
                    id v513 = sub_100070554();
                    _NRLogWithArgs( v513,  16LL,  "%s%.30s:%-4d checksum failed disjoint IOVec received 0x%02x%02x != computed 0x%02x%02x",  "");
LABEL_550:
                  }

                  goto LABEL_551;
                }

LABEL_242:
                id v17 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
                goto LABEL_246;
              }

              id v528 = sub_100070554();
              int v529 = _NRLogIsLevelEnabled(v528, 16LL);

              if (v529)
              {
                id v530 = sub_100070554();
                v531 = (void *)createIOVecString(&v675, v184);
                _NRLogWithArgs( v530,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: iovecs[iovecIndex + 1].len >= 1; %@, iovecIndex=%u bytesToCheckThisIOVec=%u",
                  "",
                  "nrChecksumIOVecInner",
                  193LL,
                  v531,
                  v179,
                  v175);
              }

              uint64_t v532 = _os_log_pack_size(34LL);
              v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
              v533 = __error();
              uint64_t v520 = _os_log_pack_fill( v399,  v532,  *v533,  &_mh_execute_header,  "%{public}s Assertion Failed: iovecs[iovecIndex + 1].len >= 1; %@, iovecIndex=%u bytesToCheckThisIOVec=%u");
              v521 = (void *)createIOVecString(&v675, v184);
            }

            id v534 = v521;
            sub_100043200(v520, (uint64_t)"nrChecksumIOVecInner", (uint64_t)v534, v179, v175);

            goto LABEL_485;
          }

          id v186 = (unsigned __int8 *)(*(void *)v182 + v175);
          unsigned __int16 v184 = v651;
          if (*v186 == v180 && v186[1] == v181) {
            goto LABEL_242;
          }
LABEL_536:
          id v511 = sub_100070554();
          int v512 = _NRLogIsLevelEnabled(v511, 16LL);

          if (v512)
          {
            id v513 = sub_100070554();
            _NRLogWithArgs( v513,  16LL,  "%s%.30s:%-4d checksum failed same IOVec received 0x%02x%02x != computed 0x%02x%02x",  "");
            goto LABEL_550;
          }

            uint64_t v3 = v631;
            uint64_t v20 = v642;
            goto LABEL_243;
          }

          uint64_t v451 = sub_100070554();
          id v452 = _NRLogIsLevelEnabled(v451, 16LL);

          uint64_t v379 = "nrChecksumIOVecInner";
          if (v452)
          {
            char v453 = sub_100070554();
            _NRLogWithArgs( v453,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: computedBytes == writtenLength",  "",  "nrChecksumIOVecInner",  164);
          }

          id v454 = _os_log_pack_size(12LL);
          uint64_t v382 = (char *)&v621 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
          id v455 = *__error();
          uint64_t v384 = _os_log_pack_fill( v382,  v454,  v455,  &_mh_execute_header,  "%{public}s Assertion Failed: computedBytes == writtenLength");
LABEL_459:
          *(_DWORD *)uint64_t v384 = 136446210;
          *(void *)(v384 + 4) = v379;
          goto LABEL_477;
        }
      }
    }

    if (!(_WORD)v82) {
      goto LABEL_494;
    }
    uint64_t v152 = 0LL;
    size_t v153 = 0LL;
    uint64_t v154 = bswap32(v147);
    BOOL v155 = (v632 >> 4) ^ HIWORD(v154);
    BOOL v156 = (16 * v632) ^ HIBYTE(v154);
    uint64_t v157 = 16LL * (unsigned __int16)v82;
    uint64_t v636 = (uint64_t *)((unsigned __int16)v147 + 3);
    uint64_t v158 = (unsigned __int16)v147 + 3;
    while (2)
    {
      unsigned int v159 = *(_DWORD *)((char *)&v660 + v152 + 8);
      if (v158)
      {
        if (v158 > v159)
        {
          v158 -= v159;
        }

        else
        {
          if (v158 < v159) {
            break;
          }
          uint64_t v158 = 0;
        }

LABEL_551:
          v537 = *(id *)(v3 + 1863);
          if (v537) {
            v537[96] = 1;
          }

          v539 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v538);
          char v540 = _NRLogIsLevelEnabled(v539, 17LL);

          uint64_t v542 = v649;
          if ((v540 & 1) != 0)
          {
            uint64_t v657 = _NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v541);
            id v543 = [(id)v3 copyDescription];
            v544 = (void *)createStringFromNRTLVType(v542);
            unsigned __int16 v545 = v654;
            uint64_t v655 = (unsigned __int16)v654;
            size_t v653 = *(unsigned int *)(v3 + 319);
            uint64_t v546 = *(unsigned int *)(v3 + 323);
            unsigned __int16 v547 = v651;
            v548 = (void *)createIOVecString(&v675, (unsigned __int16)v651);
            uint64_t v658 = (unsigned __int16)v647;
            uint64_t v634 = v546;
            uint64_t v549 = v545;
            uint64_t v542 = v649;
            v550 = (void *)v657;
            _NRLogWithArgs( v657,  17LL,  "%@: Invalid checksum detected in urgent loop on read type %@ len %u filledIn=%u handled=%u in %@ ioVecCont entLen=%u alreadyRead=%u curLinkInputSlot=%p",  v543,  v544,  v549,  v653,  v634,  v548,  v656,  (unsigned __int16)v647,  v652);
          }

          else
          {
            uint64_t v658 = (unsigned __int16)v647;
            unsigned __int16 v547 = v651;
          }

          v551 = (void *)createStringFromNRTLVType(v542);
          v552 = (void *)createIOVecString(&v675, v547);
          sub_1000749CC( (void *)v3,  @"Invalid checksum detected in urgent loop on read type %@ len %u filledIn=%u handled=%u in %@ ioVecContentLen=%u alreadyRead=%u curLinkInputSlot=%p",  v553,  v554,  v555,  v556,  v557,  v558,  (uint64_t)v551);

          goto LABEL_463;
        }

        id v474 = sub_100070554();
        int v475 = _NRLogIsLevelEnabled(v474, 16LL);

        v396 = "nrChecksumIOVecInner";
        if (v475)
        {
          id v476 = sub_100070554();
          _NRLogWithArgs( v476,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: computedBytes == writtenLength",  "",  "nrChecksumIOVecInner",  164);
        }

        uint64_t v477 = _os_log_pack_size(12LL);
        v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
        uint64_t v478 = *__error();
        uint64_t v401 = _os_log_pack_fill( v399,  v477,  v478,  &_mh_execute_header,  "%{public}s Assertion Failed: computedBytes == writtenLength");
LABEL_467:
        *(_DWORD *)uint64_t v401 = 136446210;
        *(void *)(v401 + 4) = v396;
        goto LABEL_485;
      }

      continue;
    }
  }

  if (!(_WORD)v85) {
    goto LABEL_506;
  }
  uint64_t v157 = 0LL;
  uint64_t v158 = 0LL;
  unsigned int v159 = bswap32(v152);
  int v160 = (v141 >> 4) ^ HIWORD(v159);
  int v161 = (16 * v141) ^ HIBYTE(v159);
  uint64_t v162 = (unsigned __int16)v152 + 3;
  uint64_t v163 = 16LL * (unsigned __int16)v85;
  unsigned int v164 = (unsigned __int16)v152 + 3;
  while (2)
  {
    unsigned int v165 = *(_DWORD *)((char *)&v675 + v157 + 8);
    if (v164)
    {
      if (v164 > v165)
      {
        v164 -= v165;
      }

      else
      {
        if (v164 < v165) {
          break;
        }
        unsigned int v164 = 0;
      }

LABEL_201:
      v157 += 16LL;
      if (v163 == v157) {
        goto LABEL_243;
      }
      continue;
    }

    break;
  }

  unsigned int v166 = v165 - v164;
  else {
    size_t v167 = v166;
  }
  memcpy((char *)&v659 + v158, (const void *)(*(void *)((char *)&v675 + v157) + v164), v167);
  uint64_t v158 = (v167 + v158);
  if (v158 <= 1)
  {
    unsigned int v164 = 0;
    goto LABEL_201;
  }

LABEL_243:
  uint64_t v3 = v648;
  if ((_DWORD)v158 != 2)
  {
    id v465 = sub_100070554();
    int v466 = _NRLogIsLevelEnabled(v465, 16LL);

    unsigned __int16 v467 = v651;
    if (v466)
    {
      id v468 = sub_100070554();
      v469 = (void *)createIOVecString(&v675, v467);
      _NRLogWithArgs( v468,  16LL,  "%s%.30s:%-4d ABORTING: Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@",
        "",
        "nrWriteIOVecToBuffer",
        342LL,
        v158,
        2LL,
        v162,
        v469);
    }

    uint64_t v470 = _os_log_pack_size(40LL);
    v399 = (char *)&v636 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0LL);
    v471 = __error();
    uint64_t v472 = _os_log_pack_fill( v399,  v470,  *v471,  &_mh_execute_header,  "%{public}s Assertion Failed: bytesWritten == length; bytesWritten (%u) != length (%u), offset: %u, ioVec: %@");
    id v473 = (id)createIOVecString(&v675, v467);
    sub_1000431C4(v472, (uint64_t)"nrWriteIOVecToBuffer", v158, 2, v162, (uint64_t)v473);

    goto LABEL_485;
  }

  BOOL v82 = (unsigned __int16)v659 == (unsigned __int16)(v160 | (unsigned __int16)((_WORD)v161 << 8));
  id v17 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
  unsigned __int16 v184 = v651;
  if (!v82) {
    goto LABEL_551;
  }
LABEL_246:
  uint64_t v187 = os_channel_get_next_slot(*(void *)(v3 + 687), v646, &v659);
  id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
  if (!v187)
  {
    uint64_t v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
    uint64_t v195 = v655;
    uint64_t v19 = v647;
    unsigned int v196 = v643;
    if (*(_BYTE *)(v3 + 217) && *(void *)(v3 + 703))
    {
      *(_BYTE *)(v3 + 217) = 0;
      ++*(void *)(v3 + 719);
      if (gNRPacketLoggingEnabled)
      {
        id v271 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
        int v272 = _NRLogIsLevelEnabled(v271, 1LL);

        unsigned int v196 = v643;
        if (v272)
        {
          id v274 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v273);
          id v275 = [(id)v3 copyDescription];
          _NRLogWithArgs( v274,  1LL,  "%s%.30s:%-4d %@: source-resume: NexusVIOutput",  "",  "NRLinkResumeNexusVIOutputSource",  847LL,  v275);

          unsigned int v196 = v643;
        }
      }

      dispatch_resume(*(dispatch_object_t *)(v3 + 703));
      uint64_t v19 = v647;
    }

    unsigned int v197 = v645;
    unsigned int v198 = v196 > v645;
    uint64_t v199 = *(void *)(v3 + v195) | 0x800000LL;
    *(void *)(v3 + v195) = v199;
    if (v198 < v184)
    {
      uint64_t v200 = v196 > v197;
      id v201 = (unsigned int *)&v642[16 * v200];
      do
      {
        if (gNRPacketLoggingEnabled)
        {
          int v205 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
          int v206 = _NRLogIsLevelEnabled(v205, 1LL);

          unsigned int v196 = v643;
          if (v206)
          {
            uint64_t v208 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v207);
            id v209 = [(id)v3 copyDescription];
            _NRLogWithArgs( v208,  1LL,  "%s%.30s:%-4d %@: UrgentLink:no nexusOutputSlot - consolidating %u bytes from linkInputSlot ioVecs[%u].buf= %p to linkReadBuffer filledIn=%u handled=%u",  "",  "NRLinkLinkToNexusLoopUrgent",  4836LL,  v209,  *v201,  v200,  *((void *)v201 - 1),  *(unsigned int *)(v3 + v17[287]),  *(unsigned int *)(v3 + 323));

            unsigned int v196 = v643;
          }
        }

        uint64_t v202 = *(unsigned int *)(v3 + v17[287]);
        size_t v203 = *v201;
        if ((v203 + v202) >= *(_DWORD *)(v3 + 267))
        {
          *(void *)(v3 + v195) |= 0x1000000uLL;
          uint64_t v8 = (void *)createIOVecString(&v675, (unsigned __int16)v651);
          sub_1000749CC( (void *)v3,  @"no nexusOutputSlot and linkReadBuffer is full %@ filledIn=%u handled=%u",  v402,  v403,  v404,  v405,  v406,  v407,  (uint64_t)v8);
          goto LABEL_462;
        }

        memcpy((void *)(*(void *)(v3 + 1319) + v202), *((const void **)v201 - 1), v203);
        unsigned int v204 = *v201;
        v201 += 4;
        *(_DWORD *)(v3 + v17[287]) += v204;
        ++v200;
      }

      while (v184 != v200);
      uint64_t v199 = *(void *)(v3 + v195);
      id v18 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      uint64_t v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      uint64_t v19 = v647;
      unsigned __int16 v184 = v651;
      unsigned int v197 = v645;
    }

    if (v196 <= v197 || v184 != 1)
    {
      *(void *)(v3 + v195) = v199 | 0x4000000;
      *((void *)&v646 + 1) = v652;
      goto LABEL_15;
    }

    *(void *)(v3 + v195) = v199 | 0x2000000;
    if ((_WORD)v19 && (unsigned __int16)v658 > (unsigned __int16)v19)
    {
      unsigned __int16 v285 = v658 - v19;
      if (gNRPacketLoggingEnabled)
      {
        __int128 v371 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
        int v372 = _NRLogIsLevelEnabled(v371, 1LL);

        LOWORD(v19) = v647;
        if (v372)
        {
          __int128 v374 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v373);
          id v375 = [(id)v3 copyDescription];
          _NRLogWithArgs( v374,  1LL,  "%s%.30s:%-4d %@: UrgentLink:no nexusOutputSlot - tail consolidating %u bytes from linkInputSlot to linkReadB uffer filledIn=%u handled=%u and marking curLinkInputSlot=%p as completed",  "",  "NRLinkLinkToNexusLoopUrgent",  4870LL,  v375,  v285,  *(unsigned int *)(v3 + v17[287]),  *(unsigned int *)(v3 + 323),  v652);

          LOWORD(v19) = v647;
        }
      }

      memcpy( (void *)(*(void *)(v3 + 1319) + *(unsigned int *)(v3 + v17[287])),  (const void *)(v657 + (unsigned __int16)v19),  v285);
      *(_DWORD *)(v3 + v17[287]) += v285;
      *((void *)&v646 + 1) = v652;
    }

    goto LABEL_394;
  }

  uint64_t v188 = v187;
  uint64_t v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
  uint64_t v189 = v655;
  if (v643 > v645)
  {
    if (gNRPacketLoggingEnabled)
    {
      id v261 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
      int v262 = _NRLogIsLevelEnabled(v261, 1LL);

      uint64_t v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      if (v262)
      {
        uint64_t v263 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
        id v264 = [(id)v3 copyDescription];
        _NRLogWithArgs( v263,  1LL,  "%s%.30s:%-4d %@: UrgentLink:Advancing linkReadBuffer handled by %u handled=%u filledIn=%u",  "",  "NRLinkLinkToNexusLoopUrgent",  4893LL,  v264,  DWORD2(v675),  *(unsigned int *)(v3 + 323),  *(unsigned int *)(v3 + 319));

        uint64_t v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
      }
    }

    *(_DWORD *)(v3 + 323) += DWORD2(v675);
    id v17 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
  }

  id v190 = &OBJC_IVAR___NRLinkBluetooth__recvUncompressedIP;
  switch(v649)
  {
    case 1u:
      uint64_t v191 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
      int v192 = _NRLogIsLevelEnabled(v191, 1LL);

      if (v192)
      {
        uint64_t v193 = (void *)_NRCopyLogObjectForNRUUID(*(void *)(v3 + 32), v2);
        id v194 = [(id)v3 copyDescription];
        _NRLogWithArgs( v193,  1LL,  "%s%.30s:%-4d %@: Handling PadN %u",  "",  "NRLinkLinkToNexusLoopUrgent",  4922LL,  v194,  (unsigned __int16)v654);
      }

      goto LABEL_308;
    case 2u:
      goto LABEL_294;
    case 3u:
      id v190 = &OBJC_IVAR___NRLinkBluetooth__recvEncapsulated6LoWPAN;
      goto LABEL_294;
    case 4u:
      if (!(_WORD)v654)
      {
        id v253 = objc_alloc_init(&OBJC_CLASS___NSData);
LABEL_342:
        uint64_t v254 = v253;
        uint64_t v10 = &OBJC_IVAR___NRPreferWiFiAgent_networkProvider;
        uint64_t v189 = v655;
        if ((v650 & 1) != 0)
        {
          -[NSData bytes](v253, "bytes");
          -[NSData length](v254, "length");
          if (qword_1001DC9E8 != -1) {
            dispatch_once(&qword_1001DC9E8, &stru_1001AFB78);
          }
          uint64_t v255 = (dispatch_queue_s *)(id)qword_1001DC9E0;
          v668 = _NSConcreteStackBlock;
          uint64_t v669 = 3221225472LL;
          v670 = sub_10008BBD0;
          v671 = &unk_1001B0578;
          unint64_t v672 = 0LL;
          dispatch_async(v255, &v668);
        }

        *(void *)(v3 + v189) |= 0x20000000uLL;
        sub_10008BC7C(v3, v254);

        LODWORD(v650) = 0;
        goto LABEL_308;
      }

      id v210 = (char *)malloc(v653);
      if (!v210)
      {
        id v596 = sub_100070554();
        int v597 = _NRLogIsLevelEnabled(v596, 16LL);

        if (v597)
        {
          id v598 = sub_100070554();
          _NRLogWithArgs(v598, 16LL, "%s%.30s:%-4d ABORTING: strict_malloc(%zu) failed", "", "strict_malloc", 79, v653);
        }