uint64_t handleConstrained(void *a1)
{
  id v1;
  void *v2;
  const char *string;
  uint64_t v4;
  void *v5;
  int v6;
  int v7;
  os_log_s *v8;
  const char *v9;
  int v10;
  id v11;
  char *v12;
  os_log_s *v13;
  os_log_type_t v14;
  const char *v15;
  int v16;
  os_log_s *v17;
  const char *v18;
  os_log_s *v19;
  os_log_s *v20;
  char *v21;
  os_log_type_t v22;
  BOOL v23;
  void *v24;
  os_log_s *v25;
  os_log_type_t v26;
  const char *v27;
  os_log_s *v28;
  os_log_type_t v29;
  char *backtrace_string;
  BOOL v31;
  char v33;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v36;
  __int16 v37;
  _BYTE v38[20];
  int v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  v42 = *MEMORY[0x1895F89C0];
  v1 = a1;
  [v1 request];
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  string = xpc_dictionary_get_string(v2, (const char *)networkd_privileged_key_interface_name);

  v40 = 0u;
  v41 = 0u;
  if (!string || strlen(string) > 0x10)
  {
    v4 = 22LL;
    goto LABEL_56;
  }

  __strlcpy_chk();
  [v1 request];
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(v41) = xpc_dictionary_get_BOOL(v5, (const char *)networkd_privileged_key_constrained);

  v6 = socket(2, 2, 0);
  if ((v6 & 0x80000000) == 0)
  {
    v7 = v6;
    if (ioctl(v6, 0xC02069CDuLL, &v40) != -1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v36 = "handleConstrained";
        *(_DWORD *)buf = 136446722;
        if ((_DWORD)v41) {
          v9 = "Set";
        }
        else {
          v9 = "Cleared";
        }
        v37 = 2082;
        *(void *)v38 = v9;
        *(_WORD *)&v38[8] = 2082;
        *(void *)&v38[10] = &v40;
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEFAULT,  "%{public}s Successfully %{public}s constrained on %{public}s",  buf,  0x20u);
      }

      v4 = 0LL;
LABEL_55:
      close(v7);
      goto LABEL_56;
    }

    v16 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v18 = "set";
      v36 = "handleConstrained";
      *(_DWORD *)buf = 136446978;
      v37 = 2082;
      if (!(_DWORD)v41) {
        v18 = "clear";
      }
      *(void *)v38 = v18;
      *(_WORD *)&v38[8] = 2082;
      *(void *)&v38[10] = &v40;
      *(_WORD *)&v38[18] = 1024;
      v39 = v16;
      _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEFAULT,  "%{public}s Failed to %{public}s constrained on %{public}s: %{darwin.errno}d",  buf,  0x26u);
    }

    v4 = v16;

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = (os_log_s *)(id)gLogObj;
    v20 = v19;
    if (v16 == 6)
    {
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v36 = "handleConstrained";
        v37 = 1024;
        *(_DWORD *)v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = 6;
        _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_ERROR,  "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d",  buf,  0x18u);
      }

      goto LABEL_55;
    }

    *(_DWORD *)buf = 136446722;
    v36 = "handleConstrained";
    v37 = 1024;
    *(_DWORD *)v38 = v7;
    *(_WORD *)&v38[4] = 1024;
    *(_DWORD *)&v38[6] = v16;
    v24 = (void *)_os_log_send_and_compose_impl();

    type = OS_LOG_TYPE_ERROR;
    v33 = 0;
    if (!__nwlog_fault((const char *)v24, &type, &v33))
    {
LABEL_53:
      if (v24) {
        free(v24);
      }
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446722;
        v36 = "handleConstrained";
        v37 = 1024;
        *(_DWORD *)v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v16;
        v27 = "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d";
LABEL_51:
        _os_log_impl(&dword_181A5C000, v25, v26, v27, buf, 0x18u);
      }
    }

    else
    {
      if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        v26 = type;
        v31 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136446978;
            v36 = "handleConstrained";
            v37 = 1024;
            *(_DWORD *)v38 = v7;
            *(_WORD *)&v38[4] = 1024;
            *(_DWORD *)&v38[6] = v16;
            *(_WORD *)&v38[10] = 2082;
            *(void *)&v38[12] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v25,  v26,  "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x22u);
          }

          free(backtrace_string);
          goto LABEL_53;
        }

        if (!v31) {
          goto LABEL_52;
        }
        *(_DWORD *)buf = 136446722;
        v36 = "handleConstrained";
        v37 = 1024;
        *(_DWORD *)v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v16;
        v27 = "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d, no backtrace";
        goto LABEL_51;
      }

      __nwlog_obj();
      v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446722;
        v36 = "handleConstrained";
        v37 = 1024;
        *(_DWORD *)v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v16;
        v27 = "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_51;
      }
    }

uint64_t handleUltraConstrained(void *a1)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  [v1 request];
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  string = xpc_dictionary_get_string(v2, (const char *)networkd_privileged_key_interface_name);

  __int128 v40 = 0u;
  __int128 v41 = 0u;
  if (!string || strlen(string) > 0x10)
  {
    uint64_t v4 = 22LL;
    goto LABEL_56;
  }

  __strlcpy_chk();
  [v1 request];
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(v41) = xpc_dictionary_get_BOOL(v5, (const char *)networkd_privileged_key_constrained);

  int v6 = socket(2, 2, 0);
  if ((v6 & 0x80000000) == 0)
  {
    int v7 = v6;
    if (ioctl(v6, 0xC02069DBuLL, &v40) != -1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v36 = "handleUltraConstrained";
        *(_DWORD *)buf = 136446722;
        if ((_DWORD)v41) {
          v9 = "Set";
        }
        else {
          v9 = "Cleared";
        }
        __int16 v37 = 2082;
        *(void *)v38 = v9;
        *(_WORD *)&v38[8] = 2082;
        *(void *)&v38[10] = &v40;
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEFAULT,  "%{public}s Successfully %{public}s ultra constrained on %{public}s",  buf,  0x20u);
      }

      uint64_t v4 = 0LL;
LABEL_55:
      close(v7);
      goto LABEL_56;
    }

    int v16 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v18 = "set";
      v36 = "handleUltraConstrained";
      *(_DWORD *)buf = 136446978;
      __int16 v37 = 2082;
      if (!(_DWORD)v41) {
        v18 = "clear";
      }
      *(void *)v38 = v18;
      *(_WORD *)&v38[8] = 2082;
      *(void *)&v38[10] = &v40;
      *(_WORD *)&v38[18] = 1024;
      int v39 = v16;
      _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEFAULT,  "%{public}s Failed to %{public}s ultra constrained on %{public}s: %{darwin.errno}d",  buf,  0x26u);
    }

    uint64_t v4 = v16;

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = (os_log_s *)(id)gLogObj;
    v20 = v19;
    if (v16 == 6)
    {
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v36 = "handleUltraConstrained";
        __int16 v37 = 1024;
        *(_DWORD *)v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = 6;
        _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_ERROR,  "%{public}s ioctl(%d, SIOCSIFULTRACONSTRAINED, ...) failed %{darwin.errno}d",  buf,  0x18u);
      }

      goto LABEL_55;
    }

    *(_DWORD *)buf = 136446722;
    v36 = "handleUltraConstrained";
    __int16 v37 = 1024;
    *(_DWORD *)v38 = v7;
    *(_WORD *)&v38[4] = 1024;
    *(_DWORD *)&v38[6] = v16;
    v24 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault((const char *)v24, &type, &v33))
    {
LABEL_53:
      if (v24) {
        free(v24);
      }
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446722;
        v36 = "handleUltraConstrained";
        __int16 v37 = 1024;
        *(_DWORD *)v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v16;
        v27 = "%{public}s ioctl(%d, SIOCSIFULTRACONSTRAINED, ...) failed %{darwin.errno}d";
LABEL_51:
        _os_log_impl(&dword_181A5C000, v25, v26, v27, buf, 0x18u);
      }
    }

    else
    {
      if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v26 = type;
        BOOL v31 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136446978;
            v36 = "handleUltraConstrained";
            __int16 v37 = 1024;
            *(_DWORD *)v38 = v7;
            *(_WORD *)&v38[4] = 1024;
            *(_DWORD *)&v38[6] = v16;
            *(_WORD *)&v38[10] = 2082;
            *(void *)&v38[12] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v25,  v26,  "%{public}s ioctl(%d, SIOCSIFULTRACONSTRAINED, ...) failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x22u);
          }

          free(backtrace_string);
          goto LABEL_53;
        }

        if (!v31) {
          goto LABEL_52;
        }
        *(_DWORD *)buf = 136446722;
        v36 = "handleUltraConstrained";
        __int16 v37 = 1024;
        *(_DWORD *)v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v16;
        v27 = "%{public}s ioctl(%d, SIOCSIFULTRACONSTRAINED, ...) failed %{darwin.errno}d, no backtrace";
        goto LABEL_51;
      }

      __nwlog_obj();
      v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446722;
        v36 = "handleUltraConstrained";
        __int16 v37 = 1024;
        *(_DWORD *)v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v16;
        v27 = "%{public}s ioctl(%d, SIOCSIFULTRACONSTRAINED, ...) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_51;
      }
    }

uint64_t handleExpensive(void *a1)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  [v1 request];
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  string = xpc_dictionary_get_string(v2, (const char *)networkd_privileged_key_interface_name);

  __int128 v40 = 0u;
  __int128 v41 = 0u;
  if (!string || strlen(string) > 0x10)
  {
    uint64_t v4 = 22LL;
    goto LABEL_56;
  }

  __strlcpy_chk();
  [v1 request];
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(v41) = xpc_dictionary_get_BOOL(v5, (const char *)networkd_privileged_key_expensive);

  int v6 = socket(2, 2, 0);
  if ((v6 & 0x80000000) == 0)
  {
    int v7 = v6;
    if (ioctl(v6, 0xC02069A1uLL, &v40) != -1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      v8 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v36 = "handleExpensive";
        *(_DWORD *)buf = 136446722;
        if ((_DWORD)v41) {
          v9 = "Set";
        }
        else {
          v9 = "Cleared";
        }
        __int16 v37 = 2082;
        *(void *)v38 = v9;
        *(_WORD *)&v38[8] = 2082;
        *(void *)&v38[10] = &v40;
        _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEFAULT,  "%{public}s Successfully %{public}s expensive on %{public}s",  buf,  0x20u);
      }

      uint64_t v4 = 0LL;
LABEL_55:
      close(v7);
      goto LABEL_56;
    }

    int v16 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v17 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v18 = "set";
      v36 = "handleExpensive";
      *(_DWORD *)buf = 136446978;
      __int16 v37 = 2082;
      if (!(_DWORD)v41) {
        v18 = "clear";
      }
      *(void *)v38 = v18;
      *(_WORD *)&v38[8] = 2082;
      *(void *)&v38[10] = &v40;
      *(_WORD *)&v38[18] = 1024;
      int v39 = v16;
      _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEFAULT,  "%{public}s Failed to %{public}s expensive on %{public}s: %{darwin.errno}d",  buf,  0x26u);
    }

    uint64_t v4 = v16;

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v19 = (os_log_s *)(id)gLogObj;
    v20 = v19;
    if (v16 == 6)
    {
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v36 = "handleExpensive";
        __int16 v37 = 1024;
        *(_DWORD *)v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = 6;
        _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_ERROR,  "%{public}s ioctl(%d, SIOCSIFEXPENSIVE, ...) failed %{darwin.errno}d",  buf,  0x18u);
      }

      goto LABEL_55;
    }

    *(_DWORD *)buf = 136446722;
    v36 = "handleExpensive";
    __int16 v37 = 1024;
    *(_DWORD *)v38 = v7;
    *(_WORD *)&v38[4] = 1024;
    *(_DWORD *)&v38[6] = v16;
    v24 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault((const char *)v24, &type, &v33))
    {
LABEL_53:
      if (v24) {
        free(v24);
      }
      goto LABEL_55;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446722;
        v36 = "handleExpensive";
        __int16 v37 = 1024;
        *(_DWORD *)v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v16;
        v27 = "%{public}s ioctl(%d, SIOCSIFEXPENSIVE, ...) failed %{darwin.errno}d";
LABEL_51:
        _os_log_impl(&dword_181A5C000, v25, v26, v27, buf, 0x18u);
      }
    }

    else
    {
      if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v26 = type;
        BOOL v31 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136446978;
            v36 = "handleExpensive";
            __int16 v37 = 1024;
            *(_DWORD *)v38 = v7;
            *(_WORD *)&v38[4] = 1024;
            *(_DWORD *)&v38[6] = v16;
            *(_WORD *)&v38[10] = 2082;
            *(void *)&v38[12] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v25,  v26,  "%{public}s ioctl(%d, SIOCSIFEXPENSIVE, ...) failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x22u);
          }

          free(backtrace_string);
          goto LABEL_53;
        }

        if (!v31) {
          goto LABEL_52;
        }
        *(_DWORD *)buf = 136446722;
        v36 = "handleExpensive";
        __int16 v37 = 1024;
        *(_DWORD *)v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v16;
        v27 = "%{public}s ioctl(%d, SIOCSIFEXPENSIVE, ...) failed %{darwin.errno}d, no backtrace";
        goto LABEL_51;
      }

      __nwlog_obj();
      v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446722;
        v36 = "handleExpensive";
        __int16 v37 = 1024;
        *(_DWORD *)v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v16;
        v27 = "%{public}s ioctl(%d, SIOCSIFEXPENSIVE, ...) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_51;
      }
    }

uint64_t handleSetupFakeEthernetPair(void *a1)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  [v1 request];
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  string = xpc_dictionary_get_string(v2, (const char *)networkd_privileged_key_interface_name);

  if (string)
  {
    if (strlen(string) <= 0x10)
    {
      [v1 request];
      uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
      v5 = xpc_dictionary_get_string(v4, (const char *)networkd_privileged_key_second_interface_name);

      if (v5)
      {
        if (strlen(v5) <= 0x10)
        {
          int v8 = socket(2, 2, 0);
          if ((v8 & 0x80000000) == 0)
          {
            int v9 = v8;
            LODWORD(v6) = setupFakeEthernet(v8, (uint64_t)string);
            if ((_DWORD)v6)
            {
LABEL_23:
              close(v9);
LABEL_32:
              uint64_t v6 = (int)v6;
              goto LABEL_6;
            }

            int v10 = setupFakeEthernet(v9, (uint64_t)v5);
            if (v10)
            {
              LODWORD(v6) = v10;
              int v11 = v9;
              uint64_t v12 = (uint64_t)string;
LABEL_11:
              teardownFakeEthernet(v11, v12);
              goto LABEL_23;
            }

            v50[0] = 0u;
            __int128 v48 = 0u;
            __int128 v49 = 0u;
            __int128 v46 = 0u;
            __int128 v47 = 0u;
            __int128 v44 = 0u;
            __int128 v45 = 0u;
            __int128 v42 = 0u;
            __int128 v43 = 0u;
            memset(buf, 0, sizeof(buf));
            __strlcpy_chk();
            v50[1] = xmmword_18272D7A0;
            v51 = buf;
            __strlcpy_chk();
            if ((ioctl(v9, 0x8028697BuLL, v50) & 0x80000000) == 0)
            {
              LODWORD(v6) = 0;
              goto LABEL_23;
            }

            LODWORD(v6) = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
            __nwlog_obj();
            v20 = (void *)objc_claimAutoreleasedReturnValue();
            *(_DWORD *)os_log_type_t type = 136447234;
            v30 = "handleSetupFakeEthernetPair";
            __int16 v31 = 1024;
            int v32 = v9;
            __int16 v33 = 2082;
            v34 = string;
            __int16 v35 = 2082;
            v36 = v5;
            __int16 v37 = 1024;
            int v38 = v6;
            v21 = (void *)_os_log_send_and_compose_impl();

            os_log_type_t v28 = OS_LOG_TYPE_ERROR;
            char v27 = 0;
            if (!__nwlog_fault((const char *)v21, &v28, &v27))
            {
LABEL_48:
              if (v21) {
                free(v21);
              }
              teardownFakeEthernet(v9, (uint64_t)string);
              int v11 = v9;
              uint64_t v12 = (uint64_t)v5;
              goto LABEL_11;
            }

            if (v28 == OS_LOG_TYPE_FAULT)
            {
              __nwlog_obj();
              os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v23 = v28;
              if (os_log_type_enabled(v22, v28))
              {
                *(_DWORD *)os_log_type_t type = 136447234;
                v30 = "handleSetupFakeEthernetPair";
                __int16 v31 = 1024;
                int v32 = v9;
                __int16 v33 = 2082;
                v34 = string;
                __int16 v35 = 2082;
                v36 = v5;
                __int16 v37 = 1024;
                int v38 = v6;
                v24 = "%{public}s ioctl(%d, SIOCSDRVSPEC, %{public}s<->%{public}s) failed %{darwin.errno}d";
LABEL_46:
                _os_log_impl(&dword_181A5C000, v22, v23, v24, (uint8_t *)type, 0x2Cu);
              }
            }

            else
            {
              if (v27)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v23 = v28;
                BOOL v26 = os_log_type_enabled(v22, v28);
                if (backtrace_string)
                {
                  if (v26)
                  {
                    *(_DWORD *)os_log_type_t type = 136447490;
                    v30 = "handleSetupFakeEthernetPair";
                    __int16 v31 = 1024;
                    int v32 = v9;
                    __int16 v33 = 2082;
                    v34 = string;
                    __int16 v35 = 2082;
                    v36 = v5;
                    __int16 v37 = 1024;
                    int v38 = v6;
                    __int16 v39 = 2082;
                    __int128 v40 = backtrace_string;
                    _os_log_impl( &dword_181A5C000,  v22,  v23,  "%{public}s ioctl(%d, SIOCSDRVSPEC, %{public}s<->%{public}s) failed %{darwin.errno}d, dumping backtrace:%{public}s",  (uint8_t *)type,  0x36u);
                  }

                  free(backtrace_string);
                  goto LABEL_48;
                }

                if (!v26) {
                  goto LABEL_47;
                }
                *(_DWORD *)os_log_type_t type = 136447234;
                v30 = "handleSetupFakeEthernetPair";
                __int16 v31 = 1024;
                int v32 = v9;
                __int16 v33 = 2082;
                v34 = string;
                __int16 v35 = 2082;
                v36 = v5;
                __int16 v37 = 1024;
                int v38 = v6;
                v24 = "%{public}s ioctl(%d, SIOCSDRVSPEC, %{public}s<->%{public}s) failed %{darwin.errno}d, no backtrace";
                goto LABEL_46;
              }

              __nwlog_obj();
              os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v23 = v28;
              if (os_log_type_enabled(v22, v28))
              {
                *(_DWORD *)os_log_type_t type = 136447234;
                v30 = "handleSetupFakeEthernetPair";
                __int16 v31 = 1024;
                int v32 = v9;
                __int16 v33 = 2082;
                v34 = string;
                __int16 v35 = 2082;
                v36 = v5;
                __int16 v37 = 1024;
                int v38 = v6;
                v24 = "%{public}s ioctl(%d, SIOCSDRVSPEC, %{public}s<->%{public}s) failed %{darwin.errno}d, backtrace limit exceeded";
                goto LABEL_46;
              }
            }

uint64_t handleTeardownFakeEthernetPair(void *a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  [v1 request];
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  string = xpc_dictionary_get_string(v2, (const char *)networkd_privileged_key_interface_name);

  if (!string
    || strlen(string) > 0x10
    || ([v1 request],
        uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue(),
        v5 = xpc_dictionary_get_string(v4, (const char *)networkd_privileged_key_second_interface_name),
        v4,
        !v5)
    || strlen(v5) > 0x10)
  {
    uint64_t v6 = 22LL;
    goto LABEL_6;
  }

  int v8 = socket(2, 2, 0);
  if ((v8 & 0x80000000) == 0)
  {
    int v9 = v8;
    teardownFakeEthernet(v8, (uint64_t)string);
    teardownFakeEthernet(v9, (uint64_t)v5);
    close(v9);
    uint64_t v6 = 0LL;
    goto LABEL_6;
  }

  int v10 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v11 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  v21 = "handleTeardownFakeEthernetPair";
  __int16 v22 = 1024;
  int v23 = v10;
  uint64_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v12, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        v21 = "handleTeardownFakeEthernetPair";
        __int16 v22 = 1024;
        int v23 = v10;
        v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
LABEL_22:
        _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0x12u);
      }
    }

    else
    {
      if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        BOOL v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446722;
            v21 = "handleTeardownFakeEthernetPair";
            __int16 v22 = 1024;
            int v23 = v10;
            __int16 v24 = 2082;
            v25 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
          }

          free(backtrace_string);
          goto LABEL_24;
        }

        if (!v17) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446466;
        v21 = "handleTeardownFakeEthernetPair";
        __int16 v22 = 1024;
        int v23 = v10;
        v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
        goto LABEL_22;
      }

      __nwlog_obj();
      id v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        v21 = "handleTeardownFakeEthernetPair";
        __int16 v22 = 1024;
        int v23 = v10;
        v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_22;
      }
    }

uint64_t handleThroughputEstimates(void *a1)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  [v1 request];
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  string = xpc_dictionary_get_string(v2, (const char *)networkd_privileged_key_interface_name);

  __int128 v38 = 0u;
  __int128 v39 = 0u;
  if (!string || strlen(string) > 0x10)
  {
    uint64_t v4 = 22LL;
    goto LABEL_51;
  }

  __strlcpy_chk();
  [v1 request];
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v39) = xpc_dictionary_get_uint64(v5, (const char *)networkd_privileged_key_upload);

  [v1 request];
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  BYTE1(v39) = xpc_dictionary_get_uint64(v6, (const char *)networkd_privileged_key_download);

  int v7 = socket(2, 2, 0);
  if ((v7 & 0x80000000) == 0)
  {
    int v8 = v7;
    if (ioctl(v7, 0xC02069D4uLL, &v38) != -1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v9 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        __int16 v35 = "handleThroughputEstimates";
        __int16 v36 = 2082;
        *(void *)__int16 v37 = &v38;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEFAULT,  "%{public}s Successfully set throughput estimate on %{public}s",  buf,  0x16u);
      }

      uint64_t v4 = 0LL;
LABEL_50:
      close(v8);
      goto LABEL_51;
    }

    int v16 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v17 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446722;
      __int16 v35 = "handleThroughputEstimates";
      __int16 v36 = 2082;
      *(void *)__int16 v37 = &v38;
      *(_WORD *)&v37[8] = 1024;
      *(_DWORD *)&v37[10] = v16;
      _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEFAULT,  "%{public}s Failed to set throughput estimate on %{public}s: %{darwin.errno}d",  buf,  0x1Cu);
    }

    uint64_t v4 = v16;

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v18 = (os_log_s *)(id)gLogObj;
    BOOL v19 = v18;
    if (v16 == 6)
    {
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v35 = "handleThroughputEstimates";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v8;
        *(_WORD *)&v37[4] = 1024;
        *(_DWORD *)&v37[6] = 6;
        _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d",  buf,  0x18u);
      }

      goto LABEL_50;
    }

    *(_DWORD *)buf = 136446722;
    __int16 v35 = "handleThroughputEstimates";
    __int16 v36 = 1024;
    *(_DWORD *)__int16 v37 = v8;
    *(_WORD *)&v37[4] = 1024;
    *(_DWORD *)&v37[6] = v16;
    int v23 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (!__nwlog_fault((const char *)v23, &type, &v32))
    {
LABEL_48:
      if (v23) {
        free(v23);
      }
      goto LABEL_50;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v35 = "handleThroughputEstimates";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v8;
        *(_WORD *)&v37[4] = 1024;
        *(_DWORD *)&v37[6] = v16;
        uint64_t v26 = "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d";
LABEL_46:
        _os_log_impl(&dword_181A5C000, v24, v25, v26, buf, 0x18u);
      }
    }

    else
    {
      if (v32)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = type;
        BOOL v30 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446978;
            __int16 v35 = "handleThroughputEstimates";
            __int16 v36 = 1024;
            *(_DWORD *)__int16 v37 = v8;
            *(_WORD *)&v37[4] = 1024;
            *(_DWORD *)&v37[6] = v16;
            *(_WORD *)&v37[10] = 2082;
            *(void *)&v37[12] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x22u);
          }

          free(backtrace_string);
          goto LABEL_48;
        }

        if (!v30) {
          goto LABEL_47;
        }
        *(_DWORD *)buf = 136446722;
        __int16 v35 = "handleThroughputEstimates";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v8;
        *(_WORD *)&v37[4] = 1024;
        *(_DWORD *)&v37[6] = v16;
        uint64_t v26 = "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d, no backtrace";
        goto LABEL_46;
      }

      __nwlog_obj();
      __int16 v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v35 = "handleThroughputEstimates";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v8;
        *(_WORD *)&v37[4] = 1024;
        *(_DWORD *)&v37[6] = v16;
        uint64_t v26 = "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_46;
      }
    }

uint64_t handleRadioType(void *a1)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  [v1 request];
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  string = xpc_dictionary_get_string(v2, (const char *)networkd_privileged_key_interface_name);

  __int128 v38 = 0u;
  __int128 v39 = 0u;
  if (!string || strlen(string) > 0x10)
  {
    uint64_t v4 = 22LL;
    goto LABEL_51;
  }

  __strlcpy_chk();
  [v1 request];
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  LOBYTE(v39) = xpc_dictionary_get_uint64(v5, (const char *)networkd_privileged_key_radio_type);

  [v1 request];
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  BYTE1(v39) = xpc_dictionary_get_uint64(v6, (const char *)networkd_privileged_key_radio_channel);

  int v7 = socket(2, 2, 0);
  if ((v7 & 0x80000000) == 0)
  {
    int v8 = v7;
    if (ioctl(v7, 0xC02069D5uLL, &v38) != -1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v9 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        __int16 v35 = "handleRadioType";
        __int16 v36 = 2082;
        *(void *)__int16 v37 = &v38;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEFAULT,  "%{public}s Successfully set radio type on %{public}s",  buf,  0x16u);
      }

      uint64_t v4 = 0LL;
LABEL_50:
      close(v8);
      goto LABEL_51;
    }

    int v16 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v17 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446722;
      __int16 v35 = "handleRadioType";
      __int16 v36 = 2082;
      *(void *)__int16 v37 = &v38;
      *(_WORD *)&v37[8] = 1024;
      *(_DWORD *)&v37[10] = v16;
      _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEFAULT,  "%{public}s Failed to set radio type on %{public}s: %{darwin.errno}d",  buf,  0x1Cu);
    }

    uint64_t v4 = v16;

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v18 = (os_log_s *)(id)gLogObj;
    BOOL v19 = v18;
    if (v16 == 6)
    {
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v35 = "handleRadioType";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v8;
        *(_WORD *)&v37[4] = 1024;
        *(_DWORD *)&v37[6] = 6;
        _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d",  buf,  0x18u);
      }

      goto LABEL_50;
    }

    *(_DWORD *)buf = 136446722;
    __int16 v35 = "handleRadioType";
    __int16 v36 = 1024;
    *(_DWORD *)__int16 v37 = v8;
    *(_WORD *)&v37[4] = 1024;
    *(_DWORD *)&v37[6] = v16;
    int v23 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (!__nwlog_fault((const char *)v23, &type, &v32))
    {
LABEL_48:
      if (v23) {
        free(v23);
      }
      goto LABEL_50;
    }

    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v35 = "handleRadioType";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v8;
        *(_WORD *)&v37[4] = 1024;
        *(_DWORD *)&v37[6] = v16;
        uint64_t v26 = "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d";
LABEL_46:
        _os_log_impl(&dword_181A5C000, v24, v25, v26, buf, 0x18u);
      }
    }

    else
    {
      if (v32)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v25 = type;
        BOOL v30 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446978;
            __int16 v35 = "handleRadioType";
            __int16 v36 = 1024;
            *(_DWORD *)__int16 v37 = v8;
            *(_WORD *)&v37[4] = 1024;
            *(_DWORD *)&v37[6] = v16;
            *(_WORD *)&v37[10] = 2082;
            *(void *)&v37[12] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x22u);
          }

          free(backtrace_string);
          goto LABEL_48;
        }

        if (!v30) {
          goto LABEL_47;
        }
        *(_DWORD *)buf = 136446722;
        __int16 v35 = "handleRadioType";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v8;
        *(_WORD *)&v37[4] = 1024;
        *(_DWORD *)&v37[6] = v16;
        uint64_t v26 = "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d, no backtrace";
        goto LABEL_46;
      }

      __nwlog_obj();
      __int16 v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v35 = "handleRadioType";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v8;
        *(_WORD *)&v37[4] = 1024;
        *(_DWORD *)&v37[6] = v16;
        uint64_t v26 = "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_46;
      }
    }

uint64_t handleRunProbes()
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  v0 = (void *)os_transaction_create();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v1 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "handleRunProbes";
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v0;
    _os_log_impl(&dword_181A5C000, v1, OS_LOG_TYPE_DEFAULT, "%{public}s created transaction %@", buf, 0x16u);
  }

  id v2 = v0;
  if (v2)
  {
    id v3 = +[ManagedNetworkSettings sharedMNS](&OBJC_CLASS___ManagedNetworkSettings, "sharedMNS");
    [v3 queue];
    uint64_t v4 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue();
    *(void *)buf = MEMORY[0x1895F87A8];
    *(void *)&buf[8] = 3221225472LL;
    *(void *)&buf[16] = __runProbes_block_invoke;
    BOOL v19 = &unk_189BC93A0;
    id v20 = v2;
    dispatch_async(v4, buf);

    goto LABEL_5;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v6 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "runProbes";
  int v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "runProbes";
        int v10 = "%{public}s called with null transaction";
LABEL_17:
        os_log_type_t v14 = v8;
        os_log_type_t v15 = v9;
LABEL_18:
        _os_log_impl(&dword_181A5C000, v14, v15, v10, buf, 0xCu);
      }
    }

    else
    {
      if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "runProbes";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v12,  "%{public}s called with null transaction, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v13) {
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "runProbes";
        int v10 = "%{public}s called with null transaction, no backtrace";
        os_log_type_t v14 = v8;
        os_log_type_t v15 = v12;
        goto LABEL_18;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "runProbes";
        int v10 = "%{public}s called with null transaction, backtrace limit exceeded";
        goto LABEL_17;
      }
    }

void teardownFakeEthernet(int a1, uint64_t a2)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  int v22 = 0;
  if (sysctlbyname("net.link.fake.nxattach", 0LL, 0LL, &v22, 4uLL))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v24 = "teardownFakeEthernet";
      v5 = "%{public}s Failed to clear sysctl to attach fake ethernet";
      id v6 = v4;
      os_log_type_t v7 = OS_LOG_TYPE_ERROR;
      uint32_t v8 = 12;
LABEL_7:
      _os_log_impl(&dword_181A5C000, v6, v7, v5, buf, v8);
      goto LABEL_8;
    }

    goto LABEL_8;
  }

  memset(v31, 0, sizeof(v31));
  __strlcpy_chk();
  if ((ioctl(a1, 0x80206979uLL, v31) & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446466;
      __int16 v24 = "teardownFakeEthernet";
      __int16 v25 = 2082;
      *(void *)uint64_t v26 = v31;
      v5 = "%{public}s Successfully destroyed interface %{public}s";
      id v6 = v4;
      os_log_type_t v7 = OS_LOG_TYPE_DEFAULT;
      uint32_t v8 = 22;
      goto LABEL_7;
    }

uint64_t setupFakeEthernet(int a1, uint64_t a2)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  int v31 = 1;
  uint64_t v4 = sysctlbyname("net.link.fake.nxattach", 0LL, 0LL, &v31, 4uLL);
  if ((_DWORD)v4)
  {
    uint64_t v5 = v4;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v33 = "setupFakeEthernet";
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_ERROR,  "%{public}s Failed to set sysctl to attach fake ethernet",  buf,  0xCu);
    }

    return v5;
  }

  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __strlcpy_chk();
  if (ioctl(a1, 0xC0206978uLL, &v40) < 0)
  {
    uint64_t v5 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446978;
    __int16 v33 = "setupFakeEthernet";
    __int16 v34 = 1024;
    *(_DWORD *)__int16 v35 = a1;
    *(_WORD *)&v35[4] = 2082;
    *(void *)&v35[6] = a2;
    __int16 v36 = 1024;
    int v37 = v5;
    id v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v11 = (os_log_s *)(id)gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446978;
      __int16 v33 = "setupFakeEthernet";
      __int16 v34 = 1024;
      *(_DWORD *)__int16 v35 = a1;
      *(_WORD *)&v35[4] = 2082;
      *(void *)&v35[6] = a2;
      __int16 v36 = 1024;
      int v37 = v5;
      os_log_type_t v13 = "%{public}s ioctl(%d, SIOCIFCREATE, %{public}s) failed %{darwin.errno}d";
LABEL_70:
      __int16 v24 = v11;
      os_log_type_t v25 = v12;
      goto LABEL_71;
    }

    if (!v29)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v11 = (os_log_s *)(id)gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446978;
      __int16 v33 = "setupFakeEthernet";
      __int16 v34 = 1024;
      *(_DWORD *)__int16 v35 = a1;
      *(_WORD *)&v35[4] = 2082;
      *(void *)&v35[6] = a2;
      __int16 v36 = 1024;
      int v37 = v5;
      os_log_type_t v13 = "%{public}s ioctl(%d, SIOCIFCREATE, %{public}s) failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_70;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = (os_log_s *)(id)gLogObj;
    os_log_type_t v16 = type;
    BOOL v17 = os_log_type_enabled(v11, type);
    if (backtrace_string)
    {
      if (!v17) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136447234;
      __int16 v33 = "setupFakeEthernet";
      __int16 v34 = 1024;
      *(_DWORD *)__int16 v35 = a1;
      *(_WORD *)&v35[4] = 2082;
      *(void *)&v35[6] = a2;
      __int16 v36 = 1024;
      int v37 = v5;
      __int16 v38 = 2082;
      __int128 v39 = backtrace_string;
      char v18 = "%{public}s ioctl(%d, SIOCIFCREATE, %{public}s) failed %{darwin.errno}d, dumping backtrace:%{public}s";
      goto LABEL_35;
    }

    if (!v17) {
      goto LABEL_72;
    }
    *(_DWORD *)buf = 136446978;
    __int16 v33 = "setupFakeEthernet";
    __int16 v34 = 1024;
    *(_DWORD *)__int16 v35 = a1;
    *(_WORD *)&v35[4] = 2082;
    *(void *)&v35[6] = a2;
    __int16 v36 = 1024;
    int v37 = v5;
    os_log_type_t v13 = "%{public}s ioctl(%d, SIOCIFCREATE, %{public}s) failed %{darwin.errno}d, no backtrace";
LABEL_56:
    __int16 v24 = v11;
    os_log_type_t v25 = v16;
LABEL_71:
    _os_log_impl(&dword_181A5C000, v24, v25, v13, buf, 0x22u);
    goto LABEL_72;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v7 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    __int16 v33 = "setupFakeEthernet";
    __int16 v34 = 2082;
    *(void *)__int16 v35 = &v40;
    _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEFAULT,  "%{public}s Successfully created interface %{public}s",  buf,  0x16u);
  }

  if (ioctl(a1, 0xC0206950uLL, &v40) < 0)
  {
    uint64_t v5 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v14 = (id)gLogObj;
    *(_DWORD *)buf = 136446978;
    __int16 v33 = "setupFakeEthernet";
    __int16 v34 = 1024;
    *(_DWORD *)__int16 v35 = a1;
    *(_WORD *)&v35[4] = 2082;
    *(void *)&v35[6] = a2;
    __int16 v36 = 1024;
    int v37 = v5;
    id v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v11 = (os_log_s *)(id)gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446978;
      __int16 v33 = "setupFakeEthernet";
      __int16 v34 = 1024;
      *(_DWORD *)__int16 v35 = a1;
      *(_WORD *)&v35[4] = 2082;
      *(void *)&v35[6] = a2;
      __int16 v36 = 1024;
      int v37 = v5;
      os_log_type_t v13 = "%{public}s ioctl(%d, SIOCPROTOATTACH, %{public}s) failed %{darwin.errno}d";
      goto LABEL_70;
    }

    if (!v29)
    {
      __nwlog_obj();
      id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446978;
        __int16 v33 = "setupFakeEthernet";
        __int16 v34 = 1024;
        *(_DWORD *)__int16 v35 = a1;
        *(_WORD *)&v35[4] = 2082;
        *(void *)&v35[6] = a2;
        __int16 v36 = 1024;
        int v37 = v5;
        os_log_type_t v13 = "%{public}s ioctl(%d, SIOCPROTOATTACH, %{public}s) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_70;
      }

      goto LABEL_72;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = (os_log_s *)(id)gLogObj;
    os_log_type_t v16 = type;
    BOOL v20 = os_log_type_enabled(v11, type);
    if (backtrace_string)
    {
      if (!v20) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136447234;
      __int16 v33 = "setupFakeEthernet";
      __int16 v34 = 1024;
      *(_DWORD *)__int16 v35 = a1;
      *(_WORD *)&v35[4] = 2082;
      *(void *)&v35[6] = a2;
      __int16 v36 = 1024;
      int v37 = v5;
      __int16 v38 = 2082;
      __int128 v39 = backtrace_string;
      char v18 = "%{public}s ioctl(%d, SIOCPROTOATTACH, %{public}s) failed %{darwin.errno}d, dumping backtrace:%{public}s";
LABEL_35:
      _os_log_impl(&dword_181A5C000, v11, v16, v18, buf, 0x2Cu);
LABEL_36:

      free(backtrace_string);
      if (!v10) {
        return v5;
      }
      goto LABEL_74;
    }

    if (!v20) {
      goto LABEL_72;
    }
    *(_DWORD *)buf = 136446978;
    __int16 v33 = "setupFakeEthernet";
    __int16 v34 = 1024;
    *(_DWORD *)__int16 v35 = a1;
    *(_WORD *)&v35[4] = 2082;
    *(void *)&v35[6] = a2;
    __int16 v36 = 1024;
    int v37 = v5;
    os_log_type_t v13 = "%{public}s ioctl(%d, SIOCPROTOATTACH, %{public}s) failed %{darwin.errno}d, no backtrace";
    goto LABEL_56;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint32_t v8 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    __int16 v33 = "setupFakeEthernet";
    __int16 v34 = 2082;
    *(void *)__int16 v35 = &v40;
    _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEFAULT,  "%{public}s Successfully attach proto to interface %{public}s",  buf,  0x16u);
  }

  __int128 v40 = 0u;
  __int128 v41 = 0u;
  __strlcpy_chk();
  if ((ioctl(a1, 0xC0206911uLL, &v40) & 0x80000000) == 0)
  {
    if ((v41 & 1) != 0) {
      return 0LL;
    }
    LOWORD(v41) = v41 | 1;
    if ((ioctl(a1, 0x80206910uLL, &v40) & 0x80000000) == 0) {
      return 0LL;
    }
    uint64_t v5 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    __nwlog_obj();
    int v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446978;
    __int16 v33 = "setupFakeEthernet";
    __int16 v34 = 1024;
    *(_DWORD *)__int16 v35 = a1;
    *(_WORD *)&v35[4] = 2082;
    *(void *)&v35[6] = a2;
    __int16 v36 = 1024;
    int v37 = v5;
    id v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446978;
        __int16 v33 = "setupFakeEthernet";
        __int16 v34 = 1024;
        *(_DWORD *)__int16 v35 = a1;
        *(_WORD *)&v35[4] = 2082;
        *(void *)&v35[6] = a2;
        __int16 v36 = 1024;
        int v37 = v5;
        os_log_type_t v13 = "%{public}s ioctl(%d, SIOCSIFFLAGS, %{public}s) failed %{darwin.errno}d";
        goto LABEL_70;
      }
    }

    else if (v29)
    {
      uint64_t v26 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v27 = os_log_type_enabled(v11, type);
      if (v26)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136447234;
          __int16 v33 = "setupFakeEthernet";
          __int16 v34 = 1024;
          *(_DWORD *)__int16 v35 = a1;
          *(_WORD *)&v35[4] = 2082;
          *(void *)&v35[6] = a2;
          __int16 v36 = 1024;
          int v37 = v5;
          __int16 v38 = 2082;
          __int128 v39 = v26;
          _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s ioctl(%d, SIOCSIFFLAGS, %{public}s) failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x2Cu);
        }

        free(v26);
LABEL_73:
        if (!v10) {
          return v5;
        }
LABEL_74:
        free(v10);
        return v5;
      }

      if (v27)
      {
        *(_DWORD *)buf = 136446978;
        __int16 v33 = "setupFakeEthernet";
        __int16 v34 = 1024;
        *(_DWORD *)__int16 v35 = a1;
        *(_WORD *)&v35[4] = 2082;
        *(void *)&v35[6] = a2;
        __int16 v36 = 1024;
        int v37 = v5;
        os_log_type_t v13 = "%{public}s ioctl(%d, SIOCSIFFLAGS, %{public}s) failed %{darwin.errno}d, no backtrace";
        goto LABEL_70;
      }
    }

    else
    {
      __nwlog_obj();
      id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446978;
        __int16 v33 = "setupFakeEthernet";
        __int16 v34 = 1024;
        *(_DWORD *)__int16 v35 = a1;
        *(_WORD *)&v35[4] = 2082;
        *(void *)&v35[6] = a2;
        __int16 v36 = 1024;
        int v37 = v5;
        os_log_type_t v13 = "%{public}s ioctl(%d, SIOCSIFFLAGS, %{public}s) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_70;
      }
    }

uint64_t internalHandleSetNetworkAgentOnInterface(void *a1, int a2)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  [v3 request];
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  uuid = xpc_dictionary_get_uuid(v4, (const char *)networkd_privileged_key_agent_uuid);

  if (!uuid)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v17 = (id)gLogObj;
    *(_DWORD *)length = 136446466;
    *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
    __int16 v48 = 1024;
    int v49 = [v3 pid];
    LODWORD(v45) = 18;
    char v18 = (char *)_os_log_send_and_compose_impl();

    uu[0] = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (uu[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v19 = (os_log_s *)(id)gLogObj;
      unsigned __int8 v20 = uu[0];
      if (!os_log_type_enabled(v19, uu[0])) {
        goto LABEL_42;
      }
      int v21 = objc_msgSend(v3, "pid", length, v45);
      *(_DWORD *)length = 136446466;
      *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
      __int16 v48 = 1024;
      int v49 = v21;
      BOOL v22 = "%{public}s Unable to extract agent UUID bytes from agent request from pid %d";
    }

    else
    {
      if (v46)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v19 = (os_log_s *)(id)gLogObj;
        os_log_type_t v28 = uu[0];
        BOOL v29 = os_log_type_enabled(v19, uu[0]);
        if (backtrace_string)
        {
          if (v29)
          {
            int v30 = objc_msgSend(v3, "pid", length, v45);
            *(_DWORD *)length = 136446722;
            *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
            __int16 v48 = 1024;
            int v49 = v30;
            __int16 v50 = 2082;
            v51 = backtrace_string;
            int v31 = "%{public}s Unable to extract agent UUID bytes from agent request from pid %d, dumping backtrace:%{public}s";
LABEL_29:
            _os_log_impl(&dword_181A5C000, v19, v28, v31, length, 0x1Cu);
          }

uint64_t internalHandleCreateKernelSocket(void *a1, uint64_t a2)
{
  uint64_t v81 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  int v4 = socket(32, 2, 2);
  if ((v4 & 0x80000000) == 0)
  {
    int v5 = v4;
    int v80 = 0;
    __int128 v78 = 0u;
    __int128 v79 = 0u;
    __int128 v77 = 0u;
    memset(buf, 0, sizeof(buf));
    __strlcpy_chk();
    if (ioctl(v5, 0xC0644E03uLL, buf) != -1)
    {
      *(void *)&v66[12] = 0LL;
      uint64_t v67 = 0LL;
      int v68 = 0;
      *(_DWORD *)v66 = 139296;
      *(_DWORD *)&v66[4] = *(_DWORD *)buf;
      *(_DWORD *)&v66[8] = 0;
      if (connect(v5, (const sockaddr *)v66, 0x20u))
      {
        int v6 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v7 = (id)gLogObj;
        *(_DWORD *)v70 = 136447234;
        v71 = "createKernelSocket";
        __int16 v72 = 1024;
        *(_DWORD *)v73 = *(_DWORD *)buf;
        *(_WORD *)&v73[4] = 2082;
        *(void *)&v73[6] = &buf[4];
        *(_WORD *)&v73[14] = 1024;
        *(_DWORD *)&v73[16] = v5;
        __int16 v74 = 1024;
        LODWORD(v75[0]) = v6;
        uint32_t v8 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v65 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v9 = (os_log_s *)(id)gLogObj;
          os_log_type_t v10 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)v70 = 136447234;
            v71 = "createKernelSocket";
            __int16 v72 = 1024;
            *(_DWORD *)v73 = *(_DWORD *)buf;
            *(_WORD *)&v73[4] = 2082;
            *(void *)&v73[6] = &buf[4];
            *(_WORD *)&v73[14] = 1024;
            *(_DWORD *)&v73[16] = v5;
            __int16 v74 = 1024;
            LODWORD(v75[0]) = v6;
            id v11 = "%{public}s unable to connect to id %u for socket control name %{public}s on fd %d %{darwin.errno}d";
LABEL_61:
            uint64_t v45 = v9;
            os_log_type_t v46 = v10;
            uint32_t v47 = 40;
            goto LABEL_62;
          }
        }

        else
        {
          if (v65)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v9 = (os_log_s *)(id)gLogObj;
            os_log_type_t v10 = type;
            BOOL v34 = os_log_type_enabled(v9, type);
            if (backtrace_string)
            {
              if (v34)
              {
                *(_DWORD *)v70 = 136447490;
                v71 = "createKernelSocket";
                __int16 v72 = 1024;
                *(_DWORD *)v73 = *(_DWORD *)buf;
                *(_WORD *)&v73[4] = 2082;
                *(void *)&v73[6] = &buf[4];
                *(_WORD *)&v73[14] = 1024;
                *(_DWORD *)&v73[16] = v5;
                __int16 v74 = 1024;
                LODWORD(v75[0]) = v6;
                WORD2(v75[0]) = 2082;
                *(void *)((char *)v75 + 6) = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s unable to connect to id %u for socket control name %{public}s on fd %d %{darwin.errno}d, du mping backtrace:%{public}s",  (uint8_t *)v70,  0x32u);
              }

              free(backtrace_string);
              if (!v8) {
                goto LABEL_66;
              }
              goto LABEL_65;
            }

            if (!v34) {
              goto LABEL_63;
            }
            *(_DWORD *)v70 = 136447234;
            v71 = "createKernelSocket";
            __int16 v72 = 1024;
            *(_DWORD *)v73 = *(_DWORD *)buf;
            *(_WORD *)&v73[4] = 2082;
            *(void *)&v73[6] = &buf[4];
            *(_WORD *)&v73[14] = 1024;
            *(_DWORD *)&v73[16] = v5;
            __int16 v74 = 1024;
            LODWORD(v75[0]) = v6;
            id v11 = "%{public}s unable to connect to id %u for socket control name %{public}s on fd %d %{darwin.errno}d, no backtrace";
            goto LABEL_61;
          }

          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v9 = (os_log_s *)(id)gLogObj;
          os_log_type_t v10 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)v70 = 136447234;
            v71 = "createKernelSocket";
            __int16 v72 = 1024;
            *(_DWORD *)v73 = *(_DWORD *)buf;
            *(_WORD *)&v73[4] = 2082;
            *(void *)&v73[6] = &buf[4];
            *(_WORD *)&v73[14] = 1024;
            *(_DWORD *)&v73[16] = v5;
            __int16 v74 = 1024;
            LODWORD(v75[0]) = v6;
            id v11 = "%{public}s unable to connect to id %u for socket control name %{public}s on fd %d %{darwin.errno}d, ba"
                  "cktrace limit exceeded";
            goto LABEL_61;
          }
        }

void NWPrivilegedHelperStart(void *a1)
{
  id v1 = a1;
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = __NWPrivilegedHelperStart_block_invoke;
  block[3] = &unk_189BC93A0;
  id v7 = v1;
  uint64_t v2 = NWPrivilegedHelperStart_onceToken;
  id v3 = v1;
  id v5 = v3;
  if (v2 == -1)
  {
    int v4 = v3;
  }

  else
  {
    dispatch_once(&NWPrivilegedHelperStart_onceToken, block);
    int v4 = v7;
  }
}

void __NWPrivilegedHelperStart_block_invoke(uint64_t a1)
{
  id v1 = -[NWPrivilegedHelper initWithQueue:]( objc_alloc(&OBJC_CLASS___NWPrivilegedHelper),  "initWithQueue:",  *(void *)(a1 + 32));
  uint64_t v2 = (void *)NWPrivilegedHelperStart_sNWPrivilegedHelper;
  NWPrivilegedHelperStart_sNWPrivilegedHelper = (uint64_t)v1;
}

void NWPrivilegedHelperHandleEvent(void *a1, const char *a2)
{
  id v3 = a1;
  if (!strcmp(a2, "com.apple.fsevents.matching"))
  {
    id v4 = +[ManagedNetworkSettings sharedMNS](&OBJC_CLASS___ManagedNetworkSettings, "sharedMNS");
    [v4 queue];
    id v5 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue();
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __handleEventForManagedNetworkSettings_block_invoke;
    block[3] = &unk_189BC93A0;
    id v7 = v3;
    dispatch_async(v5, block);
  }
}

void sub_182210100(_Unwind_Exception *a1)
{
}

void sub_18221078C(_Unwind_Exception *a1)
{
}

void sub_182214684(_Unwind_Exception *a1)
{
}

BOOL nw_remote_director_write_request(uint64_t a1, uint64_t a2, void *a3)
{
  *(void *)((char *)&v86[2] + 2) = *MEMORY[0x1895F89C0];
  id v5 = a3;
  uint64_t v75 = a1;
  uint64_t v76 = a2;
  while (1)
  {
    objc_msgSend(v5, "data", v73, v74);
    int v6 = (void *)objc_claimAutoreleasedReturnValue();
    unint64_t v7 = [v6 length];

    [v5 data];
    uint32_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    [v5 clientID];
    BOOL v9 = (void *)objc_claimAutoreleasedReturnValue();
    id v10 = v8;
    id v11 = v9;
    uint64_t v12 = [v10 length];
    uint64_t v13 = [v10 bytes];
    if (!a1)
    {
      __nwlog_obj();
      __int16 v48 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 136446210;
      v84 = "nw_remote_director_write_one";
      LODWORD(v74) = 12;
      v73 = buf;
      BOOL v49 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v79) = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v50 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v51 = type[0];
        if (os_log_type_enabled(v50, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v84 = "nw_remote_director_write_one";
          xpc_object_t v52 = v50;
          os_log_type_t v53 = v51;
          __int16 v54 = "%{public}s called with null protocol";
LABEL_85:
          _os_log_impl(&dword_181A5C000, v52, v53, v54, buf, 0xCu);
        }

uint64_t nw_remote_director_input_available(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v39 = *MEMORY[0x1895F89C0];
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, id *))(*(void *)(a2 + 24) + 80LL))( a2,  a1,  1LL,  0xFFFFFFFFLL,  0xFFFFFFFFLL,  v36);
  if ((_DWORD)result)
  {
    id v4 = &qword_18C45F000;
    uint64_t v30 = v2;
    do
    {
      id v35 = *(id *)(v2 + 40);
      unint64_t v32 = [v35 maximumDataChunkSize];
      [MEMORY[0x189603FA8] array];
      int v33 = (void *)objc_claimAutoreleasedReturnValue();
      id v8 = v36[0];
      __int128 v38 = 0uLL;
      if (!v8)
      {
        id v5 = 0LL;
        goto LABEL_4;
      }

      uint64_t v9 = (uint64_t)v8;
      int v6 = 0LL;
      id v5 = 0LL;
      uint64_t v34 = 0LL;
      do
      {
        id v10 = *(void **)(v9 + 32);
        if (!v10 && !*(void *)(v9 + 40)) {
          id v10 = 0LL;
        }
        id v11 = v10;
        if (!*(void *)(v9 + 112)) {
          goto LABEL_43;
        }
        if ((*(_WORD *)(v9 + 204) & 0x100) != 0)
        {
          uint64_t v12 = (unsigned int (*)(uint64_t, void))v4[199];
          if (v12)
          {
            if (!v12(v9, *(void *)(v9 + 88))) {
              goto LABEL_43;
            }
          }
        }

        int v13 = *(_DWORD *)(v9 + 52);
        if (!v13) {
          goto LABEL_43;
        }
        uint64_t v14 = *(unsigned int *)(v9 + 56);
        int v15 = v14 + *(_DWORD *)(v9 + 60);
        uint64_t v16 = (v13 - v15);
        if (v13 == v15) {
          goto LABEL_43;
        }
        uint64_t v17 = *(void *)(v9 + 112);
        if (!v17) {
          goto LABEL_43;
        }
        uint64_t v18 = 0LL;
        __int128 v37 = 0uLL;
        if ((*(_WORD *)(v9 + 204) & 0x100) != 0)
        {
          uint64_t v19 = 0LL;
          if (g_channel_get_flow_handler)
          {
            g_channel_get_flow_handler(v9, &v37);
            uint64_t v18 = *((void *)&v37 + 1);
            uint64_t v19 = v37;
          }
        }

        else
        {
          uint64_t v19 = 0LL;
        }

        BOOL v20 = v19 == (void)v38 && v18 == *((void *)&v38 + 1);
        char v21 = v20;
        if (v6 && v5)
        {
          [v35 createSendDataMessageForClientID:v5 data:v6 receiveWindow:0];
          os_log_type_t v22 = (void *)objc_claimAutoreleasedReturnValue();
          [v33 addObject:v22];

          int v6 = 0LL;
        }

        if ((v21 & 1) != 0)
        {
LABEL_37:
          uint64_t v23 = v34;
        }

        else
        {
          __int128 v38 = v37;
          uint64_t v24 = [objc_alloc(MEMORY[0x189607AB8]) initWithUUIDBytes:&v38];

          uint64_t v23 = [v35 dataModeForFlowID:v24];
          id v5 = (void *)v24;
        }

        uint64_t v34 = v23;
        id v4 = &qword_18C45F000;
        if (v23 == 2)
        {
          if (!v6)
          {
            [MEMORY[0x189603FB8] data];
            int v6 = (void *)objc_claimAutoreleasedReturnValue();
          }

          objc_msgSend(v6, "appendBytes:length:", v17 + v14, v16, v30);
LABEL_43:
          uint64_t v25 = *(void *)(v9 + 32);
          int v26 = *(void **)(v9 + 40);
          if (!v25) {
            goto LABEL_8;
          }
          goto LABEL_44;
        }

        [MEMORY[0x189603F48] dataWithBytes:v17 + v14 length:v16];
        size_t v27 = (void *)objc_claimAutoreleasedReturnValue();
        [v35 createSendDataMessageForClientID:v5 data:v27 receiveWindow:0];
        uint64_t v28 = (void *)objc_claimAutoreleasedReturnValue();
        [v33 addObject:v28];

        uint64_t v25 = *(void *)(v9 + 32);
        int v26 = *(void **)(v9 + 40);
        if (!v25)
        {
LABEL_8:
          v36[1] = v26;
          goto LABEL_9;
        }

void nw_remote_director_output_available(uint64_t a1, uint64_t a2)
{
  id obj = *(id *)(a1 + 40);
  objc_sync_enter(obj);
  while (1)
  {
    [obj writeRequests];
    id v4 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v5 = [v4 count];

    if (!v5) {
      break;
    }
    [obj writeRequests];
    int v6 = (void *)objc_claimAutoreleasedReturnValue();
    [v6 firstObject];
    unint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();

    if (!nw_remote_director_write_request(a1, a2, v7))
    {

      break;
    }

    [obj writeRequests];
    id v8 = (void *)objc_claimAutoreleasedReturnValue();
    [v8 removeObjectAtIndex:0];
  }

  objc_sync_exit(obj);
}

void sub_182215638( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

uint64_t areNSSetsEqual(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if (![v3 count])
  {

    id v3 = 0LL;
  }

  if ([v4 count])
  {
    uint64_t v5 = v3 == v4;
    if (v3 != v4 && v4 && v3) {
      uint64_t v5 = [v3 isEqualToSet:v4];
    }
  }

  else
  {

    id v4 = 0LL;
    uint64_t v5 = v3 == 0LL;
  }

  return v5;
}

void sub_1822177D8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1822179D4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_182217B7C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_182217D24( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_182217EB8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_18221804C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_182218218( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1822184A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1822186BC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_1822188EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_182218AB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_182218CB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_182218EA0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_18221911C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_18221936C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_18221956C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_182219758( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

void sub_182219940( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
}

uint64_t __Block_byref_object_copy__43604(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__43605(uint64_t a1)
{
}

void sub_182219C28(void *a1)
{
}

void sub_182219C3C(_Unwind_Exception *a1)
{
}

void _systemPowerNotificationsCallback(uint64_t a1, uint64_t a2, int a3, intptr_t a4)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (__nwlog_url_log::onceToken != -1) {
      dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_54_44366);
    }
    unint64_t v7 = (os_log_s *)(id)gurlLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = a3;
      _os_log_impl(&dword_181A5C000, v7, OS_LOG_TYPE_INFO, "Received power notification: %x", buf, 8u);
    }

    if (a3 == -536870272)
    {
      -[NWURLSession teardownAllConnections](a1);
      uint64_t v13 = 0LL;
      uint64_t v14 = &v13;
      uint64_t v15 = 0x2020000000LL;
      uint64_t v16 = 0LL;
      id v10 = *(id *)(a1 + 160);
      *(void *)buf = MEMORY[0x1895F87A8];
      uint64_t v18 = 3221225472LL;
      uint64_t v19 = __62__NWURLSession_systemPowerChangedNotification_notificationID___block_invoke;
      BOOL v20 = &unk_189BC93F0;
      os_log_type_t v22 = &v13;
      intptr_t v23 = a4;
      uint64_t v21 = a1;
      BOOL source = nw_queue_context_create_source(v10, 2, 3, 0, buf, 0LL);
      v14[3] = source;

      nw_queue_set_timer_values(v14[3], 0x8000000000000000LL, 0xFFFFFFFFFFFFFFFFLL, 0x3E8uLL);
      nw_queue_activate_source(v14[3], v12);
      _Block_object_dispose(&v13, 8);
    }

    else if (a3 == -536870288)
    {
      IOReturn v8 = IOAllowPowerChange(*(_DWORD *)(a1 + 36), a4);
      if (v8)
      {
        if (__nwlog_url_log::onceToken != -1) {
          dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_54_44366);
        }
        uint64_t v9 = (os_log_s *)(id)gurlLogObj;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v8;
          _os_log_impl(&dword_181A5C000, v9, OS_LOG_TYPE_ERROR, "Failed to allow system sleep: %d", buf, 8u);
        }
      }
    }
  }

void sub_18221CEB4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void __isWebKitNetworking_block_invoke()
{
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  [v0 bundleIdentifier];
  id v1 = (void *)objc_claimAutoreleasedReturnValue();
  int v2 = [v1 hasPrefix:@"com.apple.WebKit.Networking"];

  if (v2) {
    isWebKitNetworking_uint64_t result = 1;
  }
}

uint64_t nw_protocol_registrar_get_accept_function_for_identifier(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v18 = "nw_protocol_registrar_get_accept_function_for_identifier";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v9, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v10 = (os_log_s *)__nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v18 = "nw_protocol_registrar_get_accept_function_for_identifier";
          uint64_t v12 = "%{public}s called with null identifier";
LABEL_35:
          _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
        }
      }

      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v10 = (os_log_s *)__nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v18 = "nw_protocol_registrar_get_accept_function_for_identifier";
            __int16 v19 = 2082;
            BOOL v20 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null identifier, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_36;
        }

        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v18 = "nw_protocol_registrar_get_accept_function_for_identifier";
          uint64_t v12 = "%{public}s called with null identifier, no backtrace";
          goto LABEL_35;
        }
      }

      else
      {
        id v10 = (os_log_s *)__nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v18 = "nw_protocol_registrar_get_accept_function_for_identifier";
          uint64_t v12 = "%{public}s called with null identifier, backtrace limit exceeded";
          goto LABEL_35;
        }
      }
    }

BOOL nw_protocol_register(void *a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  nw_allow_use_of_dispatch_internal();
  os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  id v4 = &g_registration_list;
  while (1)
  {
    id v4 = (uint64_t *)*v4;
    if (!v4) {
      break;
    }
    if (*a1 == v4[4] && a1[1] == v4[5] && a1[2] == v4[6] && a1[3] == v4[7] && a1[4] == v4[8])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v18 = "nw_protocol_register";
        __int16 v19 = 2082;
        uint64_t v20 = (uint64_t)a1;
        _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s Protocol %{public}s is already registered",  buf,  0x16u);
      }

BOOL nw_protocol_register_extended(void *a1, uint64_t a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  nw_allow_use_of_dispatch_internal();
  os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  id v4 = &g_registration_list;
  while (1)
  {
    id v4 = (uint64_t *)*v4;
    if (!v4) {
      break;
    }
    if (*a1 == v4[4] && a1[1] == v4[5] && a1[2] == v4[6] && a1[3] == v4[7] && a1[4] == v4[8])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      uint64_t v25 = "nw_protocol_register_extended";
      __int16 v26 = 2082;
      uint64_t v27 = (uint64_t)a1;
      uint64_t v9 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v22 = 0;
      if (type != OS_LOG_TYPE_FAULT)
      {
        if (v22)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v10 = (os_log_s *)gLogObj;
          os_log_type_t v11 = type;
          BOOL v18 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (backtrace_string)
          {
            if (v18)
            {
              *(_DWORD *)buf = 136446722;
              uint64_t v25 = "nw_protocol_register_extended";
              __int16 v26 = 2082;
              uint64_t v27 = (uint64_t)a1;
              __int16 v28 = 2082;
              uint64_t v29 = (uint64_t)backtrace_string;
              _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s Protocol identifier %{public}s is already registered, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(backtrace_string);
            goto LABEL_35;
          }

          if (!v18) {
            goto LABEL_35;
          }
          *(_DWORD *)buf = 136446466;
          uint64_t v25 = "nw_protocol_register_extended";
          __int16 v26 = 2082;
          uint64_t v27 = (uint64_t)a1;
          __int128 v12 = "%{public}s Protocol identifier %{public}s is already registered, no backtrace";
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v10 = (os_log_s *)gLogObj;
          os_log_type_t v11 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_35;
          }
          *(_DWORD *)buf = 136446466;
          uint64_t v25 = "nw_protocol_register_extended";
          __int16 v26 = 2082;
          uint64_t v27 = (uint64_t)a1;
          __int128 v12 = "%{public}s Protocol identifier %{public}s is already registered, backtrace limit exceeded";
        }

BOOL nw_protocol_register_many_to_one(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  nw_allow_use_of_dispatch_internal();
  if (*(_DWORD *)(a1 + 36) != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    uint64_t v36 = "nw_protocol_register_many_to_one";
    __int16 v37 = 2082;
    uint64_t v38 = a1;
    uint64_t v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = (os_log_s *)gLogObj;
      os_log_type_t v18 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_51;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "nw_protocol_register_many_to_one";
      __int16 v37 = 2082;
      uint64_t v38 = a1;
      __int16 v19 = "%{public}s Protocol identifier %{public}s is not a many-to-one protocol";
    }

    else if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = (os_log_s *)gLogObj;
      os_log_type_t v18 = type;
      BOOL v27 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446722;
          uint64_t v36 = "nw_protocol_register_many_to_one";
          __int16 v37 = 2082;
          uint64_t v38 = a1;
          __int16 v39 = 2082;
          uint64_t v40 = (uint64_t)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s Protocol identifier %{public}s is not a many-to-one protocol, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(backtrace_string);
LABEL_51:
        if (v16) {
          free(v16);
        }
        return 0LL;
      }

      if (!v27) {
        goto LABEL_51;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "nw_protocol_register_many_to_one";
      __int16 v37 = 2082;
      uint64_t v38 = a1;
      __int16 v19 = "%{public}s Protocol identifier %{public}s is not a many-to-one protocol, no backtrace";
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = (os_log_s *)gLogObj;
      os_log_type_t v18 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_51;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "nw_protocol_register_many_to_one";
      __int16 v37 = 2082;
      uint64_t v38 = a1;
      __int16 v19 = "%{public}s Protocol identifier %{public}s is not a many-to-one protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v17, v18, v19, buf, 0x16u);
    goto LABEL_51;
  }

  os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  int v6 = &g_registration_list;
  while (1)
  {
    int v6 = (uint64_t *)*v6;
    BOOL v7 = v6 == 0LL;
    if (!v6) {
      break;
    }
    if (*(void *)a1 == v6[4]
      && *(void *)(a1 + 8) == v6[5]
      && *(void *)(a1 + 16) == v6[6]
      && *(void *)(a1 + 24) == v6[7]
      && *(void *)(a1 + 32) == v6[8])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "nw_protocol_register_many_to_one";
      __int16 v37 = 2082;
      uint64_t v38 = a1;
      __int128 v12 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v33 = 0;
      if (type != OS_LOG_TYPE_FAULT)
      {
        if (v33)
        {
          __int16 v28 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v13 = (os_log_s *)gLogObj;
          os_log_type_t v14 = type;
          BOOL v29 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v28)
          {
            if (v29)
            {
              *(_DWORD *)buf = 136446722;
              uint64_t v36 = "nw_protocol_register_many_to_one";
              __int16 v37 = 2082;
              uint64_t v38 = a1;
              __int16 v39 = 2082;
              uint64_t v40 = (uint64_t)v28;
              _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s Protocol identifier %{public}s is already registered, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(v28);
            goto LABEL_59;
          }

          if (!v29) {
            goto LABEL_59;
          }
          *(_DWORD *)buf = 136446466;
          uint64_t v36 = "nw_protocol_register_many_to_one";
          __int16 v37 = 2082;
          uint64_t v38 = a1;
          __int128 v15 = "%{public}s Protocol identifier %{public}s is already registered, no backtrace";
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v13 = (os_log_s *)gLogObj;
          os_log_type_t v14 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_59;
          }
          *(_DWORD *)buf = 136446466;
          uint64_t v36 = "nw_protocol_register_many_to_one";
          __int16 v37 = 2082;
          uint64_t v38 = a1;
          __int128 v15 = "%{public}s Protocol identifier %{public}s is already registered, backtrace limit exceeded";
        }

BOOL nw_protocol_register_handle(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  nw_allow_use_of_dispatch_internal();
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v41 = "nw_protocol_register_handle";
    __int16 v28 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v38)
      {
        BOOL v29 = (os_log_s *)__nwlog_obj();
        os_log_type_t v30 = type;
        if (!os_log_type_enabled(v29, type)) {
          goto LABEL_77;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v41 = "nw_protocol_register_handle";
        os_log_type_t v31 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_76;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v29 = (os_log_s *)__nwlog_obj();
      os_log_type_t v30 = type;
      BOOL v35 = os_log_type_enabled(v29, type);
      if (!backtrace_string)
      {
        if (!v35) {
          goto LABEL_77;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v41 = "nw_protocol_register_handle";
        os_log_type_t v31 = "%{public}s called with null handle, no backtrace";
        goto LABEL_76;
      }

      if (v35)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v41 = "nw_protocol_register_handle";
        __int16 v42 = 2082;
        uint64_t v43 = (uint64_t)backtrace_string;
        uint64_t v36 = "%{public}s called with null handle, dumping backtrace:%{public}s";
LABEL_66:
        _os_log_impl(&dword_181A5C000, v29, v30, v36, buf, 0x16u);
      }

BOOL nw_protocol_unregister(void *a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  nw_allow_use_of_dispatch_internal();
  os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  int v2 = &g_registration_list;
  while (1)
  {
    int v2 = (uint64_t *)*v2;
    if (!v2) {
      break;
    }
    if (*a1 == v2[4] && a1[1] == v2[5] && a1[2] == v2[6] && a1[3] == v2[7] && a1[4] == v2[8])
    {
      uint64_t v7 = *v2;
      if (*v2) {
        *(void *)(v7 + _Block_object_dispose(&a9, 8) = v2[1];
      }
      *(void *)v2[1] = v7;
      uint64_t v8 = v2[2];
      if (v8) {
        *(void *)(v8 + 24) = v2[3];
      }
      *(void *)v2[3] = v8;
      uint64_t v9 = (void *)v2[14];
      if (v9)
      {
        os_release(v9);
        v2[14] = 0LL;
      }

      free(v2);
      goto LABEL_26;
    }
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v10 = (os_log_s *)gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    int v12 = 136446466;
    uint64_t v13 = "nw_protocol_unregister";
    __int16 v14 = 2082;
    __int128 v15 = a1;
    _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s Protocol %{public}s is not registered",  (uint8_t *)&v12,  0x16u);
  }

BOOL nw_protocol_is_registered(void *a1)
{
  int v2 = &g_registration_list;
  do
  {
    int v2 = (uint64_t *)*v2;
    if (!v2) {
      break;
    }
    BOOL v3 = *a1 == v2[4] && a1[1] == v2[5];
    BOOL v4 = v3 && a1[2] == v2[6];
    BOOL v5 = v4 && a1[3] == v2[7];
  }

  while (!v5 || a1[4] != v2[8]);
  BOOL v7 = v2 != 0LL;
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  return v7;
}

uint64_t nw_protocol_create_internal(uint64_t a1, void *a2, const char *a3, int a4)
{
  uint64_t v70 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    nw_allow_use_of_dispatch_internal();
    if (gLogDatapath)
    {
      uint64_t v46 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        os_log_type_t v59 = "nw_protocol_create_internal";
        __int16 v60 = 2080;
        uint64_t v61 = a1;
        __int16 v62 = 2080;
        logging_description = nw_endpoint_get_logging_description(a2);
        __int16 v64 = 2112;
        os_log_type_t v65 = a3;
        _os_log_impl( &dword_181A5C000,  v46,  OS_LOG_TYPE_DEBUG,  "%{public}s creating protocol %s (endpoint: %s, parameters: %@)",  buf,  0x2Au);
      }
    }

    os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_registrar_lock);
    uint64_t v8 = &g_registration_list;
    do
    {
      uint64_t v8 = (uint64_t *)*v8;
      if (!v8)
      {
        if (gLogDatapath)
        {
          uint32_t v47 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            os_log_type_t v59 = "nw_protocol_create_internal";
            __int16 v60 = 2080;
            uint64_t v61 = a1;
            __int16 v62 = 2048;
            logging_description = (const char *)a1;
            _os_log_impl( &dword_181A5C000,  v47,  OS_LOG_TYPE_DEBUG,  "%{public}s failed to find registration for identifier %s (%p)",  buf,  0x20u);
          }
        }

        uint64_t v14 = 0LL;
        goto LABEL_38;
      }
    }

    while (*(void *)a1 != v8[4]
         || *(void *)(a1 + 8) != v8[5]
         || *(void *)(a1 + 16) != v8[6]
         || *(void *)(a1 + 24) != v8[7]
         || *(void *)(a1 + 32) != v8[8]);
    uint64_t v13 = (uint64_t (*)(uint64_t, uint64_t, void *, const char *))v8[12];
    if (v13)
    {
      uint64_t v14 = v13(a1, v8[14], a2, a3);
      if (!a3) {
        goto LABEL_37;
      }
LABEL_28:
      if (!a2 || !a4 || !v14 || !v8[13]) {
        goto LABEL_37;
      }
      uint64_t v16 = a2;
      BOOL v17 = (v16[231] & 4) == 0;

      if (v17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v18 = nw_endpoint_get_logging_description(v16);
        *(_DWORD *)buf = 136446466;
        os_log_type_t v59 = "nw_protocol_create_internal";
        __int16 v60 = 2080;
        uint64_t v61 = (uint64_t)v18;
        __int16 v19 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v56 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int128 v20 = (os_log_s *)gLogObj;
          os_log_type_t v21 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            __int128 v22 = nw_endpoint_get_logging_description(v16);
            *(_DWORD *)buf = 136446466;
            os_log_type_t v59 = "nw_protocol_create_internal";
            __int16 v60 = 2080;
            uint64_t v61 = (uint64_t)v22;
            uint64_t v23 = "%{public}s endpoint %s is not registered, cannot add instance for joining";
            goto LABEL_69;
          }

          goto LABEL_76;
        }

        if (v56)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int128 v20 = (os_log_s *)gLogObj;
          os_log_type_t v21 = type;
          BOOL v31 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (backtrace_string)
          {
            if (v31)
            {
              unint64_t v32 = nw_endpoint_get_logging_description(v16);
              *(_DWORD *)buf = 136446722;
              os_log_type_t v59 = "nw_protocol_create_internal";
              __int16 v60 = 2080;
              uint64_t v61 = (uint64_t)v32;
              __int16 v62 = 2082;
              logging_description = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s endpoint %s is not registered, cannot add instance for joining, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(backtrace_string);
            goto LABEL_76;
          }

          if (v31)
          {
            char v38 = nw_endpoint_get_logging_description(v16);
            *(_DWORD *)buf = 136446466;
            os_log_type_t v59 = "nw_protocol_create_internal";
            __int16 v60 = 2080;
            uint64_t v61 = (uint64_t)v38;
            uint64_t v23 = "%{public}s endpoint %s is not registered, cannot add instance for joining, no backtrace";
            goto LABEL_69;
          }

void nw_protocol_remove_instance(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v21 = "nw_protocol_remove_instance";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v21 = "nw_protocol_remove_instance";
      int v12 = "%{public}s called with null protocol";
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v21 = "nw_protocol_remove_instance";
          __int16 v22 = 2082;
          uint64_t v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_38;
      }

      if (!v16)
      {
LABEL_38:
        if (v9) {
          free(v9);
        }
        return;
      }

      *(_DWORD *)buf = 136446210;
      os_log_type_t v21 = "nw_protocol_remove_instance";
      int v12 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      BOOL v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v21 = "nw_protocol_remove_instance";
      int v12 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
    goto LABEL_38;
  }

  nw_allow_use_of_dispatch_internal();
  if (gLogDatapath)
  {
    uint64_t v13 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v14 = *(void *)(a1 + 16);
      *(_DWORD *)buf = 136446722;
      os_log_type_t v21 = "nw_protocol_remove_instance";
      __int16 v22 = 2048;
      uint64_t v23 = (char *)a1;
      __int16 v24 = 2080;
      uint64_t v25 = v14;
      _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEBUG,  "%{public}s checking to remove instance %p of %s",  buf,  0x20u);
    }
  }

  os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  int v2 = *(void **)(a1 + 16);
  BOOL v3 = &g_registration_list;
  while (1)
  {
    BOOL v3 = (uint64_t *)*v3;
    if (!v3) {
      break;
    }
    if (*v2 == v3[4] && v2[1] == v3[5] && v2[2] == v3[6] && v2[3] == v3[7] && v2[4] == v3[8])
    {
      uint64_t v8 = v3[9];
      v17[0] = MEMORY[0x1895F87A8];
      v17[1] = 0x40000000LL;
      v17[2] = __nw_protocol_remove_instance_block_invoke;
      v17[3] = &__block_descriptor_tmp_43798;
      v17[4] = a1;
      nw_array_remove_objects(v8, (uint64_t)v17);
      break;
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
}

uint64_t __nw_protocol_remove_instance_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (!*(void *)(*(void *)(a1 + 32) + 16LL))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v21 = "nw_protocol_remove_instance_block_invoke";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v21 = "nw_protocol_remove_instance_block_invoke";
      BOOL v10 = "%{public}s called with null protocol->identifier";
    }

    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v16 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v21 = "nw_protocol_remove_instance_block_invoke";
          __int16 v22 = 2082;
          uint64_t v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null protocol->identifier, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (!v16)
      {
LABEL_21:
        if (v7) {
          free(v7);
        }
        return 1LL;
      }

      *(_DWORD *)buf = 136446210;
      os_log_type_t v21 = "nw_protocol_remove_instance_block_invoke";
      BOOL v10 = "%{public}s called with null protocol->identifier, no backtrace";
    }

    else
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v21 = "nw_protocol_remove_instance_block_invoke";
      BOOL v10 = "%{public}s called with null protocol->identifier, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
    goto LABEL_21;
  }

  if (gLogDatapath)
  {
    os_log_type_t v11 = (os_log_s *)__nwlog_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      logging_description = nw_endpoint_get_logging_description(a2);
      uint64_t v13 = *(void *)(a1 + 32);
      uint64_t v14 = *(void *)(v13 + 16);
      *(_DWORD *)buf = 136447234;
      os_log_type_t v21 = "nw_protocol_remove_instance_block_invoke";
      __int16 v22 = 2080;
      uint64_t v23 = (void *)logging_description;
      __int16 v24 = 2048;
      uint64_t v25 = a2;
      __int16 v26 = 2048;
      uint64_t v27 = v13;
      __int16 v28 = 2080;
      uint64_t v29 = v14;
      _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEBUG,  "%{public}s checking registered endpoint %s (%p) to remove instance %p of %s",  buf,  0x34u);
    }
  }

  id v4 = nw_endpoint_copy_registrar_for_identifier(a2, *(__int128 **)(*(void *)(a1 + 32) + 16LL), 0);
  if (!v4) {
    return 1LL;
  }
  BOOL v5 = v4;
  nw_protocol_instance_registrar_remove_instance(v4, *(void *)(a1 + 32));
  BOOL v6 = nw_protocol_instance_registrar_get_instance_count(v5) == 0;
  os_release(v5);
  return v6;
}

uint64_t nw_protocol_copy_shared_connection_state(uint64_t a1, uint64_t a2, void *a3, char a4)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_copy_shared_connection_state";
    __int128 v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v21, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_copy_shared_connection_state";
        uint64_t v23 = "%{public}s called with null protocol";
LABEL_54:
        _os_log_impl(&dword_181A5C000, v21, v22, v23, buf, 0xCu);
      }

void sub_182220300(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL __nw_protocol_copy_shared_connection_state_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  id v4 = nw_endpoint_copy_registrar_for_identifier(a3, *(__int128 **)(*(void *)(a1 + 40) + 16LL), 0);
  if (v4)
  {
    uint64_t v6 = *(void *)(a1 + 48);
    BOOL v5 = *(void **)(a1 + 56);
    BOOL v7 = *(void **)(a1 + 64);
    char v8 = *(_BYTE *)(a1 + 72);
    uint64_t v9 = (os_unfair_lock_s *)v4;
    id v10 = v5;
    id v11 = v7;
    int v12 = v11;
    if (v6)
    {
      if (v10)
      {
        if (v11)
        {
          uint64_t v13 = (dispatch_queue_t *)v11;
          uint64_t v14 = v13;
          if (((_BYTE)v13[17] & 8) == 0) {
            dispatch_assert_queue_V2(v13[1]);
          }

          *(void *)os_log_type_t type = 0LL;
          char v38 = type;
          uint64_t v39 = 0x3032000000LL;
          os_log_type_t v40 = __Block_byref_object_copy__3860;
          uint32_t v41 = __Block_byref_object_dispose__3861;
          id v42 = 0LL;
          *(void *)aBlock = MEMORY[0x1895F87A8];
          *(void *)&aBlock[8] = 3221225472LL;
          *(void *)&aBlock[16] = __nw_protocol_instance_registrar_copy_shared_connection_state_block_invoke;
          uint64_t v45 = &unk_189BB66F8;
          uint64_t v46 = v9;
          uint64_t v50 = v6;
          char v51 = v8;
          uint32_t v47 = v14;
          id v48 = v10;
          BOOL v49 = type;
          __int128 v15 = (void (**)(void))_Block_copy(aBlock);
          os_unfair_lock_lock(v9 + 2);
          v15[2](v15);
          os_unfair_lock_unlock(v9 + 2);

          id v16 = *((id *)v38 + 5);
          _Block_object_dispose(type, 8);

          goto LABEL_8;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v24 = (id)gLogObj;
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_copy_shared_connection_state";
        __int16 v19 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        char v43 = 0;
        if (__nwlog_fault(v19, type, &v43))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int128 v20 = (os_log_s *)(id)gLogObj;
            os_log_type_t v25 = type[0];
            if (os_log_type_enabled(v20, type[0]))
            {
              *(_DWORD *)aBlock = 136446210;
              *(void *)&aBlock[4] = "nw_protocol_instance_registrar_copy_shared_connection_state";
              _os_log_impl(&dword_181A5C000, v20, v25, "%{public}s called with null context", aBlock, 0xCu);
            }

void sub_182220C88( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, id a25, id a26, id a27)
{
  _Block_object_dispose(&a14, 8);
  _Unwind_Resume(a1);
}

void nw_protocol_enumerate_instances(void *a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v22 = "nw_protocol_enumerate_instances";
    id v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v20 = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (v20 == OS_LOG_TYPE_FAULT)
    {
      id v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = v20;
      if (!os_log_type_enabled(v11, v20)) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_enumerate_instances";
      uint64_t v13 = "%{public}s called with null identifier";
      goto LABEL_48;
    }

    if (!v19)
    {
      id v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = v20;
      if (!os_log_type_enabled(v11, v20)) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_enumerate_instances";
      uint64_t v13 = "%{public}s called with null identifier, backtrace limit exceeded";
      goto LABEL_48;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    id v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = v20;
    BOOL v15 = os_log_type_enabled(v11, v20);
    if (!backtrace_string)
    {
      if (!v15) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_enumerate_instances";
      uint64_t v13 = "%{public}s called with null identifier, no backtrace";
      goto LABEL_48;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      id v22 = "nw_protocol_enumerate_instances";
      __int16 v23 = 2082;
      id v24 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null identifier, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_49:
    if (!v10) {
      return;
    }
    goto LABEL_50;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v22 = "nw_protocol_enumerate_instances";
    id v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v20 = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (v20 == OS_LOG_TYPE_FAULT)
    {
      id v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = v20;
      if (!os_log_type_enabled(v11, v20)) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_enumerate_instances";
      uint64_t v13 = "%{public}s called with null enumerator";
      goto LABEL_48;
    }

    if (!v19)
    {
      id v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = v20;
      if (!os_log_type_enabled(v11, v20)) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_enumerate_instances";
      uint64_t v13 = "%{public}s called with null enumerator, backtrace limit exceeded";
      goto LABEL_48;
    }

    id v16 = (char *)__nw_create_backtrace_string();
    id v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = v20;
    BOOL v17 = os_log_type_enabled(v11, v20);
    if (v16)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        id v22 = "nw_protocol_enumerate_instances";
        __int16 v23 = 2082;
        id v24 = v16;
        _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null enumerator, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v16);
      if (!v10) {
        return;
      }
LABEL_50:
      free(v10);
      return;
    }

    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_enumerate_instances";
      uint64_t v13 = "%{public}s called with null enumerator, no backtrace";
LABEL_48:
      _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
      goto LABEL_49;
    }

    goto LABEL_49;
  }

  nw_allow_use_of_dispatch_internal();
  os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_registrar_lock);
  id v4 = &g_registration_list;
  while (1)
  {
    id v4 = (uint64_t *)*v4;
    if (!v4) {
      break;
    }
    if (*a1 == v4[4] && a1[1] == v4[5] && a1[2] == v4[6] && a1[3] == v4[7] && a1[4] == v4[8])
    {
      uint64_t v9 = (unsigned __int8 *)v4[9];
      v18[0] = MEMORY[0x1895F87A8];
      v18[1] = 0x40000000LL;
      v18[2] = __nw_protocol_enumerate_instances_block_invoke;
      v18[3] = &unk_189BBE310;
      v18[4] = a2;
      v18[5] = a1;
      nw_array_apply(v9, (uint64_t)v18);
      break;
    }
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_registrar_lock);
}

uint64_t __nw_protocol_enumerate_instances_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  BOOL v3 = *(void **)(a1 + 32);
  id v4 = *(__int128 **)(a1 + 40);
  id v5 = a3;
  id v6 = v3;
  BOOL v7 = v6;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v12 = (id)gLogObj;
    *(_DWORD *)aBlock = 136446210;
    *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v14 = (os_log_s *)(id)gLogObj;
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null registered_endpoint", aBlock, 0xCu);
      }
    }

    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v14 = (os_log_s *)(id)gLogObj;
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)aBlock = 136446466;
          *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
          *(_WORD *)&aBlock[12] = 2082;
          *(void *)&aBlock[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s called with null registered_endpoint, dumping backtrace:%{public}s",  aBlock,  0x16u);
        }

        free(backtrace_string);
LABEL_57:
        if (!v13) {
          goto LABEL_7;
        }
LABEL_58:
        free(v13);
        goto LABEL_7;
      }

      if (v22)
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
        _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s called with null registered_endpoint, no backtrace",  aBlock,  0xCu);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v14 = (os_log_s *)(id)gLogObj;
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
        _os_log_impl( &dword_181A5C000,  v14,  v28,  "%{public}s called with null registered_endpoint, backtrace limit exceeded",  aBlock,  0xCu);
      }
    }

void sub_182221A00( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_register_parameter_modifier(uint64_t a1)
{
  int v2 = calloc(1uLL, 0x18uLL);
  if (!v2)
  {
    id v5 = (os_log_s *)__nwlog_obj();
    os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    id v6 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v6);
    if (result)
    {
      __break(1u);
      return result;
    }

    free(v6);
  }

  v2[2] = a1;
  uint64_t v3 = g_modifier_list;
  void *v2 = g_modifier_list;
  if (v3) {
    *(void *)(v3 + _Block_object_dispose(&a9, 8) = v2;
  }
  g_modifier_list = (uint64_t)v2;
  v2[1] = &g_modifier_list;
  has_modifiers = 1;
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_modify_lock);
  return 1LL;
}

const char *nw_protocol_notification_type_to_string(unsigned int a1)
{
  if (a1 > 0x1A) {
    return "unknown";
  }
  else {
    return off_189BBE330[a1];
  }
}

BOOL nw_protocol_input_handler_is_connection_flow(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v12 = "nw_protocol_input_handler_is_connection_flow";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v9 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446210;
      id v12 = "nw_protocol_input_handler_is_connection_flow";
      id v6 = "%{public}s called with null input_handler";
    }

    else if (v9)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          id v12 = "nw_protocol_input_handler_is_connection_flow";
          __int16 v13 = 2082;
          uint64_t v14 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null input_handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (!v8)
      {
LABEL_20:
        if (v3) {
          free(v3);
        }
        return 0LL;
      }

      *(_DWORD *)buf = 136446210;
      id v12 = "nw_protocol_input_handler_is_connection_flow";
      id v6 = "%{public}s called with null input_handler, no backtrace";
    }

    else
    {
      id v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446210;
      id v12 = "nw_protocol_input_handler_is_connection_flow";
      id v6 = "%{public}s called with null input_handler, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    goto LABEL_20;
  }

  id v1 = *(const char **)(a1 + 16);
  if (!v1) {
    return 0LL;
  }
  return !strcmp(*(const char **)(a1 + 16), "endpoint_flow") || strcmp(v1, "flow_replay") == 0;
}

const char *nw_protocol_input_handler_is_flow_replay(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    BOOL result = *(const char **)(a1 + 16);
    if (result) {
      return (const char *)(strcmp(result, "flow_replay") == 0);
    }
    return result;
  }

  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v11 = "nw_protocol_input_handler_is_flow_replay";
  int v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        id v11 = "nw_protocol_input_handler_is_flow_replay";
        os_log_type_t v5 = "%{public}s called with null input_handler";
LABEL_18:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          id v11 = "nw_protocol_input_handler_is_flow_replay";
          __int16 v12 = 2082;
          __int16 v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null input_handler, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }

      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        id v11 = "nw_protocol_input_handler_is_flow_replay";
        os_log_type_t v5 = "%{public}s called with null input_handler, no backtrace";
        goto LABEL_18;
      }
    }

    else
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        id v11 = "nw_protocol_input_handler_is_flow_replay";
        os_log_type_t v5 = "%{public}s called with null input_handler, backtrace limit exceeded";
        goto LABEL_18;
      }
    }
  }

uint64_t nw_libnetwork_library_initializer(void)
{
  return si_set_path_check();
}

void __nw_utilities_set_log_intercept_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (*(_BYTE *)(a1 + 32)) {
    BOOL v1 = nw_utilities_set_log_intercept::stream == 0;
  }
  else {
    BOOL v1 = 0;
  }
  if (v1)
  {
    id v4 = (id)nw_utilities_get_log_event_source(void)::source;
    if (v4)
    {
      gotLoadHelper_x8__OBJC_CLASS___OSLogEventLiveStream(v5);
      uint64_t v7 = [objc_alloc(*(Class *)(v6 + 2072)) initWithLiveSource:v4];
      char v8 = (void *)nw_utilities_set_log_intercept::stream;
      nw_utilities_set_log_intercept::stream = v7;

      [(id)nw_utilities_set_log_intercept::stream setFlags:7];
      objc_msgSend( MEMORY[0x1896079C8],  "predicateWithFormat:",  @"processIdentifier == %d && subsystem == com.apple.network",  getpid());
      char v9 = (void *)objc_claimAutoreleasedReturnValue();
      [(id)nw_utilities_set_log_intercept::stream setFilterPredicate:v9];

      [(id)nw_utilities_set_log_intercept::stream setStreamHandler:&__block_literal_global_43904];
      [(id)nw_utilities_set_log_intercept::stream activate];
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v10 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v12 = "nw_utilities_set_log_intercept_block_invoke";
        _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s Unable to start intercept, no log source",  buf,  0xCu);
      }
    }
  }

  else
  {
    if (*(_BYTE *)(a1 + 32)) {
      BOOL v2 = 1;
    }
    else {
      BOOL v2 = nw_utilities_set_log_intercept::stream == 0;
    }
    if (!v2)
    {
      [(id)nw_utilities_set_log_intercept::stream invalidate];
      uint64_t v3 = (void *)nw_utilities_set_log_intercept::stream;
      nw_utilities_set_log_intercept::stream = 0LL;
    }
  }

void sub_182222278(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  _Unwind_Resume(a1);
}

void __nw_utilities_set_log_intercept_block_invoke_3(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 composedMessage];
  BOOL v2 = (void *)objc_claimAutoreleasedReturnValue();
  __nwlog_handle_composed([v2 UTF8String], objc_msgSend(v3, "unixDate"));
}

void sub_1822222F4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void ___ZL33nw_utilities_get_log_event_sourcev_block_invoke(double a1)
{
  if (objc_opt_class())
  {
    id v2 = objc_alloc_init(*(Class *)(v1 + 2064));
    id v3 = (void *)nw_utilities_get_log_event_source(void)::source;
    nw_utilities_get_log_event_source(void)::BOOL source = (uint64_t)v2;
  }

void *nw_utilities_public_key_info_for_sec_identity(void *a1)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    id v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    int v55 = "nw_utilities_public_key_info_for_sec_identity";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(privateKeyRef) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (privateKeyRef == 17)
    {
      __nwlog_obj();
      os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = privateKeyRef;
      if (os_log_type_enabled(v20, (os_log_type_t)privateKeyRef))
      {
        *(_DWORD *)buf = 136446210;
        int v55 = "nw_utilities_public_key_info_for_sec_identity";
        _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null identity", buf, 0xCu);
      }
    }

    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v34 = privateKeyRef;
      BOOL v35 = os_log_type_enabled(v20, (os_log_type_t)privateKeyRef);
      if (backtrace_string)
      {
        if (v35)
        {
          *(_DWORD *)buf = 136446466;
          int v55 = "nw_utilities_public_key_info_for_sec_identity";
          __int16 v56 = 2082;
          uint64_t v57 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v20,  v34,  "%{public}s called with null identity, dumping backtrace:%{public}s",  buf,  0x16u);
        }

LABEL_78:
        free(backtrace_string);
        if (!v19) {
          goto LABEL_114;
        }
        goto LABEL_113;
      }

      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        int v55 = "nw_utilities_public_key_info_for_sec_identity";
        _os_log_impl(&dword_181A5C000, v20, v34, "%{public}s called with null identity, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v46 = privateKeyRef;
      if (os_log_type_enabled(v20, (os_log_type_t)privateKeyRef))
      {
        *(_DWORD *)buf = 136446210;
        int v55 = "nw_utilities_public_key_info_for_sec_identity";
        _os_log_impl( &dword_181A5C000,  v20,  v46,  "%{public}s called with null identity, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_1822230C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

sec_identity_t nw_utilities_identity_for_key_pair(__SecKey *a1)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  SecKeyRef v1 = SecKeyCopyPublicKey(a1);
  SelfSignedCertificate = (const void *)SecGenerateSelfSignedCertificate();
  if (v1) {
    CFRelease(v1);
  }
  if (!SelfSignedCertificate)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)(id)gLogObj;
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s SecGenerateSelfSignedCertificate failed", buf, 0xCu);
      }

      goto LABEL_55;
    }

    if (!v27)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)(id)gLogObj;
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
        _os_log_impl( &dword_181A5C000,  v7,  v22,  "%{public}s SecGenerateSelfSignedCertificate failed, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_55;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)(id)gLogObj;
    os_log_type_t v14 = type;
    BOOL v15 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
        _os_log_impl( &dword_181A5C000,  v7,  v14,  "%{public}s SecGenerateSelfSignedCertificate failed, no backtrace",  buf,  0xCu);
      }

      goto LABEL_55;
    }

    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
      __int16 v31 = 2082;
      os_log_type_t v32 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v7,  v14,  "%{public}s SecGenerateSelfSignedCertificate failed, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_30;
  }

  id v3 = (__SecIdentity *)SecIdentityCreate();
  CFRelease(SelfSignedCertificate);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (os_log_s *)(id)gLogObj;
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
        _os_log_impl(&dword_181A5C000, v7, v12, "%{public}s SecIdentityCreate failed", buf, 0xCu);
      }

void sub_182223918(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_utilities_trust_ref_matches_public_key(void *a1, void *a2, _BYTE *a3)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  uint64_t v7 = sec_trust_copy_ref(v5);
  os_log_type_t v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
    os_log_type_t v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v52 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
        _os_log_impl(&dword_181A5C000, v27, v28, "%{public}s called with null trustRef", buf, 0xCu);
      }
    }

    else if (v52)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v36 = type;
      BOOL v37 = os_log_type_enabled(v27, type);
      if (backtrace_string)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
          __int16 v57 = 2082;
          uint64_t v58 = (uint64_t)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v27,  v36,  "%{public}s called with null trustRef, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v26) {
          goto LABEL_73;
        }
        goto LABEL_72;
      }

      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
        _os_log_impl(&dword_181A5C000, v27, v36, "%{public}s called with null trustRef, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v44 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
        _os_log_impl( &dword_181A5C000,  v27,  v44,  "%{public}s called with null trustRef, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_70;
  }

  SecKeyRef v9 = SecTrustCopyKey(v7);
  CFRelease(v8);
  if (!v9)
  {
    __nwlog_obj();
    os_log_type_t v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
    os_log_type_t v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v52 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
        _os_log_impl(&dword_181A5C000, v27, v30, "%{public}s called with null publicKey", buf, 0xCu);
      }
    }

    else if (v52)
    {
      BOOL v38 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v39 = type;
      BOOL v40 = os_log_type_enabled(v27, type);
      if (v38)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
          __int16 v57 = 2082;
          uint64_t v58 = (uint64_t)v38;
          _os_log_impl( &dword_181A5C000,  v27,  v39,  "%{public}s called with null publicKey, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v38);
LABEL_71:
        if (!v26)
        {
LABEL_73:
          uint64_t v21 = 0LL;
          goto LABEL_24;
        }

void sub_182224224( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t nw_utilities_cidr_string_to_subnet_and_mask(const char *a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v65 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    BOOL v43 = (void *)objc_claimAutoreleasedReturnValue();
    int __dst = 136446210;
    __int16 v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
    os_log_type_t v44 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v59)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v46 = type;
        BOOL v52 = os_log_type_enabled(v45, type);
        if (backtrace_string)
        {
          if (v52)
          {
            int __dst = 136446466;
            __int16 v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
            __int16 v63 = 2082;
            __int16 v64 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v45,  v46,  "%{public}s called with null netstr, dumping backtrace:%{public}s",  (uint8_t *)&__dst,  0x16u);
          }

          free(backtrace_string);
LABEL_151:
          if (!v44) {
            return 0LL;
          }
LABEL_152:
          free(v44);
          return 0LL;
        }

        if (v52)
        {
          int __dst = 136446210;
          __int16 v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
          os_log_type_t v47 = "%{public}s called with null netstr, no backtrace";
          goto LABEL_149;
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v46 = type;
        if (os_log_type_enabled(v45, type))
        {
          int __dst = 136446210;
          __int16 v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
          os_log_type_t v47 = "%{public}s called with null netstr, backtrace limit exceeded";
          goto LABEL_149;
        }
      }

      goto LABEL_150;
    }

    __nwlog_obj();
    os_log_type_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v46 = type;
    if (!os_log_type_enabled(v45, type)) {
      goto LABEL_150;
    }
    int __dst = 136446210;
    __int16 v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
    os_log_type_t v47 = "%{public}s called with null netstr";
    goto LABEL_149;
  }

  if (!a2)
  {
    __nwlog_obj();
    __int128 v48 = (void *)objc_claimAutoreleasedReturnValue();
    int __dst = 136446210;
    __int16 v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
    os_log_type_t v44 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v59)
      {
        __nwlog_obj();
        os_log_type_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v46 = type;
        if (os_log_type_enabled(v45, type))
        {
          int __dst = 136446210;
          __int16 v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
          os_log_type_t v47 = "%{public}s called with null network, backtrace limit exceeded";
          goto LABEL_149;
        }

        goto LABEL_150;
      }

      os_log_type_t v53 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v46 = type;
      BOOL v54 = os_log_type_enabled(v45, type);
      if (!v53)
      {
        if (v54)
        {
          int __dst = 136446210;
          __int16 v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
          os_log_type_t v47 = "%{public}s called with null network, no backtrace";
          goto LABEL_149;
        }

        goto LABEL_150;
      }

      if (!v54) {
        goto LABEL_131;
      }
      int __dst = 136446466;
      __int16 v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
      __int16 v63 = 2082;
      __int16 v64 = v53;
      int v55 = "%{public}s called with null network, dumping backtrace:%{public}s";
      goto LABEL_130;
    }

    __nwlog_obj();
    os_log_type_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v46 = type;
    if (!os_log_type_enabled(v45, type)) {
      goto LABEL_150;
    }
    int __dst = 136446210;
    __int16 v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
    os_log_type_t v47 = "%{public}s called with null network";
LABEL_149:
    _os_log_impl(&dword_181A5C000, v45, v46, v47, (uint8_t *)&__dst, 0xCu);
    goto LABEL_150;
  }

  if (!a3)
  {
    __nwlog_obj();
    __int128 v49 = (void *)objc_claimAutoreleasedReturnValue();
    int __dst = 136446210;
    __int16 v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
    os_log_type_t v44 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v46 = type;
      if (!os_log_type_enabled(v45, type)) {
        goto LABEL_150;
      }
      int __dst = 136446210;
      __int16 v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
      os_log_type_t v47 = "%{public}s called with null mask";
      goto LABEL_149;
    }

    if (!v59)
    {
      __nwlog_obj();
      os_log_type_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v45, type))
      {
        int __dst = 136446210;
        __int16 v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
        os_log_type_t v47 = "%{public}s called with null mask, backtrace limit exceeded";
        goto LABEL_149;
      }

      goto LABEL_150;
    }

    os_log_type_t v53 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v46 = type;
    BOOL v56 = os_log_type_enabled(v45, type);
    if (!v53)
    {
      if (v56)
      {
        int __dst = 136446210;
        __int16 v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
        os_log_type_t v47 = "%{public}s called with null mask, no backtrace";
        goto LABEL_149;
      }

      goto LABEL_150;
    }

    if (!v56) {
      goto LABEL_131;
    }
    int __dst = 136446466;
    __int16 v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
    __int16 v63 = 2082;
    __int16 v64 = v53;
    int v55 = "%{public}s called with null mask, dumping backtrace:%{public}s";
LABEL_130:
    _os_log_impl(&dword_181A5C000, v45, v46, v55, (uint8_t *)&__dst, 0x16u);
    goto LABEL_131;
  }

  if (!a4)
  {
    __nwlog_obj();
    __int128 v50 = (void *)objc_claimAutoreleasedReturnValue();
    int __dst = 136446210;
    __int16 v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
    os_log_type_t v44 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v45, type))
      {
        int __dst = 136446210;
        __int16 v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
        os_log_type_t v47 = "%{public}s called with null prefix";
        goto LABEL_149;
      }

BOOL nw_string_is_ip_address(const char *a1, void *a2, size_t a3)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    char v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_string_is_ip_address";
    size_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v15, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_string_is_ip_address";
          uint64_t v18 = "%{public}s called with null str";
LABEL_42:
          _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
        }

uint64_t nw_utilities_copy_local_entitlement_value(char *cStr)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  if (!cStr)
  {
    __nwlog_obj();
    BOOL v41 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    __int128 v51 = "nw_utilities_copy_local_entitlement_value";
    int v13 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(error) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (error == 17)
    {
      __nwlog_obj();
      os_log_type_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v42 = error;
      if (os_log_type_enabled(v17, (os_log_type_t)error))
      {
        *(_DWORD *)buf = 136446210;
        __int128 v51 = "nw_utilities_copy_local_entitlement_value";
        _os_log_impl(&dword_181A5C000, v17, v42, "%{public}s called with null entitlement", buf, 0xCu);
      }
    }

    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v44 = error;
      BOOL v45 = os_log_type_enabled(v17, (os_log_type_t)error);
      if (backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          __int128 v51 = "nw_utilities_copy_local_entitlement_value";
          __int16 v52 = 2082;
          CFErrorRef v53 = (CFErrorRef)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v17,  v44,  "%{public}s called with null entitlement, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_74;
      }

      if (v45)
      {
        *(_DWORD *)buf = 136446210;
        __int128 v51 = "nw_utilities_copy_local_entitlement_value";
        _os_log_impl(&dword_181A5C000, v17, v44, "%{public}s called with null entitlement, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v46 = error;
      if (os_log_type_enabled(v17, (os_log_type_t)error))
      {
        *(_DWORD *)buf = 136446210;
        __int128 v51 = "nw_utilities_copy_local_entitlement_value";
        _os_log_impl( &dword_181A5C000,  v17,  v46,  "%{public}s called with null entitlement, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_18222606C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_utilities_get_c_string_from_cfstring(const __CFString *a1, CFStringEncoding a2, void *a3)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  int v5 = a3;
  BOOL v6 = v5;
  if (!a1)
  {
    __nwlog_obj();
    os_log_type_t v28 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v42 = "nw_utilities_get_c_string_from_cfstring";
    uint64_t v10 = _os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_utilities_get_c_string_from_cfstring";
        _os_log_impl(&dword_181A5C000, v12, v29, "%{public}s called with null stringRef", buf, 0xCu);
      }

      goto LABEL_79;
    }

    if (!v39)
    {
      __nwlog_obj();
      id v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v37 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_utilities_get_c_string_from_cfstring";
        _os_log_impl( &dword_181A5C000,  v12,  v37,  "%{public}s called with null stringRef, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_79;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    id v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v33 = type;
    BOOL v34 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_utilities_get_c_string_from_cfstring";
        _os_log_impl(&dword_181A5C000, v12, v33, "%{public}s called with null stringRef, no backtrace", buf, 0xCu);
      }

      goto LABEL_79;
    }

    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v42 = "nw_utilities_get_c_string_from_cfstring";
      __int16 v43 = 2082;
      os_log_type_t v44 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v12,  v33,  "%{public}s called with null stringRef, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_66;
  }

  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v30 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v42 = "nw_utilities_get_c_string_from_cfstring";
    uint64_t v10 = _os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_utilities_get_c_string_from_cfstring";
        _os_log_impl(&dword_181A5C000, v12, v31, "%{public}s called with null access_block", buf, 0xCu);
      }

      goto LABEL_79;
    }

    if (!v39)
    {
      __nwlog_obj();
      id v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v38 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_utilities_get_c_string_from_cfstring";
        _os_log_impl( &dword_181A5C000,  v12,  v38,  "%{public}s called with null access_block, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_79;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    id v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v35 = type;
    BOOL v36 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_utilities_get_c_string_from_cfstring";
        _os_log_impl(&dword_181A5C000, v12, v35, "%{public}s called with null access_block, no backtrace", buf, 0xCu);
      }

      goto LABEL_79;
    }

    if (v36)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v42 = "nw_utilities_get_c_string_from_cfstring";
      __int16 v43 = 2082;
      os_log_type_t v44 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v12,  v35,  "%{public}s called with null access_block, dumping backtrace:%{public}s",  buf,  0x16u);
    }

void sub_182226A34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_utf8_validator_init(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(_WORD *)a1 = 0;
    *(_BYTE *)(a1 + 2) = 0;
    return;
  }

  __nwlog_obj();
  SecKeyRef v1 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  id v11 = "nw_utf8_validator_init";
  id v2 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      CFStringRef v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        id v11 = "nw_utf8_validator_init";
        int v5 = "%{public}s called with null state";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else
    {
      if (v8)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        CFStringRef v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v4 = type;
        BOOL v7 = os_log_type_enabled(v3, type);
        if (backtrace_string)
        {
          if (v7)
          {
            *(_DWORD *)buf = 136446466;
            id v11 = "nw_utf8_validator_init";
            __int16 v12 = 2082;
            os_log_type_t v13 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null state, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (!v7) {
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446210;
        id v11 = "nw_utf8_validator_init";
        int v5 = "%{public}s called with null state, no backtrace";
        goto LABEL_17;
      }

      __nwlog_obj();
      CFStringRef v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        id v11 = "nw_utf8_validator_init";
        int v5 = "%{public}s called with null state, backtrace limit exceeded";
        goto LABEL_17;
      }
    }

uint64_t nw_utf8_validator_parse(char *a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    uint64_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v27 = "nw_utf8_validator_parse";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v15, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v27 = "nw_utf8_validator_parse";
          os_log_type_t v18 = "%{public}s called with null state";
LABEL_86:
          _os_log_impl(&dword_181A5C000, v16, v17, v18, buf, 0xCu);
        }

BOOL nw_utf8_validator_is_parsing(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (a1) {
    return *(_BYTE *)(a1 + 2) != 0;
  }
  __nwlog_obj();
  id v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v12 = "nw_utf8_validator_is_parsing";
  CFStringRef v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v12 = "nw_utf8_validator_is_parsing";
        unsigned int v6 = "%{public}s called with null state";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v5 = type;
        BOOL v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v12 = "nw_utf8_validator_is_parsing";
            __int16 v13 = 2082;
            uint64_t v14 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null state, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (!v8) {
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v12 = "nw_utf8_validator_is_parsing";
        unsigned int v6 = "%{public}s called with null state, no backtrace";
        goto LABEL_17;
      }

      __nwlog_obj();
      int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v12 = "nw_utf8_validator_is_parsing";
        unsigned int v6 = "%{public}s called with null state, backtrace limit exceeded";
        goto LABEL_17;
      }
    }

void nw_utilities_get_uuid_for_pid(int pid, _OWORD *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (!pid)
  {
    __nwlog_obj();
    os_log_type_t v5 = (void *)objc_claimAutoreleasedReturnValue();
    LODWORD(buffer[0]) = 136446210;
    *(void *)((char *)buffer + 4) = "nw_utilities_get_uuid_for_pid";
    unsigned int v6 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    char v16 = 0;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = buf[0];
      if (os_log_type_enabled(v7, (os_log_type_t)buf[0]))
      {
        LODWORD(buffer[0]) = 136446210;
        *(void *)((char *)buffer + 4) = "nw_utilities_get_uuid_for_pid";
        char v9 = "%{public}s called with null pid";
LABEL_42:
        _os_log_impl(&dword_181A5C000, v7, v8, v9, (uint8_t *)buffer, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = buf[0];
      BOOL v12 = os_log_type_enabled(v7, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v12)
        {
          LODWORD(buffer[0]) = 136446466;
          *(void *)((char *)buffer + 4) = "nw_utilities_get_uuid_for_pid";
          WORD6(buffer[0]) = 2082;
          *(void *)((char *)buffer + 14) = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null pid, dumping backtrace:%{public}s",  (uint8_t *)buffer,  0x16u);
        }

        free(backtrace_string);
LABEL_44:
        if (!v6) {
          return;
        }
LABEL_45:
        free(v6);
        return;
      }

      if (v12)
      {
        LODWORD(buffer[0]) = 136446210;
        *(void *)((char *)buffer + 4) = "nw_utilities_get_uuid_for_pid";
        char v9 = "%{public}s called with null pid, no backtrace";
        goto LABEL_42;
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = buf[0];
      if (os_log_type_enabled(v7, (os_log_type_t)buf[0]))
      {
        LODWORD(buffer[0]) = 136446210;
        *(void *)((char *)buffer + 4) = "nw_utilities_get_uuid_for_pid";
        char v9 = "%{public}s called with null pid, backtrace limit exceeded";
        goto LABEL_42;
      }
    }

BOOL nw_utilities_copy_bundle_id_for_uuid(const unsigned __int8 *a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (uuid_is_null(a1))
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446466;
    int v22 = "nw_utilities_copy_bundle_id_for_uuid";
    __int16 v23 = 2080;
    *(void *)char v24 = "nw_utilities_copy_bundle_id_for_uuid";
    char v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v9, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446466;
          int v22 = "nw_utilities_copy_bundle_id_for_uuid";
          __int16 v23 = 2080;
          *(void *)char v24 = "nw_utilities_copy_bundle_id_for_uuid";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s NULL uuid passed to %s", buf, 0x16u);
        }
      }

      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446722;
            int v22 = "nw_utilities_copy_bundle_id_for_uuid";
            __int16 v23 = 2080;
            *(void *)char v24 = "nw_utilities_copy_bundle_id_for_uuid";
            *(_WORD *)&v24[8] = 2082;
            *(void *)&v24[10] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v14,  "%{public}s NULL uuid passed to %s, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(backtrace_string);
          goto LABEL_35;
        }

        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          int v22 = "nw_utilities_copy_bundle_id_for_uuid";
          __int16 v23 = 2080;
          *(void *)char v24 = "nw_utilities_copy_bundle_id_for_uuid";
          _os_log_impl(&dword_181A5C000, v10, v14, "%{public}s NULL uuid passed to %s, no backtrace", buf, 0x16u);
        }
      }

      else
      {
        __nwlog_obj();
        char v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446466;
          int v22 = "nw_utilities_copy_bundle_id_for_uuid";
          __int16 v23 = 2080;
          *(void *)char v24 = "nw_utilities_copy_bundle_id_for_uuid";
          _os_log_impl( &dword_181A5C000,  v10,  v16,  "%{public}s NULL uuid passed to %s, backtrace limit exceeded",  buf,  0x16u);
        }
      }
    }

void sub_182227EC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_utilities_copy_bundle_id_for_pid(int a1)
{
  uint64_t v13 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    CFStringRef v3 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)uu = 136446210;
    *(void *)&uu[4] = "nw_utilities_copy_bundle_id_for_pid";
    int v4 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)uu = 136446210;
        *(void *)&uu[4] = "nw_utilities_copy_bundle_id_for_pid";
        int v7 = "%{public}s called with null pid";
LABEL_18:
        _os_log_impl(&dword_181A5C000, v5, v6, v7, uu, 0xCu);
      }
    }

    else
    {
      if (v10)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v6 = type;
        BOOL v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *(_DWORD *)uu = 136446466;
            *(void *)&uu[4] = "nw_utilities_copy_bundle_id_for_pid";
            *(_WORD *)&uu[12] = 2082;
            *(void *)&uu[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null pid, dumping backtrace:%{public}s",  uu,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v9) {
          goto LABEL_19;
        }
        *(_DWORD *)uu = 136446210;
        *(void *)&uu[4] = "nw_utilities_copy_bundle_id_for_pid";
        int v7 = "%{public}s called with null pid, no backtrace";
        goto LABEL_18;
      }

      __nwlog_obj();
      os_log_type_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)uu = 136446210;
        *(void *)&uu[4] = "nw_utilities_copy_bundle_id_for_pid";
        int v7 = "%{public}s called with null pid, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

BOOL nw_utilities_copy_bundle_id_for_audit_token(__int128 *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  __int128 v1 = a1[1];
  __int128 v14 = *a1;
  __int128 v15 = v1;
  if (!((unint64_t)v14 | *((void *)&v14 + 1) | (unint64_t)v1 | *((void *)&v1 + 1)))
  {
    __nwlog_obj();
    int v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446466;
    os_log_type_t v17 = "nw_utilities_copy_bundle_id_for_audit_token";
    __int16 v18 = 2080;
    char v19 = "nw_utilities_copy_bundle_id_for_audit_token";
    os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v17 = "nw_utilities_copy_bundle_id_for_audit_token";
        __int16 v18 = 2080;
        char v19 = "nw_utilities_copy_bundle_id_for_audit_token";
        os_log_type_t v8 = "%{public}s NULL audit_token passed to %s";
LABEL_21:
        _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0x16u);
      }
    }

    else
    {
      if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v7 = type;
        BOOL v11 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446722;
            os_log_type_t v17 = "nw_utilities_copy_bundle_id_for_audit_token";
            __int16 v18 = 2080;
            char v19 = "nw_utilities_copy_bundle_id_for_audit_token";
            __int16 v20 = 2082;
            __int16 v21 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s NULL audit_token passed to %s, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }

        if (!v11) {
          goto LABEL_22;
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v17 = "nw_utilities_copy_bundle_id_for_audit_token";
        __int16 v18 = 2080;
        char v19 = "nw_utilities_copy_bundle_id_for_audit_token";
        os_log_type_t v8 = "%{public}s NULL audit_token passed to %s, no backtrace";
        goto LABEL_21;
      }

      __nwlog_obj();
      os_log_type_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v17 = "nw_utilities_copy_bundle_id_for_audit_token";
        __int16 v18 = 2080;
        char v19 = "nw_utilities_copy_bundle_id_for_audit_token";
        os_log_type_t v8 = "%{public}s NULL audit_token passed to %s, backtrace limit exceeded";
        goto LABEL_21;
      }
    }

void nw_utilities_get_self_uuid(_OWORD *a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (nw_utilities_get_self_uuid::onceToken != -1) {
      dispatch_once(&nw_utilities_get_self_uuid::onceToken, &__block_literal_global_6_44145);
    }
    if (gLogDatapath)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        uint64_t v13 = "nw_utilities_get_self_uuid";
        __int16 v14 = 1024;
        *(_DWORD *)__int128 v15 = nw_utilities_get_self_uuid::self_pid;
        *(_WORD *)&v15[4] = 1040;
        *(_DWORD *)&v15[6] = 16;
        __int16 v16 = 2096;
        os_log_type_t v17 = &nw_utilities_get_self_uuid::self_uuid;
        _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s Self UUID for pid %d: %{uuid_t}.16P",  buf,  0x22u);
      }
    }

    *a1 = nw_utilities_get_self_uuid::self_uuid;
    return;
  }

  __nwlog_obj();
  int v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)buf = 136446210;
  uint64_t v13 = "nw_utilities_get_self_uuid";
  CFStringRef v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v3, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_utilities_get_self_uuid";
        os_log_type_t v6 = "%{public}s called with null out_uuid";
LABEL_23:
        _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v10)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v5 = type;
        BOOL v9 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v13 = "nw_utilities_get_self_uuid";
            __int16 v14 = 2082;
            *(void *)__int128 v15 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null out_uuid, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }

        if (!v9) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_utilities_get_self_uuid";
        os_log_type_t v6 = "%{public}s called with null out_uuid, no backtrace";
        goto LABEL_23;
      }

      __nwlog_obj();
      int v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_utilities_get_self_uuid";
        os_log_type_t v6 = "%{public}s called with null out_uuid, backtrace limit exceeded";
        goto LABEL_23;
      }
    }

void __nw_utilities_get_self_uuid_block_invoke()
{
  pid_t v0 = getpid();
  nw_utilities_get_self_uuid::self_pid = v0;
  if (v0) {
    nw_utilities_get_uuid_for_pid(v0, &nw_utilities_get_self_uuid::self_uuid);
  }
}

uint64_t nw_utilities_get_self_bundle_id()
{
  if (nw_utilities_get_self_bundle_id::onceToken != -1) {
    dispatch_once(&nw_utilities_get_self_bundle_id::onceToken, &__block_literal_global_7);
  }
  return nw_utilities_get_self_bundle_id::bundle_identifier_string;
}

uint64_t __nw_utilities_get_self_bundle_id_block_invoke()
{
  uint64_t result = (uint64_t)CFBundleGetMainBundle();
  if (result)
  {
    uint64_t result = (uint64_t)CFBundleGetValueForInfoDictionaryKey((CFBundleRef)result, (CFStringRef)*MEMORY[0x189604E00]);
    if (result)
    {
      __int128 v1 = (const __CFString *)result;
      uint64_t result = CFStringGetLength((CFStringRef)result);
      if (result >= 1)
      {
        uint64_t result = nw_utilities_create_c_string_from_cfstring(v1);
        nw_utilities_get_self_bundle_id::bundle_identifier_string = result;
      }
    }
  }

  return result;
}

uint64_t nw_utilities_get_self_name()
{
  if (nw_utilities_get_self_name::onceToken != -1) {
    dispatch_once(&nw_utilities_get_self_name::onceToken, &__block_literal_global_8_44151);
  }
  return nw_utilities_get_self_name::name;
}

void __nw_utilities_get_self_name_block_invoke()
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (nw_utilities_get_self_bundle_id::onceToken != -1) {
    dispatch_once(&nw_utilities_get_self_bundle_id::onceToken, &__block_literal_global_7);
  }
  p_cache = &OBJC_CLASS___NWConcrete_nw_activity.cache;
  nw_utilities_get_self_name::name = nw_utilities_get_self_bundle_id::bundle_identifier_string;
  if (!nw_utilities_get_self_bundle_id::bundle_identifier_string)
  {
    __int128 buffer = 0u;
    memset(v6, 0, sizeof(v6));
    pid_t v1 = getpid();
    if (proc_pidinfo(v1, 13, 1uLL, &buffer, 64) != 64 || !LOBYTE(v6[0]))
    {
      if (nw_utilities_get_self_name::name) {
        return;
      }
      goto LABEL_10;
    }

    int v2 = strdup((const char *)v6);
    if (!v2)
    {
      __nwlog_obj();
      CFStringRef v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
      int v7 = 136446210;
      os_log_type_t v8 = "strict_strdup";
      int v4 = (void *)_os_log_send_and_compose_impl();

      if (__nwlog_abort((uint64_t)v4))
      {
        __break(1u);
        return;
      }

      free(v4);
      int v2 = 0LL;
      p_cache = (void **)(&OBJC_CLASS___NWConcrete_nw_activity + 16);
    }

    p_cache[345] = v2;
    if (!v2) {
LABEL_10:
    }
      p_cache[345] = (void *)getprogname();
  }

uint64_t nw_utilities_get_user_agent()
{
  if (nw_utilities_get_user_agent::onceToken != -1) {
    dispatch_once(&nw_utilities_get_user_agent::onceToken, &__block_literal_global_9_44154);
  }
  return nw_utilities_get_user_agent::user_agent_string;
}

void __nw_utilities_get_user_agent_block_invoke()
{
  pid_t v0 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL);
  MainBundle = CFBundleGetMainBundle();
  if (!MainBundle) {
    goto LABEL_14;
  }
  CFStringRef v3 = MainBundle;
  InfoDictionary = CFBundleGetInfoDictionary(MainBundle);
  if (InfoDictionary)
  {
    Value = CFDictionaryGetValue(InfoDictionary, (const void *)*MEMORY[0x189604E10]);
    CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(v3, (CFStringRef)*MEMORY[0x189604E18]);
    CFTypeRef v7 = ValueForInfoDictionaryKey;
    if (Value)
    {
      if (ValueForInfoDictionaryKey) {
        CFStringAppendFormat(Mutable, 0LL, @"%@/%@", Value, ValueForInfoDictionaryKey);
      }
      else {
        CFStringAppendFormat(Mutable, 0LL, @"%@", Value);
      }
      goto LABEL_14;
    }
  }

  else
  {
    CFTypeRef v7 = CFBundleGetValueForInfoDictionaryKey(v3, (CFStringRef)*MEMORY[0x189604E18]);
  }

  if (nw_utilities_get_self_name::onceToken != -1) {
    dispatch_once(&nw_utilities_get_self_name::onceToken, &__block_literal_global_8_44151);
  }
  if (nw_utilities_get_self_name::name)
  {
    if (v7) {
      CFStringAppendFormat(Mutable, 0LL, @"%s/%@", nw_utilities_get_self_name::name, v7);
    }
    else {
      CFStringAppendFormat(Mutable, 0LL, @"%s", nw_utilities_get_self_name::name);
    }
  }

uint64_t nw_utilities_get_self_is_daemon()
{
  if (nw_utilities_get_self_is_daemon::onceToken != -1) {
    dispatch_once(&nw_utilities_get_self_is_daemon::onceToken, &__block_literal_global_33);
  }
  return nw_utilities_get_self_is_daemon::is_daemon;
}

void __nw_utilities_get_self_is_daemon_block_invoke(double a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  gotLoadHelper_x19__OBJC_CLASS___RBSProcessHandle(a1);
  if (objc_opt_class()
    && ([*(id *)(v1 + 728) currentProcess],
        int v2 = (void *)objc_claimAutoreleasedReturnValue(),
        char v3 = [v2 isDaemon],
        v2,
        (v3 & 1) != 0))
  {
    BOOL v4 = 1;
  }

  else
  {
    if (nw_utilities_get_self_bundle_id::onceToken != -1) {
      dispatch_once(&nw_utilities_get_self_bundle_id::onceToken, &__block_literal_global_7);
    }
    BOOL v4 = nw_utilities_get_self_bundle_id::bundle_identifier_string == 0;
  }

  nw_utilities_get_self_is_daemon::is_daemon = v4;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v5 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    int v6 = 136446466;
    CFTypeRef v7 = "nw_utilities_get_self_is_daemon_block_invoke";
    __int16 v8 = 1024;
    int v9 = nw_utilities_get_self_is_daemon::is_daemon;
    _os_log_impl(&dword_181A5C000, v5, OS_LOG_TYPE_INFO, "%{public}s is_daemon: %{BOOL}d", (uint8_t *)&v6, 0x12u);
  }
}

void sub_182228E54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_utilities_minos_atleast()
{
  return dyld_program_minos_at_least();
}

BOOL nw_utilities_convert_hex_string_to_bytes(const char *a1, size_t *a2)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    uint64_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v31 = "nw_utilities_convert_hex_string_to_bytes";
    __int16 v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int128 v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_utilities_convert_hex_string_to_bytes";
        os_log_type_t v17 = "%{public}s called with null hex_string";
LABEL_53:
        _os_log_impl(&dword_181A5C000, v15, v16, v17, buf, 0xCu);
      }

uint64_t nw_utilities_execute_block_as_persona_from_parameters(void *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  size_t v4 = a2;
  os_log_type_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    char v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)uu = 136446210;
    *(void *)&uu[4] = "nw_utilities_execute_block_as_persona_from_parameters";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)uu = 136446210;
        *(void *)&uu[4] = "nw_utilities_execute_block_as_persona_from_parameters";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null parameters", uu, 0xCu);
      }
    }

    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)uu = 136446466;
          *(void *)&uu[4] = "nw_utilities_execute_block_as_persona_from_parameters";
          *(_WORD *)&uu[12] = 2082;
          *(void *)&uu[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v17,  "%{public}s called with null parameters, dumping backtrace:%{public}s",  uu,  0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v11) {
          goto LABEL_6;
        }
LABEL_43:
        free(v11);
        goto LABEL_6;
      }

      if (v18)
      {
        *(_DWORD *)uu = 136446210;
        *(void *)&uu[4] = "nw_utilities_execute_block_as_persona_from_parameters";
        _os_log_impl(&dword_181A5C000, v12, v17, "%{public}s called with null parameters, no backtrace", uu, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)uu = 136446210;
        *(void *)&uu[4] = "nw_utilities_execute_block_as_persona_from_parameters";
        _os_log_impl( &dword_181A5C000,  v12,  v22,  "%{public}s called with null parameters, backtrace limit exceeded",  uu,  0xCu);
      }
    }

void sub_1822299E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_utilities_execute_block_as_persona(const unsigned __int8 *a1, void *a2)
{
  *(void *)&v30[13] = *MEMORY[0x1895F89C0];
  size_t v4 = a2;
  if (!v4)
  {
    __nwlog_obj();
    os_log_type_t v16 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)buf = 136446210;
    char v28 = "nw_utilities_execute_block_as_persona";
    os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault(v17, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          char v28 = "nw_utilities_execute_block_as_persona";
          _os_log_impl(&dword_181A5C000, v18, v19, "%{public}s called with null block", buf, 0xCu);
        }
      }

      else if (v25)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = type;
        BOOL v22 = os_log_type_enabled(v18, type);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446466;
            char v28 = "nw_utilities_execute_block_as_persona";
            __int16 v29 = 2082;
            *(void *)uint64_t v30 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v18,  v21,  "%{public}s called with null block, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }

        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          char v28 = "nw_utilities_execute_block_as_persona";
          _os_log_impl(&dword_181A5C000, v18, v21, "%{public}s called with null block, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v18 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          char v28 = "nw_utilities_execute_block_as_persona";
          _os_log_impl( &dword_181A5C000,  v18,  v23,  "%{public}s called with null block, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_182229DEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *nw_protocol_socksv4_copy_definition()
{
  if (nw_protocol_socksv4_copy_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_socksv4_copy_definition::onceToken, &__block_literal_global_44241);
  }
  BOOL result = (void *)nw_protocol_socksv4_copy_definition::definition;
  if (nw_protocol_socksv4_copy_definition::definition) {
    return os_retain((void *)nw_protocol_socksv4_copy_definition::definition);
  }
  return result;
}

BOOL __nw_protocol_socksv4_copy_definition_block_invoke()
{
  nw_protocol_socksv4_copy_definition::definition = (uint64_t)nw_framer_create_definition( "socksv4",  0,  &__block_literal_global_6_44245);
  return nw_protocol_definition_register((void *)nw_protocol_socksv4_copy_definition::definition);
}

uint64_t __nw_protocol_socksv4_copy_definition_block_invoke_2(uint64_t a1, nw_framer *a2)
{
  uint64_t v73 = *MEMORY[0x1895F89C0];
  id v3 = calloc(1uLL, 0x10uLL);
  if (v3)
  {
LABEL_2:
    v3[2] = 0;
    nw_parameters_t v4 = nw_framer_copy_parameters(a2);
    if (v4)
    {
      double v5 = v4;
      id v6 = v5[23];

      if (v6)
      {
        int v7 = (id *)v6;
        id v8 = v7[13];

        if (v8)
        {
          int v9 = v8;
          char v10 = (const char *)v9[2];

          if (v10) {
            *(void *)id v3 = xpc_string_create(v10);
          }
        }

        os_release(v7);
      }

      os_release(v5);
    }

    uint64_t v11 = MEMORY[0x1895F87A8];
    input_handler[0] = MEMORY[0x1895F87A8];
    input_handler[1] = 0x40000000LL;
    input_handler[2] = __nw_protocol_socksv4_copy_definition_block_invoke_3;
    input_handler[3] = &__block_descriptor_tmp_11_44250;
    input_handler[4] = v3;
    input_handler[5] = a2;
    nw_framer_set_input_handler(a2, input_handler);
    output_handler[0] = v11;
    output_handler[1] = 0x40000000LL;
    output_handler[2] = __nw_protocol_socksv4_copy_definition_block_invoke_2_12;
    output_handler[3] = &__block_descriptor_tmp_14_44251;
    output_handler[4] = v3;
    nw_framer_set_output_handler(a2, output_handler);
    cleanup_handler[0] = v11;
    cleanup_handler[1] = 0x40000000LL;
    cleanup_handler[2] = __nw_protocol_socksv4_copy_definition_block_invoke_3_15;
    cleanup_handler[3] = &__block_descriptor_tmp_17_44252;
    cleanup_handler[4] = v3;
    nw_framer_set_cleanup_handler(a2, cleanup_handler);
    if (a2)
    {
      nw_endpoint_t v12 = nw_framer_copy_remote_endpoint(a2);
      BOOL v13 = nw_endpoint_copy_proxy_original_endpoint(v12);
      if (v12) {
        os_release(v12);
      }
      nw_endpoint_type_t v14 = nw_endpoint_get_type((nw_endpoint_t)v13);
      bzero(&v68, 0x204uLL);
      *(_WORD *)output___int128 buffer = 260;
      *(_WORD *)&output_buffer[2] = __rev16(nw_endpoint_get_port((nw_endpoint_t)v13));
      if (v14 == nw_endpoint_type_address)
      {
        address = nw_endpoint_get_address((nw_endpoint_t)v13);
        if (address->sa_family == 30)
        {
          if (gLogDatapath)
          {
            int v55 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446210;
              __int16 v62 = "nw_socksv4_send_connect";
              _os_log_impl( &dword_181A5C000,  v55,  OS_LOG_TYPE_DEBUG,  "%{public}s IPv6 is not supported with SOCKSv4",  buf,  0xCu);
            }
          }

          nw_framer_mark_failed_with_error(a2, 43);
          if (!v13) {
            return 2LL;
          }
          goto LABEL_85;
        }

        LODWORD(v6_Block_object_dispose(&a9, 8) = *(_DWORD *)&address->sa_data[2];
        if (!*(void *)v3) {
          goto LABEL_81;
        }
        string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)v3);
        if (!string_ptr) {
          goto LABEL_81;
        }
        char v25 = string_ptr;
        size_t v26 = strlen(string_ptr);
        size_t v19 = v26;
        if (!v26) {
          goto LABEL_82;
        }
        if (v26 < 0xFF)
        {
          memcpy((char *)&v68 + 4, v25, v26);
          goto LABEL_82;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446466;
        __int16 v62 = "nw_socksv4_send_connect";
        __int16 v63 = 2048;
        size_t v64 = v19;
        uint64_t v27 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v59 = 0;
        if (__nwlog_fault(v27, &type, &v59))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            char v28 = (os_log_s *)__nwlog_obj();
            os_log_type_t v29 = type;
            if (!os_log_type_enabled(v28, type)) {
              goto LABEL_79;
            }
            *(_DWORD *)buf = 136446466;
            __int16 v62 = "nw_socksv4_send_connect";
            __int16 v63 = 2048;
            size_t v64 = v19;
            uint64_t v30 = "%{public}s SOCKS (by address) username has invalid length %zu";
            goto LABEL_78;
          }

          if (!v59)
          {
            char v28 = (os_log_s *)__nwlog_obj();
            os_log_type_t v29 = type;
            if (!os_log_type_enabled(v28, type)) {
              goto LABEL_79;
            }
            *(_DWORD *)buf = 136446466;
            __int16 v62 = "nw_socksv4_send_connect";
            __int16 v63 = 2048;
            size_t v64 = v19;
            uint64_t v30 = "%{public}s SOCKS (by address) username has invalid length %zu, backtrace limit exceeded";
            goto LABEL_78;
          }

          backtrace_string = (char *)__nw_create_backtrace_string();
          char v28 = (os_log_s *)__nwlog_obj();
          os_log_type_t v29 = type;
          BOOL v34 = os_log_type_enabled(v28, type);
          if (backtrace_string)
          {
            if (v34)
            {
              *(_DWORD *)buf = 136446722;
              __int16 v62 = "nw_socksv4_send_connect";
              __int16 v63 = 2048;
              size_t v64 = v19;
              __int16 v65 = 2082;
              __int16 v66 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s SOCKS (by address) username has invalid length %zu, dumping backtrace:%{public}s",  buf,  0x20u);
            }

            free(backtrace_string);
            goto LABEL_79;
          }

          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v62 = "nw_socksv4_send_connect";
            __int16 v63 = 2048;
            size_t v64 = v19;
            uint64_t v30 = "%{public}s SOCKS (by address) username has invalid length %zu, no backtrace";
LABEL_78:
            _os_log_impl(&dword_181A5C000, v28, v29, v30, buf, 0x16u);
          }
        }

uint64_t __nw_protocol_socksv4_copy_definition_block_invoke_3(uint64_t a1, nw_framer_t framer)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = *(_DWORD *)(v4 + 8);
  if (v5 != 1)
  {
    if (!v5)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = "nw_protocol_socksv4_copy_definition_block_invoke_3";
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_ERROR,  "%{public}s Reading packets in initial state",  (uint8_t *)&buf,  0xCu);
      }

      return 0LL;
    }

BOOL __nw_protocol_socksv4_copy_definition_block_invoke_2_12( BOOL result, nw_framer_t framer, int a3, size_t output_length)
{
  if (*(_DWORD *)(*(void *)(result + 32) + 8LL) == 2) {
    return nw_framer_write_output_no_copy(framer, output_length);
  }
  return result;
}

void __nw_protocol_socksv4_copy_definition_block_invoke_3_15(uint64_t a1)
{
  uint64_t v2 = *(xpc_object_t **)(a1 + 32);
  if (!*v2 || (xpc_release(*v2), **(void **)(a1 + 32) = 0LL, (uint64_t v2 = *(xpc_object_t **)(a1 + 32)) != 0LL)) {
    free(v2);
  }
}

uint64_t ___ZL24nw_socksv4_parse_connectP9nw_framerP10nw_socksv4_block_invoke( uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (*a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int v5 = *a2;
      int v12 = 136446466;
      uint64_t v13 = "nw_socksv4_parse_connect_block_invoke";
      __int16 v14 = 1024;
      int v15 = v5;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s SOCKSv4 replies must start will a NULL byte, received 0x%x",  (uint8_t *)&v12,  0x12u);
    }

    id v6 = *(nw_framer **)(a1 + 32);
    int v7 = 100;
LABEL_12:
    nw_framer_mark_failed_with_error(v6, v7);
    return 8LL;
  }

  int v8 = a2[1];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v9 = (os_log_s *)gLogObj;
  if (v8 != 90)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int v10 = a2[1];
      int v12 = 136446466;
      uint64_t v13 = "nw_socksv4_parse_connect_block_invoke";
      __int16 v14 = 1024;
      int v15 = v10;
      _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_ERROR,  "%{public}s Received SOCKS connect status %d, failing",  (uint8_t *)&v12,  0x12u);
    }

    id v6 = *(nw_framer **)(a1 + 32);
    int v7 = 1;
    goto LABEL_12;
  }

  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
  {
    int v12 = 136446210;
    uint64_t v13 = "nw_socksv4_parse_connect_block_invoke";
    _os_log_impl( &dword_181A5C000,  v9,  OS_LOG_TYPE_DEBUG,  "%{public}s Received complete connect message from SOCKS server",  (uint8_t *)&v12,  0xCu);
  }

  *(_DWORD *)(*(void *)(a1 + 40) + 8LL) = 2;
  nw_framer_pass_through_input(*(nw_framer_t *)(a1 + 32));
  nw_framer_pass_through_output(*(nw_framer_t *)(a1 + 32));
  nw_framer_mark_ready(*(nw_framer_t *)(a1 + 32));
  return 8LL;
}

uint64_t __nw_protocol_socksv4_copy_definition_block_invoke_7(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a3;
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a4;
  return 0LL;
}

uint64_t __nwlog_fault(const char *a1, _BYTE *a2, _BYTE *a3)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if (sNWIsBetweenForkAndExec == 1 && (sNWParentAllowedDispatch & 1) != 0) {
    return 0LL;
  }
  if ((sNWDispatchAllowedNow & 1) != 0)
  {
    int v7 = 1;
    uint64_t v6 = 0LL;
    if (!a3) {
      return v6;
    }
  }

  else if ((_dispatch_is_fork_of_multithreaded_parent() & 1) == 0 && (_dispatch_is_multithreaded() & 1) != 0 {
         || (getpid(), sandbox_check() == 1))
  }
  {
    int v7 = 1;
    sNWDispatchAllowedNow = 1;
    uint64_t v6 = 0LL;
    if (!a3) {
      return v6;
    }
  }

  else
  {
    int v7 = sNWDispatchAllowedNow;
    uint64_t v6 = 0LL;
    if (!a3) {
      return v6;
    }
  }

  if (a2 && v7)
  {
    *a2 = 16;
    *a3 = 0;
    uint64_t v24 = 0LL;
    char v25 = &v24;
    uint64_t v26 = 0x3802000000LL;
    uint64_t v27 = __Block_byref_object_copy__44288;
    char v28 = __Block_byref_object_dispose__44289;
    aBlock = 0LL;
    uint64_t v8 = MEMORY[0x1895F87A8];
    char v30 = -1;
    v23[0] = MEMORY[0x1895F87A8];
    v23[1] = 0x40000000LL;
    v23[2] = ____nwlog_fault_block_invoke;
    v23[3] = &unk_189BBE698;
    v23[4] = &v24;
    os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
    ____nwlog_fault_block_invoke((uint64_t)v23);
    os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
    uint64_t v9 = v25[5];
    if (v9)
    {
      uint64_t v9 = (*(uint64_t (**)(uint64_t, const char *))(v9 + 16))(v9, a1);
      if ((v9 & 1) != 0)
      {
        uint64_t v6 = 0LL;
LABEL_44:
        _Block_object_dispose(&v24, 8);
        if ((v30 & 1) != 0 && aBlock) {
          _Block_release(aBlock);
        }
        return v6;
      }
    }

    if (a1)
    {
      uint64_t v9 = pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
      if (sNWIsBetweenForkAndExec != 1 || (sNWParentAllowedDispatch & 1) == 0)
      {
        if ((sNWDispatchAllowedNow & 1) != 0)
        {
LABEL_27:
          pthread_mutex_lock(&__nwlog_fault_add_description_to_list(char const*)::mutex);
          xpc_object_t v10 = (xpc_object_t)__nwlog_fault_add_description_to_list(char const*)::known_faults;
          if (__nwlog_fault_add_description_to_list(char const*)::known_faults
            || (xpc_object_t v10 = xpc_dictionary_create(0LL, 0LL, 0LL),
                (__nwlog_fault_add_description_to_list(char const*)::known_faults = (uint64_t)v10) != 0))
          {
            if (xpc_dictionary_get_BOOL(v10, a1))
            {
              char v11 = 1;
LABEL_34:
              uint64_t v9 = pthread_mutex_unlock(&__nwlog_fault_add_description_to_list(char const*)::mutex);
LABEL_35:
              int v12 = (const char *)nw_setting_tcpconn_disable_simulate_crash;
              networkd_settings_init(v9);
              if (sCachedSettings)
              {
                pthread_mutex_lock(&sSettingsMutex);
                uint64_t v13 = (void *)sCachedSettings;
                if (sCachedSettings
                  && (Class Class = object_getClass((id)sCachedSettings), v12)
                  && Class == (Class)MEMORY[0x1895F9250]
                  && (xpc_object_t v15 = xpc_dictionary_get_value(v13, v12)) != 0LL
                  && (uint64_t v16 = v15, object_getClass(v15) == (Class)MEMORY[0x1895F9228]))
                {
                  BOOL value = xpc_BOOL_get_value(v16);
                  pthread_mutex_unlock(&sSettingsMutex);
                  if (value) {
                    goto LABEL_43;
                  }
                }

                else
                {
                  pthread_mutex_unlock(&sSettingsMutex);
                }
              }

              v21[0] = v8;
              v21[1] = 0x40000000LL;
              v21[2] = ____nwlog_fault_block_invoke_2;
              v21[3] = &__block_descriptor_tmp_1;
              char v22 = v11;
              v21[4] = a2;
              v21[5] = a3;
              os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
              ____nwlog_fault_block_invoke_2((uint64_t)v21);
              os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
LABEL_43:
              uint64_t v6 = 1LL;
              goto LABEL_44;
            }

            xpc_dictionary_set_BOOL( (xpc_object_t)__nwlog_fault_add_description_to_list(char const*)::known_faults,  a1,  1);
          }

          else
          {
            uint64_t v18 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init(v18);
            uint64_t v19 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__int128 buf = 136446210;
              BOOL v32 = "__nwlog_fault_add_description_to_list";
              _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s xpc_dictionary_create failed",  buf,  0xCu);
            }
          }

          char v11 = 0;
          goto LABEL_34;
        }

        if ((_dispatch_is_fork_of_multithreaded_parent() & 1) == 0 && (_dispatch_is_multithreaded() & 1) != 0
          || (getpid(), uint64_t v9 = sandbox_check(), (_DWORD)v9 == 1))
        {
          sNWDispatchAllowedNow = 1;
          goto LABEL_27;
        }

        if (sNWDispatchAllowedNow == 1) {
          goto LABEL_27;
        }
      }
    }

    char v11 = 0;
    goto LABEL_35;
  }

  return v6;
}

uint64_t __Block_byref_object_copy__44288(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(_BYTE *)(result + 4_Block_object_dispose(&a9, 8) = *(_BYTE *)(result + 48) & 0xFE | *(_BYTE *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0LL;
  *(_BYTE *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__44289(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 48) & 1) != 0)
  {
    uint64_t v2 = *(const void **)(a1 + 40);
    if (v2) {
      _Block_release(v2);
    }
  }

  *(void *)(a1 + 40) = 0LL;
}

void ____nwlog_fault_block_invoke(uint64_t a1)
{
  if (s_override_fault_handler)
  {
    uint64_t v2 = _Block_copy((const void *)s_override_fault_handler);
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8LL);
    char v4 = *(_BYTE *)(v3 + 48);
    if ((v4 & 1) != 0)
    {
      int v5 = *(const void **)(v3 + 40);
      if (v5)
      {
        _Block_release(v5);
        char v4 = *(_BYTE *)(v3 + 48);
      }
    }

    *(void *)(v3 + 40) = v2;
    *(_BYTE *)(v3 + 4_Block_object_dispose(&a9, 8) = v4 | 1;
  }

void nwlog_legacy_init_once(void)
{
  if ((gHasForked & 1) == 0) {
    gLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "");
  }
}

uint64_t ____nwlog_fault_block_invoke_2(uint64_t result)
{
  if (!*(_BYTE *)(result + 48))
  {
    int v1 = __nwlog_fault::num_faults;
    if (__nwlog_fault::num_faults <= 0x18)
    {
      **(_BYTE **)(result + 32) = 17;
      __nwlog_fault::num_faults = v1 + 1;
    }

    int v2 = __nwlog_fault::num_backtraces;
    if (__nwlog_fault::num_backtraces <= 0x63)
    {
      **(_BYTE **)(result + 40) = 1;
      __nwlog_fault::num_backtraces = v2 + 1;
    }
  }

  return result;
}

BOOL __nw_should_fault()
{
  return !networkd_settings_get_BOOL((const char *)nw_setting_tcpconn_disable_simulate_crash);
}

BOOL __nwlog_abort(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v8 = 0LL;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x3002000000LL;
  char v11 = __Block_byref_object_copy__2;
  int v12 = __Block_byref_object_dispose__3;
  uint64_t v13 = 0LL;
  v7[0] = MEMORY[0x1895F87A8];
  v7[1] = 0x40000000LL;
  v7[2] = ____nwlog_abort_block_invoke;
  v7[3] = &unk_189BBE6E0;
  v7[4] = &v8;
  os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
  ____nwlog_abort_block_invoke((uint64_t)v7);
  os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
  uint64_t v2 = v9[5];
  if (v2)
  {
    if (((*(uint64_t (**)(uint64_t, uint64_t))(v2 + 16))(v9[5], a1) & 1) == 0)
    {
      uint64_t v3 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v3);
      char v4 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446466;
        xpc_object_t v15 = "__nwlog_abort";
        __int16 v16 = 2080;
        uint64_t v17 = a1;
        _os_log_impl(&dword_181A5C000, v4, OS_LOG_TYPE_ERROR, "%{public}s Abort not handled: %s", buf, 0x16u);
      }
    }

    int v5 = (const void *)v9[5];
    if (v5)
    {
      _Block_release(v5);
      v9[5] = 0LL;
    }
  }

  else
  {
    qword_18C592378 = a1;
  }

  _Block_object_dispose(&v8, 8);
  return v2 == 0;
}

void __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
}

void *____nwlog_abort_block_invoke(uint64_t a1)
{
  uint64_t result = (void *)s_abort_override_handler;
  if (s_abort_override_handler)
  {
    uint64_t result = _Block_copy((const void *)s_abort_override_handler);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 40LL) = result;
  }

  return result;
}

const char *__nw_create_backtrace_string()
{
  v9[128] = *(void **)MEMORY[0x1895F89C0];
  uint64_t v8 = 0LL;
  nw_append_format(&v8, "\n        [%s]%s libnetcore%s%s%s%s", "arm64", "", "-", "4277.60.255", "", "");
  int v0 = backtrace(v9, 128);
  int v1 = backtrace_symbols(v9, v0);
  uint64_t v2 = v1;
  if (v0 >= 1)
  {
    uint64_t v3 = v0 - 1LL;
    char v4 = (const char **)v1;
    do
    {
      int v5 = *v4++;
      nw_append_format(&v8, "\n    %s", v5);
      if (v8) {
        BOOL v6 = v3 == 0;
      }
      else {
        BOOL v6 = 1;
      }
      --v3;
    }

    while (!v6);
    goto LABEL_10;
  }

  if (v1) {
LABEL_10:
  }
    free(v2);
  return v8;
}

uint64_t __nw_should_log_backtrace()
{
  uint64_t v3 = 0LL;
  char v4 = &v3;
  uint64_t v5 = 0x2000000000LL;
  char v6 = 0;
  v2[0] = MEMORY[0x1895F87A8];
  v2[1] = 0x40000000LL;
  v2[2] = ____nw_should_log_backtrace_block_invoke;
  v2[3] = &unk_189BBE708;
  v2[4] = &v3;
  os_unfair_lock_lock(&__nw_should_log_backtrace::backtrace_lock);
  ____nw_should_log_backtrace_block_invoke((uint64_t)v2);
  os_unfair_lock_unlock(&__nw_should_log_backtrace::backtrace_lock);
  uint64_t v0 = *((unsigned __int8 *)v4 + 24);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t ____nw_should_log_backtrace_block_invoke(uint64_t result)
{
  int v1 = __nw_should_log_backtrace::num_backtraces;
  if (__nw_should_log_backtrace::num_backtraces <= 0x31)
  {
    *(_BYTE *)(*(void *)(*(void *)(result + 32) + 8LL) + 24LL) = 1;
    __nw_should_log_backtrace::num_backtraces = v1 + 1;
  }

  return result;
}

uint64_t __nwlog_override_fault_block(uint64_t a1, const void *a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  pthread_rwlock_wrlock(&s_fault_lock);
  *(void *)&__int128 buf = 0LL;
  *((void *)&buf + 1) = &buf;
  uint64_t v16 = 0x3802000000LL;
  uint64_t v17 = __Block_byref_object_copy__44288;
  uint64_t v18 = __Block_byref_object_dispose__44289;
  aBlock = 0LL;
  char v20 = -1;
  uint64_t v4 = MEMORY[0x1895F87A8];
  uint64_t v9 = MEMORY[0x1895F87A8];
  uint64_t v10 = 0x40000000LL;
  char v11 = ____nwlog_set_override_fault_handler_block_invoke;
  int v12 = &unk_189BBE730;
  uint64_t v13 = a2;
  p___int128 buf = &buf;
  os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
  ____nwlog_set_override_fault_handler_block_invoke((uint64_t)&v9);
  os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
  uint64_t v5 = *(const void **)(*((void *)&buf + 1) + 40LL);
  *(void *)(*((void *)&buf + 1) + 40LL) = 0LL;
  _Block_object_dispose(&buf, 8);
  if ((v20 & 1) != 0 && aBlock) {
    _Block_release(aBlock);
  }
  (*(void (**)(uint64_t))(a1 + 16))(a1);
  *(void *)&__int128 buf = 0LL;
  *((void *)&buf + 1) = &buf;
  uint64_t v16 = 0x3802000000LL;
  uint64_t v17 = __Block_byref_object_copy__44288;
  uint64_t v18 = __Block_byref_object_dispose__44289;
  aBlock = 0LL;
  char v20 = -1;
  uint64_t v9 = v4;
  uint64_t v10 = 0x40000000LL;
  char v11 = ____nwlog_set_override_fault_handler_block_invoke;
  int v12 = &unk_189BBE730;
  uint64_t v13 = v5;
  p___int128 buf = &buf;
  os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
  ____nwlog_set_override_fault_handler_block_invoke((uint64_t)&v9);
  os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
  char v6 = *(const void **)(*((void *)&buf + 1) + 40LL);
  *(void *)(*((void *)&buf + 1) + 40LL) = 0LL;
  _Block_object_dispose(&buf, 8);
  if ((v20 & 1) != 0 && aBlock) {
    _Block_release(aBlock);
  }
  _Block_release(v5);
  if (v6 != a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v7 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = "__nwlog_override_fault_block";
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEBUG,  "%{public}s __nwlog_set_override_fault_handler called while in block",  (uint8_t *)&buf,  0xCu);
    }
  }

  _Block_release(v6);
  return pthread_rwlock_unlock(&s_fault_lock);
}

void ____nwlog_set_override_fault_handler_block_invoke(uint64_t a1)
{
  if (s_override_fault_handler) {
    uint64_t v2 = _Block_copy((const void *)s_override_fault_handler);
  }
  else {
    uint64_t v2 = 0LL;
  }
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  char v4 = *(_BYTE *)(v3 + 48);
  if ((v4 & 1) != 0)
  {
    uint64_t v5 = *(const void **)(v3 + 40);
    if (v5)
    {
      _Block_release(v5);
      char v4 = *(_BYTE *)(v3 + 48);
    }
  }

  *(void *)(v3 + 40) = v2;
  *(_BYTE *)(v3 + 4_Block_object_dispose(&a9, 8) = v4 | 1;
  char v6 = *(const void **)(a1 + 32);
  if (!v6)
  {
    int v7 = 0LL;
    uint64_t v8 = (const void *)s_override_fault_handler;
    if (!s_override_fault_handler) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }

  int v7 = _Block_copy(v6);
  uint64_t v8 = (const void *)s_override_fault_handler;
  if (s_override_fault_handler) {
LABEL_9:
  }
    _Block_release(v8);
LABEL_10:
  s_override_fault_handler = (uint64_t)v7;
}

uint64_t __nwlog_set_override_fault_handler(uint64_t a1)
{
  uint64_t v4 = 0LL;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x3802000000LL;
  int v7 = __Block_byref_object_copy__44288;
  uint64_t v8 = __Block_byref_object_dispose__44289;
  aBlock = 0LL;
  char v10 = -1;
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  v3[2] = ____nwlog_set_override_fault_handler_block_invoke;
  v3[3] = &unk_189BBE730;
  v3[4] = a1;
  v3[5] = &v4;
  os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
  ____nwlog_set_override_fault_handler_block_invoke((uint64_t)v3);
  os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
  uint64_t v1 = v5[5];
  v5[5] = 0LL;
  _Block_object_dispose(&v4, 8);
  if ((v10 & 1) != 0 && aBlock) {
    _Block_release(aBlock);
  }
  return v1;
}

void __nwlog_override_abort_block(uint64_t a1, uint64_t a2)
{
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 0x40000000LL;
  v3[2] = ____nwlog_override_abort_block_block_invoke;
  v3[3] = &unk_189BBE758;
  v3[4] = a2;
  os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
  ____nwlog_override_abort_block_block_invoke((uint64_t)v3);
  os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
  (*(void (**)(uint64_t))(a1 + 16))(a1);
  os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
  s_abort_override_handler = 0LL;
  os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
}

uint64_t ____nwlog_override_abort_block_block_invoke(uint64_t result)
{
  s_abort_override_handler = *(void *)(result + 32);
  return result;
}

uint64_t __nwlog_activity_log()
{
  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_15_44313);
  }
  return gactivityLogObj;
}

void ____nwlog_activity_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gactivityLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "activity");
  }
}

uint64_t __nwlog_browser_log()
{
  if (__nwlog_browser_log::onceToken[0] != -1) {
    dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_18_44316);
  }
  return gbrowserLogObj;
}

void ____nwlog_browser_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gbrowserLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "browser");
  }
}

uint64_t __nwlog_candidate_manager_log()
{
  if (__nwlog_candidate_manager_log::onceToken != -1) {
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_21);
  }
  return gcandidate_managerLogObj;
}

void ____nwlog_candidate_manager_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gcandidate_managerLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "candidate_manager");
  }
}

uint64_t __nwlog_connection_log()
{
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  return gconnectionLogObj;
}

void ____nwlog_connection_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gconnectionLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "connection");
  }
}

uint64_t __nwlog_connection_group_log()
{
  if (__nwlog_connection_group_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_27_44330);
  }
  return gconnection_groupLogObj;
}

void ____nwlog_connection_group_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gconnection_groupLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "connection_group");
  }
}

uint64_t __nwlog_http_log()
{
  if (__nwlog_http_log::onceToken != -1) {
    dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_30_44335);
  }
  return ghttpLogObj;
}

void ____nwlog_http_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    ghttpLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "http");
  }
}

uint64_t __nwlog_listener_log()
{
  if (__nwlog_listener_log::onceToken != -1) {
    dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_33_44340);
  }
  return glistenerLogObj;
}

void ____nwlog_listener_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    glistenerLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "listener");
  }
}

uint64_t __nwlog_metrics_log()
{
  if (__nwlog_metrics_log::onceToken[0] != -1) {
    dispatch_once(__nwlog_metrics_log::onceToken, &__block_literal_global_36_44343);
  }
  return gmetricsLogObj;
}

void ____nwlog_metrics_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gmetricsLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "metrics");
  }
}

uint64_t __nwlog_path_log()
{
  if (__nwlog_path_log::onceToken[0] != -1) {
    dispatch_once(__nwlog_path_log::onceToken, &__block_literal_global_39_44346);
  }
  return gpathLogObj;
}

void ____nwlog_path_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gpathLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "path");
  }
}

void ____nwlog_tcp_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gtcpLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "tcp");
  }
}

uint64_t __nwlog_privacy_proxy_log()
{
  if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
    dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_45_44354);
  }
  return gprivacy_proxyLogObj;
}

void ____nwlog_privacy_proxy_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gprivacy_proxyLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "privacy_proxy");
  }
}

uint64_t __nwlog_network_test_log()
{
  if (__nwlog_network_test_log::onceToken != -1) {
    dispatch_once(&__nwlog_network_test_log::onceToken, &__block_literal_global_48);
  }
  return gnetwork_testLogObj;
}

void ____nwlog_network_test_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gnetwork_testLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "network_test");
  }
}

uint64_t __nwlog_metricstream_log()
{
  if (__nwlog_metricstream_log::onceToken != -1) {
    dispatch_once(&__nwlog_metricstream_log::onceToken, &__block_literal_global_51_44361);
  }
  return gmetricstreamLogObj;
}

void ____nwlog_metricstream_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gmetricstreamLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "metricstream");
  }
}

uint64_t __nwlog_url_log()
{
  if (__nwlog_url_log::onceToken != -1) {
    dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_54_44366);
  }
  return gurlLogObj;
}

void ____nwlog_url_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gurlLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "url");
  }
}

uint64_t nwlog_get_private_redacted()
{
  if (nwlog_get_private_redacted::onceToken != -1) {
    dispatch_once(&nwlog_get_private_redacted::onceToken, &__block_literal_global_57_44371);
  }
  return nwlog_get_private_redacted::privateRedacted;
}

uint64_t __nwlog_get_private_redacted_block_invoke()
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  strcpy(__s2, "not redacted");
  char __s1 = 0;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v25 = 136380675;
  uint64_t v26 = __s2;
  uint64_t v0 = (char *)_os_log_send_and_compose_impl();
  if (v0 == &__s1)
  {
LABEL_14:
    uint64_t result = strncmp(&__s1, __s2, 0xDuLL);
    nwlog_get_private_redacted::privateRedacted = (_DWORD)result != 0;
    return result;
  }

  uint64_t v1 = v0;
  if (v0)
  {
LABEL_3:
    int v2 = __s1;
    *uint64_t v1 = __s1;
    if (v2)
    {
      int v3 = v15;
      v1[1] = v15;
      if (v3)
      {
        int v4 = v16;
        v1[2] = v16;
        if (v4)
        {
          int v5 = v17;
          v1[3] = v17;
          if (v5)
          {
            int v6 = v18;
            v1[4] = v18;
            if (v6)
            {
              int v7 = v19;
              v1[5] = v19;
              if (v7)
              {
                int v8 = v20;
                v1[6] = v20;
                if (v8)
                {
                  int v9 = v21;
                  v1[7] = v21;
                  if (v9)
                  {
                    int v10 = v22;
                    v1[8] = v22;
                    if (v10) {
                      v1[9] = v23;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    free(v1);
    goto LABEL_14;
  }

  int v12 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  int v25 = 136446210;
  uint64_t v26 = "_strict_strlcpy";
  uint64_t v13 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort((uint64_t)v13);
  if (!(_DWORD)result)
  {
    free(v13);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

uint64_t nwlog_get_sensitive_redacted()
{
  if (nwlog_get_sensitive_redacted::onceToken != -1) {
    dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_59);
  }
  return nwlog_get_sensitive_redacted::sensitiveRedacted;
}

uint64_t __nwlog_get_sensitive_redacted_block_invoke()
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  strcpy(__s2, "not redacted");
  char __s1 = 0;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v25 = 136642819;
  uint64_t v26 = __s2;
  uint64_t v0 = (char *)_os_log_send_and_compose_impl();
  if (v0 == &__s1)
  {
LABEL_14:
    uint64_t result = strncmp(&__s1, __s2, 0xDuLL);
    nwlog_get_sensitive_redacted::sensitiveRedacted = (_DWORD)result != 0;
    return result;
  }

  uint64_t v1 = v0;
  if (v0)
  {
LABEL_3:
    int v2 = __s1;
    *uint64_t v1 = __s1;
    if (v2)
    {
      int v3 = v15;
      v1[1] = v15;
      if (v3)
      {
        int v4 = v16;
        v1[2] = v16;
        if (v4)
        {
          int v5 = v17;
          v1[3] = v17;
          if (v5)
          {
            int v6 = v18;
            v1[4] = v18;
            if (v6)
            {
              int v7 = v19;
              v1[5] = v19;
              if (v7)
              {
                int v8 = v20;
                v1[6] = v20;
                if (v8)
                {
                  int v9 = v21;
                  v1[7] = v21;
                  if (v9)
                  {
                    int v10 = v22;
                    v1[8] = v22;
                    if (v10) {
                      v1[9] = v23;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    free(v1);
    goto LABEL_14;
  }

  int v12 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  int v25 = 136446210;
  uint64_t v26 = "_strict_strlcpy";
  uint64_t v13 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort((uint64_t)v13);
  if (!(_DWORD)result)
  {
    free(v13);
    goto LABEL_3;
  }

  __break(1u);
  return result;
}

void __nwlog_handle_composed(uint64_t a1, uint64_t a2)
{
  if (gLogFDOverride != -1)
  {
    if (a2)
    {
      uint64_t v3 = 1000LL * *(int *)(a2 + 8);
      *(void *)&__int128 v7 = *(void *)a2;
      *((void *)&v7 + 1) = v3;
    }

    else
    {
      mach_get_times();
    }

    v4[0] = MEMORY[0x1895F87A8];
    v4[1] = 0x40000000LL;
    v4[2] = ____nwlog_handle_composed_block_invoke;
    v4[3] = &__block_descriptor_tmp_64_44382;
    __int128 v5 = v7;
    uint64_t v6 = a1;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
    ____nwlog_handle_composed_block_invoke((uint64_t)v4);
    os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
  }

uint64_t ____nwlog_handle_composed_block_invoke(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1895F89C0];
  if ((_ZZZ23__nwlog_handle_composedEUb_E9tz_is_set & 1) == 0)
  {
    tzset();
    _ZZZ23__nwlog_handle_composedEUb_E9tz_is_set = 1;
  }

  memset(&v4, 0, sizeof(v4));
  int v2 = localtime_r((const time_t *)(a1 + 32), &v4);
  if (!strftime(v5, 9uLL, "%T", v2)) {
    return dprintf(gLogFDOverride, "%s\n");
  }
  v5[8] = 0;
  return dprintf(gLogFDOverride, "%s.%06lu %s\n");
}

void __nwlog_run_with_lock(uint64_t a1)
{
}

uint64_t __nwlog_override_fd(int a1)
{
  uint64_t v2 = gLogFDOverride;
  gLogFDOverride = a1;
  if ((a1 & 0x80000000) == 0)
  {
    gLogDatapath = 1;
    gLogDatapathOverridden = 1;
  }

  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  v4[2] = __nw_utilities_set_log_intercept_block_invoke;
  v4[3] = &__block_descriptor_33_e5_v8__0l;
  BOOL v5 = a1 >= 0;
  os_unfair_lock_lock(&nw_utilities_set_log_intercept::lock);
  __nw_utilities_set_log_intercept_block_invoke((uint64_t)v4);
  os_unfair_lock_unlock(&nw_utilities_set_log_intercept::lock);
  os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
  return v2;
}

uint64_t __nwlog_override_datapath(char a1)
{
  uint64_t v2 = gLogDatapath;
  gLogDatapath = a1;
  gLogDatapathOverridden = 1;
  os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
  return v2;
}

uint64_t __nwlog_register_helper()
{
  if ((gIsHelper & 1) == 0)
  {
    gIsHelper = 1;
    nw_allow_use_of_dispatch_internal();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    return networkd_settings_init();
  }

  return result;
}

void ____nwlog_salted_hash_block_invoke()
{
}

uint64_t __nwlog_create_hash_from_private_string(const char *a1, char *a2)
{
  size_t v4 = strlen(a1);
  __nwlog_salted_hash(a1, v4, a2);
  return 1LL;
}

void nwlog_send_copy_to_fd(int a1)
{
  if (os_variant_has_internal_content())
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
    gLogFDOverride = a1;
    if ((a1 & 0x80000000) == 0)
    {
      gLogDatapath = 1;
      gLogDatapathOverridden = 1;
    }

    v2[0] = MEMORY[0x1895F87A8];
    v2[1] = 3221225472LL;
    v2[2] = __nw_utilities_set_log_intercept_block_invoke;
    v2[3] = &__block_descriptor_33_e5_v8__0l;
    BOOL v3 = a1 >= 0;
    os_unfair_lock_lock(&nw_utilities_set_log_intercept::lock);
    __nw_utilities_set_log_intercept_block_invoke((uint64_t)v2);
    os_unfair_lock_unlock(&nw_utilities_set_log_intercept::lock);
    os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
  }

BOOL __nwlog_compose_logs()
{
  return gLogFDOverride != -1;
}

BOOL __nwlog_level_enabled(os_log_s *a1, os_log_type_t a2)
{
  return gLogFDOverride != -1 || os_log_type_enabled(a1, a2);
}

uint64_t nwlog_get_signposts_enabled()
{
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_15_88556);
  }
  return _nw_signposts_enabled;
}

void nw_mpkl_child_has_forked()
{
  gMpklHasForked = 1;
  gMpklLogObj = MEMORY[0x1895F8DA0];
}

uint64_t nw_mpkl_copy_log_object()
{
  return gMpklLogObj;
}

uint64_t nw_mpkl_log_init_once(void)
{
  uint64_t result = pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if ((gMpklHasForked & 1) == 0)
  {
    uint64_t result = (uint64_t)os_log_create("com.apple.magnetpacketlog", "libnetcore");
    gMpklLogObj = result;
  }

  return result;
}

BOOL nw_ws_copy_response_for_challenge(const __CFString *a1)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  CFIndex Length = CFStringGetLength(a1);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  size_t v4 = MaximumSizeForEncoding + 1;
  if (MaximumSizeForEncoding == -1)
  {
    __nwlog_obj();
    uint64_t v24 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "strict_malloc";
    int v25 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v25);
    if (result) {
      goto LABEL_40;
    }
    free(v25);
  }

  BOOL v5 = (char *)malloc(v4);
  if (!v5)
  {
    __nwlog_obj();
    uint64_t v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = "strict_malloc";
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(void *)&buf[14] = v4;
    uint64_t v27 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v27);
    if (result) {
      goto LABEL_40;
    }
    free(v27);
  }

  int CString = CFStringGetCString(a1, v5, v4, 0x8000100u);
  if (v5 && !CString)
  {
    free(v5);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_ws_copy_response_for_challenge";
    int v8 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v29[0]) = 0;
    if (__nwlog_fault(v8, type, v29))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type[0];
        if (os_log_type_enabled(v9, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_ws_copy_response_for_challenge";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s CFStringGetCString failed", buf, 0xCu);
        }
      }

      else if (LOBYTE(v29[0]))
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v21 = type[0];
        BOOL v22 = os_log_type_enabled(v9, type[0]);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_ws_copy_response_for_challenge";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v9,  v21,  "%{public}s CFStringGetCString failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v8) {
            return 0LL;
          }
          goto LABEL_11;
        }

        if (v22)
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_ws_copy_response_for_challenge";
          _os_log_impl(&dword_181A5C000, v9, v21, "%{public}s CFStringGetCString failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v23 = type[0];
        if (os_log_type_enabled(v9, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_ws_copy_response_for_challenge";
          _os_log_impl( &dword_181A5C000,  v9,  v23,  "%{public}s CFStringGetCString failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v8) {
      return 0LL;
    }
LABEL_11:
    free(v8);
    return 0LL;
  }

  char v28 = 0LL;
  CC_LONG v12 = asprintf(&v28, "%s%s", v5, "258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
  if (v5) {
    free(v5);
  }
  if (v12 != -1)
  {
LABEL_18:
    *(void *)md = 0LL;
    uint64_t v39 = 0LL;
    int v40 = 0;
    CC_SHA1(v28, v12, md);
    if (v28)
    {
      free(v28);
      char v28 = 0LL;
    }

    dispatch_get_global_queue(0LL, 0LL);
    unsigned __int8 v16 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue();
    dispatch_data_t v17 = dispatch_data_create(md, 0x14uLL, v16, &__block_literal_global_44426);

    unsigned __int8 v18 = (dispatch_data_s *)dispatch_data_create_with_transform();
    unsigned __int8 v19 = v18;
    *(void *)bytes = 0LL;
    uint64_t v35 = 0LL;
    int v37 = 0;
    uint64_t v36 = 0LL;
    *(void *)os_log_type_t type = 0LL;
    os_log_type_t v31 = type;
    uint64_t v32 = 0x2000000000LL;
    uint64_t v33 = 0LL;
    v29[0] = 0LL;
    v29[1] = v29;
    v29[2] = 0x2000000000LL;
    v29[3] = bytes;
    if (v18)
    {
      *(void *)__int128 buf = MEMORY[0x1895F87A8];
      *(void *)&uint8_t buf[8] = 0x40000000LL;
      *(void *)&buf[16] = __nw_dispatch_data_copyout_block_invoke;
      os_log_type_t v42 = &unk_189BBF598;
      BOOL v44 = v29;
      uint64_t v45 = 28LL;
      __int16 v43 = type;
      dispatch_data_apply(v18, buf);
    }

    _Block_object_dispose(v29, 8);
    _Block_object_dispose(type, 8);
    CFStringRef v11 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x189604DB0], bytes, 28LL, 0x8000100u, 0);

    return (BOOL)v11;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v13 = (os_log_s *)(id)gLogObj;
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ws_copy_response_for_challenge";
  __int16 v14 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v14);
  if (!result)
  {
    free(v14);
    goto LABEL_18;
  }

void sub_18222D55C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CFDataRef nw_ws_create_client_request(uint64_t a1, void *a2, void *a3)
{
  uint64_t v94 = *MEMORY[0x1895F89C0];
  BOOL v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (a1)
  {
    if (v5)
    {
      if (v6)
      {
        int v8 = (const __CFURL *)nw_endpoint_copy_cfurl(v6);
        if (v8)
        {
          int v9 = (const __CFAllocator *)*MEMORY[0x189604DB0];
          Request = CFHTTPMessageCreateRequest( (CFAllocatorRef)*MEMORY[0x189604DB0],  @"GET",  v8,  (CFStringRef)*MEMORY[0x1896020E0]);
          if (Request)
          {
            CFStringRef v11 = CFURLCopyHostName(v8);
            if (v11)
            {
              CFHTTPMessageSetHeaderFieldValue(Request, @"Host", v11);
              CFRelease(v11);
              CFRelease(v8);
              CFHTTPMessageSetHeaderFieldValue(Request, @"Upgrade", @"WebSocket");
              CFHTTPMessageSetHeaderFieldValue(Request, @"Connection", @"Upgrade");
              __buf[0] = 0LL;
              __buf[1] = 0LL;
              arc4random_buf(__buf, 0x10uLL);
              dispatch_get_global_queue(0LL, 0LL);
              CC_LONG v12 = (dispatch_queue_s *)objc_claimAutoreleasedReturnValue();
              dispatch_data_t v13 = dispatch_data_create(__buf, 0x10uLL, v12, &__block_literal_global_14_44464);

              __int16 v14 = (dispatch_data_s *)dispatch_data_create_with_transform();
              unsigned __int8 v15 = v14;
              *(void *)bytes = 0LL;
              uint64_t v86 = 0LL;
              uint64_t v87 = 0LL;
              *(void *)os_log_type_t type = 0LL;
              uint64_t v82 = type;
              uint64_t v83 = 0x2000000000LL;
              uint64_t v84 = 0LL;
              v80[0] = 0LL;
              v80[1] = v80;
              v80[2] = 0x2000000000LL;
              v80[3] = bytes;
              uint64_t v16 = MEMORY[0x1895F87A8];
              if (v14)
              {
                *(void *)applier = MEMORY[0x1895F87A8];
                *(void *)&applier[8] = 0x40000000LL;
                *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
                v90 = &unk_189BBF598;
                v92 = v80;
                uint64_t v93 = 24LL;
                v91 = type;
                dispatch_data_apply(v14, applier);
              }

              _Block_object_dispose(v80, 8);
              _Block_object_dispose(type, 8);
              dispatch_data_t v17 = CFStringCreateWithBytes(v9, bytes, 24LL, 0x8000100u, 0);
              if (v17)
              {
                CFHTTPMessageSetHeaderFieldValue(Request, @"Sec-WebSocket-Key", v17);
                *(void *)(a1 + _Block_object_dispose(&a9, 8) = v17;
                nw_protocol_options_t v18 = nw_framer_copy_options(v5);
                v79[0] = v16;
                v79[1] = 3221225472LL;
                v79[2] = __nw_ws_create_client_request_block_invoke_17;
                v79[3] = &__block_descriptor_48_e9_B16__0_v8l;
                v79[4] = Request;
                v79[5] = a1;
                char v19 = nw_protocol_options_access_handle(v18, v79);

                if ((v19 & 1) != 0)
                {
                  CFDataRef v20 = CFHTTPMessageCopySerializedMessage(Request);
                  CFRelease(Request);
                  if (v20)
                  {
LABEL_104:

                    goto LABEL_105;
                  }

                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  id v21 = (id)gLogObj;
                  *(_DWORD *)applier = 136446210;
                  *(void *)&applier[4] = "nw_ws_create_client_request";
                  BOOL v22 = (char *)_os_log_send_and_compose_impl();

                  type[0] = OS_LOG_TYPE_ERROR;
                  LOBYTE(v80[0]) = 0;
                  if (type[0] == OS_LOG_TYPE_FAULT)
                  {
                    __nwlog_obj();
                    os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v24 = type[0];
                    if (os_log_type_enabled(v23, type[0]))
                    {
                      *(_DWORD *)applier = 136446210;
                      *(void *)&applier[4] = "nw_ws_create_client_request";
                      _os_log_impl( &dword_181A5C000,  v23,  v24,  "%{public}s ws.output.client: CFHTTPMessageCopySerializedMessage failed",  applier,  0xCu);
                    }
                  }

                  else if (LOBYTE(v80[0]))
                  {
                    backtrace_string = (char *)__nw_create_backtrace_string();
                    __nwlog_obj();
                    os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v60 = type[0];
                    BOOL v61 = os_log_type_enabled(v23, type[0]);
                    if (backtrace_string)
                    {
                      if (v61)
                      {
                        *(_DWORD *)applier = 136446466;
                        *(void *)&applier[4] = "nw_ws_create_client_request";
                        *(_WORD *)&applier[12] = 2082;
                        *(void *)&applier[14] = backtrace_string;
                        _os_log_impl( &dword_181A5C000,  v23,  v60,  "%{public}s ws.output.client: CFHTTPMessageCopySerializedMessage failed, dumping backtrace:%{public}s",  applier,  0x16u);
                      }

                      free(backtrace_string);
                      goto LABEL_112;
                    }

                    if (v61)
                    {
                      *(_DWORD *)applier = 136446210;
                      *(void *)&applier[4] = "nw_ws_create_client_request";
                      _os_log_impl( &dword_181A5C000,  v23,  v60,  "%{public}s ws.output.client: CFHTTPMessageCopySerializedMessage failed, no backtrace",  applier,  0xCu);
                    }
                  }

                  else
                  {
                    __nwlog_obj();
                    os_log_type_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v63 = type[0];
                    if (os_log_type_enabled(v23, type[0]))
                    {
                      *(_DWORD *)applier = 136446210;
                      *(void *)&applier[4] = "nw_ws_create_client_request";
                      _os_log_impl( &dword_181A5C000,  v23,  v63,  "%{public}s ws.output.client: CFHTTPMessageCopySerializedMessage failed, backtrace limit exceeded",  applier,  0xCu);
                    }
                  }

LABEL_112:
                  if (v22) {
                    free(v22);
                  }
                  goto LABEL_103;
                }

                CFRelease(Request);
LABEL_103:
                CFDataRef v20 = 0LL;
                goto LABEL_104;
              }

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              id v43 = (id)gLogObj;
              *(_DWORD *)applier = 136446210;
              *(void *)&applier[4] = "nw_ws_create_client_request";
              BOOL v44 = (char *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v80[0]) = 0;
              if (__nwlog_fault(v44, type, v80))
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  uint64_t v45 = (os_log_s *)(id)gLogObj;
                  os_log_type_t v46 = type[0];
                  if (os_log_type_enabled(v45, type[0]))
                  {
                    *(_DWORD *)applier = 136446210;
                    *(void *)&applier[4] = "nw_ws_create_client_request";
                    _os_log_impl(&dword_181A5C000, v45, v46, "%{public}s CFStringCreateWithBytes failed", applier, 0xCu);
                  }
                }

                else if (LOBYTE(v80[0]))
                {
                  __int16 v52 = (char *)__nw_create_backtrace_string();
                  __nwlog_obj();
                  uint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v53 = type[0];
                  BOOL v54 = os_log_type_enabled(v45, type[0]);
                  if (v52)
                  {
                    if (v54)
                    {
                      *(_DWORD *)applier = 136446466;
                      *(void *)&applier[4] = "nw_ws_create_client_request";
                      *(_WORD *)&applier[12] = 2082;
                      *(void *)&applier[14] = v52;
                      _os_log_impl( &dword_181A5C000,  v45,  v53,  "%{public}s CFStringCreateWithBytes failed, dumping backtrace:%{public}s",  applier,  0x16u);
                    }

                    free(v52);
                    if (!v44) {
                      goto LABEL_102;
                    }
                    goto LABEL_101;
                  }

                  if (v54)
                  {
                    *(_DWORD *)applier = 136446210;
                    *(void *)&applier[4] = "nw_ws_create_client_request";
                    _os_log_impl( &dword_181A5C000,  v45,  v53,  "%{public}s CFStringCreateWithBytes failed, no backtrace",  applier,  0xCu);
                  }
                }

                else
                {
                  __nwlog_obj();
                  uint64_t v45 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v58 = type[0];
                  if (os_log_type_enabled(v45, type[0]))
                  {
                    *(_DWORD *)applier = 136446210;
                    *(void *)&applier[4] = "nw_ws_create_client_request";
                    _os_log_impl( &dword_181A5C000,  v45,  v58,  "%{public}s CFStringCreateWithBytes failed, backtrace limit exceeded",  applier,  0xCu);
                  }
                }
              }

              if (!v44)
              {
LABEL_102:
                CFRelease(Request);
                goto LABEL_103;
              }

void sub_18222EA50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_create_client_request_block_invoke_17(uint64_t a1, uint64_t a2)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)(a2 + 56) != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v23 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v46 = "nw_ws_create_client_request_block_invoke";
    os_log_type_t v24 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v25 = (os_log_s *)(id)gLogObj;
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v46 = "nw_ws_create_client_request_block_invoke";
      uint64_t v27 = "%{public}s nw_ws_options_get_version failed";
    }

    else
    {
      if (v43)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v25 = (os_log_s *)(id)gLogObj;
        os_log_type_t v29 = type;
        BOOL v30 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (!v30) {
            goto LABEL_66;
          }
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v46 = "nw_ws_create_client_request_block_invoke";
          __int16 v47 = 2082;
          __int128 v48 = backtrace_string;
          os_log_type_t v31 = "%{public}s nw_ws_options_get_version failed, dumping backtrace:%{public}s";
          goto LABEL_65;
        }

        if (!v30)
        {
LABEL_43:

          if (!v24) {
            return 0LL;
          }
          goto LABEL_75;
        }

        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v46 = "nw_ws_create_client_request_block_invoke";
        uint64_t v27 = "%{public}s nw_ws_options_get_version failed, no backtrace";
        BOOL v35 = v25;
        os_log_type_t v36 = v29;
LABEL_42:
        _os_log_impl(&dword_181A5C000, v35, v36, v27, buf, 0xCu);
        goto LABEL_43;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v25 = (os_log_s *)(id)gLogObj;
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v46 = "nw_ws_create_client_request_block_invoke";
      uint64_t v27 = "%{public}s nw_ws_options_get_version failed, backtrace limit exceeded";
    }

    BOOL v35 = v25;
    os_log_type_t v36 = v26;
    goto LABEL_42;
  }

  CFHTTPMessageSetHeaderFieldValue(*(CFHTTPMessageRef *)(a1 + 32), @"Sec-WebSocket-Version", @"13");
  CFMutableStringRef Mutable = CFStringCreateMutable(0LL, 0LL);
  if (!Mutable)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v32 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v46 = "nw_ws_create_client_request_block_invoke";
    os_log_type_t v24 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v25 = (os_log_s *)(id)gLogObj;
      os_log_type_t v33 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v46 = "nw_ws_create_client_request_block_invoke";
        os_log_type_t v34 = "%{public}s CFStringCreateMutable failed";
LABEL_71:
        int v40 = v25;
        os_log_type_t v41 = v33;
LABEL_72:
        _os_log_impl(&dword_181A5C000, v40, v41, v34, buf, 0xCu);
      }

BOOL __nw_ws_create_client_request_block_invoke_22(uint64_t a1, size_t a2, void *a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  string_ptr = xpc_string_get_string_ptr(v5);
  uint64_t v7 = CFStringCreateWithCString(0LL, string_ptr, 0x8000100u);
  if (v7)
  {
    CFStringAppend(*(CFMutableStringRef *)(a1 + 32), v7);
    CFRelease(v7);
    if (xpc_array_get_count(**(xpc_object_t **)(a1 + 40)) - 1 > a2) {
      CFStringAppend(*(CFMutableStringRef *)(a1 + 32), @",");
    }
    goto LABEL_11;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v8 = (id)gLogObj;
  *(_DWORD *)__int128 buf = 136446210;
  CFDataRef v20 = "nw_ws_create_client_request_block_invoke";
  xpc_object_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    CFMutableStringRef v10 = (os_log_s *)(id)gLogObj;
    os_log_type_t v11 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)__int128 buf = 136446210;
      CFDataRef v20 = "nw_ws_create_client_request_block_invoke";
      _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s CFStringCreatewithCString failed", buf, 0xCu);
    }

void sub_18222F70C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_ws_validate_client_request(uint64_t a1, void *a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  size_t v4 = *(__CFHTTPMessage **)(a1 + 24);
  id v5 = CFHTTPMessageCopyHeaderFieldValue(v4, @"Upgrade");
  xpc_object_t v6 = v5;
  if (!v5)
  {
LABEL_4:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    if (!os_log_type_enabled((os_log_t)v7, OS_LOG_TYPE_ERROR))
    {
LABEL_6:

      uint64_t v8 = 0LL;
      goto LABEL_7;
    }

void sub_18222FED4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CFArrayRef nw_ws_copy_extension_decl_as_array(CFStringRef theString)
{
  uint64_t v1 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings( (CFAllocatorRef)*MEMORY[0x189604DB0],  theString,  @";");
  CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
  MutableCopy = CFArrayCreateMutableCopy(v1, Count, ArrayBySeparatingStrings);
  if (ArrayBySeparatingStrings) {
    CFRelease(ArrayBySeparatingStrings);
  }
  for (CFIndex i = 0LL; i < CFArrayGetCount(MutableCopy); ++i)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, i);
    CFIndex Length = CFStringGetLength(ValueAtIndex);
    uint64_t v8 = CFStringCreateMutableCopy(v1, Length, ValueAtIndex);
    CFStringTrimWhitespace(v8);
    CFArraySetValueAtIndex(MutableCopy, i, v8);
    if (v8) {
      CFRelease(v8);
    }
  }

  return MutableCopy;
}

BOOL nw_ws_get_extension_parameter(CFStringRef theString, CFStringRef theString2, unint64_t *a3)
{
  if (!a3) {
    return CFStringCompare(theString, theString2, 1uLL) == kCFCompareEqualTo;
  }
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings( (CFAllocatorRef)*MEMORY[0x189604DB0],  theString,  @"=");
  if (CFArrayGetCount(ArrayBySeparatingStrings) == 2
    && (xpc_object_t v6 = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 0LL),
        CFStringCompare(v6, theString2, 1uLL) == kCFCompareEqualTo))
  {
    uint64_t v7 = 1LL;
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 1LL);
    c_string_from_cfstring = (const char *)nw_utilities_create_c_string_from_cfstring(ValueAtIndex);
    if (c_string_from_cfstring)
    {
      os_log_type_t v11 = (char *)c_string_from_cfstring;
      *a3 = atoi(c_string_from_cfstring);
      free(v11);
      uint64_t v7 = 1LL;
    }
  }

  else
  {
    uint64_t v7 = 0LL;
  }

  if (ArrayBySeparatingStrings) {
    CFRelease(ArrayBySeparatingStrings);
  }
  return v7;
}

void nw_ws_present_request_to_user(uint64_t a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  size_t v4 = *(__CFHTTPMessage **)(a1 + 24);
  id v5 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_ws_request);
  xpc_object_t v6 = CFHTTPMessageCopyAllHeaderFields(v4);
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    id v25 = "nw_ws_present_request_to_user";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v8, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        xpc_object_t v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          id v25 = "nw_ws_present_request_to_user";
          _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s CFHTTPMessageCopyAllHeaderFields failed", buf, 0xCu);
        }
      }

      else if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        xpc_object_t v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)__int128 buf = 136446466;
            id v25 = "nw_ws_present_request_to_user";
            __int16 v26 = 2082;
            uint64_t v27 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v9,  v15,  "%{public}s CFHTTPMessageCopyAllHeaderFields failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v8) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }

        if (v16)
        {
          *(_DWORD *)__int128 buf = 136446210;
          id v25 = "nw_ws_present_request_to_user";
          _os_log_impl( &dword_181A5C000,  v9,  v15,  "%{public}s CFHTTPMessageCopyAllHeaderFields failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        xpc_object_t v9 = (os_log_s *)(id)gLogObj;
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          id v25 = "nw_ws_present_request_to_user";
          _os_log_impl( &dword_181A5C000,  v9,  v17,  "%{public}s CFHTTPMessageCopyAllHeaderFields failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v8)
    {
LABEL_9:
      nw_framer_mark_failed_with_error(v3, 14);
      goto LABEL_10;
    }

void sub_182230470( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

void nw_ws_copy_headers_into_ws_request(const __CFString *a1, const __CFString *a2, void *a3)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  if (CFStringCompare(a1, @"Sec-WebSocket-Version", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(a1, @"Upgrade", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(a1, @"Connection", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(a1, @"Sec-WebSocket-Key", 1uLL) == kCFCompareEqualTo)
  {
    goto LABEL_44;
  }

  if (CFStringCompare(a1, @"Sec-WebSocket-Protocol", 1uLL))
  {
    c_string_from_cfstring = (char *)nw_utilities_create_c_string_from_cfstring(a1);
    uint64_t v7 = nw_utilities_create_c_string_from_cfstring(a2);
    uint64_t v8 = (char *)v7;
    if (!c_string_from_cfstring || !v7)
    {
      if (!c_string_from_cfstring) {
        goto LABEL_42;
      }
      goto LABEL_41;
    }

    xpc_object_t v9 = v5;
    os_log_type_t v10 = v9;
    if (v9)
    {
      nw_protocol_options_t v11 = (void *)v9[2];
      xpc_object_t v12 = xpc_string_create(c_string_from_cfstring);
      xpc_array_append_value(v11, v12);

      size_t v13 = (void *)v10[3];
      xpc_object_t v14 = xpc_string_create(v8);
      xpc_array_append_value(v13, v14);

LABEL_10:
LABEL_41:
      free(c_string_from_cfstring);
LABEL_42:
      if (v8) {
        free(v8);
      }
      goto LABEL_44;
    }

    __nwlog_obj();
    id v32 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v46 = "nw_ws_request_add_additional_header";
    __int16 v33 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (__nwlog_fault(v33, &type, &v43))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v35 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v46 = "nw_ws_request_add_additional_header";
          _os_log_impl(&dword_181A5C000, v34, v35, "%{public}s called with null request", buf, 0xCu);
        }
      }

      else if (v43)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v37 = type;
        BOOL v38 = os_log_type_enabled(v34, type);
        if (backtrace_string)
        {
          if (v38)
          {
            *(_DWORD *)__int128 buf = 136446466;
            os_log_type_t v46 = "nw_ws_request_add_additional_header";
            __int16 v47 = 2082;
            __int128 v48 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v34,  v37,  "%{public}s called with null request, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_61;
        }

        if (v38)
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v46 = "nw_ws_request_add_additional_header";
          _os_log_impl(&dword_181A5C000, v34, v37, "%{public}s called with null request, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v39 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v46 = "nw_ws_request_add_additional_header";
          _os_log_impl( &dword_181A5C000,  v34,  v39,  "%{public}s called with null request, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_182230BA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_present_request_to_user_block_invoke(uint64_t a1, uint64_t a2)
{
  id v3 = *(dispatch_queue_s **)(a2 + 48);
  if (v3 && *(void *)(a2 + 40))
  {
    v8[0] = MEMORY[0x1895F87A8];
    v8[1] = 3221225472LL;
    v8[2] = __nw_ws_present_request_to_user_block_invoke_2;
    v8[3] = &unk_189BC0C00;
    uint64_t v11 = a2;
    id v4 = *(id *)(a1 + 32);
    xpc_object_t v6 = *(void **)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 48);
    id v9 = v4;
    uint64_t v12 = v5;
    id v10 = v6;
    dispatch_async(v3, v8);
  }

  else
  {
    nw_ws_write_server_response(*(void *)(a1 + 48), *(void **)(a1 + 40), 0LL);
  }

  return 1LL;
}

void __nw_ws_present_request_to_user_block_invoke_2(uint64_t a1)
{
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  nw_ws_write_server_response(*(void *)(a1 + 56), *(void **)(a1 + 40), v2);
}

void sub_182230D14( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void nw_ws_write_server_response(uint64_t a1, void *a2, void *a3)
{
  uint64_t v64 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a2;
  xpc_object_t v6 = a3;
  uint64_t v7 = v6;
  uint64_t v56 = 0LL;
  os_log_type_t v57 = &v56;
  uint64_t v58 = 0x2020000000LL;
  uint64_t v59 = 0LL;
  if (v6)
  {
    unsigned int v8 = v6[2];
    if (v8 >= 2)
    {
      if (v8 != 2) {
        goto LABEL_30;
      }
      CFHTTPMessageRef Response = CFHTTPMessageCreateResponse( (CFAllocatorRef)*MEMORY[0x189604DB0],  400LL,  @"Bad Request",  (CFStringRef)*MEMORY[0x1896020E0]);
      v57[3] = (uint64_t)Response;
      if (Response) {
        goto LABEL_30;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v33 = (id)gLogObj;
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v61 = "nw_ws_write_server_response";
      uint64_t v23 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v54 = 0;
      if (!__nwlog_fault((const char *)v23, &type, &v54))
      {
LABEL_84:
        if (!v23)
        {
LABEL_86:
          nw_framer_mark_failed_with_error(v5, 14);
          goto LABEL_87;
        }

void sub_182231990( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, char a27)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL27nw_ws_write_server_responseP13nw_ws_state_tPU23objcproto12OS_nw_framer8NSObjectPU28objcproto17OS_nw_ws_responseS1__block_invoke( uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v5 = (const __CFAllocator *)*MEMORY[0x189604DB0];
  CFStringRef v6 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x189604DB0], a2, 0x8000100u);
  uint64_t v7 = CFStringCreateWithCString(v5, a3, 0x8000100u);
  unsigned int v8 = v7;
  if (v6) {
    BOOL v9 = v7 == 0LL;
  }
  else {
    BOOL v9 = 1;
  }
  uint64_t v10 = !v9;
  if (v9)
  {
    if (v6) {
      CFRelease(v6);
    }
    if (v8) {
      CFRelease(v8);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v25 = "nw_ws_write_server_response_block_invoke";
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v12, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v13 = (os_log_s *)(id)gLogObj;
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_29;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v25 = "nw_ws_write_server_response_block_invoke";
        __int16 v15 = "%{public}s CFStringCreateWithCString failed";
LABEL_27:
        CFIndex v20 = v13;
        os_log_type_t v21 = v14;
        goto LABEL_28;
      }

      if (!v22)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v13 = (os_log_s *)(id)gLogObj;
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_29;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v25 = "nw_ws_write_server_response_block_invoke";
        __int16 v15 = "%{public}s CFStringCreateWithCString failed, backtrace limit exceeded";
        goto LABEL_27;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v13 = (os_log_s *)(id)gLogObj;
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (!v18)
        {
LABEL_29:

          if (!v12) {
            return v10;
          }
          goto LABEL_23;
        }

        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v25 = "nw_ws_write_server_response_block_invoke";
        __int16 v15 = "%{public}s CFStringCreateWithCString failed, no backtrace";
        CFIndex v20 = v13;
        os_log_type_t v21 = v17;
LABEL_28:
        _os_log_impl(&dword_181A5C000, v20, v21, v15, buf, 0xCu);
        goto LABEL_29;
      }

      if (v18)
      {
        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v25 = "nw_ws_write_server_response_block_invoke";
        __int16 v26 = 2082;
        uint64_t v27 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v13,  v17,  "%{public}s CFStringCreateWithCString failed, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v12) {
      return v10;
    }
LABEL_23:
    free(v12);
    return v10;
  }

  CFHTTPMessageSetHeaderFieldValue(*(CFHTTPMessageRef *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL), v6, v7);
  CFRelease(v6);
  CFRelease(v8);
  return v10;
}

void ___ZL27nw_ws_write_server_responseP13nw_ws_state_tPU23objcproto12OS_nw_framer8NSObjectPU28objcproto17OS_nw_ws_responseS1__block_invoke_68( uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  objc_storeStrong((id *)(*(void *)(a1 + 56) + 48LL), *(id *)(a1 + 32));
  id v2 = CFHTTPMessageCopySerializedMessage(*(CFHTTPMessageRef *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL));
  id v3 = *(const void **)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) = 0LL;
  }

  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v26 = "nw_ws_write_server_response_block_invoke";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v5, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        CFStringRef v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v26 = "nw_ws_write_server_response_block_invoke";
        unsigned int v8 = "%{public}s CFHTTPMessageCopySerializedMessage failed";
LABEL_22:
        CFIndex v16 = v6;
        os_log_type_t v17 = v7;
        goto LABEL_23;
      }

      if (!v23)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        CFStringRef v6 = (os_log_s *)(id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v26 = "nw_ws_write_server_response_block_invoke";
        unsigned int v8 = "%{public}s CFHTTPMessageCopySerializedMessage failed, backtrace limit exceeded";
        goto LABEL_22;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      CFStringRef v6 = (os_log_s *)(id)gLogObj;
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v11)
        {
LABEL_24:

          if (!v5) {
            goto LABEL_15;
          }
          goto LABEL_14;
        }

        *(_DWORD *)__int128 buf = 136446210;
        __int16 v26 = "nw_ws_write_server_response_block_invoke";
        unsigned int v8 = "%{public}s CFHTTPMessageCopySerializedMessage failed, no backtrace";
        CFIndex v16 = v6;
        os_log_type_t v17 = v10;
LABEL_23:
        _os_log_impl(&dword_181A5C000, v16, v17, v8, buf, 0xCu);
        goto LABEL_24;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v26 = "nw_ws_write_server_response_block_invoke";
        __int16 v27 = 2082;
        uint64_t v28 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v6,  v10,  "%{public}s CFHTTPMessageCopySerializedMessage failed, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
    }

    if (!v5)
    {
LABEL_15:
      nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 40), 14);
      goto LABEL_16;
    }

uint64_t nw_ws_validate_server_response_with_protocol_options(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  id v7 = a3;
  unsigned int v8 = v7;
  if (!a1)
  {
    __nwlog_obj();
    uint64_t v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null response", buf, 0xCu);
      }

      goto LABEL_55;
    }

    if (!v31)
    {
      __nwlog_obj();
      os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
        _os_log_impl( &dword_181A5C000,  v14,  v27,  "%{public}s called with null response, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_55;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
        _os_log_impl(&dword_181A5C000, v14, v21, "%{public}s called with null response, no backtrace", buf, 0xCu);
      }

      goto LABEL_55;
    }

    if (v22)
    {
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s called with null response, dumping backtrace:%{public}s",  buf,  0x16u);
    }

void sub_18223293C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__44609(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 4_Block_object_dispose(va, 8) = *(_OWORD *)(a2 + 48);
  uint64_t v2 = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = 0LL;
  *(void *)(a1 + 64) = v2;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  __int128 v3 = *(_OWORD *)(a2 + 88);
  *(void *)(a2 + 8_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a2 + 96) = 0LL;
  *(_OWORD *)(a1 + 8_Block_object_dispose(va, 8) = v3;
  uint64_t v4 = *(void *)(a2 + 104);
  *(void *)(a2 + 104) = 0LL;
  *(void *)(a1 + 104) = v4;
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  __int128 v5 = *(_OWORD *)(a2 + 128);
  __int128 v6 = *(_OWORD *)(a2 + 144);
  __int128 v7 = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
  *(_OWORD *)(a1 + 176) = v7;
  *(_OWORD *)(a1 + 12_Block_object_dispose(va, 8) = v5;
  *(_OWORD *)(a1 + 144) = v6;
  __int128 v8 = *(_OWORD *)(a2 + 192);
  __int128 v9 = *(_OWORD *)(a2 + 208);
  __int128 v10 = *(_OWORD *)(a2 + 224);
  *(_DWORD *)(a1 + 240) = *(_DWORD *)(a2 + 240);
  *(_OWORD *)(a1 + 20_Block_object_dispose(va, 8) = v9;
  *(_OWORD *)(a1 + 224) = v10;
  *(_OWORD *)(a1 + 192) = v8;
  uint64_t v11 = *(void *)(a2 + 244);
  *(void *)(a2 + 244) = 0LL;
  *(void *)(a1 + 244) = v11;
  __int128 v12 = *(_OWORD *)(a2 + 252);
  __int128 v13 = *(_OWORD *)(a2 + 268);
  *(_OWORD *)(a1 + 284) = *(_OWORD *)(a2 + 284);
  *(_OWORD *)(a1 + 26_Block_object_dispose(va, 8) = v13;
  *(_OWORD *)(a1 + 252) = v12;
  __n128 result = *(__n128 *)(a2 + 300);
  __int128 v15 = *(_OWORD *)(a2 + 316);
  __int128 v16 = *(_OWORD *)(a2 + 332);
  *(_OWORD *)(a1 + 343) = *(_OWORD *)(a2 + 343);
  *(_OWORD *)(a1 + 316) = v15;
  *(_OWORD *)(a1 + 332) = v16;
  *(__n128 *)(a1 + 300) = result;
  return result;
}

void __Block_byref_object_dispose__44610(id *a1)
{
}

uint64_t __nw_ws_validate_server_response_with_protocol_options_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 144LL) = *(void *)(a2 + 32);
  uint64_t v2 = (_WORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 273LL);
  _WORD *v2 = *v2 & 0xFFFE | ((*(_BYTE *)(a2 + 70) & 4) != 0);
  __int128 v3 = (_WORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 273LL);
  *v3 &= ~4u;
  uint64_t v4 = (_WORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 273LL);
  *uint64_t v4 = *v4 & 0xFFBF | (8 * *(unsigned __int8 *)(a2 + 70)) & 0x40;
  __int128 v5 = (_WORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 273LL);
  _WORD *v5 = *v5 & 0xFF7F | (8 * *(unsigned __int8 *)(a2 + 70)) & 0x80;
  __int128 v6 = (_WORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 273LL);
  *__int128 v6 = *v6 & 0xFEFF | (((*(_BYTE *)(a2 + 70) & 0x20) != 0) << 8);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 268LL) = *(_BYTE *)(a2 + 68);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 269LL) = *(_BYTE *)(a2 + 69);
  uint64_t v7 = *(unsigned int *)(a2 + 60);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 200LL) = *(unsigned int *)(a2 + 64);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 192LL) = v7;
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 64LL), *(id *)a2);
  return 1LL;
}

uint64_t nw_ws_validate_server_response(uint64_t a1)
{
  uint64_t v75 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(__CFHTTPMessage **)(a1 + 24);
  __int128 v3 = *(const __CFString **)(a1 + 8);
  if (CFHTTPMessageGetResponseStatusCode(v2) != 101)
  {
    nw_ws_response_t v9 = nw_ws_response_create(nw_ws_response_status_reject, 0LL);
    __int128 v10 = *(void **)(a1 + 48);
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = v9;

    uint64_t result = 0LL;
    *(_DWORD *)(a1 + 212) = 0;
    return result;
  }

  nw_ws_response_t v4 = nw_ws_response_create(nw_ws_response_status_accept, 0LL);
  __int128 v5 = *(void **)(a1 + 48);
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v4;

  if (gLogDatapath)
  {
    __nwlog_obj();
    char v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = a1 + 227;
      _os_log_impl(&dword_181A5C000, v31, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Got 101 response", buf, 0x16u);
    }
  }

  __int128 v6 = CFHTTPMessageCopyVersion(v2);
  uint64_t v7 = v6;
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int128 v12 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = a1 + 227;
      _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s server response didn't contain http version",  buf,  0x16u);
    }

    goto LABEL_12;
  }

  if (CFStringCompare(v6, (CFStringRef)*MEMORY[0x1896020E0], 1uLL))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int128 v8 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = a1 + 227;
      *(_WORD *)&buf[22] = 2112;
      os_log_type_t v74 = v7;
      _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s server response has invalid http version %@",  buf,  0x20u);
    }

    CFRelease(v7);
LABEL_12:
    uint64_t result = 0LL;
    int v13 = 1;
LABEL_13:
    *(_DWORD *)(a1 + 212) = v13;
    return result;
  }

  CFRelease(v7);
  os_log_type_t v14 = CFHTTPMessageCopyHeaderFieldValue(v2, @"Upgrade");
  __int128 v15 = v14;
  if (!v14 || (BOOL v16 = CFStringCompare(v14, @"WebSocket", 1uLL) == kCFCompareEqualTo, CFRelease(v15), !v16))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v17 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = a1 + 227;
      _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s server response doesn't match expected value",  buf,  0x16u);
    }

    uint64_t result = 0LL;
    int v13 = 3;
    goto LABEL_13;
  }

  BOOL v18 = CFHTTPMessageCopyHeaderFieldValue(v2, @"Connection");
  os_log_type_t v19 = v18;
  if (!v18 || (BOOL v20 = CFStringCompare(v18, @"Upgrade", 1uLL) == kCFCompareEqualTo, CFRelease(v19), !v20))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v21 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = a1 + 227;
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s server response doesn't match expected value",  buf,  0x16u);
    }

    uint64_t result = 0LL;
    int v13 = 2;
    goto LABEL_13;
  }

  CFStringRef v22 = CFHTTPMessageCopyHeaderFieldValue(v2, @"Sec-WebSocket-Accept");
  if (!v22)
  {
    __nwlog_obj();
    BOOL v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = a1 + 227;
      _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s Sec-WebSocket-Accept has no value!",  buf,  0x16u);
    }

    goto LABEL_36;
  }

  BOOL v23 = nw_ws_copy_response_for_challenge(v3);
  BOOL v24 = (const void *)v23;
  if (!v23)
  {
    __nwlog_obj();
    os_log_type_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = a1 + 227;
      _os_log_impl( &dword_181A5C000,  v27,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s nw_ws_copy_response_for_challenge",  buf,  0x16u);
    }

    CFRelease(v22);
    goto LABEL_36;
  }

  if (CFStringCompare((CFStringRef)v23, v22, 1uLL))
  {
    __nwlog_obj();
    os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = a1 + 227;
      _os_log_impl( &dword_181A5C000,  v25,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}s server response doesn't match expected value",  buf,  0x16u);
    }

    CFRelease(v24);
    CFRelease(v22);
LABEL_36:
    uint64_t result = 0LL;
    int v13 = 5;
    goto LABEL_13;
  }

  CFRelease(v24);
  CFRelease(v22);
  os_log_type_t v28 = CFHTTPMessageCopyHeaderFieldValue(v2, @"Sec-WebSocket-Protocol");
  os_log_type_t v29 = v28;
  if (!v28)
  {
LABEL_47:
    id v33 = CFHTTPMessageCopyHeaderFieldValue(v2, @"Sec-WebSocket-Extensions");
    if (v33)
    {
      theArray = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x189604DB0], v33, @",");
      CFRelease(v33);
      CFIndex v34 = 0LL;
      for (char i = 1; ; char i = 0)
      {
LABEL_49:
        if (v34 >= CFArrayGetCount(theArray))
        {
          char v49 = i;
          goto LABEL_111;
        }

        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v34);
        os_log_type_t v36 = nw_ws_copy_extension_decl_as_array(ValueAtIndex);
        uint64_t v37 = v36;
        if (!v36) {
          break;
        }
        if (CFArrayGetCount(v36) < 1
          || (uint64_t v38 = (const __CFString *)CFArrayGetValueAtIndex(v37, 0LL),
              CFStringCompare(v38, @"permessage-deflate", 1uLL)))
        {
          __int128 v47 = v37;
          goto LABEL_99;
        }

        if ((*(_WORD *)(a1 + 225) & 0x40) == 0)
        {
          __nwlog_obj();
          __int128 v51 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = a1 + 227;
            __int128 v52 = "%{public}s %{public}s server response contains a permessage-deflate extension that was not negotiated";
            goto LABEL_107;
          }

void sub_182233C20(_Unwind_Exception *a1)
{
}

uint64_t __nw_ws_validate_server_response_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v4 = a3;
  string_ptr = xpc_string_get_string_ptr(v4);
  __int128 v6 = CFStringCreateWithCString(0LL, string_ptr, 0x8000100u);
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v21 = "nw_ws_validate_server_response_block_invoke";
    __int128 v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v10, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v21 = "nw_ws_validate_server_response_block_invoke";
          _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s CFStringCreatewithCString failed", buf, 0xCu);
        }
      }

      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)__int128 buf = 136446466;
            os_log_type_t v21 = "nw_ws_validate_server_response_block_invoke";
            __int16 v22 = 2082;
            BOOL v23 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v11,  v15,  "%{public}s CFStringCreatewithCString failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v10) {
            goto LABEL_11;
          }
          goto LABEL_10;
        }

        if (v16)
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v21 = "nw_ws_validate_server_response_block_invoke";
          _os_log_impl( &dword_181A5C000,  v11,  v15,  "%{public}s CFStringCreatewithCString failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v21 = "nw_ws_validate_server_response_block_invoke";
          _os_log_impl( &dword_181A5C000,  v11,  v17,  "%{public}s CFStringCreatewithCString failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v10) {
      goto LABEL_11;
    }
LABEL_10:
    free(v10);
    goto LABEL_11;
  }

  CFComparisonResult v7 = CFStringCompare(*(CFStringRef *)(a1 + 40), v6, 0LL);
  CFRelease(v6);
  uint64_t v8 = 1LL;
  if (v7 == kCFCompareEqualTo)
  {
    *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = 1;
LABEL_11:
    uint64_t v8 = 0LL;
  }

  return v8;
}

void sub_182233F70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_ws_copy_headers_into_ws_response(const __CFString *a1, const __CFString *a2, void *a3)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  __int128 v5 = a3;
  if (CFStringCompare(a1, @"Sec-WebSocket-Version", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(a1, @"Upgrade", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(a1, @"Connection", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(a1, @"Sec-WebSocket-Accept", 1uLL) == kCFCompareEqualTo)
  {
    goto LABEL_18;
  }

  if (CFStringCompare(a1, @"Sec-WebSocket-Protocol", 1uLL))
  {
    c_string_from_cfstring = (char *)nw_utilities_create_c_string_from_cfstring(a1);
    CFComparisonResult v7 = (const char *)nw_utilities_create_c_string_from_cfstring(a2);
    uint64_t v8 = (void *)v7;
    if (c_string_from_cfstring && v7)
    {
      nw_ws_response_add_additional_header(v5, c_string_from_cfstring, v7);
    }

    else if (!c_string_from_cfstring)
    {
      goto LABEL_16;
    }

    free(c_string_from_cfstring);
LABEL_16:
    if (!v8)
    {
LABEL_18:

      return;
    }

void sub_182234410(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_storage_register_provider(void *a1, const char *a2, __int128 *a3)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  __int128 v5 = a1;
  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v35 = "nw_storage_register_provider";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v33.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (LOBYTE(v33.receiver) == 17)
    {
      __nwlog_obj();
      BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t receiver = (os_log_type_t)v33.receiver;
      if (os_log_type_enabled(v16, (os_log_type_t)v33.receiver))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v35 = "nw_storage_register_provider";
        char v18 = "%{public}s called with null type";
LABEL_46:
        _os_log_impl(&dword_181A5C000, v16, receiver, v18, buf, 0xCu);
      }
    }

    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t receiver = (os_log_type_t)v33.receiver;
      BOOL v26 = os_log_type_enabled(v16, (os_log_type_t)v33.receiver);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v35 = "nw_storage_register_provider";
          __int16 v36 = 2082;
          uint64_t v37 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v16,  receiver,  "%{public}s called with null type, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_48:
        if (!v15) {
          goto LABEL_7;
        }
LABEL_49:
        free(v15);
        goto LABEL_7;
      }

      if (v26)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v35 = "nw_storage_register_provider";
        char v18 = "%{public}s called with null type, no backtrace";
        goto LABEL_46;
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t receiver = (os_log_type_t)v33.receiver;
      if (os_log_type_enabled(v16, (os_log_type_t)v33.receiver))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v35 = "nw_storage_register_provider";
        char v18 = "%{public}s called with null type, backtrace limit exceeded";
        goto LABEL_46;
      }
    }

void nw_storage_flush_all_storages_atexit()
{
  uint64_t v0 = (objc_class *)objc_opt_class();
  InstanceVariable = class_getInstanceVariable(v0, "chain");
  ptrdiff_t Offset = ivar_getOffset(InstanceVariable);
  __int128 v3 = (void *)storages;
  if (storages)
  {
    ptrdiff_t v4 = Offset;
    uint64_t v5 = MEMORY[0x1895F87A8];
    do
    {
      __int128 v6 = (char *)v3 - v4;
      CFComparisonResult v7 = (dispatch_queue_s *)*((void *)v6 + 2);
      block[0] = v5;
      block[1] = 3221225472LL;
      block[2] = __nw_storage_flush_all_storages_atexit_block_invoke;
      block[3] = &unk_189BC93A0;
      __int128 v10 = v6;
      uint64_t v8 = v6;
      dispatch_async_and_wait(v7, block);

      __int128 v3 = (void *)*v3;
    }

    while (v3);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)&storages_lock);
}

void __nw_storage_flush_all_storages_atexit_block_invoke(uint64_t a1)
{
}

void nw_storage_flush(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    __int128 v3 = (unsigned __int8 *)v1[9];
    v11[0] = MEMORY[0x1895F87A8];
    v11[1] = 3221225472LL;
    v11[2] = __nw_storage_flush_block_invoke;
    v11[3] = &unk_189BC85B0;
    __int128 v12 = v1;
    nw_array_apply(v3, (uint64_t)v11);
    nw_array_remove_all_objects(v2[9]);

    goto LABEL_3;
  }

  __nwlog_obj();
  ptrdiff_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v16 = "nw_storage_flush";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int128 v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v16 = "nw_storage_flush";
        uint64_t v8 = "%{public}s called with null storage";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
      }
    }

    else
    {
      if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int128 v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v7 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)__int128 buf = 136446466;
            BOOL v16 = "nw_storage_flush";
            __int16 v17 = 2082;
            char v18 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null storage, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (!v10) {
          goto LABEL_18;
        }
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v16 = "nw_storage_flush";
        uint64_t v8 = "%{public}s called with null storage, no backtrace";
        goto LABEL_17;
      }

      __nwlog_obj();
      __int128 v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v16 = "nw_storage_flush";
        uint64_t v8 = "%{public}s called with null storage, backtrace limit exceeded";
        goto LABEL_17;
      }
    }

uint64_t __nw_storage_flush_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  if (a3)
  {
    ptrdiff_t v4 = *(const char **)(a3 + 8);
    uint64_t v5 = *(const char **)(a3 + 16);
  }

  else
  {
    ptrdiff_t v4 = 0LL;
    uint64_t v5 = 0LL;
  }

  __int128 v6 = nw_storage_provider_for_type(*(void **)(a1 + 32), (uint64_t)v4);
  os_log_type_t v7 = nw_dictionary_copy_value(*(void *)(*(void *)(a1 + 32) + 64LL), (uint64_t)v5);
  uint64_t v8 = v7;
  if (v7)
  {
    __int128 v9 = nw_dictionary_copy_value((uint64_t)v7, (uint64_t)v4);
    BOOL v10 = v9;
    *(void *)n = 0LL;
    uint64_t v11 = (*((uint64_t (**)(void *, int *))v6 + 6))(v10, n);
    __int128 v12 = *(sqlite3 ***)(a1 + 32);
    if (v11)
    {
      char v13 = (void *)v11;
      os_log_type_t v14 = v12[5];
      if (!v14)
      {
        if (sqlite3_prepare_v2( v12[3],  "INSERT OR REPLACE INTO network_storage(key, type, canvas, time) \t\t\t\t\tVALUES (?, ?, ?, strftime('%s','now'))",  -1,  v12 + 5,  0LL))
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v26 = (id)gLogObj;
          *(_DWORD *)__int128 buf = 136446210;
          char v53 = "nw_storage_flush_block_invoke";
          BOOL v16 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v49 = 0;
          if (type == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            __int16 v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v18 = type;
            if (os_log_type_enabled(v17, type))
            {
              *(_DWORD *)__int128 buf = 136446210;
              char v53 = "nw_storage_flush_block_invoke";
              uint64_t v19 = "%{public}s Failed to prepare statement";
              goto LABEL_141;
            }

char *nw_storage_provider_for_type(void *a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  __int128 v3 = a1;
  ptrdiff_t v4 = v3;
  if (v3)
  {
    if (a2)
    {
      uint64_t v5 = (char *)nw_dictionary_copy_value(v3[7], a2);
      if (v5) {
        __int128 v6 = v5 + 8;
      }
      else {
        __int128 v6 = 0LL;
      }

      goto LABEL_7;
    }

    __nwlog_obj();
    char v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    id v21 = "nw_storage_provider_for_type";
    __int128 v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v9, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          id v21 = "nw_storage_provider_for_type";
          __int128 v12 = "%{public}s called with null type";
          goto LABEL_34;
        }

        goto LABEL_35;
      }

      if (!v18)
      {
        __nwlog_obj();
        BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          id v21 = "nw_storage_provider_for_type";
          __int128 v12 = "%{public}s called with null type, backtrace limit exceeded";
          goto LABEL_34;
        }

        goto LABEL_35;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v17 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)__int128 buf = 136446210;
          id v21 = "nw_storage_provider_for_type";
          __int128 v12 = "%{public}s called with null type, no backtrace";
          goto LABEL_34;
        }

        goto LABEL_35;
      }

      if (!v17) {
        goto LABEL_25;
      }
      *(_DWORD *)__int128 buf = 136446466;
      id v21 = "nw_storage_provider_for_type";
      __int16 v22 = 2082;
      os_log_type_t v23 = backtrace_string;
      BOOL v16 = "%{public}s called with null type, dumping backtrace:%{public}s";
LABEL_24:
      _os_log_impl(&dword_181A5C000, v10, v11, v16, buf, 0x16u);
LABEL_25:

      free(backtrace_string);
    }
  }

  else
  {
    __nwlog_obj();
    uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    id v21 = "nw_storage_provider_for_type";
    __int128 v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v9, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          id v21 = "nw_storage_provider_for_type";
          __int128 v12 = "%{public}s called with null storage";
LABEL_34:
          _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
        }

BOOL nw_dns_cache_storage_canvas_lookup(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  if (v1)
  {
    BOOL v2 = nw_array_create();
    BOOL v3 = v2;
    ptrdiff_t v4 = (void *)v1[1];
    if (v4) {
      nw_array_append(v2, v4);
    }
    goto LABEL_4;
  }

  __nwlog_obj();
  __int128 v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v16 = "nw_dns_cache_storage_canvas_lookup";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v7, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v16 = "nw_dns_cache_storage_canvas_lookup";
        BOOL v10 = "%{public}s called with null canvas";
LABEL_18:
        _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
      }
    }

    else
    {
      if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)__int128 buf = 136446466;
            BOOL v16 = "nw_dns_cache_storage_canvas_lookup";
            __int16 v17 = 2082;
            char v18 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null canvas, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (!v12) {
          goto LABEL_19;
        }
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v16 = "nw_dns_cache_storage_canvas_lookup";
        BOOL v10 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_18;
      }

      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v16 = "nw_dns_cache_storage_canvas_lookup";
        BOOL v10 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_18;
      }
    }

void nw_dns_cache_storage_canvas_store(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  os_log_type_t v7 = a1;
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v24 = "nw_dns_cache_storage_canvas_store";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v24 = "nw_dns_cache_storage_canvas_store";
        BOOL v15 = "%{public}s called with null canvas";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
      }
    }

    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v18 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v24 = "nw_dns_cache_storage_canvas_store";
          __int16 v25 = 2082;
          id v26 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s called with null canvas, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v12) {
          goto LABEL_4;
        }
LABEL_35:
        free(v12);
        goto LABEL_4;
      }

      if (v18)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v24 = "nw_dns_cache_storage_canvas_store";
        BOOL v15 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_32;
      }
    }

    else
    {
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v24 = "nw_dns_cache_storage_canvas_store";
        BOOL v15 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_32;
      }
    }

void nw_dns_cache_storage_canvas_remove(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    BOOL v3 = (void *)*((void *)v1 + 1);
    *((void *)v1 + 1) = 0LL;

    v2[16] = 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  ptrdiff_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v14 = "nw_dns_cache_storage_canvas_remove";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int128 v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v14 = "nw_dns_cache_storage_canvas_remove";
        id v8 = "%{public}s called with null canvas";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
      }
    }

    else
    {
      if (v11)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int128 v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v7 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)__int128 buf = 136446466;
            os_log_type_t v14 = "nw_dns_cache_storage_canvas_remove";
            __int16 v15 = 2082;
            BOOL v16 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null canvas, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (!v10) {
          goto LABEL_18;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v14 = "nw_dns_cache_storage_canvas_remove";
        id v8 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_17;
      }

      __nwlog_obj();
      __int128 v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v14 = "nw_dns_cache_storage_canvas_remove";
        id v8 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_17;
      }
    }

BOOL nw_dns_cache_storage_key(void *a1, void *a2)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    __nwlog_obj();
    __int16 v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_key";
    char v13 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v13, type, &v24))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type[0];
        if (os_log_type_enabled(v16, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_key";
          _os_log_impl(&dword_181A5C000, v16, v17, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type[0];
        BOOL v20 = os_log_type_enabled(v16, type[0]);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_key";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v16,  v19,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v13) {
            goto LABEL_28;
          }
          goto LABEL_27;
        }

        if (v20)
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_key";
          _os_log_impl(&dword_181A5C000, v16, v19, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type[0];
        if (os_log_type_enabled(v16, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_key";
          _os_log_impl( &dword_181A5C000,  v16,  v23,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (v13) {
LABEL_27:
    }
      free(v13);
LABEL_28:
    char v11 = 0LL;
    goto LABEL_29;
  }

  id v5 = v3;
  int v6 = [v5 type];

  if (v6 != 2) {
    goto LABEL_28;
  }
  os_log_type_t v7 = (os_unfair_lock_s *)v5;
  *(void *)os_log_type_t type = 0LL;
  id v26 = type;
  uint64_t v27 = 0x2020000000LL;
  uint64_t v28 = 0LL;
  id v8 = v7 + 45;
  *(void *)__int128 buf = MEMORY[0x1895F87A8];
  *(void *)&uint8_t buf[8] = 3221225472LL;
  *(void *)&buf[16] = __nw_endpoint_get_description_block_invoke;
  BOOL v30 = &unk_189BC9210;
  id v9 = v7;
  char v31 = v9;
  id v32 = type;
  os_unfair_lock_lock(v8);
  __nw_endpoint_get_description_block_invoke((uint64_t)buf);
  os_unfair_lock_unlock(v8);
  BOOL v10 = (const char *)*((void *)v26 + 3);

  _Block_object_dispose(type, 8);
  if (v10)
  {
LABEL_4:
    char v11 = strdup(v10);
    if (v11)
    {
LABEL_29:

      return (BOOL)v11;
    }

    __nwlog_obj();
    BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "strict_strdup";
    char v13 = (char *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v13);
    if (result) {
      goto LABEL_30;
    }
    goto LABEL_27;
  }

  __nwlog_obj();
  char v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "strict_strdup";
  __int16 v22 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v22);
  if (!result)
  {
    free(v22);
    goto LABEL_4;
  }

void sub_18223771C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_dns_cache_storage_canvas *nw_dns_cache_storage_canvas_create()
{
  return objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_dns_cache_storage_canvas);
}

NWConcrete_nw_dns_cache_storage_canvas *nw_dns_cache_storage_canvas_deserialize( unsigned __int8 *a1, unint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v4 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_dns_cache_storage_canvas);
  BOOL v5 = nw_array_create();
  endpoints = v4->endpoints;
  v4->endpoints = (OS_nw_array *)v5;

  if (!a2)
  {
LABEL_12:
    os_log_type_t v14 = v4;
    goto LABEL_16;
  }

  while (1)
  {
    os_log_type_t v7 = (sockaddr *)(a1 + 1);
    int v8 = *a1;
    if (v8 != 30) {
      break;
    }
    sockaddr address_8 = (sockaddr)0LL;
    int v18 = 0;
    uint64_t address = 7708LL;
    if (a2 < 0x11) {
      goto LABEL_15;
    }
    sockaddr address_8 = *v7;
    if (a2 - 17 <= 1) {
      goto LABEL_15;
    }
    WORD1(address) = *(_WORD *)(a1 + 17);
    unint64_t v9 = a2 - 19;
    BOOL v10 = (unsigned __int16 *)(a1 + 19);
LABEL_10:
    nw_endpoint_t v11 = nw_endpoint_create_address((const sockaddr *)&address);
    nw_endpoint_t v12 = v11;
    if (v9 <= 1) {
      goto LABEL_14;
    }
    unsigned int v13 = *v10;
    a1 = (unsigned __int8 *)(v10 + 1);
    a2 = v9 - 2;
    nw_endpoint_set_priority(v11, v13);
    nw_array_append((uint64_t)v4->endpoints, v12);

    if (!a2) {
      goto LABEL_12;
    }
  }

  if (v8 == 2)
  {
    *(void *)&address_8.sa_len = 0LL;
    uint64_t address = 528LL;
    if (a2 < 5) {
      goto LABEL_15;
    }
    HIDWORD(address) = *(_DWORD *)&v7->sa_len;
    if (a2 - 5 <= 1) {
      goto LABEL_15;
    }
    WORD1(address) = *(_WORD *)(a1 + 5);
    unint64_t v9 = a2 - 7;
    BOOL v10 = (unsigned __int16 *)(a1 + 7);
    goto LABEL_10;
  }

  nw_endpoint_t v12 = 0LL;
LABEL_14:

LABEL_15:
  os_log_type_t v14 = 0LL;
LABEL_16:

  return v14;
}

BOOL nw_dns_cache_storage_canvas_serialize(void *a1, size_t *a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    nw_endpoint_t v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_serialize";
    nw_endpoint_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v12, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        unsigned int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_serialize";
          _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null canvas", buf, 0xCu);
        }

        goto LABEL_42;
      }

      if (!v27)
      {
        __nwlog_obj();
        unsigned int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_serialize";
          _os_log_impl( &dword_181A5C000,  v13,  v24,  "%{public}s called with null canvas, backtrace limit exceeded",  buf,  0xCu);
        }

        goto LABEL_42;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unsigned int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_serialize";
          _os_log_impl(&dword_181A5C000, v13, v20, "%{public}s called with null canvas, no backtrace", buf, 0xCu);
        }

        goto LABEL_42;
      }

      if (v21)
      {
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_serialize";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v13,  v20,  "%{public}s called with null canvas, dumping backtrace:%{public}s",  buf,  0x16u);
      }

BOOL nw_dns_cache_storage_canvas_dirty(void *a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    BOOL v3 = *((_BYTE *)v1 + 16) != 0;
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  __int16 v15 = "nw_dns_cache_storage_canvas_dirty";
  size_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      size_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v15 = "nw_dns_cache_storage_canvas_dirty";
        unint64_t v9 = "%{public}s called with null canvas";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
      }
    }

    else
    {
      if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        size_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v8 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)__int128 buf = 136446466;
            __int16 v15 = "nw_dns_cache_storage_canvas_dirty";
            __int16 v16 = 2082;
            os_log_type_t v17 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null canvas, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (!v11) {
          goto LABEL_18;
        }
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v15 = "nw_dns_cache_storage_canvas_dirty";
        unint64_t v9 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_17;
      }

      __nwlog_obj();
      size_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v15 = "nw_dns_cache_storage_canvas_dirty";
        unint64_t v9 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_17;
      }
    }

uint64_t nw_dns_cache_storage_canvas_can_evict()
{
  return 1LL;
}

uint64_t nw_dns_cache_storage_canvas_memory_size(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    BOOL v3 = v1;
    uint64_t v4 = v3[1];
    if (!v4 || *(void *)(v4 + 24) == *(void *)(v4 + 16))
    {
      uint64_t v5 = 0LL;
    }

    else
    {
      *(void *)__int128 buf = 0LL;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&buf[16] = 0x2020000000LL;
      uint64_t v19 = 0LL;
      v15[0] = MEMORY[0x1895F87A8];
      v15[1] = 3221225472LL;
      v15[2] = __nw_dns_cache_storage_canvas_memory_size_block_invoke;
      v15[3] = &unk_189BC50D0;
      v15[4] = buf;
      nw_array_apply((unsigned __int8 *)v4, (uint64_t)v15);
      uint64_t v5 = *(void *)(*(void *)&buf[8] + 24LL);
      _Block_object_dispose(buf, 8);
    }

    goto LABEL_7;
  }

  __nwlog_obj();
  size_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_memory_size";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v8, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_memory_size";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null canvas", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_memory_size";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null canvas, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_memory_size";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null canvas, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      unint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_memory_size";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null canvas, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_dns_cache_storage_needs_canvas_destroy()
{
  return 0LL;
}

void nw_dns_cache_storage_canvas_remove_past(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    id v1 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v11 = "nw_dns_cache_storage_canvas_remove_past";
    BOOL v2 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v8 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v11 = "nw_dns_cache_storage_canvas_remove_past";
        uint64_t v5 = "%{public}s called with null canvas";
LABEL_16:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else
    {
      if (v8)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v4 = type;
        BOOL v7 = os_log_type_enabled(v3, type);
        if (backtrace_string)
        {
          if (v7)
          {
            *(_DWORD *)__int128 buf = 136446466;
            BOOL v11 = "nw_dns_cache_storage_canvas_remove_past";
            __int16 v12 = 2082;
            BOOL v13 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null canvas, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_18;
        }

        if (!v7) {
          goto LABEL_17;
        }
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v11 = "nw_dns_cache_storage_canvas_remove_past";
        uint64_t v5 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_16;
      }

      __nwlog_obj();
      BOOL v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v11 = "nw_dns_cache_storage_canvas_remove_past";
        uint64_t v5 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_16;
      }
    }

uint64_t __nw_dns_cache_storage_canvas_memory_size_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  int address_family = nw_endpoint_get_address_family(a3);
  if (address_family == 2)
  {
    uint64_t v5 = 9LL;
    goto LABEL_5;
  }

  if (address_family == 30)
  {
    uint64_t v5 = 21LL;
LABEL_5:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v5;
  }

  return 1LL;
}

uint64_t __nw_dns_cache_storage_canvas_serialize_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  os_log_type_t v4 = a3;
  uint64_t address = nw_endpoint_get_address(v4);
  __int16 priority = nw_endpoint_get_priority(v4);

  if (address)
  {
    int sa_family = address->sa_family;
    if (sa_family == 30)
    {
      uint64_t v12 = *(void *)(a1 + 32);
      uint64_t v8 = a1 + 32;
      **(_BYTE **)(*(void *)(v12 + 8) + 24LL) = 30;
      *(sockaddr *)++*(void *)(*(void *)(*(void *)v8 + 8LL) + 24LL) = *(sockaddr *)&address->sa_data[6];
      uint64_t v10 = *(void *)(*(void *)v8 + 8LL);
      uint64_t v11 = *(void *)(v10 + 24) + 16LL;
      goto LABEL_6;
    }

    if (sa_family == 2)
    {
      uint64_t v9 = *(void *)(a1 + 32);
      uint64_t v8 = a1 + 32;
      **(_BYTE **)(*(void *)(v9 + 8) + 24LL) = 2;
      *(_DWORD *)++*(void *)(*(void *)(*(void *)v8 + 8LL) + 24LL) = *(_DWORD *)&address->sa_data[2];
      uint64_t v10 = *(void *)(*(void *)v8 + 8LL);
      uint64_t v11 = *(void *)(v10 + 24) + 4LL;
LABEL_6:
      *(void *)(v10 + 24) = v11;
      **(_WORD **)(*(void *)(*(void *)v8 + 8LL) + 24LL) = *(_WORD *)address->sa_data;
      *(void *)(*(void *)(*(void *)v8 + 8LL) + 24LL) += 2LL;
      **(_WORD **)(*(void *)(*(void *)v8 + 8LL) + 24LL) = priority;
      *(void *)(*(void *)(*(void *)v8 + 8LL) + 24LL) += 2LL;
    }
  }

  return 1LL;
}

BOOL nw_h3_0rtt_storage_canvas_lookup(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    BOOL v3 = (void **)v1;
    BOOL v4 = nw_array_create();
    if (v3[1] && v3[2] && v3[3])
    {
      BOOL v5 = nw_array_create();
      nw_array_append(v5, v3[1]);
      nw_array_append(v5, v3[2]);
      nw_array_append(v5, v3[3]);
      nw_array_append(v4, (void *)v5);
    }

    goto LABEL_7;
  }

  __nwlog_obj();
  BOOL v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v17 = "nw_h3_0rtt_storage_canvas_lookup";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v8, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_h3_0rtt_storage_canvas_lookup";
        uint64_t v11 = "%{public}s called with null canvas";
LABEL_21:
        _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
      }
    }

    else
    {
      if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        BOOL v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)__int128 buf = 136446466;
            os_log_type_t v17 = "nw_h3_0rtt_storage_canvas_lookup";
            __int16 v18 = 2082;
            uint64_t v19 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null canvas, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }

        if (!v13) {
          goto LABEL_22;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_h3_0rtt_storage_canvas_lookup";
        uint64_t v11 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_21;
      }

      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_h3_0rtt_storage_canvas_lookup";
        uint64_t v11 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_21;
      }
    }

void nw_h3_0rtt_storage_canvas_store(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  BOOL v7 = a1;
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  if (!v7)
  {
    __nwlog_obj();
    os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v30 = "nw_h3_0rtt_storage_canvas_store";
    __int16 v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v30 = "nw_h3_0rtt_storage_canvas_store";
        BOOL v21 = "%{public}s called with null canvas";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0xCu);
      }
    }

    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v24 = os_log_type_enabled(v19, type);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v30 = "nw_h3_0rtt_storage_canvas_store";
          __int16 v31 = 2082;
          id v32 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s called with null canvas, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v18) {
          goto LABEL_4;
        }
LABEL_35:
        free(v18);
        goto LABEL_4;
      }

      if (v24)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v30 = "nw_h3_0rtt_storage_canvas_store";
        BOOL v21 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_32;
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v30 = "nw_h3_0rtt_storage_canvas_store";
        BOOL v21 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_32;
      }
    }

void nw_h3_0rtt_storage_canvas_remove(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    BOOL v3 = (void *)v1[1];
    v1[1] = 0LL;

    BOOL v4 = (void *)v2[2];
    v2[2] = 0LL;

    BOOL v5 = (void *)v2[3];
    v2[3] = 0LL;

    *((_BYTE *)v2 + 32) = 1;
    goto LABEL_3;
  }

  __nwlog_obj();
  size_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  char v16 = "nw_h3_0rtt_storage_canvas_remove";
  BOOL v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v7, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v16 = "nw_h3_0rtt_storage_canvas_remove";
        id v10 = "%{public}s called with null canvas";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
      }
    }

    else
    {
      if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)__int128 buf = 136446466;
            char v16 = "nw_h3_0rtt_storage_canvas_remove";
            __int16 v17 = 2082;
            __int16 v18 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null canvas, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (!v12) {
          goto LABEL_18;
        }
        *(_DWORD *)__int128 buf = 136446210;
        char v16 = "nw_h3_0rtt_storage_canvas_remove";
        id v10 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_17;
      }

      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v16 = "nw_h3_0rtt_storage_canvas_remove";
        id v10 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_17;
      }
    }

char *nw_h3_0rtt_storage_key(void *a1, void *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  id v4 = a1;
  id v5 = a2;
  if (!v4)
  {
    __nwlog_obj();
    char v14 = (void *)objc_claimAutoreleasedReturnValue();
    int v24 = 136446210;
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v2 = "nw_h3_0rtt_storage_key";
    *(void *)&uint8_t buf[4] = "nw_h3_0rtt_storage_key";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type[0];
      if (os_log_type_enabled(v15, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_h3_0rtt_storage_key";
        _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null endpoint", buf, 0xCu);
      }

void sub_18223993C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_h3_0rtt_storage_canvas *nw_h3_0rtt_storage_canvas_create()
{
  return objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_h3_0rtt_storage_canvas);
}

NWConcrete_nw_h3_0rtt_storage_canvas *nw_h3_0rtt_storage_canvas_deserialize( unsigned __int16 *a1, unint64_t a2)
{
  id v4 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_h3_0rtt_storage_canvas);
  unint64_t v5 = a2 - 2;
  if (a2 < 2) {
    goto LABEL_7;
  }
  unint64_t v6 = *a1;
  unint64_t v7 = v5 - v6;
  if (v5 < v6) {
    goto LABEL_7;
  }
  id v8 = a1 + 1;
  dispatch_data_t v9 = dispatch_data_create(a1 + 1, *a1, 0LL, 0LL);
  settings_data = v4->settings_data;
  v4->settings_data = (OS_dispatch_data *)v9;

  uint64_t v11 = 0LL;
  unint64_t v12 = v7 - 2;
  if (v7 < 2) {
    goto LABEL_8;
  }
  char v13 = (char *)v8 + v6;
  size_t v14 = *(unsigned __int16 *)((char *)v8 + v6);
  unint64_t v15 = v12 - v14;
  if (v12 < v14)
  {
LABEL_7:
    uint64_t v11 = 0LL;
    goto LABEL_8;
  }

  os_log_type_t v16 = v13 + 2;
  dispatch_data_t v17 = dispatch_data_create(v13 + 2, v14, 0LL, 0LL);
  quic_state = v4->quic_state;
  v4->quic_state = (OS_dispatch_data *)v17;

  uint64_t v11 = 0LL;
  if (v15 >= 2)
  {
    size_t v19 = *(unsigned __int16 *)&v16[v14];
    if (v15 - 2 >= v19)
    {
      dispatch_data_t v21 = dispatch_data_create(&v16[v14 + 2], v19, 0LL, 0LL);
      tls_state = v4->tls_state;
      v4->tls_state = (OS_dispatch_data *)v21;

      uint64_t v11 = v4;
      goto LABEL_8;
    }

    goto LABEL_7;
  }

BOOL nw_h3_0rtt_storage_canvas_serialize(void *a1, void *a2)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_h3_0rtt_storage_canvas_serialize";
    dispatch_data_t v21 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v33) = 0;
    if (__nwlog_fault(v21, type, &v33))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v23 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_h3_0rtt_storage_canvas_serialize";
          int v24 = "%{public}s called with null canvas";
LABEL_47:
          _os_log_impl(&dword_181A5C000, v22, v23, v24, applier, 0xCu);
        }

BOOL nw_h3_0rtt_storage_canvas_dirty(void *a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    BOOL v3 = *((_BYTE *)v1 + 32) != 0;
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  unint64_t v15 = "nw_h3_0rtt_storage_canvas_dirty";
  unint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unint64_t v15 = "nw_h3_0rtt_storage_canvas_dirty";
        dispatch_data_t v9 = "%{public}s called with null canvas";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
      }
    }

    else
    {
      if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v8 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)__int128 buf = 136446466;
            unint64_t v15 = "nw_h3_0rtt_storage_canvas_dirty";
            __int16 v16 = 2082;
            uint64_t v17 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null canvas, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (!v11) {
          goto LABEL_18;
        }
        *(_DWORD *)__int128 buf = 136446210;
        unint64_t v15 = "nw_h3_0rtt_storage_canvas_dirty";
        dispatch_data_t v9 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_17;
      }

      __nwlog_obj();
      unint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unint64_t v15 = "nw_h3_0rtt_storage_canvas_dirty";
        dispatch_data_t v9 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_17;
      }
    }

uint64_t nw_h3_0rtt_storage_canvas_can_evict()
{
  return 1LL;
}

size_t nw_h3_0rtt_storage_canvas_memory_size(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    BOOL v3 = (dispatch_data_s *)*((void *)v1 + 1);
    if (v3)
    {
      size_t size = dispatch_data_get_size(v3);
      id v5 = (dispatch_data_s *)v2[2];
      if (!v5) {
        goto LABEL_5;
      }
    }

    else
    {
      size_t size = 0LL;
      id v5 = (dispatch_data_s *)v2[2];
      if (!v5)
      {
LABEL_5:
        unint64_t v6 = (dispatch_data_s *)v2[3];
        if (v6) {
          size += dispatch_data_get_size(v6);
        }
        goto LABEL_7;
      }
    }

    size += dispatch_data_get_size(v5);
    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v18 = "nw_h3_0rtt_storage_canvas_memory_size";
  dispatch_data_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v9, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unsigned __int16 v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v18 = "nw_h3_0rtt_storage_canvas_memory_size";
        char v12 = "%{public}s called with null canvas";
LABEL_23:
        _os_log_impl(&dword_181A5C000, v10, v11, v12, buf, 0xCu);
      }
    }

    else
    {
      if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        unsigned __int16 v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        BOOL v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)__int128 buf = 136446466;
            uint64_t v18 = "nw_h3_0rtt_storage_canvas_memory_size";
            __int16 v19 = 2082;
            os_log_type_t v20 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null canvas, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }

        if (!v14) {
          goto LABEL_24;
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v18 = "nw_h3_0rtt_storage_canvas_memory_size";
        char v12 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_23;
      }

      __nwlog_obj();
      unsigned __int16 v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v18 = "nw_h3_0rtt_storage_canvas_memory_size";
        char v12 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_23;
      }
    }

uint64_t nw_h3_0rtt_storage_needs_canvas_destroy()
{
  return 0LL;
}

void nw_h3_0rtt_storage_canvas_remove_past(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    id v1 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v11 = "nw_h3_0rtt_storage_canvas_remove_past";
    BOOL v2 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v8 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v11 = "nw_h3_0rtt_storage_canvas_remove_past";
        id v5 = "%{public}s called with null canvas";
LABEL_16:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else
    {
      if (v8)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v4 = type;
        BOOL v7 = os_log_type_enabled(v3, type);
        if (backtrace_string)
        {
          if (v7)
          {
            *(_DWORD *)__int128 buf = 136446466;
            os_log_type_t v11 = "nw_h3_0rtt_storage_canvas_remove_past";
            __int16 v12 = 2082;
            uint64_t v13 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null canvas, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_18;
        }

        if (!v7) {
          goto LABEL_17;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v11 = "nw_h3_0rtt_storage_canvas_remove_past";
        id v5 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_16;
      }

      __nwlog_obj();
      BOOL v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v11 = "nw_h3_0rtt_storage_canvas_remove_past";
        id v5 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_16;
      }
    }

id nw_storage_copy_shared()
{
  if (nw_storage_copy_shared_token != -1) {
    dispatch_once(&nw_storage_copy_shared_token, &__block_literal_global_44978);
  }
  return (id)nw_storage_copy_shared_storage;
}

void __nw_storage_copy_shared_block_invoke()
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  bzero(__s1, 0x400uLL);
  uint64_t v0 = getenv("HOME");
  if (!v0)
  {
LABEL_50:
    BOOL v27 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_storage);
LABEL_51:
    BOOL v29 = (void *)nw_storage_copy_shared_storage;
    nw_storage_copy_shared_storage = (uint64_t)v27;

    return;
  }

  uint64_t v1 = 0LL;
  while (1)
  {
    int v2 = v0[v1];
    __s1[v1] = v2;
    if (!v2) {
      break;
    }
    if (++v1 == 1023)
    {
      char v37 = 0;
      break;
    }
  }

  uint64_t v3 = 0LL;
  unint64_t v4 = 1024LL;
  while (1)
  {
    id v5 = &__s1[v3];
    if (!__s1[v3]) {
      break;
    }
    ++v3;
    if (!--v4) {
      goto LABEL_17;
    }
  }

  if (v4 < 2)
  {
LABEL_16:
    char *v5 = 0;
  }

  else
  {
    unint64_t v6 = v4 - 2;
    uint64_t v7 = 1023 - v3;
    unint64_t v8 = 1022 - v3;
    if (v8 >= 0x16) {
      unint64_t v8 = 22LL;
    }
    memcpy(v5, "/Library/HTTPStorages/", v8 + 1);
    id v5 = &v37;
    while (v6 <= 0x15)
    {
      if (!--v7) {
        goto LABEL_16;
      }
    }
  }

void nw_storage_lookup_items(void *a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  dispatch_data_t v9 = a1;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  int v13 = v12;
  if (!v9)
  {
    __nwlog_obj();
    unint64_t v15 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v42 = "nw_storage_lookup_items";
    __int16 v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v40 = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (v40 != OS_LOG_TYPE_FAULT)
    {
      if (v39)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = v40;
        BOOL v25 = os_log_type_enabled(v17, v40);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)__int128 buf = 136446466;
            __int128 v42 = "nw_storage_lookup_items";
            __int16 v43 = 2082;
            __int128 v44 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s called with null storage, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
LABEL_74:
          if (!v16) {
            goto LABEL_7;
          }
LABEL_75:
          free(v16);
          goto LABEL_7;
        }

        if (v25)
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int128 v42 = "nw_storage_lookup_items";
          int v19 = "%{public}s called with null storage, no backtrace";
          goto LABEL_72;
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = v40;
        if (os_log_type_enabled(v17, v40))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int128 v42 = "nw_storage_lookup_items";
          int v19 = "%{public}s called with null storage, backtrace limit exceeded";
          goto LABEL_72;
        }
      }

      goto LABEL_73;
    }

    __nwlog_obj();
    uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v18 = v40;
    if (!os_log_type_enabled(v17, v40)) {
      goto LABEL_73;
    }
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v42 = "nw_storage_lookup_items";
    int v19 = "%{public}s called with null storage";
    goto LABEL_72;
  }

  if (!a2)
  {
    __nwlog_obj();
    uint64_t v20 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v42 = "nw_storage_lookup_items";
    __int16 v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v40 = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (v40 != OS_LOG_TYPE_FAULT)
    {
      if (!v39)
      {
        __nwlog_obj();
        uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = v40;
        if (os_log_type_enabled(v17, v40))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int128 v42 = "nw_storage_lookup_items";
          int v19 = "%{public}s called with null type, backtrace limit exceeded";
          goto LABEL_72;
        }

        goto LABEL_73;
      }

      unint64_t v26 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = v40;
      BOOL v27 = os_log_type_enabled(v17, v40);
      if (!v26)
      {
        if (v27)
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int128 v42 = "nw_storage_lookup_items";
          int v19 = "%{public}s called with null type, no backtrace";
          goto LABEL_72;
        }

        goto LABEL_73;
      }

      if (!v27) {
        goto LABEL_50;
      }
      *(_DWORD *)__int128 buf = 136446466;
      __int128 v42 = "nw_storage_lookup_items";
      __int16 v43 = 2082;
      __int128 v44 = v26;
      uint64_t v28 = "%{public}s called with null type, dumping backtrace:%{public}s";
      goto LABEL_49;
    }

    __nwlog_obj();
    uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v18 = v40;
    if (!os_log_type_enabled(v17, v40)) {
      goto LABEL_73;
    }
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v42 = "nw_storage_lookup_items";
    int v19 = "%{public}s called with null type";
LABEL_72:
    _os_log_impl(&dword_181A5C000, v17, v18, v19, buf, 0xCu);
    goto LABEL_73;
  }

  if (!v10)
  {
    __nwlog_obj();
    uint64_t v21 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v42 = "nw_storage_lookup_items";
    __int16 v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v40 = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (v40 != OS_LOG_TYPE_FAULT)
    {
      if (!v39)
      {
        __nwlog_obj();
        uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v18 = v40;
        if (os_log_type_enabled(v17, v40))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int128 v42 = "nw_storage_lookup_items";
          int v19 = "%{public}s called with null endpoint, backtrace limit exceeded";
          goto LABEL_72;
        }

        goto LABEL_73;
      }

      unint64_t v26 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = v40;
      BOOL v29 = os_log_type_enabled(v17, v40);
      if (!v26)
      {
        if (v29)
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int128 v42 = "nw_storage_lookup_items";
          int v19 = "%{public}s called with null endpoint, no backtrace";
          goto LABEL_72;
        }

        goto LABEL_73;
      }

      if (!v29) {
        goto LABEL_50;
      }
      *(_DWORD *)__int128 buf = 136446466;
      __int128 v42 = "nw_storage_lookup_items";
      __int16 v43 = 2082;
      __int128 v44 = v26;
      uint64_t v28 = "%{public}s called with null endpoint, dumping backtrace:%{public}s";
      goto LABEL_49;
    }

    __nwlog_obj();
    uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v18 = v40;
    if (!os_log_type_enabled(v17, v40)) {
      goto LABEL_73;
    }
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v42 = "nw_storage_lookup_items";
    int v19 = "%{public}s called with null endpoint";
    goto LABEL_72;
  }

  if (!v11)
  {
    __nwlog_obj();
    unint64_t v22 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v42 = "nw_storage_lookup_items";
    __int16 v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v40 = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (v40 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = v40;
      if (!os_log_type_enabled(v17, v40)) {
        goto LABEL_73;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int128 v42 = "nw_storage_lookup_items";
      int v19 = "%{public}s called with null context";
      goto LABEL_72;
    }

    if (!v39)
    {
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = v40;
      if (os_log_type_enabled(v17, v40))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int128 v42 = "nw_storage_lookup_items";
        int v19 = "%{public}s called with null context, backtrace limit exceeded";
        goto LABEL_72;
      }

      goto LABEL_73;
    }

    unint64_t v26 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v18 = v40;
    BOOL v30 = os_log_type_enabled(v17, v40);
    if (!v26)
    {
      if (v30)
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int128 v42 = "nw_storage_lookup_items";
        int v19 = "%{public}s called with null context, no backtrace";
        goto LABEL_72;
      }

      goto LABEL_73;
    }

    if (!v30) {
      goto LABEL_50;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int128 v42 = "nw_storage_lookup_items";
    __int16 v43 = 2082;
    __int128 v44 = v26;
    uint64_t v28 = "%{public}s called with null context, dumping backtrace:%{public}s";
LABEL_49:
    _os_log_impl(&dword_181A5C000, v17, v18, v28, buf, 0x16u);
    goto LABEL_50;
  }

  if (!v12)
  {
    __nwlog_obj();
    os_log_type_t v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v42 = "nw_storage_lookup_items";
    __int16 v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v40 = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (v40 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = v40;
      if (os_log_type_enabled(v17, v40))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int128 v42 = "nw_storage_lookup_items";
        int v19 = "%{public}s called with null completion";
        goto LABEL_72;
      }

void __nw_storage_lookup_items_block_invoke(uint64_t a1)
{
  int v2 = nw_storage_provider_for_type(*(void **)(a1 + 32), *(void *)(a1 + 72));
  uint64_t v3 = (const char *)(*((uint64_t (**)(void, void))v2 + 3))(*(void *)(a1 + 40), *(void *)(a1 + 48));
  if (v3)
  {
    unint64_t v4 = (char *)v3;
    nw_storage_fault_in_canvas(*(void **)(a1 + 32), v3, *(const char **)(a1 + 72), (uint64_t)v2);
    id v5 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v6 = (*(uint64_t (**)(void *, void, void))v2)(v5, *(void *)(a1 + 40), *(void *)(a1 + 48));
    else {
      free(v4);
    }
  }

  else
  {
    uint64_t v6 = nw_array_create();
  }

  v10[0] = MEMORY[0x1895F87A8];
  v10[1] = 3221225472LL;
  v10[2] = __nw_storage_lookup_items_block_invoke_2;
  v10[3] = &unk_189BC91E8;
  uint64_t v7 = *(void **)(a1 + 56);
  id v8 = *(id *)(a1 + 64);
  id v11 = (id)v6;
  id v12 = v8;
  id v9 = (id)v6;
  nw_queue_context_async(v7, v10);
}

id nw_storage_fault_in_canvas(void *a1, const char *a2, const char *a3, uint64_t a4)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  uint64_t v7 = a1;
  id v8 = v7;
  if (!v7)
  {
    __nwlog_obj();
    id v37 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v52 = "nw_storage_fault_in_canvas";
    uint64_t v38 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v49 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = type;
      if (!os_log_type_enabled(v39, type)) {
        goto LABEL_94;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int128 v52 = "nw_storage_fault_in_canvas";
      BOOL v41 = "%{public}s called with null storage";
LABEL_93:
      _os_log_impl(&dword_181A5C000, v39, v40, v41, buf, 0xCu);
      goto LABEL_94;
    }

    if (!v49)
    {
      __nwlog_obj();
      char v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = type;
      if (os_log_type_enabled(v39, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int128 v52 = "nw_storage_fault_in_canvas";
        BOOL v41 = "%{public}s called with null storage, backtrace limit exceeded";
        goto LABEL_93;
      }

      goto LABEL_94;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    char v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v40 = type;
    BOOL v45 = os_log_type_enabled(v39, type);
    if (!backtrace_string)
    {
      if (v45)
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int128 v52 = "nw_storage_fault_in_canvas";
        BOOL v41 = "%{public}s called with null storage, no backtrace";
        goto LABEL_93;
      }

      goto LABEL_94;
    }

    if (!v45) {
      goto LABEL_80;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int128 v52 = "nw_storage_fault_in_canvas";
    __int16 v53 = 2082;
    __int16 v54 = backtrace_string;
    uint64_t v46 = "%{public}s called with null storage, dumping backtrace:%{public}s";
LABEL_79:
    _os_log_impl(&dword_181A5C000, v39, v40, v46, buf, 0x16u);
LABEL_80:

    free(backtrace_string);
    goto LABEL_95;
  }

  if (!a3)
  {
    __nwlog_obj();
    __int128 v42 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int128 v52 = "nw_storage_fault_in_canvas";
    uint64_t v38 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v49 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = type;
      if (!os_log_type_enabled(v39, type)) {
        goto LABEL_94;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int128 v52 = "nw_storage_fault_in_canvas";
      BOOL v41 = "%{public}s called with null type";
      goto LABEL_93;
    }

    if (!v49)
    {
      __nwlog_obj();
      char v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v40 = type;
      if (os_log_type_enabled(v39, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int128 v52 = "nw_storage_fault_in_canvas";
        BOOL v41 = "%{public}s called with null type, backtrace limit exceeded";
        goto LABEL_93;
      }

      goto LABEL_94;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    char v39 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v40 = type;
    BOOL v47 = os_log_type_enabled(v39, type);
    if (!backtrace_string)
    {
      if (v47)
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int128 v52 = "nw_storage_fault_in_canvas";
        BOOL v41 = "%{public}s called with null type, no backtrace";
        goto LABEL_93;
      }

      goto LABEL_94;
    }

    if (!v47) {
      goto LABEL_80;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int128 v52 = "nw_storage_fault_in_canvas";
    __int16 v53 = 2082;
    __int16 v54 = backtrace_string;
    uint64_t v46 = "%{public}s called with null type, dumping backtrace:%{public}s";
    goto LABEL_79;
  }

  if (a4)
  {
    id v9 = nw_dictionary_copy_value(v7[8], (uint64_t)a2);
    if (v9)
    {
LABEL_48:
      id v35 = nw_dictionary_copy_value((uint64_t)v9, (uint64_t)a3);
      if (!v35)
      {
        id v35 = (void *)(*(uint64_t (**)(void, uint64_t))(a4 + 32))(0LL, v34);
        nw_dictionary_set_value((uint64_t)v9, a3, v35);
      }

      goto LABEL_51;
    }

    if ((nw_storage_open_db(v8) & 1) == 0)
    {
      id v10 = (void *)v8[1];
      if (v10)
      {
        free(v10);
        v8[1] = 0LL;
      }

      nw_storage_open_db(v8);
    }

    id v11 = v8;
    int v13 = (sqlite3_stmt **)(v11 + 32);
    id v12 = (sqlite3_stmt *)*((void *)v11 + 4);
    if (!v12)
    {
      if (sqlite3_prepare_v2( *((sqlite3 **)v11 + 3),  "SELECT type, canvas FROM network_storage WHERE key = ?",  -1,  v13,  0LL))
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v19 = (id)gLogObj;
        *(_DWORD *)__int128 buf = 136446210;
        __int128 v52 = "nw_storage_load_canvases_for_key";
        unint64_t v15 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v49 = 0;
        if (__nwlog_fault(v15, &type, &v49))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v16 = (os_log_s *)(id)gLogObj;
            os_log_type_t v17 = type;
            if (os_log_type_enabled(v16, type))
            {
              *(_DWORD *)__int128 buf = 136446210;
              __int128 v52 = "nw_storage_load_canvases_for_key";
              os_log_type_t v18 = "%{public}s Failed to prepare statement";
              goto LABEL_41;
            }

void nw_storage_enqueue_flush_and_free_key(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  if (!v5)
  {
    __nwlog_obj();
    id v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v34 = "nw_storage_enqueue_flush_and_free_key";
    id v12 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v32.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (LOBYTE(v32.receiver) == 17)
    {
      __nwlog_obj();
      int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t receiver = (os_log_type_t)v32.receiver;
      if (os_log_type_enabled(v13, (os_log_type_t)v32.receiver))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v34 = "nw_storage_enqueue_flush_and_free_key";
        unint64_t v15 = "%{public}s called with null storage";
LABEL_48:
        _os_log_impl(&dword_181A5C000, v13, receiver, v15, buf, 0xCu);
      }
    }

    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t receiver = (os_log_type_t)v32.receiver;
      BOOL v23 = os_log_type_enabled(v13, (os_log_type_t)v32.receiver);
      if (backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v34 = "nw_storage_enqueue_flush_and_free_key";
          __int16 v35 = 2082;
          id v36 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  receiver,  "%{public}s called with null storage, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_50:
        if (!v12) {
          goto LABEL_9;
        }
LABEL_51:
        free(v12);
        goto LABEL_9;
      }

      if (v23)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v34 = "nw_storage_enqueue_flush_and_free_key";
        unint64_t v15 = "%{public}s called with null storage, no backtrace";
        goto LABEL_48;
      }
    }

    else
    {
      __nwlog_obj();
      int v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t receiver = (os_log_type_t)v32.receiver;
      if (os_log_type_enabled(v13, (os_log_type_t)v32.receiver))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v34 = "nw_storage_enqueue_flush_and_free_key";
        unint64_t v15 = "%{public}s called with null storage, backtrace limit exceeded";
        goto LABEL_48;
      }
    }

uint64_t __nw_storage_lookup_items_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16LL))( *(void *)(a1 + 40),  *(void *)(a1 + 32));
}

void __nw_storage_enqueue_flush_and_free_key_block_invoke(uint64_t a1)
{
  *(_BYTE *)(*(void *)(a1 + 32) + 96LL) &= ~1u;
  nw_storage_flush(*(void **)(a1 + 32));
}

uint64_t nw_storage_open_db(void *a1)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  int v2 = v1;
  uint64_t v3 = (sqlite3 **)(v1 + 24);
  if (*((void *)v1 + 3)) {
    goto LABEL_2;
  }
  if (*((void *)v1 + 1)) {
    id v5 = (const char *)*((void *)v1 + 1);
  }
  else {
    id v5 = ":memory:";
  }
  if (sqlite3_open_v2(v5, v3, 3145734, 0LL)) {
    goto LABEL_56;
  }
  sqlite3_busy_timeout(*v3, 1000);
  if (sqlite3_exec(*v3, "PRAGMA journal_mode=WAL;", 0LL, 0LL, &errmsg))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v27 = "nw_storage_open_db";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v8 = (os_log_s *)(id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v27 = "nw_storage_open_db";
        id v10 = "%{public}s Failed to enable WAL mode";
LABEL_51:
        os_log_type_t v18 = v8;
        os_log_type_t v19 = v9;
LABEL_52:
        _os_log_impl(&dword_181A5C000, v18, v19, v10, buf, 0xCu);
        goto LABEL_53;
      }
    }

    else
    {
      if (v23)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)__int128 buf = 136446466;
            BOOL v27 = "nw_storage_open_db";
            __int16 v28 = 2082;
            id v29 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s Failed to enable WAL mode, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v7) {
            goto LABEL_56;
          }
          goto LABEL_55;
        }

        if (!v14) {
          goto LABEL_53;
        }
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v27 = "nw_storage_open_db";
        id v10 = "%{public}s Failed to enable WAL mode, no backtrace";
        os_log_type_t v18 = v8;
        os_log_type_t v19 = v13;
        goto LABEL_52;
      }

      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v27 = "nw_storage_open_db";
        id v10 = "%{public}s Failed to enable WAL mode, backtrace limit exceeded";
        goto LABEL_51;
      }
    }

    goto LABEL_53;
  }

  if (sqlite3_exec(*v3, "PRAGMA auto_vacuum = 2;", 0LL, 0LL, &errmsg))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v27 = "nw_storage_open_db";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v27 = "nw_storage_open_db";
        id v10 = "%{public}s Failed to set vacuum policy";
        goto LABEL_51;
      }
    }

    else
    {
      if (v23)
      {
        __int16 v16 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        BOOL v17 = os_log_type_enabled(v8, type);
        if (v16)
        {
          if (v17)
          {
            *(_DWORD *)__int128 buf = 136446466;
            BOOL v27 = "nw_storage_open_db";
            __int16 v28 = 2082;
            id v29 = v16;
            _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s Failed to set vacuum policy, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v16);
          if (!v7) {
            goto LABEL_56;
          }
          goto LABEL_55;
        }

        if (!v17) {
          goto LABEL_53;
        }
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v27 = "nw_storage_open_db";
        id v10 = "%{public}s Failed to set vacuum policy, no backtrace";
        goto LABEL_51;
      }

      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v27 = "nw_storage_open_db";
        id v10 = "%{public}s Failed to set vacuum policy, backtrace limit exceeded";
        goto LABEL_51;
      }
    }

void nw_storage_store_items(void *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  id v11 = a1;
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  __int16 v16 = v15;
  if (!v11)
  {
    __nwlog_obj();
    os_log_type_t v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v46 = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (v46 != OS_LOG_TYPE_FAULT)
    {
      if (v45)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = v46;
        BOOL v29 = os_log_type_enabled(v20, v46);
        if (backtrace_string)
        {
          if (v29)
          {
            *(_DWORD *)__int128 buf = 136446466;
            BOOL v48 = "nw_storage_store_items";
            __int16 v49 = 2082;
            __int128 v50 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v20,  v21,  "%{public}s called with null storage, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
LABEL_87:
          if (!v19) {
            goto LABEL_8;
          }
LABEL_88:
          free(v19);
          goto LABEL_8;
        }

        if (v29)
        {
          *(_DWORD *)__int128 buf = 136446210;
          BOOL v48 = "nw_storage_store_items";
          unint64_t v22 = "%{public}s called with null storage, no backtrace";
          goto LABEL_85;
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = v46;
        if (os_log_type_enabled(v20, v46))
        {
          *(_DWORD *)__int128 buf = 136446210;
          BOOL v48 = "nw_storage_store_items";
          unint64_t v22 = "%{public}s called with null storage, backtrace limit exceeded";
          goto LABEL_85;
        }
      }

      goto LABEL_86;
    }

    __nwlog_obj();
    os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = v46;
    if (!os_log_type_enabled(v20, v46)) {
      goto LABEL_86;
    }
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    unint64_t v22 = "%{public}s called with null storage";
    goto LABEL_85;
  }

  if (!a2)
  {
    __nwlog_obj();
    char v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v46 = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (v46 != OS_LOG_TYPE_FAULT)
    {
      if (!v45)
      {
        __nwlog_obj();
        os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = v46;
        if (os_log_type_enabled(v20, v46))
        {
          *(_DWORD *)__int128 buf = 136446210;
          BOOL v48 = "nw_storage_store_items";
          unint64_t v22 = "%{public}s called with null type, backtrace limit exceeded";
          goto LABEL_85;
        }

        goto LABEL_86;
      }

      uint64_t v30 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = v46;
      BOOL v31 = os_log_type_enabled(v20, v46);
      if (!v30)
      {
        if (v31)
        {
          *(_DWORD *)__int128 buf = 136446210;
          BOOL v48 = "nw_storage_store_items";
          unint64_t v22 = "%{public}s called with null type, no backtrace";
          goto LABEL_85;
        }

        goto LABEL_86;
      }

      if (!v31) {
        goto LABEL_59;
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v48 = "nw_storage_store_items";
      __int16 v49 = 2082;
      __int128 v50 = v30;
      objc_super v32 = "%{public}s called with null type, dumping backtrace:%{public}s";
      goto LABEL_58;
    }

    __nwlog_obj();
    os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = v46;
    if (!os_log_type_enabled(v20, v46)) {
      goto LABEL_86;
    }
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    unint64_t v22 = "%{public}s called with null type";
LABEL_85:
    _os_log_impl(&dword_181A5C000, v20, v21, v22, buf, 0xCu);
    goto LABEL_86;
  }

  if (!v12)
  {
    __nwlog_obj();
    unint64_t v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v46 = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (v46 != OS_LOG_TYPE_FAULT)
    {
      if (!v45)
      {
        __nwlog_obj();
        os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = v46;
        if (os_log_type_enabled(v20, v46))
        {
          *(_DWORD *)__int128 buf = 136446210;
          BOOL v48 = "nw_storage_store_items";
          unint64_t v22 = "%{public}s called with null items, backtrace limit exceeded";
          goto LABEL_85;
        }

        goto LABEL_86;
      }

      uint64_t v30 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = v46;
      BOOL v33 = os_log_type_enabled(v20, v46);
      if (!v30)
      {
        if (v33)
        {
          *(_DWORD *)__int128 buf = 136446210;
          BOOL v48 = "nw_storage_store_items";
          unint64_t v22 = "%{public}s called with null items, no backtrace";
          goto LABEL_85;
        }

        goto LABEL_86;
      }

      if (!v33) {
        goto LABEL_59;
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v48 = "nw_storage_store_items";
      __int16 v49 = 2082;
      __int128 v50 = v30;
      objc_super v32 = "%{public}s called with null items, dumping backtrace:%{public}s";
      goto LABEL_58;
    }

    __nwlog_obj();
    os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = v46;
    if (!os_log_type_enabled(v20, v46)) {
      goto LABEL_86;
    }
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    unint64_t v22 = "%{public}s called with null items";
    goto LABEL_85;
  }

  if (!v13)
  {
    __nwlog_obj();
    BOOL v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v46 = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (v46 != OS_LOG_TYPE_FAULT)
    {
      if (!v45)
      {
        __nwlog_obj();
        os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v21 = v46;
        if (os_log_type_enabled(v20, v46))
        {
          *(_DWORD *)__int128 buf = 136446210;
          BOOL v48 = "nw_storage_store_items";
          unint64_t v22 = "%{public}s called with null endpoint, backtrace limit exceeded";
          goto LABEL_85;
        }

        goto LABEL_86;
      }

      uint64_t v30 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = v46;
      BOOL v34 = os_log_type_enabled(v20, v46);
      if (!v30)
      {
        if (v34)
        {
          *(_DWORD *)__int128 buf = 136446210;
          BOOL v48 = "nw_storage_store_items";
          unint64_t v22 = "%{public}s called with null endpoint, no backtrace";
          goto LABEL_85;
        }

        goto LABEL_86;
      }

      if (!v34) {
        goto LABEL_59;
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v48 = "nw_storage_store_items";
      __int16 v49 = 2082;
      __int128 v50 = v30;
      objc_super v32 = "%{public}s called with null endpoint, dumping backtrace:%{public}s";
      goto LABEL_58;
    }

    __nwlog_obj();
    os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = v46;
    if (!os_log_type_enabled(v20, v46)) {
      goto LABEL_86;
    }
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    unint64_t v22 = "%{public}s called with null endpoint";
    goto LABEL_85;
  }

  if (!v14)
  {
    __nwlog_obj();
    unint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v46 = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (v46 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = v46;
      if (!os_log_type_enabled(v20, v46)) {
        goto LABEL_86;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v48 = "nw_storage_store_items";
      unint64_t v22 = "%{public}s called with null context";
      goto LABEL_85;
    }

    if (!v45)
    {
      __nwlog_obj();
      os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = v46;
      if (os_log_type_enabled(v20, v46))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v48 = "nw_storage_store_items";
        unint64_t v22 = "%{public}s called with null context, backtrace limit exceeded";
        goto LABEL_85;
      }

      goto LABEL_86;
    }

    uint64_t v30 = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v21 = v46;
    BOOL v35 = os_log_type_enabled(v20, v46);
    if (!v30)
    {
      if (v35)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v48 = "nw_storage_store_items";
        unint64_t v22 = "%{public}s called with null context, no backtrace";
        goto LABEL_85;
      }

      goto LABEL_86;
    }

    if (!v35) {
      goto LABEL_59;
    }
    *(_DWORD *)__int128 buf = 136446466;
    BOOL v48 = "nw_storage_store_items";
    __int16 v49 = 2082;
    __int128 v50 = v30;
    objc_super v32 = "%{public}s called with null context, dumping backtrace:%{public}s";
LABEL_58:
    _os_log_impl(&dword_181A5C000, v20, v21, v32, buf, 0x16u);
    goto LABEL_59;
  }

  if (!v15)
  {
    __nwlog_obj();
    BOOL v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v46 = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (v46 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = v46;
      if (os_log_type_enabled(v20, v46))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v48 = "nw_storage_store_items";
        unint64_t v22 = "%{public}s called with null completion";
        goto LABEL_85;
      }

void __nw_storage_store_items_block_invoke(uint64_t a1)
{
  int v2 = nw_storage_provider_for_type(*(void **)(a1 + 32), *(void *)(a1 + 80));
  uint64_t v3 = (const char *)(*((uint64_t (**)(void, void))v2 + 3))(*(void *)(a1 + 40), *(void *)(a1 + 48));
  if (v3)
  {
    uint64_t v4 = (char *)v3;
    nw_storage_fault_in_canvas(*(void **)(a1 + 32), v3, *(const char **)(a1 + 80), (uint64_t)v2);
    id v5 = (void *)objc_claimAutoreleasedReturnValue();
    id v6 = *(unsigned __int8 **)(a1 + 56);
    v8[0] = MEMORY[0x1895F87A8];
    v8[1] = 3221225472LL;
    v8[2] = __nw_storage_store_items_block_invoke_2;
    v8[3] = &unk_189BBED00;
    id v12 = v2;
    id v7 = v5;
    id v9 = v7;
    id v10 = *(id *)(a1 + 40);
    id v11 = *(id *)(a1 + 48);
    nw_array_apply(v6, (uint64_t)v8);
    else {
      free(v4);
    }
  }

  nw_queue_context_async(*(void **)(a1 + 64), *(void **)(a1 + 72));
}

uint64_t __nw_storage_store_items_block_invoke_2(void *a1, uint64_t a2, uint64_t a3)
{
  return 1LL;
}

void __nw_storage_remove_items_block_invoke(uint64_t a1)
{
  int v2 = nw_storage_provider_for_type(*(void **)(a1 + 32), *(void *)(a1 + 80));
  uint64_t v3 = (const char *)(*((uint64_t (**)(void, void))v2 + 3))(*(void *)(a1 + 40), *(void *)(a1 + 48));
  if (v3)
  {
    uint64_t v4 = (char *)v3;
    nw_storage_fault_in_canvas(*(void **)(a1 + 32), v3, *(const char **)(a1 + 80), (uint64_t)v2);
    id v5 = (void *)objc_claimAutoreleasedReturnValue();
    id v6 = v5;
    id v7 = *(unsigned __int8 **)(a1 + 56);
    if (v7)
    {
      v8[0] = MEMORY[0x1895F87A8];
      v8[1] = 3221225472LL;
      v8[2] = __nw_storage_remove_items_block_invoke_2;
      v8[3] = &unk_189BBED00;
      id v12 = v2;
      id v9 = v5;
      id v10 = *(id *)(a1 + 40);
      id v11 = *(id *)(a1 + 48);
      nw_array_apply(v7, (uint64_t)v8);
    }

    else
    {
      (*((void (**)(void *, void, void, void))v2 + 2))( v5,  0LL,  *(void *)(a1 + 40),  *(void *)(a1 + 48));
    }

    else {
      free(v4);
    }
  }

  nw_queue_context_async(*(void **)(a1 + 64), *(void **)(a1 + 72));
}

uint64_t __nw_storage_remove_items_block_invoke_2(void *a1, uint64_t a2, uint64_t a3)
{
  return 1LL;
}

void sub_18223EFAC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, id location)
{
}

nw_protocol_definition_t nw_protocol_copy_udp_definition(void)
{
  return (nw_protocol_definition_t)(id)g_udp_definition;
}

BOOL ___ZL32nw_protocol_setup_udp_definitionv_block_invoke()
{
  if (nw_protocol_udp_identifier::onceToken != -1) {
    dispatch_once(&nw_protocol_udp_identifier::onceToken, &__block_literal_global_24);
  }
  uint64_t v0 = nw_protocol_definition_create_with_identifier((__int128 *)&nw_protocol_udp_identifier::identifier);
  uint64_t v1 = (void *)g_udp_definition;
  g_udp_definition = (uint64_t)v0;

  nw_protocol_definition_set_options_allocator( (void *)g_udp_definition,  (uint64_t)nw_udp_allocate_options,  (uint64_t)nw_udp_copy_options,  (uint64_t)nw_udp_deallocate_options);
  nw_protocol_definition_set_options_equality_check((void *)g_udp_definition, (uint64_t)nw_udp_option_is_equal);
  nw_protocol_definition_set_options_serializer( (void *)g_udp_definition,  0,  (uint64_t)nw_udp_serialize_options,  (uint64_t)nw_udp_deserialize_options);
  nw_protocol_definition_set_metadata_allocator( (void *)g_udp_definition,  (uint64_t)nw_udp_allocate_metadata,  (uint64_t)nw_udp_deallocate_metadata);
  nw_protocol_definition_set_has_global_definition((void *)g_udp_definition);
  return nw_protocol_register_handle( (uint64_t)&nw_protocol_udp_identifier::identifier,  (void *)g_udp_definition,  (uint64_t)nw_protocol_udp_create,  0LL);
}

BOOL nw_udp_allocate_options(void *a1)
{
  id v1 = a1;
  int v2 = calloc(1uLL, 4uLL);
  if (v2) {
    goto LABEL_2;
  }
  __nwlog_obj();
  uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  id v5 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:

    return (BOOL)v2;
  }

  __break(1u);
  return result;
}

void sub_18223F450(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_udp_copy_options(void *a1, _DWORD *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (!a2)
  {
    __nwlog_obj();
    id v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v19 = "nw_udp_copy_options";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v7, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v19 = "nw_udp_copy_options";
          _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }

      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)__int128 buf = 136446466;
            os_log_type_t v19 = "nw_udp_copy_options";
            __int16 v20 = 2082;
            uint64_t v21 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null existing_handle, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }

        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v19 = "nw_udp_copy_options";
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null existing_handle, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v19 = "nw_udp_copy_options";
          _os_log_impl( &dword_181A5C000,  v8,  v15,  "%{public}s called with null existing_handle, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_18223F7C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_udp_deallocate_options(int a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

BOOL nw_udp_option_is_equal(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  return *a2 == *a3;
}

BOOL nw_udp_serialize_options(void *a1, _DWORD *a2, void *a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = v5;
  if (a2)
  {
    BOOL v7 = nw_udp_copy_options(v5, a2);
    *a3 = 4LL;
    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  __int16 v20 = "nw_udp_serialize_options";
  id v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v20 = "nw_udp_serialize_options";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null existing_handle", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v20 = "nw_udp_serialize_options";
          __int16 v21 = 2082;
          __int16 v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null existing_handle, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v15)
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v20 = "nw_udp_serialize_options";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null existing_handle, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v20 = "nw_udp_serialize_options";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null existing_handle, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_18223FAA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_udp_deserialize_options(void *a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = v5;
  if (a2)
  {
    if (a3 == 4)
    {
      BOOL v7 = nw_udp_copy_options(v5, a2);
      goto LABEL_4;
    }

    __nwlog_obj();
    os_log_type_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v25 = "nw_udp_deserialize_options";
    id v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v10, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        id v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          BOOL v25 = "nw_udp_deserialize_options";
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null (serialized_length == sizeof(struct nw_protocol_udp_options))",  buf,  0xCu);
        }

void sub_18223FF70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_udp_allocate_metadata(void *a1)
{
  id v1 = a1;
  int v2 = calloc(1uLL, 0x20uLL);
  if (v2) {
    goto LABEL_2;
  }
  __nwlog_obj();
  uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  id v5 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:
    _OWORD *v2 = 0u;
    v2[1] = 0u;

    return (BOOL)v2;
  }

  __break(1u);
  return result;
}

void sub_1822400AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_udp_deallocate_metadata(int a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

nw_protocol_options_t nw_udp_create_options(void)
{
  return (nw_protocol_options_t)nw_protocol_create_options((void *)g_udp_definition);
}

void nw_udp_options_set_prefer_no_checksum(nw_protocol_options_t options, BOOL prefer_no_checksum)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = options;
  if (nw_protocol_options_is_udp(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_udp_options_set_prefer_no_checksum_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = prefer_no_checksum;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v17 = "nw_udp_options_set_prefer_no_checksum";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v17 = "nw_udp_options_set_prefer_no_checksum";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_udp(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v17 = "nw_udp_options_set_prefer_no_checksum";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_udp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v17 = "nw_udp_options_set_prefer_no_checksum";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_udp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v17 = "nw_udp_options_set_prefer_no_checksum";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_udp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822403DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_udp_options_set_prefer_no_checksum_block_invoke(uint64_t a1, _BYTE *a2)
{
  *a2 = *a2 & 0xFE | *(_BYTE *)(a1 + 32);
  return 1LL;
}

BOOL nw_udp_options_get_prefer_no_checksum(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_udp(v1))
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_udp_options_get_prefer_no_checksum_block_invoke;
    v12[3] = &unk_189BC60A8;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_udp_options_get_prefer_no_checksum";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_udp_options_get_prefer_no_checksum";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_udp(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_udp_options_get_prefer_no_checksum";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_udp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_udp_options_get_prefer_no_checksum";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_udp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_udp_options_get_prefer_no_checksum";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_udp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_182240708( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_udp_options_get_prefer_no_checksum_block_invoke(uint64_t a1, _BYTE *a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *a2 & 1;
  return 1LL;
}

void nw_udp_options_set_no_metadata(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (nw_protocol_options_is_udp(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_udp_options_set_no_metadata_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v17 = "nw_udp_options_set_no_metadata";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_udp_options_set_no_metadata";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_udp(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v17 = "nw_udp_options_set_no_metadata";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_udp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_udp_options_set_no_metadata";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_udp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_udp_options_set_no_metadata";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_udp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_182240A1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_udp_options_set_no_metadata_block_invoke(uint64_t a1, _BYTE *a2)
{
  *a2 = *a2 & 0xFD | (2 * *(_BYTE *)(a1 + 32));
  return 1LL;
}

BOOL nw_udp_options_get_no_metadata(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_udp(v1))
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_udp_options_get_no_metadata_block_invoke;
    v12[3] = &unk_189BC60A8;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_udp_options_get_no_metadata";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_udp_options_get_no_metadata";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_udp(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_udp_options_get_no_metadata";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_udp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_udp_options_get_no_metadata";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_udp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_udp_options_get_no_metadata";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_udp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_182240D48( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_udp_options_get_no_metadata_block_invoke(uint64_t a1, _BYTE *a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (*a2 & 2) != 0;
  return 1LL;
}

uint64_t __nw_udp_options_set_ignore_inbound_checksum_block_invoke(uint64_t a1, _BYTE *a2)
{
  *a2 = *a2 & 0xFB | (4 * *(_BYTE *)(a1 + 32));
  return 1LL;
}

uint64_t __nw_udp_options_get_ignore_inbound_checksum_block_invoke(uint64_t a1, _BYTE *a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (*a2 & 4) != 0;
  return 1LL;
}

void nw_udp_options_set_use_quic_stats(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (nw_protocol_options_is_udp(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_udp_options_set_use_quic_stats_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v17 = "nw_udp_options_set_use_quic_stats";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_udp_options_set_use_quic_stats";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_udp(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v17 = "nw_udp_options_set_use_quic_stats";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_udp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_udp_options_set_use_quic_stats";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_udp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_udp_options_set_use_quic_stats";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_udp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_182241094(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_udp_options_set_use_quic_stats_block_invoke(uint64_t a1, _BYTE *a2)
{
  *a2 = *a2 & 0xF7 | (8 * *(_BYTE *)(a1 + 32));
  return 1LL;
}

BOOL nw_udp_options_get_use_quic_stats(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_udp(v1))
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_udp_options_get_use_quic_stats_block_invoke;
    v12[3] = &unk_189BC60A8;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_udp_options_get_use_quic_stats";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_udp_options_get_use_quic_stats";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_udp(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_udp_options_get_use_quic_stats";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_udp(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_udp_options_get_use_quic_stats";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_udp(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_udp_options_get_use_quic_stats";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_udp(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822413C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_udp_options_get_use_quic_stats_block_invoke(uint64_t a1, _BYTE *a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (*a2 & 8) != 0;
  return 1LL;
}

nw_protocol_metadata_t nw_udp_create_metadata(void)
{
  return (nw_protocol_metadata_t)nw_protocol_metadata_create_singleton((void *)g_udp_definition);
}

BOOL nw_protocol_metadata_is_udp(nw_protocol_metadata_t metadata)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  id v1 = metadata;
  if (v1)
  {
    BOOL v2 = nw_protocol_metadata_matches_definition((uint64_t)v1, g_udp_definition);
    goto LABEL_5;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v15 = "nw_protocol_metadata_is_udp";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v15 = "nw_protocol_metadata_is_udp";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v15 = "nw_protocol_metadata_is_udp";
          __int16 v16 = 2082;
          uint64_t v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v15 = "nw_protocol_metadata_is_udp";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v15 = "nw_protocol_metadata_is_udp";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_182241710(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182245A70(_Unwind_Exception *a1)
{
}

void sub_1822495EC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, char a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26, uint64_t a27, uint64_t a28, uint64_t a29, char a30)
{
}

void sub_182249718( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_18224B3A8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, char a26)
{
}

uint64_t __Block_byref_object_copy__45545(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__45546(uint64_t a1)
{
}

void sub_18224BAB4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
}

void sub_18224C1E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182250ECC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
}

void sub_1822533B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182254314(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1822579A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

void sub_182258CF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1822597E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_frame_reclassify(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if ((*(_WORD *)(a1 + 204) & 0x100) != 0 && g_channel_reclassifier)
    {
      g_channel_reclassifier(a1, a2, *(void *)(a1 + 88));
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v3 = (os_log_s *)gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v13 = "nw_frame_reclassify";
        _os_log_impl(&dword_181A5C000, v3, OS_LOG_TYPE_ERROR, "%{public}s frame does not support reclassify", buf, 0xCu);
      }

      nw_frame_finalize(a1);
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  char v13 = "nw_frame_reclassify";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v13 = "nw_frame_reclassify";
      os_log_type_t v7 = "%{public}s called with null frame";
      goto LABEL_22;
    }

    if (!v10)
    {
      uint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v13 = "nw_frame_reclassify";
      os_log_type_t v7 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_22;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)__int128 buf = 136446466;
        char v13 = "nw_frame_reclassify";
        __int16 v14 = 2082;
        BOOL v15 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_23;
    }

    if (v9)
    {
      *(_DWORD *)__int128 buf = 136446210;
      char v13 = "nw_frame_reclassify";
      os_log_type_t v7 = "%{public}s called with null frame, no backtrace";
LABEL_22:
      _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    }
  }

uint64_t nw_frame_check_validity(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    char v12 = "__nw_frame_check_validity";
    id v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v9 = 0;
    if (__nwlog_fault(v3, &type, &v9))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v4 = (os_log_s *)__nwlog_obj();
        os_log_type_t v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v12 = "__nw_frame_check_validity";
          os_log_type_t v6 = "%{public}s called with null frame";
LABEL_18:
          _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
        }
      }

      else if (v9)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v4 = (os_log_s *)__nwlog_obj();
        os_log_type_t v5 = type;
        BOOL v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *(_DWORD *)__int128 buf = 136446466;
            char v12 = "__nw_frame_check_validity";
            __int16 v13 = 2082;
            __int16 v14 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (v8)
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v12 = "__nw_frame_check_validity";
          os_log_type_t v6 = "%{public}s called with null frame, no backtrace";
          goto LABEL_18;
        }
      }

      else
      {
        uint64_t v4 = (os_log_s *)__nwlog_obj();
        os_log_type_t v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v12 = "__nw_frame_check_validity";
          os_log_type_t v6 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_18;
        }
      }
    }

void nw_frame_set_is_channel_frame(uint64_t a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    int v3 = *(unsigned __int16 *)(a1 + 204);
    uint64_t v2 = a1 + 204;
    int v4 = v3 | (*(unsigned __int8 *)(v2 + 2) << 16);
    if (a2) {
      __int16 v5 = 256;
    }
    else {
      __int16 v5 = 0;
    }
    unsigned int v6 = v4 & 0xFFFFFEFF;
    *(_WORD *)uint64_t v2 = v6 | v5;
    *(_BYTE *)(v2 + 2) = BYTE2(v6);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v16 = "__nw_frame_set_is_channel_frame";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v7, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v16 = "__nw_frame_set_is_channel_frame";
      char v10 = "%{public}s called with null frame";
      goto LABEL_20;
    }

    if (!v13)
    {
      BOOL v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v16 = "__nw_frame_set_is_channel_frame";
      char v10 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_20;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v12 = os_log_type_enabled(v8, type);
    if (backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v16 = "__nw_frame_set_is_channel_frame";
        __int16 v17 = 2082;
        uint64_t v18 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_21;
    }

    if (v12)
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v16 = "__nw_frame_set_is_channel_frame";
      char v10 = "%{public}s called with null frame, no backtrace";
LABEL_20:
      _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
    }
  }

void nw_frame_set_flow_id(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    char v13 = "nw_frame_set_flow_id";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v13 = "nw_frame_set_flow_id";
      __int16 v5 = "%{public}s called with null frame";
    }

    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)__int128 buf = 136446466;
          char v13 = "nw_frame_set_flow_id";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v2) {
          return;
        }
        goto LABEL_35;
      }

      if (!v7) {
        goto LABEL_34;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v13 = "nw_frame_set_flow_id";
      __int16 v5 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      int v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v13 = "nw_frame_set_flow_id";
      __int16 v5 = "%{public}s called with null frame, backtrace limit exceeded";
    }

uint64_t nw_frame_get_flow_id(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0LL;
      if ((*(_WORD *)(a1 + 204) & 0x100) != 0)
      {
        if (g_channel_get_flow_handler)
        {
          g_channel_get_flow_handler(a1, a2);
          return 1LL;
        }
      }

      return result;
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v15 = "nw_frame_get_flow_id";
    os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v15 = "nw_frame_get_flow_id";
        BOOL v7 = "%{public}s called with null out_flow_id";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (!v12)
    {
      __int16 v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v15 = "nw_frame_get_flow_id";
        BOOL v7 = "%{public}s called with null out_flow_id, backtrace limit exceeded";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v11 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v15 = "nw_frame_get_flow_id";
        BOOL v7 = "%{public}s called with null out_flow_id, no backtrace";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (v11)
    {
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v15 = "nw_frame_get_flow_id";
      __int16 v16 = 2082;
      __int16 v17 = backtrace_string;
      char v10 = "%{public}s called with null out_flow_id, dumping backtrace:%{public}s";
      goto LABEL_23;
    }

    goto LABEL_24;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v15 = "nw_frame_get_flow_id";
  os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v12)
    {
      __int16 v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v15 = "nw_frame_get_flow_id";
        BOOL v7 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v15 = "nw_frame_get_flow_id";
        BOOL v7 = "%{public}s called with null frame, no backtrace";
        goto LABEL_33;
      }

      goto LABEL_34;
    }

    if (v9)
    {
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v15 = "nw_frame_get_flow_id";
      __int16 v16 = 2082;
      __int16 v17 = backtrace_string;
      char v10 = "%{public}s called with null frame, dumping backtrace:%{public}s";
LABEL_23:
      _os_log_impl(&dword_181A5C000, v5, v6, v10, buf, 0x16u);
    }

uint64_t nw_frame_set_internet_checksum(uint64_t a1, char a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v14 = "__nw_frame_set_internet_checksum";
    __int16 v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (__nwlog_fault(v5, &type, &v11))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v14 = "__nw_frame_set_internet_checksum";
          BOOL v8 = "%{public}s called with null frame";
LABEL_18:
          _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
        }
      }

      else if (v11)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)__int128 buf = 136446466;
            __int16 v14 = "__nw_frame_set_internet_checksum";
            __int16 v15 = 2082;
            __int16 v16 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v14 = "__nw_frame_set_internet_checksum";
          BOOL v8 = "%{public}s called with null frame, no backtrace";
          goto LABEL_18;
        }
      }

      else
      {
        os_log_type_t v6 = (os_log_s *)__nwlog_obj();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v14 = "__nw_frame_set_internet_checksum";
          BOOL v8 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_18;
        }
      }
    }

uint64_t nw_frame_get_internet_checksum(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v15 = "__nw_frame_get_internet_checksum";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (__nwlog_fault(v6, &type, &v12))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v15 = "__nw_frame_get_internet_checksum";
          BOOL v9 = "%{public}s called with null frame";
LABEL_18:
          _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
        }
      }

      else if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)__int128 buf = 136446466;
            __int16 v15 = "__nw_frame_get_internet_checksum";
            __int16 v16 = 2082;
            uint64_t v17 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }

        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v15 = "__nw_frame_get_internet_checksum";
          BOOL v9 = "%{public}s called with null frame, no backtrace";
          goto LABEL_18;
        }
      }

      else
      {
        os_log_type_t v7 = (os_log_s *)__nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v15 = "__nw_frame_get_internet_checksum";
          BOOL v9 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_18;
        }
      }
    }

void nw_frame_set_departure_time(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(void *)(a1 + 160) = a2;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v11 = "__nw_frame_set_departure_time";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v11 = "__nw_frame_set_departure_time";
      __int16 v5 = "%{public}s called with null frame";
      goto LABEL_17;
    }

    if (!v8)
    {
      int v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v11 = "__nw_frame_set_departure_time";
      __int16 v5 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)__int128 buf = 136446466;
        BOOL v11 = "__nw_frame_set_departure_time";
        __int16 v12 = 2082;
        char v13 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v7)
    {
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v11 = "__nw_frame_set_departure_time";
      __int16 v5 = "%{public}s called with null frame, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    }
  }

uint64_t nw_frame_get_departure_time(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1) {
    return *(void *)(a1 + 160);
  }
  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v11 = "__nw_frame_get_departure_time";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v11 = "__nw_frame_get_departure_time";
        __int16 v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v11 = "__nw_frame_get_departure_time";
          __int16 v12 = 2082;
          char v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v7)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v11 = "__nw_frame_get_departure_time";
        __int16 v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      int v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v11 = "__nw_frame_get_departure_time";
        __int16 v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

void nw_frame_set_buffer_used_malloc(uint64_t a1, __int16 a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(_WORD *)(a1 + 204) = *(_WORD *)(a1 + 204) & 0xFFFE | a2;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v11 = "__nw_frame_set_buffer_used_malloc";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v11 = "__nw_frame_set_buffer_used_malloc";
      __int16 v5 = "%{public}s called with null frame";
      goto LABEL_17;
    }

    if (!v8)
    {
      int v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v11 = "__nw_frame_set_buffer_used_malloc";
      __int16 v5 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    int v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)__int128 buf = 136446466;
        BOOL v11 = "__nw_frame_set_buffer_used_malloc";
        __int16 v12 = 2082;
        char v13 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v7)
    {
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v11 = "__nw_frame_set_buffer_used_malloc";
      __int16 v5 = "%{public}s called with null frame, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    }
  }

uint64_t nw_frame_get_manager_for_size(unsigned int a1)
{
  if (nw_context_copy_implicit_context::onceToken != -1) {
    dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
  }
  return nw_frame_get_buffer_manager_with_context( (id)nw_context_copy_implicit_context::implicit_context,  a1);
}

dispatch_data_t nw_frame_copy_unclaimed_data(unsigned int *object, int a2, _BYTE *a3)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (!object)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v27 = "nw_frame_copy_unclaimed_data";
    __int16 v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v25 = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (v25 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = v25;
      if (!os_log_type_enabled(v17, v25)) {
        goto LABEL_41;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v27 = "nw_frame_copy_unclaimed_data";
      uint64_t v19 = "%{public}s called with null frame";
    }

    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = v25;
      BOOL v21 = os_log_type_enabled(v17, v25);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v27 = "nw_frame_copy_unclaimed_data";
          __int16 v28 = 2082;
          BOOL v29 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v17,  v18,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_41;
      }

      if (!v21)
      {
LABEL_41:
        if (v16) {
          free(v16);
        }
        return 0LL;
      }

      *(_DWORD *)__int128 buf = 136446210;
      BOOL v27 = "nw_frame_copy_unclaimed_data";
      uint64_t v19 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      uint64_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = v25;
      if (!os_log_type_enabled(v17, v25)) {
        goto LABEL_41;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v27 = "nw_frame_copy_unclaimed_data";
      uint64_t v19 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v17, v18, v19, buf, 0xCu);
    goto LABEL_41;
  }

  if (a3) {
    *a3 = 0;
  }
  if (!*((void *)object + 14)
    || (object[51] & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(object, *((void *)object + 11)))
  {
    return 0LL;
  }

  unsigned int v6 = object[13];
  if (!v6) {
    return 0LL;
  }
  uint64_t v7 = 0LL;
  uint64_t v8 = object[14];
  int v9 = object[15] + v8;
  size_t v10 = v6 - v9;
  if (v6 == v9) {
    return (dispatch_data_t)v7;
  }
  BOOL v11 = (char *)*((void *)object + 14);
  if (!v11) {
    return (dispatch_data_t)v7;
  }
  if ((object[51] & 2) != 0)
  {
    uint64_t v7 = *((void *)object + 12);
    if (v7) {
      dispatch_retain(*((dispatch_object_t *)object + 12));
    }
    return (dispatch_data_t)v7;
  }

  if ((object[51] & 1) != 0 && !(_DWORD)v8)
  {
    nw_frame_will_free_buffer_externally((uint64_t)object);
    return dispatch_data_create(v11, v10, 0LL, (dispatch_block_t)*MEMORY[0x1895F8A88]);
  }

  uint64_t v13 = *((void *)object + 13);
  if (v13 && !(_DWORD)v8)
  {
    nw_frame_will_free_buffer_externally((uint64_t)object);
    BOOL v14 = nw_queue_copy_current_workloop();
    v23[0] = MEMORY[0x1895F87A8];
    v23[1] = 0x40000000LL;
    v23[2] = __nw_frame_copy_unclaimed_data_block_invoke;
    v23[3] = &__block_descriptor_tmp_46411;
    v23[4] = v13;
    void v23[5] = v11;
    __int16 v15 = v23;
    return dispatch_data_create(v11, v10, (dispatch_queue_t)v14, v15);
  }

  v11 += v8;
  if (a2)
  {
    if (a3) {
      *a3 = 1;
    }
    os_retain(object);
    BOOL v14 = nw_queue_copy_current_workloop();
    destructor[0] = MEMORY[0x1895F87A8];
    destructor[1] = 0x40000000LL;
    destructor[2] = __nw_frame_copy_unclaimed_data_block_invoke_2;
    destructor[3] = &__block_descriptor_tmp_3_46412;
    destructor[4] = object;
    __int16 v15 = destructor;
    return dispatch_data_create(v11, v10, (dispatch_queue_t)v14, v15);
  }

  return dispatch_data_create(v11, v10, 0LL, 0LL);
}

void __nw_frame_copy_unclaimed_data_block_invoke(uint64_t a1)
{
}

void __nw_frame_copy_unclaimed_data_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2) {
    os_release(v2);
  }
}

uint64_t nw_frame_copy_external_data(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v16 = "__nw_frame_get_external_data";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_29;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v16 = "__nw_frame_get_external_data";
      size_t v10 = "%{public}s called with null frame";
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v16 = "__nw_frame_get_external_data";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_29;
      }

      if (!v12)
      {
LABEL_29:
        if (v7) {
          free(v7);
        }
        return 0LL;
      }

      *(_DWORD *)__int128 buf = 136446210;
      __int16 v16 = "__nw_frame_get_external_data";
      size_t v10 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_29;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v16 = "__nw_frame_get_external_data";
      size_t v10 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
    goto LABEL_29;
  }

  if ((*(_WORD *)(a1 + 204) & 2) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v3 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v16 = "__nw_frame_get_external_data";
      _os_log_impl(&dword_181A5C000, v3, OS_LOG_TYPE_ERROR, "%{public}s Frame does not use external data", buf, 0xCu);
    }

    return 0LL;
  }

  if (a2) {
    *a2 = *(_DWORD *)(a1 + 56);
  }
  if (a3)
  {
    int v5 = *(_DWORD *)(a1 + 52);
    if (v5) {
      v5 -= *(_DWORD *)(a1 + 56) + *(_DWORD *)(a1 + 60);
    }
    *a3 = v5;
  }

  uint64_t v4 = *(void *)(a1 + 96);
  if (v4) {
    dispatch_retain(*(dispatch_object_t *)(a1 + 96));
  }
  return v4;
}

void nw_frame_free_buffer(uint64_t a1)
{
  if ((*(_WORD *)(a1 + 204) & 2) == 0)
  {
    uint64_t v2 = *(void **)(a1 + 112);
    if (!v2)
    {
LABEL_4:
      *(_WORD *)(a1 + 196) = 0;
      *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
      return;
    }

uint64_t nw_frame_is_metadata_complete(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v12 = "__nw_frame_is_metadata_complete";
    int v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v9 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v12 = "__nw_frame_is_metadata_complete";
      unsigned int v6 = "%{public}s called with null frame";
    }

    else if (v9)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v12 = "__nw_frame_is_metadata_complete";
          __int16 v13 = 2082;
          BOOL v14 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (!v8)
      {
LABEL_18:
        if (v3) {
          free(v3);
        }
        return 0LL;
      }

      *(_DWORD *)__int128 buf = 136446210;
      BOOL v12 = "__nw_frame_is_metadata_complete";
      unsigned int v6 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      uint64_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v12 = "__nw_frame_is_metadata_complete";
      unsigned int v6 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
    goto LABEL_18;
  }

  uint64_t v1 = *(void *)(a1 + 64);
  if (v1) {
    return (*(unsigned __int8 *)(v1 + 66) >> 6) & 1;
  }
  return 0LL;
}

void *nw_frame_copy_metadata_for_protocol(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v21 = "__nw_frame_copy_metadata_for_protocol";
    size_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v21 = "__nw_frame_copy_metadata_for_protocol";
      __int16 v13 = "%{public}s called with null frame";
      goto LABEL_39;
    }

    if (!v18)
    {
      BOOL v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v21 = "__nw_frame_copy_metadata_for_protocol";
      __int16 v13 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_39;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v15 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (!v15) {
        goto LABEL_40;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v21 = "__nw_frame_copy_metadata_for_protocol";
      __int16 v13 = "%{public}s called with null frame, no backtrace";
      goto LABEL_39;
    }

    if (v15)
    {
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v21 = "__nw_frame_copy_metadata_for_protocol";
      __int16 v22 = 2082;
      uint64_t v23 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_40:
    if (!v10) {
      return 0LL;
    }
LABEL_41:
    free(v10);
    return 0LL;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v21 = "__nw_frame_copy_metadata_for_protocol";
    size_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v21 = "__nw_frame_copy_metadata_for_protocol";
      __int16 v13 = "%{public}s called with null definition";
      goto LABEL_39;
    }

    if (!v18)
    {
      BOOL v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v21 = "__nw_frame_copy_metadata_for_protocol";
      __int16 v13 = "%{public}s called with null definition, backtrace limit exceeded";
      goto LABEL_39;
    }

    __int16 v16 = (char *)__nw_create_backtrace_string();
    BOOL v11 = (os_log_s *)__nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v17 = os_log_type_enabled(v11, type);
    if (v16)
    {
      if (v17)
      {
        *(_DWORD *)__int128 buf = 136446466;
        BOOL v21 = "__nw_frame_copy_metadata_for_protocol";
        __int16 v22 = 2082;
        uint64_t v23 = v16;
        _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null definition, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v16);
      if (!v10) {
        return 0LL;
      }
      goto LABEL_41;
    }

    if (v17)
    {
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v21 = "__nw_frame_copy_metadata_for_protocol";
      __int16 v13 = "%{public}s called with null definition, no backtrace";
LABEL_39:
      _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
      goto LABEL_40;
    }

    goto LABEL_40;
  }

  int v3 = *(void **)(a1 + 64);
  if (!v3) {
    return 0LL;
  }
  while (1)
  {
    os_log_type_t v5 = (void *)v3[6];
    if (v5)
    {
      unsigned int v6 = v5;
      id v7 = v6[1];

      BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe(a2, (uint64_t)v7);
      if (v7) {
        os_release(v7);
      }
      if (is_equal_unsafe) {
        break;
      }
    }

    int v3 = (void *)*v3;
    if (!v3) {
      return 0LL;
    }
  }

  char v9 = (void *)v3[6];
  if (!v9) {
    return 0LL;
  }
  return os_retain(v9);
}

uint64_t nw_frame_copy_metadata_uuid(uint64_t a1, _OWORD *a2, BOOL *a3)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v14 = "__nw_frame_copy_metadata_uuid";
    os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v14 = "__nw_frame_copy_metadata_uuid";
      BOOL v8 = "%{public}s called with null frame";
    }

    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v14 = "__nw_frame_copy_metadata_uuid";
          __int16 v15 = 2082;
          __int16 v16 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (!v10)
      {
LABEL_21:
        if (v5) {
          free(v5);
        }
        return 0LL;
      }

      *(_DWORD *)__int128 buf = 136446210;
      BOOL v14 = "__nw_frame_copy_metadata_uuid";
      BOOL v8 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      unsigned int v6 = (os_log_s *)__nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v14 = "__nw_frame_copy_metadata_uuid";
      BOOL v8 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v6, v7, v8, buf, 0xCu);
    goto LABEL_21;
  }

  uint64_t v3 = *(void *)(a1 + 64);
  if (v3)
  {
    if (a3) {
      *a3 = (*(_BYTE *)(v3 + 66) & 0x40) != 0;
    }
    if (*(void *)(v3 + 48))
    {
      *a2 = *(_OWORD *)(v3 + 16);
      return 1LL;
    }
  }

  return 0LL;
}

uint64_t nw_frame_is_connection_complete(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 186) >> 7;
}

uint64_t nw_frame_set_connection_complete(uint64_t result, int a2)
{
  if (a2) {
    char v2 = 0x80;
  }
  else {
    char v2 = 0;
  }
  *(_BYTE *)(result + 186) = v2 & 0x80 | *(_BYTE *)(result + 186) & 0x7F;
  return result;
}

void nw_frame_inherit_metadata(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v77 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v70 = "__nw_frame_inherit_metadata";
    __int16 v54 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v67 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v55 = (os_log_s *)__nwlog_obj();
      os_log_type_t v56 = type[0];
      if (!os_log_type_enabled(v55, type[0])) {
        goto LABEL_114;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v70 = "__nw_frame_inherit_metadata";
      os_log_type_t v57 = "%{public}s called with null original_frame";
      goto LABEL_113;
    }

    if (!v67)
    {
      uint64_t v55 = (os_log_s *)__nwlog_obj();
      os_log_type_t v56 = type[0];
      if (!os_log_type_enabled(v55, type[0])) {
        goto LABEL_114;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v70 = "__nw_frame_inherit_metadata";
      os_log_type_t v57 = "%{public}s called with null original_frame, backtrace limit exceeded";
      goto LABEL_113;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v55 = (os_log_s *)__nwlog_obj();
    os_log_type_t v56 = type[0];
    BOOL v59 = os_log_type_enabled(v55, type[0]);
    if (!backtrace_string)
    {
      if (!v59) {
        goto LABEL_114;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v70 = "__nw_frame_inherit_metadata";
      os_log_type_t v57 = "%{public}s called with null original_frame, no backtrace";
      goto LABEL_113;
    }

    if (v59)
    {
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v70 = "__nw_frame_inherit_metadata";
      __int16 v71 = 2082;
      uint64_t v72 = (uint64_t)backtrace_string;
      _os_log_impl( &dword_181A5C000,  v55,  v56,  "%{public}s called with null original_frame, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_114:
    if (!v54) {
      return;
    }
    goto LABEL_115;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v70 = "__nw_frame_inherit_metadata";
    __int16 v54 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v67 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v55 = (os_log_s *)__nwlog_obj();
      os_log_type_t v56 = type[0];
      if (!os_log_type_enabled(v55, type[0])) {
        goto LABEL_114;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v70 = "__nw_frame_inherit_metadata";
      os_log_type_t v57 = "%{public}s called with null new_frame";
      goto LABEL_113;
    }

    if (!v67)
    {
      uint64_t v55 = (os_log_s *)__nwlog_obj();
      os_log_type_t v56 = type[0];
      if (!os_log_type_enabled(v55, type[0])) {
        goto LABEL_114;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v70 = "__nw_frame_inherit_metadata";
      os_log_type_t v57 = "%{public}s called with null new_frame, backtrace limit exceeded";
      goto LABEL_113;
    }

    os_log_type_t v60 = (char *)__nw_create_backtrace_string();
    uint64_t v55 = (os_log_s *)__nwlog_obj();
    os_log_type_t v56 = type[0];
    BOOL v61 = os_log_type_enabled(v55, type[0]);
    if (v60)
    {
      if (v61)
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v70 = "__nw_frame_inherit_metadata";
        __int16 v71 = 2082;
        uint64_t v72 = (uint64_t)v60;
        _os_log_impl( &dword_181A5C000,  v55,  v56,  "%{public}s called with null new_frame, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v60);
      if (!v54) {
        return;
      }
LABEL_115:
      free(v54);
      return;
    }

    if (v61)
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v70 = "__nw_frame_inherit_metadata";
      os_log_type_t v57 = "%{public}s called with null new_frame, no backtrace";
LABEL_113:
      _os_log_impl(&dword_181A5C000, v55, v56, v57, buf, 0xCu);
      goto LABEL_114;
    }

    goto LABEL_114;
  }

  int v4 = a3;
  os_log_type_t v5 = *(uint64_t ***)(a1 + 64);
  if (!v5)
  {
LABEL_82:
    if (v4)
    {
    }

    return;
  }

  os_log_type_t v65 = (uint64_t **)(a2 + 64);
  uint64_t v66 = a2 + 120;
  os_log_type_t v63 = (_OWORD *)(a2 + 136);
  while (v4)
  {
    int v6 = (*((unsigned __int8 *)v5 + 66) >> 6) & 1;
    os_log_type_t v7 = v5[6];
    if (v7) {
      goto LABEL_9;
    }
LABEL_17:
    if ((*(_WORD *)(a2 + 204) & 8) != 0) {
      goto LABEL_6;
    }
LABEL_22:
    char v11 = *(void **)(a2 + 168);
    if (v11)
    {
      os_release(v11);
      *(void *)(a2 + 16_Block_object_dispose(va, 8) = 0LL;
    }

    if (v7)
    {
      *(void *)(a2 + 16_Block_object_dispose(va, 8) = os_retain(v7);
      int v12 = *(unsigned __int16 *)(a2 + 204);
      int v13 = v12 | (*(unsigned __int8 *)(a2 + 206) << 16);
      if ((v12 & 0x20) == 0)
      {
        BOOL v14 = v7;
        *os_log_type_t v63 = *((_OWORD *)v14 + 1);

        int v13 = *(unsigned __int16 *)(a2 + 204) | (*(unsigned __int8 *)(a2 + 206) << 16);
        int v4 = a3;
      }

      *(_BYTE *)(a2 + 206) = BYTE2(v13);
      *(_WORD *)(a2 + 204) = v13 | 8;
    }

    *(_BYTE *)(a2 + 186) = *(_BYTE *)(a2 + 186) & 0xBF | ((_BYTE)v6 << 6);
    uint64_t v15 = *(void *)(a2 + 64);
    if (!v15)
    {
      *(void *)(a2 + 64) = v66;
      *(void *)(a2 + 72) = v66;
      *(void *)(a2 + 120) = 0LL;
      *(void *)(a2 + 12_Block_object_dispose(va, 8) = v65;
      goto LABEL_6;
    }

    if (v15 != v66)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)__int128 buf = 136446722;
      uint64_t v70 = "__nw_frame_set_metadata";
      __int16 v71 = 2048;
      uint64_t v72 = v15;
      __int16 v73 = 2048;
      uint64_t v74 = v66;
      __int16 v16 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      char v67 = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v17 = gLogObj;
        os_log_type_t v18 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v70 = "__nw_frame_set_metadata";
          __int16 v71 = 2048;
          uint64_t v72 = v15;
          __int16 v73 = 2048;
          uint64_t v74 = v66;
          uint64_t v19 = (os_log_s *)v17;
          os_log_type_t v20 = v18;
          BOOL v21 = "%{public}s Existing metadata %p doesn't match expected %p";
          goto LABEL_61;
        }

        goto LABEL_62;
      }

      if (v67)
      {
        BOOL v34 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v35 = (os_log_s *)gLogObj;
        os_log_type_t v36 = type[0];
        BOOL v37 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v34)
        {
          if (v37)
          {
            *(_DWORD *)__int128 buf = 136446978;
            uint64_t v70 = "__nw_frame_set_metadata";
            __int16 v71 = 2048;
            uint64_t v72 = v15;
            __int16 v73 = 2048;
            uint64_t v74 = v66;
            __int16 v75 = 2082;
            os_log_type_t v76 = v34;
            _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s Existing metadata %p doesn't match expected %p, dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v34);
          goto LABEL_62;
        }

        if (!v37)
        {
LABEL_62:
          if (v16) {
            free(v16);
          }
          goto LABEL_6;
        }

        *(_DWORD *)__int128 buf = 136446722;
        uint64_t v70 = "__nw_frame_set_metadata";
        __int16 v71 = 2048;
        uint64_t v72 = v15;
        __int16 v73 = 2048;
        uint64_t v74 = v66;
        uint64_t v19 = v35;
        os_log_type_t v20 = v36;
        BOOL v21 = "%{public}s Existing metadata %p doesn't match expected %p, no backtrace";
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v38 = gLogObj;
        os_log_type_t v39 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
          goto LABEL_62;
        }
        *(_DWORD *)__int128 buf = 136446722;
        uint64_t v70 = "__nw_frame_set_metadata";
        __int16 v71 = 2048;
        uint64_t v72 = v15;
        __int16 v73 = 2048;
        uint64_t v74 = v66;
        uint64_t v19 = (os_log_s *)v38;
        os_log_type_t v20 = v39;
        BOOL v21 = "%{public}s Existing metadata %p doesn't match expected %p, backtrace limit exceeded";
      }

void nw_frame_set_expire_time(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    __int16 v3 = *(_WORD *)(a1 + 204);
    char v2 = (_WORD *)(a1 + 204);
    _WORD *v2 = v3 | 0x10;
    *(void *)(v2 - 26) = a2;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  int v13 = "__nw_frame_set_expire_time";
  int v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)__int128 buf = 136446210;
      int v13 = "__nw_frame_set_expire_time";
      os_log_type_t v7 = "%{public}s called with null frame";
      goto LABEL_17;
    }

    if (!v10)
    {
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)__int128 buf = 136446210;
      int v13 = "__nw_frame_set_expire_time";
      os_log_type_t v7 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)__int128 buf = 136446466;
        int v13 = "__nw_frame_set_expire_time";
        __int16 v14 = 2082;
        uint64_t v15 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v9)
    {
      *(_DWORD *)__int128 buf = 136446210;
      int v13 = "__nw_frame_set_expire_time";
      os_log_type_t v7 = "%{public}s called with null frame, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    }
  }

uint64_t nw_frame_get_expire_time(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    char v11 = "__nw_frame_get_expire_time";
    char v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v8 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v11 = "__nw_frame_get_expire_time";
      os_log_type_t v5 = "%{public}s called with null frame";
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)__int128 buf = 136446466;
          char v11 = "__nw_frame_get_expire_time";
          __int16 v12 = 2082;
          int v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (!v7)
      {
LABEL_20:
        if (v2) {
          free(v2);
        }
        return 0LL;
      }

      *(_DWORD *)__int128 buf = 136446210;
      char v11 = "__nw_frame_get_expire_time";
      os_log_type_t v5 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      __int16 v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v11 = "__nw_frame_get_expire_time";
      os_log_type_t v5 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    goto LABEL_20;
  }

  if ((*(_WORD *)(a1 + 204) & 0x10) == 0) {
    return 0LL;
  }
  return *(void *)(a1 + 152);
}

void nw_frame_set_packet_id(uint64_t a1, _OWORD *a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v15 = "__nw_frame_set_packet_id";
    os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v15 = "__nw_frame_set_packet_id";
      BOOL v7 = "%{public}s called with null frame";
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v15 = "__nw_frame_set_packet_id";
          __int16 v16 = 2082;
          uint64_t v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v4) {
          return;
        }
LABEL_35:
        free(v4);
        return;
      }

      if (!v9) {
        goto LABEL_34;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v15 = "__nw_frame_set_packet_id";
      BOOL v7 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      os_log_type_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v15 = "__nw_frame_set_packet_id";
      BOOL v7 = "%{public}s called with null frame, backtrace limit exceeded";
    }

uint64_t nw_frame_get_packet_id(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if ((*(_WORD *)(a1 + 204) & 0x20) != 0) {
      return a1 + 136;
    }
    else {
      return 0LL;
    }
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v11 = "__nw_frame_get_packet_id";
  int v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v11 = "__nw_frame_get_packet_id";
        os_log_type_t v5 = "%{public}s called with null frame";
LABEL_19:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v11 = "__nw_frame_get_packet_id";
          __int16 v12 = 2082;
          int v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v7)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v11 = "__nw_frame_get_packet_id";
        os_log_type_t v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_19;
      }
    }

    else
    {
      int v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v11 = "__nw_frame_get_packet_id";
        os_log_type_t v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_19;
      }
    }
  }

void nw_frame_set_is_wake_packet(uint64_t a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    int v3 = *(unsigned __int16 *)(a1 + 204);
    uint64_t v2 = a1 + 204;
    int v4 = v3 | (*(unsigned __int8 *)(v2 + 2) << 16);
    if (a2) {
      __int16 v5 = 0x4000;
    }
    else {
      __int16 v5 = 0;
    }
    unsigned int v6 = v4 & 0xFFFFBFFF;
    *(_WORD *)uint64_t v2 = v6 | v5;
    *(_BYTE *)(v2 + 2) = BYTE2(v6);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  __int16 v16 = "__nw_frame_set_is_wake_packet";
  BOOL v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v7, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v16 = "__nw_frame_set_is_wake_packet";
      char v10 = "%{public}s called with null frame";
      goto LABEL_20;
    }

    if (!v13)
    {
      char v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v16 = "__nw_frame_set_is_wake_packet";
      char v10 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_20;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v8 = (os_log_s *)__nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v12 = os_log_type_enabled(v8, type);
    if (backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v16 = "__nw_frame_set_is_wake_packet";
        __int16 v17 = 2082;
        uint64_t v18 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v8,  v9,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_21;
    }

    if (v12)
    {
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v16 = "__nw_frame_set_is_wake_packet";
      char v10 = "%{public}s called with null frame, no backtrace";
LABEL_20:
      _os_log_impl(&dword_181A5C000, v8, v9, v10, buf, 0xCu);
    }
  }

void nw_frame_set_app_metadata(uint64_t a1, char a2, char a3)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    int v3 = *(unsigned __int16 *)(a1 + 204) | (*(unsigned __int8 *)(a1 + 206) << 16);
    if ((v3 & 0x10000) == 0)
    {
      *(_BYTE *)(a1 + 201) = a2;
      *(_BYTE *)(a1 + 202) = a3;
      *(_WORD *)(a1 + 204) = v3;
      *(_BYTE *)(a1 + 206) = (v3 | 0x10000u) >> 16;
    }

    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  char v13 = "__nw_frame_set_app_metadata";
  int v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v13 = "__nw_frame_set_app_metadata";
      BOOL v7 = "%{public}s called with null frame";
      goto LABEL_18;
    }

    if (!v10)
    {
      __int16 v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v13 = "__nw_frame_set_app_metadata";
      BOOL v7 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_18;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)__int128 buf = 136446466;
        char v13 = "__nw_frame_set_app_metadata";
        __int16 v14 = 2082;
        uint64_t v15 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v5,  v6,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_19;
    }

    if (v9)
    {
      *(_DWORD *)__int128 buf = 136446210;
      char v13 = "__nw_frame_set_app_metadata";
      BOOL v7 = "%{public}s called with null frame, no backtrace";
LABEL_18:
      _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
    }
  }

BOOL nw_frame_is_in_array(void *a1, int a2)
{
  if (a2)
  {
    if (a1[4]) {
      return 1LL;
    }
    int v3 = a1 + 5;
  }

  else
  {
    if (a1[2]) {
      return 1LL;
    }
    int v3 = a1 + 3;
  }

  return *v3 != 0LL;
}

uint64_t nw_frame_array_last(uint64_t a1)
{
  return **(void **)(*(void *)(a1 + 8) + 8LL);
}

uint64_t nw_frame_array_previous(int a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a2 + 40);
    if (*(_OWORD *)(a2 + 32) == 0LL) {
      return 0LL;
    }
  }

  else
  {
    uint64_t v2 = *(void *)(a2 + 24);
    if (*(_OWORD *)(a2 + 16) == 0LL) {
      return 0LL;
    }
  }

  return **(void **)(v2 + 8);
}

uint64_t *nw_frame_array_prepend(uint64_t *result, int a2, uint64_t a3)
{
  int v3 = result + 1;
  uint64_t v4 = *result;
  if (a2)
  {
    *(void *)(a3 + 32) = v4;
    uint64_t v5 = a3 + 32;
    os_log_type_t v6 = (void *)(v4 + 40);
  }

  else
  {
    *(void *)(a3 + 16) = v4;
    uint64_t v5 = a3 + 16;
    os_log_type_t v6 = (void *)(v4 + 24);
  }

  if (v4) {
    int v3 = v6;
  }
  *int v3 = v5;
  *uint64_t result = a3;
  *(void *)(v5 + _Block_object_dispose(va, 8) = result;
  return result;
}

uint64_t nw_frame_array_insert_after(uint64_t result, int a2, void *a3, uint64_t a4)
{
  uint64_t v4 = (void *)(result + 8);
  if (a2)
  {
    uint64_t v6 = *(void *)(a4 + 32);
    uint64_t v5 = (void *)(a4 + 32);
    a3[4] = v6;
    BOOL v7 = (void *)(v6 + 40);
    if (v6) {
      uint64_t v4 = v7;
    }
    *uint64_t v4 = a3 + 4;
    void *v5 = a3;
    a3[5] = v5;
  }

  else
  {
    uint64_t v9 = *(void *)(a4 + 16);
    char v8 = (void *)(a4 + 16);
    a3[2] = v9;
    char v10 = (void *)(v9 + 24);
    if (v9) {
      uint64_t v4 = v10;
    }
    *uint64_t v4 = a3 + 2;
    void *v8 = a3;
    a3[3] = v8;
  }

  return result;
}

uint64_t nw_frame_array_remove_each(uint64_t result, char a2, uint64_t a3)
{
  uint64_t v4 = (uint64_t *)result;
  if ((a2 & 1) != 0)
  {
    do
    {
      uint64_t v6 = *v4;
      if (!*v4) {
        break;
      }
      uint64_t v7 = *(void *)(v6 + 32);
      uint64_t v5 = *(void **)(v6 + 40);
      if (v7)
      {
        *(void *)(v7 + 40) = v5;
        uint64_t v5 = *(void **)(v6 + 40);
      }

      else
      {
        v4[1] = (uint64_t)v5;
      }

      void *v5 = v7;
      *(void *)(v6 + 32) = 0LL;
      *(void *)(v6 + 40) = 0LL;
      uint64_t result = (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
    }

    while ((result & 1) != 0);
  }

  else
  {
    do
    {
      uint64_t v9 = *v4;
      if (!*v4) {
        break;
      }
      uint64_t v10 = *(void *)(v9 + 16);
      char v8 = *(void **)(v9 + 24);
      if (v10)
      {
        *(void *)(v10 + 24) = v8;
        char v8 = *(void **)(v9 + 24);
      }

      else
      {
        v4[1] = (uint64_t)v8;
      }

      void *v8 = v10;
      *(void *)(v9 + 16) = 0LL;
      *(void *)(v9 + 24) = 0LL;
      uint64_t result = (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
    }

    while ((result & 1) != 0);
  }

  return result;
}

void *nw_frame_array_prepend_array(void *result, void **a2, int a3)
{
  uint64_t v3 = *result;
  if (a3)
  {
    if (v3)
    {
      *a2[1] = v3;
      uint64_t v4 = (void *)result[1];
      *(void *)(*result + 40LL) = a2[1];
      a2[1] = v4;
      *uint64_t result = 0LL;
      result[1] = result;
    }

    if (*a2)
    {
      uint64_t v5 = (void *)result[1];
      ++result;
      void *v5 = *a2;
      (*a2)[5] = *result;
LABEL_10:
      *uint64_t result = a2[1];
      *a2 = 0LL;
      a2[1] = a2;
    }
  }

  else
  {
    if (v3)
    {
      *a2[1] = v3;
      uint64_t v6 = (void *)result[1];
      *(void *)(*result + 24LL) = a2[1];
      a2[1] = v6;
      *uint64_t result = 0LL;
      result[1] = result;
    }

    if (*a2)
    {
      uint64_t v7 = (void *)result[1];
      ++result;
      *uint64_t v7 = *a2;
      (*a2)[3] = *result;
      goto LABEL_10;
    }
  }

  return result;
}

uint64_t nw_frame_array_unclaimed_length(uint64_t *a1, int a2)
{
  unsigned int v3 = 0;
  nw_frame_array_get_frame_count(a1, a2, &v3);
  return v3;
}

uint64_t nw_frame_array_get_frame_count(uint64_t *a1, int a2, _DWORD *a3)
{
  uint64_t v88 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v79 = "nw_frame_array_get_frame_count";
    __int16 v69 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v76 = 0;
    if (__nwlog_fault(v69, &type, &v76))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v70 = (os_log_s *)__nwlog_obj();
        os_log_type_t v71 = type;
        if (os_log_type_enabled(v70, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v79 = "nw_frame_array_get_frame_count";
          uint64_t v72 = "%{public}s called with null array";
LABEL_112:
          _os_log_impl(&dword_181A5C000, v70, v71, v72, buf, 0xCu);
        }
      }

      else if (v76)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v70 = (os_log_s *)__nwlog_obj();
        os_log_type_t v71 = type;
        BOOL v74 = os_log_type_enabled(v70, type);
        if (backtrace_string)
        {
          if (v74)
          {
            *(_DWORD *)__int128 buf = 136446466;
            uint64_t v79 = "nw_frame_array_get_frame_count";
            __int16 v80 = 2082;
            uint64_t v81 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v70,  v71,  "%{public}s called with null array, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_113;
        }

        if (v74)
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v79 = "nw_frame_array_get_frame_count";
          uint64_t v72 = "%{public}s called with null array, no backtrace";
          goto LABEL_112;
        }
      }

      else
      {
        uint64_t v70 = (os_log_s *)__nwlog_obj();
        os_log_type_t v71 = type;
        if (os_log_type_enabled(v70, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v79 = "nw_frame_array_get_frame_count";
          uint64_t v72 = "%{public}s called with null array, backtrace limit exceeded";
          goto LABEL_112;
        }
      }
    }

BOOL nw_frame_array_check_length(uint64_t *a1, char a2, unsigned int a3)
{
  uint64_t v3 = *a1;
  unsigned int v4 = 0;
  if ((a2 & 1) != 0)
  {
    while (v3)
    {
      int v8 = *(_DWORD *)(v3 + 52);
      if (v8) {
        v8 -= *(_DWORD *)(v3 + 56) + *(_DWORD *)(v3 + 60);
      }
      uint64_t v3 = *(void *)(v3 + 32);
      BOOL v5 = __CFADD__(v4, v8);
      unsigned int v6 = v4 + v8;
      v4 += v8;
      if (v5) {
        unsigned int v7 = -1;
      }
      else {
        unsigned int v7 = v6;
      }
      if (v7 >= a3) {
        return 1LL;
      }
    }
  }

  else
  {
    while (v3)
    {
      int v11 = *(_DWORD *)(v3 + 52);
      if (v11) {
        v11 -= *(_DWORD *)(v3 + 56) + *(_DWORD *)(v3 + 60);
      }
      uint64_t v3 = *(void *)(v3 + 16);
      BOOL v5 = __CFADD__(v4, v11);
      unsigned int v9 = v4 + v11;
      v4 += v11;
      if (v5) {
        unsigned int v10 = -1;
      }
      else {
        unsigned int v10 = v9;
      }
      if (v10 >= a3) {
        return 1LL;
      }
    }
  }

  return v4 >= a3;
}

uint64_t nw_frame_array_fill_from_pending_array(void *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
    unsigned int v9 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v31)
      {
        unsigned int v10 = (os_log_s *)__nwlog_obj();
        os_log_type_t v11 = type[0];
        if (!os_log_type_enabled(v10, type[0])) {
          goto LABEL_35;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
        BOOL v12 = "%{public}s called with null from_array, backtrace limit exceeded";
        goto LABEL_34;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v10 = (os_log_s *)__nwlog_obj();
      os_log_type_t v11 = type[0];
      BOOL v14 = os_log_type_enabled(v10, type[0]);
      if (!backtrace_string)
      {
        if (!v14) {
          goto LABEL_35;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
        BOOL v12 = "%{public}s called with null from_array, no backtrace";
        goto LABEL_34;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        uint64_t v15 = "%{public}s called with null from_array, dumping backtrace:%{public}s";
LABEL_24:
        _os_log_impl(&dword_181A5C000, v10, v11, v15, buf, 0x16u);
      }

uint64_t __nw_frame_array_fill_from_pending_array_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) >= *(_DWORD *)(a1 + 64)) {
    return 0LL;
  }
  int v4 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  if (a2)
  {
    int v5 = *(_DWORD *)(a2 + 52);
    if (v5) {
      v5 -= *(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60);
    }
    goto LABEL_5;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v29 = "__nw_frame_unclaimed_length";
  uint64_t v13 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (__nwlog_fault(v13, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v29 = "__nw_frame_unclaimed_length";
        BOOL v16 = "%{public}s called with null frame";
LABEL_37:
        _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
      }
    }

    else
    {
      int v21 = v4;
      if (v26)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v23 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v23)
          {
            *(_DWORD *)__int128 buf = 136446466;
            uint64_t v29 = "__nw_frame_unclaimed_length";
            __int16 v30 = 2082;
            char v31 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          int v4 = v21;
          goto LABEL_38;
        }

        int v4 = v21;
        if (v23)
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v29 = "__nw_frame_unclaimed_length";
          BOOL v16 = "%{public}s called with null frame, no backtrace";
          goto LABEL_37;
        }
      }

      else
      {
        BOOL v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v29 = "__nw_frame_unclaimed_length";
          BOOL v16 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_37;
        }
      }
    }
  }

uint64_t nw_frame_get_ecn_flag(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1) {
    return *(_BYTE *)(a1 + 186) & 3;
  }
  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v11 = "nw_frame_get_ecn_flag";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v11 = "nw_frame_get_ecn_flag";
        int v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v11 = "nw_frame_get_ecn_flag";
          __int16 v12 = 2082;
          uint64_t v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v7)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v11 = "nw_frame_get_ecn_flag";
        int v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v11 = "nw_frame_get_ecn_flag";
        int v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

void nw_frame_set_ecn_flag(uint64_t a1, char a2)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(_BYTE *)(a1 + 186) = *(_BYTE *)(a1 + 186) & 0xFC | a2 & 3;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v11 = "nw_frame_set_ecn_flag";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v11 = "nw_frame_set_ecn_flag";
      int v5 = "%{public}s called with null frame";
      goto LABEL_17;
    }

    if (!v8)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v11 = "nw_frame_set_ecn_flag";
      int v5 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_17;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v3 = (os_log_s *)__nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v11 = "nw_frame_set_ecn_flag";
        __int16 v12 = 2082;
        uint64_t v13 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_18;
    }

    if (v7)
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v11 = "nw_frame_set_ecn_flag";
      int v5 = "%{public}s called with null frame, no backtrace";
LABEL_17:
      _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
    }
  }

void nw_frame_set_compression_generation_count(uint64_t a1, int a2)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v13 = "nw_frame_set_compression_generation_count";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v13 = "nw_frame_set_compression_generation_count";
      int v5 = "%{public}s called with null frame";
    }

    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v13 = "nw_frame_set_compression_generation_count";
          __int16 v14 = 2082;
          os_log_type_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }

      if (!v9) {
        goto LABEL_19;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v13 = "nw_frame_set_compression_generation_count";
      int v5 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      uint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v13 = "nw_frame_set_compression_generation_count";
      int v5 = "%{public}s called with null frame, backtrace limit exceeded";
    }

uint64_t nw_frame_split(uint64_t *a1, unsigned int a2)
{
  uint64_t v78 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v67 = "nw_frame_split";
    os_log_type_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v64 = 0;
    if (__nwlog_fault(v20, &type, &v64))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v21 = (os_log_s *)__nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v67 = "nw_frame_split";
          BOOL v23 = "%{public}s called with null frame";
LABEL_66:
          os_log_type_t v46 = v21;
          os_log_type_t v47 = v22;
          uint32_t v48 = 12;
LABEL_106:
          _os_log_impl(&dword_181A5C000, v46, v47, v23, buf, v48);
        }
      }

      else if (v64)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v21 = (os_log_s *)__nwlog_obj();
        os_log_type_t v22 = type;
        BOOL v53 = os_log_type_enabled(v21, type);
        if (backtrace_string)
        {
          if (!v53) {
            goto LABEL_38;
          }
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v67 = "nw_frame_split";
          __int16 v68 = 2082;
          uint64_t v69 = (uint64_t)backtrace_string;
          char v26 = "%{public}s called with null frame, dumping backtrace:%{public}s";
          goto LABEL_36;
        }

        if (v53)
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v67 = "nw_frame_split";
          BOOL v23 = "%{public}s called with null frame, no backtrace";
          goto LABEL_66;
        }
      }

      else
      {
        int v21 = (os_log_s *)__nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v67 = "nw_frame_split";
          BOOL v23 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_66;
        }
      }
    }

void __nw_frame_empty_finalizer(nw_frame *a1, BOOL a2, void *a3)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v18 = "__nw_frame_empty_finalizer";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v3, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v4 = (os_log_s *)__nwlog_obj();
        os_log_type_t v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v18 = "__nw_frame_empty_finalizer";
          uint64_t v6 = "%{public}s called with null frame";
LABEL_21:
          _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
        }
      }

      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v4 = (os_log_s *)__nwlog_obj();
        os_log_type_t v5 = type;
        BOOL v12 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)__int128 buf = 136446466;
            os_log_type_t v18 = "__nw_frame_empty_finalizer";
            __int16 v19 = 2082;
            os_log_type_t v20 = (nw_frame *)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
        }

        else if (v12)
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v18 = "__nw_frame_empty_finalizer";
          uint64_t v6 = "%{public}s called with null frame, no backtrace";
          goto LABEL_21;
        }
      }

      else
      {
        os_log_type_t v4 = (os_log_s *)__nwlog_obj();
        os_log_type_t v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v18 = "__nw_frame_empty_finalizer";
          uint64_t v6 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_21;
        }
      }
    }

void __nw_frame_split_finalizer(nw_frame *a1, BOOL a2, void *a3)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v47 = "__nw_frame_split_finalizer";
    uint64_t v3 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v44 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v47 = "__nw_frame_split_finalizer";
      uint64_t v6 = "%{public}s called with null frame";
    }

    else if (v44)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v39 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v39)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v47 = "__nw_frame_split_finalizer";
          __int16 v48 = 2082;
          uint64_t v49 = (uint64_t)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_61;
      }

      if (!v39) {
        goto LABEL_61;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v47 = "__nw_frame_split_finalizer";
      uint64_t v6 = "%{public}s called with null frame, no backtrace";
    }

    else
    {
      os_log_type_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v47 = "__nw_frame_split_finalizer";
      uint64_t v6 = "%{public}s called with null frame, backtrace limit exceeded";
    }

    goto LABEL_59;
  }

  if (a3 != (void *)16435934)
  {
    if (a3)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v47 = "__nw_frame_split_finalizer";
      uint64_t v3 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v44 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v4 = (os_log_s *)gLogObj;
        os_log_type_t v5 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_61;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v47 = "__nw_frame_split_finalizer";
        uint64_t v6 = "%{public}s trying to finalize non-split frame";
LABEL_59:
        uint64_t v24 = v4;
        os_log_type_t v25 = v5;
        uint32_t v26 = 12;
LABEL_60:
        _os_log_impl(&dword_181A5C000, v24, v25, v6, buf, v26);
        goto LABEL_61;
      }

      if (!v44)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v4 = (os_log_s *)gLogObj;
        os_log_type_t v5 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_61;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v47 = "__nw_frame_split_finalizer";
        uint64_t v6 = "%{public}s trying to finalize non-split frame, backtrace limit exceeded";
        goto LABEL_59;
      }

      os_log_type_t v18 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v4 = (os_log_s *)gLogObj;
      os_log_type_t v5 = type;
      BOOL v19 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!v18)
      {
        if (!v19) {
          goto LABEL_61;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v47 = "__nw_frame_split_finalizer";
        uint64_t v6 = "%{public}s trying to finalize non-split frame, no backtrace";
        goto LABEL_59;
      }

      if (v19)
      {
        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v47 = "__nw_frame_split_finalizer";
        __int16 v48 = 2082;
        uint64_t v49 = (uint64_t)v18;
        os_log_type_t v20 = "%{public}s trying to finalize non-split frame, dumping backtrace:%{public}s";
        goto LABEL_44;
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v47 = "__nw_frame_split_finalizer";
      uint64_t v3 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v44 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v4 = (os_log_s *)__nwlog_obj();
        os_log_type_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_61;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v47 = "__nw_frame_split_finalizer";
        uint64_t v6 = "%{public}s called with null context";
        goto LABEL_59;
      }

      if (!v44)
      {
        os_log_type_t v4 = (os_log_s *)__nwlog_obj();
        os_log_type_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_61;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v47 = "__nw_frame_split_finalizer";
        uint64_t v6 = "%{public}s called with null context, backtrace limit exceeded";
        goto LABEL_59;
      }

      os_log_type_t v18 = (char *)__nw_create_backtrace_string();
      os_log_type_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v40 = os_log_type_enabled(v4, type);
      if (!v18)
      {
        if (!v40) {
          goto LABEL_61;
        }
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v47 = "__nw_frame_split_finalizer";
        uint64_t v6 = "%{public}s called with null context, no backtrace";
        goto LABEL_59;
      }

      if (v40)
      {
        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v47 = "__nw_frame_split_finalizer";
        __int16 v48 = 2082;
        uint64_t v49 = (uint64_t)v18;
        os_log_type_t v20 = "%{public}s called with null context, dumping backtrace:%{public}s";
        goto LABEL_44;
      }
    }

void __nw_frame_custom_finalizer(nw_frame *a1, BOOL a2, void *a3)
{
  __int128 buffer = (void *)nw_frame_get_buffer((uint64_t)a1, 0LL);
  if (buffer) {
    free(buffer);
  }
  nw_frame_reset((uint64_t)a1, 0LL, 0, 0LL, 0LL);
  if (a1) {
    os_release(a1);
  }
}

uint64_t nw_frame_get_tso_segment_size(uint64_t a1, BOOL *a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      *a2 = (*(_BYTE *)(a1 + 206) & 2) != 0;
      return *(unsigned __int16 *)(a1 + 198);
    }

    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v14 = "__nw_frame_get_tso_segment_size";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v14 = "__nw_frame_get_tso_segment_size";
        uint64_t v6 = "%{public}s called with null tso_ipv6";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (!v11)
    {
      os_log_type_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v14 = "__nw_frame_get_tso_segment_size";
        uint64_t v6 = "%{public}s called with null tso_ipv6, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v14 = "__nw_frame_get_tso_segment_size";
        uint64_t v6 = "%{public}s called with null tso_ipv6, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v10)
    {
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v14 = "__nw_frame_get_tso_segment_size";
      __int16 v15 = 2082;
      char v16 = backtrace_string;
      BOOL v9 = "%{public}s called with null tso_ipv6, dumping backtrace:%{public}s";
      goto LABEL_21;
    }

    goto LABEL_22;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v14 = "__nw_frame_get_tso_segment_size";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      os_log_type_t v4 = (os_log_s *)__nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v14 = "__nw_frame_get_tso_segment_size";
        uint64_t v6 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v4 = (os_log_s *)__nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v14 = "__nw_frame_get_tso_segment_size";
        uint64_t v6 = "%{public}s called with null frame, no backtrace";
        goto LABEL_31;
      }

      goto LABEL_32;
    }

    if (v8)
    {
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v14 = "__nw_frame_get_tso_segment_size";
      __int16 v15 = 2082;
      char v16 = backtrace_string;
      BOOL v9 = "%{public}s called with null frame, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_181A5C000, v4, v5, v9, buf, 0x16u);
    }

void nw_frame_set_tso_segment_size(uint64_t a1, __int16 a2, int a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    int v4 = *(unsigned __int16 *)(a1 + 204);
    uint64_t v3 = a1 + 204;
    *(_WORD *)(v3 - 6) = a2;
    int v5 = v4 | (*(unsigned __int8 *)(v3 + 2) << 16);
    if (a3) {
      int v6 = 0x20000;
    }
    else {
      int v6 = 0;
    }
    unsigned int v7 = v5 & 0xFFFDFFFF;
    *(_WORD *)uint64_t v3 = v7;
    *(_BYTE *)(v3 + 2) = (v7 | v6) >> 16;
    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v17 = "__nw_frame_set_tso_segment_size";
  BOOL v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v8, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v17 = "__nw_frame_set_tso_segment_size";
      char v11 = "%{public}s called with null frame";
      goto LABEL_20;
    }

    if (!v14)
    {
      BOOL v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v17 = "__nw_frame_set_tso_segment_size";
      char v11 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_20;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v13 = os_log_type_enabled(v9, type);
    if (backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v17 = "__nw_frame_set_tso_segment_size";
        __int16 v18 = 2082;
        BOOL v19 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null frame, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_21;
    }

    if (v13)
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v17 = "__nw_frame_set_tso_segment_size";
      char v11 = "%{public}s called with null frame, no backtrace";
LABEL_20:
      _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
    }
  }

uint64_t NWPBAddressEndpointReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x189611CF0];
  uint64_t v4 = (int)*MEMORY[0x189611CF0];
  unint64_t v5 = *(void *)(a2 + v4);
  int v6 = (int *)MEMORY[0x189611CE8];
  unint64_t v7 = *(void *)(a2 + (int)*MEMORY[0x189611CE8]);
  BOOL v8 = (int *)MEMORY[0x189611CE0];
  if (v5 < v7)
  {
    os_log_type_t v10 = (int *)MEMORY[0x189611CD8];
    while (1)
    {
      BOOL v13 = (_BYTE *)(a2 + *v8);
      if (*v13) {
        return *(_BYTE *)(a2 + *v8) == 0;
      }
      if (v5 >= v7) {
        break;
      }
      char v14 = *(_BYTE *)(*(void *)(a2 + *v10) + v5);
      *(void *)(a2 + (int)v4) = v5 + 1;
      unint64_t v15 = v14 & 0x7F;
      if ((v14 & 0x80) == 0) {
        goto LABEL_39;
      }
      uint64_t v16 = *v3;
      unint64_t v17 = *(void *)(a2 + v16);
      if (v17 == -1LL || v17 >= *(void *)(a2 + *v6)) {
        goto LABEL_37;
      }
      unint64_t v18 = v17 + 1;
      int v19 = *(char *)(*(void *)(a2 + *v10) + v17);
      *(void *)(a2 + v16) = v18;
      v15 |= (unint64_t)(v19 & 0x7F) << 7;
      if ((v19 & 0x80000000) == 0) {
        goto LABEL_39;
      }
      uint64_t v20 = *v3;
      unint64_t v21 = *(void *)(a2 + v20);
      if (v21 == -1LL || v21 >= *(void *)(a2 + *v6)) {
        goto LABEL_37;
      }
      unint64_t v22 = v21 + 1;
      int v23 = *(char *)(*(void *)(a2 + *v10) + v21);
      *(void *)(a2 + v20) = v22;
      v15 |= (unint64_t)(v23 & 0x7F) << 14;
      if ((v23 & 0x80000000) == 0) {
        goto LABEL_39;
      }
      uint64_t v24 = *v3;
      unint64_t v25 = *(void *)(a2 + v24);
      if (v25 == -1LL || v25 >= *(void *)(a2 + *v6)) {
        goto LABEL_37;
      }
      unint64_t v26 = v25 + 1;
      int v27 = *(char *)(*(void *)(a2 + *v10) + v25);
      *(void *)(a2 + v24) = v26;
      v15 |= (unint64_t)(v27 & 0x7F) << 21;
      if ((v27 & 0x80000000) == 0) {
        goto LABEL_39;
      }
      uint64_t v28 = *v3;
      unint64_t v29 = *(void *)(a2 + v28);
      if (v29 == -1LL || v29 >= *(void *)(a2 + *v6)) {
        goto LABEL_37;
      }
      unint64_t v30 = v29 + 1;
      int v31 = *(char *)(*(void *)(a2 + *v10) + v29);
      *(void *)(a2 + v2_Block_object_dispose(va, 8) = v30;
      v15 |= (unint64_t)(v31 & 0x7F) << 28;
      if ((v31 & 0x80000000) == 0) {
        goto LABEL_39;
      }
      uint64_t v32 = *v3;
      unint64_t v33 = *(void *)(a2 + v32);
      if (v33 == -1LL || v33 >= *(void *)(a2 + *v6)) {
        goto LABEL_37;
      }
      unint64_t v34 = v33 + 1;
      int v35 = *(char *)(*(void *)(a2 + *v10) + v33);
      *(void *)(a2 + v32) = v34;
      if ((v35 & 0x80000000) == 0) {
        goto LABEL_39;
      }
      uint64_t v36 = *v3;
      unint64_t v37 = *(void *)(a2 + v36);
      if (v37 == -1LL || v37 >= *(void *)(a2 + *v6)) {
        goto LABEL_37;
      }
      unint64_t v38 = v37 + 1;
      int v39 = *(char *)(*(void *)(a2 + *v10) + v37);
      *(void *)(a2 + v36) = v38;
      if ((v39 & 0x80000000) == 0) {
        goto LABEL_39;
      }
      uint64_t v40 = *v3;
      unint64_t v41 = *(void *)(a2 + v40);
      if (v41 == -1LL || v41 >= *(void *)(a2 + *v6)) {
        goto LABEL_37;
      }
      unint64_t v42 = v41 + 1;
      int v43 = *(char *)(*(void *)(a2 + *v10) + v41);
      *(void *)(a2 + v40) = v42;
      if ((v43 & 0x80000000) == 0) {
        goto LABEL_39;
      }
      uint64_t v44 = *v3;
      unint64_t v45 = *(void *)(a2 + v44);
      if (v45 == -1LL || v45 >= *(void *)(a2 + *v6)) {
        goto LABEL_37;
      }
      unint64_t v46 = v45 + 1;
      int v47 = *(char *)(*(void *)(a2 + *v10) + v45);
      *(void *)(a2 + v44) = v46;
      if ((v47 & 0x80000000) == 0) {
        goto LABEL_39;
      }
      uint64_t v48 = *v3;
      unint64_t v49 = *(void *)(a2 + v48);
      if (v49 == -1LL || v49 >= *(void *)(a2 + *v6))
      {
LABEL_37:
        BOOL v13 = (_BYTE *)(a2 + *v8);
        goto LABEL_38;
      }

      unint64_t v50 = v49 + 1;
      int v51 = *(char *)(*(void *)(a2 + *v10) + v49);
      *(void *)(a2 + v4_Block_object_dispose(va, 8) = v50;
      if (v51 < 0)
      {
        unint64_t v15 = 0LL;
        int v52 = *(unsigned __int8 *)(a2 + *v8);
        goto LABEL_41;
      }

uint64_t llhttp__internal__run@<X0>( uint64_t a1@<X0>, unsigned __int8 *a2@<X1>, unsigned __int8 *a3@<X2>, signed int a4@<W8>)
{
  uint64_t result = *(unsigned int *)(a1 + 56);
  switch((int)result)
  {
    case 1:
      goto LABEL_1918;
    case 2:
      goto LABEL_1911;
    case 3:
      goto LABEL_1932;
    case 4:
      goto LABEL_1931;
    case 5:
      goto LABEL_1934;
    case 6:
      goto LABEL_1654;
    case 7:
      goto LABEL_1647;
    case 8:
      goto LABEL_1641;
    case 9:
      goto LABEL_1639;
    case 10:
      goto LABEL_1638;
    case 11:
      goto LABEL_1631;
    case 12:
      goto LABEL_1493;
    case 13:
LABEL_1490:
      uint64_t v367 = *(void *)(a1 + 88);
      if (!v367 || (v368 = *(uint64_t (**)(uint64_t))(v367 + 144)) == 0LL || (int v369 = v368(a1)) == 0)
      {
LABEL_1493:
        if ((*(_WORD *)(a1 + 78) & 0x100) == 0)
        {
          uint64_t result = 0LL;
          *(_DWORD *)(a1 + 24) = 25;
          BOOL v8 = "Missing expected CR after chunk extension name";
          goto LABEL_2272;
        }

        goto LABEL_1631;
      }

      if (v369 == 21)
      {
        uint64_t result = 0LL;
        *(_DWORD *)(a1 + 24) = 21;
        *(void *)(a1 + 32) = "on_chunk_extension_name pause";
        *(void *)(a1 + 40) = a2;
        *(void *)(a1 + 56) = 12LL;
        return result;
      }

      goto LABEL_1580;
    case 14:
      goto LABEL_1499;
    case 15:
      goto LABEL_1508;
    case 16:
      goto LABEL_1630;
    case 17:
LABEL_1531:
      uint64_t v397 = *(void *)(a1 + 88);
      if (!v397) {
        goto LABEL_1630;
      }
      v398 = *(uint64_t (**)(uint64_t))(v397 + 152);
      if (!v398) {
        goto LABEL_1630;
      }
      int v399 = v398(a1);
      if (!v399) {
        goto LABEL_1630;
      }
      if (v399 != 21) {
        goto LABEL_1688;
      }
      uint64_t result = 0LL;
      *(_DWORD *)(a1 + 24) = 21;
      *(void *)(a1 + 32) = "on_chunk_extension_value pause";
      *(void *)(a1 + 40) = a2;
      *(void *)(a1 + 56) = 16LL;
      return result;
    case 18:
      goto LABEL_1540;
    case 19:
      goto LABEL_1625;
    case 20:
      goto LABEL_1622;
    case 21:
      goto LABEL_1695;
    case 22:
      goto LABEL_1611;
    case 23:
      goto LABEL_1672;
    case 24:
      while (2)
      {
        if (a2 == a3) {
          return 24LL;
        }
        uint64_t result = 24LL;
        while (1)
        {
          int v431 = llhttp__internal__run_lookup_table_3[*a2];
          if (v431 != 1) {
            break;
          }
          if (++a2 == a3) {
            return result;
          }
        }

        if (v431 != 2)
        {
          if (v431 == 3)
          {
            ++a2;
LABEL_1611:
            if (a2 == a3) {
              return 22LL;
            }
            if (llhttp__internal__run_lookup_table_14[*a2] == 1)
            {
LABEL_1602:
              ++a2;
              continue;
            }

            uint64_t v432 = *(void *)(a1 + 8);
            *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
            uint64_t v433 = *(void *)(a1 + 88);
            if (v433)
            {
              v434 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v433 + 64);
              if (v434)
              {
                int v435 = v434(a1, v432, &a2[-v432]);
                if (v435)
                {
                  int v436 = v435;
                  if (v435 == -1)
                  {
                    *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_value";
                    int v436 = 24;
                  }

                  uint64_t result = 0LL;
                  *(_DWORD *)(a1 + 24) = v436;
                  *(void *)(a1 + 40) = a2 + 1;
                  *(void *)(a1 + 56) = 21LL;
                  return result;
                }
              }
            }

            ++a2;
LABEL_1695:
            uint64_t result = 0LL;
            *(_DWORD *)(a1 + 24) = 2;
            BOOL v8 = "Invalid quoted-pair in chunk extensions quoted value";
          }

          else
          {
            uint64_t v459 = *(void *)(a1 + 8);
            *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
            uint64_t v460 = *(void *)(a1 + 88);
            if (v460)
            {
              v461 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v460 + 64);
              if (v461)
              {
                int v462 = v461(a1, v459, &a2[-v459]);
                if (v462)
                {
                  int v463 = v462;
                  if (v462 == -1)
                  {
                    *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_value";
                    int v463 = 24;
                  }

                  uint64_t result = 0LL;
                  *(_DWORD *)(a1 + 24) = v463;
                  *(void *)(a1 + 40) = a2 + 1;
                  *(void *)(a1 + 56) = 23LL;
                  return result;
                }
              }
            }

            ++a2;
LABEL_1672:
            uint64_t result = 0LL;
            *(_DWORD *)(a1 + 24) = 2;
            BOOL v8 = "Invalid character in chunk extensions quoted value";
          }

          goto LABEL_2272;
        }

        break;
      }

      ++a2;
      uint64_t v437 = *(void *)(a1 + 8);
      *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
      uint64_t v438 = *(void *)(a1 + 88);
      if (v438)
      {
        v439 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v438 + 64);
        if (v439)
        {
          int v440 = v439(a1, v437, &a2[-v437]);
          if (v440)
          {
            int v465 = v440;
            if (v440 == -1)
            {
              *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_value";
              int v465 = 24;
            }

            uint64_t result = 0LL;
            *(_DWORD *)(a1 + 24) = v465;
            *(void *)(a1 + 40) = a2;
            *(void *)(a1 + 56) = 20LL;
            return result;
          }
        }
      }

LABEL_1622:
      uint64_t v441 = *(void *)(a1 + 88);
      if (v441 && (v442 = *(uint64_t (**)(uint64_t))(v441 + 152)) != 0LL && (int v443 = v442(a1)) != 0)
      {
        if (v443 == 21)
        {
          uint64_t result = 0LL;
          *(_DWORD *)(a1 + 24) = 21;
          *(void *)(a1 + 32) = "on_chunk_extension_value pause";
          *(void *)(a1 + 40) = a2;
          *(void *)(a1 + 56) = 19LL;
          return result;
        }
      }

      else
      {
LABEL_1625:
        if (a2 == a3) {
          return 19LL;
        }
        int v444 = *a2;
        if (v444 == 10)
        {
LABEL_1630:
          if ((*(_WORD *)(a1 + 78) & 0x100) == 0)
          {
            uint64_t result = 0LL;
            *(_DWORD *)(a1 + 24) = 25;
            BOOL v8 = "Missing expected CR after chunk extension value";
            goto LABEL_2272;
          }

          goto LABEL_1631;
        }

        if (v444 != 59)
        {
          if (v444 != 13)
          {
            uint64_t result = 0LL;
            *(_DWORD *)(a1 + 24) = 2;
            BOOL v8 = "Invalid character in chunk extensions quote value";
            goto LABEL_2272;
          }

LABEL_1629:
          ++a2;
LABEL_1631:
          if (a2 == a3) {
            return 11LL;
          }
          if (*a2 == 10)
          {
            ++a2;
          }

          else if ((*(_WORD *)(a1 + 78) & 0x40) == 0)
          {
            uint64_t result = 0LL;
            *(_DWORD *)(a1 + 24) = 2;
            BOOL v8 = "Expected LF after chunk size";
            goto LABEL_2272;
          }

          uint64_t v445 = *(void *)(a1 + 88);
          if (v445)
          {
            v446 = *(uint64_t (**)(uint64_t))(v445 + 160);
            if (v446)
            {
              int v447 = v446(a1);
              if (v447)
              {
                if (v447 != 21)
                {
                  uint64_t result = 0LL;
                  *(_DWORD *)(a1 + 24) = 19;
                  goto LABEL_2272;
                }

                uint64_t result = 0LL;
                *(_DWORD *)(a1 + 24) = 21;
                *(void *)(a1 + 32) = "on_chunk_header pause";
                *(void *)(a1 + 40) = a2;
                *(void *)(a1 + 56) = 10LL;
                return result;
              }
            }
          }

LABEL_1638:
          if (!*(void *)(a1 + 64))
          {
            *(_WORD *)(a1 + 82) |= 0x80u;
            goto LABEL_1939;
          }

LABEL_1639:
          if (a2 == a3) {
            return 9LL;
          }
          *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
          *(void *)(a1 + 16) = llhttp__on_body;
LABEL_1641:
          unint64_t v448 = *(void *)(a1 + 64);
          unint64_t v449 = v448 - (a3 - a2);
          if (v448 < a3 - a2) {
            unint64_t v449 = 0LL;
          }
          *(void *)(a1 + 64) = v449;
          if (a3 - a2 < v448) {
            return 8LL;
          }
          a2 += v448;
          uint64_t v450 = *(void *)(a1 + 8);
          *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
          uint64_t v451 = *(void *)(a1 + 88);
          if (v451)
          {
            v452 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v451 + 80);
            if (v452)
            {
              int v453 = v452(a1, v450, &a2[-v450]);
              if (v453)
              {
                int v464 = v453;
                if (v453 == -1)
                {
                  *(void *)(a1 + 32) = "Span callback error in on_body";
                  int v464 = 24;
                }

                uint64_t result = 0LL;
                *(_DWORD *)(a1 + 24) = v464;
                *(void *)(a1 + 40) = a2;
                *(void *)(a1 + 56) = 7LL;
                return result;
              }
            }
          }

LABEL_1647:
          if (a2 == a3) {
            return 7LL;
          }
          int v454 = *a2;
          if (v454 == 13)
          {
            ++a2;
LABEL_1654:
            if (a2 == a3) {
              return 6LL;
            }
            if (*a2 == 10)
            {
              ++a2;
LABEL_1658:
              int v455 = 0;
              uint64_t v456 = *(void *)(a1 + 88);
              if (v456)
              {
                int v455 = 0;
                v457 = *(uint64_t (**)(uint64_t))(v456 + 168);
                if (v457) {
                  int v455 = v457(a1);
                }
              }

              if (v455)
              {
                if (v455 == 21)
                {
                  uint64_t result = 0LL;
                  *(_DWORD *)(a1 + 24) = 21;
                  *(void *)(a1 + 32) = "on_chunk_complete pause";
                  *(void *)(a1 + 40) = a2;
                  *(void *)(a1 + 56) = 36LL;
                  return result;
                }

                goto LABEL_2157;
              }

LABEL_1662:
              *(void *)(a1 + 64) = 0LL;
LABEL_1663:
              if (a2 == a3) {
                return 35LL;
              }
              uint64_t v458 = 0LL;
              switch(*a2)
              {
                case '0':
                  break;
                case '1':
LABEL_2220:
                  uint64_t v458 = 1LL;
                  break;
                case '2':
LABEL_2221:
                  uint64_t v458 = 2LL;
                  break;
                case '3':
LABEL_2222:
                  uint64_t v458 = 3LL;
                  break;
                case '4':
LABEL_2223:
                  uint64_t v458 = 4LL;
                  break;
                case '5':
LABEL_2224:
                  uint64_t v458 = 5LL;
                  break;
                case '6':
LABEL_2225:
                  uint64_t v458 = 6LL;
                  break;
                case '7':
LABEL_2226:
                  uint64_t v458 = 7LL;
                  break;
                case '8':
LABEL_2227:
                  uint64_t v458 = 8LL;
                  break;
                case '9':
LABEL_2228:
                  uint64_t v458 = 9LL;
                  break;
                case 'A':
                case 'a':
LABEL_2214:
                  uint64_t v458 = 10LL;
                  break;
                case 'B':
                case 'b':
LABEL_2215:
                  uint64_t v458 = 11LL;
                  break;
                case 'C':
                case 'c':
LABEL_2216:
                  uint64_t v458 = 12LL;
                  break;
                case 'D':
                case 'd':
LABEL_2217:
                  uint64_t v458 = 13LL;
                  break;
                case 'E':
                case 'e':
LABEL_2218:
                  uint64_t v458 = 14LL;
                  break;
                case 'F':
                case 'f':
LABEL_2219:
                  uint64_t v458 = 15LL;
                  break;
                default:
LABEL_2209:
                  uint64_t result = 0LL;
                  *(_DWORD *)(a1 + 24) = 12;
                  BOOL v8 = "Invalid character in chunk size";
                  goto LABEL_2272;
              }

              while (2)
              {
                ++a2;
                unint64_t v613 = *(void *)(a1 + 64);
                if (!(v613 >> 60))
                {
                  *(void *)(a1 + 64) = v458 | (16 * v613);
LABEL_2212:
                  if (a2 != a3)
                  {
                    uint64_t v458 = 0LL;
                    switch(*a2)
                    {
                      case '0':
                        continue;
                      case '1':
                        goto LABEL_2220;
                      case '2':
                        goto LABEL_2221;
                      case '3':
                        goto LABEL_2222;
                      case '4':
                        goto LABEL_2223;
                      case '5':
                        goto LABEL_2224;
                      case '6':
                        goto LABEL_2225;
                      case '7':
                        goto LABEL_2226;
                      case '8':
                        goto LABEL_2227;
                      case '9':
                        goto LABEL_2228;
                      case 'A':
                      case 'a':
                        goto LABEL_2214;
                      case 'B':
                      case 'b':
                        goto LABEL_2215;
                      case 'C':
                      case 'c':
                        goto LABEL_2216;
                      case 'D':
                      case 'd':
                        goto LABEL_2217;
                      case 'E':
                      case 'e':
                        goto LABEL_2218;
                      case 'F':
                      case 'f':
                        goto LABEL_2219;
                      default:
                        goto LABEL_2203;
                    }
                  }

                  return 34LL;
                }

                break;
              }

              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = 12;
              BOOL v8 = "Chunk size overflow";
LABEL_2272:
              *(void *)(a1 + 32) = v8;
              *(void *)(a1 + 40) = a2;
              *(void *)(a1 + 56) = 0LL;
              return result;
            }
          }

          else if (v454 == 10)
          {
            ++a2;
            if ((*(_WORD *)(a1 + 78) & 0x100) == 0)
            {
              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = 25;
              BOOL v8 = "Missing expected CR after chunk data";
              goto LABEL_2272;
            }

            goto LABEL_1658;
          }

          if ((*(_WORD *)(a1 + 78) & 0x80) == 0)
          {
            uint64_t result = 0LL;
            *(_DWORD *)(a1 + 24) = 2;
            BOOL v8 = "Expected LF after chunk data";
            goto LABEL_2272;
          }

          goto LABEL_1658;
        }

LABEL_2196:
        ++a2;
LABEL_2197:
        while (2)
        {
          if (a2 == a3) {
            return 32LL;
          }
          int v612 = *a2;
          if (v612 == 32 || v612 == 13)
          {
            uint64_t result = 0LL;
            v258 = a2 + 1;
            *(_DWORD *)(a1 + 24) = 2;
            v260 = "Invalid character in chunk extensions";
            goto LABEL_2201;
          }

LABEL_2194:
          if (a2 == a3) {
            return 31LL;
          }
          *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
          *(void *)(a1 + 16) = llhttp__on_chunk_extension_name;
LABEL_1481:
          if (a2 == a3) {
            return 30LL;
          }
          uint64_t result = 30LL;
          while (llhttp__internal__run_lookup_table_7[*a2] == 3)
          {
            if (++a2 == a3) {
              return result;
            }
          }

          switch(*a2)
          {
            case 0xAu:
              uint64_t v363 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
              uint64_t v364 = *(void *)(a1 + 88);
              if (!v364) {
                goto LABEL_1490;
              }
              v365 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v364 + 56);
              if (!v365) {
                goto LABEL_1490;
              }
              int v366 = v365(a1, v363, &a2[-v363]);
              if (!v366) {
                goto LABEL_1490;
              }
              int v424 = v366;
              if (v366 == -1)
              {
                *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_name";
                int v424 = 24;
              }

              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = v424;
              *(void *)(a1 + 40) = a2;
              *(void *)(a1 + 56) = 13LL;
              return result;
            case 0xDu:
              uint64_t v370 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
              uint64_t v371 = *(void *)(a1 + 88);
              if (v371)
              {
                v372 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v371 + 56);
                if (v372)
                {
                  int v373 = v372(a1, v370, &a2[-v370]);
                  if (v373)
                  {
                    int v425 = v373;
                    if (v373 == -1)
                    {
                      *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_name";
                      int v425 = 24;
                    }

                    uint64_t result = 0LL;
                    *(_DWORD *)(a1 + 24) = v425;
                    *(void *)(a1 + 40) = a2 + 1;
                    *(void *)(a1 + 56) = 14LL;
                    return result;
                  }
                }
              }

              ++a2;
LABEL_1499:
              uint64_t v374 = *(void *)(a1 + 88);
              if (!v374) {
                goto LABEL_1631;
              }
              v375 = *(uint64_t (**)(uint64_t))(v374 + 144);
              if (!v375) {
                goto LABEL_1631;
              }
              int v376 = v375(a1);
              if (!v376) {
                goto LABEL_1631;
              }
              if (v376 != 21) {
                goto LABEL_1580;
              }
              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = 21;
              v377 = "on_chunk_extension_name pause";
              goto LABEL_1545;
            case 0x3Bu:
              uint64_t v378 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
              uint64_t v379 = *(void *)(a1 + 88);
              if (v379)
              {
                v380 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v379 + 56);
                if (v380)
                {
                  int v381 = v380(a1, v378, &a2[-v378]);
                  if (v381)
                  {
                    int v426 = v381;
                    if (v381 == -1)
                    {
                      *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_name";
                      int v426 = 24;
                    }

                    uint64_t result = 0LL;
                    *(_DWORD *)(a1 + 24) = v426;
                    *(void *)(a1 + 40) = a2 + 1;
                    *(void *)(a1 + 56) = 15LL;
                    return result;
                  }
                }
              }

              ++a2;
LABEL_1508:
              int v382 = 0;
              uint64_t v383 = *(void *)(a1 + 88);
              if (v383)
              {
                int v382 = 0;
                v384 = *(uint64_t (**)(uint64_t))(v383 + 144);
                if (v384) {
                  int v382 = v384(a1);
                }
              }

              if (!v382) {
                continue;
              }
              if (v382 != 21) {
                goto LABEL_1580;
              }
              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = 21;
              v385 = "on_chunk_extension_name pause";
              goto LABEL_1556;
            case 0x3Du:
              uint64_t v386 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
              uint64_t v387 = *(void *)(a1 + 88);
              if (v387)
              {
                v388 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v387 + 56);
                if (v388)
                {
                  int v389 = v388(a1, v386, &a2[-v386]);
                  if (v389)
                  {
                    int v427 = v389;
                    if (v389 == -1)
                    {
                      *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_name";
                      int v427 = 24;
                    }

                    uint64_t result = 0LL;
                    *(_DWORD *)(a1 + 24) = v427;
                    *(void *)(a1 + 40) = a2 + 1;
                    *(void *)(a1 + 56) = 28LL;
                    return result;
                  }
                }
              }

              ++a2;
LABEL_1518:
              if (a2 == a3) {
                return 28LL;
              }
              *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
              *(void *)(a1 + 16) = llhttp__on_chunk_extension_value;
              uint64_t v390 = *(void *)(a1 + 88);
              if (v390)
              {
                v391 = *(uint64_t (**)(uint64_t))(v390 + 144);
                if (v391)
                {
                  int v392 = v391(a1);
                  if (v392)
                  {
                    if (v392 == 21)
                    {
                      uint64_t result = 0LL;
                      *(_DWORD *)(a1 + 24) = 21;
                      *(void *)(a1 + 32) = "on_chunk_extension_name pause";
                      *(void *)(a1 + 40) = a2;
                      *(void *)(a1 + 56) = 27LL;
                      return result;
                    }

LABEL_1580:
                    uint64_t result = 0LL;
                    *(_DWORD *)(a1 + 24) = 34;
                    goto LABEL_2272;
                  }
                }
              }

LABEL_1522:
              if (a2 == a3) {
                return 27LL;
              }
              uint64_t result = 27LL;
              while (llhttp__internal__run_lookup_table_5[*a2] == 3)
              {
                if (++a2 == a3) {
                  return result;
                }
              }

              switch((unint64_t)*a2)
              {
                case 0xAuLL:
                case 0x10AuLL:
                  uint64_t v393 = *(void *)(a1 + 8);
                  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
                  uint64_t v394 = *(void *)(a1 + 88);
                  if (!v394) {
                    goto LABEL_1531;
                  }
                  v395 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v394 + 64);
                  if (!v395) {
                    goto LABEL_1531;
                  }
                  int v396 = v395(a1, v393, &a2[-v393]);
                  if (!v396) {
                    goto LABEL_1531;
                  }
                  int v428 = v396;
                  if (v396 == -1)
                  {
                    *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_value";
                    int v428 = 24;
                  }

                  uint64_t result = 0LL;
                  *(_DWORD *)(a1 + 24) = v428;
                  *(void *)(a1 + 40) = a2;
                  *(void *)(a1 + 56) = 17LL;
                  return result;
                case 0xDuLL:
                case 0x10DuLL:
                  uint64_t v400 = *(void *)(a1 + 8);
                  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
                  uint64_t v401 = *(void *)(a1 + 88);
                  if (v401)
                  {
                    v402 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v401 + 64);
                    if (v402)
                    {
                      int v403 = v402(a1, v400, &a2[-v400]);
                      if (v403)
                      {
                        int v429 = v403;
                        if (v403 == -1)
                        {
                          *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_value";
                          int v429 = 24;
                        }

                        uint64_t result = 0LL;
                        *(_DWORD *)(a1 + 24) = v429;
                        *(void *)(a1 + 40) = a2 + 1;
                        *(void *)(a1 + 56) = 18LL;
                        return result;
                      }
                    }
                  }

                  ++a2;
LABEL_1540:
                  uint64_t v404 = *(void *)(a1 + 88);
                  if (!v404) {
                    goto LABEL_1631;
                  }
                  v405 = *(uint64_t (**)(uint64_t))(v404 + 152);
                  if (!v405) {
                    goto LABEL_1631;
                  }
                  int v406 = v405(a1);
                  if (!v406) {
                    goto LABEL_1631;
                  }
                  if (v406 == 21)
                  {
                    uint64_t result = 0LL;
                    *(_DWORD *)(a1 + 24) = 21;
                    v377 = "on_chunk_extension_value pause";
LABEL_1545:
                    *(void *)(a1 + 32) = v377;
                    *(void *)(a1 + 40) = a2;
                    *(void *)(a1 + 56) = 11LL;
                    return result;
                  }

                  goto LABEL_1688;
                case 0x22uLL:
                case 0x13BuLL:
                  goto LABEL_1602;
                case 0x3BuLL:
                case 0x13DuLL:
                  uint64_t v407 = *(void *)(a1 + 8);
                  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
                  uint64_t v408 = *(void *)(a1 + 88);
                  if (v408)
                  {
                    v409 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v408 + 64);
                    if (v409)
                    {
                      int v410 = v409(a1, v407, &a2[-v407]);
                      if (v410)
                      {
                        int v430 = v410;
                        if (v410 == -1)
                        {
                          *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_value";
                          int v430 = 24;
                        }

                        uint64_t result = 0LL;
                        *(_DWORD *)(a1 + 24) = v430;
                        *(void *)(a1 + 40) = a2 + 1;
                        *(void *)(a1 + 56) = 25LL;
                        return result;
                      }
                    }
                  }

                  ++a2;
LABEL_1550:
                  int v411 = 0;
                  uint64_t v412 = *(void *)(a1 + 88);
                  if (v412)
                  {
                    int v411 = 0;
                    v413 = *(uint64_t (**)(uint64_t))(v412 + 152);
                    if (v413) {
                      int v411 = v413(a1);
                    }
                  }

                  if (!v411) {
                    continue;
                  }
                  if (v411 == 21)
                  {
                    uint64_t result = 0LL;
                    *(_DWORD *)(a1 + 24) = 21;
                    v385 = "on_chunk_extension_value pause";
LABEL_1556:
                    *(void *)(a1 + 32) = v385;
                    *(void *)(a1 + 40) = a2;
                    *(void *)(a1 + 56) = 32LL;
                    return result;
                  }

                  break;
                default:
                  uint64_t v419 = *(void *)(a1 + 8);
                  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
                  uint64_t v420 = *(void *)(a1 + 88);
                  if (!v420
                    || (v421 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v420 + 64)) == 0LL
                    || (int v422 = v421(a1, v419, &a2[-v419])) == 0)
                  {
                    ++a2;
                    goto LABEL_1572;
                  }

                  int v423 = v422;
                  if (v422 == -1)
                  {
                    *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_value";
                    int v423 = 24;
                  }

                  uint64_t result = 0LL;
                  *(_DWORD *)(a1 + 24) = v423;
                  *(void *)(a1 + 40) = a2 + 1;
                  *(void *)(a1 + 56) = 26LL;
                  return result;
              }

              break;
            default:
              uint64_t v414 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
              uint64_t v415 = *(void *)(a1 + 88);
              if (!v415
                || (v416 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v415 + 56)) == 0LL
                || (int v417 = v416(a1, v414, &a2[-v414])) == 0)
              {
                ++a2;
                goto LABEL_1570;
              }

              int v418 = v417;
              if (v417 == -1)
              {
                *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_name";
                int v418 = 24;
              }

              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = v418;
              *(void *)(a1 + 40) = a2 + 1;
              *(void *)(a1 + 56) = 29LL;
              return result;
          }

          break;
        }
      }

LABEL_1688:
      uint64_t result = 0LL;
      *(_DWORD *)(a1 + 24) = 35;
      goto LABEL_2272;
    case 25:
      goto LABEL_1550;
    case 26:
LABEL_1572:
      uint64_t result = 0LL;
      *(_DWORD *)(a1 + 24) = 2;
      BOOL v8 = "Invalid character in chunk extensions value";
      goto LABEL_2272;
    case 27:
      goto LABEL_1522;
    case 28:
      goto LABEL_1518;
    case 29:
LABEL_1570:
      uint64_t result = 0LL;
      *(_DWORD *)(a1 + 24) = 2;
      BOOL v8 = "Invalid character in chunk extensions name";
      goto LABEL_2272;
    case 30:
      goto LABEL_1481;
    case 31:
      goto LABEL_2194;
    case 32:
      goto LABEL_2197;
    case 33:
LABEL_2203:
      while (2)
      {
        if (a2 == a3) {
          return 33LL;
        }
        switch(*a2)
        {
          case 9u:
          case 0x20u:
            ++a2;
            if ((*(_WORD *)(a1 + 78) & 0x200) == 0) {
              goto LABEL_2209;
            }
            continue;
          case 0xAu:
            ++a2;
            if ((*(_WORD *)(a1 + 78) & 0x100) != 0) {
              goto LABEL_1631;
            }
            uint64_t result = 0LL;
            *(_DWORD *)(a1 + 24) = 25;
            BOOL v8 = "Missing expected CR after chunk size";
            break;
          case 0xBu:
          case 0xCu:
          case 0xEu:
          case 0xFu:
          case 0x10u:
          case 0x11u:
          case 0x12u:
          case 0x13u:
          case 0x14u:
          case 0x15u:
          case 0x16u:
          case 0x17u:
          case 0x18u:
          case 0x19u:
          case 0x1Au:
          case 0x1Bu:
          case 0x1Cu:
          case 0x1Du:
          case 0x1Eu:
          case 0x1Fu:
            goto LABEL_2209;
          case 0xDu:
            goto LABEL_1629;
          default:
            if (*a2 != 59) {
              goto LABEL_2209;
            }
            goto LABEL_2196;
        }

        goto LABEL_2272;
      }

    case 34:
      goto LABEL_2212;
    case 35:
      goto LABEL_1663;
    case 36:
      goto LABEL_1662;
    case 37:
      goto LABEL_2141;
    case 38:
LABEL_2139:
      if (a2 == a3) {
        return 38LL;
      }
      *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
      *(void *)(a1 + 16) = llhttp__on_body;
LABEL_2141:
      unint64_t v593 = *(void *)(a1 + 64);
      unint64_t v594 = v593 - (a3 - a2);
      if (v593 < a3 - a2) {
        unint64_t v594 = 0LL;
      }
      *(void *)(a1 + 64) = v594;
      if (a3 - a2 < v593) {
        return 37LL;
      }
      a2 += v593;
      uint64_t v595 = *(void *)(a1 + 8);
      *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
      uint64_t v596 = *(void *)(a1 + 88);
      if (!v596) {
        goto LABEL_1934;
      }
      v597 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v596 + 80);
      if (!v597) {
        goto LABEL_1934;
      }
      int v598 = v597(a1, v595, &a2[-v595]);
      if (!v598) {
        goto LABEL_1934;
      }
      int v599 = v598;
      if (v598 == -1)
      {
        *(void *)(a1 + 32) = "Span callback error in on_body";
        int v599 = 24;
      }

      uint64_t result = 0LL;
      *(_DWORD *)(a1 + 24) = v599;
      goto LABEL_2150;
    case 39:
      return result;
    case 40:
LABEL_2180:
      if (a2 == a3) {
        return 40LL;
      }
      *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
      *(void *)(a1 + 16) = llhttp__on_body;
      return 39LL;
    case 41:
      goto LABEL_2138;
    case 42:
      goto LABEL_2191;
    case 43:
      goto LABEL_2021;
    case 44:
      goto LABEL_2118;
    case 45:
      goto LABEL_2233;
    case 46:
      goto LABEL_2241;
    case 47:
      goto LABEL_2250;
    case 48:
LABEL_2264:
      while (2)
      {
        if (a2 == a3) {
          return 48LL;
        }
        int v623 = *a2;
        if (v623 == 13)
        {
          ++a2;
          if ((*(_WORD *)(a1 + 78) & 0x1000) == 0) {
            goto LABEL_1773;
          }
          continue;
        }

        break;
      }

      if (v623 == 10)
      {
        ++a2;
LABEL_2250:
        if (a2 == a3) {
          return 47LL;
        }
      }

      else if ((*(_WORD *)(a1 + 78) & 1) == 0)
      {
        goto LABEL_1773;
      }

      int v621 = *a2;
      if (v621 != 9 && v621 != 32)
      {
        __int16 v622 = 1;
        switch(*(_BYTE *)(a1 + 76))
        {
          case 2:
            uint64_t result = 0LL;
            *(_DWORD *)(a1 + 24) = 11;
            BOOL v8 = "Empty Content-Length";
            goto LABEL_2272;
          case 5:
            goto LABEL_2275;
          case 6:
            __int16 v622 = 2;
            goto LABEL_2275;
          case 7:
            __int16 v622 = 4;
LABEL_2275:
            *(_WORD *)(a1 + 82) |= v622;
            *(_BYTE *)(a1 + 76) = 1;
            break;
          case 8:
            *(_WORD *)(a1 + 82) |= 8u;
            break;
          default:
            break;
        }

LABEL_2241:
        if (a2 == a3) {
          return 46LL;
        }
        *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
        *(void *)(a1 + 16) = llhttp__on_header_value;
        uint64_t v617 = *(void *)(a1 + 88);
        if (v617)
        {
          v618 = *(uint64_t (**)(uint64_t, unsigned __int8 *, void))(v617 + 48);
          if (v618)
          {
            int v619 = v618(a1, a2, 0LL);
            if (v619)
            {
              int v620 = v619;
              if (v619 == -1)
              {
                *(void *)(a1 + 32) = "Span callback error in on_header_value";
                int v620 = 24;
              }

              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = v620;
              *(void *)(a1 + 40) = a2;
              *(void *)(a1 + 56) = 45LL;
              return result;
            }
          }
        }

        goto LABEL_2233;
      }

      ++a2;
      if ((*(_WORD *)(a1 + 78) & 1) != 0) {
        goto LABEL_2256;
      }
      goto LABEL_2271;
    case 49:
      goto LABEL_1776;
    case 50:
      goto LABEL_1770;
    case 51:
    case 52:
      goto LABEL_1769;
    case 53:
      goto LABEL_1761;
    case 54:
      goto LABEL_2271;
    case 55:
      goto LABEL_1747;
    case 56:
      goto LABEL_2354;
    case 57:
      goto LABEL_1890;
    case 58:
      goto LABEL_2317;
    case 59:
      goto LABEL_2337;
    case 60:
      goto LABEL_2297;
    case 61:
LABEL_2283:
      while (2)
      {
        uint64_t result = 61LL;
        if (a2 == a3) {
          return result;
        }
        while (2)
        {
          a4 = *a2;
          if (a4 <= 31)
          {
            if (a4 != 9) {
              goto LABEL_2354;
            }
            goto LABEL_2286;
          }

          if (a4 <= 98)
          {
            if (a4 != 32) {
              goto LABEL_2354;
            }
LABEL_2286:
            if (++a2 == a3) {
              return result;
            }
            continue;
          }

          break;
        }

        if (a4 != 99)
        {
          if (a4 != 107)
          {
            if (a4 != 117) {
              goto LABEL_2354;
            }
            ++a2;
LABEL_2297:
            if (a2 == a3) {
              return 60LL;
            }
            unsigned int v625 = *(_DWORD *)a1;
            while (1)
            {
              int v626 = *a2;
              int v627 = llparse_blob4[v625];
              if (v625 == 5)
              {
                a4 = 0;
                int v628 = 5;
              }

              else
              {
                int v628 = 0;
              }

              if (v626 != v627)
              {
                a4 = 2;
                int v628 = 5;
              }

              if (v628) {
                break;
              }
              if (v626 == v627) {
                ++v625;
              }
              if (++a2 == a3)
              {
                a4 = 1;
                a2 = a3;
                goto LABEL_2312;
              }
            }

            unsigned int v625 = 0;
LABEL_2312:
            *(_DWORD *)a1 = v625;
            char v629 = 7;
            if (a4)
            {
              if (a4 == 2) {
                goto LABEL_2354;
              }
              if (a4 != 1) {
                goto LABEL_2359;
              }
              return 60LL;
            }

            goto LABEL_1889;
          }

          ++a2;
LABEL_2337:
          if (a2 == a3) {
            return 59LL;
          }
          unsigned int v634 = *(_DWORD *)a1;
          while (1)
          {
            int v635 = *a2;
            int v636 = llparse_blob3[v634];
            if (v634 == 8)
            {
              a4 = 0;
              int v637 = 5;
            }

            else
            {
              int v637 = 0;
            }

            if (v635 != v636)
            {
              a4 = 2;
              int v637 = 5;
            }

            if (v637) {
              break;
            }
            if (v635 == v636) {
              ++v634;
            }
            if (++a2 == a3)
            {
              a4 = 1;
              a2 = a3;
              goto LABEL_2352;
            }
          }

          unsigned int v634 = 0;
LABEL_2352:
          *(_DWORD *)a1 = v634;
          char v629 = 5;
          if (a4)
          {
            if (a4 == 2) {
              goto LABEL_2354;
            }
            if (a4 != 1) {
              goto LABEL_2359;
            }
            return 59LL;
          }

LABEL_1889:
          ++a2;
          *(_BYTE *)(a1 + 76) = v629;
LABEL_1890:
          uint64_t result = 57LL;
          if (a2 == a3) {
            return result;
          }
          while (1)
          {
            int v532 = *a2;
            if (v532 != 32) {
              break;
            }
            if (++a2 == a3) {
              return result;
            }
          }

          if (v532 != 10 && v532 != 13)
          {
            if (v532 == 44)
            {
              ++a2;
              __int16 v534 = 1;
              switch(*(_BYTE *)(a1 + 76))
              {
                case 5:
                  goto LABEL_1903;
                case 6:
                  __int16 v534 = 2;
                  goto LABEL_1903;
                case 7:
                  __int16 v534 = 4;
LABEL_1903:
                  *(_WORD *)(a1 + 82) |= v534;
                  *(_BYTE *)(a1 + 76) = 1;
                  break;
                case 8:
                  *(_WORD *)(a1 + 82) |= 8u;
                  break;
                default:
                  continue;
              }

              continue;
            }

            *(_BYTE *)(a1 + 76) = 0;
LABEL_2354:
            if (a2 == a3) {
              return 56LL;
            }
            uint64_t result = 56LL;
            while (1)
            {
              int v624 = llhttp__internal__run_lookup_table_15[*a2];
              if (v624 != 1) {
                break;
              }
              if (++a2 == a3) {
                return result;
              }
            }

            if (v624 == 2)
            {
              ++a2;
              continue;
            }

            goto LABEL_1747;
          }

          while (1)
          {
LABEL_1747:
            if (a2 == a3) {
              return 55LL;
            }
            int v480 = *a2;
            if (v480 == 10) {
              break;
            }
            if (v480 != 13)
            {
              if ((*(_WORD *)(a1 + 78) & 1) == 0)
              {
                uint64_t v522 = *(void *)(a1 + 8);
                *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
                uint64_t v523 = *(void *)(a1 + 88);
                if (v523)
                {
                  v524 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v523 + 48);
                  if (v524)
                  {
                    int v525 = v524(a1, v522, &a2[-v522]);
                    if (v525)
                    {
                      int v526 = v525;
                      if (v525 == -1)
                      {
                        *(void *)(a1 + 32) = "Span callback error in on_header_value";
                        int v526 = 24;
                      }

                      uint64_t result = 0LL;
                      *(_DWORD *)(a1 + 24) = v526;
                      *(void *)(a1 + 40) = a2;
                      *(void *)(a1 + 56) = 54LL;
                      return result;
                    }
                  }
                }

LABEL_2271:
                uint64_t result = 0LL;
                *(_DWORD *)(a1 + 24) = 10;
                BOOL v8 = "Invalid header value char";
                goto LABEL_2272;
              }

LABEL_1761:
              uint64_t result = 53LL;
              if (a2 == a3) {
                return result;
              }
              while (1)
              {
                int v490 = *a2;
                if (v490 == 10) {
                  break;
                }
                if (v490 == 13) {
                  goto LABEL_1750;
                }
                if (++a2 == a3) {
                  return result;
                }
              }

              uint64_t v491 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
              uint64_t v492 = *(void *)(a1 + 88);
              if (v492)
              {
                v493 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v492 + 48);
                if (v493)
                {
                  int v494 = v493(a1, v491, &a2[-v491]);
                  if (v494)
                  {
                    int v527 = v494;
                    if (v494 == -1)
                    {
                      *(void *)(a1 + 32) = "Span callback error in on_header_value";
                      int v527 = 24;
                    }

                    uint64_t result = 0LL;
                    *(_DWORD *)(a1 + 24) = v527;
                    *(void *)(a1 + 40) = a2;
                    *(void *)(a1 + 56) = 52LL;
                    return result;
                  }
                }
              }

              goto LABEL_1769;
            }

LABEL_1750:
            uint64_t v481 = *(void *)(a1 + 8);
            *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
            uint64_t v482 = *(void *)(a1 + 88);
            if (v482)
            {
              v483 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v482 + 48);
              if (v483)
              {
                int v484 = v483(a1, v481, &a2[-v481]);
                if (v484)
                {
                  int v521 = v484;
                  if (v484 == -1)
                  {
                    *(void *)(a1 + 32) = "Span callback error in on_header_value";
                    int v521 = 24;
                  }

                  uint64_t result = 0LL;
                  *(_DWORD *)(a1 + 24) = v521;
                  *(void *)(a1 + 40) = a2 + 1;
                  *(void *)(a1 + 56) = 50LL;
                  return result;
                }
              }
            }

            ++a2;
            while (1)
            {
LABEL_1770:
              if (a2 == a3) {
                return 50LL;
              }
              int v495 = *a2;
              if (v495 != 13) {
                break;
              }
              ++a2;
              if ((*(_WORD *)(a1 + 78) & 0x1000) == 0) {
                goto LABEL_1773;
              }
            }

            if (v495 != 10)
            {
              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = 3;
              BOOL v8 = "Missing expected LF after header value";
              goto LABEL_2272;
            }

            ++a2;
LABEL_1776:
            if (a2 == a3) {
              return 49LL;
            }
            int v496 = *a2;
            if (v496 != 9 && v496 != 32)
            {
              __int16 v501 = 1;
              switch(*(_BYTE *)(a1 + 76))
              {
                case 5:
                  goto LABEL_1858;
                case 6:
                  __int16 v501 = 2;
                  goto LABEL_1858;
                case 7:
                  __int16 v501 = 4;
LABEL_1858:
                  *(_WORD *)(a1 + 82) |= v501;
                  *(_BYTE *)(a1 + 76) = 1;
                  break;
                case 8:
                  *(_WORD *)(a1 + 82) |= 8u;
                  break;
                default:
                  break;
              }

LABEL_2233:
              int v614 = 0;
              uint64_t v615 = *(void *)(a1 + 88);
              if (v615)
              {
                int v614 = 0;
                v616 = *(uint64_t (**)(uint64_t))(v615 + 136);
                if (v616) {
                  int v614 = v616(a1);
                }
              }

              if (v614)
              {
                if (v614 == 21)
                {
                  uint64_t result = 0LL;
                  *(_DWORD *)(a1 + 24) = 21;
                  *(void *)(a1 + 32) = "on_header_value_complete pause";
                  *(void *)(a1 + 40) = a2;
                  *(void *)(a1 + 56) = 90LL;
                  return result;
                }

                uint64_t result = 0LL;
                *(_DWORD *)(a1 + 24) = 29;
                goto LABEL_2272;
              }

LABEL_1939:
              while (2)
              {
                if (a2 == a3) {
                  return 90LL;
                }
                int v542 = *a2;
                switch(v542)
                {
                  case 10:
                    ++a2;
                    if ((*(_WORD *)(a1 + 78) & 0x100) == 0) {
                      goto LABEL_2191;
                    }
                    v558 = (_WORD *)(a1 + 82);
                    int v557 = *(unsigned __int16 *)(a1 + 82);
                    if ((v557 & 0x80) == 0)
                    {
                      if ((~v557 & 0x14) != 0)
                      {
                        BOOL v560 = *(_BYTE *)(a1 + 73) == 5;
                        goto LABEL_2130;
                      }

                      char v559 = 1;
                      if (*(_BYTE *)(a1 + 72) != 1)
                      {
                        BOOL v560 = *(unsigned __int16 *)(a1 + 84) == 101;
LABEL_2130:
                        char v559 = v560;
                      }

                      *(_BYTE *)(a1 + 80) = v559;
                      uint64_t v591 = *(void *)(a1 + 88);
                      if (v591)
                      {
                        v592 = *(unsigned int (**)(uint64_t))(v591 + 72);
                        if (v592)
                        {
                          switch(v592(a1))
                          {
                            case 0u:
                              break;
                            case 1u:
                              goto LABEL_2137;
                            case 2u:
LABEL_2136:
                              *(_BYTE *)(a1 + 80) = 1;
LABEL_2137:
                              *v558 |= 0x40u;
                              break;
                            case 0x15u:
LABEL_2193:
                              uint64_t result = 0LL;
                              *(_DWORD *)(a1 + 24) = 21;
                              *(void *)(a1 + 32) = "Paused by on_headers_complete";
                              *(void *)(a1 + 40) = a2;
                              *(void *)(a1 + 56) = 41LL;
                              return result;
                            default:
LABEL_2192:
                              uint64_t result = 0LL;
                              *(_DWORD *)(a1 + 24) = 17;
                              BOOL v8 = "User callback error";
                              goto LABEL_2272;
                          }
                        }
                      }

LABEL_2138:
                      switch(llhttp__after_headers_complete(a1))
                      {
                        case 1u:
                          uint64_t v604 = *(void *)(a1 + 88);
                          if (!v604) {
                            goto LABEL_1932;
                          }
                          v605 = *(uint64_t (**)(uint64_t))(v604 + 88);
                          if (!v605) {
                            goto LABEL_1932;
                          }
                          int v606 = v605(a1);
                          if (!v606) {
                            goto LABEL_1932;
                          }
                          if (v606 != 21) {
                            goto LABEL_2178;
                          }
                          uint64_t result = 0LL;
                          *(_DWORD *)(a1 + 24) = 21;
                          *(void *)(a1 + 32) = "on_message_complete pause";
                          *(void *)(a1 + 40) = a2;
                          *(void *)(a1 + 56) = 3LL;
                          return result;
                        case 2u:
                          goto LABEL_1662;
                        case 3u:
                          goto LABEL_2139;
                        case 4u:
                          *(_BYTE *)(a1 + 81) = 1;
                          goto LABEL_2180;
                        case 5u:
                          uint64_t result = 0LL;
                          *(_DWORD *)(a1 + 24) = 15;
                          goto LABEL_2272;
                        default:
                          int v600 = 0;
                          uint64_t v601 = *(void *)(a1 + 88);
                          if (v601)
                          {
                            int v600 = 0;
                            v602 = *(uint64_t (**)(uint64_t))(v601 + 88);
                            if (v602) {
                              int v600 = v602(a1);
                            }
                          }

                          if (!v600) {
                            goto LABEL_1911;
                          }
                          if (v600 != 21) {
                            goto LABEL_2178;
                          }
                          uint64_t result = 0LL;
                          *(_DWORD *)(a1 + 24) = 21;
                          v538 = "on_message_complete pause";
                          goto LABEL_1933;
                      }
                    }

                    break;
                  case 13:
                    ++a2;
                    while (1)
                    {
LABEL_2021:
                      if (a2 == a3) {
                        return 43LL;
                      }
                      int v561 = *a2;
                      if (v561 != 13) {
                        break;
                      }
                      ++a2;
                      if ((*(_WORD *)(a1 + 78) & 0x1000) == 0) {
                        goto LABEL_2024;
                      }
                    }

                    if (v561 == 10)
                    {
                      ++a2;
                    }

                    else if ((*(_WORD *)(a1 + 78) & 0x40) == 0)
                    {
LABEL_2024:
                      uint64_t result = 0LL;
                      *(_DWORD *)(a1 + 24) = 2;
                      BOOL v8 = "Expected LF after headers";
                      goto LABEL_2272;
                    }

                    v558 = (_WORD *)(a1 + 82);
                    int v562 = *(unsigned __int16 *)(a1 + 82);
                    if ((v562 & 0x80) == 0)
                    {
                      if ((~v562 & 0x14) == 0)
                      {
                        char v563 = 1;
                        if (*(_BYTE *)(a1 + 72) != 1)
                        {
                          BOOL v564 = *(unsigned __int16 *)(a1 + 84) == 101;
LABEL_2123:
                          char v563 = v564;
                        }

                        *(_BYTE *)(a1 + 80) = v563;
                        uint64_t v589 = *(void *)(a1 + 88);
                        if (v589)
                        {
                          v590 = *(unsigned int (**)(uint64_t))(v589 + 72);
                          if (v590)
                          {
                            switch(v590(a1))
                            {
                              case 0u:
                                goto LABEL_2138;
                              case 1u:
                                goto LABEL_2137;
                              case 2u:
                                goto LABEL_2136;
                              case 0x15u:
                                goto LABEL_2193;
                              default:
                                goto LABEL_2192;
                            }
                          }
                        }

                        goto LABEL_2138;
                      }

                      BOOL v564 = *(_BYTE *)(a1 + 73) == 5;
                      goto LABEL_2123;
                    }

                    break;
                  case 58:
                    goto LABEL_2165;
                  default:
LABEL_1943:
                    if (a2 == a3) {
                      return 89LL;
                    }
                    *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
                    *(void *)(a1 + 16) = llhttp__on_header_field;
LABEL_1945:
                    if (a2 != a3)
                    {
                      int v543 = *a2;
                      a4 = v543 - 99;
                      switch(a4)
                      {
                        case 0:
                          ++a2;
                          goto LABEL_1950;
                        case 13:
                          ++a2;
                          goto LABEL_2039;
                        case 17:
                          ++a2;
                          goto LABEL_2059;
                        case 18:
                          ++a2;
                          goto LABEL_2079;
                        default:
                          goto LABEL_1702;
                      }
                    }

                    return 88LL;
                }

                uint64_t v565 = *(void *)(a1 + 88);
                if (v565)
                {
                  v566 = *(uint64_t (**)(uint64_t))(v565 + 168);
                  if (v566)
                  {
                    int v567 = v566(a1);
                    if (v567)
                    {
                      if (v567 == 21)
                      {
                        uint64_t result = 0LL;
                        *(_DWORD *)(a1 + 24) = 21;
                        *(void *)(a1 + 32) = "on_chunk_complete pause";
LABEL_2150:
                        *(void *)(a1 + 40) = a2;
                        *(void *)(a1 + 56) = 5LL;
                        return result;
                      }

LABEL_2157:
                      uint64_t result = 0LL;
                      *(_DWORD *)(a1 + 24) = 20;
                      goto LABEL_2272;
                    }
                  }
                }

LABEL_1934:
                uint64_t v539 = *(void *)(a1 + 88);
                if (v539)
                {
                  v540 = *(uint64_t (**)(uint64_t))(v539 + 88);
                  if (v540)
                  {
                    int v541 = v540(a1);
                    if (v541)
                    {
                      if (v541 == 21)
                      {
                        uint64_t result = 0LL;
                        *(_DWORD *)(a1 + 24) = 21;
                        *(void *)(a1 + 32) = "on_message_complete pause";
                        *(void *)(a1 + 40) = a2;
                        *(void *)(a1 + 56) = 4LL;
                        return result;
                      }

LABEL_2178:
                      uint64_t result = 0LL;
                      *(_DWORD *)(a1 + 24) = 18;
                      goto LABEL_2272;
                    }
                  }
                }

LABEL_1931:
                if (*(_BYTE *)(a1 + 80) == 1)
                {
LABEL_1932:
                  uint64_t result = 0LL;
                  *(_DWORD *)(a1 + 24) = 22;
                  v538 = "Pause on CONNECT/Upgrade";
LABEL_1933:
                  *(void *)(a1 + 32) = v538;
                  *(void *)(a1 + 40) = a2;
                  *(void *)(a1 + 56) = 2LL;
                  return result;
                }

LABEL_1911:
                if (*(_BYTE *)(a1 + 74) && *(_BYTE *)(a1 + 75))
                {
                  __int16 v536 = *(_WORD *)(a1 + 82);
                  if ((v536 & 2) == 0) {
                    goto LABEL_1920;
                  }
LABEL_1916:
                  *(_WORD *)(a1 + 82) = 0;
                  goto LABEL_1917;
                }

                __int16 v536 = *(_WORD *)(a1 + 82);
                if ((v536 & 1) == 0) {
                  goto LABEL_1916;
                }
LABEL_1920:
                if (*(_BYTE *)(a1 + 72) == 1
                  || (int v537 = *(unsigned __int16 *)(a1 + 84), (v537 - 100) < 0x64)
                  || v537 == 204
                  || v537 == 304
                  || (v536 & 0x40) != 0)
                {
                  *(_WORD *)(a1 + 82) = 0;
                }

                else
                {
                  if ((v536 & 0x208) == 0x200) {
                    goto LABEL_1916;
                  }
                  *(_BYTE *)(a1 + 81) = 0;
                  *(_WORD *)(a1 + 82) = 0;
                  if ((v536 & 0x28) == 0)
                  {
LABEL_1917:
                    *(_BYTE *)(a1 + 81) = 0;
                    if ((*(_WORD *)(a1 + 78) & 4) == 0)
                    {
LABEL_1918:
                      uint64_t result = 1LL;
                      if (a2 != a3)
                      {
                        while (1)
                        {
                          int v535 = *a2;
                          if (v535 == 13 || v535 == 10)
                          {
                            ++a2;
                          }

                          else
                          {
                            ++a2;
                            if ((*(_WORD *)(a1 + 78) & 0x20) == 0)
                            {
                              uint64_t result = 0LL;
                              *(_DWORD *)(a1 + 24) = 5;
                              goto LABEL_2272;
                            }
                          }

                          if (a2 == a3) {
                            return result;
                          }
                        }
                      }

                      return result;
                    }

LABEL_1930:
                    *(_BYTE *)(a1 + 86) = 1;
                    *(_BYTE *)(a1 + 81) = 0;
LABEL_3:
                    uint64_t result = 238LL;
                    if (a2 == a3) {
                      return result;
                    }
                    while (1)
                    {
                      int v9 = *a2;
                      if (v9 != 13 && v9 != 10) {
                        break;
                      }
                      if (++a2 == a3) {
                        return result;
                      }
                    }

                    if (*(_BYTE *)(a1 + 86) == 1)
                    {
                      uint64_t v11 = *(void *)(a1 + 88);
                      if (v11)
                      {
                        BOOL v12 = *(uint64_t (**)(uint64_t))(v11 + 176);
                        if (v12)
                        {
                          int v13 = v12(a1);
                          if (v13)
                          {
                            if (v13 != 21)
                            {
                              uint64_t result = 0LL;
                              *(_DWORD *)(a1 + 24) = 31;
                              goto LABEL_2272;
                            }

                            uint64_t result = 0LL;
                            *(_DWORD *)(a1 + 24) = 21;
                            *(void *)(a1 + 32) = "on_reset pause";
                            *(void *)(a1 + 40) = a2;
                            *(void *)(a1 + 56) = 237LL;
                            return result;
                          }
                        }
                      }
                    }

LABEL_2359:
                        abort();
                      }

                      ++a2;
LABEL_80:
                      if (a2 == a3) {
                        return 231LL;
                      }
                      unsigned int v30 = *(_DWORD *)a1;
                      while (1)
                      {
                        int v31 = *a2;
                        int v32 = llparse_blob60[v30];
                        if (v30 == 2)
                        {
                          a4 = 0;
                          int v33 = 5;
                        }

                        else
                        {
                          int v33 = 0;
                        }

                        if (v31 != v32)
                        {
                          a4 = 2;
                          int v33 = 5;
                        }

                        if (v33) {
                          break;
                        }
                        if (v31 == v32) {
                          ++v30;
                        }
                        if (++a2 == a3)
                        {
                          a4 = 1;
                          a2 = a3;
                          goto LABEL_93;
                        }
                      }

                      unsigned int v30 = 0;
LABEL_93:
                      *(_DWORD *)a1 = v30;
                      if (a4)
                      {
                        if (a4 == 1) {
                          return 231LL;
                        }
                        goto LABEL_206;
                      }

                      ++a2;
                      uint64_t v34 = *(void *)(a1 + 8);
                      *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
                      uint64_t v35 = *(void *)(a1 + 88);
                      if (v35)
                      {
                        uint64_t v36 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v35 + 24);
                        if (v36)
                        {
                          int v37 = v36(a1, v34, &a2[-v34]);
                          if (v37)
                          {
                            int v347 = v37;
                            if (v37 == -1)
                            {
                              *(void *)(a1 + 32) = "Span callback error in on_method";
                              int v347 = 24;
                            }

                            uint64_t result = 0LL;
                            *(_DWORD *)(a1 + 24) = v347;
                            *(void *)(a1 + 40) = a2;
                            *(void *)(a1 + 56) = 230LL;
                            return result;
                          }
                        }
                      }

LABEL_2360:
                              ++a2;
                              if ((*(_WORD *)(a1 + 78) & 0x1000) == 0) {
                                goto LABEL_1773;
                              }
                            }

                            return 97LL;
                          }

                          if (v64 != 10 || (++a2, (*(_WORD *)(a1 + 78) & 0x100) == 0))
                          {
                            uint64_t result = 0LL;
                            *(_DWORD *)(a1 + 24) = 13;
                            BOOL v8 = "Invalid response status";
                            goto LABEL_2272;
                          }
                        }

LABEL_1270:
                        if (a2 == a3) {
                          return 91LL;
                        }
                        if (*a2 == 32)
                        {
                          ++a2;
                          if ((*(_WORD *)(a1 + 78) & 1) == 0)
                          {
                            uint64_t result = 0LL;
                            *(_DWORD *)(a1 + 24) = 30;
                            BOOL v8 = "Unexpected space after start line";
                            goto LABEL_2272;
                          }
                        }

                        break;
                      default:
                        uint64_t v353 = *(void *)(a1 + 8);
                        *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
                        uint64_t v354 = *(void *)(a1 + 88);
                        if (!v354) {
                          goto LABEL_1478;
                        }
                        v355 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v354 + 32);
                        if (!v355) {
                          goto LABEL_1478;
                        }
                        int v356 = v355(a1, v353, &a2[-v353]);
                        if (!v356) {
                          goto LABEL_1478;
                        }
                        int v357 = v356;
                        if (v356 == -1)
                        {
                          *(void *)(a1 + 32) = "Span callback error in on_version";
                          int v357 = 24;
                        }

                        uint64_t result = 0LL;
                        *(_DWORD *)(a1 + 24) = v357;
                        *(void *)(a1 + 40) = a2;
                        *(void *)(a1 + 56) = 220LL;
                        return result;
                    }

                    continue;
                  }
                }

                break;
              }

              *(void *)(a1 + 64) = 0LL;
              goto LABEL_1930;
            }

            if ((*(_WORD *)(a1 + 78) & 1) == 0)
            {
              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = 10;
              BOOL v8 = "Unexpected whitespace after header value";
              goto LABEL_2272;
            }

            if (*(_BYTE *)(a1 + 76) == 8) {
              *(_BYTE *)(a1 + 76) = 0;
            }
LABEL_1782:
            if (a2 == a3) {
              return 73LL;
            }
            *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
            *(void *)(a1 + 16) = llhttp__on_header_value;
            switch(*(_BYTE *)(a1 + 76))
            {
              case 1:
                goto LABEL_2283;
              case 2:
                if ((*(_WORD *)(a1 + 82) & 0x20) == 0) {
                  goto LABEL_1787;
                }
                if ((*(_WORD *)(a1 + 78) & 0x800) == 0)
                {
                  uint64_t result = 0LL;
                  *(_DWORD *)(a1 + 24) = 4;
                  BOOL v8 = "Duplicate Content-Length";
                  goto LABEL_2272;
                }

                *(void *)(a1 + 64) = 0LL;
LABEL_1787:
                if (a2 == a3) {
                  return 65LL;
                }
                v497 = a2;
                uint64_t result = 65LL;
                while (2)
                {
                  if (*v497 - 48 < 0xA)
                  {
                    a2 = v497 + 1;
                    unint64_t v498 = *(void *)(a1 + 64);
                    if (v498 <= 0x1999999999999999LL)
                    {
                      uint64_t v499 = (*v497 - 48);
                      uint64_t v500 = 10 * v498;
                      *(void *)(a1 + 64) = v500;
                      if (!__CFADD__(v499, v500))
                      {
                        *(void *)(a1 + 64) = v500 + v499;
                        ++v497;
                        if (a2 == a3) {
                          return result;
                        }
                        continue;
                      }

                      a2 = v497 + 1;
                    }

                    uint64_t v509 = *(void *)(a1 + 8);
                    *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
                    uint64_t v510 = *(void *)(a1 + 88);
                    if (!v510
                      || (v511 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v510 + 48)) == 0LL
                      || (int v512 = v511(a1, v509, &a2[-v509])) == 0)
                    {
LABEL_1823:
                      uint64_t result = 0LL;
                      *(_DWORD *)(a1 + 24) = 11;
                      BOOL v8 = "Content-Length overflow";
                      goto LABEL_2272;
                    }

                    int v513 = v512;
                    if (v512 == -1)
                    {
                      *(void *)(a1 + 32) = "Span callback error in on_header_value";
                      int v513 = 24;
                    }

                    uint64_t result = 0LL;
                    *(_DWORD *)(a1 + 24) = v513;
                    *(void *)(a1 + 40) = a2;
                    *(void *)(a1 + 56) = 62LL;
                    return result;
                  }

                  break;
                }

                a2 = v497;
LABEL_1798:
                uint64_t result = 64LL;
                if (a2 == a3) {
                  return result;
                }
                while (1)
                {
                  int v502 = *a2;
                  if (v502 != 32) {
                    break;
                  }
                  if (++a2 == a3) {
                    return result;
                  }
                }

                if (v502 != 10 && v502 != 13)
                {
                  uint64_t v504 = *(void *)(a1 + 8);
                  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
                  uint64_t v505 = *(void *)(a1 + 88);
                  if (!v505
                    || (v506 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v505 + 48)) == 0LL
                    || (int v507 = v506(a1, v504, &a2[-v504])) == 0)
                  {
LABEL_1815:
                    uint64_t result = 0LL;
                    *(_DWORD *)(a1 + 24) = 11;
                    BOOL v8 = "Invalid character in Content-Length";
                    goto LABEL_2272;
                  }

                  int v508 = v507;
                  if (v507 == -1)
                  {
                    *(void *)(a1 + 32) = "Span callback error in on_header_value";
                    int v508 = 24;
                  }

                  uint64_t result = 0LL;
                  *(_DWORD *)(a1 + 24) = v508;
                  *(void *)(a1 + 40) = a2;
                  *(void *)(a1 + 56) = 63LL;
                  return result;
                }

                *(_WORD *)(a1 + 82) |= 0x20u;
                break;
              case 3:
                __int16 v514 = *(_WORD *)(a1 + 82);
                if ((v514 & 8) != 0 && *(_BYTE *)(a1 + 72) == 1 && (*(_WORD *)(a1 + 78) & 8) == 0)
                {
                  *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
                  uint64_t v528 = *(void *)(a1 + 88);
                  if (v528)
                  {
                    v529 = *(uint64_t (**)(uint64_t, unsigned __int8 *, void))(v528 + 48);
                    if (v529)
                    {
                      int v530 = v529(a1, a2, 0LL);
                      if (v530)
                      {
                        int v531 = v530;
                        if (v530 == -1)
                        {
                          *(void *)(a1 + 32) = "Span callback error in on_header_value";
                          int v531 = 24;
                        }

                        uint64_t result = 0LL;
                        *(_DWORD *)(a1 + 24) = v531;
                        *(void *)(a1 + 40) = a2 + 1;
                        *(void *)(a1 + 56) = 66LL;
                        return result;
                      }
                    }
                  }

                  goto LABEL_1888;
                }

                *(_WORD *)(a1 + 82) = v514 & 0xFDF7 | 0x200;
LABEL_1828:
                while (2)
                {
                  if (a2 == a3) {
                    return 72LL;
                  }
                  unsigned int v515 = *(_DWORD *)a1;
                  v516 = &a2[6 - *(_DWORD *)a1];
                  int v517 = *(_DWORD *)a1 + (_DWORD)a3 - (_DWORD)a2;
                  while (2)
                  {
                    if ((*a2 | 0x20) == llparse_blob5[v515])
                    {
                      if (v515 != 6)
                      {
                        ++a2;
                        ++v515;
                        if (a2 == a3)
                        {
                          *(_DWORD *)a1 = v517;
                          return 72LL;
                        }

                        continue;
                      }

                      *(_DWORD *)a1 = 0;
                      a2 = v516 + 1;
LABEL_1728:
                      uint64_t result = 71LL;
                      if (a2 == a3) {
                        return result;
                      }
                      while (1)
                      {
                        int v473 = *a2;
                        if (v473 != 32) {
                          break;
                        }
                        if (++a2 == a3) {
                          return result;
                        }
                      }

                      if (v473 == 10 || v473 == 13)
                      {
                        *(_BYTE *)(a1 + 76) = 8;
                        goto LABEL_1747;
                      }

                      if (v473 == 44)
                      {
                        if (*(_BYTE *)(a1 + 72) == 1 && (*(_WORD *)(a1 + 78) & 8) == 0)
                        {
                          uint64_t v475 = *(void *)(a1 + 8);
                          *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
                          uint64_t v476 = *(void *)(a1 + 88);
                          if (v476)
                          {
                            v477 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v476 + 48);
                            if (v477)
                            {
                              int v478 = v477(a1, v475, &a2[-v475]);
                              if (v478)
                              {
                                int v479 = v478;
                                if (v478 == -1)
                                {
                                  *(void *)(a1 + 32) = "Span callback error in on_header_value";
                                  int v479 = 24;
                                }

                                uint64_t result = 0LL;
                                *(_DWORD *)(a1 + 24) = v479;
                                *(void *)(a1 + 40) = a2 + 1;
                                *(void *)(a1 + 56) = 67LL;
                                return result;
                              }
                            }
                          }

LABEL_1888:
                          ++a2;
LABEL_2:
                          uint64_t result = 0LL;
                          *(_DWORD *)(a1 + 24) = 15;
                          goto LABEL_2272;
                        }

                        goto LABEL_1828;
                      }
                    }

                    else
                    {
                      *(_DWORD *)a1 = 0;
                    }

                    break;
                  }

LABEL_1835:
                  if (a2 == a3) {
                    return 70LL;
                  }
                  uint64_t result = 70LL;
                  while (1)
                  {
                    int v518 = llhttp__internal__run_lookup_table_15[*a2];
                    if (v518 != 1) {
                      break;
                    }
                    if (++a2 == a3) {
                      return result;
                    }
                  }

                  if (v518 == 2)
                  {
                    ++a2;
LABEL_1842:
                    uint64_t result = 68LL;
                    if (a2 == a3) {
                      return result;
                    }
                    while (1)
                    {
                      int v519 = *a2;
                      if (v519 != 32 && v519 != 9) {
                        break;
                      }
                      if (++a2 == a3) {
                        return result;
                      }
                    }

                    continue;
                  }

                  break;
                }

LABEL_1851:
                *(_BYTE *)(a1 + 76) = 0;
LABEL_1852:
                if (a2 == a3) {
                  return 69LL;
                }
                uint64_t result = 69LL;
                while (llhttp__internal__run_lookup_table_14[*a2] == 1)
                {
                  if (++a2 == a3) {
                    return result;
                  }
                }

                continue;
              case 4:
                *(_WORD *)(a1 + 82) |= 0x10u;
                goto LABEL_1851;
              default:
                goto LABEL_1852;
            }
          }

          uint64_t v485 = *(void *)(a1 + 8);
          *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
          uint64_t v486 = *(void *)(a1 + 88);
          if (v486)
          {
            v487 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v486 + 48);
            if (v487)
            {
              int v488 = v487(a1, v485, &a2[-v485]);
              if (v488)
              {
                int v489 = v488;
                if (v488 == -1)
                {
                  *(void *)(a1 + 32) = "Span callback error in on_header_value";
                  int v489 = 24;
                }

                uint64_t result = 0LL;
                *(_DWORD *)(a1 + 24) = v489;
                *(void *)(a1 + 40) = a2;
                *(void *)(a1 + 56) = 51LL;
                return result;
              }
            }
          }

LABEL_1769:
          if ((*(_WORD *)(a1 + 78) & 0x100) == 0)
          {
            uint64_t result = 0LL;
            *(_DWORD *)(a1 + 24) = 25;
            BOOL v8 = "Missing expected CR after header value";
            goto LABEL_2272;
          }

          goto LABEL_1770;
        }

        break;
      }

      ++a2;
LABEL_2317:
      if (a2 != a3)
      {
        unsigned int v630 = *(_DWORD *)a1;
        while (1)
        {
          int v631 = *a2;
          int v632 = llparse_blob2[v630];
          if (v630 == 3)
          {
            a4 = 0;
            int v633 = 5;
          }

          else
          {
            int v633 = 0;
          }

          if (v631 != v632)
          {
            a4 = 2;
            int v633 = 5;
          }

          if (v633) {
            break;
          }
          if (v631 == v632) {
            ++v630;
          }
          if (++a2 == a3)
          {
            a4 = 1;
            a2 = a3;
            goto LABEL_2332;
          }
        }

        unsigned int v630 = 0;
LABEL_2332:
        *(_DWORD *)a1 = v630;
        char v629 = 6;
        if (!a4) {
          goto LABEL_1889;
        }
        if (a4 == 2) {
          goto LABEL_2354;
        }
        if (a4 != 1) {
          goto LABEL_2359;
        }
      }

      return 58LL;
    case 62:
      goto LABEL_1823;
    case 63:
      goto LABEL_1815;
    case 64:
      goto LABEL_1798;
    case 65:
      goto LABEL_1787;
    case 66:
    case 67:
      goto LABEL_2;
    case 68:
      goto LABEL_1842;
    case 69:
      goto LABEL_1852;
    case 70:
      goto LABEL_1835;
    case 71:
      goto LABEL_1728;
    case 72:
      goto LABEL_1828;
    case 73:
      goto LABEL_1782;
    case 74:
      goto LABEL_2256;
    case 75:
      goto LABEL_2109;
    case 76:
      goto LABEL_2106;
    case 77:
      goto LABEL_1711;
    case 78:
      goto LABEL_1708;
    case 79:
      goto LABEL_1703;
    case 80:
      goto LABEL_2099;
    case 81:
      goto LABEL_1976;
    case 82:
      goto LABEL_1996;
    case 83:
      goto LABEL_1970;
    case 84:
LABEL_1950:
      if (a2 == a3) {
        return 84LL;
      }
      unsigned int v544 = *(_DWORD *)a1;
      while (1)
      {
        int v545 = *a2;
        int v546 = llparse_blob0[v544];
        if (v544 == 1)
        {
          a4 = 0;
          int v547 = 5;
        }

        else
        {
          int v547 = 0;
        }

        if (v545 != v546)
        {
          a4 = 2;
          int v547 = 5;
        }

        if (v547) {
          break;
        }
        if (v545 == v546) {
          ++v544;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_1965;
        }
      }

      unsigned int v544 = 0;
LABEL_1965:
      *(_DWORD *)a1 = v544;
      if (a4)
      {
        if (a4 != 2)
        {
          if (a4 == 1) {
            return 84LL;
          }
          goto LABEL_2359;
        }

LABEL_1702:
        *(_BYTE *)(a1 + 76) = 0;
LABEL_1703:
        if (a2 == a3) {
          return 79LL;
        }
        uint64_t result = 79LL;
        while (llhttp__internal__run_lookup_table_16[*a2] == 1)
        {
          if (++a2 == a3) {
            return result;
          }
        }

LABEL_1708:
        if (a2 == a3) {
          return 78LL;
        }
        if (*a2 != 58)
        {
          if ((*(_WORD *)(a1 + 78) & 0x400) == 0)
          {
LABEL_2165:
            uint64_t result = 0LL;
            *(_DWORD *)(a1 + 24) = 10;
            BOOL v8 = "Invalid header token";
            goto LABEL_2272;
          }

LABEL_1711:
          uint64_t result = 77LL;
          if (a2 == a3) {
            return result;
          }
          while (1)
          {
            int v466 = *a2;
            if (v466 == 10 || v466 == 13) {
              break;
            }
            if (v466 == 58) {
              goto LABEL_2102;
            }
            if (++a2 == a3) {
              return result;
            }
          }

          uint64_t v468 = *(void *)(a1 + 8);
          *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
          uint64_t v469 = *(void *)(a1 + 88);
          if (v469)
          {
            v470 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v469 + 40);
            if (v470)
            {
              int v471 = v470(a1, v468, &a2[-v468]);
              if (v471)
              {
                int v472 = v471;
                if (v471 == -1)
                {
                  *(void *)(a1 + 32) = "Span callback error in on_header_field";
                  int v472 = 24;
                }

                uint64_t result = 0LL;
                *(_DWORD *)(a1 + 24) = v472;
                *(void *)(a1 + 40) = a2;
                goto LABEL_2169;
              }
            }
          }

          goto LABEL_2106;
        }

LABEL_2102:
        uint64_t v581 = *(void *)(a1 + 8);
        *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
        uint64_t v582 = *(void *)(a1 + 88);
        if (v582)
        {
          v583 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v582 + 40);
          if (v583)
          {
            int v584 = v583(a1, v581, &a2[-v581]);
            if (v584)
            {
              int v603 = v584;
              if (v584 == -1)
              {
                *(void *)(a1 + 32) = "Span callback error in on_header_field";
                int v603 = 24;
              }

              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = v603;
              *(void *)(a1 + 40) = a2 + 1;
LABEL_2169:
              *(void *)(a1 + 56) = 76LL;
              return result;
            }
          }
        }

        ++a2;
LABEL_2106:
        uint64_t v585 = *(void *)(a1 + 88);
        if (v585)
        {
          v586 = *(uint64_t (**)(uint64_t))(v585 + 128);
          if (v586)
          {
            int v587 = v586(a1);
            if (v587)
            {
              if (v587 == 21)
              {
                uint64_t result = 0LL;
                *(_DWORD *)(a1 + 24) = 21;
                *(void *)(a1 + 32) = "on_header_field_complete pause";
                *(void *)(a1 + 40) = a2;
                *(void *)(a1 + 56) = 75LL;
                return result;
              }

              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = 28;
              goto LABEL_2272;
            }
          }
        }

LABEL_2109:
        int v588 = *(unsigned __int8 *)(a1 + 76);
        if (v588 == 2)
        {
          if ((*(_WORD *)(a1 + 82) & 0x200) != 0 && (*(_WORD *)(a1 + 78) & 2) == 0)
          {
            uint64_t result = 0LL;
            *(_DWORD *)(a1 + 24) = 11;
            BOOL v8 = "Content-Length can't be present with Transfer-Encoding";
            goto LABEL_2272;
          }
        }

        else if (v588 == 3 && (*(_WORD *)(a1 + 82) & 0x20) != 0 && (*(_WORD *)(a1 + 78) & 2) == 0)
        {
          uint64_t result = 0LL;
          *(_DWORD *)(a1 + 24) = 15;
          BOOL v8 = "Transfer-Encoding can't be present with Content-Length";
          goto LABEL_2272;
        }

LABEL_2256:
        if (a2 != a3)
        {
          uint64_t result = 74LL;
          while (2)
          {
            switch(*a2)
            {
              case 9u:
              case 0x20u:
                if (++a2 == a3) {
                  return result;
                }
                continue;
              case 0xAu:
                ++a2;
                if ((*(_WORD *)(a1 + 78) & 0x100) != 0) {
                  goto LABEL_2250;
                }
                goto LABEL_2271;
              case 0xDu:
                ++a2;
                goto LABEL_2264;
              default:
                goto LABEL_1782;
            }
          }
        }

        return 74LL;
      }

      ++a2;
LABEL_1970:
      if (a2 == a3) {
        return 83LL;
      }
      a4 = *a2;
      if (a4 != 116)
      {
        if (a4 != 110) {
          goto LABEL_1702;
        }
        ++a2;
LABEL_1976:
        if (a2 == a3) {
          return 81LL;
        }
        unsigned int v548 = *(_DWORD *)a1;
        while (1)
        {
          int v549 = *a2;
          int v550 = llparse_blob1[v548];
          if (v548 == 5)
          {
            a4 = 0;
            int v551 = 5;
          }

          else
          {
            int v551 = 0;
          }

          if (v549 != v550)
          {
            a4 = 2;
            int v551 = 5;
          }

          if (v551) {
            break;
          }
          if (v549 == v550) {
            ++v548;
          }
          if (++a2 == a3)
          {
            a4 = 1;
            a2 = a3;
            goto LABEL_1991;
          }
        }

        unsigned int v548 = 0;
LABEL_1991:
        *(_DWORD *)a1 = v548;
        char v552 = 1;
        if (a4)
        {
          if (a4 == 2) {
            goto LABEL_1702;
          }
          if (a4 != 1) {
            goto LABEL_2359;
          }
          return 81LL;
        }

LABEL_2098:
        ++a2;
        *(_BYTE *)(a1 + 76) = v552;
        while (1)
        {
LABEL_2099:
          if (a2 == a3) {
            return 80LL;
          }
          int v580 = *a2;
          if (v580 != 32) {
            break;
          }
          if ((*(_WORD *)(a1 + 78) & 1) == 0)
          {
            uint64_t v607 = *(void *)(a1 + 8);
            *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
            uint64_t v608 = *(void *)(a1 + 88);
            if (v608)
            {
              v609 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v608 + 40);
              if (v609)
              {
                int v610 = v609(a1, v607, &a2[-v607]);
                if (v610)
                {
                  int v611 = v610;
                  if (v610 == -1)
                  {
                    *(void *)(a1 + 32) = "Span callback error in on_header_field";
                    int v611 = 24;
                  }

                  uint64_t result = 0LL;
                  *(_DWORD *)(a1 + 24) = v611;
                  *(void *)(a1 + 40) = a2 + 1;
                  *(void *)(a1 + 56) = 42LL;
                  return result;
                }
              }
            }

            ++a2;
LABEL_2191:
            uint64_t result = 0LL;
            *(_DWORD *)(a1 + 24) = 10;
            BOOL v8 = "Invalid header field char";
            goto LABEL_2272;
          }

LABEL_2118:
          uint64_t result = 44LL;
          if (a2 == a3) {
            return result;
          }
          while (*a2 == 32)
          {
            if (++a2 == a3) {
              return result;
            }
          }
        }

        if (v580 == 58) {
          goto LABEL_2102;
        }
        goto LABEL_1702;
      }

      ++a2;
LABEL_1996:
      if (a2 != a3)
      {
        unsigned int v553 = *(_DWORD *)a1;
        while (1)
        {
          int v554 = *a2;
          int v555 = llparse_blob9[v553];
          if (v553 == 9)
          {
            a4 = 0;
            int v556 = 5;
          }

          else
          {
            int v556 = 0;
          }

          if (v554 != v555)
          {
            a4 = 2;
            int v556 = 5;
          }

          if (v556) {
            break;
          }
          if (v554 == v555) {
            ++v553;
          }
          if (++a2 == a3)
          {
            a4 = 1;
            a2 = a3;
            goto LABEL_2011;
          }
        }

        unsigned int v553 = 0;
LABEL_2011:
        *(_DWORD *)a1 = v553;
        char v552 = 2;
        if (!a4) {
          goto LABEL_2098;
        }
        if (a4 == 2) {
          goto LABEL_1702;
        }
        if (a4 != 1) {
          goto LABEL_2359;
        }
      }

      return 82LL;
    case 85:
LABEL_2039:
      if (a2 == a3) {
        return 85LL;
      }
      unsigned int v568 = *(_DWORD *)a1;
      while (1)
      {
        int v569 = *a2;
        int v570 = llparse_blob10[v568];
        if (v568 == 14)
        {
          a4 = 0;
          int v571 = 5;
        }

        else
        {
          int v571 = 0;
        }

        if (v569 != v570)
        {
          a4 = 2;
          int v571 = 5;
        }

        if (v571) {
          break;
        }
        if (v569 == v570) {
          ++v568;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_2054;
        }
      }

      unsigned int v568 = 0;
LABEL_2054:
      *(_DWORD *)a1 = v568;
      char v552 = 1;
      if (!a4) {
        goto LABEL_2098;
      }
      if (a4 != 2)
      {
        if (a4 == 1) {
          return 85LL;
        }
        goto LABEL_2359;
      }

      goto LABEL_1702;
    case 86:
LABEL_2059:
      if (a2 == a3) {
        return 86LL;
      }
      unsigned int v572 = *(_DWORD *)a1;
      while (1)
      {
        int v573 = *a2;
        int v574 = llparse_blob11[v572];
        if (v572 == 15)
        {
          a4 = 0;
          int v575 = 5;
        }

        else
        {
          int v575 = 0;
        }

        if (v573 != v574)
        {
          a4 = 2;
          int v575 = 5;
        }

        if (v575) {
          break;
        }
        if (v573 == v574) {
          ++v572;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_2074;
        }
      }

      unsigned int v572 = 0;
LABEL_2074:
      *(_DWORD *)a1 = v572;
      char v552 = 3;
      if (!a4) {
        goto LABEL_2098;
      }
      if (a4 != 2)
      {
        if (a4 == 1) {
          return 86LL;
        }
        goto LABEL_2359;
      }

      goto LABEL_1702;
    case 87:
LABEL_2079:
      if (a2 == a3) {
        return 87LL;
      }
      unsigned int v576 = *(_DWORD *)a1;
      while (1)
      {
        int v577 = *a2;
        int v578 = llparse_blob12[v576];
        if (v576 == 5)
        {
          a4 = 0;
          int v579 = 5;
        }

        else
        {
          int v579 = 0;
        }

        if (v577 != v578)
        {
          a4 = 2;
          int v579 = 5;
        }

        if (v579) {
          break;
        }
        if (v577 == v578) {
          ++v576;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_2094;
        }
      }

      unsigned int v576 = 0;
LABEL_2094:
      *(_DWORD *)a1 = v576;
      char v552 = 4;
      if (!a4) {
        goto LABEL_2098;
      }
      if (a4 != 2)
      {
        if (a4 == 1) {
          return 87LL;
        }
        goto LABEL_2359;
      }

      goto LABEL_1702;
    case 88:
      goto LABEL_1945;
    case 89:
      goto LABEL_1943;
    case 90:
      goto LABEL_1939;
    case 91:
      goto LABEL_1270;
    case 92:
      goto LABEL_1138;
    case 93:
LABEL_1123:
      if (a2 == a3) {
        return 93LL;
      }
      int v266 = *a2;
      if (v266 == 9 || v266 == 12) {
        goto LABEL_1403;
      }
      ++a2;
      goto LABEL_1138;
    case 94:
      goto LABEL_1135;
    case 95:
LABEL_1132:
      if (a2 == a3) {
        return 95LL;
      }
      int v272 = *a2;
      if (v272 == 13)
      {
        ++a2;
LABEL_1135:
        if (a2 == a3) {
          return 94LL;
        }
        v258 = a2;
        if (*a2 == 10)
        {
          ++a2;
LABEL_1138:
          if (a2 == a3) {
            return 92LL;
          }
          int v273 = *a2;
          if (v273 != 9 && v273 != 12)
          {
            *(_WORD *)(a1 + 74) = 2304;
            uint64_t v275 = *(void *)(a1 + 88);
            if (!v275) {
              goto LABEL_1270;
            }
            v276 = *(uint64_t (**)(uint64_t))(v275 + 96);
            if (!v276) {
              goto LABEL_1270;
            }
            int v277 = v276(a1);
            if (!v277) {
              goto LABEL_1270;
            }
            if (v277 == 21)
            {
              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = 21;
              unsigned int v73 = "on_url_complete pause";
LABEL_1148:
              *(void *)(a1 + 32) = v73;
              *(void *)(a1 + 40) = a2;
              *(void *)(a1 + 56) = 91LL;
              return result;
            }

LABEL_1440:
            uint64_t result = 0LL;
            *(_DWORD *)(a1 + 24) = 26;
            goto LABEL_2272;
          }

          goto LABEL_1403;
        }
      }

      else
      {
        if (v272 == 9) {
          goto LABEL_1403;
        }
        v258 = a2;
        if (v272 == 12) {
          goto LABEL_1403;
        }
      }

      uint64_t result = 0LL;
      *(_DWORD *)(a1 + 24) = 7;
      v260 = "Expected CRLF";
      goto LABEL_2201;
    case 96:
      goto LABEL_1284;
    case 97:
      goto LABEL_2361;
    case 98:
      goto LABEL_1265;
    case 99:
      goto LABEL_1260;
    case 100:
      goto LABEL_1259;
    case 101:
      goto LABEL_1256;
    case 102:
    case 219:
      goto LABEL_1283;
    case 103:
    case 220:
LABEL_1478:
      uint64_t result = 0LL;
      *(_DWORD *)(a1 + 24) = 9;
      BOOL v8 = "Invalid minor version";
      goto LABEL_2272;
    case 104:
      goto LABEL_1234;
    case 105:
    case 222:
      goto LABEL_1417;
    case 106:
      goto LABEL_1231;
    case 107:
    case 224:
      goto LABEL_1410;
    case 108:
      goto LABEL_1228;
    case 109:
      goto LABEL_1226;
    case 110:
      goto LABEL_1193;
    case 111:
      goto LABEL_1211;
    case 112:
      goto LABEL_1174;
    case 113:
      goto LABEL_1166;
    case 114:
      goto LABEL_1158;
    case 115:
LABEL_1152:
      if (a2 == a3) {
        return 115LL;
      }
      int v282 = *a2;
      if (v282 == 9 || v282 == 12) {
        goto LABEL_1403;
      }
      ++a2;
LABEL_1158:
      if (a2 == a3) {
        return 114LL;
      }
      int v284 = *a2;
      if (v284 == 9 || v284 == 12) {
        goto LABEL_1403;
      }
      uint64_t v286 = *(void *)(a1 + 88);
      if (v286)
      {
        v287 = *(uint64_t (**)(uint64_t))(v286 + 96);
        if (v287)
        {
          int v288 = v287(a1);
          if (v288)
          {
            if (v288 == 21)
            {
              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = 21;
              *(void *)(a1 + 32) = "on_url_complete pause";
              *(void *)(a1 + 40) = a2;
              *(void *)(a1 + 56) = 113LL;
              return result;
            }

            goto LABEL_1440;
          }
        }
      }

LABEL_1226:
            if (a2 == a3) {
              return 109LL;
            }
            *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
            *(void *)(a1 + 16) = llhttp__on_version;
LABEL_1228:
            if (a2 == a3) {
              return 108LL;
            }
            unsigned int v303 = *a2 - 48;
            if (v303 >= 0xA)
            {
              uint64_t v334 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
              uint64_t v335 = *(void *)(a1 + 88);
              if (v335)
              {
                v336 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v335 + 32);
                if (v336)
                {
                  int v337 = v336(a1, v334, &a2[-v334]);
                  if (v337)
                  {
                    int v338 = v337;
                    if (v337 == -1)
                    {
                      *(void *)(a1 + 32) = "Span callback error in on_version";
                      int v338 = 24;
                    }

                    uint64_t result = 0LL;
                    *(_DWORD *)(a1 + 24) = v338;
                    *(void *)(a1 + 40) = a2;
                    *(void *)(a1 + 56) = 107LL;
                    return result;
                  }
                }
              }

LABEL_1410:
              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = 9;
              BOOL v8 = "Invalid major version";
              goto LABEL_2272;
            }

            ++a2;
            *(_BYTE *)(a1 + 74) = v303;
LABEL_1231:
            if (a2 == a3) {
              return 106LL;
            }
            if (*a2 != 46)
            {
              uint64_t v339 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
              uint64_t v340 = *(void *)(a1 + 88);
              if (v340)
              {
                v341 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v340 + 32);
                if (v341)
                {
                  int v342 = v341(a1, v339, &a2[-v339]);
                  if (v342)
                  {
                    int v343 = v342;
                    if (v342 == -1)
                    {
                      *(void *)(a1 + 32) = "Span callback error in on_version";
                      int v343 = 24;
                    }

                    uint64_t result = 0LL;
                    *(_DWORD *)(a1 + 24) = v343;
                    *(void *)(a1 + 40) = a2;
                    *(void *)(a1 + 56) = 105LL;
                    return result;
                  }
                }
              }

LABEL_1417:
              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = 9;
              BOOL v8 = "Expected dot";
              goto LABEL_2272;
            }

            ++a2;
LABEL_1234:
            if (a2 == a3) {
              return 104LL;
            }
            char v304 = 0;
            char v305 = 0;
            char v306 = 1;
            char v307 = 1;
            switch(*a2)
            {
              case '0':
                goto LABEL_1248;
              case '1':
                char v306 = 0;
                char v304 = 0;
                char v305 = 1;
                goto LABEL_1248;
              case '2':
                char v306 = 0;
                char v304 = 0;
                char v307 = 0;
                char v305 = 2;
                goto LABEL_1248;
              case '3':
                char v306 = 0;
                char v304 = 0;
                char v307 = 0;
                char v305 = 3;
                goto LABEL_1248;
              case '4':
                char v306 = 0;
                char v304 = 0;
                char v307 = 0;
                char v305 = 4;
                goto LABEL_1248;
              case '5':
                char v306 = 0;
                char v304 = 0;
                char v307 = 0;
                char v305 = 5;
                goto LABEL_1248;
              case '6':
                char v306 = 0;
                char v304 = 0;
                char v307 = 0;
                char v305 = 6;
                goto LABEL_1248;
              case '7':
                char v306 = 0;
                char v304 = 0;
                char v307 = 0;
                char v305 = 7;
                goto LABEL_1248;
              case '8':
                char v306 = 0;
                char v304 = 0;
                char v307 = 0;
                char v305 = 8;
                goto LABEL_1248;
              case '9':
                char v306 = 0;
                char v307 = 0;
                char v305 = 9;
                char v304 = 1;
LABEL_1248:
                ++a2;
                *(_BYTE *)(a1 + 75) = v305;
                if ((*(_WORD *)(a1 + 78) & 0x10) != 0) {
                  goto LABEL_1253;
                }
                int v308 = *(unsigned __int8 *)(a1 + 74);
                if (*(_BYTE *)(a1 + 74))
                {
                  if (v308 != 1)
                  {
                    if (v308 == 2 && (v306 & 1) != 0) {
                      goto LABEL_1253;
                    }
LABEL_1277:
                    uint64_t v318 = *(void *)(a1 + 8);
                    *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
                    uint64_t v319 = *(void *)(a1 + 88);
                    if (v319)
                    {
                      v320 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v319 + 32);
                      if (v320)
                      {
                        int v321 = v320(a1, v318, &a2[-v318]);
                        if (v321)
                        {
                          int v322 = v321;
                          if (v321 == -1)
                          {
                            *(void *)(a1 + 32) = "Span callback error in on_version";
                            int v322 = 24;
                          }

                          uint64_t result = 0LL;
                          *(_DWORD *)(a1 + 24) = v322;
                          *(void *)(a1 + 40) = a2;
                          *(void *)(a1 + 56) = 102LL;
                          return result;
                        }
                      }
                    }

LABEL_1283:
                    uint64_t result = 0LL;
                    *(_DWORD *)(a1 + 24) = 9;
                    BOOL v8 = "Invalid HTTP version";
                    goto LABEL_2272;
                  }

                  if ((v307 & 1) == 0) {
                    goto LABEL_1277;
                  }
                }

                else if ((v304 & 1) == 0)
                {
                  goto LABEL_1277;
                }

LABEL_1253:
                uint64_t v309 = *(void *)(a1 + 8);
                *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
                uint64_t v310 = *(void *)(a1 + 88);
                if (v310)
                {
                  v311 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v310 + 32);
                  if (v311)
                  {
                    int v312 = v311(a1, v309, &a2[-v309]);
                    if (v312)
                    {
                      int v346 = v312;
                      if (v312 == -1)
                      {
                        *(void *)(a1 + 32) = "Span callback error in on_version";
                        int v346 = 24;
                      }

                      uint64_t result = 0LL;
                      *(_DWORD *)(a1 + 24) = v346;
                      *(void *)(a1 + 40) = a2;
                      *(void *)(a1 + 56) = 101LL;
                      return result;
                    }
                  }
                }

LABEL_1256:
                uint64_t v313 = *(void *)(a1 + 88);
                if (v313)
                {
                  v314 = *(uint64_t (**)(uint64_t))(v313 + 120);
                  if (v314)
                  {
                    int v315 = v314(a1);
                    if (v315)
                    {
                      if (v315 == 21)
                      {
                        uint64_t result = 0LL;
                        *(_DWORD *)(a1 + 24) = 21;
                        *(void *)(a1 + 32) = "on_version_complete pause";
                        *(void *)(a1 + 40) = a2;
                        *(void *)(a1 + 56) = 100LL;
                        return result;
                      }

    if (!v505) {
      goto LABEL_1240;
    }
LABEL_1257:
    free(v505);
    goto LABEL_1240;
  }

  int v494 = (os_log_s *)__nwlog_obj();
  if (os_log_type_enabled(v494, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 136446466;
    unsigned int v553 = "nw_socket_set_common_sockopts";
    int v554 = 1024;
    *(_DWORD *)int v555 = v527;
    int v479 = "%{public}s setsockopt SO_MARK_KNOWN_TRACKER_NON_APP_INITIATED failed %{darwin.errno}d";
    goto LABEL_1238;
  }

LABEL_1259:
                a4 = *(unsigned __int8 *)(a1 + 73);
                if (a4 != 34)
                {
LABEL_1260:
                  if (a2 == a3) {
                    return 99LL;
                  }
                  int v316 = *a2;
                  if (v316 == 10)
                  {
                    if ((*(_WORD *)(a1 + 78) & 0x100) != 0) {
                      goto LABEL_1265;
                    }
                  }

                  else if (v316 == 13)
                  {
                    ++a2;
LABEL_1265:
                    if (a2 == a3) {
                      return 98LL;
                    }
                    int v317 = *a2;
                    if (v317 == 13) {
                      goto LABEL_2360;
                    }
                    if (v317 == 10)
                    {
                      ++a2;
                      goto LABEL_1270;
                    }

                    if ((*(_WORD *)(a1 + 78) & 0x40) != 0) {
                      goto LABEL_1270;
                    }
                    uint64_t result = 0LL;
                    int v344 = 2;
LABEL_1455:
                    *(_DWORD *)(a1 + 24) = v344;
                    BOOL v8 = "Expected CRLF after version";
                    goto LABEL_2272;
                  }

                  uint64_t result = 0LL;
                  int v344 = 9;
                  goto LABEL_1455;
                }

LABEL_1308:
      if (a4 != 2) {
        goto LABEL_2359;
      }
LABEL_1309:
      uint64_t result = 0LL;
      *(_DWORD *)(a1 + 24) = 8;
      BOOL v8 = "Expected HTTP/";
      goto LABEL_2272;
    case 116:
      goto LABEL_1114;
    case 117:
LABEL_1112:
      if (a2 == a3) {
        return 117LL;
      }
LABEL_1113:
      ++a2;
LABEL_1114:
      if (a2 == a3) {
        return 116LL;
      }
      uint64_t result = 116LL;
      do
      {
        if (llhttp__internal__run_lookup_table_21[*a2] != 5)
        {
          switch(*a2)
          {
            case 9u:
            case 0xCu:
              goto LABEL_1403;
            case 0xAu:
              goto LABEL_1120;
            case 0xDu:
              goto LABEL_1129;
            case 0x20u:
              goto LABEL_1149;
            default:
              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = 7;
              BOOL v8 = "Invalid char in url fragment start";
              goto LABEL_2272;
          }
        }

        ++a2;
      }

      while (a2 != a3);
      return result;
    case 118:
LABEL_1106:
      if (a2 == a3) {
        return 118LL;
      }
      uint64_t result = 118LL;
      do
      {
        if (llhttp__internal__run_lookup_table_22[*a2] != 5)
        {
          switch((unint64_t)*a2)
          {
            case 9uLL:
            case 0xCuLL:
            case 0x109uLL:
            case 0x10CuLL:
            case 0x209uLL:
            case 0x20CuLL:
              goto LABEL_1403;
            case 0xAuLL:
            case 0x121uLL:
            case 0x122uLL:
            case 0x124uLL:
            case 0x125uLL:
            case 0x126uLL:
            case 0x127uLL:
            case 0x128uLL:
            case 0x129uLL:
            case 0x12AuLL:
            case 0x12BuLL:
            case 0x12CuLL:
            case 0x12DuLL:
            case 0x12EuLL:
            case 0x12FuLL:
            case 0x130uLL:
            case 0x131uLL:
            case 0x132uLL:
            case 0x133uLL:
            case 0x134uLL:
            case 0x135uLL:
            case 0x136uLL:
            case 0x137uLL:
            case 0x138uLL:
            case 0x139uLL:
            case 0x13AuLL:
            case 0x13BuLL:
            case 0x13CuLL:
            case 0x13DuLL:
            case 0x13EuLL:
            case 0x140uLL:
            case 0x141uLL:
            case 0x142uLL:
            case 0x143uLL:
            case 0x144uLL:
            case 0x145uLL:
            case 0x146uLL:
            case 0x147uLL:
            case 0x148uLL:
            case 0x149uLL:
            case 0x14AuLL:
            case 0x14BuLL:
            case 0x14CuLL:
            case 0x14DuLL:
            case 0x14EuLL:
            case 0x14FuLL:
            case 0x150uLL:
            case 0x151uLL:
            case 0x152uLL:
            case 0x153uLL:
            case 0x154uLL:
            case 0x155uLL:
            case 0x156uLL:
            case 0x157uLL:
            case 0x158uLL:
            case 0x159uLL:
            case 0x15AuLL:
            case 0x15BuLL:
            case 0x15CuLL:
            case 0x15DuLL:
            case 0x15EuLL:
            case 0x15FuLL:
            case 0x160uLL:
            case 0x161uLL:
            case 0x162uLL:
            case 0x163uLL:
            case 0x164uLL:
            case 0x165uLL:
            case 0x166uLL:
            case 0x167uLL:
            case 0x168uLL:
            case 0x169uLL:
            case 0x16AuLL:
            case 0x16BuLL:
            case 0x16CuLL:
            case 0x16DuLL:
            case 0x16EuLL:
            case 0x16FuLL:
            case 0x170uLL:
            case 0x171uLL:
            case 0x172uLL:
            case 0x173uLL:
            case 0x174uLL:
            case 0x175uLL:
            case 0x176uLL:
            case 0x177uLL:
            case 0x178uLL:
            case 0x179uLL:
            case 0x17AuLL:
            case 0x17BuLL:
            case 0x17CuLL:
            case 0x17DuLL:
            case 0x17EuLL:
            case 0x20AuLL:
              goto LABEL_1120;
            case 0xDuLL:
            case 0x20DuLL:
              goto LABEL_1129;
            case 0x20uLL:
            case 0x220uLL:
              goto LABEL_1149;
            case 0x23uLL:
            case 0x22FuLL:
              goto LABEL_1112;
            default:
              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = 7;
              BOOL v8 = "Invalid char in url query";
              goto LABEL_2272;
          }
        }

        ++a2;
      }

      while (a2 != a3);
      return result;
    case 119:
      goto LABEL_1103;
    case 120:
      goto LABEL_1097;
    case 121:
      goto LABEL_1084;
    case 122:
LABEL_1082:
      if (a2 != a3) {
        goto LABEL_1096;
      }
      return 122LL;
    case 123:
LABEL_1095:
      if (a2 != a3) {
        goto LABEL_1096;
      }
      return 123LL;
    case 124:
LABEL_1091:
      if (a2 != a3)
      {
        switch((unint64_t)*a2)
        {
          case 9uLL:
          case 0xCuLL:
          case 0x109uLL:
          case 0x10AuLL:
          case 0x10CuLL:
          case 0x10DuLL:
          case 0x120uLL:
          case 0x209uLL:
          case 0x20AuLL:
          case 0x20CuLL:
          case 0x20DuLL:
          case 0x220uLL:
            goto LABEL_1403;
          case 0xAuLL:
          case 0x13AuLL:
          case 0x22AuLL:
          case 0x22FuLL:
            goto LABEL_1120;
          case 0xDuLL:
          case 0x141uLL:
          case 0x142uLL:
          case 0x143uLL:
          case 0x144uLL:
          case 0x145uLL:
          case 0x146uLL:
          case 0x147uLL:
          case 0x148uLL:
          case 0x149uLL:
          case 0x14AuLL:
          case 0x14BuLL:
          case 0x14CuLL:
          case 0x14DuLL:
          case 0x14EuLL:
          case 0x14FuLL:
          case 0x150uLL:
          case 0x151uLL:
          case 0x152uLL:
          case 0x153uLL:
          case 0x154uLL:
          case 0x155uLL:
          case 0x156uLL:
          case 0x157uLL:
          case 0x158uLL:
          case 0x159uLL:
          case 0x15AuLL:
          case 0x161uLL:
          case 0x162uLL:
          case 0x163uLL:
          case 0x164uLL:
          case 0x165uLL:
          case 0x166uLL:
          case 0x167uLL:
          case 0x168uLL:
          case 0x169uLL:
          case 0x16AuLL:
          case 0x16BuLL:
          case 0x16CuLL:
          case 0x16DuLL:
          case 0x16EuLL:
          case 0x16FuLL:
          case 0x170uLL:
          case 0x171uLL:
          case 0x172uLL:
          case 0x173uLL:
          case 0x174uLL:
          case 0x175uLL:
          case 0x176uLL:
          case 0x177uLL:
          case 0x178uLL:
          case 0x179uLL:
          case 0x17AuLL:
          case 0x241uLL:
          case 0x242uLL:
          case 0x243uLL:
          case 0x244uLL:
          case 0x245uLL:
          case 0x246uLL:
          case 0x247uLL:
          case 0x248uLL:
          case 0x249uLL:
          case 0x24AuLL:
          case 0x24BuLL:
          case 0x24CuLL:
          case 0x24DuLL:
          case 0x24EuLL:
          case 0x24FuLL:
          case 0x250uLL:
          case 0x251uLL:
          case 0x252uLL:
          case 0x253uLL:
          case 0x254uLL:
          case 0x255uLL:
          case 0x256uLL:
          case 0x257uLL:
          case 0x258uLL:
          case 0x259uLL:
          case 0x25AuLL:
          case 0x261uLL:
          case 0x262uLL:
          case 0x263uLL:
          case 0x264uLL:
          case 0x265uLL:
          case 0x266uLL:
          case 0x267uLL:
          case 0x268uLL:
          case 0x269uLL:
          case 0x26AuLL:
          case 0x26BuLL:
          case 0x26CuLL:
          case 0x26DuLL:
          case 0x26EuLL:
          case 0x26FuLL:
          case 0x270uLL:
          case 0x271uLL:
          case 0x272uLL:
          case 0x273uLL:
          case 0x274uLL:
          case 0x275uLL:
          case 0x276uLL:
          case 0x277uLL:
          case 0x278uLL:
          case 0x279uLL:
          case 0x27AuLL:
            goto LABEL_1129;
          case 0x20uLL:
            goto LABEL_1149;
          case 0x21uLL:
          case 0x24uLL:
          case 0x25uLL:
          case 0x26uLL:
          case 0x27uLL:
          case 0x28uLL:
          case 0x29uLL:
          case 0x2AuLL:
          case 0x2BuLL:
          case 0x2CuLL:
          case 0x2DuLL:
          case 0x2EuLL:
          case 0x30uLL:
          case 0x31uLL:
          case 0x32uLL:
          case 0x33uLL:
          case 0x34uLL:
          case 0x35uLL:
          case 0x36uLL:
          case 0x37uLL:
          case 0x38uLL:
          case 0x39uLL:
          case 0x3AuLL:
          case 0x3BuLL:
          case 0x3DuLL:
          case 0x41uLL:
          case 0x42uLL:
          case 0x43uLL:
          case 0x44uLL:
          case 0x45uLL:
          case 0x46uLL:
          case 0x47uLL:
          case 0x48uLL:
          case 0x49uLL:
          case 0x4AuLL:
          case 0x4BuLL:
          case 0x4CuLL:
          case 0x4DuLL:
          case 0x4EuLL:
          case 0x4FuLL:
          case 0x50uLL:
          case 0x51uLL:
          case 0x52uLL:
          case 0x53uLL:
          case 0x54uLL:
          case 0x55uLL:
          case 0x56uLL:
          case 0x57uLL:
          case 0x58uLL:
          case 0x59uLL:
          case 0x5AuLL:
          case 0x5BuLL:
          case 0x5DuLL:
          case 0x5FuLL:
          case 0x61uLL:
          case 0x62uLL:
          case 0x63uLL:
          case 0x64uLL:
          case 0x65uLL:
          case 0x66uLL:
          case 0x67uLL:
          case 0x68uLL:
          case 0x69uLL:
          case 0x6AuLL:
          case 0x6BuLL:
          case 0x6CuLL:
          case 0x6DuLL:
          case 0x6EuLL:
          case 0x6FuLL:
          case 0x70uLL:
          case 0x71uLL:
          case 0x72uLL:
          case 0x73uLL:
          case 0x74uLL:
          case 0x75uLL:
          case 0x76uLL:
          case 0x77uLL:
          case 0x78uLL:
          case 0x79uLL:
          case 0x7AuLL:
          case 0x7EuLL:
            if (++a2 == a3) {
              return 125LL;
            }
            goto LABEL_1077;
          case 0x2FuLL:
            goto LABEL_1095;
          case 0x3FuLL:
            goto LABEL_1105;
          case 0x40uLL:
            uint64_t result = 0LL;
            v258 = a2 + 1;
            *(_DWORD *)(a1 + 24) = 7;
            v260 = "Double @ in url";
            goto LABEL_2201;
          default:
            goto LABEL_1239;
        }
      }

      return 124LL;
    case 125:
      goto LABEL_1076;
    case 126:
      goto LABEL_1073;
    case 127:
      goto LABEL_1070;
    case 128:
      goto LABEL_1068;
    case 129:
      goto LABEL_1061;
    case 130:
      goto LABEL_1058;
    case 131:
      goto LABEL_1056;
    case 132:
      goto LABEL_1051;
    case 133:
      goto LABEL_1048;
    case 134:
      goto LABEL_1043;
    case 135:
      goto LABEL_1035;
    case 136:
      goto LABEL_1032;
    case 137:
    case 228:
      goto LABEL_1029;
    case 138:
      goto LABEL_76;
    case 139:
      goto LABEL_110;
    case 140:
LABEL_72:
      if (a2 == a3) {
        return 140LL;
      }
      a4 = *a2;
      if (a4 != 78)
      {
        if (a4 == 67)
        {
          ++a2;
LABEL_76:
          if (a2 == a3) {
            return 138LL;
          }
          if (*a2 == 76)
          {
            ++a2;
            LOBYTE(a4) = 19;
            goto LABEL_1026;
          }
        }

LABEL_1301:
        uint64_t result = 0LL;
        *(_DWORD *)(a1 + 24) = 6;
        BOOL v8 = "Invalid method encountered";
        goto LABEL_2272;
      }

      ++a2;
LABEL_110:
      if (a2 == a3) {
        return 139LL;
      }
      unsigned int v43 = *(_DWORD *)a1;
      while (1)
      {
        int v44 = *a2;
        int v45 = llparse_blob17[v43];
        if (v43 == 5)
        {
          a4 = 0;
          int v46 = 5;
        }

        else
        {
          int v46 = 0;
        }

        if (v44 != v45)
        {
          a4 = 2;
          int v46 = 5;
        }

        if (v46) {
          break;
        }
        if (v44 == v45) {
          ++v43;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_123;
        }
      }

      unsigned int v43 = 0;
LABEL_123:
      *(_DWORD *)a1 = v43;
      if (!a4)
      {
        ++a2;
        LOBYTE(a4) = 36;
        goto LABEL_1026;
      }

      if (a4 == 1) {
        return 139LL;
      }
      goto LABEL_1300;
    case 141:
LABEL_212:
      if (a2 == a3) {
        return 141LL;
      }
      unsigned int v83 = *(_DWORD *)a1;
      while (1)
      {
        int v84 = *a2;
        int v85 = llparse_blob18[v83];
        if (v83 == 2)
        {
          a4 = 0;
          int v86 = 5;
        }

        else
        {
          int v86 = 0;
        }

        if (v84 != v85)
        {
          a4 = 2;
          int v86 = 5;
        }

        if (v86) {
          break;
        }
        if (v84 == v85) {
          ++v83;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_225;
        }
      }

      unsigned int v83 = 0;
LABEL_225:
      *(_DWORD *)a1 = v83;
      if (!a4)
      {
        ++a2;
        LOBYTE(a4) = 16;
        goto LABEL_1026;
      }

      if (a4 == 1) {
        return 141LL;
      }
      goto LABEL_1300;
    case 142:
      goto LABEL_234;
    case 143:
      goto LABEL_254;
    case 144:
      goto LABEL_270;
    case 145:
      goto LABEL_250;
    case 146:
LABEL_230:
      if (a2 == a3) {
        return 146LL;
      }
      a4 = *a2;
      if (a4 == 79)
      {
        ++a2;
LABEL_250:
        if (a2 == a3) {
          return 145LL;
        }
        a4 = *a2;
        if (a4 == 80)
        {
          ++a2;
LABEL_270:
          if (a2 == a3) {
            return 144LL;
          }
          if (*a2 == 89)
          {
            ++a2;
            LOBYTE(a4) = 8;
            goto LABEL_1026;
          }

          goto LABEL_1301;
        }

        if (a4 != 78) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_254:
        if (a2 == a3) {
          return 143LL;
        }
        unsigned int v91 = *(_DWORD *)a1;
        while (1)
        {
          int v92 = *a2;
          int v93 = llparse_blob20[v91];
          if (v91 == 3)
          {
            a4 = 0;
            int v94 = 5;
          }

          else
          {
            int v94 = 0;
          }

          if (v92 != v93)
          {
            a4 = 2;
            int v94 = 5;
          }

          if (v94) {
            break;
          }
          if (v92 == v93) {
            ++v91;
          }
          if (++a2 == a3)
          {
            a4 = 1;
            a2 = a3;
            goto LABEL_267;
          }
        }

        unsigned int v91 = 0;
LABEL_267:
        *(_DWORD *)a1 = v91;
        if (!a4)
        {
          ++a2;
          LOBYTE(a4) = 5;
          goto LABEL_1026;
        }

        if (a4 == 1) {
          return 143LL;
        }
      }

      else
      {
        if (a4 != 72) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_234:
        if (a2 == a3) {
          return 142LL;
        }
        unsigned int v87 = *(_DWORD *)a1;
        while (1)
        {
          int v88 = *a2;
          int v89 = llparse_blob19[v87];
          if (v87 == 5)
          {
            a4 = 0;
            int v90 = 5;
          }

          else
          {
            int v90 = 0;
          }

          if (v88 != v89)
          {
            a4 = 2;
            int v90 = 5;
          }

          if (v90) {
            break;
          }
          if (v88 == v89) {
            ++v87;
          }
          if (++a2 == a3)
          {
            a4 = 1;
            a2 = a3;
            goto LABEL_247;
          }
        }

        unsigned int v87 = 0;
LABEL_247:
        *(_DWORD *)a1 = v87;
        if (!a4)
        {
          ++a2;
          LOBYTE(a4) = 22;
          goto LABEL_1026;
        }

        if (a4 == 1) {
          return 142LL;
        }
      }

      goto LABEL_1300;
    case 147:
      goto LABEL_285;
    case 148:
      goto LABEL_301;
    case 149:
      goto LABEL_281;
    case 150:
LABEL_278:
      if (a2 == a3) {
        return 150LL;
      }
      if (*a2 != 69) {
        goto LABEL_1301;
      }
      ++a2;
LABEL_281:
      if (a2 == a3) {
        return 149LL;
      }
      a4 = *a2;
      if (a4 == 83)
      {
        ++a2;
LABEL_301:
        if (a2 == a3) {
          return 148LL;
        }
        unsigned int v99 = *(_DWORD *)a1;
        while (1)
        {
          int v100 = *a2;
          int v101 = llparse_blob22[v99];
          if (v99 == 4)
          {
            a4 = 0;
            int v102 = 5;
          }

          else
          {
            int v102 = 0;
          }

          if (v100 != v101)
          {
            a4 = 2;
            int v102 = 5;
          }

          if (v102) {
            break;
          }
          if (v100 == v101) {
            ++v99;
          }
          if (++a2 == a3)
          {
            a4 = 1;
            a2 = a3;
            goto LABEL_314;
          }
        }

        unsigned int v99 = 0;
LABEL_314:
        *(_DWORD *)a1 = v99;
        if (!a4)
        {
          ++a2;
          LOBYTE(a4) = 35;
          goto LABEL_1026;
        }

        if (a4 == 1) {
          return 148LL;
        }
      }

      else
      {
        if (a4 != 76) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_285:
        if (a2 == a3) {
          return 147LL;
        }
        unsigned int v95 = *(_DWORD *)a1;
        while (1)
        {
          int v96 = *a2;
          int v97 = llparse_blob21[v95];
          if (v95 == 2)
          {
            a4 = 0;
            int v98 = 5;
          }

          else
          {
            int v98 = 0;
          }

          if (v96 != v97)
          {
            a4 = 2;
            int v98 = 5;
          }

          if (v98) {
            break;
          }
          if (v96 == v97) {
            ++v95;
          }
          if (++a2 == a3)
          {
            a4 = 1;
            a2 = a3;
            goto LABEL_298;
          }
        }

        unsigned int v95 = 0;
LABEL_298:
        *(_DWORD *)a1 = v95;
        if (!a4)
        {
          ++a2;
          goto LABEL_1026;
        }

        if (a4 == 1) {
          return 147LL;
        }
      }

      goto LABEL_1300;
    case 151:
LABEL_321:
      if (a2 == a3) {
        return 151LL;
      }
      unsigned int v103 = *(_DWORD *)a1;
      while (1)
      {
        int v104 = *a2;
        int v105 = llparse_blob23[v103];
        if (v103 == 3)
        {
          a4 = 0;
          int v106 = 5;
        }

        else
        {
          int v106 = 0;
        }

        if (v104 != v105)
        {
          a4 = 2;
          int v106 = 5;
        }

        if (v106) {
          break;
        }
        if (v104 == v105) {
          ++v103;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_334;
        }
      }

      unsigned int v103 = 0;
LABEL_334:
      *(_DWORD *)a1 = v103;
      if (!a4)
      {
        ++a2;
        LOBYTE(a4) = 45;
        goto LABEL_1026;
      }

      if (a4 == 1) {
        return 151LL;
      }
      goto LABEL_1300;
    case 152:
      goto LABEL_357;
    case 153:
      goto LABEL_354;
    case 154:
LABEL_339:
      if (a2 == a3) {
        return 154LL;
      }
      unsigned int v107 = *(_DWORD *)a1;
      while (1)
      {
        int v108 = *a2;
        int v109 = llparse_blob24[v107];
        if (v107 == 1)
        {
          a4 = 0;
          int v110 = 5;
        }

        else
        {
          int v110 = 0;
        }

        if (v108 != v109)
        {
          a4 = 2;
          int v110 = 5;
        }

        if (v110) {
          break;
        }
        if (v108 == v109) {
          ++v107;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_352;
        }
      }

      unsigned int v107 = 0;
LABEL_352:
      *(_DWORD *)a1 = v107;
      if (a4)
      {
        if (a4 == 1) {
          return 154LL;
        }
LABEL_1300:
        if (a4 != 2) {
          goto LABEL_2359;
        }
        goto LABEL_1301;
      }

      ++a2;
LABEL_354:
      if (a2 == a3) {
        return 153LL;
      }
      a4 = 1;
      if (*a2 == 95)
      {
        ++a2;
LABEL_357:
        if (a2 == a3) {
          return 152LL;
        }
        unsigned int v111 = *(_DWORD *)a1;
        while (1)
        {
          int v112 = *a2;
          int v113 = llparse_blob25[v111];
          if (v111 == 8)
          {
            a4 = 0;
            int v114 = 5;
          }

          else
          {
            int v114 = 0;
          }

          if (v112 != v113)
          {
            a4 = 2;
            int v114 = 5;
          }

          if (v114) {
            break;
          }
          if (v112 == v113) {
            ++v111;
          }
          if (++a2 == a3)
          {
            a4 = 1;
            a2 = a3;
            goto LABEL_370;
          }
        }

        unsigned int v111 = 0;
LABEL_370:
        *(_DWORD *)a1 = v111;
        if (!a4)
        {
          ++a2;
          LOBYTE(a4) = 41;
          goto LABEL_1026;
        }

        if (a4 == 1) {
          return 152LL;
        }
        goto LABEL_1300;
      }

LABEL_1026:
      *(_BYTE *)(a1 + 73) = a4;
      uint64_t v244 = *(void *)(a1 + 8);
      *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
      uint64_t v245 = *(void *)(a1 + 88);
      if (v245)
      {
        v246 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v245 + 24);
        if (v246)
        {
          int v247 = v246(a1, v244, &a2[-v244]);
          if (v247)
          {
            int v251 = v247;
            if (v247 == -1)
            {
              *(void *)(a1 + 32) = "Span callback error in on_method";
              int v251 = 24;
            }

            uint64_t result = 0LL;
            *(_DWORD *)(a1 + 24) = v251;
            *(void *)(a1 + 40) = a2;
            *(void *)(a1 + 56) = 137LL;
            return result;
          }
        }
      }

LABEL_1029:
      uint64_t v248 = *(void *)(a1 + 88);
      if (v248)
      {
        v249 = *(uint64_t (**)(uint64_t))(v248 + 112);
        if (v249)
        {
          int v250 = v249(a1);
          if (v250)
          {
            if (v250 != 21)
            {
              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = 32;
              goto LABEL_2272;
            }

            uint64_t result = 0LL;
            *(_DWORD *)(a1 + 24) = 21;
            *(void *)(a1 + 32) = "on_method_complete pause";
            *(void *)(a1 + 40) = a2;
            *(void *)(a1 + 56) = 136LL;
            return result;
          }
        }
      }

LABEL_1032:
      if (a2 == a3) {
        return 136LL;
      }
      if (*a2 != 32)
      {
        uint64_t result = 0LL;
        *(_DWORD *)(a1 + 24) = 6;
        BOOL v8 = "Expected space after method";
        goto LABEL_2272;
      }

      ++a2;
LABEL_1035:
      uint64_t result = 135LL;
      if (a2 != a3)
      {
        while (*a2 == 32)
        {
          if (++a2 == a3) {
            return result;
          }
        }

        if (*(_BYTE *)(a1 + 73) == 5)
        {
LABEL_1043:
          if (a2 == a3) {
            return 134LL;
          }
          int v252 = *a2;
          if (v252 == 9 || v252 == 12) {
            goto LABEL_1403;
          }
LABEL_1048:
          if (a2 == a3) {
            return 133LL;
          }
          *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
          *(void *)(a1 + 16) = llhttp__on_url;
LABEL_1077:
          uint64_t result = 125LL;
          while (llhttp__internal__run_lookup_table_25[*a2] == 5)
          {
            if (++a2 == a3) {
              return result;
            }
          }

          switch((unint64_t)*a2)
          {
            case 9uLL:
            case 0xCuLL:
            case 0x109uLL:
            case 0x10AuLL:
            case 0x10CuLL:
            case 0x10DuLL:
            case 0x120uLL:
            case 0x209uLL:
            case 0x20AuLL:
            case 0x20CuLL:
            case 0x20DuLL:
            case 0x220uLL:
              goto LABEL_1403;
            case 0xAuLL:
            case 0x13AuLL:
            case 0x22AuLL:
            case 0x22FuLL:
LABEL_1120:
              uint64_t v262 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
              uint64_t v263 = *(void *)(a1 + 88);
              if (!v263) {
                goto LABEL_1123;
              }
              v264 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v263 + 8);
              if (!v264) {
                goto LABEL_1123;
              }
              int v265 = v264(a1, v262, &a2[-v262]);
              if (!v265) {
                goto LABEL_1123;
              }
              int v348 = v265;
              if (v265 == -1)
              {
                *(void *)(a1 + 32) = "Span callback error in on_url";
                int v348 = 24;
              }

              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = v348;
              *(void *)(a1 + 40) = a2;
              *(void *)(a1 + 56) = 93LL;
              break;
            case 0xDuLL:
            case 0x141uLL:
            case 0x142uLL:
            case 0x143uLL:
            case 0x144uLL:
            case 0x145uLL:
            case 0x146uLL:
            case 0x147uLL:
            case 0x148uLL:
            case 0x149uLL:
            case 0x14AuLL:
            case 0x14BuLL:
            case 0x14CuLL:
            case 0x14DuLL:
            case 0x14EuLL:
            case 0x14FuLL:
            case 0x150uLL:
            case 0x151uLL:
            case 0x152uLL:
            case 0x153uLL:
            case 0x154uLL:
            case 0x155uLL:
            case 0x156uLL:
            case 0x157uLL:
            case 0x158uLL:
            case 0x159uLL:
            case 0x15AuLL:
            case 0x161uLL:
            case 0x162uLL:
            case 0x163uLL:
            case 0x164uLL:
            case 0x165uLL:
            case 0x166uLL:
            case 0x167uLL:
            case 0x168uLL:
            case 0x169uLL:
            case 0x16AuLL:
            case 0x16BuLL:
            case 0x16CuLL:
            case 0x16DuLL:
            case 0x16EuLL:
            case 0x16FuLL:
            case 0x170uLL:
            case 0x171uLL:
            case 0x172uLL:
            case 0x173uLL:
            case 0x174uLL:
            case 0x175uLL:
            case 0x176uLL:
            case 0x177uLL:
            case 0x178uLL:
            case 0x179uLL:
            case 0x17AuLL:
            case 0x241uLL:
            case 0x242uLL:
            case 0x243uLL:
            case 0x244uLL:
            case 0x245uLL:
            case 0x246uLL:
            case 0x247uLL:
            case 0x248uLL:
            case 0x249uLL:
            case 0x24AuLL:
            case 0x24BuLL:
            case 0x24CuLL:
            case 0x24DuLL:
            case 0x24EuLL:
            case 0x24FuLL:
            case 0x250uLL:
            case 0x251uLL:
            case 0x252uLL:
            case 0x253uLL:
            case 0x254uLL:
            case 0x255uLL:
            case 0x256uLL:
            case 0x257uLL:
            case 0x258uLL:
            case 0x259uLL:
            case 0x25AuLL:
            case 0x261uLL:
            case 0x262uLL:
            case 0x263uLL:
            case 0x264uLL:
            case 0x265uLL:
            case 0x266uLL:
            case 0x267uLL:
            case 0x268uLL:
            case 0x269uLL:
            case 0x26AuLL:
            case 0x26BuLL:
            case 0x26CuLL:
            case 0x26DuLL:
            case 0x26EuLL:
            case 0x26FuLL:
            case 0x270uLL:
            case 0x271uLL:
            case 0x272uLL:
            case 0x273uLL:
            case 0x274uLL:
            case 0x275uLL:
            case 0x276uLL:
            case 0x277uLL:
            case 0x278uLL:
            case 0x279uLL:
            case 0x27AuLL:
LABEL_1129:
              uint64_t v268 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
              uint64_t v269 = *(void *)(a1 + 88);
              if (!v269) {
                goto LABEL_1132;
              }
              v270 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v269 + 8);
              if (!v270) {
                goto LABEL_1132;
              }
              int v271 = v270(a1, v268, &a2[-v268]);
              if (!v271) {
                goto LABEL_1132;
              }
              int v349 = v271;
              if (v271 == -1)
              {
                *(void *)(a1 + 32) = "Span callback error in on_url";
                int v349 = 24;
              }

              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = v349;
              *(void *)(a1 + 40) = a2;
              *(void *)(a1 + 56) = 95LL;
              break;
            case 0x20uLL:
LABEL_1149:
              uint64_t v278 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
              uint64_t v279 = *(void *)(a1 + 88);
              if (!v279) {
                goto LABEL_1152;
              }
              v280 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v279 + 8);
              if (!v280) {
                goto LABEL_1152;
              }
              int v281 = v280(a1, v278, &a2[-v278]);
              if (!v281) {
                goto LABEL_1152;
              }
              int v350 = v281;
              if (v281 == -1)
              {
                *(void *)(a1 + 32) = "Span callback error in on_url";
                int v350 = 24;
              }

              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = v350;
              *(void *)(a1 + 40) = a2;
              *(void *)(a1 + 56) = 115LL;
              break;
            case 0x2FuLL:
              goto LABEL_1082;
            case 0x3FuLL:
LABEL_1105:
              ++a2;
              goto LABEL_1106;
            case 0x40uLL:
              ++a2;
              goto LABEL_1091;
            default:
LABEL_1239:
              uint64_t result = 0LL;
              *(_DWORD *)(a1 + 24) = 7;
              BOOL v8 = "Unexpected char in url server";
              goto LABEL_2272;
          }

          return result;
        }

LABEL_1051:
        if (a2 == a3) {
          return 132LL;
        }
        int v254 = *a2;
        if (v254 == 9 || v254 == 12) {
          goto LABEL_1403;
        }
LABEL_1056:
        if (a2 == a3) {
          return 131LL;
        }
        *(void *)(a1 + _Block_object_dispose(va, 8) = a2;
        *(void *)(a1 + 16) = llhttp__on_url;
LABEL_1058:
        if (a2 == a3) {
          return 130LL;
        }
        int v256 = llhttp__internal__run_lookup_table_27[*a2];
        if (v256 == 2)
        {
LABEL_1084:
          if (a2 == a3) {
            return 121LL;
          }
LABEL_1096:
          ++a2;
LABEL_1097:
          if (a2 == a3) {
            return 120LL;
          }
          uint64_t result = 120LL;
          while (1)
          {
            int v261 = llhttp__internal__run_lookup_table_23[*a2];
            if (v261 != 2) {
              break;
            }
            if (++a2 == a3) {
              return result;
            }
          }

          if (v261 != 1)
          {
LABEL_1103:
            if (a2 != a3)
            {
              switch(*a2)
              {
                case 9u:
                case 0xCu:
                  goto LABEL_1403;
                case 0xAu:
                  goto LABEL_1120;
                case 0xDu:
                  goto LABEL_1129;
                case 0x20u:
                  goto LABEL_1149;
                case 0x23u:
                  goto LABEL_1113;
                case 0x3Fu:
                  goto LABEL_1105;
                default:
                  uint64_t result = 0LL;
                  *(_DWORD *)(a1 + 24) = 7;
                  BOOL v8 = "Invalid char in url path";
                  goto LABEL_2272;
              }
            }

            return 119LL;
          }

          goto LABEL_1403;
        }

        if (v256 != 3)
        {
          if (v256 != 1)
          {
            uint64_t result = 0LL;
            *(_DWORD *)(a1 + 24) = 7;
            BOOL v8 = "Unexpected start char in url";
            goto LABEL_2272;
          }

          goto LABEL_1403;
        }

LABEL_1061:
        if (a2 == a3) {
          return 129LL;
        }
        uint64_t result = 129LL;
        while (1)
        {
          int v257 = llhttp__internal__run_lookup_table_26[*a2];
          if (v257 != 3) {
            break;
          }
          if (++a2 == a3) {
            return result;
          }
        }

        if (v257 == 1)
        {
LABEL_1403:
          uint64_t result = 0LL;
          *(_DWORD *)(a1 + 24) = 7;
          *(void *)(a1 + 32) = "Invalid characters in url";
          *(void *)(a1 + 40) = a2 + 1;
          *(void *)(a1 + 56) = 0LL;
          return result;
        }

        if (v257 != 2)
        {
          uint64_t result = 0LL;
          *(_DWORD *)(a1 + 24) = 7;
          BOOL v8 = "Unexpected char in url schema";
          goto LABEL_2272;
        }

LABEL_1068:
        if (a2 == a3) {
          return 128LL;
        }
        ++a2;
LABEL_1070:
        if (a2 == a3) {
          return 127LL;
        }
        v258 = a2;
        unsigned int v259 = *a2;
        if (v259 == 47)
        {
          ++a2;
LABEL_1073:
          if (a2 == a3) {
            return 126LL;
          }
          v258 = a2;
          if (*a2 == 47)
          {
            ++a2;
LABEL_1076:
            if (a2 == a3) {
              return 125LL;
            }
            goto LABEL_1077;
          }
        }

        else if (v259 <= 0x20 && ((1LL << v259) & 0x100003600LL) != 0)
        {
          goto LABEL_1403;
        }

        uint64_t result = 0LL;
        *(_DWORD *)(a1 + 24) = 7;
        v260 = "Unexpected char in url schema";
        goto LABEL_2201;
      }

      return result;
    case 155:
LABEL_377:
      if (a2 == a3) {
        return 155LL;
      }
      unsigned int v115 = *(_DWORD *)a1;
      while (1)
      {
        int v116 = *a2;
        int v117 = llparse_blob26[v115];
        if (v115 == 2)
        {
          a4 = 0;
          int v118 = 5;
        }

        else
        {
          int v118 = 0;
        }

        if (v116 != v117)
        {
          a4 = 2;
          int v118 = 5;
        }

        if (v118) {
          break;
        }
        if (v116 == v117) {
          ++v115;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_390;
        }
      }

      unsigned int v115 = 0;
LABEL_390:
      *(_DWORD *)a1 = v115;
      if (!a4)
      {
        ++a2;
        LOBYTE(a4) = 2;
        goto LABEL_1026;
      }

      if (a4 == 1) {
        return 155LL;
      }
      goto LABEL_1300;
    case 156:
      goto LABEL_399;
    case 157:
      goto LABEL_415;
    case 158:
LABEL_395:
      if (a2 == a3) {
        return 158LL;
      }
      a4 = *a2;
      if (a4 == 79)
      {
        ++a2;
LABEL_415:
        if (a2 == a3) {
          return 157LL;
        }
        unsigned int v123 = *(_DWORD *)a1;
        while (1)
        {
          int v124 = *a2;
          int v125 = llparse_blob28[v123];
          if (v123 == 1)
          {
            a4 = 0;
            int v126 = 5;
          }

          else
          {
            int v126 = 0;
          }

          if (v124 != v125)
          {
            a4 = 2;
            int v126 = 5;
          }

          if (v126) {
            break;
          }
          if (v124 == v125) {
            ++v123;
          }
          if (++a2 == a3)
          {
            a4 = 1;
            a2 = a3;
            goto LABEL_428;
          }
        }

        unsigned int v123 = 0;
LABEL_428:
        *(_DWORD *)a1 = v123;
        if (!a4)
        {
          ++a2;
          LOBYTE(a4) = 9;
          goto LABEL_1026;
        }

        if (a4 == 1) {
          return 157LL;
        }
      }

      else
      {
        if (a4 != 73) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_399:
        if (a2 == a3) {
          return 156LL;
        }
        unsigned int v119 = *(_DWORD *)a1;
        while (1)
        {
          int v120 = *a2;
          int v121 = llparse_blob27[v119];
          if (v119 == 1)
          {
            a4 = 0;
            int v122 = 5;
          }

          else
          {
            int v122 = 0;
          }

          if (v120 != v121)
          {
            a4 = 2;
            int v122 = 5;
          }

          if (v122) {
            break;
          }
          if (v120 == v121) {
            ++v119;
          }
          if (++a2 == a3)
          {
            a4 = 1;
            a2 = a3;
            goto LABEL_412;
          }
        }

        unsigned int v119 = 0;
LABEL_412:
        *(_DWORD *)a1 = v119;
        if (!a4)
        {
          ++a2;
          LOBYTE(a4) = 31;
          goto LABEL_1026;
        }

        if (a4 == 1) {
          return 156LL;
        }
      }

      goto LABEL_1300;
    case 159:
LABEL_438:
      if (a2 == a3) {
        return 159LL;
      }
      unsigned int v127 = *(_DWORD *)a1;
      while (1)
      {
        int v128 = *a2;
        int v129 = llparse_blob29[v127];
        if (v127 == 5)
        {
          a4 = 0;
          int v130 = 5;
        }

        else
        {
          int v130 = 0;
        }

        if (v128 != v129)
        {
          a4 = 2;
          int v130 = 5;
        }

        if (v130) {
          break;
        }
        if (v128 == v129) {
          ++v127;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_451;
        }
      }

      unsigned int v127 = 0;
LABEL_451:
      *(_DWORD *)a1 = v127;
      if (!a4)
      {
        ++a2;
        LOBYTE(a4) = 24;
        goto LABEL_1026;
      }

      if (a4 == 1) {
        return 159LL;
      }
      goto LABEL_1300;
    case 160:
LABEL_454:
      if (a2 == a3) {
        return 160LL;
      }
      unsigned int v131 = *(_DWORD *)a1;
      while (1)
      {
        int v132 = *a2;
        int v133 = llparse_blob30[v131];
        if (v131 == 2)
        {
          a4 = 0;
          int v134 = 5;
        }

        else
        {
          int v134 = 0;
        }

        if (v132 != v133)
        {
          a4 = 2;
          int v134 = 5;
        }

        if (v134) {
          break;
        }
        if (v132 == v133) {
          ++v131;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_467;
        }
      }

      unsigned int v131 = 0;
LABEL_467:
      *(_DWORD *)a1 = v131;
      if (!a4)
      {
        ++a2;
        LOBYTE(a4) = 23;
        goto LABEL_1026;
      }

      if (a4 == 1) {
        return 160LL;
      }
      goto LABEL_1300;
    case 161:
      goto LABEL_474;
    case 162:
      goto LABEL_494;
    case 163:
      goto LABEL_510;
    case 164:
      goto LABEL_490;
    case 165:
LABEL_470:
      if (a2 == a3) {
        return 165LL;
      }
      a4 = *a2;
      if (a4 == 67)
      {
        ++a2;
LABEL_490:
        if (a2 == a3) {
          return 164LL;
        }
        a4 = *a2;
        if (a4 == 79)
        {
          ++a2;
LABEL_510:
          if (a2 == a3) {
            return 163LL;
          }
          if (*a2 == 76)
          {
            ++a2;
            LOBYTE(a4) = 10;
            goto LABEL_1026;
          }

          goto LABEL_1301;
        }

        if (a4 != 65) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_494:
        if (a2 == a3) {
          return 162LL;
        }
        unsigned int v139 = *(_DWORD *)a1;
        while (1)
        {
          int v140 = *a2;
          int v141 = llparse_blob32[v139];
          if (v139 == 5)
          {
            a4 = 0;
            int v142 = 5;
          }

          else
          {
            int v142 = 0;
          }

          if (v140 != v141)
          {
            a4 = 2;
            int v142 = 5;
          }

          if (v142) {
            break;
          }
          if (v140 == v141) {
            ++v139;
          }
          if (++a2 == a3)
          {
            a4 = 1;
            a2 = a3;
            goto LABEL_507;
          }
        }

        unsigned int v139 = 0;
LABEL_507:
        *(_DWORD *)a1 = v139;
        if (!a4)
        {
          ++a2;
          LOBYTE(a4) = 30;
          goto LABEL_1026;
        }

        if (a4 == 1) {
          return 162LL;
        }
      }

      else
      {
        if (a4 != 65) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_474:
        if (a2 == a3) {
          return 161LL;
        }
        unsigned int v135 = *(_DWORD *)a1;
        while (1)
        {
          int v136 = *a2;
          int v137 = llparse_blob31[v135];
          if (v135 == 6)
          {
            a4 = 0;
            int v138 = 5;
          }

          else
          {
            int v138 = 0;
          }

          if (v136 != v137)
          {
            a4 = 2;
            int v138 = 5;
          }

          if (v138) {
            break;
          }
          if (v136 == v137) {
            ++v135;
          }
          if (++a2 == a3)
          {
            a4 = 1;
            a2 = a3;
            goto LABEL_487;
          }
        }

        unsigned int v135 = 0;
LABEL_487:
        *(_DWORD *)a1 = v135;
        if (!a4)
        {
          ++a2;
          LOBYTE(a4) = 21;
          goto LABEL_1026;
        }

        if (a4 == 1) {
          return 161LL;
        }
      }

      goto LABEL_1300;
    case 166:
LABEL_514:
      if (a2 == a3) {
        return 166LL;
      }
      unsigned int v143 = *(_DWORD *)a1;
      while (1)
      {
        int v144 = *a2;
        int v145 = llparse_blob33[v143];
        if (v143 == 1)
        {
          a4 = 0;
          int v146 = 5;
        }

        else
        {
          int v146 = 0;
        }

        if (v144 != v145)
        {
          a4 = 2;
          int v146 = 5;
        }

        if (v146) {
          break;
        }
        if (v144 == v145) {
          ++v143;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_527;
        }
      }

      unsigned int v143 = 0;
LABEL_527:
      *(_DWORD *)a1 = v143;
      if (!a4)
      {
        ++a2;
        LOBYTE(a4) = 11;
        goto LABEL_1026;
      }

      if (a4 == 1) {
        return 166LL;
      }
      goto LABEL_1300;
    case 167:
LABEL_435:
      if (a2 != a3)
      {
        a4 = *a2 - 45;
        switch(*a2)
        {
          case '-':
            ++a2;
            goto LABEL_438;
          case 'E':
            ++a2;
            goto LABEL_454;
          case 'K':
            ++a2;
            goto LABEL_470;
          case 'O':
            ++a2;
            goto LABEL_514;
          default:
            goto LABEL_1301;
        }
      }

      return 167LL;
    case 168:
LABEL_540:
      if (a2 == a3) {
        return 168LL;
      }
      unsigned int v147 = *(_DWORD *)a1;
      while (1)
      {
        int v148 = *a2;
        int v149 = llparse_blob34[v147];
        if (v147 == 4)
        {
          a4 = 0;
          int v150 = 5;
        }

        else
        {
          int v150 = 0;
        }

        if (v148 != v149)
        {
          a4 = 2;
          int v150 = 5;
        }

        if (v150) {
          break;
        }
        if (v148 == v149) {
          ++v147;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_553;
        }
      }

      unsigned int v147 = 0;
LABEL_553:
      *(_DWORD *)a1 = v147;
      if (!a4)
      {
        ++a2;
        LOBYTE(a4) = 25;
        goto LABEL_1026;
      }

      if (a4 == 1) {
        return 168LL;
      }
      goto LABEL_1300;
    case 169:
LABEL_558:
      if (a2 == a3) {
        return 169LL;
      }
      unsigned int v151 = *(_DWORD *)a1;
      while (1)
      {
        int v152 = *a2;
        int v153 = llparse_blob35[v151];
        if (v151 == 5)
        {
          a4 = 0;
          int v154 = 5;
        }

        else
        {
          int v154 = 0;
        }

        if (v152 != v153)
        {
          a4 = 2;
          int v154 = 5;
        }

        if (v154) {
          break;
        }
        if (v152 == v153) {
          ++v151;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_571;
        }
      }

      unsigned int v151 = 0;
LABEL_571:
      *(_DWORD *)a1 = v151;
      if (!a4)
      {
        ++a2;
        LOBYTE(a4) = 6;
        goto LABEL_1026;
      }

      if (a4 == 1) {
        return 169LL;
      }
      goto LABEL_1300;
    case 170:
      goto LABEL_583;
    case 171:
      goto LABEL_599;
    case 172:
LABEL_579:
      if (a2 == a3) {
        return 172LL;
      }
      a4 = *a2;
      if (a4 == 85)
      {
        ++a2;
LABEL_599:
        if (a2 == a3) {
          return 171LL;
        }
        unsigned int v159 = *(_DWORD *)a1;
        while (1)
        {
          int v160 = *a2;
          int v161 = llparse_blob37[v159];
          if (v159 == 1)
          {
            a4 = 0;
            int v162 = 5;
          }

          else
          {
            int v162 = 0;
          }

          if (v160 != v161)
          {
            a4 = 2;
            int v162 = 5;
          }

          if (v162) {
            break;
          }
          if (v160 == v161) {
            ++v159;
          }
          if (++a2 == a3)
          {
            a4 = 1;
            a2 = a3;
            goto LABEL_612;
          }
        }

        unsigned int v159 = 0;
LABEL_612:
        *(_DWORD *)a1 = v159;
        if (!a4)
        {
          ++a2;
          LOBYTE(a4) = 39;
          goto LABEL_1026;
        }

        if (a4 == 1) {
          return 171LL;
        }
      }

      else
      {
        if (a4 != 84) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_583:
        if (a2 == a3) {
          return 170LL;
        }
        unsigned int v155 = *(_DWORD *)a1;
        while (1)
        {
          int v156 = *a2;
          int v157 = llparse_blob36[v155];
          if (v155 == 1)
          {
            a4 = 0;
            int v158 = 5;
          }

          else
          {
            int v158 = 0;
          }

          if (v156 != v157)
          {
            a4 = 2;
            int v158 = 5;
          }

          if (v158) {
            break;
          }
          if (v156 == v157) {
            ++v155;
          }
          if (++a2 == a3)
          {
            a4 = 1;
            a2 = a3;
            goto LABEL_596;
          }
        }

        unsigned int v155 = 0;
LABEL_596:
        *(_DWORD *)a1 = v155;
        if (!a4)
        {
          ++a2;
          LOBYTE(a4) = 28;
          goto LABEL_1026;
        }

        if (a4 == 1) {
          return 170LL;
        }
      }

      goto LABEL_1300;
    case 173:
LABEL_615:
      if (a2 == a3) {
        return 173LL;
      }
      unsigned int v163 = *(_DWORD *)a1;
      while (1)
      {
        int v164 = *a2;
        int v165 = llparse_blob38[v163];
        if (v163 == 1)
        {
          a4 = 0;
          int v166 = 5;
        }

        else
        {
          int v166 = 0;
        }

        if (v164 != v165)
        {
          a4 = 2;
          int v166 = 5;
        }

        if (v166) {
          break;
        }
        if (v164 == v165) {
          ++v163;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_628;
        }
      }

      unsigned int v163 = 0;
LABEL_628:
      *(_DWORD *)a1 = v163;
      if (!a4)
      {
        ++a2;
        LOBYTE(a4) = 38;
        goto LABEL_1026;
      }

      if (a4 == 1) {
        return 173LL;
      }
      goto LABEL_1300;
    case 174:
LABEL_631:
      if (a2 == a3) {
        return 174LL;
      }
      unsigned int v167 = *(_DWORD *)a1;
      while (1)
      {
        int v168 = *a2;
        int v169 = llparse_blob39[v167];
        if (v167 == 1)
        {
          a4 = 0;
          int v170 = 5;
        }

        else
        {
          int v170 = 0;
        }

        if (v168 != v169)
        {
          a4 = 2;
          int v170 = 5;
        }

        if (v170) {
          break;
        }
        if (v168 == v169) {
          ++v167;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_644;
        }
      }

      unsigned int v167 = 0;
LABEL_644:
      *(_DWORD *)a1 = v167;
      if (!a4)
      {
        ++a2;
        LOBYTE(a4) = 3;
        goto LABEL_1026;
      }

      if (a4 == 1) {
        return 174LL;
      }
      goto LABEL_1300;
    case 175:
      goto LABEL_659;
    case 176:
      goto LABEL_675;
    case 177:
      goto LABEL_655;
    case 178:
      goto LABEL_652;
    case 179:
LABEL_647:
      if (a2 == a3) {
        return 179LL;
      }
      int v171 = *a2;
      if (v171 != 79)
      {
        if (v171 == 73)
        {
          ++a2;
          LOBYTE(a4) = 34;
          goto LABEL_1026;
        }

        goto LABEL_1301;
      }

      ++a2;
LABEL_652:
      if (a2 == a3) {
        return 178LL;
      }
      if (*a2 != 80) {
        goto LABEL_1301;
      }
      ++a2;
LABEL_655:
      if (a2 == a3) {
        return 177LL;
      }
      a4 = *a2;
      if (a4 == 80)
      {
        ++a2;
LABEL_675:
        if (a2 == a3) {
          return 176LL;
        }
        unsigned int v176 = *(_DWORD *)a1;
        while (1)
        {
          int v177 = *a2;
          int v178 = llparse_blob41[v176];
          if (v176 == 3)
          {
            a4 = 0;
            int v179 = 5;
          }

          else
          {
            int v179 = 0;
          }

          if (v177 != v178)
          {
            a4 = 2;
            int v179 = 5;
          }

          if (v179) {
            break;
          }
          if (v177 == v178) {
            ++v176;
          }
          if (++a2 == a3)
          {
            a4 = 1;
            a2 = a3;
            goto LABEL_688;
          }
        }

        unsigned int v176 = 0;
LABEL_688:
        *(_DWORD *)a1 = v176;
        if (!a4)
        {
          ++a2;
          LOBYTE(a4) = 13;
          goto LABEL_1026;
        }

        if (a4 == 1) {
          return 176LL;
        }
      }

      else
      {
        if (a4 != 70) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_659:
        if (a2 == a3) {
          return 175LL;
        }
        unsigned int v172 = *(_DWORD *)a1;
        while (1)
        {
          int v173 = *a2;
          int v174 = llparse_blob40[v172];
          if (v172 == 2)
          {
            a4 = 0;
            int v175 = 5;
          }

          else
          {
            int v175 = 0;
          }

          if (v173 != v174)
          {
            a4 = 2;
            int v175 = 5;
          }

          if (v175) {
            break;
          }
          if (v173 == v174) {
            ++v172;
          }
          if (++a2 == a3)
          {
            a4 = 1;
            a2 = a3;
            goto LABEL_672;
          }
        }

        unsigned int v172 = 0;
LABEL_672:
        *(_DWORD *)a1 = v172;
        if (!a4)
        {
          ++a2;
          LOBYTE(a4) = 12;
          goto LABEL_1026;
        }

        if (a4 == 1) {
          return 175LL;
        }
      }

      goto LABEL_1300;
    case 180:
      goto LABEL_695;
    case 181:
LABEL_691:
      if (a2 == a3) {
        return 181LL;
      }
      a4 = *a2;
      if (a4 == 84)
      {
        ++a2;
        LOBYTE(a4) = 4;
        goto LABEL_1026;
      }

      if (a4 != 82) {
        goto LABEL_1301;
      }
      ++a2;
LABEL_695:
      if (a2 == a3) {
        return 180LL;
      }
      unsigned int v180 = *(_DWORD *)a1;
      while (1)
      {
        int v181 = *a2;
        int v182 = llparse_blob42[v180];
        if (v180 == 1)
        {
          a4 = 0;
          int v183 = 5;
        }

        else
        {
          int v183 = 0;
        }

        if (v181 != v182)
        {
          a4 = 2;
          int v183 = 5;
        }

        if (v183) {
          break;
        }
        if (v181 == v182) {
          ++v180;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_708;
        }
      }

      unsigned int v180 = 0;
LABEL_708:
      *(_DWORD *)a1 = v180;
      if (!a4)
      {
        ++a2;
        LOBYTE(a4) = 29;
        goto LABEL_1026;
      }

      if (a4 == 1) {
        return 180LL;
      }
      goto LABEL_1300;
    case 182:
LABEL_576:
      if (a2 != a3)
      {
        a4 = *a2 - 65;
        switch(*a2)
        {
          case 'A':
            ++a2;
            goto LABEL_579;
          case 'L':
            ++a2;
            goto LABEL_615;
          case 'O':
            ++a2;
            goto LABEL_631;
          case 'R':
            ++a2;
            goto LABEL_647;
          case 'U':
            ++a2;
            goto LABEL_691;
          default:
            goto LABEL_1301;
        }
      }

      return 182LL;
    case 183:
LABEL_726:
      if (a2 == a3) {
        return 183LL;
      }
      unsigned int v184 = *(_DWORD *)a1;
      while (1)
      {
        int v185 = *a2;
        int v186 = llparse_blob43[v184];
        if (v184 == 3)
        {
          a4 = 0;
          int v187 = 5;
        }

        else
        {
          int v187 = 0;
        }

        if (v185 != v186)
        {
          a4 = 2;
          int v187 = 5;
        }

        if (v187) {
          break;
        }
        if (v185 == v186) {
          ++v184;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_739;
        }
      }

      unsigned int v184 = 0;
LABEL_739:
      *(_DWORD *)a1 = v184;
      if (!a4)
      {
        ++a2;
        LOBYTE(a4) = 46;
        goto LABEL_1026;
      }

      if (a4 == 1) {
        return 183LL;
      }
      goto LABEL_1300;
    case 184:
LABEL_750:
      if (a2 == a3) {
        return 184LL;
      }
      unsigned int v188 = *(_DWORD *)a1;
      while (1)
      {
        int v189 = *a2;
        int v190 = llparse_blob44[v188];
        if (v188 == 2)
        {
          a4 = 0;
          int v191 = 5;
        }

        else
        {
          int v191 = 0;
        }

        if (v189 != v190)
        {
          a4 = 2;
          int v191 = 5;
        }

        if (v191) {
          break;
        }
        if (v189 == v190) {
          ++v188;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_763;
        }
      }

      unsigned int v188 = 0;
LABEL_763:
      *(_DWORD *)a1 = v188;
      if (!a4)
      {
        ++a2;
        LOBYTE(a4) = 17;
        goto LABEL_1026;
      }

      if (a4 == 1) {
        return 184LL;
      }
      goto LABEL_1300;
    case 185:
LABEL_766:
      if (a2 == a3) {
        return 185LL;
      }
      unsigned int v192 = *(_DWORD *)a1;
      while (1)
      {
        int v193 = *a2;
        int v194 = llparse_blob45[v192];
        if (v192 == 2)
        {
          a4 = 0;
          int v195 = 5;
        }

        else
        {
          int v195 = 0;
        }

        if (v193 != v194)
        {
          a4 = 2;
          int v195 = 5;
        }

        if (v195) {
          break;
        }
        if (v193 == v194) {
          ++v192;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_779;
        }
      }

      unsigned int v192 = 0;
LABEL_779:
      *(_DWORD *)a1 = v192;
      if (!a4)
      {
        ++a2;
        LOBYTE(a4) = 44;
        goto LABEL_1026;
      }

      if (a4 == 1) {
        return 185LL;
      }
      goto LABEL_1300;
    case 186:
LABEL_782:
      if (a2 == a3) {
        return 186LL;
      }
      unsigned int v196 = *(_DWORD *)a1;
      while (1)
      {
        int v197 = *a2;
        int v198 = llparse_blob46[v196];
        if (v196 == 4)
        {
          a4 = 0;
          int v199 = 5;
        }

        else
        {
          int v199 = 0;
        }

        if (v197 != v198)
        {
          a4 = 2;
          int v199 = 5;
        }

        if (v199) {
          break;
        }
        if (v197 == v198) {
          ++v196;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_795;
        }
      }

      unsigned int v196 = 0;
LABEL_795:
      *(_DWORD *)a1 = v196;
      if (!a4)
      {
        ++a2;
        LOBYTE(a4) = 43;
        goto LABEL_1026;
      }

      if (a4 == 1) {
        return 186LL;
      }
      goto LABEL_1300;
    case 187:
LABEL_798:
      if (a2 == a3) {
        return 187LL;
      }
      unsigned int v200 = *(_DWORD *)a1;
      while (1)
      {
        int v201 = *a2;
        int v202 = llparse_blob47[v200];
        if (v200 == 2)
        {
          a4 = 0;
          int v203 = 5;
        }

        else
        {
          int v203 = 0;
        }

        if (v201 != v202)
        {
          a4 = 2;
          int v203 = 5;
        }

        if (v203) {
          break;
        }
        if (v201 == v202) {
          ++v200;
        }
        if (++a2 == a3)
        {
          a4 = 1;
          a2 = a3;
          goto LABEL_811;
        }
      }

      unsigned int v200 = 0;
LABEL_811:
      *(_DWORD *)a1 = v200;
      if (!a4)
      {
        ++a2;
        LOBYTE(a4) = 20;
        goto LABEL_1026;
      }

      if (a4 == 1) {
        return 187LL;
      }
      goto LABEL_1300;
    case 188:
      goto LABEL_747;
    case 189:
LABEL_744:
      if (a2 == a3) {
        return 189LL;
      }
      if (*a2 != 69) {
        goto LABEL_1301;
      }
      ++a2;
LABEL_747:
      if (a2 != a3)
      {
        a4 = *a2 - 66;
        switch(*a2)
        {
          case 'B':
            ++a2;
            goto LABEL_750;
          case 'C':
            ++a2;
            goto LABEL_766;
          case 'D':
            ++a2;
            goto LABEL_782;
          case 'P':
            ++a2;
            goto LABEL_798;
          default:
            goto LABEL_1301;
        }
      }

      return 188LL;
    case 190:
      goto LABEL_831;
    case 191:
      goto LABEL_851;
    case 192:
      goto LABEL_855;
    case 193:
      goto LABEL_847;
    case 194:
      goto LABEL_827;
    case 195:
      goto LABEL_887;
    case 196:
      goto LABEL_871;
    case 197:
LABEL_822:
      if (a2 == a3) {
        return 197LL;
      }
      a4 = *a2;
      switch(a4)
      {
        case 'U':
          ++a2;
LABEL_871:
          if (a2 == a3) {
            return 196LL;
          }
          unsigned int v212 = *(_DWORD *)a1;
          while (1)
          {
            int v213 = *a2;
            int v214 = llparse_blob51[v212];
            if (v212 == 6)
            {
              a4 = 0;
              int v215 = 5;
            }

            else
            {
              int v215 = 0;
            }

            if (v213 != v214)
            {
              a4 = 2;
              int v215 = 5;
            }

            if (v215) {
              break;
            }
            if (v213 == v214) {
              ++v212;
            }
            if (++a2 == a3)
            {
              a4 = 1;
              a2 = a3;
              goto LABEL_884;
            }
          }

          unsigned int v212 = 0;
LABEL_884:
          *(_DWORD *)a1 = v212;
          if (!a4)
          {
            ++a2;
            LOBYTE(a4) = 26;
            goto LABEL_1026;
          }

          if (a4 == 1) {
            return 196LL;
          }
          break;
        case 'O':
          ++a2;
LABEL_887:
          if (a2 == a3) {
            return 195LL;
          }
          unsigned int v216 = *(_DWORD *)a1;
          while (1)
          {
            int v217 = *a2;
            int v218 = llparse_blob50[v216];
            if (v216 == 3)
            {
              a4 = 0;
              int v219 = 5;
            }

            else
            {
              int v219 = 0;
            }

            if (v217 != v218)
            {
              a4 = 2;
              int v219 = 5;
            }

            if (v219) {
              break;
            }
            if (v217 == v218) {
              ++v216;
            }
            if (++a2 == a3)
            {
              a4 = 1;
              a2 = a3;
              goto LABEL_900;
            }
          }

          unsigned int v216 = 0;
LABEL_900:
          *(_DWORD *)a1 = v216;
          if (!a4)
          {
            ++a2;
            LOBYTE(a4) = 33;
            goto LABEL_1026;
          }

          if (a4 == 1) {
            return 195LL;
          }
          break;
        case 'E':
          ++a2;
LABEL_827:
          if (a2 == a3) {
            return 194LL;
          }
          a4 = *a2;
          if (a4 == 84)
          {
            ++a2;
LABEL_847:
            if (a2 == a3) {
              return 193LL;
            }
            a4 = *a2;
            if (a4 != 95)
            {
              if (a4 == 85)
              {
                ++a2;
LABEL_851:
                if (a2 == a3) {
                  return 191LL;
                }
                if (*a2 == 80)
                {
                  ++a2;
                  LOBYTE(a4) = 37;
                  goto LABEL_1026;
                }
              }

              goto LABEL_1301;
            }

            ++a2;
LABEL_855:
            if (a2 == a3) {
              return 192LL;
            }
            unsigned int v208 = *(_DWORD *)a1;
            while (1)
            {
              int v209 = *a2;
              int v210 = llparse_blob49[v208];
              if (v208 == 8)
              {
                a4 = 0;
                int v211 = 5;
              }

              else
              {
                int v211 = 0;
              }

              if (v209 != v210)
              {
                a4 = 2;
                int v211 = 5;
              }

              if (v211) {
                break;
              }
              if (v209 == v210) {
                ++v208;
              }
              if (++a2 == a3)
              {
                a4 = 1;
                a2 = a3;
                goto LABEL_868;
              }
            }

            unsigned int v208 = 0;
LABEL_868:
            *(_DWORD *)a1 = v208;
            if (!a4)
            {
              ++a2;
              LOBYTE(a4) = 42;
              goto LABEL_1026;
            }

            if (a4 == 1) {
              return 192LL;
            }
          }

          else
          {
            if (a4 != 65) {
              goto LABEL_1301;
            }
            ++a2;
LABEL_831:
            if (a2 == a3) {
              return 190LL;
            }
            unsigned int v204 = *(_DWORD *)a1;
            while (1)
            {
              int v205 = *a2;
              int v206 = llparse_blob48[v204];
              if (v204 == 2)
              {
                a4 = 0;
                int v207 = 5;
              }

              else
              {
                int v207 = 0;
              }

              if (v205 != v206)
              {
                a4 = 2;
                int v207 = 5;
              }

              if (v207) {
                break;
              }
              if (v205 == v206) {
                ++v204;
              }
              if (++a2 == a3)
              {
                a4 = 1;
                a2 = a3;
                goto LABEL_844;
              }
            }

            unsigned int v204 = 0;
LABEL_844:
            *(_DWORD *)a1 = v204;
            if (!a4)
            {
              ++a2;
              LOBYTE(a4) = 14;
              goto LABEL_1026;
            }

            if (a4 == 1) {
              return 190LL;
            }
          }

          break;
        default:
          goto LABEL_1301;
      }

      goto LABEL_1300;
    case 198:
      goto LABEL_915;
    case 199:
      goto LABEL_931;
    case 200:
LABEL_911:
      if (a2 == a3) {
        return 200LL;
      }
      a4 = *a2;
      if (a4 == 82)
      {
        ++a2;
LABEL_931:
        if (a2 == a3) {
          return 199LL;
        }
        unsigned int v224 = *(_DWORD *)a1;
        while (1)
        {
          int v225 = *a2;
          int v226 = llparse_blob53[v224];
          if (v224 == 2)
          {
            a4 = 0;
            int v227 = 5;
          }

          else
          {
            int v227 = 0;
          }

          if (v225 != v226)
          {
            a4 = 2;
            int v227 = 5;
          }

          if (v227) {
            break;
          }
          if (v225 == v226) {
            ++v224;
          }
          if (++a2 == a3)
          {
            a4 = 1;
            a2 = a3;
            goto LABEL_944;
          }
        }

        unsigned int v224 = 0;
LABEL_944:
        *(_DWORD *)a1 = v224;
        if (!a4)
        {
          ++a2;
          LOBYTE(a4) = 7;
          goto LABEL_1026;
        }

        if (a4 == 1) {
          return 199LL;
        }
      }

      else
      {
        if (a4 != 69) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_915:
        if (a2 == a3) {
          return 198LL;
        }
        unsigned int v220 = *(_DWORD *)a1;
        while (1)
        {
          int v221 = *a2;
          int v222 = llparse_blob52[v220];
          if (v220 == 5)
          {
            a4 = 0;
            int v223 = 5;
          }

          else
          {
            int v223 = 0;
          }

          if (v221 != v222)
          {
            a4 = 2;
            int v223 = 5;
          }

          if (v223) {
            break;
          }
          if (v221 == v222) {
            ++v220;
          }
          if (++a2 == a3)
          {
            a4 = 1;
            a2 = a3;
            goto LABEL_928;
          }
        }

        unsigned int v220 = 0;
LABEL_928:
        *(_DWORD *)a1 = v220;
        if (!a4)
        {
          ++a2;
          LOBYTE(a4) = 40;
          goto LABEL_1026;
        }

        if (a4 == 1) {
          return 198LL;
        }
      }

      goto LABEL_1300;
    case 201:
      goto LABEL_959;
    case 202:
      goto LABEL_995;
    case 203:
      goto LABEL_1011;
    case 204:
      goto LABEL_991;
    case 205:
      goto LABEL_975;
    case 206:
      goto LABEL_954;
    case 207:
LABEL_951:
      if (a2 == a3) {
        return 207LL;
      }
      if (*a2 != 78) {
        goto LABEL_1301;
      }
      ++a2;
LABEL_954:
      if (a2 == a3) {
        return 206LL;
      }
      a4 = *a2;
      switch(a4)
      {
        case 'S':
          ++a2;
LABEL_975:
          if (a2 == a3) {
            return 205LL;
          }
          unsigned int v232 = *(_DWORD *)a1;
          while (1)
          {
            int v233 = *a2;
            int v234 = llparse_blob57[v232];
            if (v232 == 7)
            {
              a4 = 0;
              int v235 = 5;
            }

            else
            {
              int v235 = 0;
            }

            if (v233 != v234)
            {
              a4 = 2;
              int v235 = 5;
            }

            if (v235) {
              break;
            }
            if (v233 == v234) {
              ++v232;
            }
            if (++a2 == a3)
            {
              a4 = 1;
              a2 = a3;
              goto LABEL_988;
            }
          }

          unsigned int v232 = 0;
LABEL_988:
          *(_DWORD *)a1 = v232;
          if (!a4)
          {
            ++a2;
            LOBYTE(a4) = 27;
            goto LABEL_1026;
          }

          if (a4 == 1) {
            return 205LL;
          }
          break;
        case 'L':
          ++a2;
LABEL_991:
          if (a2 == a3) {
            return 204LL;
          }
          a4 = *a2;
          if (a4 == 79)
          {
            ++a2;
LABEL_1011:
            if (a2 == a3) {
              return 203LL;
            }
            unsigned int v240 = *(_DWORD *)a1;
            while (1)
            {
              int v241 = *a2;
              int v242 = llparse_blob56[v240];
              if (v240 == 1)
              {
                a4 = 0;
                int v243 = 5;
              }

              else
              {
                int v243 = 0;
              }

              if (v241 != v242)
              {
                a4 = 2;
                int v243 = 5;
              }

              if (v243) {
                break;
              }
              if (v241 == v242) {
                ++v240;
              }
              if (++a2 == a3)
              {
                a4 = 1;
                a2 = a3;
                goto LABEL_1024;
              }
            }

            unsigned int v240 = 0;
LABEL_1024:
            *(_DWORD *)a1 = v240;
            if (!a4)
            {
              ++a2;
              LOBYTE(a4) = 15;
              goto LABEL_1026;
            }

            if (a4 == 1) {
              return 203LL;
            }
          }

          else
          {
            if (a4 != 73) {
              goto LABEL_1301;
            }
            ++a2;
LABEL_995:
            if (a2 == a3) {
              return 202LL;
            }
            unsigned int v236 = *(_DWORD *)a1;
            while (1)
            {
              int v237 = *a2;
              int v238 = llparse_blob55[v236];
              if (v236 == 1)
              {
                a4 = 0;
                int v239 = 5;
              }

              else
              {
                int v239 = 0;
              }

              if (v237 != v238)
              {
                a4 = 2;
                int v239 = 5;
              }

              if (v239) {
                break;
              }
              if (v237 == v238) {
                ++v236;
              }
              if (++a2 == a3)
              {
                a4 = 1;
                a2 = a3;
                goto LABEL_1008;
              }
            }

            unsigned int v236 = 0;
LABEL_1008:
            *(_DWORD *)a1 = v236;
            if (!a4)
            {
              ++a2;
              LOBYTE(a4) = 32;
              goto LABEL_1026;
            }

            if (a4 == 1) {
              return 202LL;
            }
          }

          break;
        case 'B':
          ++a2;
LABEL_959:
          if (a2 == a3) {
            return 201LL;
          }
          unsigned int v228 = *(_DWORD *)a1;
          while (1)
          {
            int v229 = *a2;
            int v230 = llparse_blob54[v228];
            if (v228 == 2)
            {
              a4 = 0;
              int v231 = 5;
            }

            else
            {
              int v231 = 0;
            }

            if (v229 != v230)
            {
              a4 = 2;
              int v231 = 5;
            }

            if (v231) {
              break;
            }
            if (v229 == v230) {
              ++v228;
            }
            if (++a2 == a3)
            {
              a4 = 1;
              a2 = a3;
              goto LABEL_972;
            }
          }

          unsigned int v228 = 0;
LABEL_972:
          *(_DWORD *)a1 = v228;
          if (!a4)
          {
            ++a2;
            LOBYTE(a4) = 18;
            goto LABEL_1026;
          }

          if (a4 == 1) {
            return 201LL;
          }
          break;
        default:
          goto LABEL_1301;
      }

      goto LABEL_1300;
    case 208:
      goto LABEL_69;
    case 209:
      goto LABEL_67;
    case 210:
      goto LABEL_181;
    case 211:
      goto LABEL_172;
    case 212:
      goto LABEL_170;
    case 213:
      goto LABEL_163;
    case 214:
      goto LABEL_157;
    case 215:
      goto LABEL_152;
    case 216:
      goto LABEL_147;
    case 217:
      goto LABEL_144;
    case 218:
      goto LABEL_141;
    case 221:
      goto LABEL_106;
    case 223:
      goto LABEL_103;
    case 225:
      goto LABEL_100;
    case 226:
      goto LABEL_98;
    case 227:
      goto LABEL_20;
    case 229:
      goto LABEL_46;
    case 230:
      goto LABEL_97;
    case 231:
      goto LABEL_80;
    case 232:
      goto LABEL_42;
    case 233:
      goto LABEL_39;
    case 234:
      goto LABEL_37;
    case 235:
      goto LABEL_35;
    case 236:
      goto LABEL_18;
    case 237:
      goto LABEL_15;
    case 238:
      goto LABEL_3;
    default:
      goto LABEL_2359;
  }

uint64_t llparse__match_sequence_id@<X0>( unsigned int *a1@<X0>, unsigned __int8 *a2@<X1>, unsigned __int8 *a3@<X2>, uint64_t a4@<X3>, int a5@<W4>, unsigned int a6@<W8>)
{
  unsigned int v6 = *a1;
  if (a2 == a3)
  {
    a6 = 1;
  }

  else
  {
    while (1)
    {
      int v7 = *a2;
      int v8 = *(unsigned __int8 *)(a4 + v6);
      if (v6 + 1 == a5)
      {
        a6 = 0;
        int v9 = 5;
      }

      else
      {
        int v9 = 0;
      }

      if (v7 != v8)
      {
        a6 = 2;
        int v9 = 5;
      }

      if (v9) {
        break;
      }
      if (v7 == v8) {
        ++v6;
      }
      if (++a2 == a3)
      {
        a6 = 1;
        goto LABEL_14;
      }
    }

    unsigned int v6 = 0;
  }

void sub_18226AE68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18226B934(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18226BA48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18226BAEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18226C1A4(_Unwind_Exception *exception_object)
{
}

BOOL nw_endpoint_create_srv(const char *a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (a1) {
    return -[NWConcrete_nw_srv_endpoint initWithName:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_srv_endpoint), a1);
  }
  __nwlog_obj();
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v12 = "nw_endpoint_create_srv";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v12 = "nw_endpoint_create_srv";
        unsigned int v6 = "%{public}s called with null name";
LABEL_16:
        _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v5 = type;
        BOOL v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *(_DWORD *)__int128 buf = 136446466;
            BOOL v12 = "nw_endpoint_create_srv";
            __int16 v13 = 2082;
            char v14 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null name, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_18;
        }

        if (!v8) {
          goto LABEL_17;
        }
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v12 = "nw_endpoint_create_srv";
        unsigned int v6 = "%{public}s called with null name, no backtrace";
        goto LABEL_16;
      }

      __nwlog_obj();
      uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v12 = "nw_endpoint_create_srv";
        unsigned int v6 = "%{public}s called with null name, backtrace limit exceeded";
        goto LABEL_16;
      }
    }

uint64_t nw_endpoint_get_srv_name(void *a1)
{
  *(void *)&v40[13] = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    uint64_t v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v38 = "nw_endpoint_get_srv_name";
    int v27 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v27, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v38 = "nw_endpoint_get_srv_name";
          _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v31 = type;
        BOOL v32 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)__int128 buf = 136446466;
            unsigned int v38 = "nw_endpoint_get_srv_name";
            __int16 v39 = 2082;
            *(void *)char v40 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v28,  v31,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }

        if (v32)
        {
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v38 = "nw_endpoint_get_srv_name";
          _os_log_impl(&dword_181A5C000, v28, v31, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v38 = "nw_endpoint_get_srv_name";
          _os_log_impl( &dword_181A5C000,  v28,  v33,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_18226C9F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18226E034( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
}

void sub_18226E340( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
}

uint64_t __Block_byref_object_copy__47388(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__47389(uint64_t a1)
{
}

void sub_1822711E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182275BFC( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id *location, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, uint64_t a36, uint64_t a37, uint64_t a38, uint64_t a39, uint64_t a40, uint64_t a41, uint64_t a42, uint64_t a43, uint64_t a44, uint64_t a45, uint64_t a46, uint64_t a47, uint64_t a48, uint64_t a49, char a50)
{
}

uint64_t __Block_byref_object_copy__47790(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__47791(uint64_t a1)
{
}

void __Block_byref_object_copy__53(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__54(uint64_t a1)
{
}

void sub_18227655C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void *network_retain(void *object)
{
  if (object) {
    return os_retain(object);
  }
  return object;
}

void network_release(void *object)
{
  if (object) {
    os_release(object);
  }
}

xpc_object_t nw_xpc_array_get_value_of_type(void *a1, size_t a2, objc_class *a3)
{
  if (!a1 || object_getClass(a1) != (Class)MEMORY[0x1895F9220] || xpc_array_get_count(a1) <= a2) {
    return 0LL;
  }
  xpc_object_t value = xpc_array_get_value(a1, a2);
  xpc_object_t v7 = value;
  if (a3 && value && object_getClass(value) != a3) {
    return 0LL;
  }
  return v7;
}

xpc_object_t nw_xpc_dictionary_get_value_of_type(void *a1, const char *a2, objc_class *a3)
{
  if (!a1) {
    return 0LL;
  }
  Class Class = object_getClass(a1);
  xpc_object_t v7 = 0LL;
  if (a2)
  {
    if (Class == (Class)MEMORY[0x1895F9250])
    {
      xpc_object_t value = xpc_dictionary_get_value(a1, a2);
      xpc_object_t v7 = value;
      if (a3)
      {
        if (value && object_getClass(value) != a3) {
          return 0LL;
        }
      }
    }
  }

  return v7;
}

uint64_t nw_dispatch_data_copyout(dispatch_data_s *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0LL;
  int v8 = &v7;
  uint64_t v9 = 0x2000000000LL;
  uint64_t v10 = 0LL;
  v6[0] = 0LL;
  v6[1] = v6;
  v6[2] = 0x2000000000LL;
  _OWORD v6[3] = a2;
  if (a1)
  {
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 0x40000000LL;
    applier[2] = __nw_dispatch_data_copyout_block_invoke;
    applier[3] = &unk_189BBF598;
    applier[5] = v6;
    void applier[6] = a3;
    applier[4] = &v7;
    dispatch_data_apply(a1, applier);
    uint64_t v3 = v8[3];
  }

  else
  {
    uint64_t v3 = 0LL;
  }

  _Block_object_dispose(v6, 8);
  _Block_object_dispose(&v7, 8);
  return v3;
}

BOOL __nw_dispatch_data_copyout_block_invoke(void *a1, int a2, int a3, void *__src, size_t a5)
{
  unint64_t v5 = a1[6];
  unint64_t v6 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
  if (v5 - v6 >= a5) {
    size_t v7 = a5;
  }
  else {
    size_t v7 = v5 - v6;
  }
  if (v7)
  {
    memcpy((void *)(*(void *)(*(void *)(a1[5] + 8LL) + 24LL) + v6), __src, v7);
    *(void *)(*(void *)(a1[4] + 8LL) + 24LL) += v7;
    unint64_t v6 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
    unint64_t v5 = a1[6];
  }

  return v6 < v5;
}

uint64_t nw_dispatch_data_copyout_from_offset(dispatch_data_s *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2000000000LL;
    uint64_t v19 = 0LL;
    *(void *)os_log_type_t type = 0LL;
    uint64_t v14 = type;
    uint64_t v15 = 0x2000000000LL;
    uint64_t v16 = a4;
    applier[0] = MEMORY[0x1895F87A8];
    applier[1] = 0x40000000LL;
    applier[2] = __nw_dispatch_data_copyout_from_offset_block_invoke;
    applier[3] = &unk_189BBF5C0;
    applier[4] = type;
    applier[5] = buf;
    void applier[6] = a3;
    void applier[7] = a2;
    dispatch_data_apply(a1, applier);
    uint64_t v4 = *(void *)(*(void *)&buf[8] + 24LL);
    _Block_object_dispose(type, 8);
    _Block_object_dispose(buf, 8);
    return v4;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_dispatch_data_copyout_from_offset";
  unint64_t v6 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v6, type, &v17))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      size_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type[0];
      if (os_log_type_enabled(v7, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_dispatch_data_copyout_from_offset";
        uint64_t v9 = "%{public}s called with null data";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v7, v8, v9, buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type[0];
      BOOL v11 = os_log_type_enabled(v7, type[0]);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_dispatch_data_copyout_from_offset";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null data, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_dispatch_data_copyout_from_offset";
        uint64_t v9 = "%{public}s called with null data, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      size_t v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type[0];
      if (os_log_type_enabled(v7, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_dispatch_data_copyout_from_offset";
        uint64_t v9 = "%{public}s called with null data, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

BOOL __nw_dispatch_data_copyout_from_offset_block_invoke( void *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v5 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
  if (a5 + a3 <= v5) {
    return 1LL;
  }
  unint64_t v7 = a1[6];
  unint64_t v8 = *(void *)(*(void *)(a1[5] + 8LL) + 24LL);
  BOOL v9 = v7 > v8;
  size_t v10 = v7 - v8;
  if (!v9) {
    return 0LL;
  }
  BOOL v11 = v5 >= a3;
  unint64_t v12 = v5 - a3;
  if (!v11) {
    unint64_t v12 = 0LL;
  }
  if (v10 >= a5 - v12) {
    size_t v13 = a5 - v12;
  }
  else {
    size_t v13 = v10;
  }
  memcpy((void *)(a1[7] + v8), (const void *)(a4 + v12), v13);
  *(void *)(*(void *)(a1[4] + 8LL) + 24LL) += v13;
  *(void *)(*(void *)(a1[5] + 8LL) + 24LL) += v13;
  return *(void *)(*(void *)(a1[5] + 8LL) + 24LL) < a1[6];
}

void nw_append_format(const char **a1, char *a2, ...)
{
  uint64_t v79 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    if (a2)
    {
      va_copy(v69, va);
      *(void *)uint64_t v70 = 0LL;
      int v4 = vasprintf((char **)v70, a2, va);
      unsigned int v5 = v4;
      if ((v4 & 0x80000000) == 0 && *(void *)v70)
      {
        if (!*a1)
        {
          size_t v9 = (size_t)malloc((v4 + 1));
          size_t v8 = v9;
          if (!v9)
          {
            unsigned int v63 = (os_log_s *)__nwlog_obj(0LL, v10);
            os_log_type_enabled(v63, OS_LOG_TYPE_ERROR);
            *(_DWORD *)__int128 buf = 136446466;
            int v72 = "strict_malloc";
            __int16 v73 = 2048;
            unint64_t v74 = v5 + 1;
            int v64 = (void *)_os_log_send_and_compose_impl();
            free(v64);
          }

          size_t v11 = 0LL;
          *a1 = (const char *)v8;
          *(_BYTE *)size_t v8 = 0;
          uint64_t v7 = v5 + 1LL;
          goto LABEL_19;
        }

        size_t v6 = strlen(*a1);
        uint64_t v7 = v5 + 1LL;
        size_t v8 = nw_reallocf_type<char *>((void *)*a1, v7 + v6);
        *a1 = (const char *)v8;
        size_t v9 = strlen((const char *)v8);
        if (v8)
        {
          size_t v11 = v9;
LABEL_19:
          int v23 = *(unsigned __int8 **)v70;
          if (*(void *)v70)
          {
            size_t v24 = v7 + v11;
            if (v7 + v11)
            {
LABEL_21:
              uint64_t v25 = 0LL;
              uint64_t v26 = 0LL;
              size_t v27 = -v7 - v11;
              while (1)
              {
                int v28 = (const char *)(v8 + v26);
                if (!*(_BYTE *)(v8 + v26)) {
                  break;
                }
                ++v26;
                --v25;
                if (!(v27 + v26)) {
                  goto LABEL_24;
                }
              }

              if (v23) {
                goto LABEL_28;
              }
              int v65 = (os_log_s *)__nwlog_obj(v9, v10);
              os_log_type_enabled(v65, OS_LOG_TYPE_ERROR);
              *(_DWORD *)__int128 buf = 136446210;
              int v72 = "_strict_strlcpy";
              uint64_t v66 = (void *)_os_log_send_and_compose_impl();
              if (!__nwlog_abort((uint64_t)v66))
              {
                free(v66);
LABEL_28:
                if (v24 + v25 < 2)
                {
LABEL_33:
                  const char *v28 = 0;
                }

                else
                {
                  uint64_t v31 = 0LL;
                  uint64_t v32 = 0LL;
                  while (1)
                  {
                    int v33 = v23[v31];
                    *(_BYTE *)(v8 + v31 + v26) = v33;
                    if (!v33) {
                      break;
                    }
                    --v32;
                    ++v31;
                    if (v32 + v24 - v26 <= 1)
                    {
                      int v28 = (const char *)(v8 + v26 + v31);
                      goto LABEL_33;
                    }
                  }
                }

const char *nw_create_buffer_str_slow(unsigned __int8 *a1, uint64_t a2)
{
  if (!a1) {
    return (const char *)nw_calloc_type<unsigned char>(1uLL);
  }
  uint64_t v2 = a2;
  if (!a2) {
    return (const char *)nw_calloc_type<unsigned char>(1uLL);
  }
  uint64_t v3 = a1;
  size_t v6 = 0LL;
  do
  {
    int v4 = *v3++;
    nw_append_format(&v6, "%02x", v4);
    --v2;
  }

  while (v2);
  return v6;
}

unint64_t nw_convert_to_timebase(uint64_t a1)
{
  unsigned int v2 = dword_18C45F3A4;
  if (!dword_18C45F3A4)
  {
    mach_timebase_info((mach_timebase_info_t)&time_base);
    unsigned int v2 = dword_18C45F3A4;
  }

  return (unint64_t)time_base * a1 / v2;
}

uint64_t nw_delta_ms(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = nw_delta_nanos(a1, a2);
  if (v2 > 0xF423FFFFFFFFFLL) {
    return 0xFFFFFFFFLL;
  }
  else {
    return (v2 / 0xF4240);
  }
}

uint64_t nw_get_future_time_from(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = dword_18C45F3A4;
  if (!dword_18C45F3A4)
  {
    mach_timebase_info((mach_timebase_info_t)&time_base);
    unsigned int v4 = dword_18C45F3A4;
  }

  return (unint64_t)v4 * a2 / time_base + a1;
}

unint64_t nw_get_time_before(unint64_t a1, uint64_t a2)
{
  unsigned int v4 = dword_18C45F3A4;
  if (!dword_18C45F3A4)
  {
    mach_timebase_info((mach_timebase_info_t)&time_base);
    unsigned int v4 = dword_18C45F3A4;
  }

  unint64_t v5 = (unint64_t)v4 * a2 / time_base;
  BOOL v6 = a1 >= v5;
  unint64_t v7 = a1 - v5;
  if (v6) {
    return v7;
  }
  else {
    return 0LL;
  }
}

uint64_t nw_get_future_continuous_time(uint64_t a1)
{
  unsigned int v2 = dword_18C45F3A4;
  if (!dword_18C45F3A4)
  {
    mach_timebase_info((mach_timebase_info_t)&time_base);
    unsigned int v2 = dword_18C45F3A4;
  }

  unint64_t v3 = (unint64_t)v2 * a1 / time_base;
  return mach_continuous_time() + v3;
}

uint64_t nw_mach_continuous_time()
{
  uint64_t result = mach_continuous_time();
  if (result <= 1) {
    return 1LL;
  }
  return result;
}

uint64_t nw_mach_continuous_approximate_time()
{
  uint64_t result = mach_continuous_approximate_time();
  if (result <= 1) {
    return 1LL;
  }
  return result;
}

uint64_t nw_mach_continuous_time_with_timespec()
{
  return 1LL;
}

__uint64_t nw_gettime_nanoseconds()
{
  return clock_gettime_nsec_np(_CLOCK_REALTIME);
}

uint64_t __nw_copy_current_audit_token_block_invoke()
{
  mach_msg_type_number_t task_info_outCnt = 8;
  uint64_t result = task_info( *MEMORY[0x1895FBBE0],  0xFu,  (task_info_t)&nw_copy_current_audit_token::my_audit_token,  &task_info_outCnt);
  nw_copy_current_audit_token::valid = (_DWORD)result == 0;
  return result;
}

uint64_t nw_dispatch_data_to_iovec(dispatch_data_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v61 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
    size_t v27 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf[0]) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (LOBYTE(buf[0]) == 17)
    {
      int v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = buf[0];
      if (!os_log_type_enabled(v28, buf[0])) {
        goto LABEL_94;
      }
      *(_DWORD *)applier = 136446210;
      *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
      unsigned int v30 = "%{public}s called with null data";
    }

    else if (type[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = buf[0];
      BOOL v32 = os_log_type_enabled(v28, buf[0]);
      if (backtrace_string)
      {
        if (v32)
        {
          *(_DWORD *)applier = 136446466;
          *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
          *(_WORD *)&applier[12] = 2082;
          *(void *)&applier[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v28,  v29,  "%{public}s called with null data, dumping backtrace:%{public}s",  applier,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_94;
      }

      if (!v32) {
        goto LABEL_94;
      }
      *(_DWORD *)applier = 136446210;
      *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
      unsigned int v30 = "%{public}s called with null data, no backtrace";
    }

    else
    {
      int v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = buf[0];
      if (!os_log_type_enabled(v28, buf[0])) {
        goto LABEL_94;
      }
      *(_DWORD *)applier = 136446210;
      *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
      unsigned int v30 = "%{public}s called with null data, backtrace limit exceeded";
    }

    goto LABEL_92;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
    size_t v27 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf[0]) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (LOBYTE(buf[0]) != 17)
    {
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        int v28 = (os_log_s *)__nwlog_obj();
        os_log_type_t v29 = buf[0];
        if (!os_log_type_enabled(v28, buf[0])) {
          goto LABEL_94;
        }
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
        unsigned int v30 = "%{public}s called with null len, backtrace limit exceeded";
        goto LABEL_92;
      }

      int v33 = (char *)__nw_create_backtrace_string();
      int v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = buf[0];
      BOOL v34 = os_log_type_enabled(v28, buf[0]);
      if (!v33)
      {
        if (!v34) {
          goto LABEL_94;
        }
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
        unsigned int v30 = "%{public}s called with null len, no backtrace";
        goto LABEL_92;
      }

      if (!v34) {
        goto LABEL_72;
      }
      *(_DWORD *)applier = 136446466;
      *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
      *(_WORD *)&applier[12] = 2082;
      *(void *)&applier[14] = v33;
      uint64_t v35 = "%{public}s called with null len, dumping backtrace:%{public}s";
      goto LABEL_66;
    }

    int v28 = (os_log_s *)__nwlog_obj();
    os_log_type_t v29 = buf[0];
    if (!os_log_type_enabled(v28, buf[0])) {
      goto LABEL_94;
    }
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
    unsigned int v30 = "%{public}s called with null len";
LABEL_92:
    char v40 = applier;
LABEL_93:
    _os_log_impl(&dword_181A5C000, v28, v29, v30, v40, 0xCu);
    goto LABEL_94;
  }

  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
    size_t v27 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf[0]) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (LOBYTE(buf[0]) != 17)
    {
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        int v28 = (os_log_s *)__nwlog_obj();
        os_log_type_t v29 = buf[0];
        if (!os_log_type_enabled(v28, buf[0])) {
          goto LABEL_94;
        }
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
        unsigned int v30 = "%{public}s called with null iovs, backtrace limit exceeded";
        goto LABEL_92;
      }

      int v33 = (char *)__nw_create_backtrace_string();
      int v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = buf[0];
      BOOL v36 = os_log_type_enabled(v28, buf[0]);
      if (!v33)
      {
        if (!v36) {
          goto LABEL_94;
        }
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
        unsigned int v30 = "%{public}s called with null iovs, no backtrace";
        goto LABEL_92;
      }

      if (!v36) {
        goto LABEL_72;
      }
      *(_DWORD *)applier = 136446466;
      *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
      *(_WORD *)&applier[12] = 2082;
      *(void *)&applier[14] = v33;
      uint64_t v35 = "%{public}s called with null iovs, dumping backtrace:%{public}s";
      goto LABEL_66;
    }

    int v28 = (os_log_s *)__nwlog_obj();
    os_log_type_t v29 = buf[0];
    if (!os_log_type_enabled(v28, buf[0])) {
      goto LABEL_94;
    }
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
    unsigned int v30 = "%{public}s called with null iovs";
    goto LABEL_92;
  }

  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
    size_t v27 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(buf[0]) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (LOBYTE(buf[0]) == 17)
    {
      int v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = buf[0];
      if (!os_log_type_enabled(v28, buf[0])) {
        goto LABEL_94;
      }
      *(_DWORD *)applier = 136446210;
      *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
      unsigned int v30 = "%{public}s called with null maxiov";
      goto LABEL_92;
    }

    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      int v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = buf[0];
      if (!os_log_type_enabled(v28, buf[0])) {
        goto LABEL_94;
      }
      *(_DWORD *)applier = 136446210;
      *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
      unsigned int v30 = "%{public}s called with null maxiov, backtrace limit exceeded";
      goto LABEL_92;
    }

    int v33 = (char *)__nw_create_backtrace_string();
    int v28 = (os_log_s *)__nwlog_obj();
    os_log_type_t v29 = buf[0];
    BOOL v37 = os_log_type_enabled(v28, buf[0]);
    if (!v33)
    {
      if (!v37) {
        goto LABEL_94;
      }
      *(_DWORD *)applier = 136446210;
      *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
      unsigned int v30 = "%{public}s called with null maxiov, no backtrace";
      goto LABEL_92;
    }

    if (!v37) {
      goto LABEL_72;
    }
    *(_DWORD *)applier = 136446466;
    *(void *)&applier[4] = "nw_dispatch_data_to_iovec";
    *(_WORD *)&applier[12] = 2082;
    *(void *)&applier[14] = v33;
    uint64_t v35 = "%{public}s called with null maxiov, dumping backtrace:%{public}s";
LABEL_66:
    unsigned int v38 = applier;
    goto LABEL_71;
  }

  char v41 = 0;
  if (a5 <= 0)
  {
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_dispatch_data_to_iovec_partial";
    size_t v27 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type[0];
      if (!os_log_type_enabled(v28, type[0])) {
        goto LABEL_94;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_dispatch_data_to_iovec_partial";
      unsigned int v30 = "%{public}s called with null (maxiov >= 1)";
      goto LABEL_98;
    }

    if (!v46)
    {
      int v28 = (os_log_s *)__nwlog_obj();
      os_log_type_t v29 = type[0];
      if (!os_log_type_enabled(v28, type[0])) {
        goto LABEL_94;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_dispatch_data_to_iovec_partial";
      unsigned int v30 = "%{public}s called with null (maxiov >= 1), backtrace limit exceeded";
      goto LABEL_98;
    }

    int v33 = (char *)__nw_create_backtrace_string();
    int v28 = (os_log_s *)__nwlog_obj();
    os_log_type_t v29 = type[0];
    BOOL v39 = os_log_type_enabled(v28, type[0]);
    if (v33)
    {
      if (!v39) {
        goto LABEL_72;
      }
      LODWORD(buf[0]) = 136446466;
      *(void *)((char *)buf + 4) = "nw_dispatch_data_to_iovec_partial";
      WORD2(buf[1]) = 2082;
      *(void *)((char *)&buf[1] + 6) = v33;
      uint64_t v35 = "%{public}s called with null (maxiov >= 1), dumping backtrace:%{public}s";
      unsigned int v38 = (uint8_t *)buf;
LABEL_71:
      _os_log_impl(&dword_181A5C000, v28, v29, v35, v38, 0x16u);
LABEL_72:
      free(v33);
      if (!v27) {
        return 0LL;
      }
LABEL_95:
      uint64_t v25 = (char *)v27;
      goto LABEL_26;
    }

    if (v39)
    {
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_dispatch_data_to_iovec_partial";
      unsigned int v30 = "%{public}s called with null (maxiov >= 1), no backtrace";
LABEL_98:
      char v40 = (uint8_t *)buf;
      goto LABEL_93;
    }

uint64_t ___ZL33nw_dispatch_data_to_iovec_partialP15dispatch_data_smmP5ioveciPb_block_invoke( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  unint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
  if (a5 + a3 <= v5) {
    return 1LL;
  }
  unint64_t v7 = *(void *)(a1 + 48);
  if (v7 <= a3) {
    return 0LL;
  }
  uint64_t v8 = *(int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  if ((_DWORD)v8 != *(_DWORD *)(a1 + 72))
  {
    BOOL v13 = v5 >= a3;
    unint64_t v14 = v5 - a3;
    if (!v13) {
      unint64_t v14 = 0LL;
    }
    *(void *)(*(void *)(a1 + 64) + 16 * v_Block_object_dispose((const void *)(v50 - 136), 8) = a4 + v14;
    unint64_t v15 = v7 - *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    unint64_t v16 = a5 - v14;
    if (v15 >= v16) {
      unint64_t v15 = v16;
    }
    uint64_t v17 = *(void *)(a1 + 64);
    *(void *)(v17 + 16LL * *(int *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) + _Block_object_dispose((const void *)(v50 - 136), 8) = v15;
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += *(void *)(v17
                                                                             + 16LL
                                                                             * (int)(*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL)
                                                                                               + 24LL))++
                                                                             + 8);
    unint64_t v18 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    unint64_t v19 = *(void *)(a1 + 48);
    if (v18 <= v19) {
      return v18 < v19;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v20 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    uint64_t v21 = *(void *)(a1 + 48);
    *(_DWORD *)__int128 buf = 136446722;
    BOOL v39 = "nw_dispatch_data_to_iovec_partial_block_invoke";
    __int16 v40 = 2048;
    uint64_t v41 = v20;
    __int16 v42 = 2048;
    uint64_t v43 = v21;
    size_t v22 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (__nwlog_fault(v22, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        size_t v23 = (os_log_s *)gLogObj;
        os_log_type_t v24 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v25 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
          uint64_t v26 = *(void *)(a1 + 48);
          *(_DWORD *)__int128 buf = 136446722;
          BOOL v39 = "nw_dispatch_data_to_iovec_partial_block_invoke";
          __int16 v40 = 2048;
          uint64_t v41 = v25;
          __int16 v42 = 2048;
          uint64_t v43 = v26;
          size_t v27 = "%{public}s Cursor hit invalid value (%zu > %zu)";
LABEL_28:
          _os_log_impl(&dword_181A5C000, v23, v24, v27, buf, 0x20u);
        }
      }

      else if (v36)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        size_t v23 = (os_log_s *)__nwlog_obj();
        os_log_type_t v24 = type;
        BOOL v29 = os_log_type_enabled(v23, type);
        if (backtrace_string)
        {
          if (v29)
          {
            uint64_t v30 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
            uint64_t v31 = *(void *)(a1 + 48);
            *(_DWORD *)__int128 buf = 136446978;
            BOOL v39 = "nw_dispatch_data_to_iovec_partial_block_invoke";
            __int16 v40 = 2048;
            uint64_t v41 = v30;
            __int16 v42 = 2048;
            uint64_t v43 = v31;
            __int16 v44 = 2082;
            uint64_t v45 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v23,  v24,  "%{public}s Cursor hit invalid value (%zu > %zu), dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(backtrace_string);
          goto LABEL_29;
        }

        if (v29)
        {
          uint64_t v34 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
          uint64_t v35 = *(void *)(a1 + 48);
          *(_DWORD *)__int128 buf = 136446722;
          BOOL v39 = "nw_dispatch_data_to_iovec_partial_block_invoke";
          __int16 v40 = 2048;
          uint64_t v41 = v34;
          __int16 v42 = 2048;
          uint64_t v43 = v35;
          size_t v27 = "%{public}s Cursor hit invalid value (%zu > %zu), no backtrace";
          goto LABEL_28;
        }
      }

      else
      {
        size_t v23 = (os_log_s *)__nwlog_obj();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          uint64_t v32 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
          uint64_t v33 = *(void *)(a1 + 48);
          *(_DWORD *)__int128 buf = 136446722;
          BOOL v39 = "nw_dispatch_data_to_iovec_partial_block_invoke";
          __int16 v40 = 2048;
          uint64_t v41 = v32;
          __int16 v42 = 2048;
          uint64_t v43 = v33;
          size_t v27 = "%{public}s Cursor hit invalid value (%zu > %zu), backtrace limit exceeded";
          goto LABEL_28;
        }
      }
    }

const char *nwlog_get_string_for_dns_service_error(int a1)
{
  uint64_t result = (const char *)DNSServiceErrorCodeToString();
  if (!result)
  {
    switch(a1)
    {
      case -65570:
        uint64_t result = "PolicyDenied";
        break;
      case -65569:
        uint64_t result = "DefunctConnection";
        break;
      case -65568:
        uint64_t result = "Timeout";
        break;
      case -65567:
        uint64_t result = "PollingMode";
        break;
      case -65566:
        uint64_t result = "NoRouter";
        break;
      case -65565:
        uint64_t result = "NATPortMappingDisabled";
        break;
      case -65564:
        uint64_t result = "NATPortMappingUnsupported";
        break;
      case -65563:
        uint64_t result = "ServiceNotRunning";
        break;
      case -65562:
        uint64_t result = "Transient";
        break;
      case -65561:
        uint64_t result = "BadKey";
        break;
      case -65560:
        uint64_t result = "BadSig";
        break;
      case -65559:
        uint64_t result = "BadTime";
        break;
      case -65558:
        uint64_t result = "DoubleNAT";
        break;
      case -65557:
        uint64_t result = "NATTraversal";
        break;
      case -65556:
        uint64_t result = "NoSuchKey";
        break;
      case -65555:
        uint64_t result = "NoAuth";
        break;
      case -65554:
        uint64_t result = "NoSuchRecord";
        break;
      case -65553:
        uint64_t result = "Refused";
        break;
      case -65552:
        uint64_t result = "BadInterfaceIndex";
        break;
      case -65551:
        uint64_t result = "Incompatible";
        break;
      case -65550:
        uint64_t result = "Firewall";
        break;
      case -65549:
        uint64_t result = "Invalid";
        break;
      case -65548:
        uint64_t result = "NameConflict";
        break;
      case -65547:
        uint64_t result = "AlreadyRegistered";
        break;
      case -65546:
      case -65537:
        goto LABEL_7;
      case -65545:
        uint64_t result = "NotInitialized";
        break;
      case -65544:
        uint64_t result = "Unsupported";
        break;
      case -65543:
        uint64_t result = "BadFlags";
        break;
      case -65542:
        uint64_t result = "BadState";
        break;
      case -65541:
        uint64_t result = "BadReference";
        break;
      case -65540:
        uint64_t result = "BadParam";
        break;
      case -65539:
        uint64_t result = "NoMemory";
        break;
      case -65538:
        uint64_t result = "NoSuchName";
        break;
      default:
        if (a1) {
LABEL_7:
        }
          uint64_t result = "Unknown";
        else {
          uint64_t result = "NoError";
        }
        break;
    }
  }

  return result;
}

uint64_t nw_unordered_xpc_array_is_equal(xpc_object_t object1, xpc_object_t object2)
{
  BOOL v3 = object1 == object2;
  uint64_t result = object1 == object2;
  if (!v3 && object1 && object2)
  {
    if (xpc_equal(object1, object2))
    {
      return 1LL;
    }

    else
    {
      Class Class = object_getClass(object1);
      unint64_t v7 = (objc_class *)MEMORY[0x1895F9220];
      if (Class == (Class)MEMORY[0x1895F9220]
        && object_getClass(object2) == v7
        && (size_t count = xpc_array_get_count(object1), xpc_array_get_count(object2) == count))
      {
        return nw_unordered_xpc_array_is_equal_inner(object1, object2, count);
      }

      else
      {
        return 0LL;
      }
    }
  }

  return result;
}

uint64_t nw_unordered_xpc_array_is_equal_inner(xpc_object_t xarray, void *a2, size_t a3)
{
  if (!a3) {
    return 1LL;
  }
  size_t v6 = 0LL;
  while (2)
  {
    xpc_object_t value = xpc_array_get_value(xarray, v6);
    size_t v8 = 0LL;
    while (1)
    {
      xpc_object_t v9 = xpc_array_get_value(a2, v8);
      if (v9)
      {
        if (xpc_equal(value, v9)) {
          break;
        }
      }

      if (a3 == ++v8)
      {
        char v15 = 0;
        return v15 & 1;
      }
    }

    if (++v6 != a3) {
      continue;
    }
    break;
  }

  BOOL v10 = 0;
  size_t v11 = 0LL;
  while (2)
  {
    xpc_object_t v12 = xpc_array_get_value(a2, v11);
    size_t v13 = 0LL;
    while (1)
    {
      xpc_object_t v14 = xpc_array_get_value(xarray, v13);
      if (v14)
      {
        if (xpc_equal(v12, v14)) {
          break;
        }
      }

      if (a3 == ++v13)
      {
        char v15 = v10;
        return v15 & 1;
      }
    }

    ++v11;
    char v15 = 1;
    BOOL v10 = v11 >= a3;
    if (v11 != a3) {
      continue;
    }
    break;
  }

  return v15 & 1;
}

BOOL nw_dispatch_data_is_equal(dispatch_data_t data, dispatch_data_s *a2)
{
  BOOL v2 = data == a2;
  if (data != a2 && data && a2)
  {
    size_t size = dispatch_data_get_size(data);
    if (size == dispatch_data_get_size(a2))
    {
      uint64_t v8 = 0LL;
      xpc_object_t v9 = &v8;
      uint64_t v10 = 0x2000000000LL;
      char v11 = 1;
      v7[0] = MEMORY[0x1895F87A8];
      v7[1] = 0x40000000LL;
      v7[2] = __nw_dispatch_data_is_equal_block_invoke;
      v7[3] = &unk_189BBF650;
      v7[4] = &v8;
      void v7[5] = a2;
      dispatch_data_apply(data, v7);
      BOOL v2 = *((_BYTE *)v9 + 24) != 0;
      _Block_object_dispose(&v8, 8);
    }

    else
    {
      return 0LL;
    }
  }

  return v2;
}

uint64_t __nw_dispatch_data_is_equal_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 0x40000000LL;
  v8[2] = __nw_dispatch_data_is_equal_block_invoke_2;
  v8[3] = &unk_189BBF628;
  size_t v6 = *(dispatch_data_s **)(a1 + 40);
  void v8[4] = *(void *)(a1 + 32);
  v8[5] = a3;
  v8[6] = a5;
  v8[7] = a4;
  dispatch_data_apply(v6, v8);
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
}

BOOL __nw_dispatch_data_is_equal_block_invoke_2( void *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v7 = a1[5];
  uint64_t v6 = a1[6];
  if (v7 <= a3) {
    unint64_t v8 = a3;
  }
  else {
    unint64_t v8 = a1[5];
  }
  unint64_t v9 = v6 + v7;
  if (v6 + v7 >= a5 + a3) {
    unint64_t v10 = a5 + a3;
  }
  else {
    unint64_t v10 = v6 + v7;
  }
  BOOL v11 = v10 > v8;
  size_t v12 = v10 - v8;
  if (v11)
  {
    *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) = memcmp( (const void *)(a4 + v8 - a3),  (const void *)(a1[7] + v8 - v7),  v12) == 0;
  }

  else
  {
    if (v9 < a3) {
      return 0LL;
    }
    if (a5 + a3 < v7) {
      return 1LL;
    }
  }

  return *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) != 0;
}

uint64_t __nw_dictionary_dispose_block_invoke()
{
  pointer = (void *)xpc_dictionary_get_pointer();
  return 1LL;
}

uint64_t nw_dictionary_copy(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v17 = "nw_dictionary_copy";
    unsigned int v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v17 = "nw_dictionary_copy";
      unint64_t v7 = "%{public}s called with null dictionary";
      goto LABEL_19;
    }

    if (!v14)
    {
      unint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v17 = "nw_dictionary_copy";
      unint64_t v7 = "%{public}s called with null dictionary, backtrace limit exceeded";
      goto LABEL_19;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v12 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (!v12) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v17 = "nw_dictionary_copy";
      unint64_t v7 = "%{public}s called with null dictionary, no backtrace";
      goto LABEL_19;
    }

    if (!v12) {
      goto LABEL_14;
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v17 = "nw_dictionary_copy";
    __int16 v18 = 2082;
    unint64_t v19 = backtrace_string;
    unint64_t v10 = "%{public}s called with null dictionary, dumping backtrace:%{public}s";
    goto LABEL_13;
  }

  if (!*(void *)(a1 + 16))
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v17 = "nw_dictionary_copy";
    unsigned int v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v17 = "nw_dictionary_copy";
      unint64_t v7 = "%{public}s called with null dictionary->xpc_object";
      goto LABEL_19;
    }

    if (!v14)
    {
      unint64_t v5 = (os_log_s *)__nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v17 = "nw_dictionary_copy";
      unint64_t v7 = "%{public}s called with null dictionary->xpc_object, backtrace limit exceeded";
      goto LABEL_19;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v5 = (os_log_s *)__nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v13 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (!v13) {
        goto LABEL_20;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v17 = "nw_dictionary_copy";
      unint64_t v7 = "%{public}s called with null dictionary->xpc_object, no backtrace";
      goto LABEL_19;
    }

    if (!v13) {
      goto LABEL_14;
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v17 = "nw_dictionary_copy";
    __int16 v18 = 2082;
    unint64_t v19 = backtrace_string;
    unint64_t v10 = "%{public}s called with null dictionary->xpc_object, dumping backtrace:%{public}s";
    goto LABEL_13;
  }

  objc_opt_class();
  uint64_t v2 = _os_object_alloc();
  if (v2)
  {
    uint64_t v3 = v2;
    *(void *)(v2 + 16) = xpc_copy(*(xpc_object_t *)(a1 + 16));
    xpc_dictionary_apply(*(xpc_object_t *)(a1 + 16), &__block_literal_global_48067);
    return v3;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v17 = "nw_dictionary_copy";
  unsigned int v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v5 = (os_log_s *)gLogObj;
    os_log_type_t v6 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v17 = "nw_dictionary_copy";
      unint64_t v7 = "%{public}s nw_dictionary_obj_alloc failed";
LABEL_19:
      _os_log_impl(&dword_181A5C000, v5, v6, v7, buf, 0xCu);
      goto LABEL_20;
    }

    goto LABEL_20;
  }

  if (v14)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v5 = (os_log_s *)gLogObj;
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_dictionary_copy";
        unint64_t v7 = "%{public}s nw_dictionary_obj_alloc failed, no backtrace";
        goto LABEL_19;
      }

      goto LABEL_20;
    }

    if (!v9)
    {
LABEL_14:
      free(backtrace_string);
      goto LABEL_20;
    }

    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v17 = "nw_dictionary_copy";
    __int16 v18 = 2082;
    unint64_t v19 = backtrace_string;
    unint64_t v10 = "%{public}s nw_dictionary_obj_alloc failed, dumping backtrace:%{public}s";
LABEL_13:
    _os_log_impl(&dword_181A5C000, v5, v6, v10, buf, 0x16u);
    goto LABEL_14;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unint64_t v5 = (os_log_s *)gLogObj;
  os_log_type_t v6 = type;
  if (os_log_type_enabled((os_log_t)gLogObj, type))
  {
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v17 = "nw_dictionary_copy";
    unint64_t v7 = "%{public}s nw_dictionary_obj_alloc failed, backtrace limit exceeded";
    goto LABEL_19;
  }

uint64_t __nw_dictionary_copy_block_invoke()
{
  xpc_object_t value = (void *)xpc_pointer_get_value();
  if (value) {
    os_retain(value);
  }
  return 1LL;
}

BOOL NWPBHostEndpointReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x189611CF0];
  uint64_t v4 = (int)*MEMORY[0x189611CF0];
  unint64_t v5 = *(void *)(a2 + v4);
  os_log_type_t v6 = (int *)MEMORY[0x189611CE8];
  unint64_t v7 = *(void *)(a2 + (int)*MEMORY[0x189611CE8]);
  unint64_t v8 = (int *)MEMORY[0x189611CE0];
  if (v5 < v7)
  {
    unint64_t v10 = (int *)MEMORY[0x189611CD8];
    while (1)
    {
      char v14 = (_BYTE *)(a2 + *v8);
      if (*v14) {
        return *(_BYTE *)(a2 + *v8) == 0;
      }
      if (v5 >= v7) {
        break;
      }
      char v15 = *(_BYTE *)(*(void *)(a2 + *v10) + v5);
      *(void *)(a2 + (int)v4) = v5 + 1;
      unint64_t v16 = v15 & 0x7F;
      if ((v15 & 0x80) == 0) {
        goto LABEL_40;
      }
      uint64_t v17 = *v3;
      unint64_t v18 = *(void *)(a2 + v17);
      if (v18 == -1LL || v18 >= *(void *)(a2 + *v6)) {
        goto LABEL_38;
      }
      unint64_t v19 = v18 + 1;
      int v20 = *(char *)(*(void *)(a2 + *v10) + v18);
      *(void *)(a2 + v17) = v19;
      v16 |= (unint64_t)(v20 & 0x7F) << 7;
      if ((v20 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      uint64_t v21 = *v3;
      unint64_t v22 = *(void *)(a2 + v21);
      if (v22 == -1LL || v22 >= *(void *)(a2 + *v6)) {
        goto LABEL_38;
      }
      unint64_t v23 = v22 + 1;
      int v24 = *(char *)(*(void *)(a2 + *v10) + v22);
      *(void *)(a2 + v21) = v23;
      v16 |= (unint64_t)(v24 & 0x7F) << 14;
      if ((v24 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      uint64_t v25 = *v3;
      unint64_t v26 = *(void *)(a2 + v25);
      if (v26 == -1LL || v26 >= *(void *)(a2 + *v6)) {
        goto LABEL_38;
      }
      unint64_t v27 = v26 + 1;
      int v28 = *(char *)(*(void *)(a2 + *v10) + v26);
      *(void *)(a2 + v25) = v27;
      v16 |= (unint64_t)(v28 & 0x7F) << 21;
      if ((v28 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      uint64_t v29 = *v3;
      unint64_t v30 = *(void *)(a2 + v29);
      if (v30 == -1LL || v30 >= *(void *)(a2 + *v6)) {
        goto LABEL_38;
      }
      unint64_t v31 = v30 + 1;
      int v32 = *(char *)(*(void *)(a2 + *v10) + v30);
      *(void *)(a2 + v29) = v31;
      v16 |= (unint64_t)(v32 & 0x7F) << 28;
      if ((v32 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      uint64_t v33 = *v3;
      unint64_t v34 = *(void *)(a2 + v33);
      if (v34 == -1LL || v34 >= *(void *)(a2 + *v6)) {
        goto LABEL_38;
      }
      unint64_t v35 = v34 + 1;
      int v36 = *(char *)(*(void *)(a2 + *v10) + v34);
      *(void *)(a2 + v33) = v35;
      if ((v36 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      uint64_t v37 = *v3;
      unint64_t v38 = *(void *)(a2 + v37);
      if (v38 == -1LL || v38 >= *(void *)(a2 + *v6)) {
        goto LABEL_38;
      }
      unint64_t v39 = v38 + 1;
      int v40 = *(char *)(*(void *)(a2 + *v10) + v38);
      *(void *)(a2 + v37) = v39;
      if ((v40 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      uint64_t v41 = *v3;
      unint64_t v42 = *(void *)(a2 + v41);
      if (v42 == -1LL || v42 >= *(void *)(a2 + *v6)) {
        goto LABEL_38;
      }
      unint64_t v43 = v42 + 1;
      int v44 = *(char *)(*(void *)(a2 + *v10) + v42);
      *(void *)(a2 + v41) = v43;
      if ((v44 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      uint64_t v45 = *v3;
      unint64_t v46 = *(void *)(a2 + v45);
      if (v46 == -1LL || v46 >= *(void *)(a2 + *v6)) {
        goto LABEL_38;
      }
      unint64_t v47 = v46 + 1;
      int v48 = *(char *)(*(void *)(a2 + *v10) + v46);
      *(void *)(a2 + v45) = v47;
      if ((v48 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      uint64_t v49 = *v3;
      unint64_t v50 = *(void *)(a2 + v49);
      if (v50 == -1LL || v50 >= *(void *)(a2 + *v6))
      {
LABEL_38:
        char v14 = (_BYTE *)(a2 + *v8);
        goto LABEL_39;
      }

      unint64_t v51 = v50 + 1;
      int v52 = *(char *)(*(void *)(a2 + *v10) + v50);
      *(void *)(a2 + v49) = v51;
      if (v52 < 0)
      {
        unint64_t v16 = 0LL;
        int v53 = *(unsigned __int8 *)(a2 + *v8);
        goto LABEL_42;
      }

BOOL nw_http_get_binary_message_length(nw_protocol_metadata *a1, unint64_t a2)
{
  return nw_http_get_binary_message_length_inner(a1, 0, a2);
}

BOOL nw_http_get_binary_message_length_inner(nw_protocol_metadata *a1, int a2, unint64_t a3)
{
  uint64_t v73 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
    unint64_t v43 = (char *)_os_log_send_and_compose_impl();
    v65[0] = 16;
    v63[0] = 0;
    if (v65[0] == 17)
    {
      int v44 = (os_log_s *)__nwlog_obj();
      os_log_type_t v45 = v65[0];
      if (os_log_type_enabled(v44, (os_log_type_t)v65[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
        unint64_t v46 = "%{public}s called with null metadata";
LABEL_89:
        _os_log_impl(&dword_181A5C000, v44, v45, v46, buf, 0xCu);
      }

void ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke( uint64_t a1, char *__s)
{
  if (!__s)
  {
    size_t v4 = 0LL;
    uint64_t v5 = 1LL;
    goto LABEL_13;
  }

  size_t v3 = strlen(__s);
  size_t v4 = v3;
  if (v3 < 0x40)
  {
    uint64_t v5 = 1LL;
LABEL_13:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v5;
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v4;
    return;
  }

  if (v3 < 0x4000)
  {
    uint64_t v5 = 2LL;
    goto LABEL_13;
  }

  if (!(v3 >> 30))
  {
    uint64_t v5 = 4LL;
    goto LABEL_13;
  }

  if (!(v3 >> 62))
  {
    uint64_t v5 = 8LL;
    goto LABEL_13;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  os_log_type_t v6 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v6))
  {
    free(v6);
    uint64_t v5 = 0LL;
    goto LABEL_13;
  }

  __break(1u);
}

void ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke_2( uint64_t a1, char *__s)
{
  if (!__s)
  {
    size_t v4 = 0LL;
    uint64_t v5 = 1LL;
    goto LABEL_13;
  }

  size_t v3 = strlen(__s);
  size_t v4 = v3;
  if (v3 < 0x40)
  {
    uint64_t v5 = 1LL;
LABEL_13:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v5;
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v4;
    return;
  }

  if (v3 < 0x4000)
  {
    uint64_t v5 = 2LL;
    goto LABEL_13;
  }

  if (!(v3 >> 30))
  {
    uint64_t v5 = 4LL;
    goto LABEL_13;
  }

  if (!(v3 >> 62))
  {
    uint64_t v5 = 8LL;
    goto LABEL_13;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  os_log_type_t v6 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v6))
  {
    free(v6);
    uint64_t v5 = 0LL;
    goto LABEL_13;
  }

  __break(1u);
}

void ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke_3( uint64_t a1, char *__s)
{
  if (!__s)
  {
    size_t v4 = 0LL;
    uint64_t v5 = 1LL;
    goto LABEL_13;
  }

  size_t v3 = strlen(__s);
  size_t v4 = v3;
  if (v3 < 0x40)
  {
    uint64_t v5 = 1LL;
LABEL_13:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v5;
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v4;
    return;
  }

  if (v3 < 0x4000)
  {
    uint64_t v5 = 2LL;
    goto LABEL_13;
  }

  if (!(v3 >> 30))
  {
    uint64_t v5 = 4LL;
    goto LABEL_13;
  }

  if (!(v3 >> 62))
  {
    uint64_t v5 = 8LL;
    goto LABEL_13;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  os_log_type_t v6 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v6))
  {
    free(v6);
    uint64_t v5 = 0LL;
    goto LABEL_13;
  }

  __break(1u);
}

void ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke_4( uint64_t a1, char *__s)
{
  if (!__s)
  {
    size_t v4 = 0LL;
    uint64_t v5 = 1LL;
    goto LABEL_13;
  }

  size_t v3 = strlen(__s);
  size_t v4 = v3;
  if (v3 < 0x40)
  {
    uint64_t v5 = 1LL;
LABEL_13:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v5;
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += v4;
    return;
  }

  if (v3 < 0x4000)
  {
    uint64_t v5 = 2LL;
    goto LABEL_13;
  }

  if (!(v3 >> 30))
  {
    uint64_t v5 = 4LL;
    goto LABEL_13;
  }

  if (!(v3 >> 62))
  {
    uint64_t v5 = 8LL;
    goto LABEL_13;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  os_log_type_t v6 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v6))
  {
    free(v6);
    uint64_t v5 = 0LL;
    goto LABEL_13;
  }

  __break(1u);
}

BOOL ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke_5( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a3 < 0x40)
  {
    uint64_t v8 = 1LL;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
LABEL_12:
    uint64_t v9 = 1LL;
LABEL_23:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += a5 + a3 + v8 + v9;
    return 1LL;
  }

  if (a3 < 0x4000)
  {
    uint64_t v8 = 2LL;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }

  if (!(a3 >> 30))
  {
    uint64_t v8 = 4LL;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }

  if (a3 >> 62)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    unint64_t v10 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v10);
    if (result) {
      goto LABEL_24;
    }
    free(v10);
    uint64_t v8 = 0LL;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }

  else
  {
    uint64_t v8 = 8LL;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }

BOOL ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke_6( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a3 < 0x40)
  {
    uint64_t v8 = 1LL;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
LABEL_12:
    uint64_t v9 = 1LL;
LABEL_23:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += a5 + a3 + v8 + v9;
    return 1LL;
  }

  if (a3 < 0x4000)
  {
    uint64_t v8 = 2LL;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }

  if (!(a3 >> 30))
  {
    uint64_t v8 = 4LL;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }

  if (a3 >> 62)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    unint64_t v10 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v10);
    if (result) {
      goto LABEL_24;
    }
    free(v10);
    uint64_t v8 = 0LL;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }

  else
  {
    uint64_t v8 = 8LL;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }

BOOL nw_http_get_indeterminate_binary_message_header_length(nw_protocol_metadata *a1)
{
  return nw_http_get_binary_message_length_inner(a1, 1, 0LL);
}

unint64_t nw_http_get_indeterminate_binary_message_chunk_length( unint64_t result, int a2, void *a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (result)
  {
    unint64_t v5 = result;
    if (result >= 0x40)
    {
      if (result >= 0x4000)
      {
        if (result >> 30)
        {
          if (result >> 62)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
            *(_DWORD *)uint64_t v12 = 136446466;
            *(void *)&void v12[4] = "_http_vle_length";
            *(_WORD *)&v12[12] = 2048;
            *(void *)&v12[14] = v5;
            uint64_t v7 = (void *)_os_log_send_and_compose_impl();
            BOOL result = __nwlog_abort((uint64_t)v7);
            if ((_DWORD)result)
            {
              __break(1u);
              return result;
            }

            free(v7);
            uint64_t v6 = 0LL;
          }

          else
          {
            uint64_t v6 = 8LL;
          }
        }

        else
        {
          uint64_t v6 = 4LL;
        }
      }

      else
      {
        uint64_t v6 = 2LL;
      }
    }

    else
    {
      uint64_t v6 = 1LL;
    }

    BOOL result = v6 + v5;
  }

  if (a2)
  {
    unint64_t v8 = result + 1;
    if (a3)
    {
      *(void *)uint64_t v12 = 0LL;
      *(void *)&v12[8] = v12;
      *(void *)&v12[16] = 0x2000000000LL;
      uint64_t v13 = 0LL;
      v11[0] = MEMORY[0x1895F87A8];
      v11[1] = 0x40000000LL;
      v11[2] = __nw_http_get_indeterminate_binary_message_chunk_length_block_invoke;
      v11[3] = &unk_189BBF728;
      void v11[4] = v12;
      id v9 = a3;
      unint64_t v10 = v11;
      _nw_http_fields_enumerate((uint64_t)v9, v10);

      v8 += *(void *)(*(void *)&v12[8] + 24LL);
      _Block_object_dispose(v12, 8);
    }

    return v8 + 1;
  }

  return result;
}

BOOL __nw_http_get_indeterminate_binary_message_chunk_length_block_invoke( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a3 < 0x40)
  {
    uint64_t v8 = 1LL;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
LABEL_12:
    uint64_t v9 = 1LL;
LABEL_23:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += a5 + a3 + v8 + v9;
    return 1LL;
  }

  if (a3 < 0x4000)
  {
    uint64_t v8 = 2LL;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }

  if (!(a3 >> 30))
  {
    uint64_t v8 = 4LL;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }

  if (a3 >> 62)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    unint64_t v10 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v10);
    if (result) {
      goto LABEL_24;
    }
    free(v10);
    uint64_t v8 = 0LL;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }

  else
  {
    uint64_t v8 = 8LL;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }

BOOL nw_http_fillout_binary_message( nw_protocol_metadata *a1, const unsigned __int8 *a2, size_t a3, unsigned __int8 *a4, uint64_t a5)
{
  return nw_http_fillout_binary_message_inner(a1, 0, a2, a3, a4, a5);
}

BOOL nw_http_fillout_binary_message_inner( nw_protocol_metadata *a1, int a2, const unsigned __int8 *a3, size_t a4, unsigned __int8 *a5, uint64_t a6)
{
  uint64_t v212 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v205 = "nw_http_fillout_binary_message_inner";
    uint64_t v66 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v19_Block_object_dispose((const void *)(v50 - 136), 8) = 16;
    LOBYTE(v194) = 0;
    if (v198 != 17)
    {
      if (!(_BYTE)v194)
      {
        char v67 = (os_log_s *)__nwlog_obj();
        os_log_type_t v68 = v198;
        if (os_log_type_enabled(v67, (os_log_type_t)v198))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v205 = "nw_http_fillout_binary_message_inner";
          int v69 = "%{public}s called with null metadata, backtrace limit exceeded";
          goto LABEL_352;
        }

        goto LABEL_353;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      char v67 = (os_log_s *)__nwlog_obj();
      os_log_type_t v68 = v198;
      BOOL v75 = os_log_type_enabled(v67, (os_log_type_t)v198);
      if (!backtrace_string)
      {
        if (v75)
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v205 = "nw_http_fillout_binary_message_inner";
          int v69 = "%{public}s called with null metadata, no backtrace";
          goto LABEL_352;
        }

        goto LABEL_353;
      }

      if (!v75) {
        goto LABEL_189;
      }
      *(_DWORD *)__int128 buf = 136446466;
      int v205 = "nw_http_fillout_binary_message_inner";
      __int16 v206 = 2082;
      int v207 = backtrace_string;
      unsigned int v76 = "%{public}s called with null metadata, dumping backtrace:%{public}s";
      goto LABEL_188;
    }

    char v67 = (os_log_s *)__nwlog_obj();
    os_log_type_t v68 = v198;
    if (!os_log_type_enabled(v67, (os_log_type_t)v198)) {
      goto LABEL_353;
    }
    *(_DWORD *)__int128 buf = 136446210;
    int v205 = "nw_http_fillout_binary_message_inner";
    int v69 = "%{public}s called with null metadata";
LABEL_352:
    _os_log_impl(&dword_181A5C000, v67, v68, v69, buf, 0xCu);
    goto LABEL_353;
  }

  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v205 = "nw_http_fillout_binary_message_inner";
    uint64_t v66 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v19_Block_object_dispose((const void *)(v50 - 136), 8) = 16;
    LOBYTE(v194) = 0;
    if (v198 != 17)
    {
      if (!(_BYTE)v194)
      {
        char v67 = (os_log_s *)__nwlog_obj();
        os_log_type_t v68 = v198;
        if (os_log_type_enabled(v67, (os_log_type_t)v198))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v205 = "nw_http_fillout_binary_message_inner";
          int v69 = "%{public}s called with null buffer, backtrace limit exceeded";
          goto LABEL_352;
        }

        goto LABEL_353;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      char v67 = (os_log_s *)__nwlog_obj();
      os_log_type_t v68 = v198;
      BOOL v77 = os_log_type_enabled(v67, (os_log_type_t)v198);
      if (!backtrace_string)
      {
        if (v77)
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v205 = "nw_http_fillout_binary_message_inner";
          int v69 = "%{public}s called with null buffer, no backtrace";
          goto LABEL_352;
        }

        goto LABEL_353;
      }

      if (!v77) {
        goto LABEL_189;
      }
      *(_DWORD *)__int128 buf = 136446466;
      int v205 = "nw_http_fillout_binary_message_inner";
      __int16 v206 = 2082;
      int v207 = backtrace_string;
      unsigned int v76 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
      goto LABEL_188;
    }

    char v67 = (os_log_s *)__nwlog_obj();
    os_log_type_t v68 = v198;
    if (!os_log_type_enabled(v67, (os_log_type_t)v198)) {
      goto LABEL_353;
    }
    *(_DWORD *)__int128 buf = 136446210;
    int v205 = "nw_http_fillout_binary_message_inner";
    int v69 = "%{public}s called with null buffer";
    goto LABEL_352;
  }

  if (!a4) {
    goto LABEL_6;
  }
  if (a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v205 = "nw_http_fillout_binary_message_inner";
    uint64_t v66 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v19_Block_object_dispose((const void *)(v50 - 136), 8) = 16;
    LOBYTE(v194) = 0;
    if (v198 == 17)
    {
      char v67 = (os_log_s *)__nwlog_obj();
      os_log_type_t v68 = v198;
      if (!os_log_type_enabled(v67, (os_log_type_t)v198)) {
        goto LABEL_353;
      }
      *(_DWORD *)__int128 buf = 136446210;
      int v205 = "nw_http_fillout_binary_message_inner";
      int v69 = "%{public}s called with null (!indeterminate)";
      goto LABEL_352;
    }

    if (!(_BYTE)v194)
    {
      char v67 = (os_log_s *)__nwlog_obj();
      os_log_type_t v68 = v198;
      if (os_log_type_enabled(v67, (os_log_type_t)v198))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v205 = "nw_http_fillout_binary_message_inner";
        int v69 = "%{public}s called with null (!indeterminate), backtrace limit exceeded";
        goto LABEL_352;
      }

      goto LABEL_353;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    char v67 = (os_log_s *)__nwlog_obj();
    os_log_type_t v68 = v198;
    BOOL v102 = os_log_type_enabled(v67, (os_log_type_t)v198);
    if (!backtrace_string)
    {
      if (v102)
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v205 = "nw_http_fillout_binary_message_inner";
        int v69 = "%{public}s called with null (!indeterminate), no backtrace";
        goto LABEL_352;
      }

      goto LABEL_353;
    }

    if (!v102) {
      goto LABEL_189;
    }
    *(_DWORD *)__int128 buf = 136446466;
    int v205 = "nw_http_fillout_binary_message_inner";
    __int16 v206 = 2082;
    int v207 = backtrace_string;
    unsigned int v76 = "%{public}s called with null (!indeterminate), dumping backtrace:%{public}s";
LABEL_188:
    _os_log_impl(&dword_181A5C000, v67, v68, v76, buf, 0x16u);
    goto LABEL_189;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v205 = "nw_http_fillout_binary_message_inner";
    uint64_t v66 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v19_Block_object_dispose((const void *)(v50 - 136), 8) = 16;
    LOBYTE(v194) = 0;
    if (v198 == 17)
    {
      char v67 = (os_log_s *)__nwlog_obj();
      os_log_type_t v68 = v198;
      if (os_log_type_enabled(v67, (os_log_type_t)v198))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v205 = "nw_http_fillout_binary_message_inner";
        int v69 = "%{public}s called with null body_content";
        goto LABEL_352;
      }

LABEL_461:
                  free(v98);
                  goto LABEL_462;
                }

                if (v141)
                {
                  *(_DWORD *)__int128 buf = 136446210;
                  int v205 = "_http_safe_append";
                  int v101 = "%{public}s called with null (*remaining >= length), no backtrace";
LABEL_459:
                  _os_log_impl(&dword_181A5C000, v99, v100, v101, buf, 0xCu);
                }
              }
            }

            else
            {
              __nwlog_obj();
              *(_DWORD *)__int128 buf = 136446210;
              int v205 = "_http_safe_append";
              int v98 = (void *)_os_log_send_and_compose_impl();
              type[0] = OS_LOG_TYPE_ERROR;
              v178[0] = OS_LOG_TYPE_DEFAULT;
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                unsigned int v99 = (os_log_s *)__nwlog_obj();
                os_log_type_t v100 = type[0];
                if (!os_log_type_enabled(v99, type[0])) {
                  goto LABEL_460;
                }
                *(_DWORD *)__int128 buf = 136446210;
                int v205 = "_http_safe_append";
                int v101 = "%{public}s called with null data";
                goto LABEL_459;
              }

              if (v178[0] == OS_LOG_TYPE_DEFAULT)
              {
                unsigned int v99 = (os_log_s *)__nwlog_obj();
                os_log_type_t v100 = type[0];
                if (!os_log_type_enabled(v99, type[0])) {
                  goto LABEL_460;
                }
                *(_DWORD *)__int128 buf = 136446210;
                int v205 = "_http_safe_append";
                int v101 = "%{public}s called with null data, backtrace limit exceeded";
                goto LABEL_459;
              }

              int v136 = (char *)__nw_create_backtrace_string();
              unsigned int v99 = (os_log_s *)__nwlog_obj();
              os_log_type_t v100 = type[0];
              BOOL v137 = os_log_type_enabled(v99, type[0]);
              if (!v136)
              {
                if (!v137) {
                  goto LABEL_460;
                }
                *(_DWORD *)__int128 buf = 136446210;
                int v205 = "_http_safe_append";
                int v101 = "%{public}s called with null data, no backtrace";
                goto LABEL_459;
              }

              if (v137)
              {
                *(_DWORD *)__int128 buf = 136446466;
                int v205 = "_http_safe_append";
                __int16 v206 = 2082;
                int v207 = v136;
                _os_log_impl( &dword_181A5C000,  v99,  v100,  "%{public}s called with null data, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v136);
            }

LABEL_508:
    if (!v132) {
      goto LABEL_510;
    }
    goto LABEL_509;
  }

  *(void *)int type = 0LL;
  int v181 = type;
  uint64_t v182 = 0x2000000000LL;
  uint64_t v183 = 0LL;
  v179[0] = v15;
  v179[1] = 0x40000000LL;
  v179[2] = ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_27;
  v179[3] = &unk_189BBF9A8;
  v179[4] = type;
  id v50 = v49;
  unint64_t v51 = v179;
  _nw_http_fields_enumerate((uint64_t)v50, v51);

  unint64_t v52 = *((void *)v181 + 3);
  if (v52 <= 0x3F)
  {
    *(void *)int v178 = *((void *)v181 + 3);
    size_t v53 = 1LL;
    goto LABEL_88;
  }

  if (!(v52 >> 14))
  {
    *(void *)int v178 = bswap32(v52 | 0x4000) >> 16;
    size_t v53 = 2LL;
    goto LABEL_88;
  }

  if (!(v52 >> 30))
  {
    *(void *)int v178 = bswap32(v52 | 0x80000000);
    size_t v53 = 4LL;
    goto LABEL_88;
  }

  if (!(v52 >> 62))
  {
    *(void *)int v178 = bswap64(v52 | 0xC000000000000000LL);
    size_t v53 = 8LL;
LABEL_88:
    __int16 v57 = (char *)v199[3];
    if (v57)
    {
      size_t v58 = v195;
      if (v195[3] >= v53)
      {
        memcpy(v57, v178, v53);
        unint64_t v59 = v58[3];
        v58[3] = v59 - v53;
        if (v59 < v53)
        {
          if (gLogDatapath)
          {
            int v144 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v144, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v145 = v58[3];
              *(_DWORD *)__int128 buf = 136446978;
              int v205 = "_http_safe_append";
              __int16 v206 = 2082;
              int v207 = "*remaining";
              __int16 v208 = 2048;
              uint64_t v209 = v53;
              __int16 v210 = 2048;
              uint64_t v211 = v145;
              _os_log_impl( &dword_181A5C000,  v144,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
            }
          }

          v58[3] = 0LL;
        }

        v199[3] = (uint64_t)&v57[v53];
LABEL_94:
        v177[0] = v15;
        v177[1] = 0x40000000LL;
        v177[2] = ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_29;
        v177[3] = &unk_189BBF9F8;
        v177[4] = &v198;
        v177[5] = &v194;
        id v60 = v50;
        uint64_t v61 = v177;
        _nw_http_fields_enumerate_const_field((uint64_t)v60, v61);

        _Block_object_dispose(type, 8);
        os_release(v60);
        uint64_t v55 = 1LL;
        if (!v30) {
          goto LABEL_79;
        }
        goto LABEL_78;
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      int v205 = "_http_safe_append";
      int v104 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t v203 = OS_LOG_TYPE_ERROR;
      char v202 = 0;
      if (__nwlog_fault(v104, &v203, &v202))
      {
        if (v203 == OS_LOG_TYPE_FAULT)
        {
          int v105 = (os_log_s *)__nwlog_obj();
          os_log_type_t v106 = v203;
          if (!os_log_type_enabled(v105, v203)) {
            goto LABEL_483;
          }
          *(_DWORD *)__int128 buf = 136446210;
          int v205 = "_http_safe_append";
          unsigned int v107 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_482;
        }

        if (!v202)
        {
          int v105 = (os_log_s *)__nwlog_obj();
          os_log_type_t v106 = v203;
          if (!os_log_type_enabled(v105, v203)) {
            goto LABEL_483;
          }
          *(_DWORD *)__int128 buf = 136446210;
          int v205 = "_http_safe_append";
          unsigned int v107 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_482;
        }

        int v146 = (char *)__nw_create_backtrace_string();
        int v105 = (os_log_s *)__nwlog_obj();
        os_log_type_t v106 = v203;
        BOOL v147 = os_log_type_enabled(v105, v203);
        if (v146)
        {
          if (v147)
          {
            *(_DWORD *)__int128 buf = 136446466;
            int v205 = "_http_safe_append";
            __int16 v206 = 2082;
            int v207 = v146;
            _os_log_impl( &dword_181A5C000,  v105,  v106,  "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v146);
          if (!v104) {
            goto LABEL_485;
          }
          goto LABEL_484;
        }

        if (v147)
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v205 = "_http_safe_append";
          unsigned int v107 = "%{public}s called with null (*remaining >= length), no backtrace";
LABEL_482:
          _os_log_impl(&dword_181A5C000, v105, v106, v107, buf, 0xCu);
        }
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      int v205 = "_http_safe_append";
      int v104 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t v203 = OS_LOG_TYPE_ERROR;
      char v202 = 0;
      if (v203 == OS_LOG_TYPE_FAULT)
      {
        int v105 = (os_log_s *)__nwlog_obj();
        os_log_type_t v106 = v203;
        if (!os_log_type_enabled(v105, v203)) {
          goto LABEL_483;
        }
        *(_DWORD *)__int128 buf = 136446210;
        int v205 = "_http_safe_append";
        unsigned int v107 = "%{public}s called with null buffer";
        goto LABEL_482;
      }

      if (!v202)
      {
        int v105 = (os_log_s *)__nwlog_obj();
        os_log_type_t v106 = v203;
        if (!os_log_type_enabled(v105, v203)) {
          goto LABEL_483;
        }
        *(_DWORD *)__int128 buf = 136446210;
        int v205 = "_http_safe_append";
        unsigned int v107 = "%{public}s called with null buffer, backtrace limit exceeded";
        goto LABEL_482;
      }

      int v142 = (char *)__nw_create_backtrace_string();
      int v105 = (os_log_s *)__nwlog_obj();
      os_log_type_t v106 = v203;
      BOOL v143 = os_log_type_enabled(v105, v203);
      if (!v142)
      {
        if (!v143) {
          goto LABEL_483;
        }
        *(_DWORD *)__int128 buf = 136446210;
        int v205 = "_http_safe_append";
        unsigned int v107 = "%{public}s called with null buffer, no backtrace";
        goto LABEL_482;
      }

      if (v143)
      {
        *(_DWORD *)__int128 buf = 136446466;
        int v205 = "_http_safe_append";
        __int16 v206 = 2082;
        int v207 = v142;
        _os_log_impl( &dword_181A5C000,  v105,  v106,  "%{public}s called with null buffer, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v142);
    }

              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_http3_stream_send_fields";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = v316;
              __int16 v57 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
              goto LABEL_609;
            }

            goto LABEL_610;
          }

          goto LABEL_49;
        }

        goto LABEL_64;
      }

      size_t v58 = nw_http_metadata_copy_response(v19);
      if (v58)
      {
        unint64_t v59 = v58;
        unsigned int status_code = _nw_http_response_get_status_code();

        uint64_t v61 = *v6;
        unsigned int v62 = (v61 | (*(unsigned __int8 *)(a1 + 738) << 16)) & 0xFFFEFFFF;
        *uint64_t v6 = v61;
        *(_BYTE *)(a1 + 73_Block_object_dispose((const void *)(v50 - 136), 8) = (v62 | (((status_code - 100) < 0x64) << 16)) >> 16;
        unsigned int v63 = *(void **)(a1 + 400);
        if (v63)
        {
          unint64_t v36 = nw_http_metadata_copy_request(v63);
          os_release(v59);
          if (v36)
          {
LABEL_64:
            uint64_t v64 = v36;
            has_method = _nw_http_request_has_method((uint64_t)v64);

            int v369 = v17;
            if (has_method)
            {
              if (!nw_http_fields_have_field_with_name(v64, (unint64_t)"Datagram-Flow-Id"))
              {
                nw_protocol_http3_stream_start_datagram_flow(a1);
                *(void *)__int128 buf = 0LL;
                *(void *)&uint8_t buf[8] = 0LL;
                snprintf(buf, 0x10uLL, "%llu", *(void *)(a1 + 248));
                nw_http_fields_append(v64, (uint64_t)"Datagram-Flow-Id", (uint64_t)buf);
              }

              *v6 |= 0x8000u;
            }

            else if (nw_http_request_has_method(v64, (uint64_t)"CONNECT"))
            {
              uint64_t v70 = MEMORY[0x1895F87A8];
              v387[0] = MEMORY[0x1895F87A8];
              v387[1] = 0x40000000LL;
              v387[2] = ___ZL27nw_http3_stream_send_fieldsP24nw_protocol_http3_streamb_block_invoke;
              v387[3] = &__block_descriptor_tmp_97_61019;
              v387[4] = a1;
              nw_http_fields_access_value_by_name(v64, (unint64_t)"Capsule-Protocol", v387);
              *(void *)__int128 buf = 0LL;
              *(void *)&uint8_t buf[8] = buf;
              *(void *)&buf[16] = 0x2000000000LL;
              LOBYTE(v427) = 0;
              v386[0] = v70;
              v386[1] = 0x40000000LL;
              v386[2] = ___ZL27nw_http3_stream_send_fieldsP24nw_protocol_http3_streamb_block_invoke_2;
              v386[3] = &unk_189BC4410;
              v386[4] = buf;
              nw_http_request_access_extended_connect_protocol(v64, v386);
              if (*(_BYTE *)(*(void *)&buf[8] + 24LL))
              {
                *(void *)(a1 + 256) = nw_http_metadata_get_datagram_context_id(v19);
                nw_protocol_http3_stream_start_datagram_flow(a1);
              }

              *v6 |= 0x8000u;
              _Block_object_dispose(buf, 8);
            }

LABEL_483:
    if (!v104)
    {
LABEL_485:
      v199[3] = 0LL;
      goto LABEL_486;
    }

LABEL_484:
    free(v104);
    goto LABEL_485;
  }

  uint64_t v64 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v64, OS_LOG_TYPE_ERROR);
  *(_DWORD *)__int128 buf = 136446466;
  int v205 = "_http_vle_encode";
  __int16 v206 = 2048;
  int v207 = (const char *)v52;
  int v65 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v65);
  if (!result)
  {
    free(v65);
    if (v199[3]) {
      goto LABEL_94;
    }
LABEL_486:
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v205 = "nw_http_fillout_binary_message_inner";
    int v169 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v203 = OS_LOG_TYPE_ERROR;
    char v202 = 0;
    if (__nwlog_fault(v169, &v203, &v202))
    {
      if (v203 == OS_LOG_TYPE_FAULT)
      {
        int v170 = (os_log_s *)__nwlog_obj();
        os_log_type_t v171 = v203;
        if (os_log_type_enabled(v170, v203))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v205 = "nw_http_fillout_binary_message_inner";
          unsigned int v172 = "%{public}s called with null cursor";
LABEL_499:
          _os_log_impl(&dword_181A5C000, v170, v171, v172, buf, 0xCu);
        }
      }

      else if (v202)
      {
        int v173 = (char *)__nw_create_backtrace_string();
        int v170 = (os_log_s *)__nwlog_obj();
        os_log_type_t v171 = v203;
        BOOL v174 = os_log_type_enabled(v170, v203);
        if (v173)
        {
          if (v174)
          {
            *(_DWORD *)__int128 buf = 136446466;
            int v205 = "nw_http_fillout_binary_message_inner";
            __int16 v206 = 2082;
            int v207 = v173;
            _os_log_impl( &dword_181A5C000,  v170,  v171,  "%{public}s called with null cursor, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v173);
          goto LABEL_500;
        }

        if (v174)
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v205 = "nw_http_fillout_binary_message_inner";
          unsigned int v172 = "%{public}s called with null cursor, no backtrace";
          goto LABEL_499;
        }
      }

      else
      {
        int v170 = (os_log_s *)__nwlog_obj();
        os_log_type_t v171 = v203;
        if (os_log_type_enabled(v170, v203))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v205 = "nw_http_fillout_binary_message_inner";
          unsigned int v172 = "%{public}s called with null cursor, backtrace limit exceeded";
          goto LABEL_499;
        }
      }
    }

LABEL_500:
    if (v169) {
      free(v169);
    }
    _Block_object_dispose(type, 8);
    os_release(v50);
    goto LABEL_527;
  }
    }

void ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke( uint64_t a1, char *__s)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  if (!__s)
  {
    size_t v5 = 0LL;
    goto LABEL_6;
  }

  size_t v4 = strlen(__s);
  size_t v5 = v4;
  if (v4 <= 0x3F)
  {
LABEL_6:
    unint64_t __src = v5;
    size_t v6 = 1LL;
    goto LABEL_7;
  }

  if (!(v4 >> 14))
  {
    unint64_t __src = bswap32(v4 | 0x4000) >> 16;
    size_t v6 = 2LL;
    goto LABEL_7;
  }

  if (!(v4 >> 30))
  {
    unint64_t __src = bswap32(v4 | 0x80000000);
    size_t v6 = 4LL;
    goto LABEL_7;
  }

  if (!(v4 >> 62))
  {
    unint64_t __src = bswap64(v4 | 0xC000000000000000LL);
    size_t v6 = 8LL;
LABEL_7:
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v7 = (void *)(a1 + 32);
    uint64_t v9 = *(char **)(*(void *)(v8 + 8) + 24LL);
    unint64_t v10 = v7 + 1;
    if (v9)
    {
      uint64_t v11 = *(void *)(v7[1] + 8LL);
      if (*(void *)(v11 + 24) >= v6)
      {
        memcpy(v9, &__src, v6);
        unint64_t v12 = *(void *)(v11 + 24);
        *(void *)(v11 + 24) = v12 - v6;
        if (v12 < v6)
        {
          if (gLogDatapath)
          {
            unint64_t v38 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v39 = *(void *)(v11 + 24);
              *(_DWORD *)__int128 buf = 136446978;
              unint64_t v51 = "_http_safe_append";
              __int16 v52 = 2082;
              size_t v53 = "*remaining";
              __int16 v54 = 2048;
              size_t v55 = v6;
              __int16 v56 = 2048;
              uint64_t v57 = v39;
              _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
            }
          }

          *(void *)(v11 + 24) = 0LL;
        }

        BOOL v13 = &v9[v6];
        goto LABEL_13;
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      unint64_t v51 = "_http_safe_append";
      unint64_t v23 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          unint64_t v26 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      if (!v48)
      {
        id v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          unint64_t v26 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      id v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v40 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          unint64_t v26 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      if (v40)
      {
        *(_DWORD *)__int128 buf = 136446466;
        unint64_t v51 = "_http_safe_append";
        __int16 v52 = 2082;
        size_t v53 = backtrace_string;
        uint64_t v37 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_74;
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      unint64_t v51 = "_http_safe_append";
      unint64_t v23 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          unint64_t v26 = "%{public}s called with null buffer";
LABEL_111:
          _os_log_impl(&dword_181A5C000, v24, v25, v26, buf, 0xCu);
        }

void ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_16( uint64_t a1, char *__s)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  if (!__s)
  {
    size_t v5 = 0LL;
    goto LABEL_6;
  }

  size_t v4 = strlen(__s);
  size_t v5 = v4;
  if (v4 <= 0x3F)
  {
LABEL_6:
    unint64_t __src = v5;
    size_t v6 = 1LL;
    goto LABEL_7;
  }

  if (!(v4 >> 14))
  {
    unint64_t __src = bswap32(v4 | 0x4000) >> 16;
    size_t v6 = 2LL;
    goto LABEL_7;
  }

  if (!(v4 >> 30))
  {
    unint64_t __src = bswap32(v4 | 0x80000000);
    size_t v6 = 4LL;
    goto LABEL_7;
  }

  if (!(v4 >> 62))
  {
    unint64_t __src = bswap64(v4 | 0xC000000000000000LL);
    size_t v6 = 8LL;
LABEL_7:
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v7 = (void *)(a1 + 32);
    uint64_t v9 = *(char **)(*(void *)(v8 + 8) + 24LL);
    unint64_t v10 = v7 + 1;
    if (v9)
    {
      uint64_t v11 = *(void *)(v7[1] + 8LL);
      if (*(void *)(v11 + 24) >= v6)
      {
        memcpy(v9, &__src, v6);
        unint64_t v12 = *(void *)(v11 + 24);
        *(void *)(v11 + 24) = v12 - v6;
        if (v12 < v6)
        {
          if (gLogDatapath)
          {
            unint64_t v38 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v39 = *(void *)(v11 + 24);
              *(_DWORD *)__int128 buf = 136446978;
              unint64_t v51 = "_http_safe_append";
              __int16 v52 = 2082;
              size_t v53 = "*remaining";
              __int16 v54 = 2048;
              size_t v55 = v6;
              __int16 v56 = 2048;
              uint64_t v57 = v39;
              _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
            }
          }

          *(void *)(v11 + 24) = 0LL;
        }

        BOOL v13 = &v9[v6];
        goto LABEL_13;
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      unint64_t v51 = "_http_safe_append";
      unint64_t v23 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          unint64_t v26 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      if (!v48)
      {
        id v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          unint64_t v26 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      id v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v40 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          unint64_t v26 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      if (v40)
      {
        *(_DWORD *)__int128 buf = 136446466;
        unint64_t v51 = "_http_safe_append";
        __int16 v52 = 2082;
        size_t v53 = backtrace_string;
        uint64_t v37 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_74;
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      unint64_t v51 = "_http_safe_append";
      unint64_t v23 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          unint64_t v26 = "%{public}s called with null buffer";
LABEL_111:
          _os_log_impl(&dword_181A5C000, v24, v25, v26, buf, 0xCu);
        }

void ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_18( uint64_t a1, char *__s)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  if (!__s)
  {
    size_t v5 = 0LL;
    goto LABEL_6;
  }

  size_t v4 = strlen(__s);
  size_t v5 = v4;
  if (v4 <= 0x3F)
  {
LABEL_6:
    unint64_t __src = v5;
    size_t v6 = 1LL;
    goto LABEL_7;
  }

  if (!(v4 >> 14))
  {
    unint64_t __src = bswap32(v4 | 0x4000) >> 16;
    size_t v6 = 2LL;
    goto LABEL_7;
  }

  if (!(v4 >> 30))
  {
    unint64_t __src = bswap32(v4 | 0x80000000);
    size_t v6 = 4LL;
    goto LABEL_7;
  }

  if (!(v4 >> 62))
  {
    unint64_t __src = bswap64(v4 | 0xC000000000000000LL);
    size_t v6 = 8LL;
LABEL_7:
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v7 = (void *)(a1 + 32);
    uint64_t v9 = *(char **)(*(void *)(v8 + 8) + 24LL);
    unint64_t v10 = v7 + 1;
    if (v9)
    {
      uint64_t v11 = *(void *)(v7[1] + 8LL);
      if (*(void *)(v11 + 24) >= v6)
      {
        memcpy(v9, &__src, v6);
        unint64_t v12 = *(void *)(v11 + 24);
        *(void *)(v11 + 24) = v12 - v6;
        if (v12 < v6)
        {
          if (gLogDatapath)
          {
            unint64_t v38 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v39 = *(void *)(v11 + 24);
              *(_DWORD *)__int128 buf = 136446978;
              unint64_t v51 = "_http_safe_append";
              __int16 v52 = 2082;
              size_t v53 = "*remaining";
              __int16 v54 = 2048;
              size_t v55 = v6;
              __int16 v56 = 2048;
              uint64_t v57 = v39;
              _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
            }
          }

          *(void *)(v11 + 24) = 0LL;
        }

        BOOL v13 = &v9[v6];
        goto LABEL_13;
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      unint64_t v51 = "_http_safe_append";
      unint64_t v23 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          unint64_t v26 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      if (!v48)
      {
        id v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          unint64_t v26 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      id v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v40 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          unint64_t v26 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      if (v40)
      {
        *(_DWORD *)__int128 buf = 136446466;
        unint64_t v51 = "_http_safe_append";
        __int16 v52 = 2082;
        size_t v53 = backtrace_string;
        uint64_t v37 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_74;
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      unint64_t v51 = "_http_safe_append";
      unint64_t v23 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          unint64_t v26 = "%{public}s called with null buffer";
LABEL_111:
          _os_log_impl(&dword_181A5C000, v24, v25, v26, buf, 0xCu);
        }

void ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_20( uint64_t a1, char *__s)
{
  uint64_t v58 = *MEMORY[0x1895F89C0];
  if (!__s)
  {
    size_t v5 = 0LL;
    goto LABEL_6;
  }

  size_t v4 = strlen(__s);
  size_t v5 = v4;
  if (v4 <= 0x3F)
  {
LABEL_6:
    unint64_t __src = v5;
    size_t v6 = 1LL;
    goto LABEL_7;
  }

  if (!(v4 >> 14))
  {
    unint64_t __src = bswap32(v4 | 0x4000) >> 16;
    size_t v6 = 2LL;
    goto LABEL_7;
  }

  if (!(v4 >> 30))
  {
    unint64_t __src = bswap32(v4 | 0x80000000);
    size_t v6 = 4LL;
    goto LABEL_7;
  }

  if (!(v4 >> 62))
  {
    unint64_t __src = bswap64(v4 | 0xC000000000000000LL);
    size_t v6 = 8LL;
LABEL_7:
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v7 = (void *)(a1 + 32);
    uint64_t v9 = *(char **)(*(void *)(v8 + 8) + 24LL);
    unint64_t v10 = v7 + 1;
    if (v9)
    {
      uint64_t v11 = *(void *)(v7[1] + 8LL);
      if (*(void *)(v11 + 24) >= v6)
      {
        memcpy(v9, &__src, v6);
        unint64_t v12 = *(void *)(v11 + 24);
        *(void *)(v11 + 24) = v12 - v6;
        if (v12 < v6)
        {
          if (gLogDatapath)
          {
            unint64_t v38 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v39 = *(void *)(v11 + 24);
              *(_DWORD *)__int128 buf = 136446978;
              unint64_t v51 = "_http_safe_append";
              __int16 v52 = 2082;
              size_t v53 = "*remaining";
              __int16 v54 = 2048;
              size_t v55 = v6;
              __int16 v56 = 2048;
              uint64_t v57 = v39;
              _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
            }
          }

          *(void *)(v11 + 24) = 0LL;
        }

        BOOL v13 = &v9[v6];
        goto LABEL_13;
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      unint64_t v51 = "_http_safe_append";
      unint64_t v23 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          unint64_t v26 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      if (!v48)
      {
        id v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          unint64_t v26 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      id v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v40 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          unint64_t v26 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_111;
        }

        goto LABEL_112;
      }

      if (v40)
      {
        *(_DWORD *)__int128 buf = 136446466;
        unint64_t v51 = "_http_safe_append";
        __int16 v52 = 2082;
        size_t v53 = backtrace_string;
        uint64_t v37 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_74;
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      unint64_t v51 = "_http_safe_append";
      unint64_t v23 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          unint64_t v26 = "%{public}s called with null buffer";
LABEL_111:
          _os_log_impl(&dword_181A5C000, v24, v25, v26, buf, 0xCu);
        }

BOOL ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_22( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a3 < 0x40)
  {
    uint64_t v8 = 1LL;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
LABEL_12:
    uint64_t v9 = 1LL;
LABEL_23:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += a5 + a3 + v8 + v9;
    return 1LL;
  }

  if (a3 < 0x4000)
  {
    uint64_t v8 = 2LL;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }

  if (!(a3 >> 30))
  {
    uint64_t v8 = 4LL;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }

  if (a3 >> 62)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    unint64_t v10 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v10);
    if (result) {
      goto LABEL_24;
    }
    free(v10);
    uint64_t v8 = 0LL;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }

  else
  {
    uint64_t v8 = 8LL;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }

uint64_t ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_24( uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  v4[2] = ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_2;
  v4[3] = &unk_189BBF958;
  __int128 v5 = *(_OWORD *)(a1 + 32);
  nw_http_field_access_canonical(a3, v4);
  return 1LL;
}

BOOL ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_27( uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a3 < 0x40)
  {
    uint64_t v8 = 1LL;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
LABEL_12:
    uint64_t v9 = 1LL;
LABEL_23:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += a5 + a3 + v8 + v9;
    return 1LL;
  }

  if (a3 < 0x4000)
  {
    uint64_t v8 = 2LL;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }

  if (!(a3 >> 30))
  {
    uint64_t v8 = 4LL;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }

  if (a3 >> 62)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    unint64_t v10 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v10);
    if (result) {
      goto LABEL_24;
    }
    free(v10);
    uint64_t v8 = 0LL;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }

  else
  {
    uint64_t v8 = 8LL;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }

uint64_t ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_29( uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  v4[2] = ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_2_30;
  v4[3] = &unk_189BBF9D0;
  __int128 v5 = *(_OWORD *)(a1 + 32);
  nw_http_field_access_canonical(a3, v4);
  return 1LL;
}

void ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_2_30( uint64_t a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  uint64_t v90 = *MEMORY[0x1895F89C0];
  if (a3 <= 0x3F)
  {
    unint64_t __src = a3;
    size_t v10 = 1LL;
    goto LABEL_9;
  }

  if (!(a3 >> 14))
  {
    unint64_t __src = bswap32(a3 | 0x4000) >> 16;
    size_t v10 = 2LL;
    goto LABEL_9;
  }

  if (!(a3 >> 30))
  {
    unint64_t __src = bswap32(a3 | 0x80000000);
    size_t v10 = 4LL;
    goto LABEL_9;
  }

  if (!(a3 >> 62))
  {
    unint64_t __src = bswap64(a3 | 0xC000000000000000LL);
    size_t v10 = 8LL;
LABEL_9:
    uint64_t v11 = a1 + 32;
    unint64_t v12 = *(char **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    uint64_t v13 = a1 + 40;
    if (v12)
    {
      uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 8LL);
      if (*(void *)(v14 + 24) >= v10)
      {
        memcpy(v12, &__src, v10);
        unint64_t v15 = *(void *)(v14 + 24);
        *(void *)(v14 + 24) = v15 - v10;
        if (v15 < v10)
        {
          if (gLogDatapath)
          {
            id v60 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v61 = *(void *)(v14 + 24);
              *(_DWORD *)__int128 buf = 136446978;
              unsigned int v83 = "_http_safe_append";
              __int16 v84 = 2082;
              int v85 = "*remaining";
              __int16 v86 = 2048;
              size_t v87 = v10;
              __int16 v88 = 2048;
              uint64_t v89 = v61;
              _os_log_impl( &dword_181A5C000,  v60,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
            }
          }

          *(void *)(v14 + 24) = 0LL;
        }

        unint64_t v16 = &v12[v10];
        goto LABEL_15;
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v83 = "_http_safe_append";
      unint64_t v35 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v80 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v36 = (os_log_s *)__nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v83 = "_http_safe_append";
          unint64_t v38 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_194;
        }

        goto LABEL_195;
      }

      if (!v80)
      {
        BOOL v36 = (os_log_s *)__nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v83 = "_http_safe_append";
          unint64_t v38 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_194;
        }

        goto LABEL_195;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v36 = (os_log_s *)__nwlog_obj();
      os_log_type_t v37 = type;
      BOOL v62 = os_log_type_enabled(v36, type);
      if (!backtrace_string)
      {
        if (v62)
        {
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v83 = "_http_safe_append";
          unint64_t v38 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_194;
        }

        goto LABEL_195;
      }

      if (v62)
      {
        *(_DWORD *)__int128 buf = 136446466;
        unsigned int v83 = "_http_safe_append";
        __int16 v84 = 2082;
        int v85 = backtrace_string;
        unint64_t v59 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_124;
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v83 = "_http_safe_append";
      unint64_t v35 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v80 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v36 = (os_log_s *)__nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v83 = "_http_safe_append";
          unint64_t v38 = "%{public}s called with null buffer";
LABEL_194:
          _os_log_impl(&dword_181A5C000, v36, v37, v38, buf, 0xCu);
        }

void ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_2( uint64_t a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  uint64_t v90 = *MEMORY[0x1895F89C0];
  if (a3 <= 0x3F)
  {
    unint64_t __src = a3;
    size_t v10 = 1LL;
    goto LABEL_9;
  }

  if (!(a3 >> 14))
  {
    unint64_t __src = bswap32(a3 | 0x4000) >> 16;
    size_t v10 = 2LL;
    goto LABEL_9;
  }

  if (!(a3 >> 30))
  {
    unint64_t __src = bswap32(a3 | 0x80000000);
    size_t v10 = 4LL;
    goto LABEL_9;
  }

  if (!(a3 >> 62))
  {
    unint64_t __src = bswap64(a3 | 0xC000000000000000LL);
    size_t v10 = 8LL;
LABEL_9:
    uint64_t v11 = a1 + 32;
    unint64_t v12 = *(char **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    uint64_t v13 = a1 + 40;
    if (v12)
    {
      uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 8LL);
      if (*(void *)(v14 + 24) >= v10)
      {
        memcpy(v12, &__src, v10);
        unint64_t v15 = *(void *)(v14 + 24);
        *(void *)(v14 + 24) = v15 - v10;
        if (v15 < v10)
        {
          if (gLogDatapath)
          {
            id v60 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v61 = *(void *)(v14 + 24);
              *(_DWORD *)__int128 buf = 136446978;
              unsigned int v83 = "_http_safe_append";
              __int16 v84 = 2082;
              int v85 = "*remaining";
              __int16 v86 = 2048;
              size_t v87 = v10;
              __int16 v88 = 2048;
              uint64_t v89 = v61;
              _os_log_impl( &dword_181A5C000,  v60,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
            }
          }

          *(void *)(v14 + 24) = 0LL;
        }

        unint64_t v16 = &v12[v10];
        goto LABEL_15;
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v83 = "_http_safe_append";
      unint64_t v35 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v80 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v36 = (os_log_s *)__nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v83 = "_http_safe_append";
          unint64_t v38 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_194;
        }

        goto LABEL_195;
      }

      if (!v80)
      {
        BOOL v36 = (os_log_s *)__nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v83 = "_http_safe_append";
          unint64_t v38 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_194;
        }

        goto LABEL_195;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v36 = (os_log_s *)__nwlog_obj();
      os_log_type_t v37 = type;
      BOOL v62 = os_log_type_enabled(v36, type);
      if (!backtrace_string)
      {
        if (v62)
        {
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v83 = "_http_safe_append";
          unint64_t v38 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_194;
        }

        goto LABEL_195;
      }

      if (v62)
      {
        *(_DWORD *)__int128 buf = 136446466;
        unsigned int v83 = "_http_safe_append";
        __int16 v84 = 2082;
        int v85 = backtrace_string;
        unint64_t v59 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_124;
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v83 = "_http_safe_append";
      unint64_t v35 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v80 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v36 = (os_log_s *)__nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v83 = "_http_safe_append";
          unint64_t v38 = "%{public}s called with null buffer";
LABEL_194:
          _os_log_impl(&dword_181A5C000, v36, v37, v38, buf, 0xCu);
        }

BOOL nw_http_fillout_indeterminate_binary_message_header( nw_protocol_metadata *a1, unsigned __int8 *a2, uint64_t a3)
{
  return nw_http_fillout_binary_message_inner(a1, 1, 0LL, 0LL, a2, a3);
}

BOOL nw_http_fillout_indeterminate_binary_message_body_chunk( const void *a1, size_t a2, int a3, void *a4, char *__dst, unint64_t a6)
{
  uint64_t v98 = *MEMORY[0x1895F89C0];
  if (!__dst)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
    BOOL v34 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v80) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      unint64_t v35 = (os_log_s *)__nwlog_obj();
      os_log_type_t v36 = type[0];
      if (os_log_type_enabled(v35, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unsigned int v91 = "nw_http_fillout_indeterminate_binary_message_body_chunk";
        os_log_type_t v37 = "%{public}s called with null buffer";
LABEL_176:
        _os_log_impl(&dword_181A5C000, v35, v36, v37, buf, 0xCu);
      }

uint64_t __nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke( uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 0x40000000LL;
  v4[2] = __nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke_2;
  v4[3] = &unk_189BBF750;
  __int128 v5 = *(_OWORD *)(a1 + 32);
  nw_http_field_access_canonical(a3, v4);
  return 1LL;
}

void __nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke_2( uint64_t a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  uint64_t v90 = *MEMORY[0x1895F89C0];
  if (a3 <= 0x3F)
  {
    unint64_t __src = a3;
    size_t v10 = 1LL;
    goto LABEL_9;
  }

  if (!(a3 >> 14))
  {
    unint64_t __src = bswap32(a3 | 0x4000) >> 16;
    size_t v10 = 2LL;
    goto LABEL_9;
  }

  if (!(a3 >> 30))
  {
    unint64_t __src = bswap32(a3 | 0x80000000);
    size_t v10 = 4LL;
    goto LABEL_9;
  }

  if (!(a3 >> 62))
  {
    unint64_t __src = bswap64(a3 | 0xC000000000000000LL);
    size_t v10 = 8LL;
LABEL_9:
    uint64_t v11 = a1 + 32;
    unint64_t v12 = *(char **)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL);
    uint64_t v13 = a1 + 40;
    if (v12)
    {
      uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 8LL);
      if (*(void *)(v14 + 24) >= v10)
      {
        memcpy(v12, &__src, v10);
        unint64_t v15 = *(void *)(v14 + 24);
        *(void *)(v14 + 24) = v15 - v10;
        if (v15 < v10)
        {
          if (gLogDatapath)
          {
            id v60 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v61 = *(void *)(v14 + 24);
              *(_DWORD *)__int128 buf = 136446978;
              unint64_t v83 = "_http_safe_append";
              __int16 v84 = 2082;
              int v85 = "*remaining";
              __int16 v86 = 2048;
              size_t v87 = v10;
              __int16 v88 = 2048;
              uint64_t v89 = v61;
              _os_log_impl( &dword_181A5C000,  v60,  OS_LOG_TYPE_DEBUG,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu",  buf,  0x2Au);
            }
          }

          *(void *)(v14 + 24) = 0LL;
        }

        unint64_t v16 = &v12[v10];
        goto LABEL_15;
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      unint64_t v83 = "_http_safe_append";
      unint64_t v35 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v80 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v36 = (os_log_s *)__nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v83 = "_http_safe_append";
          unint64_t v38 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_194;
        }

        goto LABEL_195;
      }

      if (!v80)
      {
        os_log_type_t v36 = (os_log_s *)__nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v83 = "_http_safe_append";
          unint64_t v38 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_194;
        }

        goto LABEL_195;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v36 = (os_log_s *)__nwlog_obj();
      os_log_type_t v37 = type;
      BOOL v62 = os_log_type_enabled(v36, type);
      if (!backtrace_string)
      {
        if (v62)
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v83 = "_http_safe_append";
          unint64_t v38 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_194;
        }

        goto LABEL_195;
      }

      if (v62)
      {
        *(_DWORD *)__int128 buf = 136446466;
        unint64_t v83 = "_http_safe_append";
        __int16 v84 = 2082;
        int v85 = backtrace_string;
        uint64_t v59 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_124;
      }
    }

    else
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      unint64_t v83 = "_http_safe_append";
      unint64_t v35 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v80 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v36 = (os_log_s *)__nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unint64_t v83 = "_http_safe_append";
          unint64_t v38 = "%{public}s called with null buffer";
LABEL_194:
          _os_log_impl(&dword_181A5C000, v36, v37, v38, buf, 0xCu);
        }

id *nw_http_copy_metadata_from_binary_message( _DWORD *a1, unint64_t a2, unint64_t *a3, BOOL *a4)
{
  uint64_t v213 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
    BOOL v102 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v201 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v201)
      {
        BOOL v103 = (os_log_s *)__nwlog_obj();
        os_log_type_t v104 = type;
        if (!os_log_type_enabled(v103, type)) {
          goto LABEL_368;
        }
        *(_DWORD *)__int128 buf = 136446210;
        unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
        int v105 = "%{public}s called with null buffer, backtrace limit exceeded";
        goto LABEL_367;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v103 = (os_log_s *)__nwlog_obj();
      os_log_type_t v104 = type;
      BOOL v111 = os_log_type_enabled(v103, type);
      if (!backtrace_string)
      {
        if (!v111) {
          goto LABEL_368;
        }
        *(_DWORD *)__int128 buf = 136446210;
        unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
        int v105 = "%{public}s called with null buffer, no backtrace";
        goto LABEL_367;
      }

      if (v111)
      {
        *(_DWORD *)__int128 buf = 136446466;
        unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
        __int16 v205 = 2082;
        __int16 v206 = backtrace_string;
        BOOL v112 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_306:
        _os_log_impl(&dword_181A5C000, v103, v104, v112, buf, 0x16u);
      }

LABEL_377:
        uint64_t v18 = (os_log_s *)__nwlog_obj();
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          goto LABEL_27;
        }
        *(_DWORD *)__int128 buf = 136446210;
        unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
        unint64_t v19 = "%{public}s Failed to decode integer";
        goto LABEL_25;
      }

      if (v77 < 8) {
        goto LABEL_377;
      }
      unint64_t v27 = bswap64(*(void *)v106 & 0xFFFFFFFFFFFFFF3FLL);
      uint64_t v107 = 8LL;
    }

    if (v27 >= 0x10000)
    {
      id v30 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
      goto LABEL_515;
    }

    if (v205) {
      free(v205);
    }
    goto LABEL_247;
  }

  __nwlog_obj();
  unsigned int v184 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v184, OS_LOG_TYPE_ERROR);
  *(_DWORD *)__int128 buf = 136446722;
  *(void *)&uint8_t buf[4] = "strict_calloc";
  *(_WORD *)&_BYTE buf[12] = 2048;
  *(void *)&buf[14] = 1LL;
  *(_WORD *)&buf[22] = 2048;
  *(void *)&_BYTE buf[24] = 16LL;
  LODWORD(v200) = 32;
  os_log_type_t v199 = buf;
  int v185 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v185))
  {
    free(v185);
    uint32_t v118 = v219;
    goto LABEL_192;
  }

  __break(1u);
}
      }
    }
  }

  else
  {
  }
}

LABEL_505:
        uint64_t v18 = (os_log_s *)__nwlog_obj();
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          goto LABEL_27;
        }
        *(_DWORD *)__int128 buf = 136446210;
        unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
        unint64_t v19 = "%{public}s Failed to decode integer";
        goto LABEL_25;
      }

      if (v126 < 8) {
        goto LABEL_505;
      }
      unint64_t v27 = bswap64(*(void *)v136 & 0xFFFFFFFFFFFFFF3FLL);
      uint64_t v137 = 8LL;
    }

    if (v27 < 0x10000)
    {
LABEL_402:
      unint64_t v29 = v126 - v137;
      if (v27 > v29)
      {
        id v30 = (os_log_s *)__nwlog_obj();
        if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
          goto LABEL_27;
        }
LABEL_404:
        *(_DWORD *)__int128 buf = 136446722;
        unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
        __int16 v205 = 2048;
        __int16 v206 = (const char *)v27;
        __int16 v207 = 2048;
        uint64_t v208 = v29;
        unint64_t v19 = "%{public}s _length %llu > remaining %zu";
        goto LABEL_172;
      }

      os_log_type_t v161 = &v136[v137];
      uint64_t v200 = &v161[v27];
      unint64_t v26 = v29 - v27;
      if (v29 >= v27)
      {
        os_log_type_t v25 = &v161[v27];
        goto LABEL_64;
      }

      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446978;
      unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
      __int16 v205 = 2082;
      __int16 v206 = "remaining";
      __int16 v207 = 2048;
      uint64_t v208 = v27;
      __int16 v209 = 2048;
      unint64_t v210 = v29 - v27;
      int v162 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v201 = 0;
      if (__nwlog_fault(v162, &type, &v201))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          unsigned int v163 = (os_log_s *)__nwlog_obj();
          os_log_type_t v164 = type;
          if (os_log_type_enabled(v163, type))
          {
            *(_DWORD *)__int128 buf = 136446978;
            unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
            __int16 v205 = 2082;
            __int16 v206 = "remaining";
            __int16 v207 = 2048;
            uint64_t v208 = v27;
            __int16 v209 = 2048;
            unint64_t v210 = v26;
            int v165 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_556:
            int v179 = v163;
            os_log_type_t v180 = v164;
LABEL_557:
            _os_log_impl(&dword_181A5C000, v179, v180, v165, buf, 0x2Au);
          }
        }

        else if (v201)
        {
          unsigned int v176 = (char *)__nw_create_backtrace_string();
          int v177 = (os_log_s *)__nwlog_obj();
          os_log_type_t v199 = type;
          BOOL v178 = os_log_type_enabled(v177, type);
          if (v176)
          {
            if (v178)
            {
              *(_DWORD *)__int128 buf = 136447234;
              unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
              __int16 v205 = 2082;
              __int16 v206 = "remaining";
              __int16 v207 = 2048;
              uint64_t v208 = v27;
              __int16 v209 = 2048;
              unint64_t v210 = v26;
              __int16 v211 = 2082;
              uint64_t v212 = v176;
              _os_log_impl( &dword_181A5C000,  v177,  v199,  "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s",  buf,  0x34u);
            }

            free(v176);
            goto LABEL_558;
          }

          if (v178)
          {
            *(_DWORD *)__int128 buf = 136446978;
            unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
            __int16 v205 = 2082;
            __int16 v206 = "remaining";
            __int16 v207 = 2048;
            uint64_t v208 = v27;
            __int16 v209 = 2048;
            unint64_t v210 = v26;
            int v165 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
            int v179 = v177;
            os_log_type_t v180 = v199;
            goto LABEL_557;
          }
        }

        else
        {
          unsigned int v163 = (os_log_s *)__nwlog_obj();
          os_log_type_t v164 = type;
          if (os_log_type_enabled(v163, type))
          {
            *(_DWORD *)__int128 buf = 136446978;
            unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
            __int16 v205 = 2082;
            __int16 v206 = "remaining";
            __int16 v207 = 2048;
            uint64_t v208 = v27;
            __int16 v209 = 2048;
            unint64_t v210 = v26;
            int v165 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
            goto LABEL_556;
          }
        }
      }

LABEL_600:
                  _os_log_impl(&dword_181A5C000, v186, v187, v188, buf, 0xCu);
                  goto LABEL_601;
                }

                if (!v88) {
                  __int16 v88 = (void *)_nw_http_parsed_fields_create();
                }
                if (!v123)
                {
                  __nwlog_obj();
                  *(_DWORD *)__int128 buf = 136446210;
                  unsigned int v204 = "_http_vle_decode";
                  int v193 = (char *)_os_log_send_and_compose_impl();
                  os_log_type_t type = OS_LOG_TYPE_ERROR;
                  char v201 = 0;
                  if (type == OS_LOG_TYPE_FAULT)
                  {
                    uint64_t v194 = (os_log_s *)__nwlog_obj();
                    os_log_type_t v195 = type;
                    if (os_log_type_enabled(v194, type))
                    {
                      *(_DWORD *)__int128 buf = 136446210;
                      unsigned int v204 = "_http_vle_decode";
                      uint64_t v196 = "%{public}s called with null *buffer";
                      goto LABEL_613;
                    }

                    goto LABEL_614;
                  }

                  if (!v201)
                  {
                    uint64_t v194 = (os_log_s *)__nwlog_obj();
                    os_log_type_t v195 = type;
                    if (!os_log_type_enabled(v194, type)) {
                      goto LABEL_614;
                    }
                    *(_DWORD *)__int128 buf = 136446210;
                    unsigned int v204 = "_http_vle_decode";
                    uint64_t v196 = "%{public}s called with null *buffer, backtrace limit exceeded";
                    goto LABEL_613;
                  }

                  uint64_t v197 = (char *)__nw_create_backtrace_string();
                  uint64_t v194 = (os_log_s *)__nwlog_obj();
                  os_log_type_t v195 = type;
                  BOOL v198 = os_log_type_enabled(v194, type);
                  if (v197)
                  {
                    if (v198)
                    {
                      *(_DWORD *)__int128 buf = 136446466;
                      unsigned int v204 = "_http_vle_decode";
                      __int16 v205 = 2082;
                      __int16 v206 = v197;
                      _os_log_impl( &dword_181A5C000,  v194,  v195,  "%{public}s called with null *buffer, dumping backtrace:%{public}s",  buf,  0x16u);
                    }

                    free(v197);
                    goto LABEL_614;
                  }

                  if (v198)
                  {
                    *(_DWORD *)__int128 buf = 136446210;
                    unsigned int v204 = "_http_vle_decode";
                    uint64_t v196 = "%{public}s called with null *buffer, no backtrace";
LABEL_613:
                    _os_log_impl(&dword_181A5C000, v194, v195, v196, buf, 0xCu);
                  }
          }

LABEL_614:
                  if (v193) {
                    free(v193);
                  }
LABEL_616:
                  int v108 = (os_log_s *)__nwlog_obj();
                  if (!os_log_type_enabled(v108, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_552;
                  }
                  *(_DWORD *)__int128 buf = 136446210;
                  unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
                  BOOL v109 = "%{public}s Failed to decode integer";
LABEL_550:
                  int v116 = v108;
                  uint32_t v118 = 12;
LABEL_551:
                  _os_log_impl(&dword_181A5C000, v116, OS_LOG_TYPE_ERROR, v109, buf, v118);
                  goto LABEL_552;
                }

                if (!v124) {
                  goto LABEL_616;
                }
                unint64_t v89 = *(unsigned __int8 *)v123;
                if (v89 <= 0x3F)
                {
                  uint64_t v139 = 1LL;
                  goto LABEL_422;
                }

                if (v89 >> 6 == 2)
                {
                  if (v124 < 4) {
                    goto LABEL_616;
                  }
                  unint64_t v89 = bswap32(*(_DWORD *)v123 & 0xFFFFFF7F);
                  uint64_t v139 = 4LL;
LABEL_422:
                  unint64_t v140 = (unint64_t)&v123[v139];
                }

                else
                {
                  if (v89 >> 6 == 1)
                  {
                    if (v124 < 2) {
                      goto LABEL_616;
                    }
                    unint64_t v89 = bswap32(*(_WORD *)v123 & 0xFFBF) >> 16;
                    uint64_t v139 = 2LL;
                    goto LABEL_422;
                  }

                  if (v124 < 8) {
                    goto LABEL_616;
                  }
                  uint64_t v147 = *(void *)v123;
                  int v146 = v123 + 8;
                  unint64_t v89 = bswap64(v147 & 0xFFFFFFFFFFFFFF3FLL);
                  if (HIDWORD(v89))
                  {
                    int v114 = (os_log_s *)__nwlog_obj();
                    if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
                    {
LABEL_391:
                      *(_DWORD *)__int128 buf = 136446722;
                      unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
                      __int16 v205 = 2048;
                      __int16 v206 = (const char *)v89;
                      __int16 v207 = 2048;
                      uint64_t v208 = 0xFFFFFFFFLL;
                      BOOL v109 = "%{public}s _output %llu > _max %llu";
                      goto LABEL_310;
                    }

LABEL_552:
                    metadata_with_parsed_fields = 0LL;
                    if (!v88) {
                      goto LABEL_28;
                    }
LABEL_553:
                    os_release(v88);
                    goto LABEL_28;
                  }

                  uint64_t v139 = 8LL;
                  unint64_t v140 = (unint64_t)v146;
                }

                uint64_t v141 = v124 - v139;
                BOOL v33 = v124 - v139 >= v89;
                unint64_t v142 = v124 - v139 - v89;
                if (!v33)
                {
                  int v114 = (os_log_s *)__nwlog_obj();
                  if (!os_log_type_enabled(v114, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_552;
                  }
                  *(_DWORD *)__int128 buf = 136446722;
                  unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
                  __int16 v205 = 2048;
                  __int16 v206 = (const char *)v89;
                  __int16 v207 = 2048;
                  uint64_t v208 = v141;
                  BOOL v109 = "%{public}s _length %llu > remaining %zu";
LABEL_310:
                  int v116 = v114;
LABEL_314:
                  uint32_t v118 = 32;
                  goto LABEL_551;
                }

                if (!v142) {
                  goto LABEL_507;
                }
                BOOL v143 = (_DWORD *)(v140 + v89);
                unint64_t v144 = *(unsigned __int8 *)(v140 + v89);
                if (v144 <= 0x3F)
                {
                  uint64_t v145 = 1LL;
                  goto LABEL_437;
                }

                if (v144 >> 6 == 2)
                {
                  if (v142 < 4) {
                    goto LABEL_507;
                  }
                  unint64_t v144 = bswap32(*v143 & 0xFFFFFF7F);
                  uint64_t v145 = 4LL;
LABEL_437:
                  BOOL v148 = (char *)v143 + v145;
                }

                else
                {
                  if (v144 >> 6 == 1)
                  {
                    if (v142 < 2) {
                      goto LABEL_507;
                    }
                    unint64_t v144 = bswap32(*(_WORD *)v143 & 0xFFBF) >> 16;
                    uint64_t v145 = 2LL;
                    goto LABEL_437;
                  }

                  if (v142 < 8)
                  {
LABEL_507:
                    int v108 = (os_log_s *)__nwlog_obj();
                    if (!os_log_type_enabled(v108, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_552;
                    }
                    *(_DWORD *)__int128 buf = 136446210;
                    unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
                    BOOL v109 = "%{public}s Failed to decode integer";
                    goto LABEL_550;
                  }

                  uint64_t v150 = *(void *)v143;
                  BOOL v148 = (const char *)(v143 + 2);
                  unint64_t v144 = bswap64(v150 & 0xFFFFFFFFFFFFFF3FLL);
                  if (HIDWORD(v144))
                  {
                    BOOL v117 = (os_log_s *)__nwlog_obj();
                    if (!os_log_type_enabled(v117, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_552;
                    }
                    *(_DWORD *)__int128 buf = 136446722;
                    unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
                    __int16 v205 = 2048;
                    __int16 v206 = (const char *)v144;
                    __int16 v207 = 2048;
                    uint64_t v208 = 0xFFFFFFFFLL;
                    BOOL v109 = "%{public}s _output %llu > _max %llu";
                    goto LABEL_313;
                  }

                  uint64_t v145 = 8LL;
                }

                uint64_t v149 = v142 - v145;
                unint64_t v124 = v142 - v145 - v144;
                if (v142 - v145 < v144)
                {
                  BOOL v117 = (os_log_s *)__nwlog_obj();
                  if (!os_log_type_enabled(v117, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_552;
                  }
                  *(_DWORD *)__int128 buf = 136446722;
                  unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
                  __int16 v205 = 2048;
                  __int16 v206 = (const char *)v144;
                  __int16 v207 = 2048;
                  uint64_t v208 = v149;
                  BOOL v109 = "%{public}s _length %llu > remaining %zu";
LABEL_313:
                  int v116 = v117;
                  goto LABEL_314;
                }

                BOOL v123 = &v148[v144];
                if (!nw_http_parsed_fields_add(v88, v140, v89, v148, v144, 0)) {
                  goto LABEL_552;
                }
                continue;
              }
            }

            __nwlog_obj();
            *(_DWORD *)__int128 buf = 136446210;
            unsigned int v204 = "_http_vle_decode";
            int v181 = (char *)_os_log_send_and_compose_impl();
            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v201 = 0;
            if (type == OS_LOG_TYPE_FAULT)
            {
              uint64_t v182 = (os_log_s *)__nwlog_obj();
              os_log_type_t v183 = type;
              if (os_log_type_enabled(v182, type))
              {
                *(_DWORD *)__int128 buf = 136446210;
                unsigned int v204 = "_http_vle_decode";
                unsigned int v184 = "%{public}s called with null *buffer";
                goto LABEL_593;
              }

              goto LABEL_594;
            }

            if (v201)
            {
              uint64_t v189 = (char *)__nw_create_backtrace_string();
              uint64_t v182 = (os_log_s *)__nwlog_obj();
              os_log_type_t v183 = type;
              BOOL v190 = os_log_type_enabled(v182, type);
              if (v189)
              {
                if (v190)
                {
                  *(_DWORD *)__int128 buf = 136446466;
                  unsigned int v204 = "_http_vle_decode";
                  __int16 v205 = 2082;
                  __int16 v206 = v189;
                  _os_log_impl( &dword_181A5C000,  v182,  v183,  "%{public}s called with null *buffer, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v189);
                goto LABEL_594;
              }

              if (!v190)
              {
LABEL_594:
                if (v181) {
                  free(v181);
                }
                goto LABEL_361;
              }

              *(_DWORD *)__int128 buf = 136446210;
              unsigned int v204 = "_http_vle_decode";
              unsigned int v184 = "%{public}s called with null *buffer, no backtrace";
            }

            else
            {
              uint64_t v182 = (os_log_s *)__nwlog_obj();
              os_log_type_t v183 = type;
              if (!os_log_type_enabled(v182, type)) {
                goto LABEL_594;
              }
              *(_DWORD *)__int128 buf = 136446210;
              unsigned int v204 = "_http_vle_decode";
              unsigned int v184 = "%{public}s called with null *buffer, backtrace limit exceeded";
            }

LABEL_593:
            _os_log_impl(&dword_181A5C000, v182, v183, v184, buf, 0xCu);
            goto LABEL_594;
          }

          if (!v56)
          {
            __nwlog_obj();
            *(_DWORD *)__int128 buf = 136446210;
            unsigned int v204 = "_http_vle_decode";
            int v157 = (char *)_os_log_send_and_compose_impl();
            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v201 = 0;
            if (type == OS_LOG_TYPE_FAULT)
            {
              BOOL v158 = (os_log_s *)__nwlog_obj();
              os_log_type_t v159 = type;
              if (os_log_type_enabled(v158, type))
              {
                *(_DWORD *)__int128 buf = 136446210;
                unsigned int v204 = "_http_vle_decode";
                int v160 = "%{public}s called with null *buffer";
                goto LABEL_531;
              }

              goto LABEL_532;
            }

            if (!v201)
            {
              BOOL v158 = (os_log_s *)__nwlog_obj();
              os_log_type_t v159 = type;
              if (!os_log_type_enabled(v158, type)) {
                goto LABEL_532;
              }
              *(_DWORD *)__int128 buf = 136446210;
              unsigned int v204 = "_http_vle_decode";
              int v160 = "%{public}s called with null *buffer, backtrace limit exceeded";
              goto LABEL_531;
            }

            BOOL v167 = (char *)__nw_create_backtrace_string();
            BOOL v158 = (os_log_s *)__nwlog_obj();
            os_log_type_t v159 = type;
            BOOL v168 = os_log_type_enabled(v158, type);
            if (v167)
            {
              if (v168)
              {
                *(_DWORD *)__int128 buf = 136446466;
                unsigned int v204 = "_http_vle_decode";
                __int16 v205 = 2082;
                __int16 v206 = v167;
                _os_log_impl( &dword_181A5C000,  v158,  v159,  "%{public}s called with null *buffer, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(v167);
              goto LABEL_532;
            }

            if (v168)
            {
              *(_DWORD *)__int128 buf = 136446210;
              unsigned int v204 = "_http_vle_decode";
              int v160 = "%{public}s called with null *buffer, no backtrace";
LABEL_531:
              _os_log_impl(&dword_181A5C000, v158, v159, v160, buf, 0xCu);
            }

LABEL_532:
            if (v157) {
              free(v157);
            }
LABEL_534:
            uint64_t v18 = (os_log_s *)__nwlog_obj();
            if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
              goto LABEL_27;
            }
            *(_DWORD *)__int128 buf = 136446210;
            unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
            unint64_t v19 = "%{public}s Failed to decode integer";
LABEL_25:
            uint64_t v22 = v18;
            uint32_t v23 = 12;
            goto LABEL_26;
          }

          if (!v57) {
            goto LABEL_534;
          }
          unint64_t v54 = *(unsigned __int8 *)v56;
          if (v54 >> 6 == 2)
          {
            if (v57 < 4) {
              goto LABEL_534;
            }
            unint64_t v54 = bswap32(*(_DWORD *)v56 & 0xFFFFFF7F);
            uint64_t v61 = 4LL;
            goto LABEL_135;
          }

          if (v54 >> 6 == 1)
          {
            if (v57 < 2) {
              goto LABEL_534;
            }
            unint64_t v54 = bswap32(*(_WORD *)v56 & 0xFFBF) >> 16;
            uint64_t v61 = 2LL;
            goto LABEL_135;
          }

          if (v57 < 8) {
            goto LABEL_534;
          }
          uint64_t v68 = *(void *)v56;
          BOOL v67 = v56 + 8;
          unint64_t v54 = bswap64(v68 & 0xFFFFFFFFFFFFFF3FLL);
          if (HIDWORD(v54))
          {
            id v30 = (os_log_s *)__nwlog_obj();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
              goto LABEL_481;
            }
            goto LABEL_27;
          }

          uint64_t v61 = 8LL;
          unint64_t v62 = (unint64_t)v67;
LABEL_136:
          uint64_t v63 = v57 - v61;
          BOOL v33 = v57 - v61 >= v54;
          unint64_t v64 = v57 - v61 - v54;
          if (!v33)
          {
            id v30 = (os_log_s *)__nwlog_obj();
            if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
              goto LABEL_27;
            }
LABEL_233:
            *(_DWORD *)__int128 buf = 136446722;
            unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
            __int16 v205 = 2048;
            __int16 v206 = (const char *)v54;
            __int16 v207 = 2048;
            uint64_t v208 = v63;
            unint64_t v19 = "%{public}s _length %llu > remaining %zu";
            goto LABEL_172;
          }

          if (!v64) {
            goto LABEL_211;
          }
          uint64_t v65 = (_DWORD *)(v62 + v54);
          unint64_t v27 = *(unsigned __int8 *)(v62 + v54);
          if (v27 <= 0x3F)
          {
            uint64_t v66 = 1LL;
LABEL_150:
            int v69 = (char *)v65 + v66;
            goto LABEL_151;
          }

          if (v27 >> 6 == 2)
          {
            if (v64 < 4) {
              goto LABEL_211;
            }
            unint64_t v27 = bswap32(*v65 & 0xFFFFFF7F);
            uint64_t v66 = 4LL;
            goto LABEL_150;
          }

          if (v27 >> 6 == 1)
          {
            if (v64 < 2) {
              goto LABEL_211;
            }
            unint64_t v27 = bswap32(*(_WORD *)v65 & 0xFFBF) >> 16;
            uint64_t v66 = 2LL;
            goto LABEL_150;
          }

          if (v64 < 8)
          {
LABEL_211:
            uint64_t v18 = (os_log_s *)__nwlog_obj();
            if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
              goto LABEL_27;
            }
            *(_DWORD *)__int128 buf = 136446210;
            unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
            unint64_t v19 = "%{public}s Failed to decode integer";
            goto LABEL_25;
          }

          uint64_t v71 = *(void *)v65;
          int v69 = (const char *)(v65 + 2);
          unint64_t v27 = bswap64(v71 & 0xFFFFFFFFFFFFFF3FLL);
          if (HIDWORD(v27))
          {
            id v30 = (os_log_s *)__nwlog_obj();
            if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
              goto LABEL_27;
            }
LABEL_287:
            *(_DWORD *)__int128 buf = 136446722;
            unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
            __int16 v205 = 2048;
            __int16 v206 = (const char *)v27;
            __int16 v207 = 2048;
            uint64_t v208 = 0xFFFFFFFFLL;
            unint64_t v19 = "%{public}s _output %llu > _max %llu";
            goto LABEL_172;
          }

          uint64_t v66 = 8LL;
LABEL_151:
          unint64_t v29 = v64 - v66;
          unint64_t v57 = v64 - v66 - v27;
          if (v64 - v66 < v27)
          {
            id v30 = (os_log_s *)__nwlog_obj();
            if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
              goto LABEL_27;
            }
            goto LABEL_404;
          }

          BOOL v56 = &v69[v27];
          BOOL v70 = nw_http_parsed_fields_add(v17, v62, v54, v69, v27, 0);
          metadata_with_parsed_fields = 0LL;
          if (!v70) {
            goto LABEL_28;
          }
        }

        uint64_t v61 = 1LL;
LABEL_135:
        unint64_t v62 = (unint64_t)&v56[v61];
        goto LABEL_136;
      }

      if (v54 >> 6 == 2)
      {
        if (v26 >= 4)
        {
          unint64_t v54 = bswap32(*(_DWORD *)v25 & 0xFFFFFF7F);
          uint64_t v55 = 4LL;
          goto LABEL_102;
        }
      }

      else if (v54 >> 6 == 1)
      {
        if (v26 >= 2)
        {
          unint64_t v54 = bswap32(*(_WORD *)v25 & 0xFFBF) >> 16;
          uint64_t v55 = 2LL;
          goto LABEL_102;
        }
      }

      else if (v26 >= 8)
      {
        uint64_t v84 = *(void *)v25;
        BOOL v56 = v25 + 8;
        unint64_t v54 = bswap64(v84 & 0xFFFFFFFFFFFFFF3FLL);
        if (HIDWORD(v54))
        {
          id v30 = (os_log_s *)__nwlog_obj();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
            goto LABEL_481;
          }
          goto LABEL_27;
        }

        uint64_t v55 = 8LL;
        goto LABEL_103;
      }
    }

    uint64_t v18 = (os_log_s *)__nwlog_obj();
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      goto LABEL_27;
    }
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
    unint64_t v19 = "%{public}s Failed to decode integer";
    goto LABEL_25;
  }

  while (1)
  {
    if (!v26)
    {
      if (a4)
      {
LABEL_167:
        metadata_with_parsed_fields = nw_http_create_metadata_with_parsed_fields(v17, v15 == 0);
        goto LABEL_28;
      }

      unint64_t v74 = 0LL;
      unint64_t v75 = 0LL;
      goto LABEL_238;
    }

    if (!v25)
    {
      __nwlog_obj();
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v204 = "_http_vle_decode";
      int v132 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v201 = 0;
      if (__nwlog_fault(v132, &type, &v201))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          int v133 = (os_log_s *)__nwlog_obj();
          os_log_type_t v134 = type;
          if (os_log_type_enabled(v133, type))
          {
            *(_DWORD *)__int128 buf = 136446210;
            unsigned int v204 = "_http_vle_decode";
            unsigned int v135 = "%{public}s called with null *buffer";
LABEL_486:
            _os_log_impl(&dword_181A5C000, v133, v134, v135, buf, 0xCu);
          }
        }

        else if (v201)
        {
          int v153 = (char *)__nw_create_backtrace_string();
          int v133 = (os_log_s *)__nwlog_obj();
          os_log_type_t v134 = type;
          BOOL v154 = os_log_type_enabled(v133, type);
          if (v153)
          {
            if (v154)
            {
              *(_DWORD *)__int128 buf = 136446466;
              unsigned int v204 = "_http_vle_decode";
              __int16 v205 = 2082;
              __int16 v206 = v153;
              _os_log_impl( &dword_181A5C000,  v133,  v134,  "%{public}s called with null *buffer, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v153);
          }

          else if (v154)
          {
            *(_DWORD *)__int128 buf = 136446210;
            unsigned int v204 = "_http_vle_decode";
            unsigned int v135 = "%{public}s called with null *buffer, no backtrace";
            goto LABEL_486;
          }
        }

        else
        {
          int v133 = (os_log_s *)__nwlog_obj();
          os_log_type_t v134 = type;
          if (os_log_type_enabled(v133, type))
          {
            *(_DWORD *)__int128 buf = 136446210;
            unsigned int v204 = "_http_vle_decode";
            unsigned int v135 = "%{public}s called with null *buffer, backtrace limit exceeded";
            goto LABEL_486;
          }
        }
      }

      if (v132) {
        free(v132);
      }
LABEL_489:
      uint64_t v18 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
      unint64_t v19 = "%{public}s Failed to decode integer";
      goto LABEL_25;
    }

    unint64_t v27 = *(unsigned __int8 *)v25;
    if (v27 <= 0x3F)
    {
      uint64_t v41 = 1LL;
      goto LABEL_77;
    }

    if (v27 >> 6 == 2)
    {
      if (v26 < 4) {
        goto LABEL_489;
      }
      unint64_t v27 = bswap32(*(_DWORD *)v25 & 0xFFFFFF7F);
      uint64_t v41 = 4LL;
LABEL_77:
      BOOL v42 = &v25[v41];
      unint64_t v43 = v26 - v41;
      if (!v27) {
        break;
      }
      goto LABEL_78;
    }

    if (v27 >> 6 == 1)
    {
      if (v26 < 2) {
        goto LABEL_489;
      }
      unint64_t v27 = bswap32(*(_WORD *)v25 & 0xFFBF) >> 16;
      uint64_t v41 = 2LL;
      goto LABEL_77;
    }

    if (v26 < 8) {
      goto LABEL_489;
    }
    uint64_t v49 = *(void *)v25;
    char v48 = v25 + 8;
    unint64_t v27 = bswap64(v49 & 0xFFFFFFFFFFFFFF3FLL);
    if (HIDWORD(v27))
    {
      id v30 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
      goto LABEL_287;
    }

    BOOL v42 = v48;
    unint64_t v43 = v26 - 8;
    if (!v27) {
      break;
    }
LABEL_78:
    unint64_t v44 = v43 - v27;
    if (v43 < v27)
    {
      id v30 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446722;
        unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
        __int16 v205 = 2048;
        __int16 v206 = (const char *)v27;
        __int16 v207 = 2048;
        uint64_t v208 = v43;
        unint64_t v19 = "%{public}s _length %llu > remaining %zu";
        goto LABEL_172;
      }

      goto LABEL_27;
    }

    if (v43 == v27)
    {
LABEL_157:
      uint64_t v18 = (os_log_s *)__nwlog_obj();
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
        goto LABEL_27;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
      unint64_t v19 = "%{public}s Failed to decode integer";
      goto LABEL_25;
    }

    os_log_type_t v45 = &v42[v27];
    unint64_t v46 = v42[v27];
    if (v46 <= 0x3F)
    {
      uint64_t v47 = 1LL;
LABEL_92:
      BOOL v50 = &v45[v47];
      goto LABEL_93;
    }

    if (v46 >> 6 == 2)
    {
      if (v44 < 4) {
        goto LABEL_157;
      }
      unint64_t v46 = bswap32(*(_DWORD *)v45 & 0xFFFFFF7F);
      uint64_t v47 = 4LL;
      goto LABEL_92;
    }

    if (v46 >> 6 == 1)
    {
      if (v44 < 2) {
        goto LABEL_157;
      }
      unint64_t v46 = bswap32(*(_WORD *)v45 & 0xFFBF) >> 16;
      uint64_t v47 = 2LL;
      goto LABEL_92;
    }

    if (v44 < 8) {
      goto LABEL_157;
    }
    uint64_t v53 = *(void *)v45;
    BOOL v50 = v45 + 8;
    unint64_t v46 = bswap64(v53 & 0xFFFFFFFFFFFFFF3FLL);
    if (HIDWORD(v46))
    {
      id v30 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446722;
        unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
        __int16 v205 = 2048;
        __int16 v206 = (const char *)v46;
        __int16 v207 = 2048;
        uint64_t v208 = 0xFFFFFFFFLL;
        unint64_t v19 = "%{public}s _output %llu > _max %llu";
        goto LABEL_172;
      }

      goto LABEL_27;
    }

    uint64_t v47 = 8LL;
LABEL_93:
    uint64_t v51 = v44 - v47;
    unint64_t v26 = v44 - v47 - v46;
    if (v44 - v47 < v46)
    {
      id v30 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446722;
        unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
        __int16 v205 = 2048;
        __int16 v206 = (const char *)v46;
        __int16 v207 = 2048;
        uint64_t v208 = v51;
        unint64_t v19 = "%{public}s _length %llu > remaining %zu";
        goto LABEL_172;
      }

      goto LABEL_27;
    }

    os_log_type_t v25 = &v50[v46];
    BOOL v52 = nw_http_parsed_fields_add(v17, (unint64_t)v42, v27, v50, v46, 0);
    metadata_with_parsed_fields = 0LL;
    if (!v52) {
      goto LABEL_28;
    }
  }

  if (a4) {
    goto LABEL_167;
  }
  unint64_t v74 = 0LL;
  if (!v43)
  {
LABEL_236:
    unint64_t v75 = 0LL;
LABEL_237:
    os_log_type_t v25 = v42;
LABEL_238:
    if (a3) {
      *a3 = v74;
    }
    __int16 v88 = 0LL;
    while (1)
    {
      if (!v75) {
        goto LABEL_444;
      }
      if (!v25)
      {
        __nwlog_obj();
        *(_DWORD *)__int128 buf = 136446210;
        unsigned int v204 = "_http_vle_decode";
        int v169 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v201 = 0;
        if (type == OS_LOG_TYPE_FAULT)
        {
          int v170 = (os_log_s *)__nwlog_obj();
          os_log_type_t v171 = type;
          if (os_log_type_enabled(v170, type))
          {
            *(_DWORD *)__int128 buf = 136446210;
            unsigned int v204 = "_http_vle_decode";
            unsigned int v172 = "%{public}s called with null *buffer";
            goto LABEL_545;
          }

LABEL_546:
          if (v169) {
            free(v169);
          }
LABEL_548:
          int v108 = (os_log_s *)__nwlog_obj();
          if (!os_log_type_enabled(v108, OS_LOG_TYPE_ERROR)) {
            goto LABEL_552;
          }
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v204 = "nw_http_copy_metadata_from_binary_message";
          BOOL v109 = "%{public}s Failed to decode integer";
          goto LABEL_550;
        }

        if (v201)
        {
          BOOL v174 = (char *)__nw_create_backtrace_string();
          int v170 = (os_log_s *)__nwlog_obj();
          os_log_type_t v171 = type;
          BOOL v175 = os_log_type_enabled(v170, type);
          if (v174)
          {
            if (v175)
            {
              *(_DWORD *)__int128 buf = 136446466;
              unsigned int v204 = "_http_vle_decode";
              __int16 v205 = 2082;
              __int16 v206 = v174;
              _os_log_impl( &dword_181A5C000,  v170,  v171,  "%{public}s called with null *buffer, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v174);
            goto LABEL_546;
          }

          if (!v175) {
            goto LABEL_546;
          }
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v204 = "_http_vle_decode";
          unsigned int v172 = "%{public}s called with null *buffer, no backtrace";
        }

        else
        {
          int v170 = (os_log_s *)__nwlog_obj();
          os_log_type_t v171 = type;
          if (!os_log_type_enabled(v170, type)) {
            goto LABEL_546;
          }
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v204 = "_http_vle_decode";
          unsigned int v172 = "%{public}s called with null *buffer, backtrace limit exceeded";
        }

BOOL nw_http_fillout_body_from_binary_message( _DWORD *a1, unint64_t a2, char *__dst, size_t a4, size_t *a5)
{
  uint64_t v87 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v84 = "nw_http_fillout_body_from_binary_message";
    BOOL v70 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v81 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v71 = (os_log_s *)__nwlog_obj();
      os_log_type_t v72 = type;
      if (!os_log_type_enabled(v71, type)) {
        goto LABEL_231;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v84 = "nw_http_fillout_body_from_binary_message";
      BOOL v73 = "%{public}s called with null buffer";
      goto LABEL_230;
    }

    if (!v81)
    {
      uint64_t v71 = (os_log_s *)__nwlog_obj();
      os_log_type_t v72 = type;
      if (!os_log_type_enabled(v71, type)) {
        goto LABEL_231;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v84 = "nw_http_fillout_body_from_binary_message";
      BOOL v73 = "%{public}s called with null buffer, backtrace limit exceeded";
      goto LABEL_230;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v71 = (os_log_s *)__nwlog_obj();
    os_log_type_t v72 = type;
    BOOL v75 = os_log_type_enabled(v71, type);
    if (!backtrace_string)
    {
      if (!v75) {
        goto LABEL_231;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v84 = "nw_http_fillout_body_from_binary_message";
      BOOL v73 = "%{public}s called with null buffer, no backtrace";
      goto LABEL_230;
    }

    if (!v75) {
      goto LABEL_205;
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v84 = "nw_http_fillout_body_from_binary_message";
    __int16 v85 = 2082;
    unint64_t v86 = (unint64_t)backtrace_string;
    unsigned int v76 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_204:
    _os_log_impl(&dword_181A5C000, v71, v72, v76, buf, 0x16u);
    goto LABEL_205;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v84 = "nw_http_fillout_body_from_binary_message";
    BOOL v70 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v81 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v71 = (os_log_s *)__nwlog_obj();
      os_log_type_t v72 = type;
      if (!os_log_type_enabled(v71, type)) {
        goto LABEL_231;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v84 = "nw_http_fillout_body_from_binary_message";
      BOOL v73 = "%{public}s called with null buffer_length";
      goto LABEL_230;
    }

    if (!v81)
    {
      uint64_t v71 = (os_log_s *)__nwlog_obj();
      os_log_type_t v72 = type;
      if (!os_log_type_enabled(v71, type)) {
        goto LABEL_231;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v84 = "nw_http_fillout_body_from_binary_message";
      BOOL v73 = "%{public}s called with null buffer_length, backtrace limit exceeded";
      goto LABEL_230;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v71 = (os_log_s *)__nwlog_obj();
    os_log_type_t v72 = type;
    BOOL v77 = os_log_type_enabled(v71, type);
    if (!backtrace_string)
    {
      if (!v77) {
        goto LABEL_231;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v84 = "nw_http_fillout_body_from_binary_message";
      BOOL v73 = "%{public}s called with null buffer_length, no backtrace";
      goto LABEL_230;
    }

    if (!v77) {
      goto LABEL_205;
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v84 = "nw_http_fillout_body_from_binary_message";
    __int16 v85 = 2082;
    unint64_t v86 = (unint64_t)backtrace_string;
    unsigned int v76 = "%{public}s called with null buffer_length, dumping backtrace:%{public}s";
    goto LABEL_204;
  }

  if (!__dst)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v84 = "nw_http_fillout_body_from_binary_message";
    BOOL v70 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v81 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v71 = (os_log_s *)__nwlog_obj();
      os_log_type_t v72 = type;
      if (!os_log_type_enabled(v71, type)) {
        goto LABEL_231;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v84 = "nw_http_fillout_body_from_binary_message";
      BOOL v73 = "%{public}s called with null body_buffer";
      goto LABEL_230;
    }

    if (!v81)
    {
      uint64_t v71 = (os_log_s *)__nwlog_obj();
      os_log_type_t v72 = type;
      if (!os_log_type_enabled(v71, type)) {
        goto LABEL_231;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v84 = "nw_http_fillout_body_from_binary_message";
      BOOL v73 = "%{public}s called with null body_buffer, backtrace limit exceeded";
      goto LABEL_230;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v71 = (os_log_s *)__nwlog_obj();
    os_log_type_t v72 = type;
    BOOL v78 = os_log_type_enabled(v71, type);
    if (!backtrace_string)
    {
      if (!v78) {
        goto LABEL_231;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v84 = "nw_http_fillout_body_from_binary_message";
      BOOL v73 = "%{public}s called with null body_buffer, no backtrace";
      goto LABEL_230;
    }

    if (!v78) {
      goto LABEL_205;
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v84 = "nw_http_fillout_body_from_binary_message";
    __int16 v85 = 2082;
    unint64_t v86 = (unint64_t)backtrace_string;
    unsigned int v76 = "%{public}s called with null body_buffer, dumping backtrace:%{public}s";
    goto LABEL_204;
  }

  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v84 = "nw_http_fillout_body_from_binary_message";
    BOOL v70 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v81 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v71 = (os_log_s *)__nwlog_obj();
      os_log_type_t v72 = type;
      if (!os_log_type_enabled(v71, type)) {
        goto LABEL_231;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v84 = "nw_http_fillout_body_from_binary_message";
      BOOL v73 = "%{public}s called with null body_buffer_length";
      goto LABEL_230;
    }

    if (!v81)
    {
      uint64_t v71 = (os_log_s *)__nwlog_obj();
      os_log_type_t v72 = type;
      if (!os_log_type_enabled(v71, type)) {
        goto LABEL_231;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v84 = "nw_http_fillout_body_from_binary_message";
      BOOL v73 = "%{public}s called with null body_buffer_length, backtrace limit exceeded";
      goto LABEL_230;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v71 = (os_log_s *)__nwlog_obj();
    os_log_type_t v72 = type;
    BOOL v79 = os_log_type_enabled(v71, type);
    if (backtrace_string)
    {
      if (v79)
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v84 = "nw_http_fillout_body_from_binary_message";
        __int16 v85 = 2082;
        unint64_t v86 = (unint64_t)backtrace_string;
        unsigned int v76 = "%{public}s called with null body_buffer_length, dumping backtrace:%{public}s";
        goto LABEL_204;
      }

char *nw_http_access_body_chunk_from_indeterminate_binary_message( _DWORD *a1, unint64_t a2, int a3, unint64_t *a4, _BYTE *a5, char **a6, unint64_t *a7)
{
  uint64_t v79 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    unsigned int v60 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      uint64_t v63 = "%{public}s called with null buffer";
      goto LABEL_217;
    }

    if (!v73)
    {
      size_t v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      uint64_t v63 = "%{public}s called with null buffer, backtrace limit exceeded";
      goto LABEL_217;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v61 = (os_log_s *)__nwlog_obj();
    os_log_type_t v62 = type;
    BOOL v65 = os_log_type_enabled(v61, type);
    if (!backtrace_string)
    {
      if (!v65) {
        goto LABEL_218;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      uint64_t v63 = "%{public}s called with null buffer, no backtrace";
      goto LABEL_217;
    }

    if (!v65) {
      goto LABEL_188;
    }
    *(_DWORD *)__int128 buf = 136446466;
    unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    __int16 v77 = 2082;
    unint64_t v78 = (unint64_t)backtrace_string;
    size_t v66 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_187:
    _os_log_impl(&dword_181A5C000, v61, v62, v66, buf, 0x16u);
    goto LABEL_188;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    unsigned int v60 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      uint64_t v63 = "%{public}s called with null buffer_length";
      goto LABEL_217;
    }

    if (!v73)
    {
      size_t v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      uint64_t v63 = "%{public}s called with null buffer_length, backtrace limit exceeded";
      goto LABEL_217;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v61 = (os_log_s *)__nwlog_obj();
    os_log_type_t v62 = type;
    BOOL v67 = os_log_type_enabled(v61, type);
    if (!backtrace_string)
    {
      if (!v67) {
        goto LABEL_218;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      uint64_t v63 = "%{public}s called with null buffer_length, no backtrace";
      goto LABEL_217;
    }

    if (!v67) {
      goto LABEL_188;
    }
    *(_DWORD *)__int128 buf = 136446466;
    unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    __int16 v77 = 2082;
    unint64_t v78 = (unint64_t)backtrace_string;
    size_t v66 = "%{public}s called with null buffer_length, dumping backtrace:%{public}s";
    goto LABEL_187;
  }

  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    unsigned int v60 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      uint64_t v63 = "%{public}s called with null out_chunk_length";
      goto LABEL_217;
    }

    if (!v73)
    {
      size_t v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      uint64_t v63 = "%{public}s called with null out_chunk_length, backtrace limit exceeded";
      goto LABEL_217;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v61 = (os_log_s *)__nwlog_obj();
    os_log_type_t v62 = type;
    BOOL v68 = os_log_type_enabled(v61, type);
    if (!backtrace_string)
    {
      if (!v68) {
        goto LABEL_218;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      uint64_t v63 = "%{public}s called with null out_chunk_length, no backtrace";
      goto LABEL_217;
    }

    if (!v68) {
      goto LABEL_188;
    }
    *(_DWORD *)__int128 buf = 136446466;
    unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    __int16 v77 = 2082;
    unint64_t v78 = (unint64_t)backtrace_string;
    size_t v66 = "%{public}s called with null out_chunk_length, dumping backtrace:%{public}s";
    goto LABEL_187;
  }

  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    unsigned int v60 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      uint64_t v63 = "%{public}s called with null out_is_complete";
      goto LABEL_217;
    }

    if (!v73)
    {
      size_t v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      uint64_t v63 = "%{public}s called with null out_is_complete, backtrace limit exceeded";
      goto LABEL_217;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v61 = (os_log_s *)__nwlog_obj();
    os_log_type_t v62 = type;
    BOOL v69 = os_log_type_enabled(v61, type);
    if (!backtrace_string)
    {
      if (!v69) {
        goto LABEL_218;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      uint64_t v63 = "%{public}s called with null out_is_complete, no backtrace";
      goto LABEL_217;
    }

    if (!v69) {
      goto LABEL_188;
    }
    *(_DWORD *)__int128 buf = 136446466;
    unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    __int16 v77 = 2082;
    unint64_t v78 = (unint64_t)backtrace_string;
    size_t v66 = "%{public}s called with null out_is_complete, dumping backtrace:%{public}s";
    goto LABEL_187;
  }

  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    unsigned int v60 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      uint64_t v63 = "%{public}s called with null out_next_chunk";
      goto LABEL_217;
    }

    if (!v73)
    {
      size_t v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      uint64_t v63 = "%{public}s called with null out_next_chunk, backtrace limit exceeded";
      goto LABEL_217;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v61 = (os_log_s *)__nwlog_obj();
    os_log_type_t v62 = type;
    BOOL v70 = os_log_type_enabled(v61, type);
    if (!backtrace_string)
    {
      if (!v70) {
        goto LABEL_218;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      uint64_t v63 = "%{public}s called with null out_next_chunk, no backtrace";
      goto LABEL_217;
    }

    if (!v70) {
      goto LABEL_188;
    }
    *(_DWORD *)__int128 buf = 136446466;
    unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    __int16 v77 = 2082;
    unint64_t v78 = (unint64_t)backtrace_string;
    size_t v66 = "%{public}s called with null out_next_chunk, dumping backtrace:%{public}s";
    goto LABEL_187;
  }

  if (!a7)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
    unsigned int v60 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v73 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      uint64_t v63 = "%{public}s called with null out_remaining_length";
      goto LABEL_217;
    }

    if (!v73)
    {
      size_t v61 = (os_log_s *)__nwlog_obj();
      os_log_type_t v62 = type;
      if (!os_log_type_enabled(v61, type)) {
        goto LABEL_218;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
      uint64_t v63 = "%{public}s called with null out_remaining_length, backtrace limit exceeded";
      goto LABEL_217;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v61 = (os_log_s *)__nwlog_obj();
    os_log_type_t v62 = type;
    BOOL v71 = os_log_type_enabled(v61, type);
    if (backtrace_string)
    {
      if (v71)
      {
        *(_DWORD *)__int128 buf = 136446466;
        unsigned int v76 = "nw_http_access_body_chunk_from_indeterminate_binary_message";
        __int16 v77 = 2082;
        unint64_t v78 = (unint64_t)backtrace_string;
        size_t v66 = "%{public}s called with null out_remaining_length, dumping backtrace:%{public}s";
        goto LABEL_187;
      }

uint64_t nw_http_copy_trailer_fields_from_indeterminate_binary_message(const char *a1, unint64_t a2)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unint64_t v45 = "nw_http_copy_trailer_fields_from_indeterminate_binary_message";
    unint64_t v33 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v34 = (os_log_s *)__nwlog_obj();
      os_log_type_t v35 = type;
      if (os_log_type_enabled(v34, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unint64_t v45 = "nw_http_copy_trailer_fields_from_indeterminate_binary_message";
        uint64_t v36 = "%{public}s called with null buffer";
LABEL_103:
        _os_log_impl(&dword_181A5C000, v34, v35, v36, buf, 0xCu);
      }

nw_protocol_definition_t __nw_protocol_tcpconverter_copy_definition_block_invoke()
{
  nw_protocol_definition_t result = nw_framer_create_definition("TCP-Converter", 0, &__block_literal_global_6_48566);
  nw_protocol_tcpconverter_copy_definition::definition = (uint64_t)result;
  return result;
}

uint64_t __nw_protocol_tcpconverter_copy_definition_block_invoke_2(uint64_t a1, void *a2)
{
  uint64_t v69 = *MEMORY[0x1895F89C0];
  size_t v3 = calloc(1uLL, 0x58uLL);
  if (v3) {
    goto LABEL_2;
  }
  BOOL v41 = (os_log_s *)__nwlog_obj();
  os_log_type_enabled(v41, OS_LOG_TYPE_ERROR);
  *(_DWORD *)__int128 buf = 136446722;
  *(void *)&uint8_t buf[4] = "strict_calloc";
  *(_WORD *)&_BYTE buf[12] = 2048;
  *(void *)&buf[14] = 1LL;
  __int16 v55 = 2048;
  uint64_t v56 = 88LL;
  char v42 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort((uint64_t)v42);
  if (!(_DWORD)result)
  {
    free(v42);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_tcpconverter_copy_definition_block_invoke_2";
    BOOL v43 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v43);
    if (!(_DWORD)result)
    {
      free(v43);
LABEL_2:
      *size_t v3 = 0;
      id v4 = a2;
      unint64_t v5 = v4;
      unint64_t v6 = 84LL;
      uint64_t v7 = 609LL;
      while (1)
      {
        int v8 = *((unsigned __int8 *)v4 + v7);
        *((_BYTE *)v3 + v7 - 605) = v8;
        if (!v8) {
          break;
        }
        --v6;
        ++v7;
        if (v6 <= 1)
        {
          *((_BYTE *)v3 + v7 - 605) = 0;
          break;
        }
      }

      uint64_t v9 = MEMORY[0x1895F87A8];
      input_handler[0] = MEMORY[0x1895F87A8];
      input_handler[1] = 0x40000000LL;
      input_handler[2] = __nw_protocol_tcpconverter_copy_definition_block_invoke_7;
      input_handler[3] = &__block_descriptor_tmp_13_48570;
      input_handler[4] = v3;
      input_handler[5] = v5;
      nw_framer_set_input_handler(v5, input_handler);
      output_handler[0] = v9;
      output_handler[1] = 0x40000000LL;
      output_handler[2] = __nw_protocol_tcpconverter_copy_definition_block_invoke_2_14;
      output_handler[3] = &__block_descriptor_tmp_16_48571;
      output_handler[4] = v3;
      nw_framer_set_output_handler(v5, output_handler);
      cleanup_handler[0] = v9;
      cleanup_handler[1] = 0x40000000LL;
      cleanup_handler[2] = __nw_protocol_tcpconverter_copy_definition_block_invoke_17;
      cleanup_handler[3] = &__block_descriptor_tmp_19_48572;
      cleanup_handler[4] = v3;
      nw_framer_set_cleanup_handler(v5, cleanup_handler);
      stop_handler[0] = v9;
      stop_handler[1] = 0x40000000LL;
      stop_handler[2] = __nw_protocol_tcpconverter_copy_definition_block_invoke_2_20;
      stop_handler[3] = &__block_descriptor_tmp_22_48573;
      stop_handler[4] = v3;
      nw_framer_set_stop_handler(v5, stop_handler);
      if (v5)
      {
        nw_endpoint_t v10 = nw_framer_copy_remote_endpoint(v5);
        if (nw_endpoint_get_type(v10) == nw_endpoint_type_address)
        {
          BOOL v11 = nw_endpoint_copy_proxy_original_endpoint(v10);
          if (nw_endpoint_get_type((nw_endpoint_t)v11) == nw_endpoint_type_address)
          {
            int v64 = 0;
            *(_DWORD *)output___int128 buffer = 1663174145;
            __int16 v66 = 1290;
            uint64_t v63 = 0LL;
            v62[0] = 528;
            v62[1] = __rev16(nw_endpoint_get_port((nw_endpoint_t)v11));
            uint64_t address = nw_endpoint_get_address((nw_endpoint_t)v11);
            if (address->sa_family == 30)
            {
              unint64_t v13 = v5;
              nw_context_assert_queue(v13[46]);
              uint64_t v15 = v13[42];
              if (v15 && (uint64_t v16 = v15[3]) != 0 && (v17 = *(void (**)(void *, uint64_t))(v16 + 120)) != 0LL)
              {
                v17(v15, v14);
                uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
              }

              else
              {
                uint64_t v18 = 0LL;
              }

              if (nw_path_has_nat64_prefixes(v18))
              {
                uint64_t v19 = (unsigned int *)nw_path_nat64_prefixes(v18);
                uint64_t v20 = v19;
                *(void *)__int128 buf = 0LL;
                *(void *)&uint8_t buf[8] = 0LL;
                size_t v21 = v19[4];
                if ((_DWORD)v21)
                {
                  *(_DWORD *)__int128 buf = v19[4];
                  memcpy(&buf[4], v19, v21);
                }

                size_t v22 = v20[9];
                if ((_DWORD)v22)
                {
                  *(_DWORD *)__int128 buf = v20[9];
                  memcpy(&buf[4], v20, v22);
                }

                if ((size_t v23 = v20[14], (_DWORD)v23)
                  && (*(_DWORD *)__int128 buf = v20[14],
                      memcpy(&buf[4], v20, v23),
                      (nw_nat64_extract_v4((unsigned int *)buf, &address->sa_data[6], (uint64_t)&v63) & 1) != 0)
                  || (size_t v24 = v20[19], (_DWORD)v24)
                  && (*(_DWORD *)__int128 buf = v20[19],
                      memcpy(&buf[4], v20, v24),
                      (nw_nat64_extract_v4((unsigned int *)buf, &address->sa_data[6], (uint64_t)&v63) & 1) != 0))
                {
LABEL_23:
                  HIBYTE(v62[0]) = 2;
                  uint64_t address = (const sockaddr *)v62;
                }
              }
            }

            unsigned __int16 v25 = *(_WORD *)address->sa_data;
            if (address->sa_family == 30)
            {
              __int128 v68 = *(_OWORD *)&address->sa_data[6];
            }

            else
            {
              int v34 = *(_DWORD *)&address->sa_data[2];
              *(void *)&__int128 v68 = 0LL;
              DWORD2(v6_Block_object_dispose((const void *)(v50 - 136), 8) = -65536;
              HIDWORD(v6_Block_object_dispose((const void *)(v50 - 136), 8) = v34;
            }

            unsigned __int16 v67 = v25;
            nw_framer_write_output(v5, output_buffer, 0x18uLL);
            inet_ntop(30, &v68, v61, 0x2Eu);
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v35 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)__int128 buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_tcpconverter_send_connect";
              *(_WORD *)&_BYTE buf[12] = 2080;
              *(void *)&buf[14] = v3 + 1;
              __int16 v55 = 2080;
              uint64_t v56 = (uint64_t)v61;
              __int16 v57 = 1024;
              unsigned int v58 = bswap32(v67) >> 16;
              __int16 v59 = 2112;
              nw_endpoint_t v60 = v10;
              _os_log_impl( &dword_181A5C000,  v35,  OS_LOG_TYPE_DEBUG,  "%{public}s %s Sent TCP-converter connect to IP %s, port %u via proxy %@",  buf,  0x30u);
            }

            *size_t v3 = 1;
            if (v10) {
              os_release(v10);
            }
            if (v11) {
              os_release((void *)v11);
            }
            return 2LL;
          }

          if (v10) {
            os_release(v10);
          }
          if (v11) {
            os_release((void *)v11);
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcpconverter_send_connect";
          *(_WORD *)&_BYTE buf[12] = 2112;
          *(void *)&buf[14] = 0LL;
          uint32_t v26 = (char *)_os_log_send_and_compose_impl();
          v61[0] = 16;
          output_buffer[0] = 0;
          if (__nwlog_fault(v26, v61, output_buffer))
          {
            if (v61[0] == 17)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              unint64_t v30 = (os_log_s *)gLogObj;
              os_log_type_t v31 = v61[0];
              if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v61[0])) {
                goto LABEL_67;
              }
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_tcpconverter_send_connect";
              *(_WORD *)&_BYTE buf[12] = 2112;
              *(void *)&buf[14] = 0LL;
              os_log_type_t v29 = "%{public}s Received incorrect endpoint-type: %@";
              goto LABEL_65;
            }

            if (!output_buffer[0])
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              unint64_t v30 = (os_log_s *)gLogObj;
              os_log_type_t v31 = v61[0];
              if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v61[0])) {
                goto LABEL_67;
              }
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_tcpconverter_send_connect";
              *(_WORD *)&_BYTE buf[12] = 2112;
              *(void *)&buf[14] = 0LL;
              os_log_type_t v29 = "%{public}s Received incorrect endpoint-type: %@, backtrace limit exceeded";
              goto LABEL_65;
            }

            backtrace_string = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            unint64_t v30 = (os_log_s *)gLogObj;
            os_log_type_t v31 = v61[0];
            BOOL v37 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v61[0]);
            if (backtrace_string)
            {
              if (v37)
              {
                *(_DWORD *)__int128 buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_tcpconverter_send_connect";
                *(_WORD *)&_BYTE buf[12] = 2112;
                *(void *)&buf[14] = 0LL;
                __int16 v55 = 2082;
                uint64_t v56 = (uint64_t)backtrace_string;
                _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s Received incorrect endpoint-type: %@, dumping backtrace:%{public}s",  buf,  0x20u);
              }

              free(backtrace_string);
              if (!v26) {
                goto LABEL_69;
              }
              goto LABEL_68;
            }

            if (v37)
            {
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_tcpconverter_send_connect";
              *(_WORD *)&_BYTE buf[12] = 2112;
              *(void *)&buf[14] = 0LL;
              os_log_type_t v29 = "%{public}s Received incorrect endpoint-type: %@, no backtrace";
LABEL_65:
              BOOL v38 = v30;
              os_log_type_t v39 = v31;
              goto LABEL_66;
            }
          }

void sub_182290F2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL __nw_protocol_tcpconverter_copy_definition_block_invoke_7(uint64_t a1, nw_framer *a2)
{
  uint64_t v64 = *MEMORY[0x1895F89C0];
  size_t v3 = *(_DWORD **)(a1 + 32);
  int v4 = *v3;
  if (*v3 == 2)
  {
    *(void *)temp___int128 buffer = 0LL;
    *(void *)&uint8_t temp_buffer[8] = temp_buffer;
    *(void *)&temp_buffer[16] = 0x2000000000LL;
    uint64_t v63 = 0LL;
    uint64_t v35 = 0LL;
    uint64_t v36 = (uint64_t)&v35;
    uint64_t v37 = 0x2000000000LL;
    LOBYTE(v3_Block_object_dispose((const void *)(v50 - 136), 8) = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v6 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      if (v7) {
        int v8 = (const char *)(v7 + 4);
      }
      else {
        int v8 = "";
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcpconverter_copy_definition_block_invoke";
      *(_WORD *)&_BYTE buf[12] = 2080;
      *(void *)&buf[14] = v8;
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEFAULT,  "%{public}s %s Received incoming data while connected",  buf,  0x16u);
    }

    parse[0] = MEMORY[0x1895F87A8];
    parse[1] = 0x40000000LL;
    parse[2] = __nw_protocol_tcpconverter_copy_definition_block_invoke_9;
    parse[3] = &unk_189BBFAA0;
    parse[4] = temp_buffer;
    parse[5] = &v35;
    nw_framer_parse_input(a2, 1uLL, 0xFFFFFFFFuLL, 0LL, parse);
    uint64_t v9 = nw_framer_message_create(*(nw_framer_t *)(a1 + 40));
    nw_framer_deliver_input_no_copy(a2, *(void *)(*(void *)&temp_buffer[8] + 24LL), v9, *(_BYTE *)(v36 + 24));
    if (v9) {
      os_release(v9);
    }
    _Block_object_dispose(&v35, 8);
    nw_endpoint_t v10 = (uint64_t *)temp_buffer;
    goto LABEL_21;
  }

  BOOL v11 = *(nw_framer **)(a1 + 40);
  uint64_t v48 = 0LL;
  BOOL v49 = &v48;
  uint64_t v50 = 0x2000000000LL;
  uint64_t v51 = 0LL;
  uint64_t v44 = 0LL;
  unint64_t v45 = &v44;
  uint64_t v46 = 0x2000000000LL;
  char v47 = 0;
  if (v4 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v18 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)temp___int128 buffer = 136446466;
      *(void *)&temp_buffer[4] = "nw_tcpconverter_parse_response";
      *(_WORD *)&temp_buffer[12] = 2080;
      *(void *)&temp_buffer[14] = v3 + 1;
      uint64_t v19 = "%{public}s %s Received response although we haven't yet sent a connect-message";
      uint64_t v20 = temp_buffer;
LABEL_18:
      _os_log_impl(&dword_181A5C000, v18, OS_LOG_TYPE_ERROR, v19, v20, 0x16u);
    }

BOOL __nw_protocol_tcpconverter_copy_definition_block_invoke_2_14( BOOL result, nw_framer *a2, uint64_t a3, size_t a4)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (**(_DWORD **)(result + 32) == 2)
  {
    uint64_t v6 = result;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(v6 + 32);
      if (v8) {
        uint64_t v9 = (const char *)(v8 + 4);
      }
      else {
        uint64_t v9 = "";
      }
      int v10 = 136446466;
      BOOL v11 = "nw_protocol_tcpconverter_copy_definition_block_invoke_2";
      __int16 v12 = 2080;
      unint64_t v13 = v9;
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEFAULT,  "%{public}s %s Received outgoing data while connected",  (uint8_t *)&v10,  0x16u);
    }

    return nw_framer_write_output_no_copy(a2, a4);
  }

  return result;
}

void __nw_protocol_tcpconverter_copy_definition_block_invoke_17(uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  if (v1) {
    free(v1);
  }
}

uint64_t __nw_protocol_tcpconverter_copy_definition_block_invoke_2_20(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unint64_t v2 = (os_log_s *)gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3) {
      int v4 = (const char *)(v3 + 4);
    }
    else {
      int v4 = "";
    }
    int v6 = 136446466;
    uint64_t v7 = "nw_protocol_tcpconverter_copy_definition_block_invoke_2";
    __int16 v8 = 2080;
    uint64_t v9 = v4;
    _os_log_impl(&dword_181A5C000, v2, OS_LOG_TYPE_DEFAULT, "%{public}s %s Got stop indication", (uint8_t *)&v6, 0x16u);
  }

  return 1LL;
}

uint64_t __nw_protocol_tcpconverter_copy_definition_block_invoke_9( uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a3;
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = a4;
  return 0LL;
}

uint64_t ___ZL30nw_tcpconverter_parse_responseP9nw_framerP15nw_tcpconverter_block_invoke( uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  if (!a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v10 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = *(void *)(a1 + 48);
      if (v11) {
        __int16 v12 = (const char *)(v11 + 4);
      }
      else {
        __int16 v12 = "";
      }
      int v28 = 136446466;
      BOOL v29 = "nw_tcpconverter_parse_response_block_invoke";
      __int16 v30 = 2080;
      os_log_type_t v31 = v12;
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s %s Received NULL header",  (uint8_t *)&v28,  0x16u);
    }

    return 0LL;
  }

  if (*a2 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v13 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      uint64_t v14 = *(void *)(a1 + 48);
      uint64_t v15 = (const char *)(v14 + 4);
      BOOL v16 = v14 == 0;
      int v17 = *a2;
      if (v16) {
        uint64_t v15 = "";
      }
      int v28 = 136446722;
      BOOL v29 = "nw_tcpconverter_parse_response_block_invoke";
      __int16 v30 = 2080;
      os_log_type_t v31 = v15;
      __int16 v32 = 1024;
      LODWORD(v33) = v17;
      uint64_t v18 = "%{public}s %s Received invalid TCP Converter version %d";
      goto LABEL_20;
    }

uint64_t ___ZL30nw_tcpconverter_parse_responseP9nw_framerP15nw_tcpconverter_block_invoke_30( void *a1, uint64_t a2)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  unint64_t v3 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
  if (v3 < 2)
  {
LABEL_23:
    *(_BYTE *)(*(void *)(a1[5] + 8LL) + 24LL) = 1;
    return *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
  }

  else
  {
    unsigned int v5 = 0;
    unint64_t v6 = 1LL;
    while (1)
    {
      int v7 = *(unsigned __int8 *)(a2 + v5);
      int v8 = 4 * *(unsigned __int8 *)(a2 + v6);
      unint64_t v9 = v8 + v5;
      if (v3 < v9) {
        break;
      }
      if (v7 == 20)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v16 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v17 = a1[6];
          uint64_t v18 = (const char *)(v17 + 4);
          BOOL v13 = v17 == 0;
          uint64_t v19 = "";
          if (!v13) {
            uint64_t v19 = v18;
          }
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcpconverter_parse_response_block_invoke";
          __int16 v39 = 2080;
          unint64_t v40 = v19;
          _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEFAULT,  "%{public}s %s Connection successfully established",  buf,  0x16u);
        }

        *(_DWORD *)a1[6] = 2;
      }

      else
      {
        if (v7 == 30)
        {
          int v28 = (unsigned __int8 *)(a2 + v5);
          int v29 = v28[1];
          *(void *)__int128 buf = 0LL;
          unsigned int v30 = v28[2];
          if (v30 >= 0x20)
          {
            if (v30 >= 0x40)
            {
              if (v30 >= 0x60)
              {
                if ((v30 & 0x80u) != 0) {
                  os_log_type_t v31 = "Unknown error class";
                }
                else {
                  os_log_type_t v31 = "Destination-server side error";
                }
              }

              else
              {
                os_log_type_t v31 = "Converter-side error";
              }
            }

            else
            {
              os_log_type_t v31 = "Client-side error";
            }
          }

          else
          {
            os_log_type_t v31 = "Message validation and processing error";
          }

          __int16 v32 = "Unsupported Version";
          switch(*(_BYTE *)(a2 + v5 + 2))
          {
            case 0:
              break;
            case 1:
              __int16 v32 = "Malformed Message";
              break;
            case 2:
              __int16 v32 = "Unsupported Message";
              break;
            case 3:
              __int16 v32 = "Missing Cookie";
              break;
            case 0x20:
              __int16 v32 = "Not Authorized";
              break;
            case 0x21:
              __int16 v32 = "Unsupported TCP Option";
              break;
            case 0x40:
              __int16 v32 = "Resource Exceeded";
              break;
            case 0x41:
              __int16 v32 = "Network Failure";
              break;
            case 0x60:
              __int16 v32 = "Connection Reset";
              break;
            case 0x61:
              __int16 v32 = "Destination Unreachable";
              break;
            default:
              __int16 v32 = "Unknown error code";
              break;
          }

          asprintf( (char **)buf,  "Error class %s (%u), type %s (%u), length %u, value %u",  v31,  v30,  v32,  v30,  4 * v29,  v28[3]);
          uint64_t v33 = *(void **)buf;
          if (*(void *)buf)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v34 = (os_log_s *)gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v35 = a1[6];
              uint64_t v36 = (const char *)(v35 + 4);
              BOOL v13 = v35 == 0;
              uint64_t v37 = "";
              if (!v13) {
                uint64_t v37 = v36;
              }
              *(_DWORD *)__int128 buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_tcpconverter_parse_response_block_invoke";
              __int16 v39 = 2080;
              unint64_t v40 = v37;
              __int16 v41 = 2080;
              *(void *)char v42 = v33;
              _os_log_impl(&dword_181A5C000, v34, OS_LOG_TYPE_DEFAULT, "%{public}s %s Received ERROR: %s", buf, 0x20u);
            }

            free(v33);
          }

          int v27 = 22;
          switch(v28[2])
          {
            case '@':
              int v27 = 35;
              break;
            case 'A':
              int v27 = 51;
              break;
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '[':
            case '\\':
            case ']':
            case '^':
            case '_':
              break;
              int v27 = 61;
              break;
            case 'a':
              int v27 = 65;
              break;
            default:
              if (v28[2] == 32) {
                int v27 = 1;
              }
              break;
          }

          *(_DWORD *)a1[6] = 3;
          os_log_type_t v26 = (nw_framer *)a1[7];
          goto LABEL_63;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v10 = (os_log_s *)gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          uint64_t v11 = a1[6];
          __int16 v12 = (const char *)(v11 + 4);
          BOOL v13 = v11 == 0;
          uint64_t v14 = "";
          if (!v13) {
            uint64_t v14 = v12;
          }
          uint64_t v15 = "RESERVED";
          switch(v7)
          {
            case 0:
              break;
            case 1:
              uint64_t v15 = "INFO";
              break;
            case 10:
              uint64_t v15 = "CONNECT";
              break;
            case 20:
              uint64_t v15 = "EXTENDED";
              break;
            case 21:
              uint64_t v15 = "EXTENSIONS";
              break;
            case 22:
              uint64_t v15 = "COOKIE";
              break;
            default:
              uint64_t v15 = "UNKNOWN";
              break;
          }

          *(_DWORD *)__int128 buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_tcpconverter_parse_response_block_invoke";
          __int16 v39 = 2080;
          unint64_t v40 = v14;
          __int16 v41 = 2080;
          *(void *)char v42 = v15;
          *(_WORD *)&v42[8] = 1024;
          *(_DWORD *)uint64_t v43 = v7;
          *(_WORD *)&v43[4] = 1024;
          *(_DWORD *)&v43[6] = v8;
          _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_ERROR,  "%{public}s %s Received unexpected Converter-type %s(%u) with length %u -> Skipping",  buf,  0x2Cu);
        }
      }

      unint64_t v6 = v9 | 1;
      unint64_t v3 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
      unsigned int v5 = v9;
      if (v3 <= v6) {
        goto LABEL_23;
      }
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    size_t v21 = (os_log_s *)gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      uint64_t v22 = a1[6];
      int v23 = (const char *)(v22 + 4);
      BOOL v13 = v22 == 0;
      size_t v24 = "";
      if (!v13) {
        size_t v24 = v23;
      }
      uint64_t v25 = *(void *)(*(void *)(a1[4] + 8LL) + 24LL);
      *(_DWORD *)__int128 buf = 136447490;
      *(void *)&uint8_t buf[4] = "nw_tcpconverter_parse_response_block_invoke";
      __int16 v39 = 2080;
      unint64_t v40 = v24;
      __int16 v41 = 1024;
      *(_DWORD *)char v42 = v7;
      *(_WORD *)&v42[4] = 1024;
      *(_DWORD *)&v42[6] = v8;
      *(_WORD *)uint64_t v43 = 2048;
      *(void *)&v43[2] = v25;
      __int16 v44 = 1024;
      unsigned int v45 = v5;
      _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s %s Insufficient data for TLV of type %u, length %d, total_length %ld, index %u",  buf,  0x32u);
    }

    os_log_type_t v26 = (nw_framer *)a1[7];
    int v27 = 22;
LABEL_63:
    nw_framer_mark_failed_with_error(v26, v27);
    return 0LL;
  }

void nw_http_capsule_framer_cleanup(void *a1, __n128 a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v3 = *a1;
    a2.n128_u64[0] = 136446722LL;
    while (v3)
    {
      uint64_t v4 = (_DWORD *)v3;
      uint64_t v3 = *(void *)(v3 + 32);
      if (gLogDatapath)
      {
        __n128 v29 = a2;
        unsigned int v5 = (os_log_s *)__nwlog_obj();
        BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG);
        a2 = v29;
        if (v6)
        {
          int v7 = nw_frame_unclaimed_length(v4);
          *(_DWORD *)__int128 buf = v29.n128_u32[0];
          *(void *)&uint8_t buf[4] = "nw_http_capsule_framer_cleanup_block_invoke";
          *(_WORD *)&_BYTE buf[12] = 2048;
          *(void *)&buf[14] = v4;
          *(_WORD *)&_BYTE buf[22] = 1024;
          LODWORD(v34) = v7;
          _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_DEBUG,  "%{public}s unprocessed_frames still has frames in it: frame %p (%u bytes)",  buf,  0x1Cu);
          a2 = v29;
        }
      }
    }

    int v8 = a1 + 2;
    uint64_t v9 = a1[2];
    while (v9)
    {
      uint64_t v10 = (_DWORD *)v9;
      uint64_t v9 = *(void *)(v9 + 32);
      if (gLogDatapath)
      {
        __n128 v30 = a2;
        os_log_t log = (os_log_s *)__nwlog_obj();
        BOOL v11 = os_log_type_enabled(log, OS_LOG_TYPE_DEBUG);
        a2 = v30;
        if (v11)
        {
          int v12 = nw_frame_unclaimed_length(v10);
          *(_DWORD *)__int128 buf = v30.n128_u32[0];
          *(void *)&uint8_t buf[4] = "nw_http_capsule_framer_cleanup_block_invoke";
          *(_WORD *)&_BYTE buf[12] = 2048;
          *(void *)&buf[14] = v10;
          *(_WORD *)&_BYTE buf[22] = 1024;
          LODWORD(v34) = v12;
          _os_log_impl( &dword_181A5C000,  log,  OS_LOG_TYPE_DEBUG,  "%{public}s processed_frames still has frames in it: frame %p (%u bytes)",  buf,  0x1Cu);
          a2 = v30;
        }
      }
    }

    if (gLogDatapath)
    {
      size_t v24 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_181A5C000, v24, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
      }
    }

    uint64_t v13 = MEMORY[0x1895F87A8];
    *(void *)__int128 buf = MEMORY[0x1895F87A8];
    *(void *)&uint8_t buf[8] = 0x40000000LL;
    *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_48665;
    uint64_t v34 = &__block_descriptor_tmp_10_48666;
    uint64_t v35 = a1;
    char v36 = 0;
    uint64_t v14 = *a1;
    do
    {
      if (!v14) {
        break;
      }
      uint64_t v15 = *(void *)(v14 + 32);
      char v16 = (*(uint64_t (**)(_BYTE *, __n128))&buf[16])(buf, a2);
      uint64_t v14 = v15;
    }

    while ((v16 & 1) != 0);
    if (gLogDatapath)
    {
      uint64_t v25 = (os_log_s *)__nwlog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_181A5C000, v25, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
      }
    }

    *(void *)__int128 buf = v13;
    *(void *)&uint8_t buf[8] = 0x40000000LL;
    *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_48665;
    uint64_t v34 = &__block_descriptor_tmp_10_48666;
    uint64_t v35 = v8;
    char v36 = 0;
    uint64_t v17 = *v8;
    do
    {
      if (!v17) {
        break;
      }
      uint64_t v18 = *(void *)(v17 + 32);
      char v19 = (*(uint64_t (**)(_BYTE *, __n128))&buf[16])(buf, a2);
      uint64_t v17 = v18;
    }

    while ((v19 & 1) != 0);
    return;
  }

  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_http_capsule_framer_cleanup";
  uint64_t v20 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v31 = 0;
  if (__nwlog_fault(v20, &type, &v31))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_capsule_framer_cleanup";
      int v23 = "%{public}s called with null framer";
      goto LABEL_38;
    }

    if (!v31)
    {
      size_t v21 = (os_log_s *)__nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_39;
      }
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_capsule_framer_cleanup";
      int v23 = "%{public}s called with null framer, backtrace limit exceeded";
      goto LABEL_38;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v21 = (os_log_s *)__nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v27 = os_log_type_enabled(v21, type);
    if (backtrace_string)
    {
      if (v27)
      {
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_capsule_framer_cleanup";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v21,  v22,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(backtrace_string);
      goto LABEL_39;
    }

    if (v27)
    {
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_capsule_framer_cleanup";
      int v23 = "%{public}s called with null framer, no backtrace";
LABEL_38:
      _os_log_impl(&dword_181A5C000, v21, v22, v23, buf, 0xCu);
    }
  }

uint64_t ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_48665( uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  uint64_t v3 = *(void **)(a2 + 40);
  if (v2)
  {
    *(void *)(v2 + 40) = v3;
    uint64_t v3 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 32) + 8LL) = v3;
  }

  *uint64_t v3 = v2;
  *(void *)(a2 + 32) = 0LL;
  *(void *)(a2 + 40) = 0LL;
  nw_frame_finalize(a2);
  return 1LL;
}

uint64_t __nw_http_capsule_framer_read_capsule_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  unsigned int v28 = 0;
  uint64_t v4 = (const void *)nw_frame_unclaimed_bytes(a2, &v28);
  uint64_t v5 = a1[5];
  if (!v4)
  {
LABEL_30:
    uint64_t v25 = *(void *)(a2 + 32);
    os_log_type_t v26 = *(void **)(a2 + 40);
    if (v25)
    {
      *(void *)(v25 + 40) = v26;
      os_log_type_t v26 = *(void **)(a2 + 40);
    }

    else
    {
      *(void *)(v5 + _Block_object_dispose((const void *)(v50 - 136), 8) = v26;
    }

    *os_log_type_t v26 = v25;
    *(void *)(a2 + 32) = 0LL;
    *(void *)(a2 + 40) = 0LL;
    uint64_t v24 = 1LL;
    nw_frame_finalize(a2);
    return v24;
  }

  uint64_t v6 = *(unsigned __int16 *)(v5 + 72);
  else {
    size_t v7 = 16 - v6;
  }
  memcpy((void *)(v5 + v6 + 56), v4, v7);
  uint64_t v5 = a1[5];
  unsigned __int16 v8 = *(_WORD *)(v5 + 72) + v7;
  *(_WORD *)(v5 + 72) = v8;
  if (!v8) {
    goto LABEL_23;
  }
  uint64_t v9 = (_DWORD *)(v5 + 56);
  unint64_t v10 = *(unsigned __int8 *)(v5 + 56);
  if (v10 <= 0x3F)
  {
    unsigned int v11 = 1;
    goto LABEL_8;
  }

  unsigned int v16 = v10 >> 6;
  if (v16 == 2)
  {
    if (v8 < 4u) {
      goto LABEL_23;
    }
    unint64_t v10 = bswap32(*v9 & 0xFFFFFF7F);
    unsigned int v11 = 4;
  }

  else
  {
    if (v16 == 1)
    {
      if (v8 >= 2u)
      {
        unint64_t v10 = bswap32(*(_WORD *)v9 & 0xFFBF) >> 16;
        unsigned int v11 = 2;
        goto LABEL_8;
      }

uint64_t ___ZL43nw_http_capsule_framer_process_capsule_bodyP22nw_http_capsule_framerP11nw_protocolPb_block_invoke( uint64_t a1, _DWORD *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) += nw_frame_unclaimed_length(a2);
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  return 1LL;
}

uint64_t ___ZL43nw_http_capsule_framer_process_capsule_bodyP22nw_http_capsule_framerP11nw_protocolPb_block_invoke_2( uint64_t a1, uint64_t a2)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  uint64_t v4 = *(void *)(a2 + 32);
  uint64_t v5 = *(void **)(a2 + 40);
  uint64_t v6 = (void *)(a2 + 32);
  if (v4)
  {
    *(void *)(v4 + 40) = v5;
    uint64_t v5 = *(void **)(a2 + 40);
  }

  else
  {
    *(void *)(*(void *)(a1 + 48) + 8LL) = v5;
  }

  void *v5 = v4;
  *uint64_t v6 = 0LL;
  *(void *)(a2 + 40) = 0LL;
  unsigned int v7 = nw_frame_unclaimed_length((_DWORD *)a2);
  uint64_t v8 = *(void *)(a1 + 48);
  unint64_t v9 = *(void *)(v8 + 40);
  uint64_t v10 = v7;
  if (v9 < v7)
  {
    uint64_t v33 = a2;
    uint64_t v11 = nw_frame_split(&v33, v9);
    uint64_t v12 = *(void *)(a1 + 48);
    unint64_t v13 = *(void *)(v12 + 40) - v9;
    *(void *)(v12 + 40) = v13;
    if (!v13) {
      **(_BYTE **)(a1 + 56) = 1;
    }
    if (v11)
    {
      *(void *)(v11 + 32) = 0LL;
      int v14 = *(uint64_t **)(v12 + 24);
      *(void *)(v11 + 40) = v14;
      *int v14 = v11;
      *(void *)(v12 + 24) = v11 + 32;
      ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
      char v15 = *(uint64_t **)(a1 + 48);
      uint64_t v16 = v33;
      uint64_t v17 = *v15;
      uint64_t v18 = v33;
      *(void *)(v33 + 32) = *v15;
      uint64_t v19 = v18 + 32;
      if (v17) {
        uint64_t v20 = (uint64_t *)(v17 + 40);
      }
      else {
        uint64_t v20 = v15 + 1;
      }
      uint64_t *v20 = v19;
      uint64_t *v15 = v16;
      *(void *)(v16 + 40) = v15;
      return 0LL;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v35 = "nw_http_capsule_framer_process_capsule_body_block_invoke_2";
    uint64_t v25 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v25, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v26 = (os_log_s *)gLogObj;
        os_log_type_t v27 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_28;
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v35 = "nw_http_capsule_framer_process_capsule_body_block_invoke";
        unsigned int v28 = "%{public}s nw_frame_split returned NULL frame";
        goto LABEL_27;
      }

      if (!v31)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v26 = (os_log_s *)gLogObj;
        os_log_type_t v27 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_28;
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v35 = "nw_http_capsule_framer_process_capsule_body_block_invoke";
        unsigned int v28 = "%{public}s nw_frame_split returned NULL frame, backtrace limit exceeded";
        goto LABEL_27;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v26 = (os_log_s *)gLogObj;
      os_log_type_t v27 = type;
      BOOL v30 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v35 = "nw_http_capsule_framer_process_capsule_body_block_invoke";
          __int16 v36 = 2082;
          uint64_t v37 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v26,  v27,  "%{public}s nw_frame_split returned NULL frame, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }

      if (v30)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v35 = "nw_http_capsule_framer_process_capsule_body_block_invoke";
        unsigned int v28 = "%{public}s nw_frame_split returned NULL frame, no backtrace";
LABEL_27:
        _os_log_impl(&dword_181A5C000, v26, v27, v28, buf, 0xCu);
      }
    }

BOOL nw_http_capsule_framer_get_output_frames( uint64_t a1, uint64_t a2, unint64_t a3, unsigned int a4, unsigned int a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_capsule_framer_get_output_frames";
    __n128 v29 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v45)
      {
        BOOL v30 = (os_log_s *)__nwlog_obj();
        os_log_type_t v31 = type;
        if (!os_log_type_enabled(v30, type)) {
          goto LABEL_75;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_capsule_framer_get_output_frames";
        uint64_t v32 = "%{public}s called with null framer, backtrace limit exceeded";
        goto LABEL_74;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = type;
      BOOL v34 = os_log_type_enabled(v30, type);
      if (!backtrace_string)
      {
        if (!v34) {
          goto LABEL_75;
        }
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_capsule_framer_get_output_frames";
        uint64_t v32 = "%{public}s called with null framer, no backtrace";
        goto LABEL_74;
      }

      if (v34)
      {
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_capsule_framer_get_output_frames";
        *(_WORD *)&_BYTE buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        uint64_t v35 = "%{public}s called with null framer, dumping backtrace:%{public}s";
LABEL_59:
        _os_log_impl(&dword_181A5C000, v30, v31, v35, buf, 0x16u);
      }

uint64_t __nw_http_capsule_framer_get_output_frames_block_invoke(uint64_t a1, _DWORD *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  unsigned int v19 = 0;
  nw_frame_get_buffer((uint64_t)a2, &v19);
  int v4 = *(_DWORD *)(a1 + 48);
  if (v19 >> 30) {
    int v5 = 8;
  }
  else {
    int v5 = 4;
  }
  if (v19 >= 0x4000) {
    int v6 = v5;
  }
  else {
    int v6 = 2;
  }
  if (v19 >= 0x40) {
    int v7 = v6;
  }
  else {
    int v7 = 1;
  }
  int v8 = v7 + v4;
  if (v7 + v4 < nw_frame_unclaimed_length(a2))
  {
    nw_frame_claim((uint64_t)a2, v9, v8, 0);
    return 1LL;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v21 = "nw_http_capsule_framer_get_output_frames_block_invoke";
  uint64_t v10 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (os_log_s *)gLogObj;
      os_log_type_t v12 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v21 = "nw_http_capsule_framer_get_output_frames_block_invoke";
        unint64_t v13 = "%{public}s Received frame contains less than minimum unclaimed bytes";
LABEL_25:
        _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (os_log_s *)gLogObj;
      os_log_type_t v12 = type;
      BOOL v15 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v21 = "nw_http_capsule_framer_get_output_frames_block_invoke";
          __int16 v22 = 2082;
          int v23 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s Received frame contains less than minimum unclaimed bytes, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }

      if (v15)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v21 = "nw_http_capsule_framer_get_output_frames_block_invoke";
        unint64_t v13 = "%{public}s Received frame contains less than minimum unclaimed bytes, no backtrace";
        goto LABEL_25;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (os_log_s *)gLogObj;
      os_log_type_t v12 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v21 = "nw_http_capsule_framer_get_output_frames_block_invoke";
        unint64_t v13 = "%{public}s Received frame contains less than minimum unclaimed bytes, backtrace limit exceeded";
        goto LABEL_25;
      }
    }
  }

uint64_t nw_http_capsule_framer_finalize_output_frames(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v30 = "nw_http_capsule_framer_finalize_output_frames";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v28 = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (v28 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = v28;
      if (!os_log_type_enabled(v12, v28)) {
        goto LABEL_52;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v30 = "nw_http_capsule_framer_finalize_output_frames";
      int v14 = "%{public}s called with null framer";
    }

    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = v28;
      BOOL v16 = os_log_type_enabled(v12, v28);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v30 = "nw_http_capsule_framer_finalize_output_frames";
          __int16 v31 = 2082;
          uint64_t v32 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v13,  "%{public}s called with null framer, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_52:
        if (!v11) {
          return 0LL;
        }
LABEL_53:
        free(v11);
        return 0LL;
      }

      if (!v16) {
        goto LABEL_52;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v30 = "nw_http_capsule_framer_finalize_output_frames";
      int v14 = "%{public}s called with null framer, no backtrace";
    }

    else
    {
      os_log_type_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = v28;
      if (!os_log_type_enabled(v12, v28)) {
        goto LABEL_52;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v30 = "nw_http_capsule_framer_finalize_output_frames";
      int v14 = "%{public}s called with null framer, backtrace limit exceeded";
    }

    goto LABEL_51;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v30 = "nw_http_capsule_framer_finalize_output_frames";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v28 = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (v28 != OS_LOG_TYPE_FAULT)
    {
      if (!v27)
      {
        os_log_type_t v12 = (os_log_s *)__nwlog_obj();
        os_log_type_t v13 = v28;
        if (!os_log_type_enabled(v12, v28)) {
          goto LABEL_52;
        }
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v30 = "nw_http_capsule_framer_finalize_output_frames";
        int v14 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_51;
      }

      char v17 = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = v28;
      BOOL v18 = os_log_type_enabled(v12, v28);
      if (!v17)
      {
        if (!v18) {
          goto LABEL_52;
        }
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v30 = "nw_http_capsule_framer_finalize_output_frames";
        int v14 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_51;
      }

      if (v18)
      {
        *(_DWORD *)__int128 buf = 136446466;
        BOOL v30 = "nw_http_capsule_framer_finalize_output_frames";
        __int16 v31 = 2082;
        uint64_t v32 = v17;
        unsigned int v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_36:
        _os_log_impl(&dword_181A5C000, v12, v13, v19, buf, 0x16u);
      }

BOOL __nw_http_capsule_framer_finalize_output_frames_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  unint64_t v4 = *(void *)(a1 + 32);
  if (v4 == 420171067 && (nw_frame_is_metadata_complete(a2) & 1) != 0) {
    unint64_t v4 = 420171068LL;
  }
  if (!*(void *)(a1 + 48))
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    int v38 = "nw_http_capsule_framer_write_capsule_header";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type[0];
      if (!os_log_type_enabled(v8, type[0])) {
        goto LABEL_68;
      }
      *(_DWORD *)__int128 buf = 136446210;
      int v38 = "nw_http_capsule_framer_write_capsule_header";
      uint64_t v10 = "%{public}s called with null protocol";
    }

    else if (v36)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type[0];
      BOOL v12 = os_log_type_enabled(v8, type[0]);
      if (backtrace_string)
      {
        if (!v12) {
          goto LABEL_89;
        }
        *(_DWORD *)__int128 buf = 136446466;
        int v38 = "nw_http_capsule_framer_write_capsule_header";
        __int16 v39 = 2082;
        unint64_t v40 = (unint64_t)backtrace_string;
        os_log_type_t v13 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_88;
      }

      if (!v12) {
        goto LABEL_68;
      }
      *(_DWORD *)__int128 buf = 136446210;
      int v38 = "nw_http_capsule_framer_write_capsule_header";
      uint64_t v10 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v8 = (os_log_s *)__nwlog_obj();
      os_log_type_t v9 = type[0];
      if (!os_log_type_enabled(v8, type[0])) {
        goto LABEL_68;
      }
      *(_DWORD *)__int128 buf = 136446210;
      int v38 = "nw_http_capsule_framer_write_capsule_header";
      uint64_t v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t nw_http_capsule_framer_parse_vle_value(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v24[1] = *MEMORY[0x1895F89C0];
  v23[0] = 0LL;
  v23[1] = v23;
  v23[2] = 0x2000000000LL;
  v23[3] = v24;
  v24[0] = 0LL;
  v21[0] = 0LL;
  v21[1] = v21;
  void v21[2] = 0x2000000000LL;
  char v22 = 0;
  uint64_t v17 = 0LL;
  int v18 = &v17;
  uint64_t v19 = 0x2000000000LL;
  char v20 = 0;
  v8[0] = MEMORY[0x1895F87A8];
  v8[1] = 0x40000000LL;
  os_log_type_t v9 = (uint64_t (*)(void *))__nw_http_capsule_framer_parse_vle_value_block_invoke;
  uint64_t v10 = &unk_189BBFC08;
  uint64_t v11 = v21;
  BOOL v12 = v23;
  os_log_type_t v13 = &v17;
  uint64_t v14 = a3;
  uint64_t v15 = a2;
  uint64_t v16 = a1;
  uint64_t v3 = *(void *)(a1 + 16);
  do
  {
    if (!v3) {
      break;
    }
    uint64_t v4 = *(void *)(v3 + 32);
    char v5 = v9(v8);
    uint64_t v3 = v4;
  }

  while ((v5 & 1) != 0);
  uint64_t v6 = *((unsigned __int8 *)v18 + 24);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(v21, 8);
  _Block_object_dispose(v23, 8);
  return v6;
}

BOOL __nw_http_capsule_framer_parse_vle_value_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  unsigned int v26 = 0;
  uint64_t v4 = (const void *)nw_frame_unclaimed_bytes(a2, &v26);
  if (!v4) {
    goto LABEL_11;
  }
  uint64_t v5 = *(unsigned __int8 *)(*(void *)(a1[4] + 8LL) + 24LL);
  else {
    size_t v6 = v26;
  }
  memcpy(*(void **)(*(void *)(a1[5] + 8LL) + 24LL), v4, v6);
  *(_BYTE *)(*(void *)(a1[4] + 8LL) + 24LL) += v6;
  uint64_t v8 = *(_DWORD **)(*(void *)(a1[5] + 8LL) + 24LL);
  if (!v8)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v30 = "_http_vle_decode";
    int v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v19 = (os_log_s *)__nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v30 = "_http_vle_decode";
      uint64_t v21 = "%{public}s called with null *buffer";
      goto LABEL_52;
    }

    if (!v27)
    {
      uint64_t v19 = (os_log_s *)__nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v30 = "_http_vle_decode";
      uint64_t v21 = "%{public}s called with null *buffer, backtrace limit exceeded";
      goto LABEL_52;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v19 = (os_log_s *)__nwlog_obj();
    os_log_type_t v20 = type;
    BOOL v23 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (!v23) {
        goto LABEL_53;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v30 = "_http_vle_decode";
      uint64_t v21 = "%{public}s called with null *buffer, no backtrace";
      goto LABEL_52;
    }

    if (v23)
    {
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v30 = "_http_vle_decode";
      __int16 v31 = 2082;
      unsigned int v32 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s called with null *buffer, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_53:
    if (!v18) {
      goto LABEL_11;
    }
    goto LABEL_54;
  }

  os_log_type_t v9 = (unint64_t *)a1[7];
  if (!v9)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v30 = "_http_vle_decode";
    int v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v19 = (os_log_s *)__nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v30 = "_http_vle_decode";
      uint64_t v21 = "%{public}s called with null decoded_val";
      goto LABEL_52;
    }

    if (!v27)
    {
      uint64_t v19 = (os_log_s *)__nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v30 = "_http_vle_decode";
      uint64_t v21 = "%{public}s called with null decoded_val, backtrace limit exceeded";
      goto LABEL_52;
    }

    unsigned int v24 = (char *)__nw_create_backtrace_string();
    uint64_t v19 = (os_log_s *)__nwlog_obj();
    os_log_type_t v20 = type;
    BOOL v25 = os_log_type_enabled(v19, type);
    if (v24)
    {
      if (v25)
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v30 = "_http_vle_decode";
        __int16 v31 = 2082;
        unsigned int v32 = v24;
        _os_log_impl( &dword_181A5C000,  v19,  v20,  "%{public}s called with null decoded_val, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v24);
      if (!v18) {
        goto LABEL_11;
      }
LABEL_54:
      free(v18);
      goto LABEL_11;
    }

    if (v25)
    {
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v30 = "_http_vle_decode";
      uint64_t v21 = "%{public}s called with null decoded_val, no backtrace";
LABEL_52:
      _os_log_impl(&dword_181A5C000, v19, v20, v21, buf, 0xCu);
      goto LABEL_53;
    }

    goto LABEL_53;
  }

  uint64_t v10 = *(void *)(a1[4] + 8LL);
  unsigned int v11 = *(unsigned __int8 *)(v10 + 24);
  if (!*(_BYTE *)(v10 + 24)) {
    goto LABEL_11;
  }
  unint64_t v12 = *(unsigned __int8 *)v8;
  if (v12 <= 0x3F)
  {
    int v13 = 1;
LABEL_10:
    unint64_t *v9 = v12;
    *(_BYTE *)(*(void *)(a1[6] + 8LL) + 24LL) = 1;
    nw_frame_claim(a2, v7, v13 - v5, 0);
    goto LABEL_11;
  }

  unsigned int v17 = v12 >> 6;
  if (v17 == 2)
  {
    if (v11 >= 4)
    {
      unint64_t v12 = bswap32(*v8 & 0xFFFFFF7F);
      int v13 = 4;
      goto LABEL_10;
    }
  }

  else if (v17 == 1)
  {
    if (v11 >= 2)
    {
      unint64_t v12 = bswap32(*(_WORD *)v8 & 0xFFBF) >> 16;
      int v13 = 2;
      goto LABEL_10;
    }
  }

  else if (v11 >= 8)
  {
    unint64_t v12 = bswap64(*(void *)v8 & 0xFFFFFFFFFFFFFF3FLL);
    int v13 = 8;
    goto LABEL_10;
  }

void sub_18229530C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, objc_super a14)
{
  a14.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_unique_connection_request;
  -[_Unwind_Exception dealloc](&a14, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_18229571C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *nw_service_connector_copy_connection_description(NWConcrete_nw_connection *a1)
{
  id v1 = a1;
  uint64_t v2 = nw_connection_copy_description((nw_connection_t)v1);
  if (v2)
  {
    uint64_t v3 = nw_connection_copy_current_path((nw_connection_t)v1);
    uint64_t v4 = v3;
    if (v3)
    {
      nw_endpoint_t v5 = nw_path_copy_effective_local_endpoint(v3);
      nw_endpoint_t v6 = v5;
      if (v5)
      {
        logging_description = nw_endpoint_get_logging_description(v5);
        if (logging_description)
        {
          os_log_type_t v9 = 0LL;
          asprintf(&v9, "%s local %s", v2, logging_description);
          free(v2);
          uint64_t v2 = v9;
        }
      }
    }

    else
    {
      nw_endpoint_t v6 = 0LL;
    }
  }

  else
  {
    nw_endpoint_t v6 = 0LL;
  }

  return v2;
}

void sub_18229583C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182295E70( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, objc_super a14)
{
  a14.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_unique_connection;
  -[_Unwind_Exception dealloc](&a14, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_182296218(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_182296570( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_service_connector;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

id nw_service_connector_create(int a1, void *a2, void *a3)
{
  uint64_t v95 = *MEMORY[0x1895F89C0];
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = v6;
  if (a1)
  {
    if (v6)
    {
      uint64_t v8 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_service_connector);
      os_log_type_t v9 = v8;
      if (v8)
      {
        do
          unint64_t v10 = __ldaxr(&nw_service_connector_create::sNWSCUniqueID);
        while (__stlxr(v10 + 1, &nw_service_connector_create::sNWSCUniqueID));
        v8->uniqueID = v10;
        v8->state = 1;
        v8->localPortHBO = a1;
        objc_storeStrong((id *)&v8->serviceConnectorQueue, a3);
        if (v5)
        {
          id v11 = v5;
          BOOL v12 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]( (id *)objc_alloc(&OBJC_CLASS___NWConcrete_nw_parameters),  v11,  0,  0);

          clientParameters = v9->clientParameters;
          v9->clientParameters = (OS_nw_parameters *)v12;
        }

        else
        {
          clientParameters = v9->clientParameters;
          v9->clientParameters = 0LL;
        }

        BOOL v18 = nw_array_create();
        pendingUnverifiedIncomingRequests = v9->pendingUnverifiedIncomingRequests;
        v9->pendingUnverifiedIncomingRequests = (OS_nw_array *)v18;

        os_log_type_t v20 = (OS_nw_dictionary *)nw_dictionary_create();
        pendingIncomingRequests = v9->pendingIncomingRequests;
        v9->pendingIncomingRequests = v20;

        if (v9->pendingIncomingRequests)
        {
          char v22 = (OS_nw_dictionary *)nw_dictionary_create();
          activeConnections = v9->activeConnections;
          v9->activeConnections = v22;

          if (!v9->activeConnections)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v44 = (id)gLogObj;
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_service_connector_create";
            uint64_t v15 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            v91[0] = 0;
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v16 = (os_log_s *)(id)gLogObj;
              os_log_type_t v45 = type[0];
              if (os_log_type_enabled(v16, type[0]))
              {
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                _os_log_impl(&dword_181A5C000, v16, v45, "%{public}s nw_dictionary_create failed", buf, 0xCu);
              }
            }

            else if (v91[0])
            {
              backtrace_string = __nw_create_backtrace_string();
              if (backtrace_string)
              {
                uint64_t v51 = (char *)backtrace_string;
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                unint64_t v52 = (os_log_s *)(id)gLogObj;
                os_log_type_t v53 = type[0];
                if (os_log_type_enabled(v52, type[0]))
                {
                  *(_DWORD *)__int128 buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                  *(_WORD *)&_BYTE buf[12] = 2082;
                  *(void *)&buf[14] = v51;
                  _os_log_impl( &dword_181A5C000,  v52,  v53,  "%{public}s nw_dictionary_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
                }

                free(v51);
                if (!v15) {
                  goto LABEL_99;
                }
                goto LABEL_98;
              }

              __nwlog_obj();
              uint64_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v63 = type[0];
              if (os_log_type_enabled(v16, type[0]))
              {
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                _os_log_impl( &dword_181A5C000,  v16,  v63,  "%{public}s nw_dictionary_create failed, no backtrace",  buf,  0xCu);
              }
            }

            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v16 = (os_log_s *)(id)gLogObj;
              os_log_type_t v62 = type[0];
              if (os_log_type_enabled(v16, type[0]))
              {
                *(_DWORD *)__int128 buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                _os_log_impl( &dword_181A5C000,  v16,  v62,  "%{public}s nw_dictionary_create failed, backtrace limit exceeded",  buf,  0xCu);
              }
            }

            goto LABEL_96;
          }

          unsigned int v24 = (OS_nw_dictionary *)nw_dictionary_create();
          activeOutgoingRequests = v9->activeOutgoingRequests;
          v9->activeOutgoingRequests = v24;

          if (v9->activeOutgoingRequests)
          {
            unsigned int v26 = (OS_xpc_object *)xpc_dictionary_create(0LL, 0LL, 0LL);
            remotePubKeys = v9->remotePubKeys;
            v9->remotePubKeys = v26;

            if (v9->remotePubKeys)
            {
              os_log_type_t v28 = v9;
              CFErrorRef error = 0LL;
              SecAccessControlRef v29 = SecAccessControlCreateWithFlags( (CFAllocatorRef)*MEMORY[0x189604DB0],  (CFTypeRef)*MEMORY[0x18960B850],  0x40000000uLL,  &error);
              SecAccessControlRef v30 = v29;
              if (v29)
              {
                uint64_t v31 = *MEMORY[0x18960B9C0];
                uint64_t v32 = *MEMORY[0x18960BAB8];
                *(void *)os_log_type_t type = *MEMORY[0x18960B998];
                uint64_t v89 = v32;
                uint64_t v33 = *MEMORY[0x18960BAC0];
                *(void *)__int128 buf = v31;
                *(void *)&uint8_t buf[8] = v33;
                uint64_t v90 = *MEMORY[0x18960BDF0];
                uint64_t v34 = *MEMORY[0x18960B818];
                v86[0] = *MEMORY[0x18960B948];
                v86[1] = v34;
                v87[0] = MEMORY[0x189604A80];
                v87[1] = v29;
                [MEMORY[0x189603F68] dictionaryWithObjects:v87 forKeys:v86 count:2];
                uint64_t v35 = (void *)objc_claimAutoreleasedReturnValue();
                *(void *)&buf[16] = v35;
                [MEMORY[0x189603F68] dictionaryWithObjects:buf forKeys:type count:3];
                char v36 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();

                CFRelease(v30);
                SecKeyRef v37 = SecKeyCreateRandomKey(v36, &error);
                v28->localPrivKey = v37;
                if (v37)
                {
                  int v38 = SecKeyCopyPublicBytes();
                  __nwlog_obj();
                  uint64_t v82 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)unint64_t v91 = 136446466;
                    uint64_t v92 = "nwsc_generate_keys";
                    __int16 v93 = 1024;
                    LODWORD(v94) = v38;
                    _os_log_impl( &dword_181A5C000,  v82,  OS_LOG_TYPE_ERROR,  "%{public}s SecKeyCopyPublicBytes failed with error %d",  v91,  0x12u);
                  }

                  localPrivKey = v28->localPrivKey;
                  if (localPrivKey)
                  {
                    CFRelease(localPrivKey);
                    v28->localPrivKey = 0LL;
                  }
                }

                else
                {
                  __nwlog_obj();
                  char v81 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)unint64_t v91 = 136446466;
                    uint64_t v92 = "nwsc_generate_keys";
                    __int16 v93 = 2112;
                    CFErrorRef v94 = error;
                    _os_log_impl( &dword_181A5C000,  v81,  OS_LOG_TYPE_ERROR,  "%{public}s SecKeyCreateRandomKey failed with error %@",  v91,  0x16u);
                  }
                }
              }

              else
              {
                __nwlog_obj();
                char v36 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)unint64_t v91 = 136446466;
                  uint64_t v92 = "nwsc_generate_keys";
                  __int16 v93 = 2112;
                  CFErrorRef v94 = error;
                  _os_log_impl( &dword_181A5C000,  v36,  OS_LOG_TYPE_ERROR,  "%{public}s SecAccessControlCreateWithFlags failed with error %@",  v91,  0x16u);
                }
              }

              goto LABEL_99;
            }

            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v55 = (id)gLogObj;
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_service_connector_create";
            uint64_t v15 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            v91[0] = 0;
            if (!__nwlog_fault(v15, type, v91))
            {
LABEL_97:
              if (!v15)
              {
LABEL_99:

                goto LABEL_100;
              }

void sub_182297D88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_service_connector_set_service_available_block(void *a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    char v27 = "nw_service_connector_set_service_available_block";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v25 = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (v25 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v27 = "nw_service_connector_set_service_available_block";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = v25;
      BOOL v15 = os_log_type_enabled(v9, v25);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)__int128 buf = 136446466;
          char v27 = "nw_service_connector_set_service_available_block";
          __int16 v28 = 2082;
          SecAccessControlRef v29 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          goto LABEL_4;
        }
LABEL_39:
        free(v8);
        goto LABEL_4;
      }

      if (v15)
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v27 = "nw_service_connector_set_service_available_block";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v27 = "nw_service_connector_set_service_available_block";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void __nw_service_connector_set_service_available_block_block_invoke(uint64_t a1)
{
  uint64_t v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(void **)(v3 + 64);
  *(void *)(v3 + 64) = v2;
}

void nw_service_connector_start(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (dispatch_queue_s *)v1[4];
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __nw_service_connector_start_block_invoke;
    block[3] = &unk_189BC93A0;
    int v13 = v1;
    dispatch_async(v3, block);

    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v17 = "nw_service_connector_start";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_service_connector_start";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v17 = "nw_service_connector_start";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_service_connector_start";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_service_connector_start";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __nw_service_connector_start_block_invoke(uint64_t a1)
{
  uint64_t v94 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v2 + 16) != 4)
  {
    int v9 = *(unsigned __int8 *)(v2 + 50);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v10 = (os_log_s *)(id)gLogObj;
    BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
    if (v9)
    {
      if (!v11) {
        goto LABEL_19;
      }
      os_log_type_t v12 = *(void **)(a1 + 32);
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v87 = "nw_service_connector_start_block_invoke";
      __int16 v88 = 2114;
      uint64_t v89 = v12;
      int v13 = "%{public}s %{public}@ restarting";
    }

    else
    {
      if (!v11) {
        goto LABEL_19;
      }
      __int16 v18 = *(void **)(a1 + 32);
      *(_DWORD *)__int128 buf = 136446466;
      uint64_t v87 = "nw_service_connector_start_block_invoke";
      __int16 v88 = 2114;
      uint64_t v89 = v18;
      int v13 = "%{public}s Client starting %{public}@";
    }

    _os_log_impl(&dword_181A5C000, v10, OS_LOG_TYPE_DEFAULT, v13, buf, 0x16u);
LABEL_19:

    uint64_t v19 = *(void *)(a1 + 32);
    int v20 = *(_DWORD *)(v19 + 16);
    if (v20 != 1)
    {
      if (v20 == 2)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v21 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          char v22 = *(void **)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v87 = "nw_service_connector_start_block_invoke";
          __int16 v88 = 2114;
          uint64_t v89 = v22;
          _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ Service connector already started",  buf,  0x16u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v21 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          char v27 = *(void **)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v87 = "nw_service_connector_start_block_invoke";
          __int16 v88 = 2114;
          uint64_t v89 = v27;
          _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ Service connector could not be started",  buf,  0x16u);
        }
      }

      return;
    }

    *(_WORD *)os_log_type_t type = 7708;
    __int16 v81 = bswap32(*(unsigned __int16 *)(v19 + 48)) >> 16;
    int v82 = 0;
    __int128 v83 = *MEMORY[0x1895FB7E8];
    int v84 = 0;
    uint64_t address = nw_endpoint_create_address((const sockaddr *)type);
    if (address)
    {
      char v24 = *(void **)(*(void *)(a1 + 32) + 24LL);
      if (v24)
      {
        id v25 = v24;
        nw_parameters_set_data_mode(v25, 2u);
        legacy_tcp_socket = (nw_parameters *)v25;
        *(_WORD *)(*((void *)legacy_tcp_socket + 13) + 100LL) |= 0x10u;

        nw_parameters_set_tfo(legacy_tcp_socket, 1);
        goto LABEL_44;
      }

      legacy_tcp_socket = nw_parameters_create_legacy_tcp_socket(&__block_literal_global_49022);
      if (legacy_tcp_socket)
      {
LABEL_44:
        nw_parameters_set_local_endpoint(legacy_tcp_socket, address);
        uint64_t v35 = legacy_tcp_socket;
        *((void *)v35 + 12) |= 0x8000000uLL;

        char v36 = *(nw_listener **)(*(void *)(a1 + 32) + 8LL);
        if (v36)
        {
          nw_listener_cancel(v36);
          uint64_t v37 = *(void *)(a1 + 32);
          int v38 = *(void **)(v37 + 8);
          *(void *)(v37 + _Block_object_dispose((const void *)(v50 - 136), 8) = 0LL;
        }

        nw_listener_t v39 = nw_listener_create(v35);
        if (v39)
        {
          objc_storeStrong((id *)(*(void *)(a1 + 32) + 8LL), v39);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v40 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v41 = *(void **)(a1 + 32);
            uint64_t v42 = v41[1];
            *(_DWORD *)__int128 buf = 136446978;
            uint64_t v87 = "nw_service_connector_start_block_invoke";
            __int16 v88 = 2114;
            uint64_t v89 = v41;
            __int16 v90 = 2048;
            *(void *)unint64_t v91 = v42;
            *(_WORD *)&v91[8] = 2112;
            uint64_t v92 = v42;
            _os_log_impl( &dword_181A5C000,  v40,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ Created listener<%p> %@",  buf,  0x2Au);
          }

          BOOL v43 = *(void **)(a1 + 32);
          id v44 = (nw_listener *)v43[1];
          uint64_t v45 = MEMORY[0x1895F87A8];
          handler[0] = MEMORY[0x1895F87A8];
          handler[1] = 3221225472LL;
          handler[2] = __nw_service_connector_start_block_invoke_96;
          handler[3] = &unk_189BBFCC0;
          os_log_type_t v77 = v43;
          os_log_type_t v46 = v39;
          BOOL v78 = v46;
          nw_listener_set_new_connection_handler(v44, handler);
          BOOL v47 = *(void **)(a1 + 32);
          id v48 = (nw_listener *)v47[1];
          v73[0] = v45;
          v73[1] = 3221225472LL;
          v73[2] = __nw_service_connector_start_block_invoke_98;
          v73[3] = &unk_189BC9490;
          os_log_type_t v74 = v47;
          BOOL v75 = v46;
          nw_listener_set_state_changed_handler(v48, v73);
          nw_listener_set_queue( *(nw_listener_t *)(*(void *)(a1 + 32) + 8LL),  *(dispatch_queue_t *)(*(void *)(a1 + 32) + 32LL));
          nw_listener_start(*(nw_listener_t *)(*(void *)(a1 + 32) + 8LL));
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v49 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v50 = *(unsigned __int8 **)(a1 + 32);
            int v51 = v50[120];
            int v52 = v50[121];
            int v53 = v50[122];
            int v54 = v50[123];
            *(_DWORD *)__int128 buf = 136447490;
            uint64_t v87 = "nw_service_connector_start_block_invoke";
            __int16 v88 = 2114;
            uint64_t v89 = v50;
            __int16 v90 = 1024;
            *(_DWORD *)unint64_t v91 = v51;
            *(_WORD *)&uint8_t v91[4] = 1024;
            *(_DWORD *)&v91[6] = v52;
            LOWORD(v92) = 1024;
            *(_DWORD *)((char *)&v92 + 2) = v53;
            HIWORD(v92) = 1024;
            int v93 = v54;
            _os_log_impl( &dword_181A5C000,  v49,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ Listener started, localPubKeyStart %02x%02x%02x%02x",  buf,  0x2Eu);
          }

LABEL_93:
LABEL_102:

          return;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v55 = (id)gLogObj;
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v87 = "nw_service_connector_start_block_invoke";
        os_log_type_t v56 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t v85 = OS_LOG_TYPE_ERROR;
        char v79 = 0;
        if (__nwlog_fault(v56, &v85, &v79))
        {
          if (v85 == OS_LOG_TYPE_FAULT)
          {
            __nwlog_obj();
            os_log_type_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v58 = v85;
            if (os_log_type_enabled(v57, v85))
            {
              *(_DWORD *)__int128 buf = 136446210;
              uint64_t v87 = "nw_service_connector_start_block_invoke";
              _os_log_impl(&dword_181A5C000, v57, v58, "%{public}s nw_listener_create failed", buf, 0xCu);
            }
          }

          else if (v79)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            __nwlog_obj();
            os_log_type_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v63 = v85;
            BOOL v64 = os_log_type_enabled(v57, v85);
            if (backtrace_string)
            {
              if (v64)
              {
                *(_DWORD *)__int128 buf = 136446466;
                uint64_t v87 = "nw_service_connector_start_block_invoke";
                __int16 v88 = 2082;
                uint64_t v89 = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v57,  v63,  "%{public}s nw_listener_create failed, dumping backtrace:%{public}s",  buf,  0x16u);
              }

              free(backtrace_string);
              goto LABEL_91;
            }

            if (v64)
            {
              *(_DWORD *)__int128 buf = 136446210;
              uint64_t v87 = "nw_service_connector_start_block_invoke";
              _os_log_impl(&dword_181A5C000, v57, v63, "%{public}s nw_listener_create failed, no backtrace", buf, 0xCu);
            }
          }

          else
          {
            __nwlog_obj();
            os_log_type_t v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v71 = v85;
            if (os_log_type_enabled(v57, v85))
            {
              *(_DWORD *)__int128 buf = 136446210;
              uint64_t v87 = "nw_service_connector_start_block_invoke";
              _os_log_impl( &dword_181A5C000,  v57,  v71,  "%{public}s nw_listener_create failed, backtrace limit exceeded",  buf,  0xCu);
            }
          }
        }

void sub_1822994CC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, void *a25)
{
  _Unwind_Resume(a1);
}

void __nw_service_connector_start_block_invoke_96(uint64_t a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  id v4 = v3;
  uint64_t v5 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v5 + 16) == 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      int v15 = 136446722;
      BOOL v16 = "nw_service_connector_start_block_invoke";
      __int16 v17 = 2114;
      uint64_t v18 = v7;
      __int16 v19 = 2114;
      int v20 = v4;
      uint64_t v8 = "%{public}s %{public}@ already cancelled, ignoring new connection %{public}@";
      int v9 = v6;
      os_log_type_t v10 = OS_LOG_TYPE_ERROR;
      uint32_t v11 = 32;
LABEL_7:
      _os_log_impl(&dword_181A5C000, v9, v10, v8, (uint8_t *)&v15, v11);
    }
  }

  else
  {
    if (*(void *)(v5 + 8) == *(void *)(a1 + 40))
    {
      nw_connection_set_state_changed_handler(v3, 0LL);
      nw_connection_set_queue(v4, *(dispatch_queue_t *)(*(void *)(a1 + 32) + 32LL));
      nw_connection_start(v4);
      nw_service_connector_should_accept_connection( *(NWConcrete_nw_service_connector **)(a1 + 32),  (NWConcrete_nw_connection *)v4,  1);
      goto LABEL_9;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 32);
      uint64_t v13 = *(void *)(a1 + 40);
      uint64_t v14 = *(void *)(v12 + 8);
      int v15 = 136447234;
      BOOL v16 = "nw_service_connector_start_block_invoke";
      __int16 v17 = 2114;
      uint64_t v18 = v12;
      __int16 v19 = 2114;
      int v20 = v4;
      __int16 v21 = 2048;
      uint64_t v22 = v14;
      __int16 v23 = 2048;
      uint64_t v24 = v13;
      uint64_t v8 = "%{public}s %{public}@ Ignoring new connection %{public}@ for stale listener (%p != %p)";
      int v9 = v6;
      os_log_type_t v10 = OS_LOG_TYPE_DEFAULT;
      uint32_t v11 = 52;
      goto LABEL_7;
    }
  }

  nw_connection_cancel(v4);
LABEL_9:
}

void sub_182299714(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_service_connector_start_block_invoke_98(uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t v87 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a3;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v6 = (os_log_s *)(id)gLogObj;
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (!v7) {
      goto LABEL_13;
    }
    if (a2 > 4) {
      uint64_t v8 = "<unknown>";
    }
    else {
      uint64_t v8 = off_189BB8B98[a2];
    }
    uint64_t v11 = *(void *)(a1 + 32);
    os_log_type_t v10 = *(uint64_t (**)(uint64_t, uint64_t))(a1 + 40);
    *(_DWORD *)__int128 buf = 136447234;
    *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke";
    *(_WORD *)&_BYTE buf[12] = 2114;
    *(void *)&buf[14] = v11;
    *(_WORD *)&_BYTE buf[22] = 2048;
    os_log_type_t v85 = v10;
    *(_WORD *)unint64_t v86 = 2082;
    *(void *)&void v86[2] = v8;
    *(_WORD *)&v86[10] = 2114;
    *(void *)&v86[12] = v5;
    uint64_t v12 = "%{public}s %{public}@ Listener(%p) entered state %{public}s with error %{public}@";
    uint64_t v13 = v6;
    uint32_t v14 = 52;
  }

  else
  {
    if (!v7) {
      goto LABEL_13;
    }
    if (a2 > 4) {
      int v9 = "<unknown>";
    }
    else {
      int v9 = off_189BB8B98[a2];
    }
    uint64_t v16 = *(void *)(a1 + 32);
    int v15 = *(uint64_t (**)(uint64_t, uint64_t))(a1 + 40);
    *(_DWORD *)__int128 buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke";
    *(_WORD *)&_BYTE buf[12] = 2114;
    *(void *)&buf[14] = v16;
    *(_WORD *)&_BYTE buf[22] = 2048;
    os_log_type_t v85 = v15;
    *(_WORD *)unint64_t v86 = 2082;
    *(void *)&void v86[2] = v9;
    uint64_t v12 = "%{public}s %{public}@ Listener(%p) entered state %{public}s";
    uint64_t v13 = v6;
    uint32_t v14 = 42;
  }

  _os_log_impl(&dword_181A5C000, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v14);
LABEL_13:

  uint64_t v17 = *(void *)(a1 + 32);
  int v18 = *(_DWORD *)(v17 + 16);
  if (v18 == 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v19 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      uint64_t v20 = *(void *)(a1 + 32);
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke";
      *(_WORD *)&_BYTE buf[12] = 2114;
      *(void *)&buf[14] = v20;
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ already cancelled, ignoring listener state change",  buf,  0x16u);
    }

void sub_18229A3BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__49049(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__49050(uint64_t a1)
{
}

uint64_t ___ZL49nwsc_start_outgoing_requests_waiting_for_listenerP31NWConcrete_nw_service_connector_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v4 = a3;
  v4[616] &= ~8u;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    int v14 = 136446722;
    int v15 = "nwsc_start_outgoing_requests_waiting_for_listener_block_invoke";
    __int16 v16 = 2114;
    uint64_t v17 = v6;
    __int16 v18 = 2114;
    __int16 v19 = v4;
    _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ starting connection for request %{public}@ due to listener ready",  (uint8_t *)&v14,  0x20u);
  }

  nwsc_request_create_and_start_connection_inner(*(void **)(a1 + 32), v4, 0LL);
  BOOL v7 = (void *)objc_claimAutoreleasedReturnValue();
  BOOL v8 = v7 == 0LL;

  if (v8)
  {
    uint64_t v9 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
    if (!v9)
    {
      BOOL v10 = nw_array_create();
      uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8LL);
      uint64_t v12 = *(void **)(v11 + 40);
      *(void *)(v11 + 40) = v10;

      uint64_t v9 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL);
    }

    nw_array_append(v9, v4);
  }

  return 1LL;
}

void sub_18229A574(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL49nwsc_start_outgoing_requests_waiting_for_listenerP31NWConcrete_nw_service_connector_block_invoke_168( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 32), v4, 0LL, 0LL, 12);
  nw_service_connector_remove_active_outgoing_request(*(NWConcrete_nw_service_connector **)(a1 + 32), v4);

  return 1LL;
}

void sub_18229A5E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_service_connector_start_block_invoke_99(uint64_t a1)
{
  return nw_service_connector_start(*(void *)(a1 + 32));
}

void nw_service_connector_trigger_request_complete_block_inner( void *a1, void *a2, void *a3, void *a4, int a5)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  uint64_t v9 = a1;
  BOOL v10 = a2;
  id v11 = a3;
  id v12 = a4;
  if (v10 && v11)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v13 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446722;
    int v49 = "nw_service_connector_trigger_request_complete_block_inner";
    __int16 v50 = 2114;
    *(void *)os_log_type_t v51 = v9;
    *(_WORD *)&v51[8] = 2114;
    *(void *)&v51[10] = v10;
    int v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v15 = (os_log_s *)(id)gLogObj;
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)__int128 buf = 136446722;
        int v49 = "nw_service_connector_trigger_request_complete_block_inner";
        __int16 v50 = 2114;
        *(void *)os_log_type_t v51 = v9;
        *(_WORD *)&v51[8] = 2114;
        *(void *)&v51[10] = v10;
        _os_log_impl( &dword_181A5C000,  v15,  v16,  "%{public}s %{public}@ cannot call this with both request %{public}@ and otherRequestBlock",  buf,  0x20u);
      }
    }

    else if (v46)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v15 = (os_log_s *)(id)gLogObj;
      os_log_type_t v23 = type;
      BOOL v24 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)__int128 buf = 136446978;
          int v49 = "nw_service_connector_trigger_request_complete_block_inner";
          __int16 v50 = 2114;
          *(void *)os_log_type_t v51 = v9;
          *(_WORD *)&v51[8] = 2114;
          *(void *)&v51[10] = v10;
          __int16 v52 = 2082;
          uint64_t v53 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v23,  "%{public}s %{public}@ cannot call this with both request %{public}@ and otherRequestBlock, dumping backtrace:%{public}s",  buf,  0x2Au);
        }

        free(backtrace_string);
        if (v14) {
          goto LABEL_53;
        }
        goto LABEL_64;
      }

      if (v24)
      {
        *(_DWORD *)__int128 buf = 136446722;
        int v49 = "nw_service_connector_trigger_request_complete_block_inner";
        __int16 v50 = 2114;
        *(void *)os_log_type_t v51 = v9;
        *(_WORD *)&v51[8] = 2114;
        *(void *)&v51[10] = v10;
        _os_log_impl( &dword_181A5C000,  v15,  v23,  "%{public}s %{public}@ cannot call this with both request %{public}@ and otherRequestBlock, no backtrace",  buf,  0x20u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v15 = (os_log_s *)(id)gLogObj;
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)__int128 buf = 136446722;
        int v49 = "nw_service_connector_trigger_request_complete_block_inner";
        __int16 v50 = 2114;
        *(void *)os_log_type_t v51 = v9;
        *(_WORD *)&v51[8] = 2114;
        *(void *)&v51[10] = v10;
        _os_log_impl( &dword_181A5C000,  v15,  v27,  "%{public}s %{public}@ cannot call this with both request %{public}@ and otherRequestBlock, backtrace limit exceeded",  buf,  0x20u);
      }
    }

    goto LABEL_51;
  }

  if (!v10 || (v10[616] & 1) == 0)
  {
    if (a5)
    {
      posix_CFErrorRef error = nw_error_create_posix_error(a5);
      if (posix_error)
      {
LABEL_63:
        uint64_t v38 = (dispatch_queue_s *)v9[4];
        block[0] = MEMORY[0x1895F87A8];
        block[1] = 3221225472LL;
        block[2] = ___ZL57nw_service_connector_trigger_request_complete_block_innerP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestU13block_pointerFvP24NWConcrete_nw_connectionP9__CFErrorES4_i_block_invoke;
        block[3] = &unk_189BBFE68;
        id v45 = v11;
        uint64_t v41 = v10;
        id v42 = posix_error;
        id v43 = v12;
        int v44 = v9;
        uint64_t v39 = posix_error;
        dispatch_async(v38, block);

        goto LABEL_64;
      }

      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v18 = (id)gLogObj;
      *(_DWORD *)__int128 buf = 136446466;
      int v49 = "nw_service_connector_trigger_request_complete_block_inner";
      __int16 v50 = 1024;
      *(_DWORD *)os_log_type_t v51 = a5;
      __int16 v19 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v46 = 0;
      if (__nwlog_fault(v19, &type, &v46))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v20 = (os_log_s *)(id)gLogObj;
          os_log_type_t v21 = type;
          if (os_log_type_enabled(v20, type))
          {
            *(_DWORD *)__int128 buf = 136446466;
            int v49 = "nw_service_connector_trigger_request_complete_block_inner";
            __int16 v50 = 1024;
            *(_DWORD *)os_log_type_t v51 = a5;
            _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s nw_error_create_posix_error(%d) failed", buf, 0x12u);
          }
        }

        else if (v46)
        {
          unsigned int v32 = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v33 = type;
          BOOL v34 = os_log_type_enabled(v20, type);
          if (v32)
          {
            if (v34)
            {
              *(_DWORD *)__int128 buf = 136446722;
              int v49 = "nw_service_connector_trigger_request_complete_block_inner";
              __int16 v50 = 1024;
              *(_DWORD *)os_log_type_t v51 = a5;
              *(_WORD *)&v51[4] = 2082;
              *(void *)&v51[6] = v32;
              _os_log_impl( &dword_181A5C000,  v20,  v33,  "%{public}s nw_error_create_posix_error(%d) failed, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(v32);
            if (!v19) {
              goto LABEL_62;
            }
            goto LABEL_61;
          }

          if (v34)
          {
            *(_DWORD *)__int128 buf = 136446466;
            int v49 = "nw_service_connector_trigger_request_complete_block_inner";
            __int16 v50 = 1024;
            *(_DWORD *)os_log_type_t v51 = a5;
            _os_log_impl( &dword_181A5C000,  v20,  v33,  "%{public}s nw_error_create_posix_error(%d) failed, no backtrace",  buf,  0x12u);
          }
        }

        else
        {
          __nwlog_obj();
          uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v37 = type;
          if (os_log_type_enabled(v20, type))
          {
            *(_DWORD *)__int128 buf = 136446466;
            int v49 = "nw_service_connector_trigger_request_complete_block_inner";
            __int16 v50 = 1024;
            *(_DWORD *)os_log_type_t v51 = a5;
            _os_log_impl( &dword_181A5C000,  v20,  v37,  "%{public}s nw_error_create_posix_error(%d) failed, backtrace limit exceeded",  buf,  0x12u);
          }
        }
      }

      if (v19) {
LABEL_61:
      }
        free(v19);
    }

void sub_18229AFAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_service_connector_remove_active_outgoing_request( NWConcrete_nw_service_connector *a1, NWConcrete_nw_unique_connection_request *a2)
{
  uint64_t v74 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    __int16 v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)os_log_type_t v47 = 136446210;
    *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = buf[0];
      if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)os_log_type_t v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
        _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null serviceConnector", v47, 0xCu);
      }
    }

    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = buf[0];
      BOOL v28 = os_log_type_enabled(v20, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)os_log_type_t v47 = 136446466;
          *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
          *(_WORD *)&v47[12] = 2082;
          *(void *)&v47[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v20,  v27,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  v47,  0x16u);
        }

        free(backtrace_string);
LABEL_23:
        if (!v8) {
          goto LABEL_25;
        }
LABEL_24:
        free(v8);
        goto LABEL_25;
      }

      if (v28)
      {
        *(_DWORD *)os_log_type_t v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
        _os_log_impl( &dword_181A5C000,  v20,  v27,  "%{public}s called with null serviceConnector, no backtrace",  v47,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v34 = buf[0];
      if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)os_log_type_t v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
        _os_log_impl( &dword_181A5C000,  v20,  v34,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  v47,  0xCu);
      }
    }

void sub_18229B9C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nwsc_request_stop_path_watcher(NWConcrete_nw_unique_connection_request *a1)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136446466;
    id v6 = "nwsc_request_stop_path_watcher";
    __int16 v7 = 2114;
    BOOL v8 = v1;
    _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_DEFAULT,  "%{public}s stopping path watcher request %{public}@",  (uint8_t *)&v5,  0x16u);
  }

  pathEvaluator = v1->pathEvaluator;
  if (pathEvaluator)
  {
    nw_path_evaluator_cancel(pathEvaluator);
    id v4 = v1->pathEvaluator;
    v1->pathEvaluator = 0LL;
  }

  *((_BYTE *)v1 + 616) &= ~0x80u;
}

void sub_18229BAE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nwsc_get_identifier(void *a1, uint64_t a2, _BYTE *a3)
{
  id v5 = a1;
  uint64_t endpoint_identifier = nwsc_get_endpoint_identifier(v5, (uint64_t)a3);
  if ((endpoint_identifier & 1) == 0)
  {
LABEL_25:

    return endpoint_identifier;
  }

  if (!a3)
  {
    __nwlog_obj();
    int v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
    os_log_type_t v16 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v16);
    if (result) {
      goto LABEL_35;
    }
    free(v16);
  }

  unint64_t v7 = 436LL;
  BOOL v8 = a3;
  while (*v8)
  {
    ++v8;
    if (!--v7) {
      goto LABEL_10;
    }
  }

  if (v7 >= 2) {
    *v8++ = 64;
  }
  _BYTE *v8 = 0;
LABEL_10:
  if (!a3)
  {
    __nwlog_obj();
    uint64_t v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
    id v18 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v18);
    if (result) {
      goto LABEL_35;
    }
    free(v18);
    if (a2) {
      goto LABEL_12;
    }
LABEL_30:
    __nwlog_obj();
    __int16 v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    uint64_t v20 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v20);
    if (result) {
      goto LABEL_35;
    }
    free(v20);
    goto LABEL_12;
  }

  if (!a2) {
    goto LABEL_30;
  }
LABEL_12:
  unint64_t v9 = 436LL;
  do
  {
    if (!*a3)
    {
      if (a2)
      {
        if (v9 >= 2)
        {
LABEL_20:
          uint64_t v13 = 0LL;
          while (1)
          {
            int v14 = *(unsigned __int8 *)(a2 + v13);
            a3[v13] = v14;
            if (!v14) {
              goto LABEL_25;
            }
            --v9;
            ++v13;
            if (v9 <= 1)
            {
              a3 += v13;
              break;
            }
          }
        }
      }

      else
      {
        unint64_t v23 = v9;
        __nwlog_obj();
        os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
        uint64_t v22 = (void *)_os_log_send_and_compose_impl();

        BOOL result = __nwlog_abort((uint64_t)v22);
        if (result) {
          goto LABEL_35;
        }
        free(v22);
        unint64_t v9 = v23;
        if (v23 >= 2) {
          goto LABEL_20;
        }
      }

      *a3 = 0;
      goto LABEL_25;
    }

    ++a3;
    --v9;
  }

  while (v9);
  if (a2) {
    goto LABEL_25;
  }
  __nwlog_obj();
  os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
  id v11 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v11);
  if (!result)
  {
    free(v11);
    goto LABEL_25;
  }

void sub_18229BEF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nwsc_get_endpoint_identifier(void *a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 4_Block_object_dispose((const void *)(v50 - 136), 8) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  *(_OWORD *)(a2 + 12_Block_object_dispose((const void *)(v50 - 136), 8) = 0u;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 176) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 20_Block_object_dispose((const void *)(v50 - 136), 8) = 0u;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 240) = 0u;
  *(_OWORD *)(a2 + 256) = 0u;
  *(_OWORD *)(a2 + 272) = 0u;
  *(_OWORD *)(a2 + 28_Block_object_dispose((const void *)(v50 - 136), 8) = 0u;
  *(_OWORD *)(a2 + 304) = 0u;
  *(_OWORD *)(a2 + 320) = 0u;
  *(_OWORD *)(a2 + 336) = 0u;
  *(_OWORD *)(a2 + 352) = 0u;
  *(_OWORD *)(a2 + 36_Block_object_dispose((const void *)(v50 - 136), 8) = 0u;
  *(_OWORD *)(a2 + 384) = 0u;
  *(_OWORD *)(a2 + 400) = 0u;
  *(_OWORD *)(a2 + 416) = 0u;
  *(_DWORD *)(a2 + 432) = 0;
  id v4 = nw_endpoint_copy_address_string(v3);
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v7 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v20 = 136446466;
      os_log_type_t v21 = "nwsc_get_endpoint_identifier";
      __int16 v22 = 2112;
      unint64_t v23 = v3;
      _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_ERROR,  "%{public}s Could not get address string from endpoint %@",  (uint8_t *)&v20,  0x16u);
    }

    goto LABEL_35;
  }

  unint64_t v5 = 436LL;
  id v6 = (_BYTE *)a2;
  while (*v6)
  {
    ++v6;
    if (!--v5) {
      goto LABEL_15;
    }
  }

  if (v5 < 2)
  {
LABEL_14:
    *id v6 = 0;
  }

  else
  {
    uint64_t v8 = 0LL;
    while (1)
    {
      int v9 = v4[v8];
      v6[v8] = v9;
      if (!v9) {
        break;
      }
      --v5;
      ++v8;
      if (v5 <= 1)
      {
        v6 += v8;
        goto LABEL_14;
      }
    }
  }

void sub_18229C224(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL57nw_service_connector_trigger_request_complete_block_innerP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestU13block_pointerFvP24NWConcrete_nw_connectionP9__CFErrorES4_i_block_invoke( uint64_t a1)
{
  uint64_t v59 = *MEMORY[0x1895F89C0];
  uint64_t v2 = _Block_copy(*(const void **)(a1 + 64));
  id v3 = v2;
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    unint64_t v5 = (void (**)(void *, void, CFErrorRef))_Block_copy(*(const void **)(v4 + 592));

    uint64_t v6 = *(void *)(a1 + 32);
    unint64_t v7 = *(void **)(v6 + 592);
    *(void *)(v6 + 592) = 0LL;

    uint64_t v8 = (NWConcrete_nw_unique_connection_request *)*(id *)(a1 + 32);
    nwsc_request_stop_path_watcher(v8);
    *((_BYTE *)v8 + 616) &= 0xE7u;

    int v9 = *(nw_error **)(a1 + 40);
    if (v9) {
      goto LABEL_3;
    }
  }

  else
  {
    unint64_t v5 = (void (**)(void *, void, CFErrorRef))v2;
    int v9 = *(nw_error **)(a1 + 40);
    if (v9)
    {
LABEL_3:
      CFErrorRef v10 = nw_error_copy_cf_error(v9);
      if (v5) {
        goto LABEL_4;
      }
      goto LABEL_14;
    }
  }

  CFErrorRef v10 = 0LL;
  if (v5)
  {
LABEL_4:
    unint64_t v11 = *(void **)(a1 + 48);
    if (v11)
    {
      id v12 = v11;
      char v13 = v12 + 34;
      *(void *)__int128 buf = MEMORY[0x1895F87A8];
      *(void *)&uint8_t buf[8] = 3221225472LL;
      *(void *)&buf[16] = __nw_connection_allow_reset_queue_block_invoke;
      __int128 v53 = &unk_189BC93A0;
      int v14 = v12;
      *(void *)__int128 v54 = v14;
      os_unfair_lock_lock(v13);
      __nw_connection_allow_reset_queue_block_invoke((uint64_t)buf);
      os_unfair_lock_unlock(v13);

      unint64_t v15 = *(void **)(a1 + 32);
      if (v15)
      {
        uint64_t v16 = (void *)v15[2];
        if (v16)
        {
          if (!v10) {
            nw_service_connector_apply_user_parameters(*(void **)(a1 + 56), v15, *(void **)(a1 + 48), v16);
          }
        }
      }
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v17 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v19 = *(void **)(a1 + 48);
      uint64_t v18 = *(void *)(a1 + 56);
      uint64_t v21 = *(void *)(a1 + 32);
      uint64_t v20 = *(void *)(a1 + 40);
      *(_DWORD *)__int128 buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_service_connector_trigger_request_complete_block_inner_block_invoke";
      *(_WORD *)&_BYTE buf[12] = 2114;
      *(void *)&buf[14] = v18;
      *(_WORD *)&_BYTE buf[22] = 2114;
      __int128 v53 = v19;
      *(_WORD *)__int128 v54 = 2114;
      *(void *)&v54[2] = v20;
      __int16 v55 = 2114;
      uint64_t v56 = v21;
      _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ calling request completion block with connection %{public}@ error %{public}@ for %{public}@",  buf,  0x34u);
    }

    v5[2](v5, *(void *)(a1 + 48), v10);
    goto LABEL_21;
  }

void sub_18229C7B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18229C7C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_service_connector_apply_user_parameters(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  unint64_t v7 = a1;
  id v8 = a2;
  int v9 = a3;
  id v10 = a4;
  if (!v7)
  {
    __nwlog_obj();
    uint64_t v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v35 = "nw_service_connector_apply_user_parameters";
    __int16 v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v35 = "nw_service_connector_apply_user_parameters";
        _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v32)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v20, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v35 = "nw_service_connector_apply_user_parameters";
          __int16 v36 = 2082;
          uint64_t v37 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v20,  v25,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_49:
        if (!v19) {
          goto LABEL_15;
        }
LABEL_50:
        free(v19);
        goto LABEL_15;
      }

      if (v26)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v35 = "nw_service_connector_apply_user_parameters";
        _os_log_impl( &dword_181A5C000,  v20,  v25,  "%{public}s called with null serviceConnector, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v35 = "nw_service_connector_apply_user_parameters";
        _os_log_impl( &dword_181A5C000,  v20,  v30,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_18229CDBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_connection_t nwsc_request_create_and_start_connection_inner(void *a1, void *a2, void *a3)
{
  uint64_t v127 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  unint64_t v7 = a3;
  id v8 = (void *)v7;
  if (!((unint64_t)v6 | v7))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v125 = "nwsc_request_create_and_start_connection_inner";
    LOWORD(v126[0]) = 2114;
    *(void *)((char *)v126 + 2) = v5;
    id v10 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(error) = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      nw_path_t v11 = (os_log_s *)(id)gLogObj;
      os_log_type_t v12 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v125 = "nwsc_request_create_and_start_connection_inner";
        LOWORD(v126[0]) = 2114;
        *(void *)((char *)v126 + 2) = v5;
        _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s %{public}@ tried to start connection on without request nor endpoint",  buf,  0x16u);
      }
    }

    else if ((_BYTE)error)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      nw_path_t v11 = (os_log_s *)(id)gLogObj;
      os_log_type_t v25 = type[0];
      BOOL v26 = os_log_type_enabled(v11, type[0]);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v125 = "nwsc_request_create_and_start_connection_inner";
          LOWORD(v126[0]) = 2114;
          *(void *)((char *)v126 + 2) = v5;
          WORD5(v126[0]) = 2082;
          *(void *)((char *)v126 + 12) = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v25,  "%{public}s %{public}@ tried to start connection on without request nor endpoint, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(backtrace_string);
        if (!v10) {
          goto LABEL_103;
        }
        goto LABEL_102;
      }

      if (v26)
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v125 = "nwsc_request_create_and_start_connection_inner";
        LOWORD(v126[0]) = 2114;
        *(void *)((char *)v126 + 2) = v5;
        _os_log_impl( &dword_181A5C000,  v11,  v25,  "%{public}s %{public}@ tried to start connection on without request nor endpoint, no backtrace",  buf,  0x16u);
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      nw_path_t v11 = (os_log_s *)(id)gLogObj;
      os_log_type_t v33 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v125 = "nwsc_request_create_and_start_connection_inner";
        LOWORD(v126[0]) = 2114;
        *(void *)((char *)v126 + 2) = v5;
        _os_log_impl( &dword_181A5C000,  v11,  v33,  "%{public}s %{public}@ tried to start connection on without request nor endpoint, backtrace limit exceeded",  buf,  0x16u);
      }
    }

    goto LABEL_100;
  }

  char v13 = (void *)v7;
  if (!v6)
  {
LABEL_14:
    endpoint = v13;
    int v16 = (unsigned __int16 *)v5;
    uint64_t v17 = (char *)v6;
    if (v16)
    {
      if (!v16[24])
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v29 = (id)gLogObj;
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v125 = "nw_service_connector_create_initial_payload_for_request";
        os_log_type_t v30 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(error) = 0;
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v31 = (os_log_s *)(id)gLogObj;
          os_log_type_t v32 = type[0];
          if (os_log_type_enabled(v31, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446210;
            uint64_t v125 = "nw_service_connector_create_initial_payload_for_request";
            _os_log_impl(&dword_181A5C000, v31, v32, "%{public}s Bad local port", buf, 0xCu);
          }
        }

        else if ((_BYTE)error)
        {
          os_log_type_t v47 = __nw_create_backtrace_string();
          if (v47)
          {
            uint64_t v48 = (char *)v47;
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v49 = (os_log_s *)(id)gLogObj;
            os_log_type_t v50 = type[0];
            if (os_log_type_enabled(v49, type[0]))
            {
              *(_DWORD *)__int128 buf = 136446466;
              uint64_t v125 = "nw_service_connector_create_initial_payload_for_request";
              LOWORD(v126[0]) = 2082;
              *(void *)((char *)v126 + 2) = v48;
              _os_log_impl( &dword_181A5C000,  v49,  v50,  "%{public}s Bad local port, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(v48);
            if (!v30) {
              goto LABEL_118;
            }
            goto LABEL_117;
          }

          __nwlog_obj();
          os_log_type_t v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v65 = type[0];
          if (os_log_type_enabled(v31, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446210;
            uint64_t v125 = "nw_service_connector_create_initial_payload_for_request";
            _os_log_impl(&dword_181A5C000, v31, v65, "%{public}s Bad local port, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v31 = (os_log_s *)(id)gLogObj;
          os_log_type_t v62 = type[0];
          if (os_log_type_enabled(v31, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446210;
            uint64_t v125 = "nw_service_connector_create_initial_payload_for_request";
            _os_log_impl(&dword_181A5C000, v31, v62, "%{public}s Bad local port, backtrace limit exceeded", buf, 0xCu);
          }
        }

        goto LABEL_214;
      }

      do
        unint64_t v18 = __ldaxr((unint64_t *)&nw_service_connector_get_new_sequence_number(void)::sNWSCSequenceNumber);
      while (__stlxr( v18 + 1,  (unint64_t *)&nw_service_connector_get_new_sequence_number(void)::sNWSCSequenceNumber));
      if (!v18)
      {
        do
        {
          unint64_t v18 = __ldaxr((unint64_t *)&nw_service_connector_get_new_sequence_number(void)::sNWSCSequenceNumber);
          if (__stlxr( v18 + 1,  (unint64_t *)&nw_service_connector_get_new_sequence_number(void)::sNWSCSequenceNumber))
          {
            BOOL v19 = 1;
          }

          else
          {
            BOOL v19 = v18 == 0;
          }
        }

        while (v19);
      }

      if (!v6)
      {
        unsigned __int8 v23 = 0;
        unsigned int v22 = 79;
LABEL_47:
        memset(v126, 0, sizeof(v126));
        *(_WORD *)__int128 buf = bswap32(v22) >> 16;
        *(_WORD *)&buf[2] = bswap32(v16[24]) >> 16;
        uint64_t v125 = (const char *)bswap64(v18);
        if (v6)
        {
          v126[0] = *((_OWORD *)v17 + 30);
          LOBYTE(v126[1]) = v23;
          memcpy((char *)&v126[1] + 1, v17 + 24, v23);
        }

        os_log_type_t v34 = (const __CFData *)[objc_alloc(MEMORY[0x189603F48]) initWithBytesNoCopy:buf length:(unsigned __int16)v22 + 2 freeWhenDone:0];
        CFErrorRef error = 0LL;
        CFDataRef v35 = SecKeyCreateSignature(*((SecKeyRef *)v16 + 14), (SecKeyAlgorithm)*MEMORY[0x18960BCA8], v34, &error);
        CFDataRef v36 = v35;
        if (!v35)
        {
          __nwlog_obj();
          int v108 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            BOOL v121 = "nw_service_connector_create_initial_payload_for_request";
            __int16 v122 = 2112;
            CFErrorRef v123 = error;
            _os_log_impl( &dword_181A5C000,  v108,  OS_LOG_TYPE_ERROR,  "%{public}s SecKeyCreateSignature failed with error %@",  (uint8_t *)type,  0x16u);
          }

          if (error)
          {
            CFRelease(error);
            __int128 v68 = 0LL;
            CFErrorRef error = 0LL;
          }

          else
          {
            __int128 v68 = 0LL;
          }

void sub_18229E9F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, void *a23, void *a24)
{
  _Unwind_Resume(a1);
}

void ___ZL46nwsc_request_create_and_start_connection_innerP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestPU25objcproto14OS_nw_endpoint8NSObject21nwsc_operation_code_e_block_invoke_190( uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  id v5 = a3;
  int v6 = *(_DWORD *)(*(void *)(a1 + 32) + 16LL);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unint64_t v7 = (os_log_s *)(id)gLogObj;
  id v8 = v7;
  if (v6 == 4)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      if (a2 > 5) {
        id v9 = "unknown";
      }
      else {
        id v9 = off_189BB9C00[a2];
      }
      uint64_t v12 = *(void *)(a1 + 32);
      nw_path_t v11 = *(nw_error **)(a1 + 40);
      uint64_t v13 = *(void *)(a1 + 48);
      int v14 = *(unsigned __int8 *)(a1 + 56);
      *(_DWORD *)__int128 buf = 136447746;
      id v43 = "nwsc_request_create_and_start_connection_inner_block_invoke";
      __int16 v44 = 2114;
      uint64_t v45 = v12;
      __int16 v46 = 2114;
      os_log_type_t v47 = v11;
      __int16 v48 = 2082;
      uint64_t v49 = v9;
      __int16 v50 = 2114;
      id v51 = v5;
      __int16 v52 = 2114;
      uint64_t v53 = v13;
      __int16 v54 = 1024;
      int v55 = v14;
      _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ already cancelled, ignoring connection %{public}@ received state %{public}s error %{public }@ for request %{public}@ opCode %u",  buf,  0x44u);
    }

    goto LABEL_11;
  }

  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 5) {
      id v10 = "unknown";
    }
    else {
      id v10 = off_189BB9C00[a2];
    }
    uint64_t v16 = *(void *)(a1 + 32);
    unint64_t v15 = *(nw_error **)(a1 + 40);
    uint64_t v17 = *(void *)(a1 + 48);
    int v18 = *(unsigned __int8 *)(a1 + 56);
    *(_DWORD *)__int128 buf = 136447746;
    id v43 = "nwsc_request_create_and_start_connection_inner_block_invoke";
    __int16 v44 = 2114;
    uint64_t v45 = v16;
    __int16 v46 = 2114;
    os_log_type_t v47 = v15;
    __int16 v48 = 2082;
    uint64_t v49 = v10;
    __int16 v50 = 2114;
    id v51 = v5;
    __int16 v52 = 2114;
    uint64_t v53 = v17;
    __int16 v54 = 1024;
    int v55 = v18;
    _os_log_impl( &dword_181A5C000,  v8,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ connection %{public}@ received state %{public}s error %{public}@ for request %{public}@ opCode %u",  buf,  0x44u);
  }

  if ((a2 & 0xFFFFFFFE) == 2)
  {
    BOOL v19 = *(NWConcrete_nw_unique_connection_request **)(a1 + 48);
    if (v19) {
      nwsc_request_stop_path_watcher(v19);
    }
  }

  if (a2 == 3)
  {
    size_t v20 = *(nw_connection **)(a1 + 40);
    size_t v21 = (nw_protocol_definition *)(id)g_tcp_definition;
    nw_protocol_metadata_t v22 = nw_connection_copy_protocol_metadata(v20, v21);

    if (v22)
    {
      if (nw_context_copy_implicit_context::onceToken != -1) {
        dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_14);
      }
      id v23 = (id)nw_context_copy_implicit_context::implicit_context;
      v38[0] = MEMORY[0x1895F87A8];
      v38[1] = 3221225472LL;
      v38[2] = ___ZL46nwsc_request_create_and_start_connection_innerP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestPU25objcproto14OS_nw_endpoint8NSObject21nwsc_operation_code_e_block_invoke_191;
      v38[3] = &unk_189BC6E60;
      int v39 = (os_log_s *)*(id *)(a1 + 32);
      id v40 = *(id *)(a1 + 48);
      os_log_type_t v41 = v22;
      nw_queue_context_async_if_needed(v23, v38);

      uint64_t v24 = v39;
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v24 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v25 = *(void *)(a1 + 32);
        BOOL v26 = *(nw_error **)(a1 + 40);
        id v27 = *(const char **)(a1 + 48);
        *(_DWORD *)__int128 buf = 136446978;
        id v43 = "nwsc_request_create_and_start_connection_inner_block_invoke";
        __int16 v44 = 2114;
        uint64_t v45 = v25;
        __int16 v46 = 2114;
        os_log_type_t v47 = v26;
        __int16 v48 = 2114;
        uint64_t v49 = v27;
        _os_log_impl( &dword_181A5C000,  v24,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ metadata for connection %{public}@ is nil -- unable to enable keep alives for request %{public}@",  buf,  0x2Au);
      }
    }

    nw_connection_set_state_changed_handler(*(nw_connection_t *)(a1 + 40), 0LL);
    nw_connection_set_path_changed_handler(*(nw_connection_t *)(a1 + 40), 0LL);
    nw_service_connector_should_accept_connection( *(NWConcrete_nw_service_connector **)(a1 + 32),  *(NWConcrete_nw_connection **)(a1 + 40),  0);
  }

  else if (a2 == 4 || a2 == 1)
  {
    if (!*(void *)(a1 + 48))
    {
LABEL_11:
      nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
      goto LABEL_33;
    }

    if (nwsc_is_error_allowlisted(v5, a2 == 1))
    {
      if (a2 == 4)
      {
        nwsc_request_start_path_watcher( *(NWConcrete_nw_service_connector **)(a1 + 32),  *(NWConcrete_nw_unique_connection_request **)(a1 + 48),  *(NWConcrete_nw_connection **)(a1 + 40),  1);
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v34 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v35 = *(void *)(a1 + 32);
          CFDataRef v36 = *(nw_error **)(a1 + 40);
          uint64_t v37 = *(const char **)(a1 + 48);
          *(_DWORD *)__int128 buf = 136446978;
          id v43 = "nwsc_request_create_and_start_connection_inner_block_invoke";
          __int16 v44 = 2114;
          uint64_t v45 = v35;
          __int16 v46 = 2114;
          os_log_type_t v47 = v36;
          __int16 v48 = 2114;
          uint64_t v49 = v37;
          _os_log_impl( &dword_181A5C000,  v34,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ connection %{public}@ in waiting state for request %{public}@",  buf,  0x2Au);
        }

        *(_BYTE *)(*(void *)(a1 + 48) + 616LL) |= 0x80u;
      }
    }

    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v28 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        uint64_t v29 = *(void *)(a1 + 32);
        os_log_type_t v30 = *(const char **)(a1 + 48);
        *(_DWORD *)__int128 buf = 136446978;
        id v43 = "nwsc_request_create_and_start_connection_inner_block_invoke";
        __int16 v44 = 2114;
        uint64_t v45 = v29;
        __int16 v46 = 2114;
        os_log_type_t v47 = v5;
        __int16 v48 = 2114;
        uint64_t v49 = v30;
        _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ received unrecoverable error %{public}@, cancelling request %{public}@",  buf,  0x2Au);
      }

      nw_service_connector_cancel_request_inner( *(void **)(a1 + 32),  *(void **)(*(void *)(a1 + 48) + 8LL),  *(void *)(a1 + 48) + 24LL,  *(void **)(a1 + 40),  0);
      os_log_type_t v31 = *(void **)(a1 + 32);
      os_log_type_t v32 = *(void **)(a1 + 48);
      int error_code = nw_error_get_error_code(v5);
      nw_service_connector_trigger_request_complete_block_inner(v31, v32, 0LL, 0LL, error_code);
    }
  }

void sub_18229F078( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void ___ZL46nwsc_request_create_and_start_connection_innerP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestPU25objcproto14OS_nw_endpoint8NSObject21nwsc_operation_code_e_block_invoke_191( uint64_t a1)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    *(_DWORD *)__int128 buf = 136446722;
    uint64_t v29 = "nwsc_request_create_and_start_connection_inner_block_invoke";
    __int16 v30 = 2114;
    uint64_t v31 = v3;
    __int16 v32 = 2114;
    uint64_t v33 = v4;
    _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ enabling keep alives for request %{public}@",  buf,  0x20u);
  }

  if (nw_tcp_reset_keepalives(*(void **)(a1 + 48), 1, 5, 5, 5))
  {
    int v5 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v6 = (os_log_s *)(id)gLogObj;
    unint64_t v7 = v6;
    if (v5 == 22)
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        uint64_t v8 = *(void *)(a1 + 32);
        uint64_t v9 = *(void *)(a1 + 40);
        *(_DWORD *)__int128 buf = 136446978;
        uint64_t v29 = "nwsc_request_create_and_start_connection_inner_block_invoke";
        __int16 v30 = 2114;
        uint64_t v31 = v8;
        __int16 v32 = 2114;
        uint64_t v33 = v9;
        __int16 v34 = 1024;
        int v35 = 22;
        _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ error enabling keep alives for request %{public}@ %{darwin.errno}d",  buf,  0x26u);
      }

      return;
    }

    uint64_t v10 = *(void *)(a1 + 32);
    uint64_t v11 = *(void *)(a1 + 40);
    *(_DWORD *)__int128 buf = 136446978;
    uint64_t v29 = "nwsc_request_create_and_start_connection_inner_block_invoke";
    __int16 v30 = 2114;
    uint64_t v31 = v10;
    __int16 v32 = 2114;
    uint64_t v33 = v11;
    __int16 v34 = 1024;
    int v35 = v5;
    uint64_t v12 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault((const char *)v12, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v13 = (os_log_s *)(id)gLogObj;
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_25;
        }
        uint64_t v15 = *(void *)(a1 + 32);
        uint64_t v16 = *(void *)(a1 + 40);
        *(_DWORD *)__int128 buf = 136446978;
        uint64_t v29 = "nwsc_request_create_and_start_connection_inner_block_invoke";
        __int16 v30 = 2114;
        uint64_t v31 = v15;
        __int16 v32 = 2114;
        uint64_t v33 = v16;
        __int16 v34 = 1024;
        int v35 = v5;
        uint64_t v17 = "%{public}s %{public}@ error enabling keep alives for request %{public}@ %{darwin.errno}d";
        goto LABEL_24;
      }

      if (!v26)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v13 = (os_log_s *)(id)gLogObj;
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_25;
        }
        uint64_t v22 = *(void *)(a1 + 32);
        uint64_t v23 = *(void *)(a1 + 40);
        *(_DWORD *)__int128 buf = 136446978;
        uint64_t v29 = "nwsc_request_create_and_start_connection_inner_block_invoke";
        __int16 v30 = 2114;
        uint64_t v31 = v22;
        __int16 v32 = 2114;
        uint64_t v33 = v23;
        __int16 v34 = 1024;
        int v35 = v5;
        uint64_t v17 = "%{public}s %{public}@ error enabling keep alives for request %{public}@ %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_24;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (os_log_s *)(id)gLogObj;
      os_log_type_t v14 = type;
      BOOL v19 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (!v19) {
          goto LABEL_25;
        }
        uint64_t v24 = *(void *)(a1 + 32);
        uint64_t v25 = *(void *)(a1 + 40);
        *(_DWORD *)__int128 buf = 136446978;
        uint64_t v29 = "nwsc_request_create_and_start_connection_inner_block_invoke";
        __int16 v30 = 2114;
        uint64_t v31 = v24;
        __int16 v32 = 2114;
        uint64_t v33 = v25;
        __int16 v34 = 1024;
        int v35 = v5;
        uint64_t v17 = "%{public}s %{public}@ error enabling keep alives for request %{public}@ %{darwin.errno}d, no backtrace";
LABEL_24:
        _os_log_impl(&dword_181A5C000, v13, v14, v17, buf, 0x26u);
LABEL_25:

        if (!v12) {
          return;
        }
LABEL_18:
        free(v12);
        return;
      }

      if (v19)
      {
        uint64_t v20 = *(void *)(a1 + 32);
        uint64_t v21 = *(void *)(a1 + 40);
        *(_DWORD *)__int128 buf = 136447234;
        uint64_t v29 = "nwsc_request_create_and_start_connection_inner_block_invoke";
        __int16 v30 = 2114;
        uint64_t v31 = v20;
        __int16 v32 = 2114;
        uint64_t v33 = v21;
        __int16 v34 = 1024;
        int v35 = v5;
        __int16 v36 = 2082;
        uint64_t v37 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s %{public}@ error enabling keep alives for request %{public}@ %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x30u);
      }

      free(backtrace_string);
    }

    if (!v12) {
      return;
    }
    goto LABEL_18;
  }

void nw_service_connector_should_accept_connection( NWConcrete_nw_service_connector *a1, NWConcrete_nw_connection *a2, int a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  int v5 = a1;
  int v6 = a2;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unint64_t v7 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = "outgoing";
    *(_DWORD *)__int128 buf = 136446978;
    uint64_t v16 = "nw_service_connector_should_accept_connection";
    __int16 v17 = 2114;
    int v18 = v5;
    if (a3) {
      uint64_t v8 = "incoming";
    }
    __int16 v19 = 2082;
    uint64_t v20 = v8;
    __int16 v21 = 2114;
    uint64_t v22 = v6;
    _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ performing first read on %{public}s connection %{public}@",  buf,  0x2Au);
  }

  v11[0] = MEMORY[0x1895F87A8];
  v11[1] = 3221225472LL;
  v11[2] = ___ZL45nw_service_connector_should_accept_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionb_block_invoke;
  v11[3] = &unk_189BBFD60;
  uint64_t v9 = v5;
  uint64_t v12 = v9;
  uint64_t v10 = v6;
  uint64_t v13 = v10;
  char v14 = a3;
  nw_connection_receive_internal(v10, 0LL, 2u, 2u, v11);
}

void sub_18229F6E4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

uint64_t nwsc_is_error_allowlisted(void *a1, char a2)
{
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    int v5 = v3;
    int v6 = v5[3];

    if ((a2 & 1) != 0 || v6 != 60)
    {
      uint64_t v7 = 1LL;
      switch(v6)
      {
        case 0:
        case 5:
        case 6:
        case 12:
        case 32:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 60:
        case 61:
        case 64:
        case 65:
        case 96:
          break;
        default:
          goto LABEL_4;
      }
    }

    else
    {
LABEL_4:
      uint64_t v7 = 0LL;
    }
  }

  else
  {
    uint64_t v7 = 1LL;
  }

  return v7;
}

void nwsc_request_start_path_watcher( NWConcrete_nw_service_connector *a1, NWConcrete_nw_unique_connection_request *a2, NWConcrete_nw_connection *a3, int a4)
{
  uint64_t v54 = *MEMORY[0x1895F89C0];
  uint64_t v7 = a1;
  uint64_t v8 = a2;
  uint64_t v9 = a3;
  uint64_t v10 = (nw_connection *)v9;
  if ((*((_BYTE *)v8 + 616) & 1) == 0)
  {
    if (v8->pathEvaluator)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 136446722;
        os_log_type_t v47 = "nwsc_request_start_path_watcher";
        __int16 v48 = 2114;
        uint64_t v49 = v7;
        __int16 v50 = 2114;
        id v51 = v8;
        _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ path watcher already started for request %{public}@",  buf,  0x20u);
      }

      goto LABEL_40;
    }

    nw_endpoint_t v19 = nw_connection_copy_endpoint((nw_connection_t)v9);
    nw_parameters_t v20 = nw_connection_copy_parameters(v10);
    evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(v19, v20);

    if (evaluator_for_endpoint)
    {
      objc_storeStrong((id *)&v8->pathEvaluator, evaluator_for_endpoint);
      *((_BYTE *)v8 + 616) |= 0x80u;
      aBlock[0] = MEMORY[0x1895F87A8];
      aBlock[1] = 3221225472LL;
      aBlock[2] = ___ZL31nwsc_request_start_path_watcherP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestP24NWConcrete_nw_connectionb_block_invoke;
      aBlock[3] = &unk_189BBFE40;
      uint64_t v22 = v7;
      os_log_type_t v41 = v22;
      uint64_t v23 = v8;
      __int16 v42 = v23;
      uint64_t v24 = evaluator_for_endpoint;
      id v43 = v24;
      uint64_t v25 = _Block_copy(aBlock);
      nw_path_evaluator_set_update_handler(v24, v22[4], v25);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v26 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int128 buf = 136446722;
        os_log_type_t v47 = "nwsc_request_start_path_watcher";
        __int16 v48 = 2114;
        uint64_t v49 = v22;
        __int16 v50 = 2114;
        id v51 = v23;
        _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ registered for path updates for request %{public}@",  buf,  0x20u);
      }

      if (a4)
      {
        id v27 = nw_connection_copy_current_path(v10);
        if (nw_path_get_status(v27) == nw_path_status_unsatisfied)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v28 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__int128 buf = 136446722;
            os_log_type_t v47 = "nwsc_request_start_path_watcher";
            __int16 v48 = 2114;
            uint64_t v49 = v22;
            __int16 v50 = 2114;
            id v51 = v23;
            _os_log_impl( &dword_181A5C000,  v28,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ forcing a path update for request %{public}@",  buf,  0x20u);
          }

          uint64_t v29 = v24;
          os_unfair_lock_lock(v24 + 24);
          id v30 = v29[6];
          os_unfair_lock_unlock(v24 + 24);

          (*((void (**)(void *, id))v25 + 2))(v25, v30);
        }
      }

      goto LABEL_39;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v32 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v47 = "nwsc_request_start_path_watcher";
    uint64_t v33 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v44 = 0;
    if (__nwlog_fault(v33, &type, &v44))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v34 = (os_log_s *)(id)gLogObj;
        os_log_type_t v35 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v47 = "nwsc_request_start_path_watcher";
          _os_log_impl(&dword_181A5C000, v34, v35, "%{public}s nw_path_create_evaluator_for_endpoint failed", buf, 0xCu);
        }
      }

      else if (v44)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v37 = type;
        BOOL v38 = os_log_type_enabled(v34, type);
        if (backtrace_string)
        {
          if (v38)
          {
            *(_DWORD *)__int128 buf = 136446466;
            os_log_type_t v47 = "nwsc_request_start_path_watcher";
            __int16 v48 = 2082;
            uint64_t v49 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v34,  v37,  "%{public}s nw_path_create_evaluator_for_endpoint failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v33) {
            goto LABEL_39;
          }
          goto LABEL_38;
        }

        if (v38)
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v47 = "nwsc_request_start_path_watcher";
          _os_log_impl( &dword_181A5C000,  v34,  v37,  "%{public}s nw_path_create_evaluator_for_endpoint failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v34 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v39 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v47 = "nwsc_request_start_path_watcher";
          _os_log_impl( &dword_181A5C000,  v34,  v39,  "%{public}s nw_path_create_evaluator_for_endpoint failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v33)
    {
LABEL_39:

      goto LABEL_40;
    }

void sub_1822A0028( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void nw_service_connector_cancel_request_inner(void *a1, void *a2, uint64_t a3, void *a4, int a5)
{
  uint64_t v66 = *MEMORY[0x1895F89C0];
  uint64_t v9 = a1;
  id v10 = a2;
  uint64_t v11 = a4;
  id v12 = nw_service_connector_copy_active_outgoing_request(v9, v10, a3);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v13 = (os_log_s *)(id)gLogObj;
  BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
  if (v12)
  {
    if (v14)
    {
      *(_DWORD *)__int128 buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_service_connector_cancel_request_inner";
      *(_WORD *)&_BYTE buf[12] = 2114;
      *(void *)&buf[14] = v9;
      *(_WORD *)&_BYTE buf[22] = 2114;
      nw_connection_t v64 = (uint64_t (*)(uint64_t, uint64_t))v12;
      _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ cancelling active request %{public}@",  buf,  0x20u);
    }

    os_log_type_t v15 = (nw_connection *)*((void *)v12 + 72);
    if (!v15 || v15 == v11) {
      goto LABEL_31;
    }
    if (!v11)
    {
LABEL_30:
      nw_connection_cancel(v15);
      os_log_type_t v15 = (nw_connection *)*((void *)v12 + 72);
LABEL_31:
      *((void *)v12 + 72) = 0LL;

      *((_BYTE *)v12 + 616) &= ~0x10u;
      uint64_t v25 = *((void *)v12 + 76);
      if (v25)
      {
        nw_queue_cancel_source(v25, v24);
        *((void *)v12 + 76) = 0LL;
      }

      nw_service_connector_remove_active_outgoing_request(v9, (NWConcrete_nw_unique_connection_request *)v12);
      goto LABEL_34;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v16 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_service_connector_cancel_request_inner";
    *(_WORD *)&_BYTE buf[12] = 2114;
    *(void *)&buf[14] = v9;
    *(_WORD *)&_BYTE buf[22] = 2114;
    nw_connection_t v64 = (uint64_t (*)(uint64_t, uint64_t))v12;
    *(_WORD *)os_log_type_t v65 = 2114;
    *(void *)&v65[2] = v11;
    os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v62 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v17, type, &v62))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v18 = (os_log_s *)(id)gLogObj;
        os_log_type_t v19 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_service_connector_cancel_request_inner";
          *(_WORD *)&_BYTE buf[12] = 2114;
          *(void *)&buf[14] = v9;
          *(_WORD *)&_BYTE buf[22] = 2114;
          nw_connection_t v64 = (uint64_t (*)(uint64_t, uint64_t))v12;
          *(_WORD *)os_log_type_t v65 = 2114;
          *(void *)&v65[2] = v11;
          _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s %{public}@ trying to cancel mismatched connections %{public}@ %{public}@",  buf,  0x2Au);
        }
      }

      else if (v62)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v18 = (os_log_s *)(id)gLogObj;
        os_log_type_t v21 = type[0];
        BOOL v22 = os_log_type_enabled(v18, type[0]);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)__int128 buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_service_connector_cancel_request_inner";
            *(_WORD *)&_BYTE buf[12] = 2114;
            *(void *)&buf[14] = v9;
            *(_WORD *)&_BYTE buf[22] = 2114;
            nw_connection_t v64 = (uint64_t (*)(uint64_t, uint64_t))v12;
            *(_WORD *)os_log_type_t v65 = 2114;
            *(void *)&v65[2] = v11;
            *(_WORD *)&v65[10] = 2082;
            *(void *)&v65[12] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v18,  v21,  "%{public}s %{public}@ trying to cancel mismatched connections %{public}@ %{public}@, dumping backtrace:%{public}s",  buf,  0x34u);
          }

          free(backtrace_string);
          if (!v17) {
            goto LABEL_29;
          }
          goto LABEL_28;
        }

        if (v22)
        {
          *(_DWORD *)__int128 buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_service_connector_cancel_request_inner";
          *(_WORD *)&_BYTE buf[12] = 2114;
          *(void *)&buf[14] = v9;
          *(_WORD *)&_BYTE buf[22] = 2114;
          nw_connection_t v64 = (uint64_t (*)(uint64_t, uint64_t))v12;
          *(_WORD *)os_log_type_t v65 = 2114;
          *(void *)&v65[2] = v11;
          _os_log_impl( &dword_181A5C000,  v18,  v21,  "%{public}s %{public}@ trying to cancel mismatched connections %{public}@ %{public}@, no backtrace",  buf,  0x2Au);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v18 = (os_log_s *)(id)gLogObj;
        os_log_type_t v23 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_service_connector_cancel_request_inner";
          *(_WORD *)&_BYTE buf[12] = 2114;
          *(void *)&buf[14] = v9;
          *(_WORD *)&_BYTE buf[22] = 2114;
          nw_connection_t v64 = (uint64_t (*)(uint64_t, uint64_t))v12;
          *(_WORD *)os_log_type_t v65 = 2114;
          *(void *)&v65[2] = v11;
          _os_log_impl( &dword_181A5C000,  v18,  v23,  "%{public}s %{public}@ trying to cancel mismatched connections %{public}@ %{public}@, backtrace limit exceeded",  buf,  0x2Au);
        }
      }
    }

    if (!v17)
    {
LABEL_29:
      os_log_type_t v15 = (nw_connection *)*((void *)v12 + 72);
      goto LABEL_30;
    }

void sub_1822A0CF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *nw_service_connector_copy_active_outgoing_request(void *a1, void *a2, uint64_t a3)
{
  uint64_t v79 = *MEMORY[0x1895F89C0];
  int v5 = a1;
  id v6 = a2;
  uint64_t v7 = v6;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)os_log_type_t v52 = 136446210;
    *(void *)&uint8_t v52[4] = "nw_service_connector_copy_active_outgoing_request";
    nw_parameters_t v20 = (const char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)os_log_type_t v52 = 136446210;
        *(void *)&uint8_t v52[4] = "nw_service_connector_copy_active_outgoing_request";
        _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s called with null serviceConnector", v52, 0xCu);
      }

      goto LABEL_94;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v38 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)os_log_type_t v52 = 136446210;
        *(void *)&uint8_t v52[4] = "nw_service_connector_copy_active_outgoing_request";
        _os_log_impl( &dword_181A5C000,  v21,  v38,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  v52,  0xCu);
      }

      goto LABEL_94;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v30 = buf[0];
    BOOL v31 = os_log_type_enabled(v21, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v31)
      {
        *(_DWORD *)os_log_type_t v52 = 136446210;
        *(void *)&uint8_t v52[4] = "nw_service_connector_copy_active_outgoing_request";
        _os_log_impl( &dword_181A5C000,  v21,  v30,  "%{public}s called with null serviceConnector, no backtrace",  v52,  0xCu);
      }

      goto LABEL_94;
    }

    if (v31)
    {
      *(_DWORD *)os_log_type_t v52 = 136446466;
      *(void *)&uint8_t v52[4] = "nw_service_connector_copy_active_outgoing_request";
      *(_WORD *)&v52[12] = 2082;
      *(void *)&v52[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v21,  v30,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  v52,  0x16u);
    }

void sub_1822A190C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL58nw_service_connector_copy_active_connection_for_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connection_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  int v5 = a3;
  uint64_t v6 = v5[61];
  uint64_t v7 = *(void *)(a1 + 32);
  if (v6 == v7) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL), a3);
  }

  return v6 != v7;
}

void nw_service_connector_remove_active_connection( NWConcrete_nw_service_connector *a1, NWConcrete_nw_unique_connection *a2)
{
  uint64_t v74 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = a2;
  p_isa = (void **)&v4->super.isa;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)os_log_type_t v47 = 136446210;
    *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      nw_parameters_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = buf[0];
      if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)os_log_type_t v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
        _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s called with null serviceConnector", v47, 0xCu);
      }
    }

    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      nw_parameters_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v27 = buf[0];
      BOOL v28 = os_log_type_enabled(v20, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)os_log_type_t v47 = 136446466;
          *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
          *(_WORD *)&v47[12] = 2082;
          *(void *)&v47[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v20,  v27,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  v47,  0x16u);
        }

        free(backtrace_string);
LABEL_23:
        if (!v8) {
          goto LABEL_25;
        }
LABEL_24:
        free(v8);
        goto LABEL_25;
      }

      if (v28)
      {
        *(_DWORD *)os_log_type_t v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
        _os_log_impl( &dword_181A5C000,  v20,  v27,  "%{public}s called with null serviceConnector, no backtrace",  v47,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      nw_parameters_t v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v34 = buf[0];
      if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)os_log_type_t v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
        _os_log_impl( &dword_181A5C000,  v20,  v34,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  v47,  0xCu);
      }
    }

void sub_1822A2390(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *nw_service_connector_copy_active_connection_with_endpoint_and_service(void *a1, void *a2, uint64_t a3)
{
  uint64_t v79 = *MEMORY[0x1895F89C0];
  int v5 = a1;
  id v6 = a2;
  uint64_t v7 = v6;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 v52 = 136446210;
    *(void *)&uint8_t v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
    nw_parameters_t v20 = (const char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)__int128 v52 = 136446210;
        *(void *)&uint8_t v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
        _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s called with null serviceConnector", v52, 0xCu);
      }

      goto LABEL_94;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v38 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)__int128 v52 = 136446210;
        *(void *)&uint8_t v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
        _os_log_impl( &dword_181A5C000,  v21,  v38,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  v52,  0xCu);
      }

      goto LABEL_94;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v30 = buf[0];
    BOOL v31 = os_log_type_enabled(v21, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v31)
      {
        *(_DWORD *)__int128 v52 = 136446210;
        *(void *)&uint8_t v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
        _os_log_impl( &dword_181A5C000,  v21,  v30,  "%{public}s called with null serviceConnector, no backtrace",  v52,  0xCu);
      }

      goto LABEL_94;
    }

    if (v31)
    {
      *(_DWORD *)__int128 v52 = 136446466;
      *(void *)&uint8_t v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
      *(_WORD *)&v52[12] = 2082;
      *(void *)&v52[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v21,  v30,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  v52,  0x16u);
    }

void sub_1822A2F80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nwsc_unique_connection_shutdown_socket( NWConcrete_nw_service_connector *a1, NWConcrete_nw_unique_connection *a2)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = a2;
  int v5 = (int *)v4;
  if (!v3)
  {
    __nwlog_obj();
    os_log_type_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v30 = "nwsc_unique_connection_shutdown_socket";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v30 = "nwsc_unique_connection_shutdown_socket";
        _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v30 = "nwsc_unique_connection_shutdown_socket";
          __int16 v31 = 2082;
          os_log_type_t v32 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_45:
        if (!v14) {
          goto LABEL_11;
        }
        goto LABEL_46;
      }

      if (v21)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v30 = "nwsc_unique_connection_shutdown_socket";
        _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s called with null serviceConnector, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v30 = "nwsc_unique_connection_shutdown_socket";
        _os_log_impl( &dword_181A5C000,  v15,  v25,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_1822A358C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL31nwsc_request_start_path_watcherP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestP24NWConcrete_nw_connectionb_block_invoke( void *a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  if (*(_DWORD *)(a1[4] + 16LL) == 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = a1[4];
      id v6 = (nw_path *)a1[5];
      int v20 = 136446978;
      BOOL v21 = "nwsc_request_start_path_watcher_block_invoke";
      __int16 v22 = 2114;
      uint64_t v23 = v5;
      __int16 v24 = 2114;
      os_log_type_t v25 = v3;
      __int16 v26 = 2114;
      char v27 = v6;
      int v7 = "%{public}s %{public}@ already cancelled, ignoring received path update %{public}@ for request %{public}@";
      uint64_t v8 = v4;
      os_log_type_t v9 = OS_LOG_TYPE_ERROR;
LABEL_7:
      _os_log_impl(&dword_181A5C000, v8, v9, v7, (uint8_t *)&v20, 0x2Au);
      goto LABEL_8;
    }

    goto LABEL_8;
  }

  uint64_t v10 = a1[6];
  uint64_t v11 = *(void *)(a1[5] + 584LL);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v4 = (os_log_s *)(id)gLogObj;
  BOOL v12 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v11 != v10)
  {
    if (v12)
    {
      uint64_t v13 = a1[4];
      os_log_type_t v14 = (nw_path *)a1[5];
      int v20 = 136446978;
      BOOL v21 = "nwsc_request_start_path_watcher_block_invoke";
      __int16 v22 = 2114;
      uint64_t v23 = v13;
      __int16 v24 = 2114;
      os_log_type_t v25 = v3;
      __int16 v26 = 2114;
      char v27 = v14;
      int v7 = "%{public}s %{public}@ ignoring received path update %{public}@ for request %{public}@";
      uint64_t v8 = v4;
      os_log_type_t v9 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_7;
    }

void sub_1822A3874(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL45nw_service_connector_should_accept_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionb_block_invoke( uint64_t a1, void *a2, uint64_t a3, int a4, void *a5)
{
  uint64_t v46 = *MEMORY[0x1895F89C0];
  uint64_t v8 = a2;
  if ((nw_service_connector_verify_read_succeeded( *(void **)(a1 + 32),  *(void **)(a1 + 40),  *(unsigned __int8 *)(a1 + 48),  2,  v8,  a4,  a5,  "first") & 1) == 0) {
    goto LABEL_42;
  }
  unsigned __int16 v38 = 0;
  *(void *)os_log_type_t type = 0LL;
  os_log_type_t v41 = type;
  uint64_t v42 = 0x2000000000LL;
  uint64_t v43 = 0LL;
  v39[0] = 0LL;
  v39[1] = v39;
  void v39[2] = 0x2000000000LL;
  v39[3] = &v38;
  if (v8)
  {
    *(void *)applier = MEMORY[0x1895F87A8];
    *(void *)&void applier[8] = 0x40000000LL;
    *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
    *(void *)__int16 v45 = &unk_189BBF598;
    *(void *)&v45[16] = v39;
    *(void *)&v45[24] = 2LL;
    *(void *)&v45[8] = type;
    dispatch_data_apply(v8, applier);
    uint64_t v9 = *((void *)v41 + 3);
  }

  else
  {
    uint64_t v9 = 0LL;
  }

  _Block_object_dispose(v39, 8);
  _Block_object_dispose(type, 8);
  if (v9 != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v17 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      uint64_t v18 = *(void *)(a1 + 32);
      uint64_t v19 = *(void *)(a1 + 40);
      *(_DWORD *)applier = 136446978;
      *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v18;
      *(_WORD *)&applier[22] = 2048;
      *(void *)__int16 v45 = v9;
      *(_WORD *)&v45[8] = 2114;
      *(void *)&v45[10] = v19;
      _os_log_impl( &dword_181A5C000,  v17,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ first read copyout had insufficient length %zu, cancelling %{public}@",  applier,  0x2Au);
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v20 = (id)gLogObj;
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
    BOOL v21 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v39[0]) = 0;
    if (__nwlog_fault(v21, type, v39))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v22 = (os_log_s *)(id)gLogObj;
        os_log_type_t v23 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl(&dword_181A5C000, v22, v23, "%{public}s first nw_dispatch_data_copyout failed", applier, 0xCu);
        }
      }

      else if (LOBYTE(v39[0]))
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v22 = (os_log_s *)(id)gLogObj;
        os_log_type_t v29 = type[0];
        BOOL v30 = os_log_type_enabled(v22, type[0]);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)applier = 136446466;
            *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
            *(_WORD *)&applier[12] = 2082;
            *(void *)&applier[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v22,  v29,  "%{public}s first nw_dispatch_data_copyout failed, dumping backtrace:%{public}s",  applier,  0x16u);
          }

          free(backtrace_string);
          if (!v21) {
            goto LABEL_41;
          }
          goto LABEL_40;
        }

        if (v30)
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl( &dword_181A5C000,  v22,  v29,  "%{public}s first nw_dispatch_data_copyout failed, no backtrace",  applier,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v22 = (os_log_s *)(id)gLogObj;
        os_log_type_t v31 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl( &dword_181A5C000,  v22,  v31,  "%{public}s first nw_dispatch_data_copyout failed, backtrace limit exceeded",  applier,  0xCu);
        }
      }
    }

    if (!v21)
    {
LABEL_41:
      nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
      goto LABEL_42;
    }

void sub_1822A3EFC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

uint64_t nw_service_connector_verify_read_succeeded( void *a1, void *a2, int a3, int a4, void *a5, int a6, void *a7, void *a8)
{
  uint64_t v96 = *MEMORY[0x1895F89C0];
  uint64_t v15 = a1;
  uint64_t v16 = a2;
  data = a5;
  id v17 = a7;
  uint64_t v18 = v17;
  if (!v15)
  {
    __nwlog_obj();
    __int128 v72 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    unint64_t v91 = "nw_service_connector_verify_read_succeeded";
    __int128 v73 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v88 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int128 v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v75 = type;
      if (os_log_type_enabled(v74, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unint64_t v91 = "nw_service_connector_verify_read_succeeded";
        _os_log_impl(&dword_181A5C000, v74, v75, "%{public}s called with null serviceConnector", buf, 0xCu);
      }

      goto LABEL_176;
    }

    if (!v88)
    {
      __nwlog_obj();
      __int128 v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v83 = type;
      if (os_log_type_enabled(v74, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unint64_t v91 = "nw_service_connector_verify_read_succeeded";
        _os_log_impl( &dword_181A5C000,  v74,  v83,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_176;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    __int128 v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v79 = type;
    BOOL v80 = os_log_type_enabled(v74, type);
    if (!backtrace_string)
    {
      if (v80)
      {
        *(_DWORD *)__int128 buf = 136446210;
        unint64_t v91 = "nw_service_connector_verify_read_succeeded";
        _os_log_impl( &dword_181A5C000,  v74,  v79,  "%{public}s called with null serviceConnector, no backtrace",  buf,  0xCu);
      }

      goto LABEL_176;
    }

    if (v80)
    {
      *(_DWORD *)__int128 buf = 136446466;
      unint64_t v91 = "nw_service_connector_verify_read_succeeded";
      __int16 v92 = 2082;
      int v93 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v74,  v79,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    goto LABEL_164;
  }

  if (!v16)
  {
    __nwlog_obj();
    __int128 v76 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    unint64_t v91 = "nw_service_connector_verify_read_succeeded";
    __int128 v73 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v88 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int128 v74 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v77 = type;
      if (os_log_type_enabled(v74, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unint64_t v91 = "nw_service_connector_verify_read_succeeded";
        _os_log_impl(&dword_181A5C000, v74, v77, "%{public}s called with null connection", buf, 0xCu);
      }

void sub_1822A5650( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void ___ZL45nw_service_connector_should_accept_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionb_block_invoke_174( uint64_t a1, void *a2, void *a3, int a4, void *a5)
{
  uint64_t v272 = *MEMORY[0x1895F89C0];
  uint64_t v9 = a2;
  id v223 = a3;
  id v10 = a5;
  if ((nw_service_connector_verify_read_succeeded( *(void **)(a1 + 32),  *(void **)(a1 + 40),  *(unsigned __int8 *)(a1 + 52),  *(unsigned __int16 *)(a1 + 48),  v9,  a4,  v10,  "second") & 1) == 0) {
    goto LABEL_271;
  }
  if (!*(_BYTE *)(a1 + 52))
  {
    int v222 = (char *)nw_service_connector_copy_active_request_for_connection( *(NWConcrete_nw_service_connector **)(a1 + 32),  *(NWConcrete_nw_connection **)(a1 + 40));
    memset(__dst, 0, 44);
    *(void *)applier = 0LL;
    *(void *)&void applier[8] = applier;
    *(void *)&applier[16] = 0x2000000000LL;
    *(void *)&_BYTE applier[24] = 0LL;
    *(void *)&__int128 buffer = 0LL;
    *((void *)&buffer + 1) = &buffer;
    *(void *)&__int128 v250 = 0x2000000000LL;
    *((void *)&v250 + 1) = __dst[0].sa_data;
    if (v9)
    {
      *(void *)__int128 buf = MEMORY[0x1895F87A8];
      *(void *)&uint8_t buf[8] = 0x40000000LL;
      *(void *)&buf[16] = __nw_dispatch_data_copyout_block_invoke;
      *(void *)&_BYTE buf[24] = &unk_189BBF598;
      v253[2] = 42LL;
      v253[0] = applier;
      v253[1] = &buffer;
      dispatch_data_apply(v9, buf);
      unint64_t v13 = *(void *)(*(void *)&applier[8] + 24LL);
    }

    else
    {
      unint64_t v13 = 0LL;
    }

    _Block_object_dispose(&buffer, 8);
    _Block_object_dispose(applier, 8);
    else {
      uint64_t v30 = *(unsigned __int16 *)(a1 + 48);
    }
    if (v13 == v30)
    {
      char v219 = __dst[0].sa_data[0];
      unint64_t v31 = bswap64(*(unint64_t *)&__dst[0].sa_data[2]);
      __int128 v234 = 0u;
      __int128 v233 = 0u;
      if (v13 >= 0x2A)
      {
        __int128 v233 = *(_OWORD *)&__dst[0].sa_data[10];
        __int128 v234 = *(_OWORD *)&__dst[1].sa_data[10];
      }

      os_log_type_t v32 = *(void **)(a1 + 32);
      nw_endpoint_t v33 = nw_connection_copy_endpoint(*(nw_connection_t *)(a1 + 40));
      id v34 = v32;
      __int16 v35 = v33;
      os_log_type_t v36 = v35;
      unint64_t v221 = v31;
      if (v34)
      {
        if (*((void *)v34 + 13))
        {
          if (v35)
          {
            int v271 = 0;
            __int128 v269 = 0u;
            memset(v270, 0, sizeof(v270));
            __int128 v267 = 0u;
            __int128 v268 = 0u;
            __int128 v265 = 0u;
            __int128 v266 = 0u;
            __int128 v263 = 0u;
            __int128 v264 = 0u;
            __int128 v261 = 0u;
            __int128 v262 = 0u;
            __int128 v259 = 0u;
            __int128 v260 = 0u;
            __int128 v257 = 0u;
            __int128 v258 = 0u;
            __int128 v255 = 0u;
            __int128 v256 = 0u;
            __int128 v254 = 0u;
            memset(v253, 0, sizeof(v253));
            memset(buf, 0, sizeof(buf));
            if ((nwsc_get_endpoint_identifier(v35, (uint64_t)buf) & 1) != 0)
            {
              xpc_dictionary_get_value(*((xpc_object_t *)v34 + 13), (const char *)buf);
              id v37 = (void *)objc_claimAutoreleasedReturnValue();
              unsigned __int16 v38 = v37;
              uint64_t v251 = 0LL;
              __int128 buffer = 0u;
              __int128 v250 = 0u;
              if (!v37 || xpc_data_get_bytes(v37, &buffer, 0LL, 0x28uLL) >= 0x28) {
                goto LABEL_188;
              }
              __nwlog_obj();
              os_log_type_t v39 = v36;
              os_log_type_t v40 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)applier = 136446210;
              *(void *)&applier[4] = "nwsc_save_remote_pub_key";
              os_log_type_t v41 = (char *)_os_log_send_and_compose_impl();

              os_log_type_t v36 = v39;
              type[0] = OS_LOG_TYPE_ERROR;
              char v232 = 0;
              if (__nwlog_fault(v41, type, &v232))
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  __nwlog_obj();
                  uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v43 = type[0];
                  if (os_log_type_enabled(v42, type[0]))
                  {
                    *(_DWORD *)applier = 136446210;
                    *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                    _os_log_impl( &dword_181A5C000,  v42,  v43,  "%{public}s Insufficient length in remotePubKeys",  applier,  0xCu);
                  }
                }

                else
                {
                  if (v232)
                  {
                    backtrace_string = (char *)__nw_create_backtrace_string();
                    __nwlog_obj();
                    int v105 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    os_log_type_t v217 = type[0];
                    BOOL v106 = os_log_type_enabled(v105, type[0]);
                    if (backtrace_string)
                    {
                      if (v106)
                      {
                        *(_DWORD *)applier = 136446466;
                        *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                        *(_WORD *)&applier[12] = 2082;
                        *(void *)&applier[14] = backtrace_string;
                        _os_log_impl( &dword_181A5C000,  v105,  v217,  "%{public}s Insufficient length in remotePubKeys, dumping backtrace:%{public}s",  applier,  0x16u);
                      }

                      free(backtrace_string);
                    }

                    else
                    {
                      if (v106)
                      {
                        *(_DWORD *)applier = 136446210;
                        *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                        _os_log_impl( &dword_181A5C000,  v105,  v217,  "%{public}s Insufficient length in remotePubKeys, no backtrace",  applier,  0xCu);
                      }
                    }

                    goto LABEL_185;
                  }

                  __nwlog_obj();
                  uint64_t v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                  os_log_type_t v130 = type[0];
                  if (os_log_type_enabled(v42, type[0]))
                  {
                    *(_DWORD *)applier = 136446210;
                    *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                    _os_log_impl( &dword_181A5C000,  v42,  v130,  "%{public}s Insufficient length in remotePubKeys, backtrace limit exceeded",  applier,  0xCu);
                  }
                }
              }

void sub_1822A8488( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20, uint64_t a21, void *a22, void *a23)
{
  _Unwind_Resume(a1);
}

void nwsc_restart_outgoing_requests_waiting_for_path(void *a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    int v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v27 = "nwsc_restart_outgoing_requests_waiting_for_path";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v25 = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (v25 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v27 = "nwsc_restart_outgoing_requests_waiting_for_path";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = v25;
      BOOL v15 = os_log_type_enabled(v9, v25);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v27 = "nwsc_restart_outgoing_requests_waiting_for_path";
          __int16 v28 = 2082;
          nw_endpoint_t v29 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          goto LABEL_4;
        }
LABEL_39:
        free(v8);
        goto LABEL_4;
      }

      if (v15)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v27 = "nwsc_restart_outgoing_requests_waiting_for_path";
        _os_log_impl(&dword_181A5C000, v9, v14, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v27 = "nwsc_restart_outgoing_requests_waiting_for_path";
        _os_log_impl( &dword_181A5C000,  v9,  v19,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  buf,  0xCu);
      }
    }

unint64_t nw_service_connector_get_new_sequence_number(void)
{
  do
    unint64_t result = __ldaxr((unint64_t *)&nw_service_connector_get_new_sequence_number(void)::sNWSCSequenceNumber);
  while (__stlxr( result + 1,  (unint64_t *)&nw_service_connector_get_new_sequence_number(void)::sNWSCSequenceNumber));
  if (!result)
  {
    do
    {
      unint64_t result = __ldaxr((unint64_t *)&nw_service_connector_get_new_sequence_number(void)::sNWSCSequenceNumber);
      if (__stlxr( result + 1,  (unint64_t *)&nw_service_connector_get_new_sequence_number(void)::sNWSCSequenceNumber))
      {
        BOOL v1 = 1;
      }

      else
      {
        BOOL v1 = result == 0;
      }
    }

    while (v1);
  }

  return result;
}

void nwsc_send_feedback(void *a1, void *a2, unint64_t a3, int a4, int a5, void *a6)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  unsigned int v11 = a1;
  id v12 = a2;
  id v13 = a6;
  int buffer = 10752;
  if ((a4 & 1) != 0 || a5)
  {
    if (a4) {
      __int16 v14 = 128;
    }
    else {
      __int16 v14 = 64;
    }
    HIWORD(buffer) = v14;
  }

  unint64_t v40 = bswap64(a3);
  __int128 v41 = *(_OWORD *)(v11 + 120);
  __int128 v42 = *(_OWORD *)(v11 + 136);
  BOOL v15 = dispatch_data_create(&buffer, 0x2CuLL, 0LL, 0LL);
  if (v15)
  {
    if (a4) {
      uint64_t v16 = &__block_literal_global_41831;
    }
    else {
      uint64_t v16 = &__block_literal_global_3_41839;
    }
    completion[0] = MEMORY[0x1895F87A8];
    completion[1] = 3221225472LL;
    completioint n[2] = ___ZL18nwsc_send_feedbackP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionybbU13block_pointerFviE_block_invoke;
    completion[3] = &unk_189BBFDA8;
    uint64_t v27 = v11;
    __int16 v28 = (nw_connection *)v12;
    char v32 = a4;
    id v30 = v13;
    unint64_t v31 = a3;
    nw_endpoint_t v29 = v16;
    os_log_type_t v17 = v16;
    nw_connection_send(v28, v15, v17, 1, completion);

    goto LABEL_21;
  }

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v18 = (id)gLogObj;
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v36 = "nwsc_send_feedback";
  os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v33 = 0;
  if (!__nwlog_fault(v19, &type, &v33))
  {
LABEL_17:
    if (!v19) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }

  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v20 = (os_log_s *)(id)gLogObj;
    os_log_type_t v21 = type;
    if (os_log_type_enabled(v20, type))
    {
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v36 = "nwsc_send_feedback";
      _os_log_impl(&dword_181A5C000, v20, v21, "%{public}s dispatch_data_create failed", buf, 0xCu);
    }

void sub_1822A8F80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nwsc_process_incoming_request( NWConcrete_nw_service_connector *a1, NWConcrete_nw_unique_connection_request *a2)
{
  uint64_t v176 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  int v132 = v3;
  if ((*((_BYTE *)v4 + 616) & 0x40) == 0)
  {
    __int128 v145 = 0u;
    __int128 v146 = 0u;
    endpoint = v4->endpoint;
    int v7 = v3;
    uint64_t v8 = endpoint;
    uint64_t v9 = v8;
    if (v7)
    {
      if (v7->remotePubKeys)
      {
        if (v8)
        {
          int v175 = 0;
          __int128 v173 = 0u;
          __int128 v174 = 0u;
          __int128 v171 = 0u;
          __int128 v172 = 0u;
          __int128 v169 = 0u;
          __int128 v170 = 0u;
          __int128 v167 = 0u;
          __int128 v168 = 0u;
          __int128 v165 = 0u;
          __int128 v166 = 0u;
          __int128 v163 = 0u;
          __int128 v164 = 0u;
          __int128 v161 = 0u;
          __int128 v162 = 0u;
          __int128 v159 = 0u;
          __int128 v160 = 0u;
          __int128 v157 = 0u;
          __int128 v158 = 0u;
          __int128 v155 = 0u;
          __int128 v156 = 0u;
          __int128 v153 = 0u;
          __int128 v154 = 0u;
          __int128 v152 = 0u;
          memset(key, 0, sizeof(key));
          if ((nwsc_get_endpoint_identifier(v8, (uint64_t)key) & 1) != 0)
          {
            xpc_dictionary_get_value(v7->remotePubKeys, key);
            os_log_type_t v10 = (void *)objc_claimAutoreleasedReturnValue();
            unsigned int v11 = v10;
            memset(buffer, 0, 40);
            if (!v10 || xpc_data_get_bytes(v10, buffer, 0LL, 0x28uLL) >= 0x28) {
              goto LABEL_51;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v12 = (id)gLogObj;
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "nwsc_get_remote_pub_key";
            id v13 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v141 = 0;
            if (__nwlog_fault(v13, &type, &v141))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                __int16 v14 = (os_log_s *)(id)gLogObj;
                os_log_type_t v15 = type;
                if (os_log_type_enabled(v14, type))
                {
                  *(_DWORD *)__int128 buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nwsc_get_remote_pub_key";
                  _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s Insufficient length in remotePubKeys", buf, 0xCu);
                }
              }

              else if (v141)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                __nwlog_obj();
                __int16 v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v26 = type;
                BOOL v27 = os_log_type_enabled(v14, type);
                if (backtrace_string)
                {
                  if (v27)
                  {
                    *(_DWORD *)__int128 buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nwsc_get_remote_pub_key";
                    __int16 v148 = 2082;
                    uint64_t v149 = backtrace_string;
                    _os_log_impl( &dword_181A5C000,  v14,  v26,  "%{public}s Insufficient length in remotePubKeys, dumping backtrace:%{public}s",  buf,  0x16u);
                  }

                  free(backtrace_string);
                  if (!v13) {
                    goto LABEL_51;
                  }
                  goto LABEL_50;
                }

                if (v27)
                {
                  *(_DWORD *)__int128 buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nwsc_get_remote_pub_key";
                  _os_log_impl( &dword_181A5C000,  v14,  v26,  "%{public}s Insufficient length in remotePubKeys, no backtrace",  buf,  0xCu);
                }
              }

              else
              {
                __nwlog_obj();
                __int16 v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                os_log_type_t v29 = type;
                if (os_log_type_enabled(v14, type))
                {
                  *(_DWORD *)__int128 buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nwsc_get_remote_pub_key";
                  _os_log_impl( &dword_181A5C000,  v14,  v29,  "%{public}s Insufficient length in remotePubKeys, backtrace limit exceeded",  buf,  0xCu);
                }
              }
            }

            if (!v13)
            {
LABEL_51:
              __int128 v145 = *(_OWORD *)&buffer[1];
              __int128 v146 = *(_OWORD *)&buffer[3];
              unint64_t v28 = buffer[0];

LABEL_52:
              uint64_t v30 = *MEMORY[0x18960B9C0];
              uint64_t v31 = *MEMORY[0x18960B968];
              v143[0] = *MEMORY[0x18960B998];
              v143[1] = v31;
              uint64_t v32 = *MEMORY[0x18960B980];
              v144[0] = v30;
              v144[1] = v32;
              [MEMORY[0x189603F68] dictionaryWithObjects:v144 forKeys:v143 count:2];
              attributes = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
              char v33 = (const __CFData *)[objc_alloc(MEMORY[0x189603F48]) initWithBytesNoCopy:&v145 length:32 freeWhenDone:0];
              *(void *)__int128 buf = 0LL;
              id v34 = SecKeyCreateWithData(v33, attributes, (CFErrorRef *)buf);
              if (v34)
              {
                __int16 v35 = (const __CFData *)[objc_alloc(MEMORY[0x189603F48]) initWithBytesNoCopy:v5->incomingReqBytesToVerify length:v5->incomingReqBytesToVerifyLen freeWhenDone:0];
                os_log_type_t v36 = (const __CFData *)[objc_alloc(MEMORY[0x189603F48]) initWithBytesNoCopy:v5->signature length:64 freeWhenDone:0];
                int v37 = SecKeyVerifySignature(v34, (SecKeyAlgorithm)*MEMORY[0x18960BCA8], v35, v36, (CFErrorRef *)buf);
                CFRelease(v34);

                if (v37)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  unsigned __int16 v38 = (os_log_s *)(id)gLogObj;
                  if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
                  {
                    int v39 = v5->signature[0];
                    int v40 = v5->signature[1];
                    int v41 = v5->signature[2];
                    int v42 = v5->signature[3];
                    *(_DWORD *)key = 136448770;
                    *(void *)&key[4] = "nwsc_process_incoming_request";
                    *(_WORD *)&key[12] = 2114;
                    *(void *)&key[14] = v7;
                    *(_WORD *)&key[22] = 2114;
                    *(void *)&key[24] = v5;
                    *(_WORD *)&key[32] = 1024;
                    *(_DWORD *)&key[34] = v39;
                    *(_WORD *)&key[38] = 1024;
                    *(_DWORD *)&key[40] = v40;
                    *(_WORD *)&key[44] = 1024;
                    *(_DWORD *)&key[46] = v41;
                    *(_WORD *)&key[50] = 1024;
                    *(_DWORD *)&key[52] = v42;
                    *(_WORD *)&key[56] = 1024;
                    *(_DWORD *)&key[58] = v145;
                    *(_WORD *)&key[62] = 1024;
                    LODWORD(v152) = BYTE1(v145);
                    WORD2(v152) = 1024;
                    *(_DWORD *)((char *)&v152 + 6) = BYTE2(v145);
                    WORD5(v152) = 1024;
                    HIDWORD(v152) = BYTE3(v145);
                    _os_log_impl( &dword_181A5C000,  v38,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ verified signature on incoming request %{public}@ sig %02x%02x%02x%02x remot ePubKey %02x%02x%02x%02x",  (uint8_t *)key,  0x50u);
                  }

                  *((_BYTE *)v5 + 616) |= 0x40u;
                  if ((*((_BYTE *)v7 + 152) & 4) != 0)
                  {
                    __nwlog_obj();
                    os_log_type_t v119 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v119, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)key = 136446722;
                      *(void *)&key[4] = "nwsc_process_incoming_request";
                      *(_WORD *)&key[12] = 2114;
                      *(void *)&key[14] = v7;
                      *(_WORD *)&key[22] = 2114;
                      *(void *)&key[24] = v5;
                      _os_log_impl( &dword_181A5C000,  v119,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ failing incoming connection for testing: %{public}@",  (uint8_t *)key,  0x20u);
                    }

                    nw_connection_cancel_current_endpoint((nw_connection_t)v5->connection);
                  }

                  nw_service_connector_remove_pending_unverified_incoming_request(v7, v5);
                  uint64_t v43 = nw_service_connector_copy_active_connection_with_endpoint_and_service( v7,  v5->endpoint,  (uint64_t)v5->service);
                  id v44 = v43;
                  if (v43)
                  {
                    __int16 v45 = (void *)*((void *)v43 + 61);
                    if (!v45) {
                      goto LABEL_60;
                    }
                    os_log_type_t v46 = v45;
                    buffer[0] = 0LL;
                    buffer[1] = buffer;
                    buffer[2] = 0x2020000000LL;
                    LOBYTE(buffer[3]) = 0;
                    os_log_type_t v47 = v46 + 34;
                    *(void *)key = MEMORY[0x1895F87A8];
                    *(void *)&key[8] = 3221225472LL;
                    *(void *)&key[16] = __nw_connection_is_cancelled_or_failed_block_invoke;
                    *(void *)&key[24] = &unk_189BC9210;
                    *(void *)&key[40] = buffer;
                    __int16 v48 = v46;
                    *(void *)&key[32] = v48;
                    os_unfair_lock_lock(v47);
                    (*(void (**)(char *))&key[16])(key);
                    os_unfair_lock_unlock(v47);
                    int v49 = *(unsigned __int8 *)(buffer[1] + 24LL);

                    _Block_object_dispose(buffer, 8);
                    if (v49)
                    {
LABEL_60:
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      BOOL v50 = (os_log_s *)(id)gLogObj;
                      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)key = 136446978;
                        *(void *)&key[4] = "nwsc_process_incoming_request";
                        *(_WORD *)&key[12] = 2114;
                        *(void *)&key[14] = v7;
                        *(_WORD *)&key[22] = 2114;
                        *(void *)&key[24] = v44;
                        *(_WORD *)&key[32] = 2114;
                        *(void *)&key[34] = v5;
                        _os_log_impl( &dword_181A5C000,  v50,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ Cleaning up dead activeConnection %{public}@ due to receiving incoming r equest %{public}@",  (uint8_t *)key,  0x2Au);
                      }

                      nw_service_connector_cancel_request_inner( v7,  v5->endpoint,  (uint64_t)v5->service,  *((void **)v44 + 61),  0);
LABEL_74:
                      __int128 v58 = (char *)nw_service_connector_copy_active_outgoing_request( v7,  v5->endpoint,  (uint64_t)v5->service);
                      __int128 v56 = v58;
                      if (!v58)
                      {
LABEL_81:
                        __int128 v56 = 0LL;
                        nw_service_connector_handle_unsolicited_requests(v7, v5);
                        id v44 = 0LL;
LABEL_112:

                        goto LABEL_113;
                      }

                      char v60 = v58[616];
                      if ((v60 & 0x10) == 0)
                      {
                        uint64_t v61 = (void *)*((void *)v58 + 72);
                        if (!v61 || nw_connection_is_cancelled(v61))
                        {
                          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                          networkd_settings_init();
                          __int128 v62 = (os_log_s *)(id)gLogObj;
                          if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_DWORD *)key = 136446978;
                            *(void *)&key[4] = "nwsc_process_incoming_request";
                            *(_WORD *)&key[12] = 2114;
                            *(void *)&key[14] = v7;
                            *(_WORD *)&key[22] = 2114;
                            *(void *)&key[24] = v56;
                            *(_WORD *)&key[32] = 2114;
                            *(void *)&key[34] = v5;
                            _os_log_impl( &dword_181A5C000,  v62,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ Cleaning up dead outgoing request %{public}@ due to receiving incomi ng request %{public}@",  (uint8_t *)key,  0x2Au);
                          }

                          nw_service_connector_cancel_request_inner( v7,  v5->endpoint,  (uint64_t)v5->service,  *((void **)v56 + 72),  0);
                          goto LABEL_81;
                        }

                        char v60 = v56[616];
                      }

                      char v69 = v60 & 0xEF;
                      v56[616] = v69;
                      uint64_t v70 = *((void *)v56 + 76);
                      if (v70)
                      {
                        nw_queue_cancel_source(v70, v59);
                        *((void *)v56 + 76) = 0LL;
                        char v69 = v56[616];
                      }

                      if ((v69 & 0x80) == 0 && nwsc_compare_uuid((unsigned __int8 *)v56 + 480, v5->uuid))
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        os_log_type_t v71 = (os_log_s *)(id)gLogObj;
                        if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)key = 136446978;
                          *(void *)&key[4] = "nwsc_process_incoming_request";
                          *(_WORD *)&key[12] = 2114;
                          *(void *)&key[14] = v7;
                          *(_WORD *)&key[22] = 2114;
                          *(void *)&key[24] = v56;
                          *(_WORD *)&key[32] = 2114;
                          *(void *)&key[34] = v5;
                          _os_log_impl( &dword_181A5C000,  v71,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ existing outgoing request %{public}@ has a larger UUID, rejecting inco ming request %{public}@",  (uint8_t *)key,  0x2Au);
                        }

                        nw_service_connector_reject_incoming_request(v7, v5, 0);
                        id v44 = 0LL;
                        goto LABEL_112;
                      }

                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      os_log_type_t v72 = (os_log_s *)(id)gLogObj;
                      if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
                      {
                        int v73 = v56[616];
                        uint64_t v74 = "has a smaller UUID";
                        *(void *)&key[4] = "nwsc_process_incoming_request";
                        *(_DWORD *)key = 136447234;
                        *(_WORD *)&key[12] = 2114;
                        if (v73 < 0) {
                          uint64_t v74 = "is waiting for path";
                        }
                        *(void *)&key[14] = v7;
                        *(_WORD *)&key[22] = 2114;
                        *(void *)&key[24] = v56;
                        *(_WORD *)&key[32] = 2082;
                        *(void *)&key[34] = v74;
                        *(_WORD *)&key[42] = 2114;
                        *(void *)&key[44] = v5;
                        _os_log_impl( &dword_181A5C000,  v72,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ existing outgoing request %{public}@ %{public}s, cancelling our outgoing request and accepting incoming request %{public}@",  (uint8_t *)key,  0x34u);
                      }

                      nw_service_connector_cancel_request_inner( v7,  *((void **)v56 + 1),  (uint64_t)(v56 + 24),  *((void **)v56 + 72),  0);
                      connection = v5->connection;
                      v137[0] = MEMORY[0x1895F87A8];
                      v137[1] = 3221225472LL;
                      v137[2] = ___ZL29nwsc_process_incoming_requestP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke;
                      v137[3] = &unk_189BBFD10;
                      int v138 = v7;
                      __int128 v56 = v56;
                      os_log_type_t v139 = v56;
                      int v140 = v5;
                      nw_service_connector_accept_connection_for_request(v138, connection, v140, v137);
                      id v44 = 0LL;
                      uint64_t v76 = (id *)&v138;
                      os_log_type_t v77 = (id *)&v139;
                      int v78 = (id *)&v140;
LABEL_111:

                      goto LABEL_112;
                    }
                  }

                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  os_log_type_t v51 = (os_log_s *)(id)gLogObj;
                  if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)key = 136446978;
                    *(void *)&key[4] = "nwsc_process_incoming_request";
                    *(_WORD *)&key[12] = 2114;
                    *(void *)&key[14] = v7;
                    *(_WORD *)&key[22] = 2114;
                    *(void *)&key[24] = v5;
                    *(_WORD *)&key[32] = 2114;
                    *(void *)&key[34] = v44;
                    _os_log_impl( &dword_181A5C000,  v51,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ Received incoming request %{public}@ activeConnection %{public}@",  (uint8_t *)key,  0x2Au);
                  }

                  if (!v44) {
                    goto LABEL_74;
                  }
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  id v52 = (os_log_s *)(id)gLogObj;
                  if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)key = 136446978;
                    *(void *)&key[4] = "nwsc_process_incoming_request";
                    *(_WORD *)&key[12] = 2114;
                    *(void *)&key[14] = v7;
                    *(_WORD *)&key[22] = 2114;
                    *(void *)&key[24] = v5;
                    *(_WORD *)&key[32] = 2114;
                    *(void *)&key[34] = v44;
                    _os_log_impl( &dword_181A5C000,  v52,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ received incoming request %{public}@ while we have activeConnection %{public}@",  (uint8_t *)key,  0x2Au);
                  }

                  unint64_t v53 = *((void *)v44 + 57);
                  unint64_t sequenceNumber = v5->sequenceNumber;
                  if (v53 < sequenceNumber)
                  {
                    uint64_t v55 = (char *)nw_service_connector_copy_active_outgoing_request( v7,  v5->endpoint,  (uint64_t)v5->service);
                    __int128 v56 = v55;
                    if (!v55 || (v55[616] & 0x10) == 0)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      os_log_type_t v57 = (os_log_s *)(id)gLogObj;
                      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)key = 136446978;
                        *(void *)&key[4] = "nwsc_process_incoming_request";
                        *(_WORD *)&key[12] = 2114;
                        *(void *)&key[14] = v7;
                        *(_WORD *)&key[22] = 2114;
                        *(void *)&key[24] = v44;
                        *(_WORD *)&key[32] = 2114;
                        *(void *)&key[34] = v5;
                        _os_log_impl( &dword_181A5C000,  v57,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ active connection %{public}@ has a lower sequence number than incoming r equest %{public}@, accepting incoming request and cancelling active connection",  (uint8_t *)key,  0x2Au);
                      }

                      nw_service_connector_cancel_request_inner( v7,  *((void **)v44 + 1),  (uint64_t)v44 + 16,  *((void **)v44 + 61),  1);
                      nw_service_connector_handle_unsolicited_requests(v7, v5);
                      goto LABEL_112;
                    }

                    __nwlog_obj();
                    os_log_type_t v79 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                    if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)key = 136447234;
                      *(void *)&key[4] = "nwsc_process_incoming_request";
                      *(_WORD *)&key[12] = 2114;
                      *(void *)&key[14] = v7;
                      *(_WORD *)&key[22] = 2114;
                      *(void *)&key[24] = v44;
                      *(_WORD *)&key[32] = 2114;
                      *(void *)&key[34] = v5;
                      *(_WORD *)&key[42] = 2114;
                      *(void *)&key[44] = v56;
                      _os_log_impl( &dword_181A5C000,  v79,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ active connection %{public}@ has a lower sequence number than incoming req uest %{public}@, accepting incoming request, cancelling active connection and using %{public}@",  (uint8_t *)key,  0x34u);
                    }

                    v56[616] &= ~0x10u;
                    uint64_t v81 = *((void *)v56 + 76);
                    if (v81)
                    {
                      nw_queue_cancel_source(v81, v80);
                      *((void *)v56 + 76) = 0LL;
                    }

                    nw_service_connector_cancel_request_inner( v7,  *((void **)v44 + 1),  (uint64_t)v44 + 16,  *((void **)v44 + 61),  1);
                    BOOL v82 = v5->connection;
                    v133[0] = MEMORY[0x1895F87A8];
                    v133[1] = 3221225472LL;
                    v133[2] = ___ZL29nwsc_process_incoming_requestP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke_188;
                    v133[3] = &unk_189BBFD10;
                    __int128 v134 = v7;
                    os_log_type_t v83 = v56;
                    __int128 v135 = v83;
                    __int128 v136 = v5;
                    nw_service_connector_accept_connection_for_request(v134, v82, v136, v133);
                    uint64_t v76 = (id *)&v134;
                    os_log_type_t v77 = (id *)&v135;
                    int v78 = (id *)&v136;
                    __int128 v56 = v83;
                    goto LABEL_111;
                  }

                  if (v53 > sequenceNumber)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    os_log_type_t v63 = (os_log_s *)(id)gLogObj;
                    if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)key = 136446978;
                      *(void *)&key[4] = "nwsc_process_incoming_request";
                      *(_WORD *)&key[12] = 2114;
                      *(void *)&key[14] = v7;
                      *(_WORD *)&key[22] = 2114;
                      *(void *)&key[24] = v44;
                      *(_WORD *)&key[32] = 2114;
                      *(void *)&key[34] = v5;
                      _os_log_impl( &dword_181A5C000,  v63,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ active connection %{public}@ has a higher sequence number than incoming re quest %{public}@, rejecting incoming request",  (uint8_t *)key,  0x2Au);
                    }

                    goto LABEL_140;
                  }

                  BOOL v64 = nwsc_compare_uuid((unsigned __int8 *)v44 + 472, v5->uuid);
                  __nwlog_obj();
                  __int128 v65 = (void *)objc_claimAutoreleasedReturnValue();
                  if (v64)
                  {
                    *(_DWORD *)key = 136446978;
                    *(void *)&key[4] = "nwsc_process_incoming_request";
                    *(_WORD *)&key[12] = 2114;
                    *(void *)&key[14] = v7;
                    *(_WORD *)&key[22] = 2114;
                    *(void *)&key[24] = v44;
                    *(_WORD *)&key[32] = 2114;
                    *(void *)&key[34] = v5;
                    BOOL v66 = (char *)_os_log_send_and_compose_impl();

                    LOBYTE(buffer[0]) = 16;
                    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                    if (__nwlog_fault(v66, buffer, &type))
                    {
                      if (LOBYTE(buffer[0]) == 17)
                      {
                        __nwlog_obj();
                        id v67 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        os_log_type_t v68 = buffer[0];
                        if (os_log_type_enabled(v67, buffer[0]))
                        {
                          *(_DWORD *)key = 136446978;
                          *(void *)&key[4] = "nwsc_process_incoming_request";
                          *(_WORD *)&key[12] = 2114;
                          *(void *)&key[14] = v7;
                          *(_WORD *)&key[22] = 2114;
                          *(void *)&key[24] = v44;
                          *(_WORD *)&key[32] = 2114;
                          *(void *)&key[34] = v5;
                          _os_log_impl( &dword_181A5C000,  v67,  v68,  "%{public}s %{public}@ active connection %{public}@ has same sequence number than incoming re quest %{public}@ but higher UUID, rejecting incoming request",  (uint8_t *)key,  0x2Au);
                        }
                      }

                      else if (type)
                      {
                        os_log_type_t v87 = (char *)__nw_create_backtrace_string();
                        __nwlog_obj();
                        id v67 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        os_log_type_t v88 = buffer[0];
                        BOOL v89 = os_log_type_enabled(v67, buffer[0]);
                        if (v87)
                        {
                          if (v89)
                          {
                            *(_DWORD *)key = 136447234;
                            *(void *)&key[4] = "nwsc_process_incoming_request";
                            *(_WORD *)&key[12] = 2114;
                            *(void *)&key[14] = v7;
                            *(_WORD *)&key[22] = 2114;
                            *(void *)&key[24] = v44;
                            *(_WORD *)&key[32] = 2114;
                            *(void *)&key[34] = v5;
                            *(_WORD *)&key[42] = 2082;
                            *(void *)&key[44] = v87;
                            _os_log_impl( &dword_181A5C000,  v67,  v88,  "%{public}s %{public}@ active connection %{public}@ has same sequence number than incoming request %{public}@ but higher UUID, rejecting incoming request, dumping backtrace:%{public}s",  (uint8_t *)key,  0x34u);
                          }

                          free(v87);
                          goto LABEL_138;
                        }

                        if (v89)
                        {
                          *(_DWORD *)key = 136446978;
                          *(void *)&key[4] = "nwsc_process_incoming_request";
                          *(_WORD *)&key[12] = 2114;
                          *(void *)&key[14] = v7;
                          *(_WORD *)&key[22] = 2114;
                          *(void *)&key[24] = v44;
                          *(_WORD *)&key[32] = 2114;
                          *(void *)&key[34] = v5;
                          _os_log_impl( &dword_181A5C000,  v67,  v88,  "%{public}s %{public}@ active connection %{public}@ has same sequence number than incoming re quest %{public}@ but higher UUID, rejecting incoming request, no backtrace",  (uint8_t *)key,  0x2Au);
                        }
                      }

                      else
                      {
                        __nwlog_obj();
                        id v67 = (os_log_s *)objc_claimAutoreleasedReturnValue();
                        os_log_type_t v93 = buffer[0];
                        if (os_log_type_enabled(v67, buffer[0]))
                        {
                          *(_DWORD *)key = 136446978;
                          *(void *)&key[4] = "nwsc_process_incoming_request";
                          *(_WORD *)&key[12] = 2114;
                          *(void *)&key[14] = v7;
                          *(_WORD *)&key[22] = 2114;
                          *(void *)&key[24] = v44;
                          *(_WORD *)&key[32] = 2114;
                          *(void *)&key[34] = v5;
                          _os_log_impl( &dword_181A5C000,  v67,  v93,  "%{public}s %{public}@ active connection %{public}@ has same sequence number than incoming re quest %{public}@ but higher UUID, rejecting incoming request, backtrace limit exceeded",  (uint8_t *)key,  0x2Au);
                        }
                      }
                    }

void sub_1822AB1A4( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20, void *a21, void *a22)
{
  _Unwind_Resume(a1);
}

id nw_service_connector_copy_active_request_for_connection( NWConcrete_nw_service_connector *a1, NWConcrete_nw_connection *a2)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unsigned int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null serviceConnector", buf, 0xCu);
      }

      goto LABEL_53;
    }

    if (!v30)
    {
      __nwlog_obj();
      unsigned int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
        _os_log_impl( &dword_181A5C000,  v11,  v24,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  buf,  0xCu);
      }

      goto LABEL_53;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    unsigned int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v18 = type;
    BOOL v19 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
        _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s called with null serviceConnector, no backtrace",  buf,  0xCu);
      }

      goto LABEL_53;
    }

    if (v19)
    {
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
      *(_WORD *)&_BYTE buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v11,  v18,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  buf,  0x16u);
    }

uint64_t ___ZL24nwsc_save_remote_pub_keyP31NWConcrete_nw_service_connectorPU25objcproto14OS_nw_endpoint8NSObjectyPh_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  uint64_t v5 = *(void **)(a1 + 32);
  uint64_t v6 = (dispatch_queue_s *)v5[4];
  block[0] = MEMORY[0x1895F87A8];
  block[1] = 3221225472LL;
  block[2] = ___ZL24nwsc_save_remote_pub_keyP31NWConcrete_nw_service_connectorPU25objcproto14OS_nw_endpoint8NSObjectyPh_block_invoke_2;
  block[3] = &unk_189BC75E8;
  os_log_type_t v10 = v5;
  id v11 = v4;
  uint64_t v12 = *(void *)(a1 + 40);
  id v7 = v4;
  dispatch_async(v6, block);

  return 1LL;
}

void ___ZL45nw_service_connector_should_accept_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionb_block_invoke_176( uint64_t a1)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    *(_DWORD *)__int128 buf = 136446722;
    BOOL v27 = "nw_service_connector_should_accept_connection_block_invoke";
    __int16 v28 = 2114;
    uint64_t v29 = v3;
    __int16 v30 = 2114;
    uint64_t v31 = v4;
    _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_INFO,  "%{public}s %{public}@ disabling keep alives for request %{public}@",  buf,  0x20u);
  }

  int v5 = nw_tcp_reset_keepalives(*(void **)(a1 + 48), 0, 0, 0, 0);
  if (v5)
  {
    int v6 = v5;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v9 = *(void *)(a1 + 40);
    *(_DWORD *)__int128 buf = 136446978;
    BOOL v27 = "nw_service_connector_should_accept_connection_block_invoke";
    __int16 v28 = 2114;
    uint64_t v29 = v8;
    __int16 v30 = 2114;
    uint64_t v31 = v9;
    __int16 v32 = 1024;
    int v33 = v6;
    os_log_type_t v10 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault((const char *)v10, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_21;
        }
        uint64_t v13 = *(void *)(a1 + 32);
        uint64_t v14 = *(void *)(a1 + 40);
        *(_DWORD *)__int128 buf = 136446978;
        BOOL v27 = "nw_service_connector_should_accept_connection_block_invoke";
        __int16 v28 = 2114;
        uint64_t v29 = v13;
        __int16 v30 = 2114;
        uint64_t v31 = v14;
        __int16 v32 = 1024;
        int v33 = v6;
        os_log_type_t v15 = "%{public}s %{public}@ error disabling keep alives for request %{public}@ %{darwin.errno}d";
        goto LABEL_20;
      }

      if (!v24)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v11 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_21;
        }
        uint64_t v20 = *(void *)(a1 + 32);
        uint64_t v21 = *(void *)(a1 + 40);
        *(_DWORD *)__int128 buf = 136446978;
        BOOL v27 = "nw_service_connector_should_accept_connection_block_invoke";
        __int16 v28 = 2114;
        uint64_t v29 = v20;
        __int16 v30 = 2114;
        uint64_t v31 = v21;
        __int16 v32 = 1024;
        int v33 = v6;
        os_log_type_t v15 = "%{public}s %{public}@ error disabling keep alives for request %{public}@ %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_20;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v11 = (os_log_s *)(id)gLogObj;
      os_log_type_t v12 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (!v17) {
          goto LABEL_21;
        }
        uint64_t v22 = *(void *)(a1 + 32);
        uint64_t v23 = *(void *)(a1 + 40);
        *(_DWORD *)__int128 buf = 136446978;
        BOOL v27 = "nw_service_connector_should_accept_connection_block_invoke";
        __int16 v28 = 2114;
        uint64_t v29 = v22;
        __int16 v30 = 2114;
        uint64_t v31 = v23;
        __int16 v32 = 1024;
        int v33 = v6;
        os_log_type_t v15 = "%{public}s %{public}@ error disabling keep alives for request %{public}@ %{darwin.errno}d, no backtrace";
LABEL_20:
        _os_log_impl(&dword_181A5C000, v11, v12, v15, buf, 0x26u);
LABEL_21:

        if (!v10) {
          return;
        }
LABEL_14:
        free(v10);
        return;
      }

      if (v17)
      {
        uint64_t v18 = *(void *)(a1 + 32);
        uint64_t v19 = *(void *)(a1 + 40);
        *(_DWORD *)__int128 buf = 136447234;
        BOOL v27 = "nw_service_connector_should_accept_connection_block_invoke";
        __int16 v28 = 2114;
        uint64_t v29 = v18;
        __int16 v30 = 2114;
        uint64_t v31 = v19;
        __int16 v32 = 1024;
        int v33 = v6;
        __int16 v34 = 2082;
        id v35 = backtrace_string;
        _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s %{public}@ error disabling keep alives for request %{public}@ %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x30u);
      }

      free(backtrace_string);
    }

    if (!v10) {
      return;
    }
    goto LABEL_14;
  }

void ___ZL45nw_service_connector_should_accept_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionb_block_invoke_177( void **a1, int a2)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = a1[4];
      int v6 = a1[5];
      int v9 = 136446978;
      os_log_type_t v10 = "nw_service_connector_should_accept_connection_block_invoke";
      __int16 v11 = 2114;
      os_log_type_t v12 = v5;
      __int16 v13 = 2114;
      uint64_t v14 = v6;
      __int16 v15 = 1024;
      int v16 = a2;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ error when accepting request %{public}@ %{darwin.errno}d",  (uint8_t *)&v9,  0x26u);
    }

    uint64_t v8 = a1[4];
    id v7 = a1 + 4;
    nw_service_connector_cancel_request_inner(v8, *((void **)v7[1] + 1), (uint64_t)v7[1] + 24, v7[2], 0);
    nw_service_connector_trigger_request_complete_block_inner(*v7, v7[1], 0LL, 0LL, a2);
  }

  else
  {
    nw_service_connector_trigger_request_complete_block_inner(a1[4], a1[5], 0LL, a1[6], 0);
  }

void nw_service_connector_accept_connection_for_request(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t v131 = *MEMORY[0x1895F89C0];
  id v95 = a1;
  id v97 = a2;
  id v7 = a3;
  uint64_t v96 = a4;
  if (v96)
  {
    uint64_t v8 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_unique_connection);
    int v9 = v8;
    if (v8)
    {
      objc_storeStrong((id *)&v8->connection, a2);
      p_endpoint = (void **)&v9->endpoint;
      objc_storeStrong((id *)&v9->endpoint, v7->endpoint);
      unint64_t v11 = 436LL;
      service = v9->service;
      while (*service)
      {
        ++service;
        if (!--v11) {
          goto LABEL_13;
        }
      }

      if (v11 < 2)
      {
LABEL_12:
        char *service = 0;
      }

      else
      {
        uint64_t v13 = 0LL;
        while (1)
        {
          int v14 = v7->service[v13];
          service[v13] = v14;
          if (!v14) {
            break;
          }
          --v11;
          ++v13;
          if (v11 <= 1)
          {
            service += v13;
            goto LABEL_12;
          }
        }
      }

void sub_1822AD610( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void ___ZL24nwsc_save_remote_pub_keyP31NWConcrete_nw_service_connectorPU25objcproto14OS_nw_endpoint8NSObjectyPh_block_invoke_2( uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  if (*(_DWORD *)(*(void *)(a1 + 32) + 16LL) == 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v2 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v3 = *(void *)(a1 + 32);
      uint64_t v4 = *(void **)(a1 + 40);
      uint64_t v5 = *(void *)(a1 + 48);
      *(_DWORD *)__int128 buf = 136446978;
      *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key_block_invoke_2";
      *(_WORD *)&_BYTE buf[12] = 2114;
      *(void *)&buf[14] = v3;
      *(_WORD *)&_BYTE buf[22] = 2114;
      int v24 = v4;
      LOWORD(v25) = 2048;
      *(void *)((char *)&v25 + 2) = v5;
      _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ already cancelled, not reevaluating %{public}@ due to received seq %llu",  buf,  0x2Au);
    }
  }

  else
  {
    int v6 = *(void **)(*(void *)(a1 + 40) + 576LL);
    if (!v6) {
      goto LABEL_7;
    }
    id v7 = v6;
    uint64_t v19 = 0LL;
    uint64_t v20 = &v19;
    uint64_t v21 = 0x2020000000LL;
    char v22 = 0;
    uint64_t v8 = v7 + 34;
    *(void *)__int128 buf = MEMORY[0x1895F87A8];
    *(void *)&uint8_t buf[8] = 3221225472LL;
    *(void *)&buf[16] = __nw_connection_is_cancelled_or_failed_block_invoke;
    int v24 = &unk_189BC9210;
    *((void *)&v25 + 1) = &v19;
    int v9 = v7;
    *(void *)&__int128 v25 = v9;
    os_unfair_lock_lock(v8);
    __nw_connection_is_cancelled_or_failed_block_invoke((uint64_t)buf);
    os_unfair_lock_unlock(v8);
    LODWORD(v_Block_object_dispose((const void *)(v50 - 136), 8) = *((unsigned __int8 *)v20 + 24);

    _Block_object_dispose(&v19, 8);
    if (!(_DWORD)v8)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v15 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = *(void *)(a1 + 32);
        uint64_t v17 = *(void **)(a1 + 40);
        uint64_t v18 = *(void *)(a1 + 48);
        *(_DWORD *)__int128 buf = 136446978;
        *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key_block_invoke";
        *(_WORD *)&_BYTE buf[12] = 2114;
        *(void *)&buf[14] = v16;
        *(_WORD *)&_BYTE buf[22] = 2114;
        int v24 = v17;
        LOWORD(v25) = 2048;
        *(void *)((char *)&v25 + 2) = v18;
        _os_log_impl( &dword_181A5C000,  v15,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ reevaluating %{public}@ due to received seq %llu",  buf,  0x2Au);
      }

      nwsc_process_incoming_request( *(NWConcrete_nw_service_connector **)(a1 + 32),  *(NWConcrete_nw_unique_connection_request **)(a1 + 40));
    }

    else
    {
LABEL_7:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void *)(a1 + 32);
        os_log_type_t v12 = *(void **)(a1 + 40);
        *(_DWORD *)__int128 buf = 136446722;
        *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key_block_invoke";
        *(_WORD *)&_BYTE buf[12] = 2114;
        *(void *)&buf[14] = v11;
        *(_WORD *)&_BYTE buf[22] = 2114;
        int v24 = v12;
        _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ removing unverified incoming request %{public}@ with bad connection",  buf,  0x20u);
      }

      uint64_t v13 = *(NWConcrete_nw_unique_connection_request **)(a1 + 40);
      connection = (nw_connection *)v13->connection;
      if (connection)
      {
        nw_connection_cancel(connection);
        uint64_t v13 = *(NWConcrete_nw_unique_connection_request **)(a1 + 40);
      }

      nw_service_connector_remove_pending_unverified_incoming_request( *(NWConcrete_nw_service_connector **)(a1 + 32),  v13);
    }
  }

void nw_service_connector_remove_pending_unverified_incoming_request( NWConcrete_nw_service_connector *a1, NWConcrete_nw_unique_connection_request *a2)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v4 = a2;
  uint64_t v5 = (uint64_t)v4;
  if (!v3)
  {
    __nwlog_obj();
    id v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
          __int16 v30 = 2082;
          id v31 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_57:
        if (!v8) {
          goto LABEL_7;
        }
LABEL_58:
        free(v8);
        goto LABEL_7;
      }

      if (v17)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
        _os_log_impl(&dword_181A5C000, v9, v16, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
        _os_log_impl( &dword_181A5C000,  v9,  v23,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  buf,  0xCu);
      }
    }

BOOL ___ZL55nw_service_connector_copy_active_request_for_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connection_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = a3;
  uint64_t v6 = v5[72];
  uint64_t v7 = *(void *)(a1 + 32);
  if (v6 == v7) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL), a3);
  }

  return v6 != v7;
}

void nw_service_connector_reject_incoming_request( NWConcrete_nw_service_connector *a1, NWConcrete_nw_unique_connection_request *a2, int a3)
{
  uint64_t v93 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  uint64_t v6 = a2;
  uint64_t v8 = v6;
  char v9 = *((_BYTE *)v6 + 616);
  if ((v9 & 1) != 0)
  {
    uint64_t rejectTimer = (uint64_t)v6->rejectTimer;
    if (rejectTimer)
    {
      nw_queue_cancel_source(rejectTimer, v7);
      v8->uint64_t rejectTimer = 0LL;
      char v9 = *((_BYTE *)v8 + 616);
    }

    if ((v9 & 2) == 0) {
      goto LABEL_49;
    }
    __int16 v15 = v5;
    os_log_type_t v16 = v8;
    BOOL v17 = v16;
    if (v15)
    {
      if (v15[10])
      {
        int v92 = 0;
        __int128 v90 = 0u;
        __int128 v91 = 0u;
        __int128 v88 = 0u;
        __int128 v89 = 0u;
        __int128 v86 = 0u;
        __int128 v87 = 0u;
        __int128 v84 = 0u;
        __int128 v85 = 0u;
        __int128 v82 = 0u;
        __int128 v83 = 0u;
        __int128 v80 = 0u;
        __int128 v81 = 0u;
        __int128 v78 = 0u;
        __int128 v79 = 0u;
        __int128 v76 = 0u;
        __int128 v77 = 0u;
        __int128 v74 = 0u;
        __int128 v75 = 0u;
        __int128 v72 = 0u;
        __int128 v73 = 0u;
        __int128 v70 = 0u;
        __int128 v71 = 0u;
        __int128 v68 = 0u;
        __int128 v69 = 0u;
        __int128 v67 = 0u;
        memset(buf, 0, sizeof(buf));
        if (nwsc_get_identifier(v16->endpoint, (uint64_t)v16->service, buf))
        {
          nw_dictionary_set_value(v15[10], (const char *)buf, 0LL);
          goto LABEL_48;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v21 = (id)gLogObj;
        endpoint = v17->endpoint;
        *(_DWORD *)os_log_type_t type = 136446722;
        uint64_t v59 = "nw_service_connector_remove_pending_incoming_request";
        __int16 v60 = 2114;
        BOOL v61 = endpoint;
        __int16 v62 = 2082;
        service = v17->service;
        os_log_type_t v23 = (void *)_os_log_send_and_compose_impl();

        os_log_type_t v57 = OS_LOG_TYPE_ERROR;
        char v56 = 0;
        if (__nwlog_fault((const char *)v23, &v57, &v56))
        {
          if (v57 == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v24 = (os_log_s *)(id)gLogObj;
            os_log_type_t v25 = v57;
            if (os_log_type_enabled(v24, v57))
            {
              char v26 = v17->endpoint;
              *(_DWORD *)os_log_type_t type = 136446722;
              uint64_t v59 = "nw_service_connector_remove_pending_incoming_request";
              __int16 v60 = 2114;
              BOOL v61 = v26;
              __int16 v62 = 2082;
              service = v17->service;
              _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s",  (uint8_t *)type,  0x20u);
            }

void sub_1822AEDB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nwsc_compare_uuid(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v2 = *a1;
  unsigned int v3 = *a2;
  if (v2 != v3) {
    return v2 > v3;
  }
  unsigned int v2 = a1[1];
  unsigned int v3 = a2[1];
  if (v2 != v3) {
    return v2 > v3;
  }
  unsigned int v2 = a1[2];
  unsigned int v3 = a2[2];
  if (v2 != v3) {
    return v2 > v3;
  }
  unsigned int v2 = a1[3];
  unsigned int v3 = a2[3];
  if (v2 != v3) {
    return v2 > v3;
  }
  unsigned int v2 = a1[4];
  unsigned int v3 = a2[4];
  if (v2 != v3) {
    return v2 > v3;
  }
  unsigned int v2 = a1[5];
  unsigned int v3 = a2[5];
  if (v2 != v3) {
    return v2 > v3;
  }
  unsigned int v2 = a1[6];
  unsigned int v3 = a2[6];
  if (v2 != v3) {
    return v2 > v3;
  }
  unsigned int v2 = a1[7];
  unsigned int v3 = a2[7];
  if (v2 != v3) {
    return v2 > v3;
  }
  unsigned int v2 = a1[8];
  unsigned int v3 = a2[8];
  if (v2 != v3) {
    return v2 > v3;
  }
  unsigned int v2 = a1[9];
  unsigned int v3 = a2[9];
  if (v2 != v3) {
    return v2 > v3;
  }
  unsigned int v2 = a1[10];
  unsigned int v3 = a2[10];
  if (v2 != v3) {
    return v2 > v3;
  }
  unsigned int v2 = a1[11];
  unsigned int v3 = a2[11];
  if (v2 != v3) {
    return v2 > v3;
  }
  unsigned int v2 = a1[12];
  unsigned int v3 = a2[12];
  if (v2 != v3) {
    return v2 > v3;
  }
  unsigned int v2 = a1[13];
  unsigned int v3 = a2[13];
  if (v2 == v3 && (unsigned int v2 = a1[14], v3 = a2[14], v2 == v3) && (unsigned int v2 = a1[15], v3 = a2[15], v2 == v3)) {
    return 0LL;
  }
  else {
    return v2 > v3;
  }
}

void ___ZL29nwsc_process_incoming_requestP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke( uint64_t a1, int a2)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      uint64_t v6 = *(void *)(a1 + 48);
      int v7 = 136446978;
      uint64_t v8 = "nwsc_process_incoming_request_block_invoke";
      __int16 v9 = 2114;
      uint64_t v10 = v5;
      __int16 v11 = 2114;
      uint64_t v12 = v6;
      __int16 v13 = 1024;
      int v14 = a2;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ error when accepting request %{public}@ %{darwin.errno}d",  (uint8_t *)&v7,  0x26u);
    }

    nw_service_connector_cancel_request_inner( *(void **)(a1 + 32),  *(void **)(*(void *)(a1 + 48) + 8LL),  *(void *)(a1 + 48) + 24LL,  *(void **)(*(void *)(a1 + 48) + 576LL),  0);
    nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 32), *(void **)(a1 + 40), 0LL, 0LL, a2);
  }

  else
  {
    nw_service_connector_trigger_request_complete_block_inner( *(void **)(a1 + 32),  *(void **)(a1 + 40),  0LL,  *(void **)(*(void *)(a1 + 48) + 576LL),  0);
  }

void nw_service_connector_handle_unsolicited_requests( NWConcrete_nw_service_connector *a1, NWConcrete_nw_unique_connection_request *a2)
{
  uint64_t v84 = *MEMORY[0x1895F89C0];
  unsigned int v3 = a1;
  uint64_t v4 = a2;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int128 buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_service_connector_handle_unsolicited_requests";
    *(_WORD *)&_BYTE buf[12] = 2114;
    *(void *)&buf[14] = v3;
    *(_WORD *)&_BYTE buf[22] = 2114;
    *(void *)&_BYTE buf[24] = v4;
    _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ handling unsolicited incoming request %{public}@",  buf,  0x20u);
  }

  uint64_t v6 = (NWConcrete_nw_unique_connection_request *)nw_service_connector_copy_pending_incoming_request( v3,  v4->endpoint,  (uint64_t)v4->service);
  int v7 = v6;
  if (!v6)
  {
LABEL_11:

    uint64_t v12 = v3;
    __int16 v13 = v4;
    int v14 = v13;
    if (v12)
    {
      if (v12->pendingIncomingRequests)
      {
        *((_BYTE *)v13 + 616) |= 2u;
        int v83 = 0;
        __int128 v81 = 0u;
        __int128 v82 = 0u;
        __int128 v79 = 0u;
        __int128 v80 = 0u;
        __int128 v77 = 0u;
        __int128 v78 = 0u;
        __int128 v75 = 0u;
        __int128 v76 = 0u;
        __int128 v73 = 0u;
        __int128 v74 = 0u;
        __int128 v71 = 0u;
        __int128 v72 = 0u;
        __int128 v69 = 0u;
        __int128 v70 = 0u;
        __int128 v67 = 0u;
        __int128 v68 = 0u;
        __int128 v65 = 0u;
        __int128 v66 = 0u;
        __int128 v63 = 0u;
        __int128 v64 = 0u;
        __int128 v61 = 0u;
        __int128 v62 = 0u;
        __int128 v59 = 0u;
        __int128 v60 = 0u;
        __int128 v58 = 0u;
        memset(buf, 0, sizeof(buf));
        if (nwsc_get_identifier(v4->endpoint, (uint64_t)v4->service, buf))
        {
          nw_dictionary_set_value((uint64_t)v12->pendingIncomingRequests, (const char *)buf, v14);
LABEL_35:

          serviceConnectorQueue = (dispatch_queue_s *)v12->serviceConnectorQueue;
          block[0] = MEMORY[0x1895F87A8];
          block[1] = 3221225472LL;
          block[2] = ___ZL48nw_service_connector_handle_unsolicited_requestsP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke;
          block[3] = &unk_189BC9238;
          __int16 v45 = v12;
          os_log_type_t v46 = v14;
          dispatch_async(serviceConnectorQueue, block);

          int v7 = v45;
          goto LABEL_36;
        }

        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v15 = (id)gLogObj;
        endpoint = v4->endpoint;
        *(_DWORD *)BOOL v49 = 136446722;
        os_log_type_t v50 = "nw_service_connector_add_pending_incoming_request";
        __int16 v51 = 2114;
        os_log_type_t v52 = endpoint;
        __int16 v53 = 2082;
        service = v4->service;
        BOOL v17 = (const char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v47 = 0;
        if (__nwlog_fault(v17, &type, &v47))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v18 = (os_log_s *)(id)gLogObj;
            os_log_type_t v19 = type;
            if (os_log_type_enabled(v18, type))
            {
              BOOL v20 = v4->endpoint;
              *(_DWORD *)BOOL v49 = 136446722;
              os_log_type_t v50 = "nw_service_connector_add_pending_incoming_request";
              __int16 v51 = 2114;
              os_log_type_t v52 = v20;
              __int16 v53 = 2082;
              service = v4->service;
              _os_log_impl( &dword_181A5C000,  v18,  v19,  "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s",  v49,  0x20u);
            }
          }

          else if (v47)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v18 = (os_log_s *)(id)gLogObj;
            os_log_type_t v22 = type;
            BOOL v23 = os_log_type_enabled(v18, type);
            if (backtrace_string)
            {
              if (v23)
              {
                os_log_type_t v24 = v4->endpoint;
                *(_DWORD *)BOOL v49 = 136446978;
                os_log_type_t v50 = "nw_service_connector_add_pending_incoming_request";
                __int16 v51 = 2114;
                os_log_type_t v52 = v24;
                __int16 v53 = 2082;
                service = v4->service;
                __int16 v55 = 2082;
                char v56 = backtrace_string;
                _os_log_impl( &dword_181A5C000,  v18,  v22,  "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, dumping backtrace:%{public}s",  v49,  0x2Au);
              }

              free(backtrace_string);
              if (!v17) {
                goto LABEL_35;
              }
LABEL_33:
              id v28 = (char *)v17;
LABEL_34:
              free(v28);
              goto LABEL_35;
            }

            if (v23)
            {
              os_log_type_t v27 = v4->endpoint;
              *(_DWORD *)BOOL v49 = 136446722;
              os_log_type_t v50 = "nw_service_connector_add_pending_incoming_request";
              __int16 v51 = 2114;
              os_log_type_t v52 = v27;
              __int16 v53 = 2082;
              service = v4->service;
              _os_log_impl( &dword_181A5C000,  v18,  v22,  "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, no backtrace",  v49,  0x20u);
            }
          }

          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v18 = (os_log_s *)(id)gLogObj;
            os_log_type_t v25 = type;
            if (os_log_type_enabled(v18, type))
            {
              char v26 = v4->endpoint;
              *(_DWORD *)BOOL v49 = 136446722;
              os_log_type_t v50 = "nw_service_connector_add_pending_incoming_request";
              __int16 v51 = 2114;
              os_log_type_t v52 = v26;
              __int16 v53 = 2082;
              service = v4->service;
              _os_log_impl( &dword_181A5C000,  v18,  v25,  "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, backtrace limit exceeded",  v49,  0x20u);
            }
          }
        }

        if (!v17) {
          goto LABEL_35;
        }
        goto LABEL_33;
      }

      __nwlog_obj();
      __int16 v34 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
      os_log_type_t v31 = (const char *)_os_log_send_and_compose_impl();

      v49[0] = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (v49[0] == 17)
      {
        __nwlog_obj();
        uint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v35 = v49[0];
        if (os_log_type_enabled(v32, (os_log_type_t)v49[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
          _os_log_impl( &dword_181A5C000,  v32,  v35,  "%{public}s called with null serviceConnector->pendingIncomingRequests",  buf,  0xCu);
        }
      }

      else if (type)
      {
        BOOL v39 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v40 = v49[0];
        BOOL v41 = os_log_type_enabled(v32, (os_log_type_t)v49[0]);
        if (v39)
        {
          if (v41)
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v39;
            _os_log_impl( &dword_181A5C000,  v32,  v40,  "%{public}s called with null serviceConnector->pendingIncomingRequests, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v39);
          if (!v31) {
            goto LABEL_35;
          }
LABEL_71:
          id v28 = (char *)v31;
          goto LABEL_34;
        }

        if (v41)
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
          _os_log_impl( &dword_181A5C000,  v32,  v40,  "%{public}s called with null serviceConnector->pendingIncomingRequests, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v43 = v49[0];
        if (os_log_type_enabled(v32, (os_log_type_t)v49[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
          _os_log_impl( &dword_181A5C000,  v32,  v43,  "%{public}s called with null serviceConnector->pendingIncomingRequests, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v30 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
      os_log_type_t v31 = (const char *)_os_log_send_and_compose_impl();

      v49[0] = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (v49[0] == 17)
      {
        __nwlog_obj();
        uint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v33 = v49[0];
        if (os_log_type_enabled(v32, (os_log_type_t)v49[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
          _os_log_impl(&dword_181A5C000, v32, v33, "%{public}s called with null serviceConnector", buf, 0xCu);
        }
      }

      else if (type)
      {
        uint64_t v36 = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v37 = v49[0];
        BOOL v38 = os_log_type_enabled(v32, (os_log_type_t)v49[0]);
        if (v36)
        {
          if (v38)
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = v36;
            _os_log_impl( &dword_181A5C000,  v32,  v37,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v36);
LABEL_70:
          if (!v31) {
            goto LABEL_35;
          }
          goto LABEL_71;
        }

        if (v38)
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
          _os_log_impl( &dword_181A5C000,  v32,  v37,  "%{public}s called with null serviceConnector, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v32 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v42 = v49[0];
        if (os_log_type_enabled(v32, (os_log_type_t)v49[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
          _os_log_impl( &dword_181A5C000,  v32,  v42,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    goto LABEL_70;
  }

  unint64_t sequenceNumber = v6->sequenceNumber;
  unint64_t v9 = v4->sequenceNumber;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v10 = (os_log_s *)(id)gLogObj;
  BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
  if (sequenceNumber <= v9)
  {
    if (v11)
    {
      *(_DWORD *)__int128 buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_service_connector_handle_unsolicited_requests";
      *(_WORD *)&_BYTE buf[12] = 2114;
      *(void *)&buf[14] = v3;
      *(_WORD *)&_BYTE buf[22] = 2114;
      *(void *)&_BYTE buf[24] = v7;
      LOWORD(v5_Block_object_dispose((const void *)(v50 - 136), 8) = 2114;
      *(void *)((char *)&v58 + 2) = v4;
      _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ rejecting %{public}@ in favor of %{public}@",  buf,  0x2Au);
    }

    nw_service_connector_reject_incoming_request(v3, v7, 0);
    goto LABEL_11;
  }

  if (v11)
  {
    *(_DWORD *)__int128 buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_service_connector_handle_unsolicited_requests";
    *(_WORD *)&_BYTE buf[12] = 2114;
    *(void *)&buf[14] = v3;
    *(_WORD *)&_BYTE buf[22] = 2114;
    *(void *)&_BYTE buf[24] = v4;
    LOWORD(v5_Block_object_dispose((const void *)(v50 - 136), 8) = 2114;
    *(void *)((char *)&v58 + 2) = v7;
    _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ rejecting %{public}@ in favor of %{public}@",  buf,  0x2Au);
  }

  nw_service_connector_reject_incoming_request(v3, v4, 0);
LABEL_36:
}

void sub_1822AFAC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL29nwsc_process_incoming_requestP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke_188( uint64_t a1, int a2)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      uint64_t v6 = *(void *)(a1 + 48);
      int v7 = 136446978;
      uint64_t v8 = "nwsc_process_incoming_request_block_invoke";
      __int16 v9 = 2114;
      uint64_t v10 = v5;
      __int16 v11 = 2114;
      uint64_t v12 = v6;
      __int16 v13 = 1024;
      int v14 = a2;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ error when accepting request %{public}@ %{darwin.errno}d",  (uint8_t *)&v7,  0x26u);
    }

    nw_service_connector_cancel_request_inner( *(void **)(a1 + 32),  *(void **)(*(void *)(a1 + 48) + 8LL),  *(void *)(a1 + 48) + 24LL,  *(void **)(*(void *)(a1 + 48) + 576LL),  0);
    nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 32), *(void **)(a1 + 40), 0LL, 0LL, a2);
  }

  else
  {
    nw_service_connector_trigger_request_complete_block_inner( *(void **)(a1 + 32),  *(void **)(a1 + 40),  0LL,  *(void **)(*(void *)(a1 + 48) + 576LL),  0);
  }

void *nw_service_connector_copy_pending_incoming_request(void *a1, void *a2, uint64_t a3)
{
  uint64_t v79 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  id v6 = a2;
  int v7 = v6;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)os_log_type_t v52 = 136446210;
    *(void *)&uint8_t v52[4] = "nw_service_connector_copy_pending_incoming_request";
    BOOL v20 = (const char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)os_log_type_t v52 = 136446210;
        *(void *)&uint8_t v52[4] = "nw_service_connector_copy_pending_incoming_request";
        _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s called with null serviceConnector", v52, 0xCu);
      }

      goto LABEL_94;
    }

    if (type == OS_LOG_TYPE_DEFAULT)
    {
      __nwlog_obj();
      id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v38 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)os_log_type_t v52 = 136446210;
        *(void *)&uint8_t v52[4] = "nw_service_connector_copy_pending_incoming_request";
        _os_log_impl( &dword_181A5C000,  v21,  v38,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  v52,  0xCu);
      }

      goto LABEL_94;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v30 = buf[0];
    BOOL v31 = os_log_type_enabled(v21, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v31)
      {
        *(_DWORD *)os_log_type_t v52 = 136446210;
        *(void *)&uint8_t v52[4] = "nw_service_connector_copy_pending_incoming_request";
        _os_log_impl( &dword_181A5C000,  v21,  v30,  "%{public}s called with null serviceConnector, no backtrace",  v52,  0xCu);
      }

      goto LABEL_94;
    }

    if (v31)
    {
      *(_DWORD *)os_log_type_t v52 = 136446466;
      *(void *)&uint8_t v52[4] = "nw_service_connector_copy_pending_incoming_request";
      *(_WORD *)&v52[12] = 2082;
      *(void *)&v52[14] = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v21,  v30,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  v52,  0x16u);
    }

void sub_1822B0840(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL48nw_service_connector_handle_unsolicited_requestsP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke( uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v2 + 16) == 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v3 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      uint64_t v4 = *(void *)(a1 + 32);
      *(_DWORD *)__int128 buf = 136446466;
      os_log_type_t v22 = "nw_service_connector_handle_unsolicited_requests_block_invoke";
      __int16 v23 = 2114;
      uint64_t v24 = v4;
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ already cancelled, ignoring unsolicited request",  buf,  0x16u);
    }
  }

  else
  {
    uint64_t v5 = *(void *)(v2 + 64);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (os_log_s *)(id)gLogObj;
    BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
      if (v7)
      {
        uint64_t v8 = *(void *)(a1 + 32);
        uint64_t v9 = *(void *)(a1 + 40);
        uint64_t v10 = *(void *)(v9 + 8);
        *(_DWORD *)__int128 buf = 136447234;
        os_log_type_t v22 = "nw_service_connector_handle_unsolicited_requests_block_invoke";
        __int16 v23 = 2114;
        uint64_t v24 = v8;
        __int16 v25 = 2114;
        uint64_t v26 = v10;
        __int16 v27 = 2082;
        uint64_t v28 = v9 + 24;
        __int16 v29 = 2114;
        uint64_t v30 = v9;
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ calling client service available block with %{public}@ %{public}s for %{public}@",  buf,  0x34u);
      }

      (*(void (**)(void))(*(void *)(*(void *)(a1 + 32) + 64LL) + 16LL))();
    }

    else
    {
      if (v7)
      {
        uint64_t v11 = *(void *)(a1 + 32);
        uint64_t v12 = *(void *)(a1 + 40);
        *(_DWORD *)__int128 buf = 136446722;
        os_log_type_t v22 = "nw_service_connector_handle_unsolicited_requests_block_invoke";
        __int16 v23 = 2114;
        uint64_t v24 = v11;
        __int16 v25 = 2114;
        uint64_t v26 = v12;
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ no client service available block to call for %{public}@",  buf,  0x20u);
      }
    }

    objc_initWeak((id *)buf, *(id *)(a1 + 40));
    uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 600LL);
    if (v14)
    {
      nw_queue_cancel_source(v14, v13);
      *(void *)(*(void *)(a1 + 40) + 600LL) = 0LL;
    }

    v18[0] = MEMORY[0x1895F87A8];
    v18[1] = 3221225472LL;
    void v18[2] = ___ZL48nw_service_connector_handle_unsolicited_requestsP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke_192;
    v18[3] = &unk_189BC75C0;
    id v19 = *(id *)(a1 + 32);
    objc_copyWeak(&v20, (id *)buf);
    *(void *)(*(void *)(a1 + 40) + 600LL) = nw_queue_context_create_source(0LL, 2, 3, 0, v18, 0LL);
    uint64_t v15 = *(void *)(*(void *)(a1 + 40) + 600LL);
    dispatch_time_t v16 = dispatch_time(0x8000000000000000LL, 20000000000LL);
    nw_queue_set_timer_values(v15, v16, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    nw_queue_activate_source(*(void *)(*(void *)(a1 + 40) + 600LL), v17);
    objc_destroyWeak(&v20);

    objc_destroyWeak((id *)buf);
  }

void sub_1822B0B60( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

void ___ZL48nw_service_connector_handle_unsolicited_requestsP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke_192( uint64_t a1)
{
  uint64_t v2 = *(dispatch_queue_s **)(*(void *)(a1 + 32) + 32LL);
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 3221225472LL;
  v3[2] = ___ZL48nw_service_connector_handle_unsolicited_requestsP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke_2;
  v3[3] = &unk_189BC75C0;
  objc_copyWeak(&v5, (id *)(a1 + 40));
  id v4 = *(id *)(a1 + 32);
  dispatch_async(v2, v3);

  objc_destroyWeak(&v5);
}

void ___ZL48nw_service_connector_handle_unsolicited_requestsP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke_2( uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  WeakRetained = (NWConcrete_nw_unique_connection_request *)objc_loadWeakRetained((id *)(a1 + 40));
  unsigned int v3 = WeakRetained;
  if (WeakRetained)
  {
    if (*(_DWORD *)(*(void *)(a1 + 32) + 16LL) == 4)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v4 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        uint64_t v5 = *(void *)(a1 + 32);
        int v9 = 136446466;
        uint64_t v10 = "nw_service_connector_handle_unsolicited_requests_block_invoke_2";
        __int16 v11 = 2114;
        uint64_t v12 = v5;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ already cancelled, ignoring unsolicited request timeout",  (uint8_t *)&v9,  0x16u);
      }
    }

    else if ((*((_BYTE *)WeakRetained + 616) & 2) != 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = *(void *)(a1 + 32);
        endpoint = v3->endpoint;
        int v9 = 136447490;
        uint64_t v10 = "nw_service_connector_handle_unsolicited_requests_block_invoke";
        __int16 v11 = 2114;
        uint64_t v12 = v7;
        __int16 v13 = 2114;
        uint64_t v14 = endpoint;
        __int16 v15 = 2082;
        service = v3->service;
        __int16 v17 = 2048;
        uint64_t v18 = 20LL;
        __int16 v19 = 2114;
        id v20 = v3;
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ client did not react to service available block for %{public}@ %{public}s after %lld s, rejecting %{public}@",  (uint8_t *)&v9,  0x3Eu);
      }

      nw_service_connector_reject_incoming_request(*(NWConcrete_nw_service_connector **)(a1 + 32), v3, 1);
    }
  }
}

void sub_1822B0E1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL18nwsc_send_feedbackP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionybbU13block_pointerFviE_block_invoke( uint64_t a1, void *a2)
{
  uint64_t v51 = *MEMORY[0x1895F89C0];
  id v3 = a2;
  id v4 = v3;
  if (*(_DWORD *)(*(void *)(a1 + 32) + 16LL) == 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      id v6 = *(const char **)(a1 + 32);
      uint64_t v7 = *(void *)(a1 + 40);
      *(_DWORD *)__int128 buf = 136446722;
      char v42 = "nwsc_send_feedback_block_invoke";
      __int16 v43 = 2114;
      os_log_type_t v44 = v6;
      __int16 v45 = 2114;
      *(void *)__int16 v46 = v7;
      _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ already cancelled, ignoring connection %{public}@ send callback",  buf,  0x20u);
    }

    nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
    uint64_t v8 = *(void *)(a1 + 56);
    if (v8) {
      (*(void (**)(uint64_t, uint64_t))(v8 + 16))(v8, 22LL);
    }
    goto LABEL_30;
  }

  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v19 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = *(void *)(a1 + 64);
      if (*(_BYTE *)(a1 + 72)) {
        uint64_t v21 = "accept";
      }
      else {
        uint64_t v21 = "deny";
      }
      os_log_type_t v22 = *(const char **)(a1 + 32);
      uint64_t v23 = *(void *)(a1 + 40);
      *(_DWORD *)__int128 buf = 136447234;
      char v42 = "nwsc_send_feedback_block_invoke";
      __int16 v43 = 2114;
      os_log_type_t v44 = v22;
      __int16 v45 = 2082;
      *(void *)__int16 v46 = v21;
      *(_WORD *)&v46[8] = 2048;
      *(void *)&v46[10] = v20;
      __int16 v47 = 2114;
      uint64_t v48 = v23;
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ sent %{public}s feedback seq %llu on connection %{public}@",  buf,  0x34u);
    }

    uint64_t v10 = 0LL;
    goto LABEL_26;
  }

  int v9 = (unsigned int *)v3;
  uint64_t v10 = v9[3];

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v11 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    uint64_t v12 = *(void *)(a1 + 64);
    if (*(_BYTE *)(a1 + 72)) {
      __int16 v13 = "accept";
    }
    else {
      __int16 v13 = "deny";
    }
    uint64_t v14 = *(const char **)(a1 + 32);
    uint64_t v15 = *(void *)(a1 + 40);
    *(_DWORD *)__int128 buf = 136447490;
    char v42 = "nwsc_send_feedback_block_invoke";
    __int16 v43 = 2114;
    os_log_type_t v44 = v14;
    __int16 v45 = 2082;
    *(void *)__int16 v46 = v13;
    *(_WORD *)&v46[8] = 2048;
    *(void *)&v46[10] = v12;
    __int16 v47 = 2114;
    uint64_t v48 = v15;
    __int16 v49 = 1024;
    int v50 = v10;
    _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ failed to send %{public}s feedback seq %llu on %{public}@ %{darwin.errno}d",  buf,  0x3Au);
  }

  if ((v10 - 32) > 0x39 || ((1LL << (v10 - 32)) & 0x200000212420001LL) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v25 = (id)gLogObj;
    int v26 = *(unsigned __int8 *)(a1 + 72);
    *(_DWORD *)__int128 buf = 136446722;
    char v42 = "nwsc_send_feedback_block_invoke";
    if (v26) {
      __int16 v27 = "accept";
    }
    else {
      __int16 v27 = "deny";
    }
    __int16 v43 = 2082;
    os_log_type_t v44 = v27;
    __int16 v45 = 1024;
    *(_DWORD *)__int16 v46 = v10;
    uint64_t v28 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (__nwlog_fault(v28, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = type;
        if (os_log_type_enabled(v29, type))
        {
          if (*(_BYTE *)(a1 + 72)) {
            uint64_t v31 = "accept";
          }
          else {
            uint64_t v31 = "deny";
          }
          *(_DWORD *)__int128 buf = 136446722;
          char v42 = "nwsc_send_feedback_block_invoke";
          __int16 v43 = 2082;
          os_log_type_t v44 = v31;
          __int16 v45 = 1024;
          *(_DWORD *)__int16 v46 = v10;
          _os_log_impl( &dword_181A5C000,  v29,  v30,  "%{public}s Failed to send %{public}s feedback %{darwin.errno}d",  buf,  0x1Cu);
        }
      }

      else if (v39)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v33 = type;
        BOOL v34 = os_log_type_enabled(v29, type);
        if (backtrace_string)
        {
          if (v34)
          {
            if (*(_BYTE *)(a1 + 72)) {
              BOOL v35 = "accept";
            }
            else {
              BOOL v35 = "deny";
            }
            *(_DWORD *)__int128 buf = 136446978;
            char v42 = "nwsc_send_feedback_block_invoke";
            __int16 v43 = 2082;
            os_log_type_t v44 = v35;
            __int16 v45 = 1024;
            *(_DWORD *)__int16 v46 = v10;
            *(_WORD *)&v46[4] = 2082;
            *(void *)&v46[6] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v29,  v33,  "%{public}s Failed to send %{public}s feedback %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x26u);
          }

          free(backtrace_string);
          goto LABEL_62;
        }

        if (v34)
        {
          if (*(_BYTE *)(a1 + 72)) {
            os_log_type_t v38 = "accept";
          }
          else {
            os_log_type_t v38 = "deny";
          }
          *(_DWORD *)__int128 buf = 136446722;
          char v42 = "nwsc_send_feedback_block_invoke";
          __int16 v43 = 2082;
          os_log_type_t v44 = v38;
          __int16 v45 = 1024;
          *(_DWORD *)__int16 v46 = v10;
          _os_log_impl( &dword_181A5C000,  v29,  v33,  "%{public}s Failed to send %{public}s feedback %{darwin.errno}d, no backtrace",  buf,  0x1Cu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v36 = type;
        if (os_log_type_enabled(v29, type))
        {
          if (*(_BYTE *)(a1 + 72)) {
            BOOL v37 = "accept";
          }
          else {
            BOOL v37 = "deny";
          }
          *(_DWORD *)__int128 buf = 136446722;
          char v42 = "nwsc_send_feedback_block_invoke";
          __int16 v43 = 2082;
          os_log_type_t v44 = v37;
          __int16 v45 = 1024;
          *(_DWORD *)__int16 v46 = v10;
          _os_log_impl( &dword_181A5C000,  v29,  v36,  "%{public}s Failed to send %{public}s feedback %{darwin.errno}d, backtrace limit exceeded",  buf,  0x1Cu);
        }
      }
    }

void sub_1822B1500(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nwsc_drain_and_cancel_connection( NWConcrete_nw_service_connector *a1, NWConcrete_nw_connection *a2, char a3)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  id v6 = a2;
  uint64_t v7 = v6;
  if ((a3 & 1) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v8 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int128 buf = 136446722;
      __int16 v13 = "nwsc_drain_and_cancel_connection";
      __int16 v14 = 2114;
      uint64_t v15 = v5;
      __int16 v16 = 2114;
      int v17 = v7;
      _os_log_impl(&dword_181A5C000, v8, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ draining %{public}@", buf, 0x20u);
    }

    v9[0] = MEMORY[0x1895F87A8];
    v9[1] = 3221225472LL;
    v9[2] = ___ZL32nwsc_drain_and_cancel_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionb_block_invoke;
    v9[3] = &unk_189BC5F30;
    uint64_t v10 = v5;
    __int16 v11 = v7;
    nw_connection_receive_internal(v11, 0LL, 1u, 0xFFFFFFFF, v9);
  }

  else
  {
    nw_connection_cancel((nw_connection_t)v6);
  }
}

void sub_1822B1688( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZL32nwsc_drain_and_cancel_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionb_block_invoke( uint64_t a1, void *a2, uint64_t a3, int a4, void *a5)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  uint64_t v8 = a2;
  id v9 = a5;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v10 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *(void *)(a1 + 32);
    uint64_t v11 = *(void *)(a1 + 40);
    if (v8) {
      size_t size = dispatch_data_get_size(v8);
    }
    else {
      size_t size = 0LL;
    }
    __int16 v14 = "in";
    int v16 = 136447490;
    int v17 = "nwsc_drain_and_cancel_connection_block_invoke";
    uint64_t v19 = v12;
    __int16 v18 = 2114;
    if (a4) {
      __int16 v14 = "";
    }
    __int16 v20 = 2114;
    uint64_t v21 = v11;
    __int16 v22 = 2048;
    size_t v23 = size;
    __int16 v24 = 2082;
    id v25 = v14;
    __int16 v26 = 2114;
    id v27 = v9;
    _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ drained %{public}@ %zu bytes %{public}scomplete error %{public}@",  (uint8_t *)&v16,  0x3Eu);
  }

  if (v9) {
    char v15 = 0;
  }
  else {
    char v15 = a4 ^ 1;
  }
  nwsc_drain_and_cancel_connection( *(NWConcrete_nw_service_connector **)(a1 + 32),  *(NWConcrete_nw_connection **)(a1 + 40),  v15);
}

void sub_1822B1830(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL47nwsc_restart_outgoing_requests_waiting_for_pathP31NWConcrete_nw_service_connectorPU25objcproto14OS_nw_endpoint8NSObject_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  id v4 = a3;
  if ((char)v4[77] < 0 && nw_endpoint_is_equal(*(void **)(a1 + 32), v4[1], 0LL))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(a1 + 40);
      int v8 = 136446722;
      id v9 = "nwsc_restart_outgoing_requests_waiting_for_path_block_invoke";
      __int16 v10 = 2114;
      uint64_t v11 = v6;
      __int16 v12 = 2114;
      __int16 v13 = v4;
      _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ restarting connection for request %{public}@ due to external trigger",  (uint8_t *)&v8,  0x20u);
    }

    nwsc_request_create_and_start_connection_inner(*(void *)(a1 + 40), v4, 0LL);
  }

  return 1LL;
}

void sub_1822B197C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL46nwsc_request_create_and_start_connection_innerP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestPU25objcproto14OS_nw_endpoint8NSObject21nwsc_operation_code_e_block_invoke( int a1, nw_protocol_options_t options)
{
}

uint64_t ___ZL44nw_service_connector_get_new_sequence_numberv_block_invoke()
{
  mach_timebase_info info = 0LL;
  mach_timebase_info(&info);
  uint64_t v0 = mach_boottime_usec();
  uint64_t result = mach_continuous_time();
  nw_service_connector_get_new_sequence_number(void)::sNWSCSequenceNumber = v0
                                                                          + ((result * info.numer / (1000 * info.denom)) >> 1);
  return result;
}

void __nw_service_connector_start_block_invoke_93(int a1, nw_protocol_options_t options)
{
}

void nw_service_connector_use_large_uuid_for_testing(void *a1, char a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    uint64_t v5 = (dispatch_queue_s *)v3[4];
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __nw_service_connector_use_large_uuid_for_testing_block_invoke;
    block[3] = &unk_189BC5EB8;
    char v15 = v3;
    char v16 = a2;
    dispatch_async(v5, block);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  __int16 v20 = "nw_service_connector_use_large_uuid_for_testing";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v20 = "nw_service_connector_use_large_uuid_for_testing";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v20 = "nw_service_connector_use_large_uuid_for_testing";
          __int16 v21 = 2082;
          __int16 v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v20 = "nw_service_connector_use_large_uuid_for_testing";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v20 = "nw_service_connector_use_large_uuid_for_testing";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_service_connector_use_large_uuid_for_testing_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(void *)(result + 32) + 152LL) = *(_BYTE *)(*(void *)(result + 32) + 152LL) & 0xFE | *(_BYTE *)(result + 40);
  return result;
}

void nw_service_connector_fail_connection_after_verification_fails_for_testing(void *a1, char a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    uint64_t v5 = (dispatch_queue_s *)v3[4];
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __nw_service_connector_fail_connection_after_verification_fails_for_testing_block_invoke;
    block[3] = &unk_189BC5EB8;
    char v15 = v3;
    char v16 = a2;
    dispatch_async(v5, block);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  __int16 v20 = "nw_service_connector_fail_connection_after_verification_fails_for_testing";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v20 = "nw_service_connector_fail_connection_after_verification_fails_for_testing";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v20 = "nw_service_connector_fail_connection_after_verification_fails_for_testing";
          __int16 v21 = 2082;
          __int16 v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v20 = "nw_service_connector_fail_connection_after_verification_fails_for_testing";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v20 = "nw_service_connector_fail_connection_after_verification_fails_for_testing";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_service_connector_fail_connection_after_verification_fails_for_testing_block_invoke( uint64_t result)
{
  *(_BYTE *)(*(void *)(result + 32) + 152LL) = *(_BYTE *)(*(void *)(result + 32) + 152LL) & 0xFD | (2 * *(_BYTE *)(result + 40));
  return result;
}

void nw_service_connector_fail_connection_after_verification_passes_for_testing(void *a1, char a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    uint64_t v5 = (dispatch_queue_s *)v3[4];
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __nw_service_connector_fail_connection_after_verification_passes_for_testing_block_invoke;
    block[3] = &unk_189BC5EB8;
    char v15 = v3;
    char v16 = a2;
    dispatch_async(v5, block);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  __int16 v20 = "nw_service_connector_fail_connection_after_verification_passes_for_testing";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v20 = "nw_service_connector_fail_connection_after_verification_passes_for_testing";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v20 = "nw_service_connector_fail_connection_after_verification_passes_for_testing";
          __int16 v21 = 2082;
          __int16 v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v20 = "nw_service_connector_fail_connection_after_verification_passes_for_testing";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v20 = "nw_service_connector_fail_connection_after_verification_passes_for_testing";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_service_connector_fail_connection_after_verification_passes_for_testing_block_invoke( uint64_t result)
{
  *(_BYTE *)(*(void *)(result + 32) + 152LL) = *(_BYTE *)(*(void *)(result + 32) + 152LL) & 0xFB | (4 * *(_BYTE *)(result + 40));
  return result;
}

void nw_service_connector_cancel(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  BOOL v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = (dispatch_queue_s *)v1[4];
    block[0] = MEMORY[0x1895F87A8];
    block[1] = 3221225472LL;
    block[2] = __nw_service_connector_cancel_block_invoke;
    block[3] = &unk_189BC93A0;
    os_log_type_t v13 = v1;
    dispatch_async(v3, block);

    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  char v17 = "nw_service_connector_cancel";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v17 = "nw_service_connector_cancel";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          char v17 = "nw_service_connector_cancel";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v17 = "nw_service_connector_cancel";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v17 = "nw_service_connector_cancel";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __nw_service_connector_cancel_block_invoke(uint64_t a1)
{
  uint64_t v91 = *MEMORY[0x1895F89C0];
  int v2 = *(_DWORD *)(*(void *)(a1 + 32) + 16LL);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v3 = (os_log_s *)(id)gLogObj;
  id v4 = v3;
  if (v2 != 4)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(void *)(a1 + 32);
      *(_DWORD *)__int128 buf = 136446466;
      __int128 v86 = "nw_service_connector_cancel_block_invoke";
      __int16 v87 = 2114;
      uint64_t v88 = v10;
      _os_log_impl(&dword_181A5C000, v4, OS_LOG_TYPE_DEFAULT, "%{public}s Client cancelling %{public}@", buf, 0x16u);
    }

    uint64_t v12 = *(void *)(a1 + 32);
    uint64_t v13 = *(void *)(v12 + 56);
    if (v13)
    {
      nw_queue_cancel_source(v13, v11);
      *(void *)(*(void *)(a1 + 32) + 56LL) = 0LL;
      uint64_t v12 = *(void *)(a1 + 32);
    }

    *(_DWORD *)(v12 + 16) = 4;
    uint64_t v14 = *(void *)(a1 + 32);
    char v15 = *(nw_listener **)(v14 + 8);
    if (v15)
    {
      nw_listener_cancel(v15);
      uint64_t v16 = *(void *)(a1 + 32);
      char v17 = *(void **)(v16 + 8);
      *(void *)(v16 + _Block_object_dispose((const void *)(v50 - 136), 8) = 0LL;

      uint64_t v14 = *(void *)(a1 + 32);
    }

    __int16 v18 = *(void **)(v14 + 64);
    *(void *)(v14 + 64) = 0LL;

    uint64_t v19 = *(void **)(a1 + 32);
    uint64_t v20 = v19[11];
    uint64_t v21 = MEMORY[0x1895F87A8];
    if (v20)
    {
      v81[0] = MEMORY[0x1895F87A8];
      v81[1] = 3221225472LL;
      v81[2] = __nw_service_connector_cancel_block_invoke_101;
      v81[3] = &unk_189BC5058;
      __int128 v82 = v19;
      nw_dictionary_apply(v20, (uint64_t)v81);
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v23 = *(void **)(v22 + 88);
      *(void *)(v22 + 8_Block_object_dispose((const void *)(v50 - 136), 8) = 0LL;

      goto LABEL_15;
    }

    __nwlog_obj();
    char v39 = (void *)objc_claimAutoreleasedReturnValue();
    uint64_t v40 = *(void *)(a1 + 32);
    *(_DWORD *)__int128 buf = 136446466;
    __int128 v86 = "nw_service_connector_cancel_block_invoke_2";
    __int16 v87 = 2114;
    uint64_t v88 = v40;
    os_log_type_t v41 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v84 = OS_LOG_TYPE_ERROR;
    char v83 = 0;
    if (__nwlog_fault(v41, &v84, &v83))
    {
      if (v84 == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v43 = v84;
        if (os_log_type_enabled(v42, v84))
        {
          uint64_t v44 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446466;
          __int128 v86 = "nw_service_connector_cancel_block_invoke";
          __int16 v87 = 2114;
          uint64_t v88 = v44;
          _os_log_impl( &dword_181A5C000,  v42,  v43,  "%{public}s %{public}@ trying to apply NULL activeConnections",  buf,  0x16u);
        }
      }

      else if (v83)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v57 = v84;
        BOOL v58 = os_log_type_enabled(v42, v84);
        if (backtrace_string)
        {
          if (v58)
          {
            uint64_t v59 = *(void *)(a1 + 32);
            *(_DWORD *)__int128 buf = 136446722;
            __int128 v86 = "nw_service_connector_cancel_block_invoke";
            __int16 v87 = 2114;
            uint64_t v88 = v59;
            __int16 v89 = 2082;
            __int128 v90 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v42,  v57,  "%{public}s %{public}@ trying to apply NULL activeConnections, dumping backtrace:%{public}s",  buf,  0x20u);
          }

          free(backtrace_string);
          goto LABEL_76;
        }

        if (v58)
        {
          uint64_t v74 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446466;
          __int128 v86 = "nw_service_connector_cancel_block_invoke";
          __int16 v87 = 2114;
          uint64_t v88 = v74;
          _os_log_impl( &dword_181A5C000,  v42,  v57,  "%{public}s %{public}@ trying to apply NULL activeConnections, no backtrace",  buf,  0x16u);
        }
      }

      else
      {
        __nwlog_obj();
        char v42 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v68 = v84;
        if (os_log_type_enabled(v42, v84))
        {
          uint64_t v69 = *(void *)(a1 + 32);
          *(_DWORD *)__int128 buf = 136446466;
          __int128 v86 = "nw_service_connector_cancel_block_invoke";
          __int16 v87 = 2114;
          uint64_t v88 = v69;
          _os_log_impl( &dword_181A5C000,  v42,  v68,  "%{public}s %{public}@ trying to apply NULL activeConnections, backtrace limit exceeded",  buf,  0x16u);
        }
      }
    }

uint64_t __nw_service_connector_cancel_block_invoke_101( uint64_t a1, int a2, NWConcrete_nw_unique_connection *a3)
{
  return 1LL;
}

uint64_t __nw_service_connector_cancel_block_invoke_104(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  nw_service_connector_cancel_request_inner(*(void **)(a1 + 32), v4[1], (uint64_t)(v4 + 3), v4[72], 1);
  nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 32), v4, 0LL, 0LL, 89);

  return 1LL;
}

void sub_1822B32E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_service_connector_cancel_block_invoke_105( uint64_t a1, int a2, NWConcrete_nw_unique_connection_request *a3)
{
  return 1LL;
}

void nw_service_connector_start_request(void *a1, void *a2, const char *a3, void *a4, void *a5)
{
  v82[3] = *MEMORY[0x1895F89C0];
  uint64_t v9 = a1;
  id v10 = a2;
  id v68 = a4;
  id v11 = a5;
  uint64_t v12 = v11;
  if (!v9)
  {
    __nwlog_obj();
    uint64_t v44 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    id v78 = "nw_service_connector_start_request";
    __int16 v45 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v75 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v47 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v78 = "nw_service_connector_start_request";
        _os_log_impl(&dword_181A5C000, v46, v47, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v75)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v55 = type;
      BOOL v56 = os_log_type_enabled(v46, type);
      if (backtrace_string)
      {
        if (v56)
        {
          *(_DWORD *)__int128 buf = 136446466;
          id v78 = "nw_service_connector_start_request";
          __int16 v79 = 2082;
          size_t v80 = (size_t)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v46,  v55,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_136:
        if (!v45) {
          goto LABEL_70;
        }
LABEL_137:
        free(v45);
        goto LABEL_70;
      }

      if (v56)
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v78 = "nw_service_connector_start_request";
        _os_log_impl( &dword_181A5C000,  v46,  v55,  "%{public}s called with null serviceConnector, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v46 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v64 = type;
      if (os_log_type_enabled(v46, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v78 = "nw_service_connector_start_request";
        _os_log_impl( &dword_181A5C000,  v46,  v64,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_1822B4538( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void __nw_service_connector_start_request_block_invoke(uint64_t a1)
{
  uint64_t v138 = *MEMORY[0x1895F89C0];
  string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)(a1 + 32));
  uint64_t v3 = *(void *)(a1 + 48);
  int v4 = *(_DWORD *)(*(void *)(a1 + 40) + 16LL);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (os_log_s *)(id)gLogObj;
  uint64_t v6 = v5;
  if (v4 == 4)
  {
    BOOL v7 = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    if (v3)
    {
      if (v7)
      {
        uint64_t v9 = *(void *)(a1 + 48);
        uint64_t v8 = *(void *)(a1 + 56);
        uint64_t v10 = *(void *)(a1 + 40);
        LODWORD(buf[0]) = 136447234;
        *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
        WORD6(buf[0]) = 2114;
        *(void *)((char *)buf + 14) = v10;
        WORD3(buf[1]) = 2082;
        *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = string_ptr;
        LOWORD(buf[2]) = 2114;
        *(void *)((char *)&buf[2] + 2) = v8;
        WORD5(buf[2]) = 2114;
        *(void *)((char *)&buf[2] + 12) = v9;
        _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ already cancelled, ignoring client requesting service %{public}s to %{public}@ param eters %{public}@",  (uint8_t *)buf,  0x34u);
      }
    }

    else if (v7)
    {
      uint64_t v18 = *(void *)(a1 + 40);
      uint64_t v19 = *(void *)(a1 + 56);
      LODWORD(buf[0]) = 136446978;
      *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
      WORD6(buf[0]) = 2114;
      *(void *)((char *)buf + 14) = v18;
      WORD3(buf[1]) = 2082;
      *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = string_ptr;
      LOWORD(buf[2]) = 2114;
      *(void *)((char *)&buf[2] + 2) = v19;
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ already cancelled, ignoring client requesting service %{public}s to %{public}@",  (uint8_t *)buf,  0x2Au);
    }

    goto LABEL_141;
  }

  BOOL v11 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v11)
    {
      uint64_t v13 = *(void *)(a1 + 48);
      uint64_t v12 = *(void *)(a1 + 56);
      uint64_t v14 = *(void *)(a1 + 40);
      LODWORD(buf[0]) = 136447234;
      *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
      WORD6(buf[0]) = 2114;
      *(void *)((char *)buf + 14) = v14;
      WORD3(buf[1]) = 2082;
      *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = string_ptr;
      LOWORD(buf[2]) = 2114;
      *(void *)((char *)&buf[2] + 2) = v12;
      WORD5(buf[2]) = 2114;
      *(void *)((char *)&buf[2] + 12) = v13;
      size_t v15 = "%{public}s %{public}@ client requesting service %{public}s to %{public}@ parameters %{public}@";
      id v16 = v6;
      uint32_t v17 = 52;
LABEL_12:
      _os_log_impl(&dword_181A5C000, v16, OS_LOG_TYPE_DEFAULT, v15, (uint8_t *)buf, v17);
    }
  }

  else if (v11)
  {
    uint64_t v20 = *(void *)(a1 + 40);
    uint64_t v21 = *(void *)(a1 + 56);
    LODWORD(buf[0]) = 136446978;
    *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
    WORD6(buf[0]) = 2114;
    *(void *)((char *)buf + 14) = v20;
    WORD3(buf[1]) = 2082;
    *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = string_ptr;
    LOWORD(buf[2]) = 2114;
    *(void *)((char *)&buf[2] + 2) = v21;
    size_t v15 = "%{public}s %{public}@ client requesting service %{public}s to %{public}@";
    id v16 = v6;
    uint32_t v17 = 42;
    goto LABEL_12;
  }

  uint64_t v22 = (void **)nw_service_connector_copy_pending_incoming_request( *(void **)(a1 + 40),  *(void **)(a1 + 56),  (uint64_t)string_ptr);
  uint64_t v6 = (os_log_s *)v22;
  if (v22 && ((_BYTE)v22[77] & 4) == 0)
  {
    *((_BYTE *)v22 + 616) |= 4u;
    os_log_type_t v23 = *(void **)(a1 + 48);
    if (v23) {
      nw_service_connector_apply_user_parameters(*(void **)(a1 + 40), v22, v22[72], v23);
    }
    size_t v24 = *(void **)(a1 + 40);
    xpc_object_t v25 = (void *)*((void *)v6 + 72);
    v126[0] = MEMORY[0x1895F87A8];
    v126[1] = 3221225472LL;
    v126[2] = __nw_service_connector_start_request_block_invoke_106;
    v126[3] = &unk_189BBFCE8;
    __int128 v127 = v24;
    id v129 = *(id *)(a1 + 64);
    __int16 v26 = v6;
    __int128 v128 = v26;
    nw_service_connector_accept_connection_for_request(v127, v25, v26, v126);
    nw_service_connector_reject_incoming_request(*(NWConcrete_nw_service_connector **)(a1 + 40), v26, 0);

    uint64_t v27 = v127;
    goto LABEL_140;
  }

  uint64_t v28 = (NWConcrete_nw_unique_connection *)nw_service_connector_copy_active_connection_with_endpoint_and_service( *(void **)(a1 + 40),  *(void **)(a1 + 56),  (uint64_t)string_ptr);
  __int128 v125 = v28;
  if (v28)
  {
    connection = v28->connection;
    if (!connection) {
      goto LABEL_21;
    }
    BOOL v30 = connection;
    *(void *)os_log_type_t type = 0LL;
    *(void *)&os_log_type_t type[8] = type;
    *(void *)&os_log_type_t type[16] = 0x2020000000LL;
    LOBYTE(v133) = 0;
    uint64_t v31 = v30 + 34;
    *(void *)&buf[0] = MEMORY[0x1895F87A8];
    *((void *)&buf[0] + nw_tcp_options_set_enable_fast_open(options, 1) = 3221225472LL;
    *(void *)&buf[1] = __nw_connection_is_cancelled_or_failed_block_invoke;
    *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = &unk_189BC9210;
    *((void *)&buf[2] + nw_tcp_options_set_enable_fast_open(options, 1) = type;
    os_log_type_t v32 = v30;
    *(void *)&buf[2] = v32;
    os_unfair_lock_lock(v31);
    (*(void (**)(_OWORD *))&buf[1])(buf);
    os_unfair_lock_unlock(v31);
    int v33 = *(unsigned __int8 *)(*(void *)&type[8] + 24LL);

    _Block_object_dispose(type, 8);
    if (!v33)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v37 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      {
        uint64_t v38 = *(void *)(a1 + 40);
        LODWORD(buf[0]) = 136446722;
        *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
        WORD6(buf[0]) = 2114;
        *(void *)((char *)buf + 14) = v38;
        WORD3(buf[1]) = 2114;
        *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = v125;
        _os_log_impl( &dword_181A5C000,  v37,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ got request for already existing activeConnection %{public}@",  (uint8_t *)buf,  0x20u);
      }

      int v36 = 1;
    }

    else
    {
LABEL_21:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v34 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v35 = *(void *)(a1 + 40);
        LODWORD(buf[0]) = 136446722;
        *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
        WORD6(buf[0]) = 2114;
        *(void *)((char *)buf + 14) = v35;
        WORD3(buf[1]) = 2114;
        *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = v125;
        _os_log_impl( &dword_181A5C000,  v34,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ cleaning up dead activeConnection %{public}@",  (uint8_t *)buf,  0x20u);
      }

      nw_service_connector_cancel_request_inner( *(void **)(a1 + 40),  *(void **)(a1 + 56),  (uint64_t)string_ptr,  v125->connection,  0);
      int v36 = 0;
    }
  }

  else
  {
    int v36 = 0;
  }

  os_log_type_t v39 = nw_service_connector_copy_active_outgoing_request(*(void **)(a1 + 40), *(void **)(a1 + 56), (uint64_t)string_ptr);
  uint64_t v40 = v39;
  __int128 v124 = v39;
  if (v39)
  {
    os_log_type_t v41 = (void *)v39[72];
    if (!v41 || nw_connection_is_cancelled(v41))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v42 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v43 = *(void *)(a1 + 40);
        LODWORD(buf[0]) = 136446722;
        *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
        WORD6(buf[0]) = 2114;
        *(void *)((char *)buf + 14) = v43;
        WORD3(buf[1]) = 2114;
        *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = v40;
        _os_log_impl( &dword_181A5C000,  v42,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ cleaning up dead request %{public}@",  (uint8_t *)buf,  0x20u);
      }

      nw_service_connector_cancel_request_inner( *(void **)(a1 + 40),  *(void **)(a1 + 56),  (uint64_t)string_ptr,  *((void **)v124 + 72),  0);
      goto LABEL_34;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v65 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
    {
      uint64_t v66 = *(void *)(a1 + 40);
      LODWORD(buf[0]) = 136446722;
      *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
      WORD6(buf[0]) = 2114;
      *(void *)((char *)buf + 14) = v66;
      WORD3(buf[1]) = 2114;
      *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = v40;
      _os_log_impl( &dword_181A5C000,  v65,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ we already have active request %{public}@",  (uint8_t *)buf,  0x20u);
    }

    __int16 v45 = (char *)_Block_copy(*((const void **)v124 + 74));
    if (v45)
    {
      os_log_type_t v67 = _Block_copy(*(const void **)(a1 + 64));
      id v68 = (void *)*((void *)v124 + 74);
      *((void *)v124 + 74) = v67;

      nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 40), 0LL, v45, 0LL, 36);
LABEL_129:
      char v83 = v45;
      goto LABEL_139;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v73 = (id)gLogObj;
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
    id v74 = (char *)_os_log_send_and_compose_impl();

    type[0] = 16;
    os_log_type_t v131 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v74, type, &v131))
    {
      if (type[0] == 17)
      {
        __nwlog_obj();
        char v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v76 = type[0];
        if (os_log_type_enabled(v75, (os_log_type_t)type[0]))
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
          _os_log_impl( &dword_181A5C000,  v75,  v76,  "%{public}s Found an old request without a request completion block",  (uint8_t *)buf,  0xCu);
        }
      }

      else
      {
        if (v131)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          __int16 v79 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v80 = type[0];
          BOOL v81 = os_log_type_enabled(v79, (os_log_type_t)type[0]);
          if (backtrace_string)
          {
            if (v81)
            {
              LODWORD(buf[0]) = 136446466;
              *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
              WORD6(buf[0]) = 2082;
              *(void *)((char *)buf + 14) = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v79,  v80,  "%{public}s Found an old request without a request completion block, dumping backtrace:%{public}s",  (uint8_t *)buf,  0x16u);
            }

            free(backtrace_string);
          }

          else
          {
            if (v81)
            {
              LODWORD(buf[0]) = 136446210;
              *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
              _os_log_impl( &dword_181A5C000,  v79,  v80,  "%{public}s Found an old request without a request completion block, no backtrace",  (uint8_t *)buf,  0xCu);
            }
          }

          goto LABEL_99;
        }

        __nwlog_obj();
        char v75 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v84 = type[0];
        if (os_log_type_enabled(v75, (os_log_type_t)type[0]))
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
          _os_log_impl( &dword_181A5C000,  v75,  v84,  "%{public}s Found an old request without a request completion block, backtrace limit exceeded",  (uint8_t *)buf,  0xCu);
        }
      }
    }

void sub_1822B5D24( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void __nw_service_connector_start_request_block_invoke_106(uint64_t a1, int a2)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v4 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      uint64_t v6 = *(void *)(a1 + 40);
      int v7 = 136446978;
      uint64_t v8 = "nw_service_connector_start_request_block_invoke";
      __int16 v9 = 2114;
      uint64_t v10 = v5;
      __int16 v11 = 2114;
      uint64_t v12 = v6;
      __int16 v13 = 1024;
      int v14 = a2;
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ error when accepting request %{public}@ %{darwin.errno}d",  (uint8_t *)&v7,  0x26u);
    }

    nw_service_connector_cancel_request_inner( *(void **)(a1 + 32),  *(void **)(*(void *)(a1 + 40) + 8LL),  *(void *)(a1 + 40) + 24LL,  *(void **)(*(void *)(a1 + 40) + 576LL),  0);
    nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 32), 0LL, *(void **)(a1 + 48), 0LL, a2);
  }

  else
  {
    nw_service_connector_trigger_request_complete_block_inner( *(void **)(a1 + 32),  0LL,  *(void **)(a1 + 48),  *(void **)(*(void *)(a1 + 40) + 576LL),  0);
  }

void nwsc_schedule_prexisting_connection_retry( NWConcrete_nw_service_connector *a1, NWConcrete_nw_unique_connection_request *a2, NWConcrete_nw_unique_connection *a3, unsigned int a4)
{
  uint64_t v29 = *MEMORY[0x1895F89C0];
  int v7 = a1;
  uint64_t v8 = a2;
  uint64_t v10 = a3;
  if (a4 < 0x14)
  {
    uint64_t preexistingConnectionTimer = (uint64_t)v8->preexistingConnectionTimer;
    if (preexistingConnectionTimer)
    {
      nw_queue_cancel_source(preexistingConnectionTimer, v9);
      v8->uint64_t preexistingConnectionTimer = 0LL;
    }

    objc_initWeak((id *)buf, v8);
    v16[0] = MEMORY[0x1895F87A8];
    v16[1] = 3221225472LL;
    v16[2] = ___ZL41nwsc_schedule_prexisting_connection_retryP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestP31NWConcrete_nw_unique_connectionj_block_invoke;
    v16[3] = &unk_189BBFE90;
    uint32_t v17 = v7;
    objc_copyWeak(&v19, (id *)buf);
    uint64_t v18 = v10;
    unsigned int v20 = a4;
    BOOL source = nw_queue_context_create_source(0LL, 2, 3, 0, v16, 0LL);
    v8->uint64_t preexistingConnectionTimer = (void *)source;
    dispatch_time_t v14 = dispatch_time(0x8000000000000000LL, 100000000LL);
    nw_queue_set_timer_values(source, v14, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    nw_queue_activate_source((uint64_t)v8->preexistingConnectionTimer, v15);

    objc_destroyWeak(&v19);
    objc_destroyWeak((id *)buf);
  }

  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v11 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446978;
      uint64_t v22 = "nwsc_schedule_prexisting_connection_retry";
      __int16 v23 = 2114;
      size_t v24 = v7;
      __int16 v25 = 2114;
      __int16 v26 = v8;
      __int16 v27 = 2114;
      uint64_t v28 = v10;
      _os_log_impl( &dword_181A5C000,  v11,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ request %{public}@ still has existing activeConnection %{public}@",  buf,  0x2Au);
    }

    nw_service_connector_cancel_request_inner(v7, v8->endpoint, (uint64_t)v8->service, 0LL, 0);
    nw_service_connector_trigger_request_complete_block_inner(v7, v8, 0LL, 0LL, 17);
  }
}

void sub_1822B6198( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

void ___ZL41nwsc_schedule_prexisting_connection_retryP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestP31NWConcrete_nw_unique_connectionj_block_invoke( uint64_t a1)
{
  int v2 = *(dispatch_queue_s **)(*(void *)(a1 + 32) + 32LL);
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 3221225472LL;
  v3[2] = ___ZL41nwsc_schedule_prexisting_connection_retryP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestP31NWConcrete_nw_unique_connectionj_block_invoke_2;
  v3[3] = &unk_189BBFE90;
  objc_copyWeak(&v6, (id *)(a1 + 48));
  id v4 = *(id *)(a1 + 32);
  id v5 = *(id *)(a1 + 40);
  int v7 = *(_DWORD *)(a1 + 56);
  dispatch_async(v2, v3);

  objc_destroyWeak(&v6);
}

void ___ZL41nwsc_schedule_prexisting_connection_retryP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestP31NWConcrete_nw_unique_connectionj_block_invoke_2( uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1895F89C0];
  WeakRetained = (NWConcrete_nw_unique_connection_request *)objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v3 = WeakRetained;
  if (WeakRetained)
  {
    if (*(_DWORD *)(*(void *)(a1 + 32) + 16LL) == 4)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v4 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        uint64_t v5 = *(void *)(a1 + 32);
        *(_DWORD *)__int128 buf = 136446466;
        *(void *)&uint8_t buf[4] = "nwsc_schedule_prexisting_connection_retry_block_invoke_2";
        *(_WORD *)&_BYTE buf[12] = 2114;
        *(void *)&buf[14] = v5;
        _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ already cancelled, ignoring connection retry",  buf,  0x16u);
      }
    }

    else if ((*((_BYTE *)WeakRetained + 616) & 0x10) != 0)
    {
      id v6 = *(void **)(*(void *)(a1 + 40) + 488LL);
      if (!v6) {
        goto LABEL_9;
      }
      int v7 = v6;
      uint64_t v19 = 0LL;
      unsigned int v20 = &v19;
      uint64_t v21 = 0x2020000000LL;
      char v22 = 0;
      uint64_t v8 = v7 + 34;
      *(void *)__int128 buf = MEMORY[0x1895F87A8];
      *(void *)&uint8_t buf[8] = 3221225472LL;
      *(void *)&buf[16] = __nw_connection_is_cancelled_or_failed_block_invoke;
      size_t v24 = (NWConcrete_nw_unique_connection_request *)&unk_189BC9210;
      *((void *)&v25 + nw_tcp_options_set_enable_fast_open(options, 1) = &v19;
      uint64_t v9 = v7;
      *(void *)&__int128 v25 = v9;
      os_unfair_lock_lock(v8);
      __nw_connection_is_cancelled_or_failed_block_invoke((uint64_t)buf);
      os_unfair_lock_unlock(v8);
      LODWORD(v_Block_object_dispose((const void *)(v50 - 136), 8) = *((unsigned __int8 *)v20 + 24);

      _Block_object_dispose(&v19, 8);
      if (!(_DWORD)v8)
      {
        nwsc_schedule_prexisting_connection_retry( *(NWConcrete_nw_service_connector **)(a1 + 32),  v3,  *(NWConcrete_nw_unique_connection **)(a1 + 40),  *(_DWORD *)(a1 + 56) + 1);
      }

      else
      {
LABEL_9:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v10 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v11 = *(void *)(a1 + 32);
          uint64_t v12 = *(void *)(a1 + 40);
          *(_DWORD *)__int128 buf = 136446978;
          *(void *)&uint8_t buf[4] = "nwsc_schedule_prexisting_connection_retry_block_invoke";
          *(_WORD *)&_BYTE buf[12] = 2114;
          *(void *)&buf[14] = v11;
          *(_WORD *)&_BYTE buf[22] = 2114;
          size_t v24 = v3;
          LOWORD(v25) = 2114;
          *(void *)((char *)&v25 + 2) = v12;
          _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ restarting request %{public}@ with inactive activeConnection %{public}@",  buf,  0x2Au);
        }

        __int16 v13 = *(NWConcrete_nw_unique_connection **)(a1 + 40);
        connection = (nw_connection *)v13->connection;
        if (connection)
        {
          nw_connection_cancel(connection);
          uint64_t v15 = *(void *)(a1 + 40);
          id v16 = *(void **)(v15 + 488);
          *(void *)(v15 + 48_Block_object_dispose((const void *)(v50 - 136), 8) = 0LL;

          __int16 v13 = *(NWConcrete_nw_unique_connection **)(a1 + 40);
        }

        nw_service_connector_remove_active_connection(*(NWConcrete_nw_service_connector **)(a1 + 32), v13);
        *((_BYTE *)v3 + 616) &= ~0x10u;
        nwsc_request_create_and_start_connection_inner(*(void **)(a1 + 32), v3, 0LL);
        uint32_t v17 = (void *)objc_claimAutoreleasedReturnValue();
        BOOL v18 = v17 == 0LL;

        if (v18)
        {
          nw_service_connector_cancel_request_inner(*(void **)(a1 + 32), v3->endpoint, (uint64_t)v3->service, 0LL, 0);
          nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 32), v3, 0LL, 0LL, 12);
        }
      }
    }
  }
}

void sub_1822B6588(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_service_connector_cancel_request(void *a1, void *a2, const char *a3)
{
  v58[2] = *MEMORY[0x1895F89C0];
  uint64_t v5 = a1;
  id v6 = a2;
  int v7 = v6;
  if (!v5)
  {
    __nwlog_obj();
    uint64_t v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    unint64_t v54 = "nw_service_connector_cancel_request";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v51 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unint64_t v54 = "nw_service_connector_cancel_request";
        _os_log_impl(&dword_181A5C000, v30, v31, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v51)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v37 = type;
      BOOL v38 = os_log_type_enabled(v30, type);
      if (backtrace_string)
      {
        if (v38)
        {
          *(_DWORD *)__int128 buf = 136446466;
          unint64_t v54 = "nw_service_connector_cancel_request";
          __int16 v55 = 2082;
          size_t v56 = (size_t)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v30,  v37,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_35;
      }

      if (v38)
      {
        *(_DWORD *)__int128 buf = 136446210;
        unint64_t v54 = "nw_service_connector_cancel_request";
        _os_log_impl( &dword_181A5C000,  v30,  v37,  "%{public}s called with null serviceConnector, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v30 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v44 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unint64_t v54 = "nw_service_connector_cancel_request";
        _os_log_impl( &dword_181A5C000,  v30,  v44,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_1822B726C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_service_connector_cancel_request_block_invoke(xpc_object_t *a1)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  string_ptr = xpc_string_get_string_ptr(a1[4]);
  int v3 = *((_DWORD *)a1[5] + 4);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (os_log_s *)(id)gLogObj;
  uint64_t v5 = v4;
  if (v3 == 4)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      xpc_object_t v6 = a1[5];
      xpc_object_t v7 = a1[6];
      int v15 = 136446978;
      id v16 = "nw_service_connector_cancel_request_block_invoke";
      __int16 v17 = 2114;
      xpc_object_t v18 = v6;
      __int16 v19 = 2082;
      id v20 = (void *)string_ptr;
      __int16 v21 = 2114;
      xpc_object_t v22 = v7;
      _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ already cancelled, ignoring client cancelling service %{public}s to %{public}@",  (uint8_t *)&v15,  0x2Au);
    }
  }

  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      xpc_object_t v8 = a1[5];
      xpc_object_t v9 = a1[6];
      int v15 = 136446978;
      id v16 = "nw_service_connector_cancel_request_block_invoke";
      __int16 v17 = 2114;
      xpc_object_t v18 = v8;
      __int16 v19 = 2082;
      id v20 = (void *)string_ptr;
      __int16 v21 = 2114;
      xpc_object_t v22 = v9;
      _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ client cancelling request for service %{public}s to %{public}@",  (uint8_t *)&v15,  0x2Au);
    }

    uint64_t v5 = (os_log_s *)nw_service_connector_copy_pending_incoming_request(a1[5], a1[6], (uint64_t)string_ptr);
    if (v5)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        xpc_object_t v11 = a1[5];
        int v15 = 136446722;
        id v16 = "nw_service_connector_cancel_request_block_invoke";
        __int16 v17 = 2114;
        xpc_object_t v18 = v11;
        __int16 v19 = 2114;
        id v20 = v5;
        _os_log_impl( &dword_181A5C000,  v10,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ client cancel: rejecting incoming %{public}@",  (uint8_t *)&v15,  0x20u);
      }

      nw_service_connector_reject_incoming_request( (NWConcrete_nw_service_connector *)a1[5],  (NWConcrete_nw_unique_connection_request *)v5,  1);
    }

    os_log_type_t v12 = nw_service_connector_copy_active_outgoing_request(a1[5], a1[6], (uint64_t)string_ptr);
    nw_service_connector_cancel_request_inner(a1[5], a1[6], (uint64_t)string_ptr, 0LL, 0);
    if (v12)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v13 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        xpc_object_t v14 = a1[5];
        int v15 = 136446722;
        id v16 = "nw_service_connector_cancel_request_block_invoke";
        __int16 v17 = 2114;
        xpc_object_t v18 = v14;
        __int16 v19 = 2114;
        id v20 = v5;
        _os_log_impl( &dword_181A5C000,  v13,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ client cancel: cancelling outgoing %{public}@",  (uint8_t *)&v15,  0x20u);
      }

      nw_service_connector_trigger_request_complete_block_inner(a1[5], v12, 0LL, 0LL, 89);
    }
  }
}

void sub_1822B7584(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_service_connector_cancel_active_connection(void *a1, void *a2, const char *a3, void *a4)
{
  v81[2] = *MEMORY[0x1895F89C0];
  xpc_object_t v7 = a1;
  id v8 = a2;
  id v9 = a4;
  uint64_t v10 = v9;
  if (!v7)
  {
    __nwlog_obj();
    __int16 v55 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
    size_t v56 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v74 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v58 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
        _os_log_impl(&dword_181A5C000, v57, v58, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }

    else if (v74)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v62 = type;
      BOOL v63 = os_log_type_enabled(v57, type);
      if (backtrace_string)
      {
        if (v63)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
          __int16 v78 = 2082;
          size_t v79 = (size_t)backtrace_string;
          _os_log_impl( &dword_181A5C000,  v57,  v62,  "%{public}s called with null serviceConnector, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_136:
        if (!v56) {
          goto LABEL_79;
        }
LABEL_137:
        free(v56);
        goto LABEL_79;
      }

      if (v63)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
        _os_log_impl( &dword_181A5C000,  v57,  v62,  "%{public}s called with null serviceConnector, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v57 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v67 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
        _os_log_impl( &dword_181A5C000,  v57,  v67,  "%{public}s called with null serviceConnector, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_1822B87D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_service_connector_cancel_active_connection_block_invoke(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)(a1 + 32));
  int v3 = *(_DWORD **)(a1 + 40);
  if (v3[4] == 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id *)(id)gLogObj;
    if (os_log_type_enabled((os_log_t)v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(a1 + 40);
      uint64_t v6 = *(void *)(a1 + 48);
      *(_DWORD *)__int128 buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_service_connector_cancel_active_connection_block_invoke";
      *(_WORD *)&_BYTE buf[12] = 2114;
      *(void *)&buf[14] = v5;
      *(_WORD *)&_BYTE buf[22] = 2082;
      id v24 = string_ptr;
      *(_WORD *)__int128 v25 = 2114;
      *(void *)&v25[2] = v6;
      _os_log_impl( &dword_181A5C000,  (os_log_t)v4,  OS_LOG_TYPE_ERROR,  "%{public}s %{public}@ already cancelled, ignoring client cancelling active connection for service %{public}s to %{public}@",  buf,  0x2Au);
    }
  }

  else
  {
    id v4 = (id *)nw_service_connector_copy_active_connection_with_endpoint_and_service( v3,  *(void **)(a1 + 48),  (uint64_t)string_ptr);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    xpc_object_t v7 = (os_log_s *)(id)gLogObj;
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v4)
    {
      if (v8)
      {
        uint64_t v10 = *(void *)(a1 + 40);
        uint64_t v9 = *(void *)(a1 + 48);
        id v11 = "dead";
        id v12 = v4[61];
        if (v12)
        {
          size_t v13 = (os_unfair_lock_s *)v12;
          uint64_t v19 = 0LL;
          id v20 = &v19;
          uint64_t v21 = 0x2020000000LL;
          char v22 = 0;
          id v14 = v13 + 34;
          *(void *)__int128 buf = MEMORY[0x1895F87A8];
          *(void *)&uint8_t buf[8] = 3221225472LL;
          *(void *)&buf[16] = __nw_connection_is_cancelled_or_failed_block_invoke;
          id v24 = (const char *)&unk_189BC9210;
          *(void *)&v25[8] = &v19;
          int v15 = v13;
          *(void *)__int128 v25 = v15;
          os_unfair_lock_lock(v14);
          __nw_connection_is_cancelled_or_failed_block_invoke((uint64_t)buf);
          os_unfair_lock_unlock(v14);
          LODWORD(v14) = *((unsigned __int8 *)v20 + 24);

          _Block_object_dispose(&v19, 8);
          if (!(_DWORD)v14) {
            id v11 = "alive";
          }
        }

        *(_DWORD *)__int128 buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_service_connector_cancel_active_connection_block_invoke";
        *(_WORD *)&_BYTE buf[12] = 2114;
        *(void *)&buf[14] = v10;
        *(_WORD *)&_BYTE buf[22] = 2082;
        id v24 = string_ptr;
        *(_WORD *)__int128 v25 = 2114;
        *(void *)&v25[2] = v9;
        *(_WORD *)&v25[10] = 2082;
        *(void *)&v25[12] = v11;
        __int16 v26 = 2114;
        BOOL v27 = v4;
        _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ client cancelling active connection for service %{public}s to %{public}@: %{public}s activeConnection %{public}@",  buf,  0x3Eu);
      }

      nwsc_unique_connection_shutdown_socket( *(NWConcrete_nw_service_connector **)(a1 + 40),  (NWConcrete_nw_unique_connection *)v4);
      id v16 = v4[61];
    }

    else
    {
      if (v8)
      {
        uint64_t v17 = *(void *)(a1 + 40);
        uint64_t v18 = *(void *)(a1 + 48);
        *(_DWORD *)__int128 buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_service_connector_cancel_active_connection_block_invoke";
        *(_WORD *)&_BYTE buf[12] = 2114;
        *(void *)&buf[14] = v17;
        *(_WORD *)&_BYTE buf[22] = 2082;
        id v24 = string_ptr;
        *(_WORD *)__int128 v25 = 2114;
        *(void *)&v25[2] = v18;
        _os_log_impl( &dword_181A5C000,  v7,  OS_LOG_TYPE_DEFAULT,  "%{public}s %{public}@ client cancelling active connection for service %{public}s to %{public}@ but no active connection",  buf,  0x2Au);
      }

      id v16 = 0LL;
    }

    nw_service_connector_cancel_request_inner(*(void **)(a1 + 40), *(void **)(a1 + 48), (uint64_t)string_ptr, v16, 0);
    dispatch_async(*(dispatch_queue_t *)(*(void *)(a1 + 40) + 32LL), *(dispatch_block_t *)(a1 + 56));
  }
}

void sub_1822B8B4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void lsqpack_enc_cleanup(uint64_t a1)
{
  int v2 = *(void **)(a1 + 56);
  if (v2)
  {
    do
    {
      int v3 = (void *)v2[2];
      free(v2);
      int v2 = v3;
    }

    while (v3);
  }

  id v4 = *(void **)(a1 + 80);
  if (v4)
  {
    do
    {
      uint64_t v5 = (void *)*v4;
      free(v4);
      id v4 = v5;
    }

    while (v5);
  }

  free(*(void **)(a1 + 72));
  free(*(void **)(a1 + 216));
  uint64_t v6 = *(FILE **)(a1 + 200);
  if (v6)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v6);
    fwrite("cleaned up", 0xAuLL, 1uLL, *(FILE **)(a1 + 200));
    fputc(10, *(FILE **)(a1 + 200));
  }

unint64_t lsqpack_enc_enc_str( char a1, _BYTE *a2, unint64_t a3, unsigned __int8 *__src, size_t __n)
{
  xpc_object_t v7 = (char *)&__src[__n];
  if ((_DWORD)__n)
  {
    BOOL v8 = __src + 1;
    else {
      uint64_t v9 = (char *)&__src[__n];
    }
    int64_t v10 = v9 - (char *)__src;
    if ((unint64_t)(v9 - (char *)__src) >= 2)
    {
      int v13 = 0;
      int v14 = 0;
      unint64_t v15 = v10 & 0xFFFFFFFFFFFFFFFELL;
      unint64_t v16 = v10 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        uint64_t v17 = *(v8 - 1);
        unsigned int v18 = *v8;
        v8 += 2;
        v13 += encode_table[2 * v17 + 1];
        v14 += encode_table[2 * v18 + 1];
        v16 -= 2LL;
      }

      while (v16);
      unsigned int v11 = v14 + v13;
      if (v10 == v15) {
        goto LABEL_13;
      }
      id v12 = &__src[v15];
    }

    else
    {
      unsigned int v11 = 0;
      id v12 = __src;
    }

    do
    {
      unsigned int v19 = *v12++;
      v11 += encode_table[2 * v19 + 1];
    }

    while (v12 < (unsigned __int8 *)v7);
  }

  else
  {
    unsigned int v11 = 0;
  }

uint64_t lsqpack_enc_end_header(uint64_t a1, uint64_t a2)
{
  if ((*(_BYTE *)(a1 + 12) & 1) == 0) {
    return -1LL;
  }
  if (*(void *)(a1 + 216))
  {
    float v5 = *(float *)(a1 + 212);
    float v6 = (float)*(unsigned int *)(a1 + 144);
    if (v5 != 0.0) {
      float v6 = v5 + (float)(v6 - v5) * 0.4;
    }
    *(float *)(a1 + 212) = v6;
    xpc_object_t v7 = *(FILE **)(a1 + 200);
    if (v7)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v7);
      fprintf( *(FILE **)(a1 + 200),  "header count actual: %u; exponential moving average: %.3f",
        *(_DWORD *)(a1 + 144),
        *(float *)(a1 + 212));
      fputc(10, *(FILE **)(a1 + 200));
    }

    float v8 = *(float *)(a1 + 208);
    if (v8 != 0.0 && v8 > *(float *)(a1 + 212))
    {
      float v9 = vabds_f32((float)*(unsigned int *)(a1 + 228), v8);
    }
  }

  uint64_t v10 = *(void *)(a1 + 128);
  if (!v10 || !*(_DWORD *)(v10 + 60))
  {
    *(_WORD *)a2 = 0;
    unint64_t v15 = *(void *)(a1 + 128);
    unint64_t v16 = *(FILE **)(a1 + 200);
    if (v15)
    {
      if (v16)
      {
        fwrite("qenc: debug: ", 0xDuLL, 1uLL, v16);
        fprintf( *(FILE **)(a1 + 200),  "ended header for stream %llu; dynamic table not referenced",
          *(void *)(*(void *)(a1 + 128) + 40LL));
        fputc(10, *(FILE **)(a1 + 200));
        unint64_t v15 = *(void *)(a1 + 128);
      }

      uint64_t v17 = (void *)(a1 + 80);
      do
      {
        uint64_t v17 = (void *)*v17;
        if (!v17) {
          __assert_rtn("enc_free_hinfo", "lsqpack.c", 347, "0");
        }
      }

      while ((unint64_t)(v17 + 2) > v15 || (unint64_t)(v17 + 514) <= v15);
      unint64_t v19 = (v15 - (unint64_t)(v17 + 2)) >> 6;
      v17[1] &= ~(1LL << v19);
      unint64_t v20 = &v17[8 * (unint64_t)v19];
      uint64_t v21 = v20[2];
      int64x2_t v22 = (void *)v20[3];
      int v23 = v20 + 2;
      if (v21)
      {
        *(void *)(v21 + _Block_object_dispose((const void *)(v50 - 136), 8) = v22;
        int64x2_t v22 = (void *)v23[1];
      }

      else
      {
        *(void *)(a1 + 104) = v22;
      }

      *int64x2_t v22 = v21;
      *(void *)(a1 + 12_Block_object_dispose((const void *)(v50 - 136), 8) = 0LL;
    }

    else if (v16)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v16);
      fwrite("ended header; hinfo absent", 0x1AuLL, 1uLL, *(FILE **)(a1 + 200));
      fputc(10, *(FILE **)(a1 + 200));
    }

    *(_DWORD *)(a1 + 12) &= ~1u;
    int v27 = 2;
    uint64_t result = 2LL;
    goto LABEL_67;
  }

  *(_BYTE *)a2 = 0;
  uint64_t v11 = *(_DWORD *)(v10 + 60) % (2 * *(_DWORD *)(a1 + 28));
  int v12 = v11 + 1;
  int v13 = *(FILE **)(a1 + 200);
  if (v13)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v13);
    fprintf(*(FILE **)(a1 + 200), "LargestRef for stream %llu is encoded as %u", *(void *)(v10 + 40), v11 + 1);
    fputc(10, *(FILE **)(a1 + 200));
  }

  if (v11 > 0xFD)
  {
    *(_BYTE *)a2 = -1;
    unint64_t v24 = v11 - 254;
    if ((unint64_t)(v11 - 254) <= 0x7F)
    {
      *(_BYTE *)(a2 + nw_tcp_options_set_enable_fast_open(options, 1) = v11 + 2;
      unint64_t v14 = 2LL;
    }

    else
    {
      *(_BYTE *)(a2 + nw_tcp_options_set_enable_fast_open(options, 1) = (v11 + 2) | 0x80;
      if (v24 < 0x4000)
      {
        unint64_t v25 = v24 >> 7;
        unint64_t v14 = 3LL;
        uint64_t v26 = 2LL;
      }

      else
      {
        *(_BYTE *)(a2 + 2) = (v24 >> 7) | 0x80;
        if (v24 < 0x200000)
        {
          unint64_t v25 = v24 >> 14;
          unint64_t v14 = 4LL;
          uint64_t v26 = 3LL;
        }

        else
        {
          *(_BYTE *)(a2 + 3) = (v24 >> 14) | 0x80;
          unint64_t v25 = v24 >> 28;
          if (v24 >> 28)
          {
            *(_BYTE *)(a2 + 4) = (v24 >> 21) | 0x80;
            unint64_t v14 = 6LL;
            uint64_t v26 = 5LL;
          }

          else
          {
            unint64_t v25 = v24 >> 21;
            unint64_t v14 = 5LL;
            uint64_t v26 = 4LL;
          }
        }
      }

      *(_BYTE *)(a2 + v26) = v25;
    }
  }

  else
  {
    *(_BYTE *)a2 |= v12;
    unint64_t v14 = 1LL;
  }

  unint64_t v28 = (_BYTE *)(a2 + v14);
  unsigned int v29 = *(_DWORD *)(a1 + 156);
  unsigned int v30 = *(_DWORD *)(v10 + 60);
  BOOL v31 = v29 >= v30;
  unsigned int v32 = v29 - v30;
  char v33 = v29 < v30;
  LODWORD(v34) = v30 + ~v29;
  if (v31) {
    uint64_t v34 = v32;
  }
  else {
    uint64_t v34 = v34;
  }
  if (v31) {
    char v35 = 0;
  }
  else {
    char v35 = 0x80;
  }
  _BYTE *v28 = v33 << 7;
  if (v34 <= 0x7E)
  {
    _BYTE *v28 = v35 | v34;
    unint64_t v36 = (unint64_t)(v28 + 1);
LABEL_62:
    if (*(_DWORD *)(v10 + 60) > *(_DWORD *)(a1 + 4)) {
      qenc_add_to_risked_list(a1, (void *)v10);
    }
    unint64_t v42 = *(FILE **)(a1 + 200);
    if (v42)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v42);
      fprintf( *(FILE **)(a1 + 200),  "ended header for stream %llu; max ref: %u encoded as %u; risked: %d",
        *(void *)(v10 + 40),
        *(_DWORD *)(v10 + 60),
        v12,
        *(_DWORD *)(v10 + 60) > *(_DWORD *)(a1 + 4));
      fputc(10, *(FILE **)(a1 + 200));
    }

    *(void *)(a1 + 12_Block_object_dispose((const void *)(v50 - 136), 8) = 0LL;
    *(_DWORD *)(a1 + 12) &= ~1u;
    uint64_t result = v36 - a2;
    int v27 = v36 - a2;
LABEL_67:
    *(_DWORD *)(a1 + 196) += v27;
    return result;
  }

  _BYTE *v28 = v35 | 0x7F;
  unint64_t v37 = v34 - 127;
  if (v37 < 0x80)
  {
    unint64_t v41 = v14 + 1;
LABEL_61:
    unint64_t v36 = a2 + v14 + 2;
    *(_BYTE *)(a2 + v4nw_tcp_options_set_enable_fast_open(options, 1) = v37;
  }

  else
  {
    unint64_t v38 = v37;
    while (1)
    {
      unint64_t v39 = v14++;
      if (v14 > 0x15) {
        break;
      }
      *(_BYTE *)(a2 + 1 + v39) = v38 | 0x80;
      unint64_t v37 = v38 >> 7;
      unint64_t v40 = v38 >> 14;
      v38 >>= 7;
      if (!v40)
      {
        unint64_t v41 = v39 + 2;
        return 0LL;
      }
    }
  }

  return 0LL;
}

void qenc_hist_update_size(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 228) != a2)
  {
    if (!a2)
    {
      *(_DWORD *)(a1 + 232) = 0;
      *(void *)(a1 + 224) = 0LL;
      return;
    }

    id v4 = malloc(8LL * (a2 + 1));
    if (!v4) {
      return;
    }
    float v5 = v4;
    float v6 = *(FILE **)(a1 + 200);
    if (v6)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v6);
      fprintf(*(FILE **)(a1 + 200), "history size change from %u to %u", *(_DWORD *)(a1 + 228), a2);
      fputc(10, *(FILE **)(a1 + 200));
    }

    unsigned int v7 = *(_DWORD *)(a1 + 224);
    if (*(_DWORD *)(a1 + 232))
    {
      unsigned int v8 = v7 + 1;
      unsigned int v7 = *(_DWORD *)(a1 + 228);
      int v9 = v8 % v7;
      uint64_t v10 = *(void **)(a1 + 216);
    }

    else
    {
      int v9 = 0;
      uint64_t v10 = *(void **)(a1 + 216);
      if (!v7)
      {
        LODWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = 0;
LABEL_15:
        unsigned int v15 = v11 % a2;
        *(_DWORD *)(a1 + 224) = v15;
        *(_DWORD *)(a1 + 22_Block_object_dispose((const void *)(v50 - 136), 8) = a2;
        *(_DWORD *)(a1 + 232) = v15 == 0;
        free(v10);
        *(void *)(a1 + 216) = v5;
        return;
      }
    }

    unint64_t v11 = 0LL;
    unsigned int v12 = *(_DWORD *)(a1 + 228);
    unsigned int v13 = v7 - 1;
    do
    {
      int v14 = v11;
      v5[v11] = *((void *)v10 + (v9 + (int)v11) % v12);
      ++v11;
    }

    while (v13 != v14 && v11 < a2);
    goto LABEL_15;
  }

uint64_t qenc_add_to_risked_list(uint64_t result, void *a2)
{
  a2[2] = 0LL;
  int v2 = *(void **)(result + 120);
  a2[3] = v2;
  void *v2 = a2;
  *(void *)(result + 120) = a2 + 2;
  uint64_t v3 = *(void *)(result + 136);
  if (v3)
  {
    a2[4] = *(void *)(v3 + 32);
    *(void *)(v3 + 32) = a2;
  }

  else
  {
    uint64_t v4 = result;
    unsigned int v5 = *(_DWORD *)(result + 40) + 1;
    *(_DWORD *)(result + 40) = v5;
    float v6 = *(FILE **)(result + 200);
    if (v6)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v6);
      fprintf(*(FILE **)(v4 + 200), "streams at risk: %u", *(_DWORD *)(v4 + 40));
      uint64_t result = fputc(10, *(FILE **)(v4 + 200));
      unsigned int v5 = *(_DWORD *)(v4 + 40);
    }

    if (v5 > *(_DWORD *)(v4 + 36)) {
      __assert_rtn( "qenc_add_to_risked_list",  "lsqpack.c",  1156,  "enc->qpe_cur_streams_at_risk <= enc->qpe_max_risked_streams");
    }
  }

  return result;
}

uint64_t XXH_INLINE_XXH32(int *a1, unint64_t a2, int a3)
{
  if (!a1)
  {
    unsigned int v12 = a3 + 374761393;
    goto LABEL_12;
  }

  if (a2 < 0x10)
  {
    unsigned int v12 = a3 + 374761393 + a2;
    if (a2 < 4) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }

  unint64_t v3 = (unint64_t)a1 + a2 - 15;
  int v4 = a3 + 606290984;
  int v5 = a3 - 2048144777;
  int v6 = a3 + 1640531535;
  do
  {
    HIDWORD(v7) = v4 - 2048144777 * *a1;
    LODWORD(v7) = HIDWORD(v7);
    int v4 = -1640531535 * (v7 >> 19);
    HIDWORD(v7) = v5 - 2048144777 * a1[1];
    LODWORD(v7) = HIDWORD(v7);
    int v5 = -1640531535 * (v7 >> 19);
    HIDWORD(v7) = a3 - 2048144777 * a1[2];
    LODWORD(v7) = HIDWORD(v7);
    a3 = -1640531535 * (v7 >> 19);
    HIDWORD(v7) = v6 - 2048144777 * a1[3];
    LODWORD(v7) = HIDWORD(v7);
    int v6 = -1640531535 * (v7 >> 19);
    a1 += 4;
  }

  while ((unint64_t)a1 < v3);
  HIDWORD(v9) = v4;
  LODWORD(v9) = v4;
  int v8 = v9 >> 31;
  HIDWORD(v9) = v5;
  LODWORD(v9) = v5;
  int v10 = v9 >> 25;
  HIDWORD(v9) = a3;
  LODWORD(v9) = a3;
  int v11 = v9 >> 20;
  HIDWORD(v9) = v6;
  LODWORD(v9) = v6;
  unsigned int v12 = v8 + a2 + v10 + v11 + (v9 >> 14);
  a2 &= 0xFu;
  if (a2 >= 4)
  {
    do
    {
LABEL_9:
      int v13 = *a1++;
      HIDWORD(v14) = v12 - 1028477379 * v13;
      LODWORD(v14) = HIDWORD(v14);
      unsigned int v12 = 668265263 * (v14 >> 15);
      a2 -= 4LL;
    }

    while (a2 > 3);
  }

uint64_t qenc_has_or_can_evict_at_least(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (*(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 16));
  if (v2 >= a2) {
    return 1LL;
  }
  int v3 = *(_DWORD *)(a1 + 152);
  if ((v3 & 4) == 0)
  {
    int v4 = *(uint64_t **)(a1 + 96);
    if (v4)
    {
      unsigned int v5 = 0;
      do
      {
        unsigned int v6 = *((_DWORD *)v4 + 14);
        if (!v5 || (v6 ? (BOOL v7 = v6 >= v5) : (BOOL v7 = 1), !v7)) {
          unsigned int v5 = *((_DWORD *)v4 + 14);
        }
        int v4 = (uint64_t *)*v4;
      }

      while (v4);
    }

    else
    {
      unsigned int v5 = 0;
    }

    *(_DWORD *)(a1 + 14_Block_object_dispose((const void *)(v50 - 136), 8) = v5;
    *(_DWORD *)(a1 + 152) = v3 | 4;
    uint64_t v8 = *(void *)(a1 + 128);
    if (!v8) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }

  unsigned int v5 = *(_DWORD *)(a1 + 148);
  uint64_t v8 = *(void *)(a1 + 128);
  if (v8)
  {
LABEL_18:
    unsigned int v9 = *(_DWORD *)(v8 + 56);
    if (!v5 || (v9 ? (BOOL v10 = v9 >= v5) : (BOOL v10 = 1), !v10)) {
      unsigned int v5 = v9;
    }
  }

void *lsqpack_enc_push_entry( uint64_t a1, int a2, int a3, const void *a4, unsigned int a5, const void *a6, unsigned int a7)
{
  v48[2] = *MEMORY[0x1895F89C0];
  int v13 = *(_DWORD *)(a1 + 52);
  uint64_t v14 = 1LL << v13;
  if (*(_DWORD *)(a1 + 48) >= (1LL << v13) >> 1)
  {
    int v47 = v13 + 1;
    int v15 = malloc(32LL * (1 << (v13 + 1)));
    if (!v15) {
      return v15;
    }
    uint64_t v16 = 0LL;
    int v17 = (1 << (v13 + 1)) - 1;
    unsigned int v18 = *(void **)(a1 + 72);
    do
    {
      unint64_t v19 = &v15[4 * v16];
      unint64_t v20 = &v15[4 * (v14 + v16)];
      v48[0] = v19;
      v48[1] = v20;
      void *v19 = 0LL;
      v19[1] = v19;
      void *v20 = 0LL;
      v20[1] = v20;
      v19[2] = 0LL;
      v19[3] = v19 + 2;
      v20[2] = 0LL;
      v20[3] = v20 + 2;
      for (char i = &v18[4 * v16]; ; char i = &v18[4 * v16])
      {
        uint64_t v24 = *i;
        if (!*i) {
          break;
        }
        uint64_t v25 = *(void *)(v24 + 8);
        *char i = v25;
        if (!v25) {
          i[1] = (uint64_t)i;
        }
        unsigned int v22 = ((*(_DWORD *)(v24 + 44) & v17) >> v13) & 1;
        *(void *)(v24 + _Block_object_dispose((const void *)(v50 - 136), 8) = 0LL;
        uint64_t v23 = v48[v22];
        **(void **)(v23 + _Block_object_dispose((const void *)(v50 - 136), 8) = v24;
        *(void *)(v23 + _Block_object_dispose((const void *)(v50 - 136), 8) = v24 + 8;
        unsigned int v18 = *(void **)(a1 + 72);
      }

      while (1)
      {
        unint64_t v28 = (char *)&v18[4 * v16];
        BOOL v31 = (uint64_t *)*((void *)v28 + 2);
        unsigned int v30 = (uint64_t *)(v28 + 16);
        unsigned int v29 = v31;
        if (!v31) {
          break;
        }
        uint64_t v32 = *v29;
        uint64_t *v30 = *v29;
        if (!v32) {
          v18[4 * v16 + 3] = v30;
        }
        unsigned int v26 = (((_DWORD)v29[5] & v17) >> v13) & 1;
        *unsigned int v29 = 0LL;
        uint64_t v27 = v48[v26];
        **(void **)(v27 + 24) = v29;
        *(void *)(v27 + 24) = v29;
        unsigned int v18 = *(void **)(a1 + 72);
      }

      ++v16;
    }

    while (v16 != v14);
    free(v18);
    *(_DWORD *)(a1 + 52) = v47;
    *(void *)(a1 + 72) = v15;
  }

  else
  {
    int v47 = *(_DWORD *)(a1 + 52);
  }

  size_t v33 = a7;
  uint64_t v34 = malloc(a5 + (unint64_t)a7 + 56);
  int v15 = v34;
  if (v34)
  {
    v34[10] = a3;
    v34[11] = a2;
    v34[12] = a5;
    v34[13] = a7;
    unsigned int v45 = a7;
    int v35 = a2;
    int v36 = *(_DWORD *)(a1 + 16);
    int v37 = *(_DWORD *)(a1 + 32);
    v34[7] = v36;
    v34[8] = v37;
    int v38 = *(_DWORD *)a1 + 1;
    *(_DWORD *)a1 = v38;
    v34[6] = v38;
    unint64_t v39 = v34 + 14;
    memcpy(v34 + 14, a4, a5);
    memcpy((char *)v39 + a5, a6, v33);
    v15[2] = 0LL;
    **(void **)(a1 + 64) = v15;
    *(void *)(a1 + 64) = v15 + 2;
    void *v15 = 0LL;
    uint64_t v40 = 32LL * (a3 & ~(-1 << v47));
    **(void **)(*(void *)(a1 + 72) + v40 + 24) = v15;
    uint64_t v41 = *(void *)(a1 + 72);
    *(void *)(v41 + v40 + 24) = v15;
    v15[1] = 0LL;
    uint64_t v42 = 32LL * (v35 & ~(-1 << v47));
    **(void **)(v41 + v42 + _Block_object_dispose((const void *)(v50 - 136), 8) = v15;
    *(void *)(*(void *)(a1 + 72) + v42 + _Block_object_dispose((const void *)(v50 - 136), 8) = v15 + 1;
    *(_DWORD *)(a1 + 16) = a5 + v45 + v36 + 32;
    ++*(_DWORD *)(a1 + 48);
    os_log_type_t v43 = *(FILE **)(a1 + 200);
    if (v43)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v43);
        *((_DWORD *)v15 + 6),
        *((_DWORD *)v15 + 12),
        (const char *)v15 + 56,
        *((_DWORD *)v15 + 13),
        (const char *)v15 + *((unsigned int *)v15 + 12) + 56,
        *(_DWORD *)(a1 + 48),
        *(_DWORD *)(a1 + 16));
      fputc(10, *(FILE **)(a1 + 200));
    }
  }

  return v15;
}

void qenc_remove_overflow_entries(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 16);
  unsigned int v3 = *(_DWORD *)(a1 + 20);
  unsigned int v4 = v3;
  if (v2 > v3)
  {
    unsigned int v5 = (void **)(a1 + 56);
    do
    {
      BOOL v7 = (char *)*v5;
      if (!*v5) {
        __assert_rtn("qenc_drop_oldest_entry", "lsqpack.c", 852, "entry");
      }
      uint64_t v8 = *(FILE **)(a1 + 200);
      unsigned int v9 = *v5;
      if (v8)
      {
        fwrite("qenc: debug: ", 0xDuLL, 1uLL, v8);
          *((_DWORD *)v7 + 6),
          *((_DWORD *)v7 + 12),
          v7 + 56,
          *((_DWORD *)v7 + 13),
          &v7[*((unsigned int *)v7 + 12) + 56],
          *(_DWORD *)(a1 + 48) - 1,
          *(_DWORD *)(a1 + 16) - (*((_DWORD *)v7 + 12) + *((_DWORD *)v7 + 13)) - 32);
        fputc(10, *(FILE **)(a1 + 200));
        unsigned int v9 = *(void **)(a1 + 56);
      }

      BOOL v10 = (void *)v9[2];
      void *v5 = v10;
      if (!v10) {
        *(void *)(a1 + 64) = v5;
      }
      int v11 = -1 << *(_DWORD *)(a1 + 52);
      uint64_t v12 = *((_DWORD *)v7 + 10) & ~v11;
      uint64_t v13 = *(void *)(a1 + 72);
      uint64_t v14 = v13 + 32 * v12;
      uint64_t v16 = *(char **)(v14 + 16);
      int v15 = (void *)(v14 + 16);
      if (v7 != v16) {
        __assert_rtn( "qenc_drop_oldest_entry",  "lsqpack.c",  859,  "entry == STAILQ_FIRST(&enc->qpe_buckets[buckno].by_nameval)");
      }
      uint64_t v17 = *(void *)v7;
      void *v15 = *(void *)v7;
      if (!v17) {
        *(void *)(v13 + 32 * v12 + 24) = v15;
      }
      unsigned int v18 = (void **)(v13 + 32LL * (*((_DWORD *)v7 + 11) & ~v11));
      if (v7 != *v18) {
        __assert_rtn( "qenc_drop_oldest_entry",  "lsqpack.c",  862,  "entry == STAILQ_FIRST(&enc->qpe_buckets[buckno].by_name)");
      }
      unint64_t v19 = (void *)*((void *)v7 + 1);
      void *v18 = v19;
      if (!v19) {
        v18[1] = v18;
      }
      int v6 = *((_DWORD *)v7 + 12) + *((_DWORD *)v7 + 13) + 32;
      *(_DWORD *)(a1 + 32) += v6;
      *(_DWORD *)(a1 + 16) -= v6;
      --*(_DWORD *)(a1 + 48);
      free(v7);
      unsigned int v4 = *(_DWORD *)(a1 + 20);
    }

    while (*(_DWORD *)(a1 + 16) > v4);
  }

  unint64_t v20 = *(FILE **)(a1 + 200);
  if (v4) {
    BOOL v21 = v20 == 0LL;
  }
  else {
    BOOL v21 = 1;
  }
  if (!v21)
  {
    int v22 = *(_DWORD *)(a1 + 12);
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v20);
    unsigned int v24 = *(_DWORD *)(a1 + 16);
    unsigned int v23 = *(_DWORD *)(a1 + 20);
    float v25 = (float)v23;
    float v26 = (float)v24 / (float)v23;
    double v27 = v26;
    if ((v22 & 2) != 0)
    {
      if (!v23) {
        __assert_rtn("qenc_effective_fill", "lsqpack.c", 878, "enc->qpe_cur_max_capacity");
      }
      uint64_t v28 = *(void *)(a1 + 56);
      unsigned int v39 = v2;
      int v38 = *(FILE **)(a1 + 200);
      if (v28 && (uint64_t v29 = *(void *)(v28 + 16)) != 0)
      {
        int v30 = 0;
        do
        {
          BOOL v31 = (_DWORD *)v28;
          uint64_t v28 = v29;
          int v32 = v31[12];
          uint64_t v33 = v29;
          while (1)
          {
            if (*(_DWORD *)(v33 + 48) == v32)
            {
              int v34 = *(_DWORD *)(v33 + 52);
            }

            uint64_t v33 = *(void *)(v33 + 16);
            if (!v33) {
              goto LABEL_25;
            }
          }

          v30 += v32 + v34 + 32;
LABEL_25:
          uint64_t v29 = *(void *)(v28 + 16);
        }

        while (v29);
      }

      else
      {
        int v30 = 0;
      }

      fprintf(v38, "fill: %.2f; effective fill: %.2f", v27, (float)((float)(v24 - v30) / v25));
      unsigned int v2 = v39;
    }

    else
    {
      fprintf(*(FILE **)(a1 + 200), "fill: %.2f", v26);
    }

    fputc(10, *(FILE **)(a1 + 200));
  }

  if (v2 > v3 && *(void *)(a1 + 216))
  {
    float v35 = *(float *)(a1 + 208);
    float v36 = (float)*(unsigned int *)(a1 + 48);
    if (v35 != 0.0) {
      float v36 = v35 + (float)(v36 - v35) * 0.4;
    }
    *(float *)(a1 + 20_Block_object_dispose((const void *)(v50 - 136), 8) = v36;
    int v37 = *(FILE **)(a1 + 200);
    if (v37)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v37);
      fprintf( *(FILE **)(a1 + 200),  "table size actual: %u; exponential moving average: %.3f",
        *(_DWORD *)(a1 + 48),
        *(float *)(a1 + 208));
      fputc(10, *(FILE **)(a1 + 200));
    }
  }

uint64_t enc_proc_stream_cancel(uint64_t a1, unint64_t a2)
{
  unsigned int v4 = *(FILE **)(a1 + 200);
  if (v4)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v4);
    fprintf(*(FILE **)(a1 + 200), "got Cancel Stream instruction; stream=%llu", a2);
    fputc(10, *(FILE **)(a1 + 200));
  }

  if (!(a2 >> 62))
  {
    unint64_t v7 = *(void *)(a1 + 96);
    if (v7)
    {
      int v8 = 0;
      do
      {
        unint64_t v9 = *(void *)v7;
        if (*(void *)(v7 + 40) == a2)
        {
          BOOL v10 = *(FILE **)(a1 + 200);
          if (v10)
          {
            fwrite("qenc: debug: ", 0xDuLL, 1uLL, v10);
            fprintf(*(FILE **)(a1 + 200), "cancel header block for stream %llu, seqno %u", a2, *(_DWORD *)(v7 + 48));
            fputc(10, *(FILE **)(a1 + 200));
          }

          if (*(_DWORD *)(v7 + 60) > *(_DWORD *)(a1 + 4)) {
            qenc_remove_from_risked_list(a1, (void *)v7);
          }
          int v11 = (void *)(a1 + 80);
          do
          {
            int v11 = (void *)*v11;
            if (!v11) {
              __assert_rtn("enc_free_hinfo", "lsqpack.c", 347, "0");
            }
          }

          while ((unint64_t)(v11 + 2) > v7 || (unint64_t)(v11 + 514) <= v7);
          unint64_t v13 = (v7 - (unint64_t)(v11 + 2)) >> 6;
          v11[1] &= ~(1LL << v13);
          uint64_t v14 = &v11[8 * (unint64_t)v13];
          uint64_t v15 = v14[2];
          uint64_t v16 = (void *)v14[3];
          uint64_t v17 = v14 + 2;
          if (v15)
          {
            *(void *)(v15 + _Block_object_dispose((const void *)(v50 - 136), 8) = v16;
            uint64_t v16 = (void *)v17[1];
          }

          else
          {
            *(void *)(a1 + 104) = v16;
          }

          *uint64_t v16 = v15;
          ++v8;
        }

        unint64_t v7 = v9;
      }

      while (v9);
    }

    else
    {
      int v8 = 0;
    }

    unsigned int v18 = *(FILE **)(a1 + 200);
    if (!v18) {
      return 0LL;
    }
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v18);
    fprintf(*(FILE **)(a1 + 200), "cancelled %u header block%.*s of stream %llu", v8, v8 != 1, "s", a2);
    uint64_t v6 = 0LL;
    goto LABEL_29;
  }

  unsigned int v5 = *(FILE **)(a1 + 200);
  if (v5)
  {
    fwrite("qenc: info: ", 0xCuLL, 1uLL, v5);
    fprintf(*(FILE **)(a1 + 200), "Invalid stream ID %llu in Cancel Stream", a2);
    uint64_t v6 = 0xFFFFFFFFLL;
LABEL_29:
    fputc(10, *(FILE **)(a1 + 200));
    return v6;
  }

  return 0xFFFFFFFFLL;
}

uint64_t enc_proc_header_ack(uint64_t a1, unint64_t a2)
{
  unsigned int v4 = *(FILE **)(a1 + 200);
  if (v4)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v4);
    fprintf(*(FILE **)(a1 + 200), "got Header Ack instruction, stream=%llu", a2);
    fputc(10, *(FILE **)(a1 + 200));
  }

  if (!(a2 >> 62))
  {
    unint64_t v6 = a1 + 96;
    while (1)
    {
      unint64_t v6 = *(void *)v6;
      if (!v6) {
        break;
      }
      if (*(void *)(v6 + 40) == a2)
      {
        if (*(_DWORD *)(v6 + 60) > *(_DWORD *)(a1 + 4))
        {
          qenc_remove_from_risked_list(a1, (void *)v6);
          *(_DWORD *)(a1 + 4) = *(_DWORD *)(v6 + 60);
          uint64_t v7 = *(void *)(a1 + 112);
          if (v7)
          {
            do
            {
              uint64_t v16 = *(void *)(v7 + 16);
              if (*(_DWORD *)(v7 + 60) <= *(_DWORD *)(a1 + 4)) {
                qenc_remove_from_risked_list(a1, (void *)v7);
              }
              uint64_t v7 = v16;
            }

            while (v16);
          }

          int v8 = *(FILE **)(a1 + 200);
          if (v8)
          {
            fwrite("qenc: debug: ", 0xDuLL, 1uLL, v8);
            fprintf(*(FILE **)(a1 + 200), "max acked ID is now %u", *(_DWORD *)(a1 + 4));
            fputc(10, *(FILE **)(a1 + 200));
          }
        }

        unint64_t v9 = (void *)(a1 + 80);
        do
        {
          unint64_t v9 = (void *)*v9;
          if (!v9) {
            __assert_rtn("enc_free_hinfo", "lsqpack.c", 347, "0");
          }
          BOOL v10 = v9 + 2;
        }

        while ((unint64_t)(v9 + 2) > v6 || (unint64_t)(v9 + 514) <= v6);
        v9[1] &= ~(1LL << ((v6 - (unint64_t)v10) >> 6));
        uint64_t v12 = &v9[8 * (unint64_t)((v6 - (unint64_t)v10) >> 6)];
        uint64_t v13 = v12[2];
        uint64_t v14 = (void *)v12[3];
        uint64_t v15 = v12 + 2;
        if (v13)
        {
          *(void *)(v13 + _Block_object_dispose((const void *)(v50 - 136), 8) = v14;
          uint64_t v14 = (void *)v15[1];
        }

        else
        {
          *(void *)(a1 + 104) = v14;
        }

        uint64_t result = 0LL;
        *uint64_t v14 = v13;
        return result;
      }
    }
  }

  return 0xFFFFFFFFLL;
}

uint64_t enc_proc_ici(uint64_t a1, unint64_t a2)
{
  unsigned int v4 = *(FILE **)(a1 + 200);
  if (v4)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v4);
    fprintf(*(FILE **)(a1 + 200), "got ICI instruction, count=%llu", a2);
    fputc(10, *(FILE **)(a1 + 200));
  }

  if (!a2)
  {
    unint64_t v6 = *(FILE **)(a1 + 200);
    if (v6)
    {
      fwrite("qenc: info: ", 0xCuLL, 1uLL, v6);
      fwrite("ICI=0 is an error", 0x11uLL, 1uLL, *(FILE **)(a1 + 200));
      goto LABEL_12;
    }

    return 0xFFFFFFFFLL;
  }

  if (HIDWORD(a2))
  {
    unsigned int v5 = *(FILE **)(a1 + 200);
    if (v5)
    {
      fwrite("qenc: info: ", 0xCuLL, 1uLL, v5);
      fprintf(*(FILE **)(a1 + 200), "insertion count too high: %llu");
LABEL_12:
      uint64_t v9 = 0xFFFFFFFFLL;
LABEL_13:
      fputc(10, *(FILE **)(a1 + 200));
      return v9;
    }

    return 0xFFFFFFFFLL;
  }

  unsigned int v7 = *(_DWORD *)(a1 + 8) + a2;
  if (v7 > *(_DWORD *)a1)
  {
    int v8 = *(FILE **)(a1 + 200);
    if (v8)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v8);
      fprintf(*(FILE **)(a1 + 200), "ICI: max_acked %u is larger than number of inserts %u");
      goto LABEL_12;
    }

    return 0xFFFFFFFFLL;
  }

  if (v7 <= *(_DWORD *)(a1 + 4))
  {
    uint64_t v13 = *(FILE **)(a1 + 200);
    if (v13)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v13);
      fprintf(*(FILE **)(a1 + 200), "duplicate ICI: %u", v7);
      uint64_t v9 = 0LL;
      goto LABEL_13;
    }

    return 0LL;
  }

  *(_DWORD *)(a1 + 4) = v7;
  *(_DWORD *)(a1 + _Block_object_dispose((const void *)(v50 - 136), 8) = v7;
  int v11 = *(FILE **)(a1 + 200);
  if (v11)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v11);
    fprintf(*(FILE **)(a1 + 200), "max acked ID is now %u", *(_DWORD *)(a1 + 4));
    fputc(10, *(FILE **)(a1 + 200));
  }

  uint64_t v12 = *(void *)(a1 + 112);
  if (!v12) {
    return 0LL;
  }
  do
  {
    uint64_t v9 = *(void *)(v12 + 16);
    if (*(_DWORD *)(v12 + 60) <= *(_DWORD *)(a1 + 4)) {
      qenc_remove_from_risked_list(a1, (void *)v12);
    }
    uint64_t v12 = v9;
  }

  while (v9);
  return v9;
}

uint64_t qenc_remove_from_risked_list(uint64_t result, void *a2)
{
  uint64_t v2 = result;
  if (*(void *)(result + 112))
  {
    uint64_t v3 = a2[2];
    unsigned int v4 = (void *)a2[3];
    if (v3)
    {
      *(void *)(v3 + 24) = v4;
      unsigned int v4 = (void *)a2[3];
    }

    else
    {
      *(void *)(result + 120) = v4;
    }

    *unsigned int v4 = v3;
    unsigned int v5 = (void *)a2[4];
    if (v5 == a2)
    {
      int v8 = *(_DWORD *)(result + 40);
      if (!v8) {
        __assert_rtn("qenc_remove_from_risked_list", "lsqpack.c", 1174, "enc->qpe_cur_streams_at_risk > 0");
      }
      *(_DWORD *)(result + 40) = v8 - 1;
      uint64_t v9 = *(FILE **)(result + 200);
      if (v9)
      {
        fwrite("qenc: debug: ", 0xDuLL, 1uLL, v9);
        fprintf(*(FILE **)(v2 + 200), "streams at risk: %u", *(_DWORD *)(v2 + 40));
        return fputc(10, *(FILE **)(v2 + 200));
      }
    }

    else
    {
      unint64_t v6 = (void *)a2[4];
      do
      {
        unsigned int v7 = v6;
        unint64_t v6 = (void *)v6[4];
      }

      while (v6 != a2);
      v7[4] = v5;
      a2[4] = a2;
    }
  }

  else if (*(_DWORD *)(result + 40))
  {
    __assert_rtn("qenc_remove_from_risked_list", "lsqpack.c", 1168, "enc->qpe_cur_streams_at_risk == 0");
  }

  return result;
}

void lsqpack_dec_cleanup(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 80);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      free(v2);
      uint64_t v2 = v3;
    }

    while (v3);
  }

  int v4 = *(_DWORD *)(a1 + 232);
  if ((v4 - 1) > 4)
  {
    unsigned int v5 = *(_DWORD **)(a1 + 280);
    if (!v5) {
      goto LABEL_9;
    }
  }

  else
  {
    unsigned int v5 = *(_DWORD **)(a1 + 288);
    if (!v5) {
      goto LABEL_9;
    }
  }

uint64_t lsqpack_huff_decode_full(_BYTE *a1, int a2, _BYTE *a3, uint64_t a4, uint64_t a5, int a6)
{
  if ((_DWORD)a4)
  {
    int v6 = &a3[(int)a4];
    unsigned int v7 = a1;
    int v8 = a3;
    switch(*(_DWORD *)a5)
    {
      case 0:
        *(_WORD *)(a5 + 4) = 256;
        unsigned int v7 = a1;
        int v8 = a3;
        goto LABEL_6;
      case 1:
        goto LABEL_6;
      case 2:
        goto LABEL_8;
      case 3:
        unsigned int v10 = *(unsigned __int8 *)(a5 + 4);
        unsigned int v7 = a1;
        int v8 = a3;
        break;
      default:
        goto LABEL_20;
    }

    while (1)
    {
      uint64_t v13 = (char *)&decode_tables + 48 * v10 + 3 * (*v7 & 0xF);
      char v14 = v13[1];
      if ((v14 & 4) != 0)
      {
LABEL_19:
        a4 = 0LL;
        uint64_t v9 = 3LL;
        return v9 | (a4 << 32);
      }

      char v15 = *v13;
      if ((v13[1] & 2) != 0)
      {
        *v8++ = v13[2];
        *(_BYTE *)(a5 + 4) = v15;
        *(_BYTE *)(a5 + 5) = v14 & 1;
        ++v7;
      }

      else
      {
        *(_BYTE *)(a5 + 4) = v15;
        *(_BYTE *)(a5 + 5) = v14 & 1;
        if (!v8) {
          goto LABEL_19;
        }
        ++v7;
      }

uint64_t qdec_header_process(uint64_t a1, void *a2, void *a3, uint64_t a4, _BYTE *a5, uint64_t *a6)
{
  uint64_t v9 = a2;
  a2[14] = *a3;
  a2[15] = a4;
  a2[16] = 0LL;
  unint64_t v11 = a2[7];
  while (2)
  {
    if (v11)
    {
      int v12 = *((_DWORD *)v9 + 26);
      if ((v12 & 1) != 0) {
        unint64_t v13 = v11;
      }
      else {
        unint64_t v13 = 1LL;
      }
      uint64_t v14 = v9[16];
      uint64_t v15 = v9[14];
      if (v9[15] - v14 >= v13) {
        unint64_t v16 = v13;
      }
      else {
        unint64_t v16 = v9[15] - v14;
      }
      v9[16] = v16 + v14;
      if (v16)
      {
        v9[7] = v11 - v16;
        switch(((unsigned int (*)(uint64_t, void *, uint64_t, unint64_t))v9[12])( a1,  v9,  v15 + v14,  v16))
        {
          case 0u:
            goto LABEL_31;
          case 1u:
            int v12 = *((_DWORD *)v9 + 26);
            goto LABEL_15;
          case 2u:
            unint64_t v11 = v9[7];
            if (!v11) {
              goto LABEL_12;
            }
            continue;
          case 3u:
LABEL_12:
            unsigned int v18 = (FILE **)(a1 + 48);
            uint64_t v17 = *(FILE **)(a1 + 48);
            if (!v17) {
              goto LABEL_62;
            }
            fwrite("qdec: debug: ", 0xDuLL, 1uLL, v17);
            fprintf(*v18, "header block for stream %llu has had an error");
            break;
          default:
            __assert_rtn("qdec_header_process", "lsqpack.c", 4223, "st == LQRHS_ERROR");
        }

        goto LABEL_27;
      }

uint64_t parse_header_prefix(uint64_t a1, uint64_t a2, unsigned __int8 *__src, uint64_t a4)
{
  if (a4 < 1)
  {
LABEL_26:
    if (*(void *)(a2 + 56)) {
      return 2LL;
    }
    else {
      return 3LL;
    }
  }

  int v4 = &__src[a4];
  switch(*(_DWORD *)(a2 + 136))
  {
    case 0:
      *(_DWORD *)(a2 + 144) = 0;
      *(_DWORD *)(a2 + 136) = 1;
      goto LABEL_6;
    case 1:
      if (!*(_DWORD *)(a2 + 144))
      {
LABEL_6:
        int v8 = __src + 1;
        unint64_t v6 = *__src;
        if (v6 == 255)
        {
          unsigned int v7 = 0;
          char v5 = 1;
          goto LABEL_13;
        }

        goto LABEL_17;
      }

      char v5 = 0;
      unint64_t v6 = *(void *)(a2 + 160);
      unsigned int v7 = *(_DWORD *)(a2 + 148);
      int v8 = __src;
      do
      {
        unsigned int v15 = *v8++;
        unsigned int v14 = v15;
        v6 += (unint64_t)(v15 & 0x7F) << v7;
        v7 += 7;
        if ((v15 & 0x80) == 0)
        {
          if (v7 >= 0x40)
          {
            if (v7 != 70) {
              return 3LL;
            }
            uint64_t v22 = 3LL;
            if (v14 > 1 || (v6 & 0x8000000000000000LL) == 0) {
              return v22;
            }
            *(void *)(a2 + 16_Block_object_dispose((const void *)(v50 - 136), 8) = v6;
            goto LABEL_18;
          }

uint64_t parse_header_data(uint64_t a1, uint64_t a2, unsigned __int8 *__src, uint64_t a4)
{
  int v4 = __src;
  unsigned int v7 = __src;
  if (a4 < 1)
  {
LABEL_219:
    if (*(void *)(a2 + 56)) {
      return 2LL;
    }
    if (*(_DWORD *)(a2 + 136))
    {
      int v161 = 3843;
      goto LABEL_348;
    }

    int v139 = *(_DWORD *)(a2 + 104);
    if ((v139 & 0x22) == 2)
    {
      int v161 = 3837;
      goto LABEL_348;
    }

    if ((v139 & 0x40) != 0)
    {
      int v161 = 3839;
      goto LABEL_348;
    }

    return 0LL;
  }

  int v8 = &__src[a4];
  __int128 v168 = (_DWORD *)(a2 + 184);
  uint64_t v9 = 0xFFFFFFFFLL;
  unint64_t v10 = __src;
  while (2)
  {
    switch(*(_DWORD *)(a2 + 136))
    {
      case 0:
        int v11 = (char)*v10;
        if (v11 < 0)
        {
          *(_DWORD *)(a2 + 144) = v11 & 0x40;
          *(_DWORD *)(a2 + 160) = 0;
          uint64_t v9 = 6LL;
          *(_DWORD *)(a2 + 136) = 1;
LABEL_58:
          unsigned int v7 = v10 + 1;
          uint64_t v50 = *v10;
          unint64_t v51 = ~(-1 << v9);
          uint64_t v13 = v50 & v51;
          if ((v50 & v51) >= v51)
          {
            unsigned int v14 = 0;
            char v12 = 1;
            do
            {
              if (v7 >= v8)
              {
                if ((v12 & 1) != 0) {
                  int v141 = 0;
                }
                else {
                  int v141 = *(_DWORD *)(a2 + 168);
                }
                unsigned int v150 = v141 + (_DWORD)v7 - (_DWORD)v10;
                if (v150 < 0xB)
                {
                  *(void *)(a2 + 176) = v13;
                  goto LABEL_327;
                }

                int v161 = 3590;
                int v4 = __src;
                goto LABEL_349;
              }

LABEL_340:
                  *(void *)(a2 + 176) = v16;
                  *(_DWORD *)(a2 + 164) = v17;
                  *(_DWORD *)(a2 + 16_Block_object_dispose((const void *)(v50 - 136), 8) = v160;
                  *(_DWORD *)(a2 + 160) = 1;
                  return 2LL;
                }

  if (v141) {
    free(v141);
  }
  p_output_handler = v140;
LABEL_343:
  unsigned int v150 = v132;
  BOOL v151 = (v150[12] & 0x200LL) == 0;

  if (v151 || !setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4356, &v551, 4u)) {
    goto LABEL_368;
  }
  __int128 v152 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
  }
  __int128 v153 = (os_log_s *)gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)__int128 buf = 136446722;
    unsigned int v553 = "nw_socket_set_common_sockopts";
    int v554 = 2080;
    *(void *)int v555 = (char *)a1 + 404;
    *(_WORD *)&v555[8] = 1024;
    *(_DWORD *)&v555[10] = v152;
    _os_log_impl( &dword_181A5C000,  v153,  OS_LOG_TYPE_ERROR,  "%{public}s %s setsockopt SO_RECV_ANYIF failed %{darwin.errno}d",  buf,  0x1Cu);
  }

  BOOL v154 = (os_log_s *)__nwlog_obj();
  int v155 = v154;
  if (v152 == 22)
  {
    if (os_log_type_enabled(v154, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int128 buf = 136446466;
      unsigned int v553 = "nw_socket_set_common_sockopts";
      int v554 = 1024;
      *(_DWORD *)int v555 = 22;
      _os_log_impl( &dword_181A5C000,  v155,  OS_LOG_TYPE_ERROR,  "%{public}s setsockopt SO_RECV_ANYIF failed %{darwin.errno}d",  buf,  0x12u);
    }

    goto LABEL_368;
  }

  __int128 v156 = v72;
  __int128 v157 = v150;
  __int128 v158 = p_output_handler;
  *(_DWORD *)__int128 buf = 136446466;
  unsigned int v553 = "nw_socket_set_common_sockopts";
  int v554 = 1024;
  *(_DWORD *)int v555 = v152;
  __int128 v159 = (char *)_os_log_send_and_compose_impl();
  v548[0] = OS_LOG_TYPE_ERROR;
  v547[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v159, v548, v547))
  {
    if (v548[0] == OS_LOG_TYPE_FAULT)
    {
      unsigned int v160 = (os_log_s *)__nwlog_obj();
      int v161 = v548[0];
      if (os_log_type_enabled(v160, v548[0]))
      {
        *(_DWORD *)__int128 buf = 136446466;
        unsigned int v553 = "nw_socket_set_common_sockopts";
        int v554 = 1024;
        *(_DWORD *)int v555 = v152;
        uint64_t v162 = "%{public}s setsockopt SO_RECV_ANYIF failed %{darwin.errno}d";
LABEL_363:
        unsigned int v167 = v160;
        __int128 v168 = v161;
LABEL_364:
        _os_log_impl(&dword_181A5C000, v167, v168, v162, buf, 0x12u);
      }
    }

    else if (v547[0])
    {
      __int128 v163 = (char *)__nw_create_backtrace_string();
      __int128 v164 = (os_log_s *)__nwlog_obj();
      uint64_t v165 = v548[0];
      unsigned int v166 = os_log_type_enabled(v164, v548[0]);
      if (v163)
      {
        if (v166)
        {
          *(_DWORD *)__int128 buf = 136446722;
          unsigned int v553 = "nw_socket_set_common_sockopts";
          int v554 = 1024;
          *(_DWORD *)int v555 = v152;
          *(_WORD *)&v555[4] = 2082;
          *(void *)&v555[6] = v163;
          _os_log_impl( &dword_181A5C000,  v164,  v165,  "%{public}s setsockopt SO_RECV_ANYIF failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
        }

        free(v163);
        goto LABEL_365;
      }

      if (v166)
      {
        *(_DWORD *)__int128 buf = 136446466;
        unsigned int v553 = "nw_socket_set_common_sockopts";
        int v554 = 1024;
        *(_DWORD *)int v555 = v152;
        uint64_t v162 = "%{public}s setsockopt SO_RECV_ANYIF failed %{darwin.errno}d, no backtrace";
        unsigned int v167 = v164;
        __int128 v168 = v165;
        goto LABEL_364;
      }
    }

    else
    {
      unsigned int v160 = (os_log_s *)__nwlog_obj();
      int v161 = v548[0];
      if (os_log_type_enabled(v160, v548[0]))
      {
        *(_DWORD *)__int128 buf = 136446466;
        unsigned int v553 = "nw_socket_set_common_sockopts";
        int v554 = 1024;
        *(_DWORD *)int v555 = v152;
        uint64_t v162 = "%{public}s setsockopt SO_RECV_ANYIF failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_363;
      }
    }
  }

uint64_t header_out_dynamic_entry(unsigned int *a1, uint64_t a2, int a3)
{
  unsigned int v5 = a1[5];
  if (v5) {
    unsigned int v5 = (2 * v5 - a3 + a1[8]) % (2 * v5);
  }
  unsigned int v6 = a1[14];
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v7 = a1[15];
  unsigned int v8 = a1[16];
  BOOL v9 = v7 >= v8;
  unsigned int v10 = v7 - v8;
  unsigned int v11 = v9 ? 0 : a1[14];
  if (v10 + v11 <= v5) {
    return 0xFFFFFFFFLL;
  }
  char v12 = *(unsigned int **)(*((void *)a1 + 9) + 8LL * ((v6 + ~v5 + v7) % v6));
  if (!v12) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v13 = 4LL * (*a1 & 1);
  uint64_t v14 = (*(uint64_t (**)(void, void, uint64_t))(*((void *)a1 + 5) + 8LL))( *(void *)(a2 + 32),  0LL,  v12[1] + *v12 + v13);
  if (!v14) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v15 = v14;
  qdec_maybe_update_entry_hashes(*a1, v12);
  unsigned int v16 = v12[6];
  if ((v16 & 1) == 0)
  {
    if ((v16 & 2) == 0) {
      goto LABEL_12;
    }
LABEL_23:
    *(_BYTE *)(v15 + 33) |= 0x10u;
    *(_DWORD *)(v15 + 12) = v12[4];
    if ((v12[6] & 4) == 0) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }

  *(_BYTE *)(v15 + 33) |= 8u;
  *(_DWORD *)(v15 + _Block_object_dispose((const void *)(v50 - 136), 8) = v12[3];
  unsigned int v16 = v12[6];
  if ((v16 & 2) != 0) {
    goto LABEL_23;
  }
LABEL_12:
  if ((v16 & 4) != 0)
  {
LABEL_13:
    *(_BYTE *)(v15 + 33) |= 2u;
    *(_BYTE *)(v15 + 3nw_tcp_options_set_enable_fast_open(options, 1) = v12[5];
  }

uint64_t header_out_begin_dynamic_nameref(unsigned int *a1, void *a2, unsigned int *a3, int a4)
{
  if (a2[10]) {
    __assert_rtn("header_out_begin_dynamic_nameref", "lsqpack.c", 3131, "!read_ctx->hbrc_out.xhdr");
  }
  uint64_t v8 = 4LL * (*a1 & 1);
  uint64_t v9 = (*(uint64_t (**)(void, void, uint64_t))(*((void *)a1 + 5) + 8LL))(a2[4], 0LL, v8 + *a3);
  a2[10] = v9;
  if (!v9) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = v9;
  *(_BYTE *)(v9 + 35) = v8;
  if (a4) {
    *(_BYTE *)(v9 + 33) |= 0x40u;
  }
  qdec_maybe_update_entry_hashes(*a1, a3);
  unsigned int v11 = a3[6];
  if ((v11 & 1) != 0)
  {
    *(_BYTE *)(v10 + 33) |= 8u;
    *(_DWORD *)(v10 + _Block_object_dispose((const void *)(v50 - 136), 8) = a3[3];
    unsigned int v11 = a3[6];
  }

  if ((v11 & 4) != 0)
  {
    *(_BYTE *)(v10 + 33) |= 2u;
    *(_BYTE *)(v10 + 3nw_tcp_options_set_enable_fast_open(options, 1) = a3[5];
  }

  size_t v12 = *a3;
  *(_WORD *)(v10 + 24) = v12;
  uint64_t v13 = (char *)(*(void *)v10 + *(int *)(v10 + 16));
  memcpy(v13, a3 + 7, v12);
  uint64_t v14 = &v13[*a3];
  if ((_DWORD)v8)
  {
    *(_WORD *)uint64_t v14 = 8250;
    LOWORD(v14) = (_WORD)v14 + 2;
  }

  uint64_t result = 0LL;
  *(_DWORD *)(v10 + 20) = (unsigned __int16)((_WORD)v14 - *(_DWORD *)v10);
  a2[11] = 1LL;
  return result;
}

uint64_t guarantee_out_bytes(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v4 = *(void *)(a2 + 80);
  if (!v4) {
    __assert_rtn("guarantee_out_bytes", "lsqpack.c", 3332, "read_ctx->hbrc_out.xhdr");
  }
  if (*(_DWORD *)(a2 + 88) != 1) {
    __assert_rtn("guarantee_out_bytes", "lsqpack.c", 3333, "read_ctx->hbrc_out.state == XOUT_VALUE");
  }
  int v6 = *(_DWORD *)(v4 + 16);
  int v5 = *(_DWORD *)(v4 + 20);
  BOOL v7 = __OFSUB__(v5, v6);
  int v8 = v5 - v6;
  if (v8 < 0 != v7) {
    __assert_rtn( "guarantee_out_bytes",  "lsqpack.c",  3335,  "read_ctx->hbrc_out.xhdr->val_offset >= read_ctx->hbrc_out.xhdr->name_offset");
  }
  unsigned int v9 = *(_DWORD *)(a2 + 92) + v8;
  unsigned int v10 = *(unsigned __int16 *)(v4 + 26);
  BOOL v11 = v10 >= v9;
  unint64_t v12 = v10 - v9;
  if (!v11) {
    __assert_rtn("guarantee_out_bytes", "lsqpack.c", 3339, "read_ctx->hbrc_out.xhdr->val_len >= off");
  }
  if (v12 >= a3) {
    return 0LL;
  }
  uint64_t v13 = (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 8LL))(*(void *)(a2 + 32));
  *(void *)(a2 + 80) = v13;
  if (v13) {
    return 0LL;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t header_out_write_value(int *a1, uint64_t a2, int a3, int a4)
{
  unsigned int v4 = *(_DWORD *)(a2 + 92) + a3;
  *(_DWORD *)(a2 + 92) = v4;
  if (!a4) {
    return 0LL;
  }
  BOOL v7 = (void *)(a2 + 80);
  uint64_t v8 = *(void *)(a2 + 80);
  int v9 = *a1;
  if ((*a1 & 1) != 0)
  {
    int v10 = *(_DWORD *)(v8 + 20);
    if (v4 + v10 + 2 > *(unsigned __int16 *)(v8 + 26))
    {
      uint64_t v11 = (*(uint64_t (**)(void, void))(*((void *)a1 + 5) + 8LL))( *(void *)(a2 + 32),  *(void *)(a2 + 80));
      *(void *)(a2 + 80) = v11;
      if (!v11) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v8 = v11;
      int v10 = *(_DWORD *)(v11 + 20);
      unsigned int v4 = *(_DWORD *)(a2 + 92);
    }

    *(_WORD *)(*(void *)v8 + v10 + v4) = 2573;
    LOWORD(v4) = *(_WORD *)(a2 + 92);
    int v9 = *a1;
  }

  *(_WORD *)(v8 + 26) = v4;
  if ((v9 & 2) != 0)
  {
    char v12 = *(_BYTE *)(v8 + 33);
    if ((v12 & 8) == 0) {
      __assert_rtn("header_out_write_value", "lsqpack.c", 3266, "xhdr->flags & LSXPACK_NAME_HASH");
    }
    *(_DWORD *)(v8 + 12) = XXH_INLINE_XXH32( (int *)(*(void *)v8 + *(int *)(v8 + 20)),  (unsigned __int16)v4,  *(_DWORD *)(v8 + 8));
    *(_BYTE *)(v8 + 33) = v12 | 0x10;
  }

  uint64_t result = (*(uint64_t (**)(void, uint64_t))(*((void *)a1 + 5) + 16LL))(*(void *)(a2 + 32), v8);
  if ((_DWORD)result) {
    uint64_t result = 0xFFFFFFFFLL;
  }
  else {
    a1[7] += *(unsigned __int16 *)(v8 + 26) + *(unsigned __int16 *)(v8 + 24);
  }
  ++*(_DWORD *)(a2 + 72);
  *BOOL v7 = 0LL;
  v7[1] = 0LL;
  return result;
}

uint64_t lsqpack_huff_decode(unsigned __int8 *a1, int a2, char *a3, uint64_t a4, _DWORD *a5, int a6)
{
  int v7 = a4;
  if (!a6 || *a5) {
    return lsqpack_huff_decode_full(a1, a2, a3, a4, (uint64_t)a5, a6);
  }
  unsigned int v8 = 0;
  unint64_t v9 = (unint64_t)&a1[a2];
  int v10 = a3;
  uint64_t v11 = &a3[(int)a4];
  do
  {
    while (1)
    {
LABEL_4:
      char v12 = a1 + 8;
      if ((unint64_t)(a1 + 8) <= v9)
      {
        unsigned int v16 = (64 - v8) >> 3;
        if (v16 != 7)
        {
          if (v16 != 8)
          {
LABEL_20:
            unsigned int v14 = ((64 - (_BYTE)v8) & 0x78) + v8;
            uint64_t v13 = a1 + 5;
            unint64_t v15 = (v6 << 48) | ((unint64_t)*a1 << 40) | ((unint64_t)a1[1] << 32) | ((unint64_t)a1[2] << 24) | ((unint64_t)a1[3] << 16) | ((unint64_t)a1[4] << 8);
            char v12 = a1 + 6;
            goto LABEL_21;
          }

          unsigned int v17 = *a1++;
          unint64_t v6 = v17;
        }

        unsigned int v18 = *a1++;
        unint64_t v6 = v18 | (v6 << 8);
        goto LABEL_20;
      }

      if ((unint64_t)a1 >= v9)
      {
        if (v8 >= 5)
        {
          int v42 = ((_DWORD)v6 << (16 - v8)) & 0xFFFE | (-1 << (16 - v8)) & 0xFFFE ^ 0xFFFF;
          if (v8 <= 7 && v42 == 0xFFFF) {
            goto LABEL_91;
          }
          unsigned int v43 = &hdecs[4 * v42];
          unsigned int v44 = *v43;
          unsigned int v45 = v8 - (v44 >> 2);
          if (v8 < v44 >> 2)
          {
LABEL_92:
            uint64_t v34 = 0LL;
            uint64_t v35 = 3LL;
            return v35 | (v34 << 32);
          }

          uint64_t v46 = v44 & 3;
          char v47 = &v10[v46];
          if ((_DWORD)v46) {
            BOOL v48 = v47 > v11;
          }
          else {
            BOOL v48 = 1;
          }
          if (v48)
          {
            if (v47 > v11) {
              goto LABEL_51;
            }
            goto LABEL_92;
          }

          char v49 = v43[1];
          char v50 = v43[2];
          if ((_DWORD)v46 == 2)
          {
            *int v10 = v49;
            v10[1] = v50;
            LODWORD(v10) = (_DWORD)v10 + 2;
          }

          else if ((_DWORD)v46 == 3)
          {
            char v51 = v43[3];
            *int v10 = v49;
            v10[1] = v50;
            v10[2] = v51;
            LODWORD(v10) = (_DWORD)v10 + 3;
          }

          else
          {
            *int v10 = v49;
            LODWORD(v10) = (_DWORD)v10 + 1;
          }

          unsigned int v8 = v45;
        }

        if (!v8 || (~(_DWORD)v6 & ~(-1 << v8)) == 0)
        {
LABEL_91:
          uint64_t v35 = 0LL;
          uint64_t v34 = ((_DWORD)v10 - (_DWORD)a3);
          return v35 | (v34 << 32);
        }

        goto LABEL_92;
      }

      uint64_t v13 = a1 + 1;
      unint64_t v6 = *a1 | (v6 << 8);
      if ((unint64_t)(a1 + 1) >= v9)
      {
        unsigned int v14 = v8 + 8;
        goto LABEL_27;
      }

      uint64_t v13 = a1 + 2;
      unint64_t v6 = a1[1] | (v6 << 8);
      if ((unint64_t)(a1 + 2) >= v9)
      {
        unsigned int v14 = v8 + 16;
        goto LABEL_27;
      }

      uint64_t v13 = a1 + 3;
      unint64_t v6 = a1[2] | (v6 << 8);
      if ((unint64_t)(a1 + 3) >= v9)
      {
        unsigned int v14 = v8 + 24;
        goto LABEL_27;
      }

      uint64_t v13 = a1 + 4;
      unint64_t v6 = a1[3] | (v6 << 8);
      if ((unint64_t)(a1 + 4) >= v9)
      {
        unsigned int v14 = v8 + 32;
        goto LABEL_27;
      }

      uint64_t v13 = a1 + 5;
      unint64_t v6 = a1[4] | (v6 << 8);
      if ((unint64_t)(a1 + 5) >= v9)
      {
        unsigned int v14 = v8 + 40;
        goto LABEL_27;
      }

      uint64_t v13 = a1 + 6;
      unint64_t v6 = a1[5] | (v6 << 8);
      unsigned int v14 = v8 + 48;
      if ((unint64_t)(a1 + 6) < v9 && v8 <= 8)
      {
        uint64_t v13 = a1 + 7;
        unint64_t v6 = a1[6] | (v6 << 8);
        unsigned int v14 = v8 + 56;
        if ((unint64_t)(a1 + 7) < v9 && !v8)
        {
          unint64_t v15 = v6 << 8;
          unsigned int v14 = 64;
LABEL_21:
          unint64_t v6 = v15 | *v13;
          uint64_t v13 = v12;
        }
      }

uint64_t header_out_grow_buf(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (void *)(a2 + 80);
  uint64_t v3 = *(void *)(a2 + 80);
  if (!v3) {
    __assert_rtn("header_out_grow_buf", "lsqpack.c", 3291, "read_ctx->hbrc_out.xhdr");
  }
  if (*(_DWORD *)(a2 + 88)) {
    unsigned int v6 = *(_DWORD *)(v3 + 20) - *(_DWORD *)(v3 + 16) + *(_DWORD *)(a2 + 92);
  }
  else {
    unsigned int v6 = *(_DWORD *)(a2 + 92);
  }
  unsigned int v7 = *(unsigned __int16 *)(v3 + 26);
  BOOL v8 = v7 >= v6;
  unsigned int v9 = v7 - v6;
  if (!v8) {
    __assert_rtn("header_out_grow_buf", "lsqpack.c", 3303, "read_ctx->hbrc_out.xhdr->val_len >= off");
  }
  if (v9 <= 2) {
    unsigned int v9 = 2;
  }
  else {
    unint64_t v10 = (v9 >> 1) + (unint64_t)*(unsigned __int16 *)(v3 + 26);
  }
  uint64_t v11 = (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 8LL))(*(void *)(a2 + 32));
  *(void *)(a2 + 80) = v11;
  if (!v11) {
    return 0xFFFFFFFFLL;
  }
  if (v10 > *(unsigned __int16 *)(v11 + 26))
  {
    char v12 = *(FILE **)(a1 + 48);
    if (v12)
    {
      fwrite("qdec: info: ", 0xCuLL, 1uLL, v12);
      fprintf( *(FILE **)(a1 + 48),  "allocated xhdr size (%zd) is smaller than requested (%zd)",  *(unsigned __int16 *)(*v4 + 26LL),  v10);
      fputc(10, *(FILE **)(a1 + 48));
    }

    *unsigned int v4 = 0LL;
    v4[1] = 0LL;
    return 0xFFFFFFFFLL;
  }

  return 0LL;
}

uint64_t header_out_write_name(int *a1, uint64_t a2, int a3, int a4)
{
  LODWORD(v4) = *(_DWORD *)(a2 + 92) + a3;
  *(_DWORD *)(a2 + 92) = v4;
  if (!a4) {
    return 0LL;
  }
  uint64_t v7 = *(void *)(a2 + 80);
  int v8 = *a1;
  if ((*a1 & 1) == 0)
  {
    int v9 = *(_DWORD *)(v7 + 16);
    *(_DWORD *)(v7 + 20) = (unsigned __int16)(v9 + v4);
    goto LABEL_8;
  }

  if ((int)v4 + 2 <= *(unsigned __int16 *)(v7 + 26))
  {
LABEL_7:
    *(_WORD *)(*(void *)v7 + *(int *)(v7 + 16) + v4) = 8250;
    int v9 = *(_DWORD *)(v7 + 16);
    LODWORD(v4) = *(_DWORD *)(a2 + 92);
    *(_DWORD *)(v7 + 20) = (unsigned __int16)(v9 + v4 + 2);
    int v8 = *a1;
LABEL_8:
    *(_WORD *)(v7 + 24) = v4;
    *(void *)(a2 + 8_Block_object_dispose((const void *)(v50 - 136), 8) = 1LL;
    if ((v8 & 6) != 0)
    {
      if (!*(void *)v7)
      {
        unsigned int v22 = 414139866;
LABEL_21:
        uint64_t result = 0LL;
        unsigned int v28 = (-2048144777 * (v22 ^ (v22 >> 15))) ^ ((-2048144777 * (v22 ^ (v22 >> 15))) >> 13);
        *(_DWORD *)(v7 + _Block_object_dispose((const void *)(v50 - 136), 8) = (-1028477379 * v28) ^ ((-1028477379 * v28) >> 16);
        *(_BYTE *)(v7 + 33) |= 8u;
        return result;
      }

      uint64_t v11 = (int *)(*(void *)v7 + v9);
      unint64_t v4 = (unsigned __int16)v4;
      if ((unsigned __int16)v4 < 0x10u)
      {
        unsigned int v22 = (unsigned __int16)v4 + 414139866;
      }

      else
      {
        unint64_t v12 = (unint64_t)v11 + (unsigned __int16)v4 - 15;
        int v13 = 1679910008;
        int v14 = 39378473;
        int v15 = -2008766304;
        int v16 = 645669457;
        do
        {
          HIDWORD(v17) = v16 - 2048144777 * *v11;
          LODWORD(v17) = HIDWORD(v17);
          int v16 = -1640531535 * (v17 >> 19);
          HIDWORD(v17) = v15 - 2048144777 * v11[1];
          LODWORD(v17) = HIDWORD(v17);
          int v15 = -1640531535 * (v17 >> 19);
          HIDWORD(v17) = v14 - 2048144777 * v11[2];
          LODWORD(v17) = HIDWORD(v17);
          int v14 = -1640531535 * (v17 >> 19);
          HIDWORD(v17) = v13 - 2048144777 * v11[3];
          LODWORD(v17) = HIDWORD(v17);
          int v13 = -1640531535 * (v17 >> 19);
          v11 += 4;
        }

        while ((unint64_t)v11 < v12);
        HIDWORD(v19) = v16;
        LODWORD(v19) = v16;
        int v18 = v19 >> 31;
        HIDWORD(v19) = v15;
        LODWORD(v19) = v15;
        int v20 = v19 >> 25;
        HIDWORD(v19) = v14;
        LODWORD(v19) = v14;
        int v21 = v19 >> 20;
        HIDWORD(v19) = v13;
        LODWORD(v19) = v13;
        unsigned int v22 = v18 + (unsigned __int16)v4 + v20 + v21 + (v19 >> 14);
        v4 &= 0xFu;
        if (v4 < 4)
        {
LABEL_19:
          while (v4)
          {
            int v26 = *(unsigned __int8 *)v11;
            uint64_t v11 = (int *)((char *)v11 + 1);
            HIDWORD(v27) = v22 + 374761393 * v26;
            LODWORD(v27) = HIDWORD(v27);
            unsigned int v22 = -1640531535 * (v27 >> 21);
            --v4;
          }

          goto LABEL_21;
        }
      }

      do
      {
        int v24 = *v11++;
        HIDWORD(v25) = v22 - 1028477379 * v24;
        LODWORD(v25) = HIDWORD(v25);
        unsigned int v22 = 668265263 * (v25 >> 15);
        v4 -= 4LL;
      }

      while (v4 > 3);
      goto LABEL_19;
    }

    return 0LL;
  }

  uint64_t v10 = (*(uint64_t (**)(void))(*((void *)a1 + 5) + 8LL))(*(void *)(a2 + 32));
  *(void *)(a2 + 80) = v10;
  if (v10)
  {
    uint64_t v7 = v10;
    LODWORD(v4) = *(_DWORD *)(a2 + 92);
    goto LABEL_7;
  }

  return 0xFFFFFFFFLL;
}

uint64_t qdec_maybe_update_entry_hashes(uint64_t result, unsigned int *a2)
{
  if ((result & 6) != 0)
  {
    unsigned int v3 = a2[6];
    if ((v3 & 1) == 0)
    {
      a2[6] = v3 | 1;
      unint64_t v4 = (int *)(a2 + 7);
      unint64_t v5 = *a2;
      if (v5 < 0x10)
      {
        unsigned int v16 = v5 + 414139866;
      }

      else
      {
        unint64_t v6 = (unint64_t)v4 + v5 - 15;
        int v7 = 1679910008;
        int v8 = 39378473;
        int v9 = -2008766304;
        int v10 = 645669457;
        do
        {
          HIDWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = v10 - 2048144777 * *v4;
          LODWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = HIDWORD(v11);
          int v10 = -1640531535 * (v11 >> 19);
          HIDWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = v9 - 2048144777 * v4[1];
          LODWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = HIDWORD(v11);
          int v9 = -1640531535 * (v11 >> 19);
          HIDWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = v8 - 2048144777 * v4[2];
          LODWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = HIDWORD(v11);
          int v8 = -1640531535 * (v11 >> 19);
          HIDWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = v7 - 2048144777 * v4[3];
          LODWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = HIDWORD(v11);
          int v7 = -1640531535 * (v11 >> 19);
          v4 += 4;
        }

        while ((unint64_t)v4 < v6);
        HIDWORD(v13) = v10;
        LODWORD(v13) = v10;
        int v12 = v13 >> 31;
        HIDWORD(v13) = v9;
        LODWORD(v13) = v9;
        int v14 = v13 >> 25;
        HIDWORD(v13) = v8;
        LODWORD(v13) = v8;
        int v15 = v13 >> 20;
        HIDWORD(v13) = v7;
        LODWORD(v13) = v7;
        unsigned int v16 = v12 + v5 + v14 + v15 + (v13 >> 14);
        v5 &= 0xFu;
      }

      if (v5 >= 4)
      {
        do
        {
          int v17 = *v4++;
          HIDWORD(v1_Block_object_dispose((const void *)(v50 - 136), 8) = v16 - 1028477379 * v17;
          LODWORD(v1_Block_object_dispose((const void *)(v50 - 136), 8) = HIDWORD(v18);
          unsigned int v16 = 668265263 * (v18 >> 15);
          v5 -= 4LL;
        }

        while (v5 > 3);
      }

      for (; v5; --v5)
      {
        int v19 = *(unsigned __int8 *)v4;
        unint64_t v4 = (int *)((char *)v4 + 1);
        HIDWORD(v20) = v16 + 374761393 * v19;
        LODWORD(v20) = HIDWORD(v20);
        unsigned int v16 = -1640531535 * (v20 >> 21);
      }

      unsigned int v21 = -1028477379 * ((-2048144777 * (v16 ^ (v16 >> 15))) ^ ((-2048144777 * (v16 ^ (v16 >> 15))) >> 13));
      a2[3] = v21 ^ HIWORD(v21);
    }
  }

  if ((result & 4) != 0)
  {
    unsigned int v22 = a2[6];
    if ((v22 & 2) == 0)
    {
      if ((v22 & 1) == 0) {
        __assert_rtn("qdec_maybe_update_entry_hashes", "lsqpack.c", 2964, "entry->dte_flags & DTEF_NAME_HASH");
      }
      a2[6] = v22 | 2;
      uint64_t result = XXH_INLINE_XXH32((int *)((char *)a2 + *a2 + 28), a2[1], a2[3]);
      a2[4] = result;
    }
  }

  return result;
}

uint64_t lsqpack_dec_push_entry(uint64_t a1, const char *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 56);
  if ((_DWORD)v4)
  {
    unsigned int v5 = *(_DWORD *)(a1 + 60);
    unsigned int v6 = v5 + 1;
    unsigned int v7 = (v5 + 1) % v4;
    if (v7 != *(_DWORD *)(a1 + 64))
    {
      int v9 = *(void **)(a1 + 72);
      goto LABEL_12;
    }

    int v8 = malloc(8LL * (2 * v4));
    if (v8)
    {
      int v9 = v8;
      int v10 = v5 - v7;
      if (v5 >= v7)
      {
        unint64_t v11 = *(char **)(a1 + 72);
        memcpy(v8, &v11[8 * v7], 8LL * (v10 + 1));
        int v12 = 0;
        *(_DWORD *)(a1 + 60) = v10;
      }

      else
      {
        unint64_t v11 = *(char **)(a1 + 72);
        memcpy(v8, v11, 8LL * v6);
        memcpy(&v9[v4 + v7], &v11[8 * v7], 8LL * (v4 - v7));
        int v12 = v7 + v4;
      }

      *(_DWORD *)(a1 + 64) = v12;
      free(v11);
      *(void *)(a1 + 72) = v9;
      LODWORD(v4) = 2 * *(_DWORD *)(a1 + 56);
      goto LABEL_11;
    }

    return 0xFFFFFFFFLL;
  }

  unint64_t v13 = malloc(0x20uLL);
  *(void *)(a1 + 72) = v13;
  if (!v13) {
    return 0xFFFFFFFFLL;
  }
  int v9 = v13;
  LODWORD(v4) = 4;
LABEL_11:
  *(_DWORD *)(a1 + 56) = v4;
LABEL_12:
  uint64_t v14 = *(unsigned int *)(a1 + 60);
  v9[v14] = a2;
  *(_DWORD *)(a1 + 60) = ((int)v14 + 1) % v4;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)a2 + *((_DWORD *)a2 + 1) + 32;
  int v15 = *(FILE **)(a1 + 48);
  if (v15)
  {
    fwrite("qdec: debug: ", 0xDuLL, 1uLL, v15);
    fputc(10, *(FILE **)(a1 + 48));
  }

  unsigned int v16 = *(_DWORD *)(a1 + 20);
  if (v16) {
    unsigned int v16 = (*(_DWORD *)(a1 + 32) + 1) % (2 * v16);
  }
  *(_DWORD *)(a1 + 32) = v16;
  qdec_remove_overflow_entries(a1);
  uint64_t v17 = a1 + 16LL * (*(_DWORD *)(a1 + 32) & 7);
  uint64_t v18 = *(void *)(v17 + 96);
  if (v18)
  {
    int v19 = (void *)(v17 + 104);
    do
    {
      uint64_t v20 = *(void *)(v18 + 16);
      if (*(_DWORD *)(v18 + 64) == *(_DWORD *)(a1 + 32))
      {
        *(_DWORD *)(v18 + 104) &= ~4u;
        unsigned int v21 = (void *)(v20 + 24);
        if (!v20) {
          unsigned int v21 = v19;
        }
        void *v21 = *(void *)(v18 + 24);
        **(void **)(v18 + 24) = v20;
        --*(_DWORD *)(a1 + 224);
        unsigned int v22 = *(FILE **)(a1 + 48);
        if (v22)
        {
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, v22);
          fprintf(*(FILE **)(a1 + 48), "header block for stream %llu has become unblocked", *(void *)(v18 + 40));
          fputc(10, *(FILE **)(a1 + 48));
        }

        (**(void (***)(void))(a1 + 40))(*(void *)(v18 + 32));
      }

      uint64_t v18 = v20;
    }

    while (v20);
  }

  if (*(_DWORD *)(a1 + 12) > *(_DWORD *)(a1 + 8)) {
    return 0xFFFFFFFFLL;
  }
  return 0LL;
}

void qdec_remove_overflow_entries(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 12);
  while (v1 > *(_DWORD *)(a1 + 8))
  {
    unsigned int v3 = *(FILE **)(a1 + 48);
    if (v3)
    {
      fwrite("qdec: debug: ", 0xDuLL, 1uLL, v3);
      fprintf(*(FILE **)(a1 + 48), "capacity %u, drop entry", *(_DWORD *)(a1 + 12));
      fputc(10, *(FILE **)(a1 + 48));
      unsigned int v1 = *(_DWORD *)(a1 + 12);
    }

    uint64_t v4 = *(unsigned int *)(a1 + 64);
    unsigned int v5 = *(_DWORD **)(*(void *)(a1 + 72) + 8 * v4);
    *(_DWORD *)(a1 + 64) = (v4 + 1) % *(_DWORD *)(a1 + 56);
    unsigned int v1 = v1 - (*v5 + v5[1]) - 32;
    *(_DWORD *)(a1 + 12) = v1;
    int v6 = v5[2] - 1;
    v5[2] = v6;
    if (!v6)
    {
      free(v5);
      unsigned int v1 = *(_DWORD *)(a1 + 12);
    }
  }

void sub_1822BDAD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1822BDBEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1822BDC90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1822BE740(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_create_with_cfurl(const __CFURL *a1)
{
  uint64_t v15 = *MEMORY[0x1895F89C0];
  if (a1) {
    return -[NWConcrete_nw_url_endpoint initWithURL:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_url_endpoint), a1);
  }
  __nwlog_obj();
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  int v12 = "nw_endpoint_create_with_cfurl";
  unsigned int v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v12 = "nw_endpoint_create_with_cfurl";
        int v6 = "%{public}s called with null url";
LABEL_16:
        _os_log_impl(&dword_181A5C000, v4, v5, v6, buf, 0xCu);
      }
    }

    else
    {
      if (v9)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v5 = type;
        BOOL v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *(_DWORD *)__int128 buf = 136446466;
            int v12 = "nw_endpoint_create_with_cfurl";
            __int16 v13 = 2082;
            uint64_t v14 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v4,  v5,  "%{public}s called with null url, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_18;
        }

        if (!v8) {
          goto LABEL_17;
        }
        *(_DWORD *)__int128 buf = 136446210;
        int v12 = "nw_endpoint_create_with_cfurl";
        int v6 = "%{public}s called with null url, no backtrace";
        goto LABEL_16;
      }

      __nwlog_obj();
      uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v12 = "nw_endpoint_create_with_cfurl";
        int v6 = "%{public}s called with null url, backtrace limit exceeded";
        goto LABEL_16;
      }
    }

uint64_t nw_endpoint_get_url_port(void *a1, char a2)
{
  *(void *)&v43[13] = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    char v29 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    int v41 = "nw_endpoint_get_url_port";
    char v30 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (__nwlog_fault(v30, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        unsigned int v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v41 = "nw_endpoint_get_url_port";
          _os_log_impl(&dword_181A5C000, v31, v32, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v38)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        unsigned int v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v34 = type;
        BOOL v35 = os_log_type_enabled(v31, type);
        if (backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)__int128 buf = 136446466;
            int v41 = "nw_endpoint_get_url_port";
            __int16 v42 = 2082;
            *(void *)unsigned int v43 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v31,  v34,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_46;
        }

        if (v35)
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v41 = "nw_endpoint_get_url_port";
          _os_log_impl(&dword_181A5C000, v31, v34, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        unsigned int v31 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v36 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v41 = "nw_endpoint_get_url_port";
          _os_log_impl( &dword_181A5C000,  v31,  v36,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_1822BEFEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_get_url_path(void *a1)
{
  *(void *)&v43[13] = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    unint64_t v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    int v41 = "nw_endpoint_get_url_path";
    unsigned int v28 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (__nwlog_fault(v28, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        char v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v41 = "nw_endpoint_get_url_path";
          _os_log_impl(&dword_181A5C000, v29, v30, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v38)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        char v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v32 = type;
        BOOL v33 = os_log_type_enabled(v29, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)__int128 buf = 136446466;
            int v41 = "nw_endpoint_get_url_path";
            __int16 v42 = 2082;
            *(void *)unsigned int v43 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v29,  v32,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }

        if (v33)
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v41 = "nw_endpoint_get_url_path";
          _os_log_impl(&dword_181A5C000, v29, v32, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        char v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v34 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v41 = "nw_endpoint_get_url_path";
          _os_log_impl( &dword_181A5C000,  v29,  v34,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_1822BF654(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_endpoint_get_url_path_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(void *)(v1 + 272))
  {
    id v3 = CFURLCopyPath(*(CFURLRef *)(v1 + 232));
    if (v3)
    {
      int v4 = v3;
      if (CFStringGetLength(v3) >= 1) {
        *(void *)(*(void *)(a1 + 32) + 272LL) = nw_utilities_create_c_string_from_cfstring(v4);
      }
      CFRelease(v4);
    }
  }

const char *__cdecl nw_endpoint_get_url(nw_endpoint_t endpoint)
{
  *(void *)&v40[13] = *MEMORY[0x1895F89C0];
  uint64_t v1 = endpoint;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    int v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    char v38 = "nw_endpoint_get_url";
    unint64_t v27 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v27, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        unsigned int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v38 = "nw_endpoint_get_url";
          _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        unsigned int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v31 = type;
        BOOL v32 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)__int128 buf = 136446466;
            char v38 = "nw_endpoint_get_url";
            __int16 v39 = 2082;
            *(void *)uint64_t v40 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v28,  v31,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }

        if (v32)
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v38 = "nw_endpoint_get_url";
          _os_log_impl(&dword_181A5C000, v28, v31, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        unsigned int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v38 = "nw_endpoint_get_url";
          _os_log_impl( &dword_181A5C000,  v28,  v33,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_1822BFD08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CFTypeRef nw_endpoint_copy_cfurl(void *a1)
{
  *(void *)&v40[13] = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    int v26 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    char v38 = "nw_endpoint_copy_cfurl";
    unint64_t v27 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v27, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        unsigned int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v38 = "nw_endpoint_copy_cfurl";
          _os_log_impl(&dword_181A5C000, v28, v29, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        unsigned int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v31 = type;
        BOOL v32 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)__int128 buf = 136446466;
            char v38 = "nw_endpoint_copy_cfurl";
            __int16 v39 = 2082;
            *(void *)uint64_t v40 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v28,  v31,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }

        if (v32)
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v38 = "nw_endpoint_copy_cfurl";
          _os_log_impl(&dword_181A5C000, v28, v31, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        unsigned int v28 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v38 = "nw_endpoint_copy_cfurl";
          _os_log_impl( &dword_181A5C000,  v28,  v33,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_1822C0330(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_copy_host_port_endpoint_for_url(void *a1)
{
  *(void *)&v41[13] = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    unint64_t v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v39 = "nw_endpoint_copy_host_port_endpoint_for_url";
    unsigned int v28 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (__nwlog_fault(v28, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v39 = "nw_endpoint_copy_host_port_endpoint_for_url";
          _os_log_impl(&dword_181A5C000, v29, v30, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }

      else if (v36)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v32 = type;
        BOOL v33 = os_log_type_enabled(v29, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)__int128 buf = 136446466;
            __int16 v39 = "nw_endpoint_copy_host_port_endpoint_for_url";
            __int16 v40 = 2082;
            *(void *)int v41 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v29,  v32,  "%{public}s called with null endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }

        if (v33)
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v39 = "nw_endpoint_copy_host_port_endpoint_for_url";
          _os_log_impl(&dword_181A5C000, v29, v32, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v29 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v34 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v39 = "nw_endpoint_copy_host_port_endpoint_for_url";
          _os_log_impl( &dword_181A5C000,  v29,  v34,  "%{public}s called with null endpoint, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_1822C098C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t countOfBytesExpectedToReceive(void *a1)
{
  id v1 = a1;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0
    && ([v1 valueForHTTPHeaderField:@"Content-Encoding"],
        (uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue()) != 0LL)
    && (v3 = v2, uint64_t v4 = [v2 caseInsensitiveCompare:@"identity"], v3, v4))
  {
    uint64_t v5 = *MEMORY[0x189601E78];
  }

  else
  {
    uint64_t v5 = [v1 expectedContentLength];
  }

  return v5;
}

BOOL nw_ws_allocate_options(void *a1)
{
  id v1 = a1;
  uint64_t v2 = calloc(1uLL, 0x48uLL);
  if (v2) {
    goto LABEL_2;
  }
  __nwlog_obj();
  uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  uint64_t v5 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:
    v2[8] = 0LL;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *(_OWORD *)uint64_t v2 = 0u;
    *((_OWORD *)v2 + nw_tcp_options_set_enable_fast_open(options, 1) = 0u;

    return (BOOL)v2;
  }

  __break(1u);
  return result;
}

void sub_1822C3020(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_protocol_options_t nw_ws_create_options(nw_ws_version_t version)
{
  if (nw_protocol_copy_ws_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_ws_definition::onceToken, &__block_literal_global_3592);
  }
  id v2 = (id)nw_protocol_copy_ws_definition::definition;
  options = nw_protocol_create_options(v2);

  v5[0] = MEMORY[0x1895F87A8];
  v5[1] = 3221225472LL;
  v5[2] = __nw_ws_create_options_block_invoke;
  v5[3] = &__block_descriptor_36_e9_B16__0_v8l;
  nw_ws_version_t v6 = version;
  nw_protocol_options_access_handle(options, v5);
  return (nw_protocol_options_t)options;
}

void sub_1822C30E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_create_options_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 56) = *(_DWORD *)(a1 + 32);
  xpc_object_t v3 = xpc_array_create(0LL, 0LL);
  uint64_t v4 = *(void **)a2;
  *(void *)a2 = v3;

  xpc_object_t v5 = xpc_array_create(0LL, 0LL);
  nw_ws_version_t v6 = *(void **)(a2 + 8);
  *(void *)(a2 + _Block_object_dispose((const void *)(v50 - 136), 8) = v5;

  xpc_object_t v7 = xpc_array_create(0LL, 0LL);
  id v8 = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v7;

  *(_BYTE *)(a2 + 70) = *(_BYTE *)(a2 + 70) & 0xC7 | 0x30;
  *(_WORD *)(a2 + 6_Block_object_dispose((const void *)(v50 - 136), 8) = 3855;
  *(void *)(a2 + 60) = 0x100000001000LL;
  return 1LL;
}

BOOL nw_ws_copy_options(void *a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (!a2)
  {
    __nwlog_obj();
    id v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    int v26 = "nw_ws_copy_options";
    int v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v14, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v26 = "nw_ws_copy_options";
          _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }

      else if (v23)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = type;
        BOOL v21 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v21)
          {
            *(_DWORD *)__int128 buf = 136446466;
            int v26 = "nw_ws_copy_options";
            __int16 v27 = 2082;
            uint64_t v28 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s called with null existing_handle, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }

        if (v21)
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v26 = "nw_ws_copy_options";
          _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s called with null existing_handle, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v26 = "nw_ws_copy_options";
          _os_log_impl( &dword_181A5C000,  v15,  v22,  "%{public}s called with null existing_handle, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_1822C35D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_ws_deallocate_options(uint64_t a1, id *a2)
{
  id v3 = *a2;
  *a2 = 0LL;

  id v4 = a2[1];
  a2[1] = 0LL;

  id v5 = a2[2];
  a2[2] = 0LL;

  id v6 = a2[5];
  a2[5] = 0LL;

  id v7 = a2[6];
  a2[6] = 0LL;

  free(a2);
}

BOOL nw_ws_option_is_equal(void *a1, uint64_t a2, uint64_t a3)
{
  id v5 = a1;
  size_t count = xpc_array_get_count(*(xpc_object_t *)(a2 + 8));
  size_t v7 = xpc_array_get_count(*(xpc_object_t *)(a3 + 8));
  size_t v8 = xpc_array_get_count(*(xpc_object_t *)(a2 + 8));
  size_t v9 = v8;
  if (count != v7 || v8 == 0)
  {
    if (count != v7) {
      goto LABEL_35;
    }
LABEL_22:
    if (nw_unordered_xpc_array_is_equal(*(xpc_object_t *)a2, *(xpc_object_t *)a3)
      && *(void *)(a2 + 40) == *(void *)(a3 + 40)
      && *(void *)(a2 + 48) == *(void *)(a3 + 48)
      && *(_DWORD *)(a2 + 56) == *(_DWORD *)(a3 + 56)
      && ((*(_BYTE *)(a3 + 70) ^ *(_BYTE *)(a2 + 70)) & 1) == 0
      && *(void *)(a2 + 32) == *(void *)(a3 + 32))
    {
      BOOL v20 = 0LL;
      if (((*(_BYTE *)(a3 + 70) ^ *(_BYTE *)(a2 + 70)) & 0x3E) == 0 && *(void *)(a2 + 24) == *(void *)(a3 + 24))
      {
        if (*(unsigned __int8 *)(a2 + 68) != *(unsigned __int8 *)(a3 + 68)
          || *(unsigned __int8 *)(a2 + 69) != *(unsigned __int8 *)(a3 + 69)
          || *(_DWORD *)(a2 + 60) != *(_DWORD *)(a3 + 60))
        {
          goto LABEL_35;
        }

        BOOL v20 = *(_DWORD *)(a2 + 64) == *(_DWORD *)(a3 + 64);
      }
    }

    else
    {
LABEL_35:
      BOOL v20 = 0LL;
    }

    return v20;
  }

  else
  {
    id v24 = v5;
    unsigned int v11 = calloc(1uLL, v8);
    os_log_type_t v12 = v11;
    if (v11) {
      goto LABEL_9;
    }
    __nwlog_obj();
    os_log_type_t v22 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
    char v23 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v23);
    if (!result)
    {
      free(v23);
LABEL_9:
      size_t v13 = 0LL;
      while (1)
      {
        xpc_array_get_value(*(xpc_object_t *)(a2 + 8), v13);
        int v14 = (void *)objc_claimAutoreleasedReturnValue();
        xpc_array_get_value(*(xpc_object_t *)(a2 + 16), v13);
        os_log_type_t v15 = (void *)objc_claimAutoreleasedReturnValue();
        size_t v16 = 0LL;
        while (v12[v16])
        {
LABEL_11:
          if (v9 == ++v16) {
            goto LABEL_17;
          }
        }

        xpc_array_get_value(*(xpc_object_t *)(a3 + 8), v16);
        BOOL v17 = (void *)objc_claimAutoreleasedReturnValue();
        xpc_array_get_value(*(xpc_object_t *)(a3 + 16), v16);
        os_log_type_t v18 = (void *)objc_claimAutoreleasedReturnValue();
        if (!xpc_equal(v14, v17) || !xpc_equal(v15, v18)) {
          break;
        }
        v12[v16] = 1;

LABEL_17:
        if (++v13 == v9)
        {
          uint64_t v19 = 0LL;
          id v5 = v24;
          while (v12[v19])
          {
            if (v9 == ++v19)
            {
              free(v12);
              goto LABEL_22;
            }
          }

          free(v12);
          goto LABEL_35;
        }
      }

      goto LABEL_11;
    }

    __break(1u);
  }

  return result;
}

void sub_1822C39AC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
}

BOOL nw_protocol_options_is_ws(void *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    id v3 = (id *)v1;
    id v4 = v3[1];

    if (nw_protocol_copy_ws_definition::onceToken != -1) {
      dispatch_once(&nw_protocol_copy_ws_definition::onceToken, &__block_literal_global_3592);
    }
    id v5 = (id)nw_protocol_copy_ws_definition::definition;
    BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v4, (uint64_t)v5);

    goto LABEL_5;
  }

  __nwlog_obj();
  size_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v19 = "nw_protocol_options_is_ws";
  size_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unsigned int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v19 = "nw_protocol_options_is_ws";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      unsigned int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v19 = "nw_protocol_options_is_ws";
          __int16 v20 = 2082;
          BOOL v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v19 = "nw_protocol_options_is_ws";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      unsigned int v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v19 = "nw_protocol_options_is_ws";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C3D00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_ws_options_add_additional_header(nw_protocol_options_t options, const char *name, const char *value)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  id v5 = options;
  if (!nw_protocol_options_is_ws(v5))
  {
    __nwlog_obj();
    size_t v7 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v30 = "nw_ws_options_add_additional_header";
    size_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      size_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v30 = "nw_ws_options_add_additional_header";
        _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null nw_protocol_options_is_ws(options)",  buf,  0xCu);
      }
    }

    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      size_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v30 = "nw_ws_options_add_additional_header";
          __int16 v31 = 2082;
          os_log_type_t v32 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_63:
        if (!v8) {
          goto LABEL_13;
        }
LABEL_64:
        free(v8);
        goto LABEL_13;
      }

      if (v17)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v30 = "nw_ws_options_add_additional_header";
        _os_log_impl( &dword_181A5C000,  v9,  v16,  "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      size_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v30 = "nw_ws_options_add_additional_header";
        _os_log_impl( &dword_181A5C000,  v9,  v23,  "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_1822C44F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_add_additional_header_block_invoke(uint64_t a1, uint64_t a2)
{
  id v4 = *(void **)(a2 + 8);
  xpc_object_t v5 = xpc_string_create(*(const char **)(a1 + 32));
  xpc_array_append_value(v4, v5);

  id v6 = *(void **)(a2 + 16);
  xpc_object_t v7 = xpc_string_create(*(const char **)(a1 + 40));
  xpc_array_append_value(v6, v7);

  return 1LL;
}

void sub_1822C4574(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_ws_options_set_maximum_message_size(nw_protocol_options_t options, size_t maximum_message_size)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = options;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ws_options_set_maximum_message_size_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    void v12[4] = maximum_message_size;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v16 = "nw_ws_options_set_maximum_message_size";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_ws_options_set_maximum_message_size";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ws(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v16 = "nw_ws_options_set_maximum_message_size";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_ws_options_set_maximum_message_size";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_ws_options_set_maximum_message_size";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C4854(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_maximum_message_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  return 1LL;
}

void nw_ws_options_add_subprotocol(nw_protocol_options_t options, const char *subprotocol)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v3 = options;
  if (!nw_protocol_options_is_ws(v3))
  {
    __nwlog_obj();
    id v4 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v22 = "nw_ws_options_add_subprotocol";
    xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v22 = "nw_ws_options_add_subprotocol";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ws(options)",  buf,  0xCu);
      }
    }

    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v22 = "nw_ws_options_add_subprotocol";
          __int16 v23 = 2082;
          os_log_type_t v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v5) {
          goto LABEL_4;
        }
LABEL_39:
        free(v5);
        goto LABEL_4;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v22 = "nw_ws_options_add_subprotocol";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v22 = "nw_ws_options_add_subprotocol";
        _os_log_impl( &dword_181A5C000,  v6,  v16,  "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_1822C4D54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_add_subprotocol_block_invoke(uint64_t a1, void **a2)
{
  id v2 = *a2;
  xpc_object_t v3 = xpc_string_create(*(const char **)(a1 + 32));
  xpc_array_append_value(v2, v3);

  return 1LL;
}

void sub_1822C4DA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_ws_options_set_auto_reply_ping(nw_protocol_options_t options, BOOL auto_reply_ping)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  xpc_object_t v3 = options;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ws_options_set_auto_reply_ping_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = auto_reply_ping;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v17 = "nw_ws_options_set_auto_reply_ping";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_ws_options_set_auto_reply_ping";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ws(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v17 = "nw_ws_options_set_auto_reply_ping";
          __int16 v18 = 2082;
          char v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_ws_options_set_auto_reply_ping";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_ws_options_set_auto_reply_ping";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C5080(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_auto_reply_ping_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 70) = *(_BYTE *)(a2 + 70) & 0xFE | *(_BYTE *)(a1 + 32);
  return 1LL;
}

void nw_ws_options_set_skip_handshake(nw_protocol_options_t options, BOOL skip_handshake)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  xpc_object_t v3 = options;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ws_options_set_skip_handshake_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = skip_handshake;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v17 = "nw_ws_options_set_skip_handshake";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_ws_options_set_skip_handshake";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ws(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v17 = "nw_ws_options_set_skip_handshake";
          __int16 v18 = 2082;
          char v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_ws_options_set_skip_handshake";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_ws_options_set_skip_handshake";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C5378(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_skip_handshake_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 70) = *(_BYTE *)(a2 + 70) & 0xFD | (2 * *(_BYTE *)(a1 + 32));
  return 1LL;
}

void nw_ws_options_set_prepend_data(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (nw_protocol_options_is_ws(v3))
  {
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = __nw_ws_options_set_prepend_data_block_invoke;
    v13[3] = &unk_189BC6260;
    id v14 = v4;
    nw_protocol_options_access_handle(v3, v13);

    goto LABEL_3;
  }

  __nwlog_obj();
  xpc_object_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  __int16 v18 = "nw_ws_options_set_prepend_data";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v18 = "nw_ws_options_set_prepend_data";
        _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null nw_protocol_options_is_ws(options)",  buf,  0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v18 = "nw_ws_options_set_prepend_data";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v18 = "nw_ws_options_set_prepend_data";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v18 = "nw_ws_options_set_prepend_data";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C5688( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_prepend_data_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1LL;
}

void nw_ws_options_set_client_request_handler( nw_protocol_options_t options, dispatch_queue_t client_queue, nw_ws_client_request_handler_t handler)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  xpc_object_t v5 = options;
  id v6 = client_queue;
  nw_ws_client_request_handler_t v7 = handler;
  if (!nw_protocol_options_is_ws(v5))
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v33 = "nw_ws_options_set_client_request_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v11,  "%{public}s called with null nw_protocol_options_is_ws(options)",  buf,  0xCu);
      }
    }

    else if (v30)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v33 = "nw_ws_options_set_client_request_handler";
          __int16 v34 = 2082;
          uint64_t v35 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v9) {
          goto LABEL_5;
        }
LABEL_56:
        free(v9);
        goto LABEL_5;
      }

      if (v18)
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v17,  "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl( &dword_181A5C000,  v10,  v24,  "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_1822C5DFC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_client_request_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  id v4 = _Block_copy(*(const void **)(a1 + 40));
  xpc_object_t v5 = *(void **)(a2 + 40);
  *(void *)(a2 + 40) = v4;

  return 1LL;
}

void nw_ws_options_set_permessage_deflate(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ws_options_set_permessage_deflate_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v17 = "nw_ws_options_set_permessage_deflate";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_ws_options_set_permessage_deflate";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ws(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v17 = "nw_ws_options_set_permessage_deflate";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_ws_options_set_permessage_deflate";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v17 = "nw_ws_options_set_permessage_deflate";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C6140(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_permessage_deflate_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 70) = *(_BYTE *)(a2 + 70) & 0xF7 | (8 * *(_BYTE *)(a1 + 32));
  return 1LL;
}

BOOL nw_ws_options_get_permessage_deflate(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_ws(v1))
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ws_options_get_permessage_deflate_block_invoke;
    v12[3] = &unk_189BC60A8;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ws_options_get_permessage_deflate";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_options_get_permessage_deflate";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ws(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ws_options_get_permessage_deflate";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_options_get_permessage_deflate";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_options_get_permessage_deflate";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C646C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_get_permessage_deflate_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (*(_BYTE *)(a2 + 70) & 8) != 0;
  return 1LL;
}

void nw_ws_options_set_permessage_deflate_server_context_takeover(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ws_options_set_permessage_deflate_server_context_takeover_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_context_takeover";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_context_takeover";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ws(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_context_takeover";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_context_takeover";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_context_takeover";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C6780(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_permessage_deflate_server_context_takeover_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 70) = *(_BYTE *)(a2 + 70) & 0xEF | (16 * *(_BYTE *)(a1 + 32));
  return 1LL;
}

void nw_ws_options_set_permessage_deflate_server_max_window_bits(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ws_options_set_permessage_deflate_server_max_window_bits_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_max_window_bits";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_max_window_bits";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ws(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_max_window_bits";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_max_window_bits";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_max_window_bits";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C6A78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_permessage_deflate_server_max_window_bits_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 6_Block_object_dispose(va, 8) = *(_BYTE *)(a1 + 32);
  return 1LL;
}

void nw_ws_options_set_permessage_deflate_client_context_takeover(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ws_options_set_permessage_deflate_client_context_takeover_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_context_takeover";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_context_takeover";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ws(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_context_takeover";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_context_takeover";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_context_takeover";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C6D64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_permessage_deflate_client_context_takeover_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 70) = *(_BYTE *)(a2 + 70) & 0xDF | (32 * *(_BYTE *)(a1 + 32));
  return 1LL;
}

void nw_ws_options_set_permessage_deflate_client_max_window_bits(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ws_options_set_permessage_deflate_client_max_window_bits_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_max_window_bits";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_max_window_bits";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ws(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_max_window_bits";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_max_window_bits";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_max_window_bits";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C705C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_permessage_deflate_client_max_window_bits_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 69) = *(_BYTE *)(a1 + 32);
  return 1LL;
}

void nw_ws_options_set_permessage_deflate_incoming_buffer_size(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ws_options_set_permessage_deflate_incoming_buffer_size_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    int v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v17 = "nw_ws_options_set_permessage_deflate_incoming_buffer_size";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_incoming_buffer_size";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ws(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v17 = "nw_ws_options_set_permessage_deflate_incoming_buffer_size";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_incoming_buffer_size";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_incoming_buffer_size";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C7348(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_permessage_deflate_incoming_buffer_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 60) = *(_DWORD *)(a1 + 32);
  return 1LL;
}

void nw_ws_options_set_permessage_deflate_outgoing_buffer_size(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ws_options_set_permessage_deflate_outgoing_buffer_size_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    int v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v17 = "nw_ws_options_set_permessage_deflate_outgoing_buffer_size";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_outgoing_buffer_size";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ws(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v17 = "nw_ws_options_set_permessage_deflate_outgoing_buffer_size";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_outgoing_buffer_size";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_outgoing_buffer_size";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C7634(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_permessage_deflate_outgoing_buffer_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a1 + 32);
  return 1LL;
}

BOOL nw_protocol_metadata_is_ws(nw_protocol_metadata_t metadata)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v1 = metadata;
  BOOL v2 = v1;
  if (v1)
  {
    id v3 = v1;
    id v4 = v3[1];

    if (nw_protocol_copy_ws_definition::onceToken != -1) {
      dispatch_once(&nw_protocol_copy_ws_definition::onceToken, &__block_literal_global_3592);
    }
    id v5 = (id)nw_protocol_copy_ws_definition::definition;
    BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v4, (uint64_t)v5);

    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  __int16 v19 = "nw_protocol_metadata_is_ws";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v19 = "nw_protocol_metadata_is_ws";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v19 = "nw_protocol_metadata_is_ws";
          __int16 v20 = 2082;
          BOOL v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v19 = "nw_protocol_metadata_is_ws";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        __int16 v19 = "nw_protocol_metadata_is_ws";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C7948(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_protocol_metadata_t nw_ws_create_metadata(nw_ws_opcode_t opcode)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  if (nw_protocol_copy_ws_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_ws_definition::onceToken, &__block_literal_global_3592);
  }
  id v2 = (id)nw_protocol_copy_ws_definition::definition;
  singleton = nw_protocol_metadata_create_singleton(v2);

  if (singleton)
  {
    nw_framer_message_set_value((nw_framer_message_t)singleton, "opcode", (void *)(int)opcode, 0LL);
    nw_framer_message_set_value((nw_framer_message_t)singleton, "close", (void *)0x3ED, 0LL);
    nw_framer_message_set_value((nw_framer_message_t)singleton, "permessage_deflate", (void *)1, 0LL);
    id v4 = singleton;
    goto LABEL_5;
  }

  __nwlog_obj();
  id v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v17 = "nw_ws_create_metadata";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_create_metadata";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v17 = "nw_ws_create_metadata";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_create_metadata";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ws_create_metadata";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C7C7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_ws_opcode_t nw_ws_metadata_get_opcode(nw_protocol_metadata_t metadata)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = metadata;
  if (nw_protocol_metadata_is_ws(v1))
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    int v16 = -1;
    *(void *)&buf[16] = 0x2020000000LL;
    access_value[0] = MEMORY[0x1895F87A8];
    access_value[1] = 3221225472LL;
    access_value[2] = __nw_ws_metadata_get_opcode_block_invoke;
    access_value[3] = &unk_189BC0970;
    access_value[4] = buf;
    nw_framer_message_access_value(v1, "opcode", access_value);
    nw_ws_opcode_t v2 = *(_DWORD *)(*(void *)&buf[8] + 24LL);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_opcode";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_opcode";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_opcode";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_opcode";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_opcode";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C7F9C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_metadata_get_opcode_block_invoke(uint64_t a1, int a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a2;
  return 1LL;
}

void nw_ws_metadata_set_close_code(nw_protocol_metadata_t metadata, nw_ws_close_code_t close_code)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  id v3 = metadata;
  if (nw_protocol_metadata_is_ws(v3))
  {
    nw_framer_message_set_value(v3, "close", (void *)close_code, 0LL);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v15 = "nw_ws_metadata_set_close_code";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v15 = "nw_ws_metadata_set_close_code";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata)",  buf,  0xCu);
      }
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v15 = "nw_ws_metadata_set_close_code";
          __int16 v16 = 2082;
          uint64_t v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v15 = "nw_ws_metadata_set_close_code";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v15 = "nw_ws_metadata_set_close_code";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C8284(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_ws_close_code_t nw_ws_metadata_get_close_code(nw_protocol_metadata_t metadata)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = metadata;
  if (nw_protocol_metadata_is_ws(v1))
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    int v16 = 1005;
    *(void *)&buf[16] = 0x2020000000LL;
    access_value[0] = MEMORY[0x1895F87A8];
    access_value[1] = 3221225472LL;
    access_value[2] = __nw_ws_metadata_get_close_code_block_invoke;
    access_value[3] = &unk_189BC0970;
    access_value[4] = buf;
    nw_framer_message_access_value(v1, "close", access_value);
    nw_ws_close_code_t v2 = *(_DWORD *)(*(void *)&buf[8] + 24LL);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_close_code";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_close_code";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_close_code";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_close_code";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_close_code";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C8598( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_metadata_get_close_code_block_invoke(uint64_t a1, int a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a2;
  return 1LL;
}

void nw_ws_metadata_set_pong_handler( nw_protocol_metadata_t metadata, dispatch_queue_t client_queue, nw_ws_pong_handler_t pong_handler)
{
  uint64_t v39 = *MEMORY[0x1895F89C0];
  id v5 = metadata;
  id v6 = client_queue;
  nw_ws_pong_handler_t v7 = pong_handler;
  if (!nw_protocol_metadata_is_ws(v5))
  {
    __nwlog_obj();
    char v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v36 = "nw_ws_metadata_set_pong_handler";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata)",  buf,  0xCu);
      }
    }

    else if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v36 = "nw_ws_metadata_set_pong_handler";
          __int16 v37 = 2082;
          char v38 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v13) {
          goto LABEL_5;
        }
LABEL_56:
        free(v13);
        goto LABEL_5;
      }

      if (v22)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl( &dword_181A5C000,  v14,  v28,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_1822C8D58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void __nw_ws_metadata_set_pong_handler_block_invoke_2(uint64_t a1, void *a2)
{
  if (a2)
  {
    id v4 = nw_dictionary_copy_value((uint64_t)a2, (uint64_t)"handler");
    id v5 = v4;
    if (v4)
    {
      id v6 = *(dispatch_queue_s **)(a1 + 32);
      if (v6)
      {
        block[0] = MEMORY[0x1895F87A8];
        block[1] = 3221225472LL;
        block[2] = __nw_ws_metadata_set_pong_handler_block_invoke_3;
        block[3] = &unk_189BC8740;
        id v8 = v4;
        dispatch_async(v6, block);
      }
    }
  }
}

void __nw_ws_metadata_set_pong_handler_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  nw_ws_close_code_t v2 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 89);
  (*(void (**)(uint64_t))(v1 + 16))(v1);
}

void sub_1822C8E84( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void *__Block_byref_object_copy__50676(uint64_t a1, uint64_t a2)
{
  BOOL result = _Block_copy(*(const void **)(a2 + 40));
  *(void *)(a1 + 40) = result;
  return result;
}

void __Block_byref_object_dispose__50677(uint64_t a1)
{
}

uint64_t __nw_ws_metadata_copy_pong_handler_block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (v3)
  {
    id v5 = nw_dictionary_copy_value((uint64_t)v3, (uint64_t)"handler");
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8LL);
    nw_ws_pong_handler_t v7 = *(void **)(v6 + 40);
    *(void *)(v6 + 40) = v5;

    nw_dictionary_set_value((uint64_t)v4, "handler", 0LL);
  }

  return 1LL;
}

uint64_t __Block_byref_object_copy__21(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__22(uint64_t a1)
{
}

uint64_t __nw_ws_metadata_copy_client_queue_block_invoke(uint64_t a1, void *a2)
{
  return 1LL;
}

nw_ws_response_t nw_ws_metadata_copy_server_response(nw_protocol_metadata_t metadata)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v1 = metadata;
  if (nw_protocol_metadata_is_ws(v1))
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    int v16 = __Block_byref_object_copy__21;
    os_log_type_t v17 = __Block_byref_object_dispose__22;
    id v18 = 0LL;
    access_value[0] = MEMORY[0x1895F87A8];
    access_value[1] = 3221225472LL;
    access_value[2] = __nw_ws_metadata_copy_server_response_block_invoke;
    access_value[3] = &unk_189BC0970;
    access_value[4] = buf;
    nw_framer_message_access_value(v1, "server_response", access_value);
    nw_ws_close_code_t v2 = (nw_ws_response *)*(id *)(*(void *)&buf[8] + 40LL);
    _Block_object_dispose(buf, 8);

    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ws_metadata_copy_server_response";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_copy_server_response";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ws_metadata_copy_server_response";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_copy_server_response";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_copy_server_response";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C92A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, id a24)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_metadata_copy_server_response_block_invoke(uint64_t a1, void *a2)
{
  return 1LL;
}

BOOL nw_ws_metadata_get_negotiated_permessage_deflate(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  if (nw_protocol_metadata_is_ws(v1))
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    access_value[0] = MEMORY[0x1895F87A8];
    access_value[1] = 3221225472LL;
    access_value[2] = __nw_ws_metadata_get_negotiated_permessage_deflate_block_invoke;
    access_value[3] = &unk_189BC0970;
    access_value[4] = buf;
    nw_framer_message_access_value(v1, "negotiated_permessage_deflate", access_value);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_negotiated_permessage_deflate";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_negotiated_permessage_deflate";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_negotiated_permessage_deflate";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_negotiated_permessage_deflate";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_negotiated_permessage_deflate";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C9600( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_metadata_get_negotiated_permessage_deflate_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a2 != 0;
  return 1LL;
}

void nw_ws_metadata_set_negotiated_permessage_deflate(void *a1, unsigned int a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (nw_protocol_metadata_is_ws(v3))
  {
    nw_framer_message_set_value(v3, "negotiated_permessage_deflate", (void *)a2, 0LL);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v15 = "nw_ws_metadata_set_negotiated_permessage_deflate";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v15 = "nw_ws_metadata_set_negotiated_permessage_deflate";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata)",  buf,  0xCu);
      }
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v15 = "nw_ws_metadata_set_negotiated_permessage_deflate";
          __int16 v16 = 2082;
          uint64_t v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v15 = "nw_ws_metadata_set_negotiated_permessage_deflate";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v15 = "nw_ws_metadata_set_negotiated_permessage_deflate";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C98F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_ws_metadata_get_permessage_deflate(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  if (nw_protocol_metadata_is_ws(v1))
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 1;
    access_value[0] = MEMORY[0x1895F87A8];
    access_value[1] = 3221225472LL;
    access_value[2] = __nw_ws_metadata_get_permessage_deflate_block_invoke;
    access_value[3] = &unk_189BC0970;
    access_value[4] = buf;
    nw_framer_message_access_value(v1, "permessage_deflate", access_value);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_permessage_deflate";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_permessage_deflate";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_permessage_deflate";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_permessage_deflate";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_permessage_deflate";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C9C0C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_metadata_get_permessage_deflate_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = a2 != 0;
  return 1LL;
}

void nw_ws_metadata_set_permessage_deflate(void *a1, unsigned int a2)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (nw_protocol_metadata_is_ws(v3))
  {
    nw_framer_message_set_value(v3, "permessage_deflate", (void *)a2, 0LL);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v15 = "nw_ws_metadata_set_permessage_deflate";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v15 = "nw_ws_metadata_set_permessage_deflate";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata)",  buf,  0xCu);
      }
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v15 = "nw_ws_metadata_set_permessage_deflate";
          __int16 v16 = 2082;
          uint64_t v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v15 = "nw_ws_metadata_set_permessage_deflate";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v15 = "nw_ws_metadata_set_permessage_deflate";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822C9EFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *std::vector<nw_object_wrapper_t>::__emplace_back_slow_path<nw_object *&>(uint64_t a1, void *a2)
{
  BOOL v2 = *(void **)a1;
  unint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = v3 - *(void *)a1;
  uint64_t v5 = v4 >> 3;
  unint64_t v6 = (v4 >> 3) + 1;
  if (v6 >> 61) {
    abort();
  }
  uint64_t v9 = *(void *)(a1 + 16) - (void)v2;
  if (v9 >> 2 > v6) {
    unint64_t v6 = v9 >> 2;
  }
  else {
    unint64_t v10 = v6;
  }
  if (v10)
  {
    if (v10 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    os_log_type_t v11 = (char *)operator new(8 * v10);
    char v12 = &v11[8 * v5];
    if (a2) {
      goto LABEL_10;
    }
  }

  else
  {
    os_log_type_t v11 = 0LL;
    char v12 = (char *)(8 * v5);
    if (a2)
    {
LABEL_10:
      char v13 = os_retain(a2);
      BOOL v2 = *(void **)a1;
      unint64_t v3 = *(void *)(a1 + 8);
      goto LABEL_13;
    }
  }

  char v13 = 0LL;
LABEL_13:
  char v14 = &v11[8 * v10];
  *(void *)char v12 = v13;
  os_log_type_t v15 = v12 + 8;
  if ((void *)v3 == v2)
  {
    *(void *)a1 = v12;
    *(void *)(a1 + _Block_object_dispose(va, 8) = v15;
    *(void *)(a1 + 16) = v14;
    goto LABEL_25;
  }

  unint64_t v16 = v3 - (void)v2 - 8;
  if (v16 <= 0x77
    || (unint64_t)&v11[v4 - (v16 & 0xFFFFFFFFFFFFFFF8LL) - 8] < v3
    && v3 - (v16 & 0xFFFFFFFFFFFFFFF8LL) - 8 < (unint64_t)v12)
  {
    uint64_t v17 = (void *)v3;
    do
    {
LABEL_18:
      uint64_t v18 = *--v17;
      *((void *)v12 - nw_tcp_options_set_enable_fast_open(options, 1) = v18;
      v12 -= 8;
      void *v17 = 0LL;
    }

    while (v17 != v2);
    goto LABEL_19;
  }

  uint64_t v24 = (v16 >> 3) + 1;
  uint64_t v17 = (void *)(v3 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL));
  BOOL v25 = &v11[8 * v5 - 16];
  os_log_type_t v26 = (_OWORD *)(v3 - 32);
  uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    __int128 v28 = v26[1];
    *((_OWORD *)v25 - nw_tcp_options_set_enable_fast_open(options, 1) = *v26;
    *(_OWORD *)BOOL v25 = v28;
    *os_log_type_t v26 = 0uLL;
    v26[1] = 0uLL;
    v26 -= 2;
    v25 -= 32;
    v27 -= 4LL;
  }

  while (v27);
  v12 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
  if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
    goto LABEL_18;
  }
LABEL_19:
  BOOL v2 = *(void **)a1;
  uint64_t v19 = *(void **)(a1 + 8);
  *(void *)a1 = v12;
  *(void *)(a1 + _Block_object_dispose(va, 8) = v15;
  *(void *)(a1 + 16) = v14;
  if (v19 != v2)
  {
    uint64_t v20 = v19;
    do
    {
      BOOL v22 = (void *)*--v20;
      os_log_type_t v21 = v22;
      if (v22) {
        os_release(v21);
      }
      *(v19 - nw_tcp_options_set_enable_fast_open(options, 1) = 0LL;
      uint64_t v19 = v20;
    }

    while (v20 != v2);
  }

void nw_array_insert_object_at_index(uint64_t a1, void *a2, char *a3)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  BOOL v25 = a2;
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v27 = "nw_array_insert_object_at_index";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v27 = "nw_array_insert_object_at_index";
      os_log_type_t v11 = "%{public}s called with null array";
      goto LABEL_52;
    }

    if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v20 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (!v20) {
          goto LABEL_42;
        }
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v27 = "nw_array_insert_object_at_index";
        __int16 v28 = 2082;
        os_log_type_t v29 = backtrace_string;
        os_log_type_t v21 = "%{public}s called with null array, dumping backtrace:%{public}s";
        goto LABEL_41;
      }

      if (!v20) {
        goto LABEL_23;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v27 = "nw_array_insert_object_at_index";
      os_log_type_t v11 = "%{public}s called with null array, no backtrace";
    }

    else
    {
      uint64_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v27 = "nw_array_insert_object_at_index";
      os_log_type_t v11 = "%{public}s called with null array, backtrace limit exceeded";
    }

BOOL nw_array_is_empty(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1895F89C0];
  if (a1) {
    return *(void *)(a1 + 16) == *(void *)(a1 + 24);
  }
  __nwlog_obj();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v11 = "nw_array_is_empty";
  BOOL v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v11 = "nw_array_is_empty";
        uint64_t v5 = "%{public}s called with null array";
LABEL_17:
        _os_log_impl(&dword_181A5C000, v3, v4, v5, buf, 0xCu);
      }
    }

    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v11 = "nw_array_is_empty";
          __int16 v12 = 2082;
          BOOL v13 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v3,  v4,  "%{public}s called with null array, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_18;
      }

      if (v7)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v11 = "nw_array_is_empty";
        uint64_t v5 = "%{public}s called with null array, no backtrace";
        goto LABEL_17;
      }
    }

    else
    {
      unint64_t v3 = (os_log_s *)__nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v11 = "nw_array_is_empty";
        uint64_t v5 = "%{public}s called with null array, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }

uint64_t nw_array_get_count(uint64_t result)
{
  if (result) {
    return (uint64_t)(*(void *)(result + 24) - *(void *)(result + 16)) >> 3;
  }
  return result;
}

void nw_array_set_object_at_index(uint64_t a1, void *object, char *a3)
{
  uint64_t v30 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v25 = "nw_array_set_object_at_index";
    os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint32_t v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v25 = "nw_array_set_object_at_index";
      os_log_type_t v10 = "%{public}s called with null array";
      goto LABEL_54;
    }

    if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint32_t v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v19 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (!v19) {
          goto LABEL_44;
        }
        *(_DWORD *)__int128 buf = 136446466;
        BOOL v25 = "nw_array_set_object_at_index";
        __int16 v26 = 2082;
        uint64_t v27 = backtrace_string;
        BOOL v20 = "%{public}s called with null array, dumping backtrace:%{public}s";
        goto LABEL_43;
      }

      if (!v19) {
        goto LABEL_25;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v25 = "nw_array_set_object_at_index";
      os_log_type_t v10 = "%{public}s called with null array, no backtrace";
    }

    else
    {
      uint32_t v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v25 = "nw_array_set_object_at_index";
      os_log_type_t v10 = "%{public}s called with null array, backtrace limit exceeded";
    }

BOOL nw_array_contains_object(uint64_t a1, uint64_t a2)
{
  BOOL result = 0LL;
  if (a1 && a2)
  {
    uint64_t v5 = *(void **)(a1 + 16);
    os_log_type_t v4 = *(void **)(a1 + 24);
    if (v5 != v4)
    {
      while (*v5 != a2)
      {
        if (++v5 == v4)
        {
          uint64_t v5 = v4;
          return v5 != v4;
        }
      }
    }

    return v5 != v4;
  }

  return result;
}

BOOL nw_array_remove_object(uint64_t a1, uint64_t a2)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj(0LL, a2);
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v32 = "nw_array_remove_object";
    BOOL v7 = (void *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    uint64_t v16 = __nwlog_fault(v7, &type, &v29);
    if (!(_DWORD)v16) {
      goto LABEL_51;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v29)
      {
        os_log_type_t v18 = (os_log_s *)__nwlog_obj(v16, v17);
        os_log_type_t v19 = type;
        if (!os_log_type_enabled(v18, type)) {
          goto LABEL_51;
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v32 = "nw_array_remove_object";
        BOOL v20 = "%{public}s called with null array, backtrace limit exceeded";
        goto LABEL_50;
      }

      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v18 = (os_log_s *)__nwlog_obj(backtrace_string, v24);
      os_log_type_t v19 = type;
      BOOL v25 = os_log_type_enabled(v18, type);
      if (!backtrace_string)
      {
        if (!v25) {
          goto LABEL_51;
        }
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v32 = "nw_array_remove_object";
        BOOL v20 = "%{public}s called with null array, no backtrace";
        goto LABEL_50;
      }

      if (v25)
      {
        *(_DWORD *)__int128 buf = 136446466;
        uint64_t v32 = "nw_array_remove_object";
        __int16 v33 = 2082;
        __int16 v34 = backtrace_string;
        __int16 v26 = "%{public}s called with null array, dumping backtrace:%{public}s";
LABEL_40:
        _os_log_impl(&dword_181A5C000, v18, v19, v26, buf, 0x16u);
      }

void *nw_array_remove_object_at_index(uint64_t a1, char *a2)
{
  uint64_t v36 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v31 = "nw_array_remove_object_at_index";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v31 = "nw_array_remove_object_at_index";
      uint64_t v9 = "%{public}s called with null array";
    }

    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v27 = os_log_type_enabled(v24, type);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v31 = "nw_array_remove_object_at_index";
          __int16 v32 = 2082;
          __int16 v33 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s called with null array, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v6) {
          return 0LL;
        }
        goto LABEL_34;
      }

      if (!v27) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v31 = "nw_array_remove_object_at_index";
      uint64_t v9 = "%{public}s called with null array, no backtrace";
    }

    else
    {
      uint64_t v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v31 = "nw_array_remove_object_at_index";
      uint64_t v9 = "%{public}s called with null array, backtrace limit exceeded";
    }

    BOOL v20 = v24;
    os_log_type_t v21 = v25;
    uint32_t v22 = 12;
    goto LABEL_32;
  }

  unint64_t v4 = *(void *)(a1 + 16) + 8LL * (void)a2;
  if (v4 >= *(void *)(a1 + 24))
  {
LABEL_6:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v31 = "nw_array_remove_object_at_index";
    __int16 v32 = 2048;
    __int16 v33 = a2;
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446466;
      __int16 v31 = "nw_array_remove_object_at_index";
      __int16 v32 = 2048;
      __int16 v33 = a2;
      uint64_t v9 = "%{public}s array index out of range: %lu";
LABEL_31:
      BOOL v20 = v7;
      os_log_type_t v21 = v8;
      uint32_t v22 = 22;
LABEL_32:
      _os_log_impl(&dword_181A5C000, v20, v21, v9, buf, v22);
      goto LABEL_33;
    }

    if (!v28)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v7 = (os_log_s *)gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446466;
      __int16 v31 = "nw_array_remove_object_at_index";
      __int16 v32 = 2048;
      __int16 v33 = a2;
      uint64_t v9 = "%{public}s array index out of range: %lu, backtrace limit exceeded";
      goto LABEL_31;
    }

    uint64_t v10 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v7 = (os_log_s *)gLogObj;
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v10)
    {
      if (!v11) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446466;
      __int16 v31 = "nw_array_remove_object_at_index";
      __int16 v32 = 2048;
      __int16 v33 = a2;
      uint64_t v9 = "%{public}s array index out of range: %lu, no backtrace";
      goto LABEL_31;
    }

    if (v11)
    {
      *(_DWORD *)__int128 buf = 136446722;
      __int16 v31 = "nw_array_remove_object_at_index";
      __int16 v32 = 2048;
      __int16 v33 = a2;
      __int16 v34 = 2082;
      uint64_t v35 = v10;
      _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s array index out of range: %lu, dumping backtrace:%{public}s",  buf,  0x20u);
    }

    free(v10);
LABEL_33:
    if (!v6) {
      return 0LL;
    }
LABEL_34:
    free(v6);
    return 0LL;
  }

  if (atomic_load((unsigned __int8 *)(a1 + 40)))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v31 = "nw_array_remove_object_at_index";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    __break(1u);
    goto LABEL_6;
  }

  uint64_t v12 = *(void **)v4;
  *(void *)unint64_t v4 = 0LL;
  unint64_t v13 = v4 + 8;
  uint64_t v14 = *(void *)(a1 + 24);
  if (v4 + 8 != v14)
  {
    do
    {
      if (*(void *)v4) {
        os_release(*(void **)v4);
      }
      unint64_t v15 = v4 + 8;
      *(void *)unint64_t v4 = *(void *)(v4 + 8);
      *(void *)(v4 + _Block_object_dispose(va, 8) = 0LL;
      unint64_t v16 = v4 + 16;
      v4 += 8LL;
    }

    while (v16 != v14);
    unint64_t v13 = *(void *)(a1 + 24);
    unint64_t v4 = v15;
    if (v13 == v15) {
      goto LABEL_26;
    }
    goto LABEL_22;
  }

  if (v13 != v4)
  {
LABEL_22:
    unint64_t v17 = v13;
    do
    {
      os_log_type_t v19 = *(void **)(v17 - 8);
      v17 -= 8LL;
      os_log_type_t v18 = v19;
      if (v19) {
        os_release(v18);
      }
      *(void *)(v13 - _Block_object_dispose(va, 8) = 0LL;
      unint64_t v13 = v17;
    }

    while (v17 != v4);
  }

void nw_array_remove_objects(uint64_t a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    int v24 = 136446210;
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v5 = (void **)"nw_array_remove_objects";
    char v28 = "nw_array_remove_objects";
    unint64_t v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v14 = (os_log_s *)__nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v28 = "nw_array_remove_objects";
      unint64_t v16 = "%{public}s called with null array";
      goto LABEL_60;
    }

void nw_array_remove_all_objects(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    int v18 = 136446210;
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v1 = "nw_array_remove_all_objects";
    uint32_t v22 = "nw_array_remove_all_objects";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = (os_log_s *)__nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint32_t v22 = "nw_array_remove_all_objects";
      unint64_t v13 = "%{public}s called with null array";
      goto LABEL_34;
    }

void nw_array_assign(uint64_t a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    int v16 = 136446210;
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v2 = "nw_array_assign";
    BOOL v20 = "nw_array_assign";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = (os_log_s *)__nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v20 = "nw_array_assign";
      int v9 = "%{public}s called with null to";
      goto LABEL_44;
    }

void std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>( uint64_t a1, void **a2, void **a3, unint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v8 = *(void *)(a1 + 16);
  int v9 = *(void **)a1;
  if (a4 > (v8 - *(void *)a1) >> 3)
  {
    if (v9)
    {
      uint64_t v10 = *(void **)(a1 + 8);
      BOOL v11 = *(void **)a1;
      if (v10 != v9)
      {
        os_log_type_t v12 = *(void **)(a1 + 8);
        do
        {
          uint64_t v14 = (void *)*--v12;
          BOOL v13 = v14;
          if (v14) {
            os_release(v13);
          }
          *(v10 - nw_tcp_options_set_enable_fast_open(options, 1) = 0LL;
          uint64_t v10 = v12;
        }

        while (v12 != v9);
        BOOL v11 = *(void **)a1;
      }

      *(void *)(a1 + _Block_object_dispose(va, 8) = v9;
      operator delete(v11);
      uint64_t v8 = 0LL;
      *(void *)a1 = 0LL;
      *(void *)(a1 + _Block_object_dispose(va, 8) = 0LL;
      *(void *)(a1 + 16) = 0LL;
    }

    if (a4 >> 61) {
      goto LABEL_47;
    }
    uint64_t v21 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v21 = a4;
    }
    BOOL v22 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8LL;
    unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v22) {
      unint64_t v23 = v21;
    }
    if (v23 >> 61) {
LABEL_47:
    }
      abort();
    uint64_t v24 = v23;
    uint64_t v25 = operator new(8 * v23);
    *(void *)a1 = v25;
    *(void *)(a1 + _Block_object_dispose(va, 8) = v25;
    *(void *)(a1 + 16) = &v25[v24];
    while (v6 != a3)
    {
      __int16 v26 = *v6;
      if (*v6) {
        __int16 v26 = os_retain(v26);
      }
      *v25++ = v26;
      ++v6;
    }

    *(void *)(a1 + _Block_object_dispose(va, 8) = v25;
    return;
  }

  BOOL v15 = *(void **)(a1 + 8);
  unint64_t v16 = v15 - v9;
  if (v16 >= a4)
  {
    if (a2 == a3)
    {
      if (v15 == v9)
      {
LABEL_46:
        *(void *)(a1 + _Block_object_dispose(va, 8) = v9;
        return;
      }
    }

    else
    {
      do
      {
        BOOL v20 = *v6;
        if (*v6) {
          BOOL v20 = os_retain(v20);
        }
        *v9++ = v20;
        ++v6;
      }

      while (v6 != a3);
      BOOL v15 = *(void **)(a1 + 8);
      if (v15 == v9) {
        goto LABEL_46;
      }
    }

    __int16 v29 = v15;
    do
    {
      uint64_t v31 = (void *)*--v29;
      uint64_t v30 = v31;
      if (v31) {
        os_release(v30);
      }
      *(v15 - nw_tcp_options_set_enable_fast_open(options, 1) = 0LL;
      BOOL v15 = v29;
    }

    while (v29 != v9);
    goto LABEL_46;
  }

  char v17 = &a2[v16];
  if (v15 != v9)
  {
    uint64_t v18 = 8 * v16;
    do
    {
      char v19 = *v6;
      if (*v6) {
        char v19 = os_retain(v19);
      }
      *v9++ = v19;
      ++v6;
      v18 -= 8LL;
    }

    while (v18);
    int v9 = *(void **)(a1 + 8);
  }

  BOOL v27 = v9;
  if (v17 != a3)
  {
    BOOL v27 = v9;
    do
    {
      char v28 = *v17;
      if (*v17) {
        char v28 = os_retain(v28);
      }
      *v27++ = v28;
      ++v17;
    }

    while (v17 != a3);
  }

  *(void *)(a1 + _Block_object_dispose(va, 8) = v27;
}

uint64_t nw_array_is_equal(uint64_t a1, uint64_t a2)
{
  if (a1) {
    BOOL v3 = a2 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  int v4 = v3;
  if (a1 == a2) {
    uint64_t result = 1LL;
  }
  else {
    uint64_t result = v4 ^ 1u;
  }
  if ((v4 & 1) == 0 && a1 != a2)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    uint64_t v6 = *(void *)(a1 + 24);
    uint64_t v8 = *(uint64_t **)(a2 + 16);
    if (v6 - v7 == *(void *)(a2 + 24) - (void)v8)
    {
      if (v7 == v6)
      {
        return 1LL;
      }

      else
      {
        uint64_t v9 = v7 + 8;
        do
        {
          uint64_t v10 = *v8++;
          uint64_t result = *(void *)(v9 - 8) == v10;
          BOOL v11 = *(void *)(v9 - 8) != v10 || v9 == v6;
          v9 += 8LL;
        }

        while (!v11);
      }
    }

    else
    {
      return 0LL;
    }
  }

  return result;
}

void *nw_array_create_combined_array(void *a1, void *object)
{
  BOOL v3 = a1;
  if (a1 && object)
  {
    uint64_t v4 = nw_array_create();
    std::vector<nw_object_wrapper_t>::reserve( v4 + 16,  ((uint64_t)(*((void *)object + 3) - *((void *)object + 2)) >> 3)
    + ((uint64_t)(*((void *)v3 + 3) - *((void *)v3 + 2)) >> 3));
    std::vector<nw_object_wrapper_t>::__insert_with_size[abi:nn180100]<std::__wrap_iter<nw_object_wrapper_t*>,std::__wrap_iter<nw_object_wrapper_t*>>( (int64_t *)(v4 + 16),  *(void *)(v4 + 16),  *((void ***)v3 + 2),  *((void ***)v3 + 3),  (uint64_t)(*((void *)v3 + 3) - *((void *)v3 + 2)) >> 3);
    std::vector<nw_object_wrapper_t>::__insert_with_size[abi:nn180100]<std::__wrap_iter<nw_object_wrapper_t*>,std::__wrap_iter<nw_object_wrapper_t*>>( (int64_t *)(v4 + 16),  *(void *)(v4 + 24),  *((void ***)object + 2),  *((void ***)object + 3),  (uint64_t)(*((void *)object + 3) - *((void *)object + 2)) >> 3);
    return (void *)v4;
  }

  if (a1) {
    return os_retain(a1);
  }
  if (object)
  {
    a1 = object;
    return os_retain(a1);
  }

  return (void *)nw_array_create();
}

void std::vector<nw_object_wrapper_t>::__insert_with_size[abi:nn180100]<std::__wrap_iter<nw_object_wrapper_t*>,std::__wrap_iter<nw_object_wrapper_t*>>( int64_t *a1, uint64_t a2, void **a3, void **a4, uint64_t a5)
{
  if (a5 < 1) {
    return;
  }
  uint64_t v6 = a3;
  int64_t v8 = *a1;
  unint64_t v9 = a1[1];
  uint64_t v10 = a2 - *a1;
  uint64_t v11 = v10 >> 3;
  os_log_type_t v12 = (char *)(*a1 + (v10 & 0xFFFFFFFFFFFFFFF8LL));
  int64_t v13 = a1[2];
  if (a5 > (uint64_t)(v13 - v9) >> 3)
  {
    unint64_t v14 = a5 + ((uint64_t)(v9 - v8) >> 3);
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = v13 - v8;
    if (v15 >> 2 > v14) {
      unint64_t v14 = v15 >> 2;
    }
    uint64_t v81 = a2 - *a1;
    int64_t v83 = *a1;
    unint64_t v79 = v14;
    if (v14)
    {
      if (v14 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v16 = (char *)operator new(8 * v14);
    }

    else
    {
      unint64_t v16 = 0LL;
    }

    uint64_t v23 = v11;
    uint64_t v24 = v16;
    uint64_t v25 = &v16[8 * v11];
    uint64_t v26 = 8 * a5;
    BOOL v27 = &v25[8 * a5];
    char v28 = v25;
    do
    {
      __int16 v29 = *v6;
      if (*v6) {
        __int16 v29 = os_retain(v29);
      }
      *(void *)char v28 = v29;
      v28 += 8;
      ++v6;
      v26 -= 8LL;
    }

    while (v26);
    uint64_t v30 = (char *)*a1;
    if ((char *)*a1 == v12)
    {
      uint64_t v32 = v81;
      int64_t v31 = v83;
      unint64_t v35 = v79;
      goto LABEL_37;
    }

    uint64_t v32 = v81;
    int64_t v31 = v83;
    unint64_t v33 = (v81 & 0xFFFFFFFFFFFFFFF8LL) + v83 - (void)v30 - 8;
    if (v33 >= 0x78)
    {
      unint64_t v36 = (v81 & 0xFFFFFFFFFFFFFFF8LL) - (v33 & 0xFFFFFFFFFFFFFFF8LL) - 8;
      unint64_t v37 = (unint64_t)&v24[v36];
      unint64_t v38 = v83 + v36;
      BOOL v39 = v37 >= (unint64_t)v12 || v38 >= (unint64_t)v25;
      __int16 v34 = v12;
      unint64_t v35 = v79;
      if (v39)
      {
        uint64_t v40 = (v33 >> 3) + 1;
        __int16 v34 = &v12[-8 * (v40 & 0x3FFFFFFFFFFFFFFCLL)];
        int v41 = (_OWORD *)(8 * v23 + v83 - 32);
        __int16 v42 = &v24[8 * v23 - 16];
        uint64_t v43 = v40 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          __int128 v44 = v41[1];
          *((_OWORD *)v42 - nw_tcp_options_set_enable_fast_open(options, 1) = *v41;
          *(_OWORD *)__int16 v42 = v44;
          *int v41 = 0uLL;
          v41[1] = 0uLL;
          v41 -= 2;
          v42 -= 32;
          v43 -= 4LL;
        }

        while (v43);
        v25 -= 8 * (v40 & 0x3FFFFFFFFFFFFFFCLL);
        if (v40 == (v40 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_37:
          uint64_t v46 = (char *)a1[1];
          if (v46 == v12)
          {
LABEL_78:
            unsigned int v75 = (char *)*a1;
            *a1 = (int64_t)v25;
            a1[1] = (int64_t)v27;
            a1[2] = (int64_t)&v24[8 * v35];
            if (v12 != v75)
            {
              unsigned int v76 = v12;
              do
              {
                unsigned int v78 = (void *)*((void *)v76 - 1);
                v76 -= 8;
                unsigned int v77 = v78;
                if (v78) {
                  os_release(v77);
                }
                *((void *)v12 - nw_tcp_options_set_enable_fast_open(options, 1) = 0LL;
                os_log_type_t v12 = v76;
              }

              while (v76 != v75);
            }

            if (v75) {
              operator delete(v75);
            }
            return;
          }

          unint64_t v47 = (unint64_t)&v46[-(v32 & 0xFFFFFFFFFFFFFFF8LL) - v31 - 8];
          if (v47 >= 0xA8)
          {
            unint64_t v49 = (v32 & 0xFFFFFFFFFFFFFFF8LL) + (v47 & 0xFFFFFFFFFFFFFFF8LL);
            if ((unint64_t)v27 >= v49 + v31 + 8 || v12 >= &v24[8 * a5 + 8 + v49])
            {
              uint64_t v51 = (v47 >> 3) + 1;
              uint64_t v52 = 8 * (v51 & 0x3FFFFFFFFFFFFFFCLL);
              BOOL v48 = &v12[v52];
              unint64_t v53 = &v24[8 * v23 + 16 + 8 * a5];
              uint64_t v54 = v51 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                __int128 v55 = *((_OWORD *)v12 + 1);
                *((_OWORD *)v53 - nw_tcp_options_set_enable_fast_open(options, 1) = *(_OWORD *)v12;
                *(_OWORD *)unint64_t v53 = v55;
                *(_OWORD *)os_log_type_t v12 = 0uLL;
                *((_OWORD *)v12 + nw_tcp_options_set_enable_fast_open(options, 1) = 0uLL;
                v12 += 32;
                v53 += 32;
                v54 -= 4LL;
              }

              while (v54);
              v27 += v52;
              if (v51 == (v51 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_77;
              }
            }

            else
            {
              BOOL v48 = v12;
            }
          }

          else
          {
            BOOL v48 = v12;
          }

          do
          {
            *(void *)BOOL v27 = *(void *)v48;
            v27 += 8;
            *(void *)BOOL v48 = 0LL;
            v48 += 8;
          }

          while (v48 != v46);
LABEL_77:
          os_log_type_t v12 = (char *)a1[1];
          goto LABEL_78;
        }
      }
    }

    else
    {
      __int16 v34 = v12;
      unint64_t v35 = v79;
    }

    do
    {
      uint64_t v45 = *((void *)v34 - 1);
      v34 -= 8;
      *((void *)v25 - nw_tcp_options_set_enable_fast_open(options, 1) = v45;
      v25 -= 8;
      *(void *)__int16 v34 = 0LL;
    }

    while (v34 != v30);
    goto LABEL_37;
  }

  uint64_t v80 = v10 >> 3;
  uint64_t v17 = (uint64_t)(v9 - (void)v12) >> 3;
  if (v17 >= a5)
  {
    char v19 = &a3[a5];
    uint64_t v21 = (char *)a1[1];
    goto LABEL_51;
  }

  char v19 = &a3[v17];
  if (v19 == a4)
  {
    uint64_t v21 = (char *)a1[1];
  }

  else
  {
    uint64_t v82 = a2 - *a1;
    int v84 = (_OWORD *)*a1;
    BOOL v20 = &a3[v17];
    uint64_t v21 = (char *)a1[1];
    do
    {
      BOOL v22 = *v20;
      if (*v20) {
        BOOL v22 = os_retain(v22);
      }
      *(void *)uint64_t v21 = v22;
      v21 += 8;
      ++v20;
    }

    while (v20 != a4);
    uint64_t v10 = v82;
    int64_t v8 = (int64_t)v84;
  }

  a1[1] = (int64_t)v21;
  if ((uint64_t)(v9 - (void)v12) >= 1)
  {
LABEL_51:
    unsigned int v56 = &v12[8 * a5];
    uint64_t v57 = v21 - v56;
    unsigned int v58 = &v21[-8 * a5];
    int v59 = v21;
    if ((unint64_t)v58 < v9)
    {
      unint64_t v60 = (v10 & 0xFFFFFFFFFFFFFFF8LL) + v57;
      int v61 = (char *)(v60 + v8);
      unint64_t v62 = v60 + v8 + 8;
      if (v9 > v62) {
        unint64_t v62 = v9;
      }
      unint64_t v63 = v62 + ~v8 - v60;
      if (v63 > 0xE7
        && (v21 < &v61[(v63 & 0xFFFFFFFFFFFFFFF8LL) + 8]
          ? (BOOL v64 = v58 >= &v21[(v63 & 0xFFFFFFFFFFFFFFF8LL) + 8])
          : (BOOL v64 = 1),
            v64))
      {
        uint64_t v65 = (v63 >> 3) + 1;
        uint64_t v66 = 8 * (v65 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v67 = &v58[v66];
        uint64_t v68 = v21 + 16;
        uint64_t v69 = v65 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          __int128 v70 = *((_OWORD *)v58 + 1);
          *(v68 - nw_tcp_options_set_enable_fast_open(options, 1) = *(_OWORD *)v58;
          *uint64_t v68 = v70;
          *(_OWORD *)unsigned int v58 = 0uLL;
          *((_OWORD *)v58 + nw_tcp_options_set_enable_fast_open(options, 1) = 0uLL;
          v58 += 32;
          v68 += 2;
          v69 -= 4LL;
        }

        while (v69);
        int v59 = &v21[v66];
        if (v65 == (v65 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_66;
        }
      }

      else
      {
        unint64_t v67 = &v21[-8 * a5];
        int v59 = v21;
      }

      do
      {
        *(void *)int v59 = *(void *)v67;
        v59 += 8;
        *(void *)unint64_t v67 = 0LL;
        v67 += 8;
      }

      while ((unint64_t)v67 < v9);
    }

BOOL nw_array_create_by_removal(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return nw_array_create();
  }
  uint64_t v4 = nw_array_create();
  uint64_t v5 = v4;
  if (a2)
  {
    uint64_t v7 = *(void ***)(a1 + 16);
    uint64_t v6 = *(void ***)(a1 + 24);
    while (v7 != v6)
    {
      int64_t v8 = *v7;
      if (*v7)
      {
        uint64_t v10 = *(void ***)(a2 + 16);
        unint64_t v9 = *(void ***)(a2 + 24);
        if (v10 != v9)
        {
          while (*v10 != v8)
          {
            if (++v10 == v9)
            {
              uint64_t v10 = *(void ***)(a2 + 24);
              break;
            }
          }
        }

        if (v10 == v9) {
          nw_array_append(v5, v8);
        }
      }

      ++v7;
    }
  }

  else if (v4 == a1)
  {
    return a1;
  }

  else
  {
    std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>( v4 + 16,  *(void ***)(a1 + 16),  *(void ***)(a1 + 24),  (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3);
  }

  return v5;
}

BOOL nw_array_compare(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    unint64_t v6 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
    if (a2) {
      goto LABEL_3;
    }
  }

  else
  {
    unint64_t v6 = 0LL;
    if (a2)
    {
LABEL_3:
      return 0;
    }
  }

  if (v6) {
    return 0;
  }
LABEL_4:
  if (v6)
  {
    BOOL v7 = 0;
    for (i = 0LL; i != v6; BOOL v7 = i >= v6)
    {
      uint64_t object_at_index = nw_array_get_object_at_index(a1, i);
      uint64_t v10 = nw_array_get_object_at_index(a2, i);
      ++i;
    }
  }

  else
  {
    return 1;
  }

  return v7;
}

void nw_array_review_change(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = a1;
  if (a1) {
    uint64_t v75 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
  }
  else {
    uint64_t v75 = 0LL;
  }
  unint64_t v79 = 0LL;
  uint64_t v80 = 0LL;
  uint64_t v81 = 0LL;
  if (a2) {
    std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>( (uint64_t)&v79,  *(void ***)(a2 + 16),  *(void ***)(a2 + 24),  (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 3);
  }
  uint64_t v72 = a4;
  if (v75)
  {
    unint64_t v7 = 0LL;
    int64_t v8 = 0LL;
    unint64_t v9 = 0LL;
    uint64_t v10 = v80;
    unsigned int v76 = v79;
    unsigned int v77 = 0LL;
    uint64_t v11 = v80;
    uint64_t v12 = v6;
    uint64_t v71 = v6;
    while (1)
    {
      uint64_t object_at_index = (void *)nw_array_get_object_at_index(v6, v7);
      uint64_t v15 = (char *)v11 - (char *)v76;
      BOOL v14 = v11 == v76;
      uint64_t v11 = v76;
      if (v14) {
        goto LABEL_19;
      }
      object = object_at_index;
      uint64_t v16 = 0LL;
      unint64_t v17 = v15 >> 3;
      if (v17 <= 1) {
        uint64_t v18 = 1LL;
      }
      else {
        uint64_t v18 = v17;
      }
      char v19 = v79;
      uint64_t v10 = v80;
      uint64_t v20 = v80 - v79;
      do
      {
        uint64_t v21 = nw_array_get_object_at_index(v12, v7);
        if (v20 == v16) {
          goto LABEL_104;
        }
        if ((*(unsigned int (**)(uint64_t, uint64_t, void *))(a3 + 16))(a3, v21, v19[v16]))
        {
          uint64_t v11 = &v76[v16];
          uint64_t v6 = v12;
          if (v11 + 1 == v10)
          {
            if (v10 == v11)
            {
LABEL_42:
              uint64_t v80 = v11;
              uint64_t v10 = v11;
              goto LABEL_9;
            }
          }

          else
          {
            do
            {
              if (*v11) {
                os_release(*v11);
              }
              uint64_t v23 = v11 + 1;
              *uint64_t v11 = v11[1];
              v11[1] = 0LL;
              uint64_t v24 = v11 + 2;
              ++v11;
            }

            while (v24 != v10);
            uint64_t v11 = v23;
            if (v10 == v23) {
              goto LABEL_42;
            }
          }

          int64_t v31 = v10;
          do
          {
            unint64_t v33 = *--v31;
            uint64_t v32 = v33;
            if (v33) {
              os_release(v32);
            }
            *(v10 - nw_tcp_options_set_enable_fast_open(options, 1) = 0LL;
            uint64_t v10 = v31;
          }

          while (v31 != v11);
          goto LABEL_42;
        }

        ++v16;
      }

      while (v18 != v16);
      uint64_t v11 = v10;
      uint64_t v6 = v12;
      uint64_t object_at_index = object;
LABEL_19:
      if (object_at_index) {
        BOOL v22 = os_retain(object_at_index);
      }
      else {
        BOOL v22 = 0LL;
      }
      __int128 v25 = 0uLL;
      if (v9 < v77)
      {
        *(void *)unint64_t v9 = v22;
        v9 += 8;
        goto LABEL_9;
      }

      int64_t v26 = v9 - v8;
      uint64_t v27 = (v9 - v8) >> 3;
      unint64_t v28 = v27 + 1;
      if ((v77 - v8) >> 2 > v28) {
        unint64_t v28 = (v77 - v8) >> 2;
      }
      unint64_t v29 = 0x1FFFFFFFFFFFFFFFLL;
      unint64_t v78 = v29;
      if (v29)
      {
        if (v29 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v30 = (char *)operator new(8 * v29);
        __int128 v25 = 0uLL;
      }

      else
      {
        uint64_t v30 = 0LL;
      }

      __int16 v34 = &v30[8 * v27];
      *(void *)__int16 v34 = v22;
      objecta = v34 + 8;
      if (v9 == v8)
      {
        uint64_t v6 = v71;
        unint64_t v37 = v78;
      }

      else
      {
        unint64_t v35 = v9 - v8 - 8;
        if (v35 < 0x138)
        {
          unint64_t v36 = v9;
          goto LABEL_58;
        }

        unint64_t v38 = v35 & 0xFFFFFFFFFFFFFFF8LL;
        if (&v30[v26 - 8 - (v35 & 0xFFFFFFFFFFFFFFF8LL)] > &v30[v26 - 8])
        {
          unint64_t v36 = v9;
          goto LABEL_58;
        }

        if (&v9[-v38 - 8] > v9 - 8)
        {
          unint64_t v36 = v9;
          goto LABEL_58;
        }

        unint64_t v39 = v35 >> 3;
        if (&v30[v26 - v38 - 8] < v9)
        {
          unint64_t v36 = v9;
          if (&v9[-8 * v39 - 8] < v34) {
            goto LABEL_108;
          }
        }

        unint64_t v40 = v39 + 1;
        unint64_t v36 = &v9[-8 * (v40 & 0x3FFFFFFFFFFFFFFCLL)];
        int v41 = &v30[8 * ((v9 - v8) >> 3) - 16];
        __int16 v42 = v9 - 32;
        uint64_t v43 = v40 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          __int128 v44 = *((_OWORD *)v42 + 1);
          *((_OWORD *)v41 - nw_tcp_options_set_enable_fast_open(options, 1) = *(_OWORD *)v42;
          *(_OWORD *)int v41 = v44;
          *(_OWORD *)__int16 v42 = v25;
          *((_OWORD *)v42 + nw_tcp_options_set_enable_fast_open(options, 1) = v25;
          v42 -= 32;
          v41 -= 32;
          v43 -= 4LL;
        }

        while (v43);
        v34 -= 8 * (v40 & 0x3FFFFFFFFFFFFFFCLL);
        if (v40 != (v40 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_108:
          do
          {
LABEL_58:
            uint64_t v45 = *((void *)v36 - 1);
            v36 -= 8;
            *((void *)v34 - nw_tcp_options_set_enable_fast_open(options, 1) = v45;
            v34 -= 8;
            *(void *)unint64_t v36 = 0LL;
          }

          while (v36 != v8);
        }

        uint64_t v46 = v30;
        unint64_t v47 = v9;
        do
        {
          unint64_t v49 = (void *)*((void *)v47 - 1);
          v47 -= 8;
          BOOL v48 = v49;
          if (v49) {
            os_release(v48);
          }
          *((void *)v9 - nw_tcp_options_set_enable_fast_open(options, 1) = 0LL;
          unint64_t v9 = v47;
        }

        while (v47 != v8);
        uint64_t v6 = v12;
        unint64_t v37 = v78;
        uint64_t v30 = v46;
      }

      unsigned int v77 = &v30[8 * v37];
      if (v8) {
        operator delete(v8);
      }
      unint64_t v9 = objecta;
      int64_t v8 = v34;
LABEL_9:
      if (++v7 == v75) {
        goto LABEL_68;
      }
    }
  }

  unint64_t v9 = 0LL;
  int64_t v8 = 0LL;
  uint64_t v10 = v80;
LABEL_68:
  char v50 = v79;
  unint64_t v51 = v10 - v79;
  unint64_t v52 = (v9 - v8) >> 3;
  if (v9 == v8)
  {
    uint64_t v53 = 0LL;
    if (v10 != v79)
    {
LABEL_76:
      if (v51 <= 1) {
        uint64_t v57 = 1LL;
      }
      else {
        uint64_t v57 = v51;
      }
      uint64_t v58 = v57 - 1;
      uint64_t v59 = v53 - v52 + 1;
      unint64_t v60 = v50;
      while (v51)
      {
        uint64_t v61 = (uint64_t)*v60++;
        int v62 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, BOOL))(v72 + 16))(v72, v61, 1LL, v59 == v51);
        BOOL v64 = v58-- != 0;
        if (v62)
        {
          --v51;
          if (v64) {
            continue;
          }
        }

        goto LABEL_89;
      }

uint64_t in_adjust_cksum( uint64_t a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  unsigned int v6 = a4 - a3;
  if ((int)(a4 - a3) >= 1)
  {
    unint64_t v7 = (unsigned __int8 *)(a1 + a3);
    if ((v7 & 1) != 0)
    {
      unint64_t v9 = (uint32x2_t *)(v7 + 1);
      unint64_t v8 = (unint64_t)*v7 << 8;
      --v6;
      if ((((_DWORD)v7 + 1) & 2) == 0)
      {
LABEL_4:
        if (v6 >= 0x40) {
          goto LABEL_5;
        }
        goto LABEL_34;
      }
    }

    else
    {
      unint64_t v8 = 0LL;
      unint64_t v9 = (uint32x2_t *)(a1 + a3);
    }

    unsigned int v27 = v6 - 2;
    if (v6 < 2)
    {
      uint64_t v10 = 0LL;
      if ((v6 & 1) == 0) {
        goto LABEL_18;
      }
      goto LABEL_17;
    }

    unsigned int v28 = v9->u16[0];
    unint64_t v9 = (uint32x2_t *)((char *)v9 + 2);
    v8 += v28;
    v6 -= 2;
    if (v27 >= 0x40)
    {
LABEL_5:
      uint64_t v10 = 0LL;
      _X13 = v9;
      do
      {
        __asm { PRFM            #0, [X13,#0x20] }

        unint64_t v9 = _X13 + 8;
        __asm { PRFM            #0, [X13,#0x40] }

        v8 += vaddvq_s64( vaddq_s64( vaddq_s64((int64x2_t)vaddl_u32(*_X13, _X13[4]), (int64x2_t)vaddl_u32(_X13[2], _X13[6])),  vaddq_s64( (int64x2_t)vaddl_high_u32(*(uint32x4_t *)_X13->i8, *(uint32x4_t *)_X13[4].i8),  (int64x2_t)vaddl_high_u32(*(uint32x4_t *)_X13[2].i8, *(uint32x4_t *)_X13[6].i8))));
        v6 -= 64;
        unint64_t v17 = __ROR8__(v8, 56);
        unint64_t v18 = v10 + HIDWORD(v17) + v17;
        if (v8 >> 62)
        {
          unint64_t v8 = 0LL;
          uint64_t v10 = v18;
        }

        _X13 += 8;
      }

      while (v6 > 0x3F);
      if (v6 < 0x20)
      {
LABEL_12:
        if ((v6 & 0x10) == 0) {
          goto LABEL_13;
        }
        goto LABEL_36;
      }

uint64_t in6_pseudo(unsigned __int16 *a1, unsigned __int16 *a2, int a3)
{
  unsigned int v3 = *a1;
  int v4 = *a1;
  if (v4 == 255)
  {
    if ((((v3 >> 8) & 0xF) != 2 || (BYTE1(v3) & 0xF0) == 48) && (BYTE1(v3) & 0xF) != 1) {
      goto LABEL_4;
    }
  }

  else if (v4 != 254 || (BYTE1(v3) & 0xC0) != 0x80)
  {
LABEL_4:
    v3 += a1[1];
  }

  unsigned int v5 = *a2;
  unsigned int v6 = v3 + a1[2] + a1[3] + a1[4] + a1[5] + a1[6] + a1[7] + v5;
  int v7 = *a2;
  if (v7 != 255)
  {
    if (v7 == 254 && (BYTE1(v5) & 0xC0) == 0x80) {
      goto LABEL_25;
    }
LABEL_24:
    v6 += a2[1];
    goto LABEL_25;
  }

  BOOL v10 = ((v5 >> 8) & 0xF) != 2 || (BYTE1(v5) & 0xF0) == 48;
  if (v10 && (BYTE1(v5) & 0xF) != 1) {
    goto LABEL_24;
  }
LABEL_25:
  unsigned int v11 = vaddvq_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)(a2 + 2))) + a2[6] + v6 + a2[7] + a3;
  return (unsigned __int16)(((HIWORD(v11) + (unsigned __int16)v11) >> 16)
                          + HIWORD(v11)
                          + v11
}

BOOL ___ZL24__nw_signpost_is_enabledv_block_invoke_51911()
{
  BOOL result = networkd_settings_get_BOOL((const char *)nw_setting_enable_signposts);
  _nw_signposts_enabled = result;
  return result;
}

NWConcrete_nw_read_request *nw_read_request_create_multiple( unint64_t a1, unint64_t a2, void *a3, void *a4)
{
  uint64_t v53 = *MEMORY[0x1895F89C0];
  id v8 = a3;
  id v9 = a4;
  if (v9)
  {
    if (a1 <= 1) {
      unint64_t v10 = 1LL;
    }
    else {
      unint64_t v10 = a1;
    }
    if (a2 >= 0x100) {
      unint64_t v11 = 256LL;
    }
    else {
      unint64_t v11 = a2;
    }
    if (v10 > v11)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v12 = (id)gLogObj;
      *(_DWORD *)__int128 buf = 136446722;
      uint64_t v46 = "nw_read_request_create_multiple";
      __int16 v47 = 2048;
      unint64_t v48 = v10;
      __int16 v49 = 2048;
      unint64_t v50 = v11;
      int64_t v13 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v43 = 0;
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v14 = (os_log_s *)(id)gLogObj;
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v46 = "nw_read_request_create_multiple";
          __int16 v47 = 2048;
          unint64_t v48 = v10;
          __int16 v49 = 2048;
          unint64_t v50 = v11;
          _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s min_data_count (%zu) > max_data_count (%zu)", buf, 0x20u);
        }
      }

      else if (v43)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v14 = (os_log_s *)(id)gLogObj;
        os_log_type_t v25 = type;
        BOOL v26 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)__int128 buf = 136446978;
            uint64_t v46 = "nw_read_request_create_multiple";
            __int16 v47 = 2048;
            unint64_t v48 = v10;
            __int16 v49 = 2048;
            unint64_t v50 = v11;
            __int16 v51 = 2082;
            unint64_t v52 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v14,  v25,  "%{public}s min_data_count (%zu) > max_data_count (%zu), dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(backtrace_string);
          if (!v13) {
            goto LABEL_46;
          }
          goto LABEL_45;
        }

        if (v26)
        {
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v46 = "nw_read_request_create_multiple";
          __int16 v47 = 2048;
          unint64_t v48 = v10;
          __int16 v49 = 2048;
          unint64_t v50 = v11;
          _os_log_impl( &dword_181A5C000,  v14,  v25,  "%{public}s min_data_count (%zu) > max_data_count (%zu), no backtrace",  buf,  0x20u);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v14 = (os_log_s *)(id)gLogObj;
        os_log_type_t v31 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)__int128 buf = 136446722;
          uint64_t v46 = "nw_read_request_create_multiple";
          __int16 v47 = 2048;
          unint64_t v48 = v10;
          __int16 v49 = 2048;
          unint64_t v50 = v11;
          _os_log_impl( &dword_181A5C000,  v14,  v31,  "%{public}s min_data_count (%zu) > max_data_count (%zu), backtrace limit exceeded",  buf,  0x20u);
        }
      }

      goto LABEL_43;
    }

    uint64_t v16 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_read_request);
    if (v16)
    {
      unint64_t v17 = _Block_copy(v9);
      id data_multiple_completion = v16->data_multiple_completion;
      v16->id data_multiple_completion = v17;

      objc_storeStrong((id *)&v16->connection, a3);
      v16->qos_class = qos_class_self();
      v16->min = v10;
      v16->max = v11;
      BOOL v19 = nw_array_create();
      read_array = v16->read_array;
      v16->read_array = (OS_nw_array *)v19;

      BOOL v21 = nw_array_create();
      context_array = v16->context_array;
      v16->context_array = (OS_nw_array *)v21;

      v16->variant = 3;
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_51910);
      }
      unsigned int v23 = v16;
      goto LABEL_55;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v27 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v46 = "nw_read_request_create_multiple";
    unsigned int v28 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (__nwlog_fault(v28, &type, &v43))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint32x4_t v29 = (os_log_s *)(id)gLogObj;
        os_log_type_t v30 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v46 = "nw_read_request_create_multiple";
          _os_log_impl( &dword_181A5C000,  v29,  v30,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed",  buf,  0xCu);
        }
      }

      else if (v43)
      {
        uint64_t v32 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint32x4_t v29 = (os_log_s *)(id)gLogObj;
        os_log_type_t v33 = type;
        BOOL v34 = os_log_type_enabled(v29, type);
        if (v32)
        {
          if (v34)
          {
            *(_DWORD *)__int128 buf = 136446466;
            uint64_t v46 = "nw_read_request_create_multiple";
            __int16 v47 = 2082;
            unint64_t v48 = (unint64_t)v32;
            _os_log_impl( &dword_181A5C000,  v29,  v33,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v32);
          if (!v28) {
            goto LABEL_55;
          }
          goto LABEL_54;
        }

        if (v34)
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v46 = "nw_read_request_create_multiple";
          _os_log_impl( &dword_181A5C000,  v29,  v33,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint32x4_t v29 = (os_log_s *)(id)gLogObj;
        os_log_type_t v35 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v46 = "nw_read_request_create_multiple";
          _os_log_impl( &dword_181A5C000,  v29,  v35,  "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v28)
    {
LABEL_55:

      goto LABEL_56;
    }

void sub_1822CE920(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_read_request_get_maximum_datagram_count(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    if (*((_DWORD *)v1 + 17) == 3)
    {
      uint64_t v3 = v1[10];
    }

    else
    {
      maximum_datagram_size_t count = v1[1];
      if (maximum_datagram_count) {
        maximum_datagram_size_t count = nw_read_request_get_maximum_datagram_count();
      }
      uint64_t v3 = maximum_datagram_count + 1;
    }

    goto LABEL_7;
  }

  __nwlog_obj();
  unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  unint64_t v17 = "nw_read_request_get_maximum_datagram_count";
  int v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unint64_t v17 = "nw_read_request_get_maximum_datagram_count";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null request", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          unint64_t v17 = "nw_read_request_get_maximum_datagram_count";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null request, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        unint64_t v17 = "nw_read_request_get_maximum_datagram_count";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null request, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unint64_t v17 = "nw_read_request_get_maximum_datagram_count";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null request, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822CEBF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_read_request_fail(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  if (v3)
  {
    posix_CFErrorRef error = nw_error_create_posix_error(a2);
    unsigned int v5 = (void *)v3[19];
    v3[19] = posix_error;

    nw_read_request_report(v3, 0LL);
    goto LABEL_3;
  }

  __nwlog_obj();
  unsigned int v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  unint64_t v17 = "nw_read_request_fail";
  int v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unint64_t v17 = "nw_read_request_fail";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null request", buf, 0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          unint64_t v17 = "nw_read_request_fail";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null request, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        unint64_t v17 = "nw_read_request_fail";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null request, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unint64_t v17 = "nw_read_request_fail";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null request, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822CEEB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_read_request_report(void *a1, void *a2)
{
  uint64_t v166 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if ((*((_BYTE *)v3 + 176) & 1) == 0)
  {
    *((_BYTE *)v3 + 176) |= 1u;
    switch(*((_DWORD *)v3 + 17))
    {
      case 0:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unsigned int v5 = (os_log_s *)(id)gLogObj;
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int128 v163 = "nw_read_request_report";
          _os_log_impl(&dword_181A5C000, v5, OS_LOG_TYPE_ERROR, "%{public}s Invalid request", buf, 0xCu);
        }

        goto LABEL_5;
      case 1:
        id v30 = *((id *)v3 + 16);
        os_log_type_t v31 = (void *)*((void *)v3 + 16);
        *((void *)v3 + 16) = 0LL;

        if (!*((void *)v3 + 7))
        {
          (*(void (**)(void))(*((void *)v3 + 3) + 16LL))();
          goto LABEL_111;
        }

        uint64_t v32 = (void *)*((void *)v3 + 19);
        if (!v32) {
          goto LABEL_110;
        }
        os_log_type_t v33 = v32;
        int v34 = v33[2];

        if (v34 == 1 && nw_error_get_error_code(*((nw_error_t *)v3 + 19)) == 89)
        {
          uint64_t v35 = *(void *)(*((void *)v3 + 7) + 16LL);
          if (v35 && !nw_path_parameters_get_logging_disabled(*(void *)(v35 + 104)))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            unint64_t v36 = (os_log_s *)(id)gconnectionLogObj;
            if (!os_log_type_enabled(v36, OS_LOG_TYPE_INFO)) {
              goto LABEL_109;
            }
            int v37 = *(_DWORD *)(*((void *)v3 + 7) + 448LL);
            *(_DWORD *)__int128 buf = 136446466;
            __int128 v163 = "nw_read_request_report";
            __int16 v164 = 1024;
            *(_DWORD *)uint64_t v165 = v37;
            os_log_type_t v38 = "%{public}s [C%u] Receive cancelled";
            uint64_t v39 = v36;
            os_log_type_t v40 = OS_LOG_TYPE_INFO;
            uint32_t v41 = 18;
LABEL_108:
            _os_log_impl(&dword_181A5C000, v39, v40, v38, buf, v41);
LABEL_109:
          }
        }

        else
        {
          uint64_t v92 = *(void *)(*((void *)v3 + 7) + 16LL);
          if (v92 && !nw_path_parameters_get_logging_disabled(*(void *)(v92 + 104)))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_24_44325);
            }
            unint64_t v36 = (os_log_s *)(id)gconnectionLogObj;
            if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
              goto LABEL_109;
            }
            int v93 = *(_DWORD *)(*((void *)v3 + 7) + 448LL);
            uint64_t v94 = *((void *)v3 + 19);
            *(_DWORD *)__int128 buf = 136446722;
            __int128 v163 = "nw_read_request_report";
            __int16 v164 = 1024;
            *(_DWORD *)uint64_t v165 = v93;
            *(_WORD *)&v165[4] = 2114;
            *(void *)&v165[6] = v94;
            os_log_type_t v38 = "%{public}s [C%u] Receive failed with error %{public}@";
            uint64_t v39 = v36;
            os_log_type_t v40 = OS_LOG_TYPE_ERROR;
            uint32_t v41 = 28;
            goto LABEL_108;
          }
        }

void sub_1822CFF10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL22nw_read_request_reportP26NWConcrete_nw_read_requestPU28objcproto17OS_dispatch_queue8NSObject_block_invoke( uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void))(*(void *)(a1 + 56) + 16LL))( *(void *)(a1 + 56),  *(void *)(a1 + 32),  *(void *)(a1 + 40),  *(unsigned __int8 *)(a1 + 64),  *(void *)(a1 + 48));
}

uint64_t ___ZL22nw_read_request_reportP26NWConcrete_nw_read_requestPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_2( void *a1, unint64_t a2, void *a3)
{
  id v6 = a3;
  objc_storeStrong((id *)(*(void *)(*(void *)(a1[5] + 8LL) + 24LL) + 8 * a2), a3);
  if (a1[7] == a1[8])
  {
    uint64_t v7 = nw_array_get_object_at_index(*(void *)(a1[4] + 168LL), a2);
    uint64_t v8 = *(void *)(*(void *)(a1[6] + 8LL) + 24LL);
    uint64_t v9 = *(void **)(v8 + 8 * a2);
    *(void *)(v8 + 8 * a2) = v7;
  }

  return 1LL;
}

void ___ZL22nw_read_request_reportP26NWConcrete_nw_read_requestPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_102( void *a1)
{
  BOOL v2 = *(void **)(*(void *)(a1[6] + 8LL) + 24LL);
  if (v2 || *(void *)(*(void *)(a1[7] + 8LL) + 24LL))
  {
    if (a1[8])
    {
      unint64_t v3 = 0LL;
      do
      {
        uint64_t v4 = *(void *)(*(void *)(a1[6] + 8LL) + 24LL);
        if (v4)
        {
          unsigned int v5 = *(void **)(v4 + 8 * v3);
          if (v5)
          {
            *(void *)(v4 + 8 * v3) = 0LL;
          }
        }

        uint64_t v6 = *(void *)(*(void *)(a1[7] + 8LL) + 24LL);
        if (v6)
        {
          uint64_t v7 = *(void **)(v6 + 8 * v3);
          if (v7)
          {
            *(void *)(v6 + 8 * v3) = 0LL;
          }
        }

        ++v3;
      }

      while (v3 < a1[8]);
      BOOL v2 = *(void **)(*(void *)(a1[6] + 8LL) + 24LL);
    }

    if (v2)
    {
      free(v2);
      *(void *)(*(void *)(a1[6] + 8LL) + 24LL) = 0LL;
    }

    uint64_t v8 = *(void **)(*(void *)(a1[7] + 8LL) + 24LL);
    if (v8)
    {
      free(v8);
      *(void *)(*(void *)(a1[7] + 8LL) + 24LL) = 0LL;
    }
  }

uint64_t ___ZL22nw_read_request_reportP26NWConcrete_nw_read_requestPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_103( uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  *(void *)(a1 + 40),  *(unsigned int *)(a1 + 48));
}

uint64_t ___ZL22nw_read_request_reportP26NWConcrete_nw_read_requestPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_104( uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void))(*(void *)(a1 + 56) + 16LL))( *(void *)(a1 + 56),  *(void *)(*(void *)(a1 + 32) + 88LL),  *(void *)(a1 + 40),  *(unsigned __int8 *)(a1 + 64),  *(void *)(a1 + 48));
}

uint64_t __Block_byref_object_copy__52020(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__52021(uint64_t a1)
{
}

uint64_t __nw_read_request_receive_block_invoke( uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  id v9 = a2;
  if (*(_DWORD *)(a1 + 72) < a5) {
    a5 = *(_DWORD *)(a1 + 72);
  }
  uint64_t v24 = 0LL;
  uint32_t v25 = &v24;
  uint64_t v26 = 0x2020000000LL;
  uint64_t v27 = 0LL;
  unint64_t v10 = *(void **)(*(void *)(a1 + 32) + 96LL);
  v22[0] = MEMORY[0x1895F87A8];
  v22[1] = 3221225472LL;
  v22[2] = __nw_read_request_receive_block_invoke_2;
  v22[3] = &unk_189BC0A00;
  v22[4] = &v24;
  v22[5] = a4;
  unsigned int v23 = a5;
  nw_fd_wrapper_get_fd(v10, v22);
  unint64_t v11 = v25[3];
  if (v11)
  {
    if (v11 == -1LL)
    {
      posix_CFErrorRef error = nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8));
      uint64_t v13 = *(void *)(a1 + 32);
      os_log_type_t v14 = *(void **)(v13 + 152);
      *(void *)(v13 + 152) = posix_error;

      nw_read_request_report(*(void **)(a1 + 32), 0LL);
      uint64_t v15 = *(void *)(*(void *)(a1 + 40) + 8LL);
      uint64_t v16 = *(void **)(v15 + 40);
      *(void *)(v15 + 40) = 0LL;

      uint64_t v17 = 0LL;
    }

    else if (v11 >= a5)
    {
      *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) += v11;
      uint64_t v17 = 1LL;
    }

    else
    {
      dispatch_data_t subrange = dispatch_data_create_subrange( *(dispatch_data_t *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL),  v11 + a3,  *(void *)(a1 + 64) - (v11 + a3));
      uint64_t v19 = *(void *)(*(void *)(a1 + 40) + 8LL);
      uint64_t v20 = *(void **)(v19 + 40);
      *(void *)(v19 + 40) = subrange;

      uint64_t v17 = 0LL;
      *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8LL) + 24LL) += *((_DWORD *)v25 + 6);
      *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 1;
    }
  }

  else
  {
    uint64_t v17 = 0LL;
    *(_BYTE *)(*(void *)(a1 + 32) + 176LL) |= 8u;
  }

  _Block_object_dispose(&v24, 8);

  return v17;
}

void sub_1822D03BC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  _Unwind_Resume(a1);
}

void ___ZL34nw_read_request_start_file_updatesP26NWConcrete_nw_read_request_block_invoke(uint64_t a1)
{
  WeakRetained = (const void **)objc_loadWeakRetained((id *)(a1 + 32));
  BOOL v2 = WeakRetained;
  if (WeakRetained)
  {
    unint64_t v3 = _Block_copy(WeakRetained[4]);
    uint64_t v4 = v3;
    if (v3)
    {
      unsigned int v5 = (void *)v2[7];
      dispatch_qos_class_t v6 = *((_DWORD *)v2 + 16);
      v7[0] = MEMORY[0x1895F87A8];
      v7[1] = 3221225472LL;
      v7[2] = ___ZL34nw_read_request_start_file_updatesP26NWConcrete_nw_read_request_block_invoke_2;
      v7[3] = &unk_189BC91E8;
      id v9 = v3;
      uint64_t v8 = v2;
      nw_connection_async_client_if_needed_with_override(v5, 0LL, v6, v7);
    }
  }
}

void sub_1822D04A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZL34nw_read_request_start_file_updatesP26NWConcrete_nw_read_request_block_invoke_2(uint64_t a1)
{
  if (((*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16LL))() & 1) == 0)
  {
    BOOL v2 = *(void **)(a1 + 32);
    unint64_t v3 = -[NWConcrete_nw_error initWithDomain:code:](objc_alloc(&OBJC_CLASS___NWConcrete_nw_error), 1, 89);
    nw_read_request_report_error_with_override(v2, 0LL, v3);
  }

void sub_1822D0550( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t __nw_read_request_receive_block_invoke_2(uint64_t a1, int __fd)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = write( __fd,  *(const void **)(a1 + 40),  *(unsigned int *)(a1 + 48));
  return 1LL;
}

void __nw_http_alt_svc_storage_copy_shared_block_invoke()
{
  uint64_t v0 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_http_alt_svc_storage);
  uint64_t v1 = (void *)nw_http_alt_svc_storage_copy_shared_storage;
  nw_http_alt_svc_storage_copy_shared_storage = (uint64_t)v0;

  uint64_t v2 = [MEMORY[0x189601F60] sharedPersistentStore];
  unint64_t v3 = *(void **)(nw_http_alt_svc_storage_copy_shared_storage + 8);
  *(void *)(nw_http_alt_svc_storage_copy_shared_storage + _Block_object_dispose(va, 8) = v2;
}

NWConcrete_nw_http_alt_svc_storage *nw_http_alt_svc_storage_create_ns(void *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = objc_alloc_init(&OBJC_CLASS___NWConcrete_nw_http_alt_svc_storage);
  storage = v2->storage;
  v2->storage = v1;

  return v2;
}

void nw_http_alt_svc_parse_and_set( void *a1, const char *a2, unsigned int a3, const char *a4, const char *a5, void *a6)
{
  uint64_t v83 = *MEMORY[0x1895F89C0];
  id v9 = a1;
  id v73 = a6;
  unint64_t v74 = v9;
  if (!v9)
  {
    __nwlog_obj();
    int v53 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
    uint64_t v54 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v78 = OS_LOG_TYPE_ERROR;
    char v77 = 0;
    if (v78 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unsigned int v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v56 = v78;
      if (!os_log_type_enabled(v55, v78)) {
        goto LABEL_107;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
      uint32x4_t v57 = "%{public}s called with null storage";
LABEL_106:
      _os_log_impl(&dword_181A5C000, v55, v56, v57, buf, 0xCu);
      goto LABEL_107;
    }

    if (!v77)
    {
      __nwlog_obj();
      unsigned int v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v56 = v78;
      if (os_log_type_enabled(v55, v78))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
        uint32x4_t v57 = "%{public}s called with null storage, backtrace limit exceeded";
        goto LABEL_106;
      }

      goto LABEL_107;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    unsigned __int32 v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v62 = v78;
    BOOL v63 = os_log_type_enabled(v61, v78);
    if (backtrace_string)
    {
      if (!v63) {
        goto LABEL_98;
      }
      *(_DWORD *)__int128 buf = 136446466;
      unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
      __int16 v81 = 2082;
      int v82 = backtrace_string;
      unsigned int v64 = "%{public}s called with null storage, dumping backtrace:%{public}s";
      goto LABEL_97;
    }

    if (!v63) {
      goto LABEL_117;
    }
    *(_DWORD *)__int128 buf = 136446210;
    unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
    uint64_t v67 = "%{public}s called with null storage, no backtrace";
LABEL_116:
    _os_log_impl(&dword_181A5C000, v61, v62, v67, buf, 0xCu);
    goto LABEL_117;
  }

  if (!a2)
  {
    __nwlog_obj();
    uint32x4_t v58 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
    uint64_t v54 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v78 = OS_LOG_TYPE_ERROR;
    char v77 = 0;
    if (v78 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unsigned int v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v56 = v78;
      if (!os_log_type_enabled(v55, v78)) {
        goto LABEL_107;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
      uint32x4_t v57 = "%{public}s called with null hostname";
      goto LABEL_106;
    }

    if (!v77)
    {
      __nwlog_obj();
      unsigned int v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v56 = v78;
      if (os_log_type_enabled(v55, v78))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
        uint32x4_t v57 = "%{public}s called with null hostname, backtrace limit exceeded";
        goto LABEL_106;
      }

      goto LABEL_107;
    }

    backtrace_string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    unsigned __int32 v61 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v62 = v78;
    BOOL v65 = os_log_type_enabled(v61, v78);
    if (backtrace_string)
    {
      if (!v65) {
        goto LABEL_98;
      }
      *(_DWORD *)__int128 buf = 136446466;
      unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
      __int16 v81 = 2082;
      int v82 = backtrace_string;
      unsigned int v64 = "%{public}s called with null hostname, dumping backtrace:%{public}s";
      goto LABEL_97;
    }

    if (!v65) {
      goto LABEL_117;
    }
    *(_DWORD *)__int128 buf = 136446210;
    unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
    uint64_t v67 = "%{public}s called with null hostname, no backtrace";
    goto LABEL_116;
  }

  if (!a3)
  {
    __nwlog_obj();
    os_log_type_t v59 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
    uint64_t v54 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v78 = OS_LOG_TYPE_ERROR;
    char v77 = 0;
    if (v78 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unsigned int v55 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v56 = v78;
      if (os_log_type_enabled(v55, v78))
      {
        *(_DWORD *)__int128 buf = 136446210;
        unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
        uint32x4_t v57 = "%{public}s called with null port";
        goto LABEL_106;
      }

void check_certs_and_store_entry(void *a1, void *a2, void *a3)
{
  uint64_t v45 = *MEMORY[0x1895F89C0];
  unsigned int v5 = a1;
  id v6 = a2;
  id v7 = a3;
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x189604DB0], 0LL, MEMORY[0x189605228]);
  id v9 = (sec_protocol_metadata *)v7;
  handler[0] = MEMORY[0x1895F87A8];
  handler[1] = 3221225472LL;
  handler[2] = __check_certs_and_store_entry_block_invoke;
  handler[3] = &__block_descriptor_40_e38_v16__0__NSObject_OS_sec_certificate__8l;
  void handler[4] = Mutable;
  sec_protocol_metadata_access_peer_certificate_chain(v9, handler);
  [v6 alternateHost];
  size_t v10 = (void *)objc_claimAutoreleasedReturnValue();
  __int128 v38 = 0u;
  __int128 v39 = 0u;
  __int128 v40 = 0u;
  __int128 v41 = 0u;
  unint64_t v11 = Mutable;
  uint64_t v31 = -[__CFArray countByEnumeratingWithState:objects:count:]( v11,  "countByEnumeratingWithState:objects:count:",  &v38,  buf,  16LL);
  if (v31)
  {
    uint64_t v12 = *(void *)v39;
    id v29 = v6;
    id v30 = v5;
    uint64_t v27 = *(void *)v39;
    uint64_t v28 = v9;
    uint64_t v32 = v11;
    do
    {
      for (uint64_t i = 0LL; i != v31; ++i)
      {
        if (*(void *)v39 != v12) {
          objc_enumerationMutation(v11);
        }
        int v14 = (void *)SecCertificateCopyDNSNames();
        __int128 v34 = 0u;
        __int128 v35 = 0u;
        __int128 v36 = 0u;
        __int128 v37 = 0u;
        id v15 = v14;
        uint64_t v16 = [v15 countByEnumeratingWithState:&v34 objects:v42 count:16];
        if (v16)
        {
          uint64_t v17 = v16;
          uint64_t v18 = *(void *)v35;
          while (2)
          {
            for (uint64_t j = 0LL; j != v17; ++j)
            {
              if (*(void *)v35 != v18) {
                objc_enumerationMutation(v15);
              }
              uint64_t v20 = *(void **)(*((void *)&v34 + 1) + 8 * j);
              if ([v20 isEqualToString:v10]) {
                goto LABEL_26;
              }
              if ([v20 hasPrefix:@"*"]
                && (unint64_t)[v20 length] >= 2)
              {
                [v20 substringFromIndex:1];
                int v21 = (void *)objc_claimAutoreleasedReturnValue();
                uint64_t v22 = [v10 rangeOfString:@"."];
                if (v23)
                {
                  [v10 substringFromIndex:v22];
                  int v24 = (void *)objc_claimAutoreleasedReturnValue();
                  char v25 = [v24 isEqualToString:v21];

                  if ((v25 & 1) != 0)
                  {

LABEL_26:
                    unint64_t v11 = v32;

                    id v6 = v29;
                    unsigned int v5 = v30;
                    [v30[1] storeHTTPServiceEntry:v29];
                    id v9 = v28;
                    goto LABEL_27;
                  }
                }
              }
            }

            uint64_t v17 = [v15 countByEnumeratingWithState:&v34 objects:v42 count:16];
            if (v17) {
              continue;
            }
            break;
          }
        }

        unint64_t v11 = v32;
        uint64_t v12 = v27;
      }

      id v6 = v29;
      unsigned int v5 = v30;
      id v9 = v28;
      uint64_t v31 = -[__CFArray countByEnumeratingWithState:objects:count:]( v32,  "countByEnumeratingWithState:objects:count:",  &v38,  buf,  16LL);
    }

    while (v31);
  }

  if (gLogDatapath)
  {
    __nwlog_obj();
    int v26 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136446210;
      id v44 = "check_certs_and_store_entry";
      _os_log_impl( &dword_181A5C000,  v26,  OS_LOG_TYPE_DEBUG,  "%{public}s Ignoring the alternative service header since it is not covered under the setting origin's certificate",  buf,  0xCu);
    }
  }

void __check_certs_and_store_entry_block_invoke(uint64_t a1, sec_certificate_t certificate)
{
  SecCertificateRef v3 = sec_certificate_copy_ref(certificate);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v3);
  if (v3) {
    CFRelease(v3);
  }
}

uint64_t __Block_byref_object_copy__52210(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__52211(uint64_t a1)
{
}

void __34__nw_ip_channel_inbox_description__block_invoke(uint64_t a1)
{
  uint64_t v134 = *MEMORY[0x1895F89C0];
  uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 24LL);
  if (v2) {
    goto LABEL_69;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v3 = (id)gLogObj;
  uint64_t v4 = (unsigned __int8 *)_os_log_send_and_compose_impl();

  if (v4 == &v72)
  {
LABEL_68:
    CFStringRef v67 = CFStringCreateWithFormat( (CFAllocatorRef)*MEMORY[0x189604DB0],  0LL,  @"flow: %@, local: %s, scope: %u, protocol: %u",  *(void *)(*(void *)(a1 + 32) + 72LL),  &v72,  *(unsigned int *)(*(void *)(a1 + 32) + 160LL),  *(unsigned __int8 *)(*(void *)(a1 + 32) + 166LL));
    uint64_t v68 = *(void *)(a1 + 32);
    uint64_t v69 = *(void **)(v68 + 24);
    *(void *)(v68 + 24) = v67;

    uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 24LL);
LABEL_69:
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 40LL), v2);
    return;
  }

  if (v4)
  {
LABEL_4:
    int v5 = v72;
    *uint64_t v4 = v72;
    if (v5)
    {
      int v6 = v73;
      v4[1] = v73;
      if (v6)
      {
        int v7 = v74;
        v4[2] = v74;
        if (v7)
        {
          int v8 = v75;
          v4[3] = v75;
          if (v8)
          {
            int v9 = v76;
            void v4[4] = v76;
            if (v9)
            {
              int v10 = v77;
              v4[5] = v77;
              if (v10)
              {
                int v11 = v78;
                v4[6] = v78;
                if (v11)
                {
                  int v12 = v79;
                  v4[7] = v79;
                  if (v12)
                  {
                    int v13 = v80;
                    v4[8] = v80;
                    if (v13)
                    {
                      int v14 = v81;
                      v4[9] = v81;
                      if (v14)
                      {
                        int v15 = v82;
                        v4[10] = v82;
                        if (v15)
                        {
                          int v16 = v83;
                          v4[11] = v83;
                          if (v16)
                          {
                            int v17 = v84;
                            v4[12] = v84;
                            if (v17)
                            {
                              int v18 = v85;
                              v4[13] = v85;
                              if (v18)
                              {
                                int v19 = v86;
                                v4[14] = v86;
                                if (v19)
                                {
                                  int v20 = v87;
                                  v4[15] = v87;
                                  if (v20)
                                  {
                                    int v21 = v88;
                                    v4[16] = v88;
                                    if (v21)
                                    {
                                      int v22 = v89;
                                      v4[17] = v89;
                                      if (v22)
                                      {
                                        int v23 = v90;
                                        v4[18] = v90;
                                        if (v23)
                                        {
                                          int v24 = v91;
                                          v4[19] = v91;
                                          if (v24)
                                          {
                                            int v25 = v92;
                                            v4[20] = v92;
                                            if (v25)
                                            {
                                              int v26 = v93;
                                              v4[21] = v93;
                                              if (v26)
                                              {
                                                int v27 = v94;
                                                v4[22] = v94;
                                                if (v27)
                                                {
                                                  int v28 = v95;
                                                  v4[23] = v95;
                                                  if (v28)
                                                  {
                                                    int v29 = v96;
                                                    v4[24] = v96;
                                                    if (v29)
                                                    {
                                                      int v30 = v97;
                                                      v4[25] = v97;
                                                      if (v30)
                                                      {
                                                        int v31 = v98;
                                                        v4[26] = v98;
                                                        if (v31)
                                                        {
                                                          int v32 = v99;
                                                          v4[27] = v99;
                                                          if (v32)
                                                          {
                                                            int v33 = v100;
                                                            v4[28] = v100;
                                                            if (v33)
                                                            {
                                                              int v34 = v101;
                                                              v4[29] = v101;
                                                              if (v34)
                                                              {
                                                                int v35 = v102;
                                                                v4[30] = v102;
                                                                if (v35)
                                                                {
                                                                  int v36 = v103;
                                                                  v4[31] = v103;
                                                                  if (v36)
                                                                  {
                                                                    int v37 = v104;
                                                                    v4[32] = v104;
                                                                    if (v37)
                                                                    {
                                                                      int v38 = v105;
                                                                      v4[33] = v105;
                                                                      if (v38)
                                                                      {
                                                                        int v39 = v106;
                                                                        v4[34] = v106;
                                                                        if (v39)
                                                                        {
                                                                          int v40 = v107;
                                                                          v4[35] = v107;
                                                                          if (v40)
                                                                          {
                                                                            int v41 = v108;
                                                                            v4[36] = v108;
                                                                            if (v41)
                                                                            {
                                                                              int v42 = v109;
                                                                              v4[37] = v109;
                                                                              if (v42)
                                                                              {
                                                                                int v43 = v110;
                                                                                v4[38] = v110;
                                                                                if (v43)
                                                                                {
                                                                                  int v44 = v111;
                                                                                  v4[39] = v111;
                                                                                  if (v44)
                                                                                  {
                                                                                    int v45 = v112;
                                                                                    v4[40] = v112;
                                                                                    if (v45)
                                                                                    {
                                                                                      int v46 = v113;
                                                                                      v4[41] = v113;
                                                                                      if (v46)
                                                                                      {
                                                                                        int v47 = v114;
                                                                                        v4[42] = v114;
                                                                                        if (v47)
                                                                                        {
                                                                                          int v48 = v115;
                                                                                          v4[43] = v115;
                                                                                          if (v48)
                                                                                          {
                                                                                            int v49 = v116;
                                                                                            v4[44] = v116;
                                                                                            if (v49)
                                                                                            {
                                                                                              int v50 = v117;
                                                                                              v4[45] = v117;
                                                                                              if (v50)
                                                                                              {
                                                                                                int v51 = v118;
                                                                                                v4[46] = v118;
                                                                                                if (v51)
                                                                                                {
                                                                                                  int v52 = v119;
                                                                                                  v4[47] = v119;
                                                                                                  if (v52)
                                                                                                  {
                                                                                                    int v53 = v120;
                                                                                                    v4[48] = v120;
                                                                                                    if (v53)
                                                                                                    {
                                                                                                      int v54 = v121;
                                                                                                      v4[49] = v121;
                                                                                                      if (v54)
                                                                                                      {
                                                                                                        int v55 = v122;
                                                                                                        v4[50] = v122;
                                                                                                        if (v55)
                                                                                                        {
                                                                                                          int v56 = v123;
                                                                                                          v4[51] = v123;
                                                                                                          if (v56)
                                                                                                          {
                                                                                                            int v57 = v124;
                                                                                                            v4[52] = v124;
                                                                                                            if (v57)
                                                                                                            {
                                                                                                              int v58 = v125;
                                                                                                              v4[53] = v125;
                                                                                                              if (v58)
                                                                                                              {
                                                                                                                int v59 = v126;
                                                                                                                v4[54] = v126;
                                                                                                                if (v59)
                                                                                                                {
                                                                                                                  int v60 = v127;
                                                                                                                  v4[55] = v127;
                                                                                                                  if (v60)
                                                                                                                  {
                                                                                                                    int v61 = v128;
                                                                                                                    v4[56] = v128;
                                                                                                                    if (v61)
                                                                                                                    {
                                                                                                                      int v62 = v129;
                                                                                                                      v4[57] = v129;
                                                                                                                      if (v62)
                                                                                                                      {
                                                                                                                        int v63 = v130;
                                                                                                                        v4[58] = v130;
                                                                                                                        if (v63)
                                                                                                                        {
                                                                                                                          int v64 = v131;
                                                                                                                          v4[59] = v131;
                                                                                                                          if (v64)
                                                                                                                          {
                                                                                                                            int v65 = v132;
                                                                                                                            v4[60] = v132;
                                                                                                                            if (v65)
                                                                                                                            {
                                                                                                                              int v66 = v133;
                                                                                                                              v4[61] = v133;
                                                                                                                              if (v66) {
                                                                                                                                v4[62] = 0;
                                                                                                                              }
                                                                                                                            }
                                                                                                                          }
                                                                                                                        }
                                                                                                                      }
                                                                                                                    }
                                                                                                                  }
                                                                                                                }
                                                                                                              }
                                                                                                            }
                                                                                                          }
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    free(v4);
    goto LABEL_68;
  }

  __nwlog_obj();
  id v70 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v70, OS_LOG_TYPE_ERROR);
  char v71 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v71))
  {
    free(v71);
    goto LABEL_4;
  }

  __break(1u);
}

void sub_1822D3638(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_ip_channel_inbox_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v4 = a1->handle;
    if (v4)
    {
      if (a2)
      {
        *(void *)os_log_type_t type = 0LL;
        int v42 = type;
        __int128 v45 = 0u;
        __int128 v46 = 0u;
        memset(buf, 0, sizeof(buf));
        uint64_t v5 = MEMORY[0x1895F87A8];
        while (((unsigned int (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, os_log_type_t *))a2->callbacks->get_input_frames)( a2,  a1,  1LL,  0xFFFFFFFFLL,  0xFFFFFFFFLL,  type))
        {
          BOOL v6 = nw_array_create();
          v33[0] = v5;
          v33[1] = 3221225472LL;
          int v34 = ___ZL35nw_ip_channel_inbox_input_availableP11nw_protocolS0__block_invoke;
          int v35 = &unk_189BC0B50;
          int v38 = type;
          id v36 = v4;
          int v39 = a2;
          id v7 = (id)v6;
          id v37 = v7;
          int v40 = buf;
          uint64_t v8 = *(void *)type;
          do
          {
            if (!v8) {
              break;
            }
            uint64_t v9 = *(void *)(v8 + 32);
            char v10 = ((uint64_t (*)(void *))v34)(v33);
            uint64_t v8 = v9;
          }

          while ((v10 & 1) != 0);
        }

        goto LABEL_63;
      }

      __nwlog_obj();
      int v19 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
      int v16 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      char v43 = 0;
      if (__nwlog_fault(v16, type, &v43))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __nwlog_obj();
          int v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v20 = type[0];
          if (os_log_type_enabled(v17, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
            _os_log_impl(&dword_181A5C000, v17, v20, "%{public}s called with null from", buf, 0xCu);
          }
        }

        else if (v43)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          int v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v28 = type[0];
          BOOL v29 = os_log_type_enabled(v17, type[0]);
          if (backtrace_string)
          {
            if (v29)
            {
              *(_DWORD *)__int128 buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
              *(_WORD *)&_BYTE buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v17,  v28,  "%{public}s called with null from, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            if (!v16) {
              goto LABEL_63;
            }
            goto LABEL_62;
          }

          if (v29)
          {
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
            _os_log_impl(&dword_181A5C000, v17, v28, "%{public}s called with null from, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          int v17 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v32 = type[0];
          if (os_log_type_enabled(v17, type[0]))
          {
            *(_DWORD *)__int128 buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_input_available";
            _os_log_impl( &dword_181A5C000,  v17,  v32,  "%{public}s called with null from, backtrace limit exceeded",  buf,  0xCu);
          }
        }

        goto LABEL_60;
      }

void sub_1822D3DF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_ip_channel_inbox_get_parameters(nw_protocol *a1)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    uint64_t v1 = a1->handle;
    uint64_t v2 = v1;
    if (v1)
    {
      id v3 = v1[6];
LABEL_4:

      return v3;
    }

    __nwlog_obj();
    uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    int v24 = "nw_ip_channel_inbox_get_parameters";
    char v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v10, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v24 = "nw_ip_channel_inbox_get_parameters";
          _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null inbox", buf, 0xCu);
        }
      }

      else if (v21)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)__int128 buf = 136446466;
            int v24 = "nw_ip_channel_inbox_get_parameters";
            __int16 v25 = 2082;
            BOOL v26 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v11,  v17,  "%{public}s called with null inbox, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_40;
        }

        if (v18)
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v24 = "nw_ip_channel_inbox_get_parameters";
          _os_log_impl(&dword_181A5C000, v11, v17, "%{public}s called with null inbox, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v24 = "nw_ip_channel_inbox_get_parameters";
          _os_log_impl( &dword_181A5C000,  v11,  v20,  "%{public}s called with null inbox, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

uint64_t ___ZL35nw_ip_channel_inbox_input_availableP11nw_protocolS0__block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  uint64_t v5 = v3[4];
  BOOL v6 = (void *)v3[5];
  if (v5)
  {
    *(void *)(v5 + 40) = v6;
    BOOL v6 = (void *)v3[5];
  }

  else
  {
    *(void *)(*(void *)(a1 + 48) + 8LL) = v6;
  }

  *BOOL v6 = v5;
  void v3[4] = 0LL;
  void v3[5] = 0LL;
  nw_ip_channel_inbox_handle_input_frame( *(void **)(a1 + 32),  *(void *)(a1 + 56),  v3,  *(void **)(a1 + 40),  *(unsigned __int8 **)(a1 + 64));

  return 1LL;
}

void sub_1822D4320(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_ip_channel_inbox_handle_input_frame(void *a1, uint64_t a2, void *a3, void *a4, unsigned __int8 *a5)
{
  uint64_t v248 = *MEMORY[0x1895F89C0];
  uint64_t v9 = a1;
  id v10 = a3;
  object = a4;
  memset(__src, 0, 28);
  memset(__dst, 0, 28);
  int v11 = *((_DWORD *)v9 + 14);
  if (v11 != 2)
  {
    int v224 = *((unsigned __int8 *)v9 + 166);
    os_log_type_t v20 = (unsigned __int8 *)v9[19];
    if (v20)
    {
      memcpy(__dst, v9[19], *v20);
      BOOL v21 = 0;
      BOOL v22 = 0;
      int v23 = 0;
      if (v20[1] == 2) {
        __int16 v24 = 528;
      }
      else {
        __int16 v24 = 7708;
      }
      *(_WORD *)&__src[0].os_log_type_t sa_len = v24;
    }

    else
    {
      BOOL v21 = 0;
      BOOL v22 = 0;
      int v23 = 0;
    }

    goto LABEL_14;
  }

  int v12 = *((_DWORD *)v9 + 40);
  LODWORD(v235) = 0;
  int v13 = (unsigned __int8 *)nw_frame_unclaimed_bytes((uint64_t)v10, &v235);
  if (!(_DWORD)v235) {
    goto LABEL_324;
  }
  int v14 = *v13 >> 4;
  if (v14 != 6)
  {
    if (v14 != 4)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v18 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
        goto LABEL_324;
      }
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ip_parse";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v14;
      os_log_type_t v19 = "%{public}s Unknown IP version: %u";
      goto LABEL_38;
    }

    *(_DWORD *)uint64_t address = 0;
    uint64_t v15 = nw_frame_unclaimed_bytes((uint64_t)v10, address);
    uint64_t v247 = 0LL;
    memset(&buf[20], 0, 32);
    int v17 = *(_DWORD *)address;
    if (*(_DWORD *)address <= 0x13u)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v18 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)int v242 = 136446466;
        *(void *)&v242[4] = "ipv4_parse";
        *(_WORD *)&v242[12] = 1024;
        *(_DWORD *)&v242[14] = *(_DWORD *)address;
        os_log_type_t v19 = "%{public}s Received IPv4 packet with incorrect length %u";
LABEL_110:
        int v33 = v242;
        goto LABEL_111;
      }

      goto LABEL_324;
    }

    *(_OWORD *)__int128 buf = *(_OWORD *)v15;
    *(_DWORD *)&buf[16] = *(_DWORD *)(v15 + 16);
    unsigned int v34 = 4 * (buf[0] & 0xF);
    if (v34 < 0x14 || *(_DWORD *)address < v34)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v18 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)int v242 = 136446466;
        *(void *)&v242[4] = "ipv4_parse";
        *(_WORD *)&v242[12] = 1024;
        *(_DWORD *)&v242[14] = v34;
        os_log_type_t v19 = "%{public}s Invalid IPv4 header length: %u";
        goto LABEL_110;
      }

void sub_1822D6E54( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, uint64_t a18, uint64_t a19, void *a20, void *a21, void *a22, void *a23, uint64_t a24, uint64_t a25, void *a26, void *a27, uint64_t a28, void *a29, void *a30, uint64_t a31, uint64_t a32, uint64_t a33, uint64_t a34, uint64_t a35, void *a36, uint64_t a37, void *a38)
{
  _Block_object_dispose((const void *)(v43 - 240), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZL38nw_ip_channel_inbox_handle_input_frameP19nw_ip_channel_inboxP11nw_protocolPU22objcproto11OS_nw_frame8NSObjectPU22objcproto11OS_nw_arrayS3_P27nw_ip_channel_fragment_info_block_invoke( uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  uint64_t v4 = a3;
  nw_endpoint_t v5 = nw_connection_copy_endpoint(v4);
  BOOL v6 = nw_connection_copy_parameters(v4);
  nw_endpoint_t v7 = nw_parameters_copy_local_endpoint(v6);
  if (!v5) {
    goto LABEL_12;
  }
  os_log_type_t v8 = v5;
  int v9 = -[nw_endpoint type](v8, "type");

  if (v9 != 1) {
    goto LABEL_12;
  }
  int v10 = nw_endpoint_address_endpoint_matches_address(v8, (unsigned __int8 *)(a1 + 40), 0, 0);
  int v11 = v7 ? v10 : 0;
  if (v11 == 1
    && (int v12 = v7, v13 = -[nw_endpoint type](v12, "type"), v12, v13 == 1)
    && nw_endpoint_address_endpoint_matches_address(v12, (unsigned __int8 *)(a1 + 68), 0, 0))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v14 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      int v17 = 136446466;
      uint64_t v18 = "nw_ip_channel_inbox_handle_input_frame_block_invoke";
      __int16 v19 = 2112;
      os_log_type_t v20 = v4;
      _os_log_impl( &dword_181A5C000,  v14,  OS_LOG_TYPE_INFO,  "%{public}s Reclassifying packet for %@",  (uint8_t *)&v17,  0x16u);
    }

    nw_connection_get_flow_id_on_nw_queue(v4, &v17);
    nw_frame_reclassify(*(void *)(a1 + 32), (uint64_t)&v17);
    uint64_t v15 = 0LL;
  }

  else
  {
LABEL_12:
    uint64_t v15 = 1LL;
  }

  return v15;
}

void sub_1822D7234(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL38nw_ip_channel_inbox_handle_input_frameP19nw_ip_channel_inboxP11nw_protocolPU22objcproto11OS_nw_frame8NSObjectPU22objcproto11OS_nw_arrayS3_P27nw_ip_channel_fragment_info_block_invoke_36( uint64_t a1, void *a2, _OWORD *a3)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  nw_endpoint_t v5 = a2;
  if (nw_interface_shallow_compare(v5, *(void **)(*(void *)(a1 + 32) + 40LL)))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v6 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      nw_endpoint_t v7 = v5 + 104;
      int v8 = 136446978;
      int v9 = "nw_ip_channel_inbox_handle_input_frame_block_invoke";
      if (!v5) {
        nw_endpoint_t v7 = 0LL;
      }
      __int16 v10 = 2080;
      int v11 = v7;
      __int16 v12 = 1040;
      int v13 = 16;
      __int16 v14 = 2096;
      uint64_t v15 = a3;
      _os_log_impl( &dword_181A5C000,  v6,  OS_LOG_TYPE_INFO,  "%{public}s Found interface %s, using agent id %{uuid_t}.16P",  (uint8_t *)&v8,  0x26u);
    }

    *(_OWORD *)*(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = *a3;
  }
}

nw_protocol_definition_t nw_protocol_copy_ip_definition(void)
{
  return (nw_protocol_definition_t)(id)g_ip_definition;
}

void ___ZL31nw_protocol_setup_ip_definitionv_block_invoke()
{
  if (nw_protocol_ip_identifier::onceToken[0] != -1) {
    dispatch_once(nw_protocol_ip_identifier::onceToken, &__block_literal_global_85447);
  }
  uint64_t v0 = nw_protocol_definition_create_with_identifier((__int128 *)&nw_protocol_ip_identifier::identifier);
  uint64_t v1 = (void *)g_ip_definition;
  g_ip_definition = (uint64_t)v0;

  nw_protocol_definition_set_options_allocator( (void *)g_ip_definition,  (uint64_t)nw_ip_allocate_options,  (uint64_t)nw_ip_copy_options,  (uint64_t)nw_ip_deallocate_options);
  nw_protocol_definition_set_options_equality_check((void *)g_ip_definition, (uint64_t)nw_ip_option_is_equal);
  nw_protocol_definition_set_metadata_allocator( (void *)g_ip_definition,  (uint64_t)nw_ip_allocate_metadata,  (uint64_t)nw_ip_deallocate_metadata);
  nw_protocol_definition_set_has_global_definition((void *)g_ip_definition);
  nw_protocol_definition_set_options_serializer( (void *)g_ip_definition,  0,  (uint64_t)nw_ip_serialize_options,  (uint64_t)nw_ip_deserialize_options);
}

BOOL nw_ip_allocate_options(void *a1)
{
  id v1 = a1;
  uint64_t v2 = calloc(1uLL, 0x10uLL);
  if (v2) {
    goto LABEL_2;
  }
  __nwlog_obj();
  uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  nw_endpoint_t v5 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:
    void *v2 = 0LL;
    v2[1] = 0LL;

    return (BOOL)v2;
  }

  __break(1u);
  return result;
}

void sub_1822D75E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_ip_copy_options(void *a1, _OWORD *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (!a2)
  {
    __nwlog_obj();
    BOOL v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v19 = "nw_ip_copy_options";
    nw_endpoint_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v7, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v19 = "nw_ip_copy_options";
          _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }

      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)__int128 buf = 136446466;
            __int16 v19 = "nw_ip_copy_options";
            __int16 v20 = 2082;
            uint64_t v21 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null existing_handle, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }

        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v19 = "nw_ip_copy_options";
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null existing_handle, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v19 = "nw_ip_copy_options";
          _os_log_impl( &dword_181A5C000,  v8,  v15,  "%{public}s called with null existing_handle, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_1822D7958(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_ip_deallocate_options(int a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

BOOL nw_ip_option_is_equal(uint64_t a1, void *a2, void *a3)
{
  return *a2 == *a3 && a2[1] == a3[1];
}

BOOL nw_ip_allocate_metadata(void *a1)
{
  id v1 = a1;
  uint64_t v2 = calloc(1uLL, 0x18uLL);
  if (v2) {
    goto LABEL_2;
  }
  __nwlog_obj();
  uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  nw_endpoint_t v5 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:
    void *v2 = 0LL;
    v2[1] = 0LL;
    v2[2] = 0LL;

    return (BOOL)v2;
  }

  __break(1u);
  return result;
}

void sub_1822D7AC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_ip_deallocate_metadata(int a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

BOOL nw_ip_serialize_options(void *a1, _OWORD *a2, void *a3)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  BOOL v6 = v5;
  if (!a2)
  {
    __nwlog_obj();
    int v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_ip_serialize_options";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v9, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        __int16 v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_ip_serialize_options";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }

      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        __int16 v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)__int128 buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_ip_serialize_options";
            *(_WORD *)&_BYTE buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null existing_handle, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }

        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_ip_serialize_options";
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null existing_handle, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        __int16 v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_ip_serialize_options";
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null existing_handle, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_1822D7DA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_ip_deserialize_options(void *a1, _OWORD *a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  BOOL v6 = v5;
  if (a2)
  {
    if (a3 == 16)
    {
      BOOL v7 = nw_ip_copy_options(v5, a2);
      goto LABEL_4;
    }

    __nwlog_obj();
    os_log_type_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    int v25 = "nw_ip_deserialize_options";
    __int16 v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v10, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v25 = "nw_ip_deserialize_options";
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null (serialized_length == sizeof(struct nw_protocol_ip_options))",  buf,  0xCu);
        }

void sub_1822D826C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_protocol_options *nw_ip_create_options()
{
  return nw_protocol_create_options((void *)g_ip_definition);
}

void nw_ip_options_set_use_minimum_mtu(nw_protocol_options_t options, BOOL use_minimum_mtu)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = options;
  if (nw_protocol_options_is_ip(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ip_options_set_use_minimum_mtu_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = use_minimum_mtu;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v17 = "nw_ip_options_set_use_minimum_mtu";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v17 = "nw_ip_options_set_use_minimum_mtu";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ip(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v17 = "nw_ip_options_set_use_minimum_mtu";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v17 = "nw_ip_options_set_use_minimum_mtu";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v17 = "nw_ip_options_set_use_minimum_mtu";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822D8588(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_options_is_ip(void *a1)
{
  uint64_t v18 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (v1)
  {
    BOOL v2 = nw_protocol_options_matches_definition(v1, (void *)g_ip_definition);
    goto LABEL_5;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v15 = "nw_protocol_options_is_ip";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v15 = "nw_protocol_options_is_ip";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v15 = "nw_protocol_options_is_ip";
          __int16 v16 = 2082;
          BOOL v17 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v15 = "nw_protocol_options_is_ip";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v15 = "nw_protocol_options_is_ip";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822D8860(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_set_use_minimum_mtu_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 13) = *(_BYTE *)(a2 + 13) & 0xFE | *(_BYTE *)(a1 + 32);
  return 1LL;
}

BOOL nw_ip_options_get_use_minimum_mtu(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_ip(v1))
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ip_options_get_use_minimum_mtu_block_invoke;
    v12[3] = &unk_189BC60A8;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_options_get_use_minimum_mtu";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_use_minimum_mtu";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ip(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_options_get_use_minimum_mtu";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_use_minimum_mtu";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_use_minimum_mtu";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822D8B90( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_get_use_minimum_mtu_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_BYTE *)(a2 + 13) & 1;
  return 1LL;
}

void nw_ip_options_set_calculate_receive_time(nw_protocol_options_t options, BOOL calculate_receive_time)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = options;
  if (nw_protocol_options_is_ip(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ip_options_set_calculate_receive_time_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = calculate_receive_time;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v17 = "nw_ip_options_set_calculate_receive_time";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_calculate_receive_time";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ip(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v17 = "nw_ip_options_set_calculate_receive_time";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_calculate_receive_time";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_calculate_receive_time";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822D8EA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_set_calculate_receive_time_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 13) = *(_BYTE *)(a2 + 13) & 0xFD | (2 * *(_BYTE *)(a1 + 32));
  return 1LL;
}

void nw_ip_options_set_hop_limit(nw_protocol_options_t options, uint8_t hop_limit)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = options;
  if (nw_protocol_options_is_ip(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ip_options_set_hop_limit_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    uint8_t v13 = hop_limit;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v17 = "nw_ip_options_set_hop_limit";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_hop_limit";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ip(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v17 = "nw_ip_options_set_hop_limit";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_hop_limit";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_hop_limit";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822D919C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_set_hop_limit_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 12) = *(_BYTE *)(a1 + 32);
  return 1LL;
}

void nw_ip_options_set_version(nw_protocol_options_t options, nw_ip_version_t version)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = options;
  if (nw_protocol_options_is_ip(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ip_options_set_version_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    nw_ip_version_t v13 = version;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v17 = "nw_ip_options_set_version";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_version";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ip(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v17 = "nw_ip_options_set_version";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_version";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_version";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822D9488(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_set_version_block_invoke(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 32);
  return 1LL;
}

uint64_t nw_ip_options_get_version(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_ip(v1))
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    int v16 = 0;
    *(void *)&buf[16] = 0x2020000000LL;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ip_options_get_version_block_invoke;
    v12[3] = &unk_189BC60A8;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    uint64_t v2 = *(unsigned int *)(*(void *)&buf[8] + 24LL);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_options_get_version";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_version";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ip(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_options_get_version";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_version";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_version";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822D97A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

void nw_ip_options_set_local_address_preference( nw_protocol_options_t options, nw_ip_local_address_preference_t preference)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = options;
  if (nw_protocol_options_is_ip(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ip_options_set_local_address_preference_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    nw_ip_local_address_preference_t v13 = preference;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v17 = "nw_ip_options_set_local_address_preference";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_local_address_preference";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ip(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v17 = "nw_ip_options_set_local_address_preference";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_local_address_preference";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_local_address_preference";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822D9A98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_set_local_address_preference_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 32);
  return 1LL;
}

void nw_ip_options_set_disable_multicast_loopback( nw_protocol_options_t options, BOOL disable_multicast_loopback)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = options;
  if (nw_protocol_options_is_ip(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ip_options_set_disable_multicast_loopback_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = disable_multicast_loopback;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v17 = "nw_ip_options_set_disable_multicast_loopback";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_disable_multicast_loopback";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ip(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v17 = "nw_ip_options_set_disable_multicast_loopback";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_disable_multicast_loopback";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_disable_multicast_loopback";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822D9D84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_set_disable_multicast_loopback_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 13) = *(_BYTE *)(a2 + 13) & 0xFB | (4 * *(_BYTE *)(a1 + 32));
  return 1LL;
}

BOOL nw_ip_options_get_disable_multicast_loopback(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_ip(v1))
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ip_options_get_disable_multicast_loopback_block_invoke;
    v12[3] = &unk_189BC60A8;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_options_get_disable_multicast_loopback";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_disable_multicast_loopback";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ip(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_options_get_disable_multicast_loopback";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_disable_multicast_loopback";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_disable_multicast_loopback";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822DA0B0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_get_disable_multicast_loopback_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (*(_BYTE *)(a2 + 13) & 4) != 0;
  return 1LL;
}

void nw_ip_options_set_corrupt_checksums(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (nw_protocol_options_is_ip(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ip_options_set_corrupt_checksums_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v17 = "nw_ip_options_set_corrupt_checksums";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_corrupt_checksums";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ip(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v17 = "nw_ip_options_set_corrupt_checksums";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_corrupt_checksums";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_corrupt_checksums";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822DA3C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_set_corrupt_checksums_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 13) = *(_BYTE *)(a2 + 13) & 0xF7 | (8 * *(_BYTE *)(a1 + 32));
  return 1LL;
}

void nw_ip_options_set_receive_hop_limit(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (nw_protocol_options_is_ip(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ip_options_set_receive_hop_limit_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v17 = "nw_ip_options_set_receive_hop_limit";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_receive_hop_limit";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ip(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v17 = "nw_ip_options_set_receive_hop_limit";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_receive_hop_limit";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_receive_hop_limit";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822DA6BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_set_receive_hop_limit_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 13) = *(_BYTE *)(a2 + 13) & 0xEF | (16 * *(_BYTE *)(a1 + 32));
  return 1LL;
}

BOOL nw_ip_options_get_receive_hop_limit(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_ip(v1))
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ip_options_get_receive_hop_limit_block_invoke;
    v12[3] = &unk_189BC60A8;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_options_get_receive_hop_limit";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_receive_hop_limit";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ip(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_options_get_receive_hop_limit";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_receive_hop_limit";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_receive_hop_limit";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822DA9E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_get_receive_hop_limit_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = (*(_BYTE *)(a2 + 13) & 0x10) != 0;
  return 1LL;
}

nw_protocol_metadata_t nw_ip_create_metadata(void)
{
  return (nw_protocol_metadata_t)nw_protocol_metadata_create_singleton((void *)g_ip_definition);
}

uint64_t __nw_ip_copy_metadata_for_ecn_flag_block_invoke(uint64_t a1)
{
  id v2 = (id)g_ip_definition;
  singleton = nw_protocol_metadata_create_singleton(v2);
  uint64_t v4 = (void *)nw_ip_copy_metadata_for_ecn_flag::non_ect_metadata;
  nw_ip_copy_metadata_for_ecn_flag::non_ect_uint64_t metadata = (uint64_t)singleton;

  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  v6[2] = __nw_ip_copy_metadata_for_ecn_flag_block_invoke_2;
  _OWORD v6[3] = &__block_descriptor_36_e9_B16__0_v8l;
  int v7 = *(_DWORD *)(a1 + 32);
  return nw_protocol_metadata_access_handle(nw_ip_copy_metadata_for_ecn_flag::non_ect_metadata, (uint64_t)v6);
}

void sub_1822DAB2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_copy_metadata_for_ecn_flag_block_invoke_3(uint64_t a1)
{
  id v2 = (id)g_ip_definition;
  singleton = nw_protocol_metadata_create_singleton(v2);
  uint64_t v4 = (void *)nw_ip_copy_metadata_for_ecn_flag::ect_1_metadata;
  nw_ip_copy_metadata_for_ecn_flag::ect_1_uint64_t metadata = (uint64_t)singleton;

  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  v6[2] = __nw_ip_copy_metadata_for_ecn_flag_block_invoke_4;
  _OWORD v6[3] = &__block_descriptor_36_e9_B16__0_v8l;
  int v7 = *(_DWORD *)(a1 + 32);
  return nw_protocol_metadata_access_handle(nw_ip_copy_metadata_for_ecn_flag::ect_1_metadata, (uint64_t)v6);
}

void sub_1822DABF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_copy_metadata_for_ecn_flag_block_invoke_5(uint64_t a1)
{
  id v2 = (id)g_ip_definition;
  singleton = nw_protocol_metadata_create_singleton(v2);
  uint64_t v4 = (void *)nw_ip_copy_metadata_for_ecn_flag::ect_0_metadata;
  nw_ip_copy_metadata_for_ecn_flag::ect_0_uint64_t metadata = (uint64_t)singleton;

  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  v6[2] = __nw_ip_copy_metadata_for_ecn_flag_block_invoke_6;
  _OWORD v6[3] = &__block_descriptor_36_e9_B16__0_v8l;
  int v7 = *(_DWORD *)(a1 + 32);
  return nw_protocol_metadata_access_handle(nw_ip_copy_metadata_for_ecn_flag::ect_0_metadata, (uint64_t)v6);
}

void sub_1822DACC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_copy_metadata_for_ecn_flag_block_invoke_7(uint64_t a1)
{
  id v2 = (id)g_ip_definition;
  singleton = nw_protocol_metadata_create_singleton(v2);
  uint64_t v4 = (void *)nw_ip_copy_metadata_for_ecn_flag::ce_metadata;
  nw_ip_copy_metadata_for_ecn_flag::ce_uint64_t metadata = (uint64_t)singleton;

  v6[0] = MEMORY[0x1895F87A8];
  v6[1] = 3221225472LL;
  v6[2] = __nw_ip_copy_metadata_for_ecn_flag_block_invoke_8;
  _OWORD v6[3] = &__block_descriptor_36_e9_B16__0_v8l;
  int v7 = *(_DWORD *)(a1 + 32);
  return nw_protocol_metadata_access_handle(nw_ip_copy_metadata_for_ecn_flag::ce_metadata, (uint64_t)v6);
}

void sub_1822DAD90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_copy_metadata_for_ecn_flag_block_invoke_8(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 22) |= 1u;
  *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = *(_DWORD *)(a1 + 32);
  return 1LL;
}

uint64_t __nw_ip_copy_metadata_for_ecn_flag_block_invoke_6(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 22) |= 1u;
  *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = *(_DWORD *)(a1 + 32);
  return 1LL;
}

uint64_t __nw_ip_copy_metadata_for_ecn_flag_block_invoke_4(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 22) |= 1u;
  *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = *(_DWORD *)(a1 + 32);
  return 1LL;
}

uint64_t __nw_ip_copy_metadata_for_ecn_flag_block_invoke_2(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 22) |= 1u;
  *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = *(_DWORD *)(a1 + 32);
  return 1LL;
}

void nw_ip_metadata_set_ecn_flag(nw_protocol_metadata_t metadata, nw_ip_ecn_flag_t ecn_flag)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  nw_protocol_metadata_t v3 = metadata;
  nw_protocol_metadata_t v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_ip_metadata_set_ecn_flag_block_invoke;
    v14[3] = &__block_descriptor_36_e9_B16__0_v8l;
    nw_ip_ecn_flag_t v15 = ecn_flag;
    uint64_t v5 = *((void *)v3 + 4);
    if (v5) {
      __nw_ip_metadata_set_ecn_flag_block_invoke((uint64_t)v14, v5);
    }
    goto LABEL_4;
  }

  __nwlog_obj();
  BOOL v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v19 = "nw_ip_metadata_set_ecn_flag";
  int v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v19 = "nw_ip_metadata_set_ecn_flag";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v19 = "nw_ip_metadata_set_ecn_flag";
          __int16 v20 = 2082;
          os_log_type_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v19 = "nw_ip_metadata_set_ecn_flag";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v19 = "nw_ip_metadata_set_ecn_flag";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL __nw_ip_metadata_set_ecn_flag_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  char v2 = *(_BYTE *)(a2 + 22);
  if ((v2 & 1) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    nw_protocol_metadata_t v3 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136446210;
      BOOL v6 = "nw_ip_metadata_set_ecn_flag_block_invoke";
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot modify static IP metadata",  (uint8_t *)&v5,  0xCu);
    }
  }

  else
  {
    *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = *(_DWORD *)(a1 + 32);
  }

  return (v2 & 1) == 0;
}

nw_ip_ecn_flag_t nw_ip_metadata_get_ecn_flag(nw_protocol_metadata_t metadata)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  nw_protocol_metadata_t v1 = metadata;
  nw_protocol_metadata_t v2 = v1;
  if (v1)
  {
    nw_protocol_metadata_t v3 = buf;
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    int v19 = 0;
    *(void *)&buf[16] = 0x2020000000LL;
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    v15[2] = __nw_ip_metadata_get_ecn_flag_block_invoke;
    v15[3] = &unk_189BC60A8;
    v15[4] = buf;
    uint64_t v4 = *((void *)v1 + 4);
    if (v4)
    {
      __nw_ip_metadata_get_ecn_flag_block_invoke((uint64_t)v15, v4);
      nw_protocol_metadata_t v3 = *(_BYTE **)&buf[8];
    }

    nw_ip_ecn_flag_t v5 = *((_DWORD *)v3 + 6);
    _Block_object_dispose(buf, 8);
    goto LABEL_5;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_ecn_flag";
  int v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v8, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_ecn_flag";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_ecn_flag";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_ecn_flag";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_ecn_flag";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_ip_metadata_get_ecn_flag_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_DWORD *)(a2 + 8);
  return 1LL;
}

void nw_ip_metadata_set_dscp_value(void *a1, unsigned int a2)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  nw_protocol_metadata_t v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __nwlog_obj();
    BOOL v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    int v25 = "nw_ip_metadata_set_dscp_value";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v25 = "nw_ip_metadata_set_dscp_value";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          int v25 = "nw_ip_metadata_set_dscp_value";
          __int16 v26 = 2082;
          char v27 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v7) {
          goto LABEL_5;
        }
LABEL_40:
        free(v7);
        goto LABEL_5;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v25 = "nw_ip_metadata_set_dscp_value";
        _os_log_impl(&dword_181A5C000, v8, v13, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v25 = "nw_ip_metadata_set_dscp_value";
        _os_log_impl( &dword_181A5C000,  v8,  v18,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }

BOOL __nw_ip_metadata_set_dscp_value_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  char v2 = *(_BYTE *)(a2 + 22);
  if ((v2 & 1) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    nw_protocol_metadata_t v3 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136446210;
      BOOL v6 = "nw_ip_metadata_set_dscp_value_block_invoke";
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot modify static IP metadata",  (uint8_t *)&v5,  0xCu);
    }
  }

  else
  {
    *(_BYTE *)(a2 + 20) = *(_BYTE *)(a1 + 32);
  }

  return (v2 & 1) == 0;
}

uint64_t nw_ip_metadata_get_dscp_value(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_protocol_metadata_t v1 = a1;
  char v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v18 = 0;
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_ip_metadata_get_dscp_value_block_invoke;
    v14[3] = &unk_189BC60A8;
    void v14[4] = buf;
    uint64_t v3 = v1[4];
    if (v3)
    {
      __nw_ip_metadata_get_dscp_value_block_invoke((uint64_t)v14, v3);
      uint64_t v4 = *(unsigned __int8 *)(*(void *)&buf[8] + 24LL);
    }

    else
    {
      uint64_t v4 = 0LL;
    }

    _Block_object_dispose(buf, 8);
    goto LABEL_6;
  }

  __nwlog_obj();
  BOOL v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_dscp_value";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v7, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_dscp_value";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_dscp_value";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_dscp_value";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_dscp_value";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_ip_metadata_get_dscp_value_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_BYTE *)(a2 + 20);
  return 1LL;
}

void nw_ip_metadata_set_service_class(nw_protocol_metadata_t metadata, nw_service_class_t service_class)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  nw_protocol_metadata_t v3 = metadata;
  nw_protocol_metadata_t v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_ip_metadata_set_service_class_block_invoke;
    v14[3] = &__block_descriptor_36_e9_B16__0_v8l;
    nw_service_class_t v15 = service_class;
    uint64_t v5 = *((void *)v3 + 4);
    if (v5) {
      __nw_ip_metadata_set_service_class_block_invoke((uint64_t)v14, v5);
    }
    goto LABEL_4;
  }

  __nwlog_obj();
  BOOL v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v19 = "nw_ip_metadata_set_service_class";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v19 = "nw_ip_metadata_set_service_class";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v19 = "nw_ip_metadata_set_service_class";
          __int16 v20 = 2082;
          char v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v19 = "nw_ip_metadata_set_service_class";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v19 = "nw_ip_metadata_set_service_class";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL __nw_ip_metadata_set_service_class_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1895F89C0];
  char v2 = *(_BYTE *)(a2 + 22);
  if ((v2 & 1) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    nw_protocol_metadata_t v3 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136446210;
      BOOL v6 = "nw_ip_metadata_set_service_class_block_invoke";
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot modify static IP metadata",  (uint8_t *)&v5,  0xCu);
    }
  }

  else
  {
    *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 32);
  }

  return (v2 & 1) == 0;
}

nw_service_class_t nw_ip_metadata_get_service_class(nw_protocol_metadata_t metadata)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  nw_protocol_metadata_t v1 = metadata;
  nw_protocol_metadata_t v2 = v1;
  if (v1)
  {
    nw_protocol_metadata_t v3 = buf;
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    int v19 = 0;
    *(void *)&buf[16] = 0x2020000000LL;
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    v15[2] = __nw_ip_metadata_get_service_class_block_invoke;
    v15[3] = &unk_189BC60A8;
    v15[4] = buf;
    uint64_t v4 = *((void *)v1 + 4);
    if (v4)
    {
      __nw_ip_metadata_get_service_class_block_invoke((uint64_t)v15, v4);
      nw_protocol_metadata_t v3 = *(_BYTE **)&buf[8];
    }

    nw_service_class_t v5 = *((_DWORD *)v3 + 6);
    _Block_object_dispose(buf, 8);
    goto LABEL_5;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_service_class";
  int v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v8, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_service_class";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_service_class";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_service_class";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_service_class";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_ip_metadata_get_service_class_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_DWORD *)(a2 + 12);
  return 1LL;
}

uint64_t __nw_ip_metadata_set_receive_time_block_invoke(uint64_t a1, void *a2)
{
  *a2 = *(void *)(a1 + 32);
  return 1LL;
}

uint64_t nw_ip_metadata_get_receive_time(nw_protocol_metadata_t metadata)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  nw_protocol_metadata_t v1 = metadata;
  nw_protocol_metadata_t v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    uint64_t v20 = 0LL;
    v16[0] = MEMORY[0x1895F87A8];
    v16[1] = 3221225472LL;
    v16[2] = __nw_ip_metadata_get_receive_time_block_invoke;
    v16[3] = &unk_189BC60A8;
    void v16[4] = buf;
    nw_protocol_metadata_t v3 = (void *)*((void *)v1 + 4);
    if (v3
      && (__nw_ip_metadata_get_receive_time_block_invoke((uint64_t)v16, v3),
          (uint64_t v4 = *(void *)(*(void *)&buf[8] + 24LL)) != 0))
    {
      unsigned int v5 = dword_18C45F3A4;
      if (!dword_18C45F3A4)
      {
        mach_timebase_info((mach_timebase_info_t)&time_base);
        unsigned int v5 = dword_18C45F3A4;
      }

      uint64_t v6 = v4 * (unint64_t)time_base / v5;
    }

    else
    {
      uint64_t v6 = 0LL;
    }

    _Block_object_dispose(buf, 8);
    goto LABEL_9;
  }

  __nwlog_obj();
  int v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_receive_time";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v9, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_receive_time";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_receive_time";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_receive_time";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_receive_time";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_ip_metadata_get_receive_time_block_invoke(uint64_t a1, void *a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *a2;
  return 1LL;
}

uint64_t __nw_ip_metadata_set_hop_limit_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a2 + 2nw_tcp_options_set_enable_fast_open(options, 1) = *(_BYTE *)(a1 + 32);
  return 1LL;
}

uint64_t nw_ip_metadata_get_hop_limit(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  nw_protocol_metadata_t v1 = a1;
  nw_protocol_metadata_t v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v18 = 0;
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_ip_metadata_get_hop_limit_block_invoke;
    v14[3] = &unk_189BC60A8;
    void v14[4] = buf;
    uint64_t v3 = v1[4];
    if (v3)
    {
      __nw_ip_metadata_get_hop_limit_block_invoke((uint64_t)v14, v3);
      uint64_t v4 = *(unsigned __int8 *)(*(void *)&buf[8] + 24LL);
    }

    else
    {
      uint64_t v4 = 0LL;
    }

    _Block_object_dispose(buf, 8);
    goto LABEL_6;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_hop_limit";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v7, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_hop_limit";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_hop_limit";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_hop_limit";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_hop_limit";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_ip_metadata_get_hop_limit_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_BYTE *)(a2 + 21);
  return 1LL;
}

void nw_ip_metadata_set_enable_fragmentation(void *a1, char a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_ip_metadata_set_enable_fragmentation_block_invoke;
    v14[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v15 = a2;
    uint64_t v5 = v3[4];
    if (v5) {
      __nw_ip_metadata_set_enable_fragmentation_block_invoke((uint64_t)v14, v5);
    }
    goto LABEL_4;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v19 = "nw_ip_metadata_set_enable_fragmentation";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v19 = "nw_ip_metadata_set_enable_fragmentation";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v19 = "nw_ip_metadata_set_enable_fragmentation";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v19 = "nw_ip_metadata_set_enable_fragmentation";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v19 = "nw_ip_metadata_set_enable_fragmentation";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

BOOL __nw_ip_metadata_set_enable_fragmentation_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x1895F89C0];
  char v2 = *(_BYTE *)(a2 + 22);
  if ((v2 & 1) != 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v6 = 136446210;
      uint64_t v7 = "nw_ip_metadata_set_enable_fragmentation_block_invoke";
      _os_log_impl( &dword_181A5C000,  v4,  OS_LOG_TYPE_ERROR,  "%{public}s Cannot modify static IP metadata",  (uint8_t *)&v6,  0xCu);
    }
  }

  else
  {
    if (*(_BYTE *)(a1 + 32)) {
      int v3 = 2;
    }
    else {
      int v3 = 1;
    }
    *(_DWORD *)(a2 + 16) = v3;
  }

  return (v2 & 1) == 0;
}

uint64_t nw_ip_metadata_get_fragmentation_value(void *a1)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  nw_protocol_metadata_t v1 = a1;
  char v2 = v1;
  if (v1)
  {
    int v3 = buf;
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    int v19 = 0;
    *(void *)&buf[16] = 0x2020000000LL;
    v15[0] = MEMORY[0x1895F87A8];
    v15[1] = 3221225472LL;
    v15[2] = __nw_ip_metadata_get_fragmentation_value_block_invoke;
    v15[3] = &unk_189BC60A8;
    v15[4] = buf;
    uint64_t v4 = v1[4];
    if (v4)
    {
      __nw_ip_metadata_get_fragmentation_value_block_invoke((uint64_t)v15, v4);
      int v3 = *(_BYTE **)&buf[8];
    }

    uint64_t v5 = *((unsigned int *)v3 + 6);
    _Block_object_dispose(buf, 8);
    goto LABEL_5;
  }

  __nwlog_obj();
  uint64_t v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_fragmentation_value";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v8, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_fragmentation_value";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_fragmentation_value";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null metadata, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_fragmentation_value";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_fragmentation_value";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null metadata, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t __nw_ip_metadata_get_fragmentation_value_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *(_DWORD *)(a2 + 16);
  return 1LL;
}

void nw_ip_options_set_disable_fragmentation(nw_protocol_options_t options, BOOL disable_fragmentation)
{
  uint64_t v20 = *MEMORY[0x1895F89C0];
  int v3 = options;
  if (nw_protocol_options_is_ip(v3))
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_ip_options_set_disable_fragmentation_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = disable_fragmentation;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  char v17 = "nw_ip_options_set_disable_fragmentation";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v17 = "nw_ip_options_set_disable_fragmentation";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_ip(options)",  buf,  0xCu);
      }
    }

    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          char v17 = "nw_ip_options_set_disable_fragmentation";
          __int16 v18 = 2082;
          int v19 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v17 = "nw_ip_options_set_disable_fragmentation";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v17 = "nw_ip_options_set_disable_fragmentation";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822DD488(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_set_disable_fragmentation_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 32)) {
    int v2 = 1;
  }
  else {
    int v2 = 2;
  }
  *(_DWORD *)(a2 + _Block_object_dispose(va, 8) = v2;
  return 1LL;
}

NWConcrete_nw_protocol_options *nw_custom_ip_create_options(char a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  options = nw_protocol_create_options((void *)nw_protocol_copy_custom_ip_definition(void)::definition);
  int v3 = options;
  if (options)
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_custom_ip_create_options_block_invoke;
    v14[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v15 = a1;
    nw_protocol_options_access_handle(options, v14);
    uint64_t v4 = v3;
    goto LABEL_5;
  }

  __nwlog_obj();
  int v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  int v19 = "nw_custom_ip_create_options";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v19 = "nw_custom_ip_create_options";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null options", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          int v19 = "nw_custom_ip_create_options";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null options, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v19 = "nw_custom_ip_create_options";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v19 = "nw_custom_ip_create_options";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null options, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822DD7B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_custom_ip_create_options_block_invoke(uint64_t a1, _BYTE *a2)
{
  *a2 = *(_BYTE *)(a1 + 32);
  return 1LL;
}

void ___ZL37nw_protocol_copy_custom_ip_definitionv_block_invoke()
{
  named = nw_protocol_definition_create_named(1, 0LL);
  nw_protocol_metadata_t v1 = (void *)nw_protocol_copy_custom_ip_definition(void)::definition;
  nw_protocol_copy_custom_ip_definition(void)::definition = (uint64_t)named;

  nw_protocol_definition_set_options_allocator( (void *)nw_protocol_copy_custom_ip_definition(void)::definition,  (uint64_t)nw_custom_ip_allocate_options,  (uint64_t)nw_custom_ip_copy_options,  (uint64_t)nw_custom_ip_deallocate_options);
  nw_protocol_definition_set_options_equality_check( (void *)nw_protocol_copy_custom_ip_definition(void)::definition,  (uint64_t)nw_custom_ip_option_is_equal);
}

BOOL nw_custom_ip_allocate_options(void *a1)
{
  id v1 = a1;
  int v2 = calloc(1uLL, 1uLL);
  if (v2) {
    goto LABEL_2;
  }
  __nwlog_obj();
  uint64_t v4 = (os_log_s *)objc_claimAutoreleasedReturnValue();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  uint64_t v5 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:
    _BYTE *v2 = 0;

    return (BOOL)v2;
  }

  __break(1u);
  return result;
}

void sub_1822DD95C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_custom_ip_copy_options(void *a1, _BYTE *a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  if (!a2)
  {
    __nwlog_obj();
    int v6 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    int v19 = "nw_custom_ip_copy_options";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v7, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v19 = "nw_custom_ip_copy_options";
          _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }

      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)__int128 buf = 136446466;
            int v19 = "nw_custom_ip_copy_options";
            __int16 v20 = 2082;
            uint64_t v21 = (uint64_t)backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null existing_handle, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }

        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v19 = "nw_custom_ip_copy_options";
          _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null existing_handle, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          int v19 = "nw_custom_ip_copy_options";
          _os_log_impl( &dword_181A5C000,  v8,  v15,  "%{public}s called with null existing_handle, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_1822DDCCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_custom_ip_deallocate_options(int a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

BOOL nw_custom_ip_option_is_equal(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  return *a2 == *a3;
}

uint64_t nw_custom_ip_options_get_protocol(void *a1)
{
  uint64_t v17 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  if (nw_protocol_options_is_custom_ip(v1))
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v16 = 0;
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_custom_ip_options_get_protocol_block_invoke;
    v12[3] = &unk_189BC60A8;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    uint64_t v2 = *(unsigned __int8 *)(*(void *)&buf[8] + 24LL);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_custom_ip_options_get_protocol";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_custom_ip_options_get_protocol";
        _os_log_impl( &dword_181A5C000,  v6,  v7,  "%{public}s called with null nw_protocol_options_is_custom_ip(options)",  buf,  0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_custom_ip_options_get_protocol";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_custom_ip(options), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_custom_ip_options_get_protocol";
        _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null nw_protocol_options_is_custom_ip(options), no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_custom_ip_options_get_protocol";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null nw_protocol_options_is_custom_ip(options), backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822DDFFC( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_custom_ip_options_get_protocol_block_invoke(uint64_t a1, _BYTE *a2)
{
  *(_BYTE *)(*(void *)(*(void *)(a1 + 32) + 8LL) + 24LL) = *a2;
  return 1LL;
}

void sub_1822E04B0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Block_object_dispose(&a25, 8);
  std::ostringstream::~ostringstream(v25);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__52869(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(MEMORY[0x189614738] + 8LL);
  uint64_t v5 = *(void *)(MEMORY[0x189614738] + 16LL);
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v4;
  uint64_t v6 = a1 + 48;
  *(void *)(a1 + 160) = MEMORY[0x189614770] + 16LL;
  *(void *)(a1 + 48 + *(void *)(v4 - 24)) = v5;
  os_log_type_t v7 = (std::ios_base *)(a1 + 48 + *(void *)(*(void *)(a1 + 48) - 24LL));
  uint64_t v8 = (std::ios_base *)(a2 + 48 + *(void *)(*(void *)(a2 + 48) - 24LL));
  std::ios_base::move(v7, v8);
  v7[1].__vftable = v8[1].__vftable;
  v8[1].__vftable = 0LL;
  uint64_t v9 = MEMORY[0x189614768];
  v7[1].__fmtflags_ = v8[1].__fmtflags_;
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = v9 + 24;
  *(void *)(a1 + 160) = v9 + 64;
  std::streambuf::basic_streambuf();
  uint64_t v10 = MEMORY[0x189614750] + 16LL;
  *(void *)(a1 + 120) = 0LL;
  os_log_type_t v11 = (_OWORD *)(a1 + 120);
  *(void *)(a1 + 56) = v10;
  *(void *)(a1 + 12_Block_object_dispose(va, 8) = 0LL;
  *(void *)(a1 + 136) = 0LL;
  *(_DWORD *)(a1 + 152) = *(_DWORD *)(a2 + 152);
  BOOL v12 = (__int128 *)(a2 + 120);
  else {
    uint64_t v13 = *(void *)(a2 + 120);
  }
  uint64_t v14 = *(void *)(a2 + 72);
  if (v14)
  {
    uint64_t v15 = v14 - v13;
    uint64_t v16 = *(void *)(a2 + 80) - v13;
    uint64_t v17 = *(void *)(a2 + 88) - v13;
    uint64_t v18 = *(void *)(a2 + 96);
    if (v18)
    {
LABEL_6:
      uint64_t v19 = v18 - v13;
      uint64_t v20 = *(void *)(a2 + 104) - v13;
      uint64_t v21 = *(void *)(a2 + 112) - v13;
      goto LABEL_9;
    }
  }

  else
  {
    uint64_t v17 = -1LL;
    uint64_t v16 = -1LL;
    uint64_t v15 = -1LL;
    uint64_t v18 = *(void *)(a2 + 96);
    if (v18) {
      goto LABEL_6;
    }
  }

  uint64_t v19 = -1LL;
  uint64_t v20 = -1LL;
  uint64_t v21 = -1LL;
LABEL_9:
  uint64_t v22 = *(void *)(a2 + 144);
  uint64_t v23 = v22 - v13;
  if (!v22) {
    uint64_t v23 = -1LL;
  }
  __int128 v24 = *v12;
  *(void *)(a1 + 136) = *(void *)(a2 + 136);
  *os_log_type_t v11 = v24;
  *(_BYTE *)(a2 + 143) = 0;
  *(_BYTE *)(a2 + 120) = 0;
  uint64_t v25 = a1 + 120;
  if (v15 != -1)
  {
    *(void *)(a1 + 72) = v25 + v15;
    *(void *)(a1 + 80) = v25 + v16;
    *(void *)(a1 + 8_Block_object_dispose(va, 8) = v25 + v17;
  }

  if (v19 != -1)
  {
    *(void *)(a1 + 112) = v25 + v21;
    *(void *)(a1 + 96) = v25 + v19;
    *(void *)(a1 + 104) = v25 + v19 + v20;
  }

  uint64_t v26 = v25 + v23;
  if (v23 == -1) {
    uint64_t v26 = 0LL;
  }
  *(void *)(a1 + 144) = v26;
  *(void *)(a2 + 72) = v12;
  *(void *)(a2 + 80) = v12;
  *(void *)(a2 + 8_Block_object_dispose(va, 8) = v12;
  *(void *)(a2 + 96) = v12;
  *(void *)(a2 + 104) = v12;
  *(void *)(a2 + 112) = v12;
  *(void *)(a2 + 144) = v12;
  std::locale::locale(&v27, (const std::locale *)(a2 + 64));
  (*(void (**)(uint64_t, std::locale *))(*(void *)(a1 + 56) + 16LL))(a1 + 56, &v27);
  std::locale::locale(&v28, (const std::locale *)(a1 + 64));
  std::locale::operator=((std::locale *)(a1 + 64), &v27);
  std::locale::~locale(&v28);
  std::locale::~locale(&v27);
  *(void *)(v6 + *(void *)(*(void *)(a1 + 48) - 24LL) + 40) = a1 + 56;
}

void sub_1822E0774( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
}

void __Block_byref_object_dispose__52870(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x189614738];
  uint64_t v2 = *MEMORY[0x189614738];
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = *MEMORY[0x189614738];
  *(void *)(a1 + 48 + *(void *)(v2 - 24)) = *(void *)(v1 + 24);
  *(void *)(a1 + 56) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  JUMPOUT(0x186E10044LL);
}

uint64_t nw_resolver_config_get_protocol(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    int v20 = 0;
    *(void *)&buf[16] = 0x2020000000LL;
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_resolver_config_get_protocol_block_invoke;
    v14[3] = &unk_189BC9210;
    uint64_t v16 = buf;
    uint64_t v15 = (os_unfair_lock_s *)v1;
    id v3 = v15 + 22;
    os_unfair_lock_lock(v15 + 22);
    __nw_resolver_config_get_protocol_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v3);
    uint64_t v4 = *(unsigned int *)(*(void *)&buf[8] + 24LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_config_get_protocol";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_protocol";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_get_protocol";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_protocol";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_protocol";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E0B5C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void nw_resolver_config_enumerate_name_servers(void *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    __int128 v24 = __Block_byref_object_copy__22_52905;
    uint64_t v25 = __Block_byref_object_dispose__23_52906;
    uint64_t v5 = MEMORY[0x1895F87A8];
    id v26 = 0LL;
    v18[0] = MEMORY[0x1895F87A8];
    v18[1] = 3221225472LL;
    void v18[2] = __nw_resolver_config_enumerate_name_servers_block_invoke;
    v18[3] = &unk_189BC9210;
    int v20 = buf;
    uint64_t v19 = (os_unfair_lock_s *)v3;
    uint64_t v6 = v19 + 22;
    os_unfair_lock_lock(v19 + 22);
    __nw_resolver_config_enumerate_name_servers_block_invoke((uint64_t)v18);
    os_unfair_lock_unlock(v6);
    os_log_type_t v7 = *(void **)(*(void *)&buf[8] + 40LL);
    if (v7)
    {
      applier[0] = v5;
      applier[1] = 3221225472LL;
      applier[2] = __nw_resolver_config_enumerate_name_servers_block_invoke_2;
      applier[3] = &unk_189BC0F80;
      id v17 = v4;
      xpc_array_apply(v7, applier);
    }

    _Block_object_dispose(buf, 8);
    goto LABEL_5;
  }

  __nwlog_obj();
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_name_servers";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (__nwlog_fault(v9, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_name_servers";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_name_servers";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_name_servers";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_name_servers";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E0F68( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, id a30)
{
  _Block_object_dispose(&a25, 8);
  _Unwind_Resume(a1);
}

void nw_resolver_config_enumerate_search_domains(void *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    __int128 v24 = __Block_byref_object_copy__22_52905;
    uint64_t v25 = __Block_byref_object_dispose__23_52906;
    uint64_t v5 = MEMORY[0x1895F87A8];
    id v26 = 0LL;
    v18[0] = MEMORY[0x1895F87A8];
    v18[1] = 3221225472LL;
    void v18[2] = __nw_resolver_config_enumerate_search_domains_block_invoke;
    v18[3] = &unk_189BC9210;
    int v20 = buf;
    uint64_t v19 = (os_unfair_lock_s *)v3;
    uint64_t v6 = v19 + 22;
    os_unfair_lock_lock(v19 + 22);
    __nw_resolver_config_enumerate_search_domains_block_invoke((uint64_t)v18);
    os_unfair_lock_unlock(v6);
    os_log_type_t v7 = *(void **)(*(void *)&buf[8] + 40LL);
    if (v7)
    {
      applier[0] = v5;
      applier[1] = 3221225472LL;
      applier[2] = __nw_resolver_config_enumerate_search_domains_block_invoke_2;
      applier[3] = &unk_189BC0F80;
      id v17 = v4;
      xpc_array_apply(v7, applier);
    }

    _Block_object_dispose(buf, 8);
    goto LABEL_5;
  }

  __nwlog_obj();
  uint64_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_search_domains";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (__nwlog_fault(v9, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_search_domains";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_search_domains";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_search_domains";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_search_domains";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E1390( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, id a30)
{
  _Block_object_dispose(&a25, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_resolver_config_get_provider_name(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    uint64_t v20 = 0LL;
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_resolver_config_get_provider_name_block_invoke;
    v14[3] = &unk_189BC9210;
    uint64_t v16 = buf;
    os_log_type_t v15 = (os_unfair_lock_s *)v1;
    id v3 = v15 + 22;
    os_unfair_lock_lock(v15 + 22);
    __nw_resolver_config_get_provider_name_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v3);
    uint64_t v4 = *(void *)(*(void *)&buf[8] + 24LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_config_get_provider_name";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_provider_name";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_get_provider_name";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_provider_name";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_provider_name";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E16F0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_resolver_config_get_provider_path(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    uint64_t v20 = 0LL;
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_resolver_config_get_provider_path_block_invoke;
    v14[3] = &unk_189BC9210;
    uint64_t v16 = buf;
    os_log_type_t v15 = (os_unfair_lock_s *)v1;
    id v3 = v15 + 22;
    os_unfair_lock_lock(v15 + 22);
    __nw_resolver_config_get_provider_path_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v3);
    uint64_t v4 = *(void *)(*(void *)&buf[8] + 24LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_config_get_provider_path";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_provider_path";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_get_provider_path";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_provider_path";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_provider_path";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E1A34( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x189614738];
  uint64_t v3 = *MEMORY[0x189614738];
  *(void *)a1 = *MEMORY[0x189614738];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + _Block_object_dispose(va, 8) = MEMORY[0x189614750] + 16LL;
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x186E10044](a1 + 112);
  return a1;
}

void __nw_resolver_config_get_provider_path_block_invoke(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 8LL);
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = xpc_dictionary_get_string(v2, "ProviderPath");
}

void sub_1822E1B34( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void __nw_resolver_config_get_provider_name_block_invoke(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 8LL);
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = xpc_dictionary_get_string(v2, "ProviderName");
}

void sub_1822E1B98( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t __Block_byref_object_copy__22_52905(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0LL;
  return result;
}

void __Block_byref_object_dispose__23_52906(uint64_t a1)
{
}

void __nw_resolver_config_enumerate_search_domains_block_invoke(uint64_t a1)
{
  id v5 = *(id *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v2 = xpc_dictionary_get_value(v5, "SearchDomains");
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_1822E1C20( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t __nw_resolver_config_enumerate_search_domains_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (object_getClass(v4) == (Class)MEMORY[0x1895F92E8])
  {
    uint64_t v6 = *(void *)(a1 + 32);
    string_ptr = xpc_string_get_string_ptr(v4);
    uint64_t v5 = (*(uint64_t (**)(uint64_t, const char *))(v6 + 16))(v6, string_ptr);
  }

  else
  {
    uint64_t v5 = 1LL;
  }

  return v5;
}

void sub_1822E1C9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_enumerate_name_servers_block_invoke(uint64_t a1)
{
  id v5 = *(id *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v2 = xpc_dictionary_get_value(v5, "NameServers");
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_1822E1D08( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t __nw_resolver_config_enumerate_name_servers_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (object_getClass(v4) == (Class)MEMORY[0x1895F92E8])
  {
    uint64_t v6 = *(void *)(a1 + 32);
    string_ptr = xpc_string_get_string_ptr(v4);
    uint64_t v5 = (*(uint64_t (**)(uint64_t, const char *))(v6 + 16))(v6, string_ptr);
  }

  else
  {
    uint64_t v5 = 1LL;
  }

  return v5;
}

void sub_1822E1D84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_get_protocol_block_invoke(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 8LL);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = xpc_dictionary_get_int64(v2, "Protocol");
}

void sub_1822E1DE4( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

NWConcrete_nw_resolver_config *nw_resolver_config_create()
{
  xpc_object_t v0 = xpc_dictionary_create(0LL, 0LL, 0LL);
  id v1 = nw_resolver_config_create_with_dictionary(v0);
  if (v0) {

  }
  return v1;
}

void sub_1822E1E4C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

nw_resolver_config_t nw_resolver_config_create_https(nw_endpoint_t url_endpoint)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  id v1 = url_endpoint;
  id v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    __int128 v24 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_resolver_config_create_https";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    out[0] = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = type[0];
      if (os_log_type_enabled(v25, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_create_https";
        _os_log_impl(&dword_181A5C000, v25, v26, "%{public}s called with null url_endpoint", buf, 0xCu);
      }
    }

    else if (out[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = type[0];
      BOOL v31 = os_log_type_enabled(v25, type[0]);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_create_https";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v25,  v30,  "%{public}s called with null url_endpoint, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (!v8) {
          goto LABEL_28;
        }
        goto LABEL_27;
      }

      if (v31)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_create_https";
        _os_log_impl(&dword_181A5C000, v25, v30, "%{public}s called with null url_endpoint, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v35 = type[0];
      if (os_log_type_enabled(v25, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_create_https";
        _os_log_impl( &dword_181A5C000,  v25,  v35,  "%{public}s called with null url_endpoint, backtrace limit exceeded",  buf,  0xCu);
      }
    }

    goto LABEL_62;
  }

  uint64_t v3 = v1;
  int v4 = -[nw_endpoint type](v3, "type");

  if (v4 != 4)
  {
    __nwlog_obj();
    uint64_t v27 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_resolver_config_create_https";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    out[0] = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type[0];
      if (os_log_type_enabled(v25, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_create_https";
        _os_log_impl( &dword_181A5C000,  v25,  v28,  "%{public}s called with null (nw_endpoint_get_type(url_endpoint) == nw_endpoint_type_url)",  buf,  0xCu);
      }
    }

    else if (out[0])
    {
      int v32 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v33 = type[0];
      BOOL v34 = os_log_type_enabled(v25, type[0]);
      if (v32)
      {
        if (v34)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_create_https";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = v32;
          _os_log_impl( &dword_181A5C000,  v25,  v33,  "%{public}s called with null (nw_endpoint_get_type(url_endpoint) == nw_endpoint_type_url), dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(v32);
LABEL_26:
        if (!v8)
        {
LABEL_28:
          uint64_t v18 = 0LL;
          goto LABEL_29;
        }

void sub_1822E26B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  _Unwind_Resume(a1);
}

void nw_resolver_config_set_identifier(void *a1, _OWORD *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  uint64_t v3 = a1;
  int v4 = v3;
  if (v3)
  {
    *(_OWORD *)(v3 + 24) = *a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v16 = "nw_resolver_config_set_identifier";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v16 = "nw_resolver_config_set_identifier";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v16 = "nw_resolver_config_set_identifier";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v16 = "nw_resolver_config_set_identifier";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v16 = "nw_resolver_config_set_identifier";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_resolver_config_set_class(void *a1, int a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  int v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_resolver_config_set_class_block_invoke;
    v14[3] = &unk_189BC76E8;
    uint64_t v5 = (os_unfair_lock_s *)v3;
    void v14[4] = v5;
    int v15 = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_set_class_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v19 = "nw_resolver_config_set_class";
  id v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v19 = "nw_resolver_config_set_class";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v19 = "nw_resolver_config_set_class";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v19 = "nw_resolver_config_set_class";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v19 = "nw_resolver_config_set_class";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E2CAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_resolver_config_set_protocol(void *a1, int a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  int v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_resolver_config_set_protocol_block_invoke;
    v14[3] = &unk_189BC76E8;
    uint64_t v5 = (os_unfair_lock_s *)v3;
    void v14[4] = v5;
    int v15 = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_set_protocol_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v19 = "nw_resolver_config_set_protocol";
  id v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v19 = "nw_resolver_config_set_protocol";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v19 = "nw_resolver_config_set_protocol";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v19 = "nw_resolver_config_set_protocol";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v19 = "nw_resolver_config_set_protocol";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E2FAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_resolver_config_set_provider_name(void *a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  int v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_resolver_config_set_provider_name_block_invoke;
    v14[3] = &unk_189BC66E8;
    uint64_t v5 = (os_unfair_lock_s *)v3;
    void v14[4] = v5;
    void v14[5] = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_set_provider_name_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v18 = "nw_resolver_config_set_provider_name";
  id v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v16 = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v7, &v16, &v15))
  {
    if (v16 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v18 = "nw_resolver_config_set_provider_name";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v16;
      BOOL v12 = os_log_type_enabled(v8, v16);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v18 = "nw_resolver_config_set_provider_name";
          __int16 v19 = 2082;
          __int16 v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v18 = "nw_resolver_config_set_provider_name";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v18 = "nw_resolver_config_set_provider_name";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E32A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_resolver_config_set_provider_path(void *a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  int v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_resolver_config_set_provider_path_block_invoke;
    v14[3] = &unk_189BC66E8;
    uint64_t v5 = (os_unfair_lock_s *)v3;
    void v14[4] = v5;
    void v14[5] = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_set_provider_path_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v18 = "nw_resolver_config_set_provider_path";
  id v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v16 = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v7, &v16, &v15))
  {
    if (v16 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v18 = "nw_resolver_config_set_provider_path";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v16;
      BOOL v12 = os_log_type_enabled(v8, v16);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v18 = "nw_resolver_config_set_provider_path";
          __int16 v19 = 2082;
          __int16 v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v18 = "nw_resolver_config_set_provider_path";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v18 = "nw_resolver_config_set_provider_path";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E35A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_set_provider_path_block_invoke(uint64_t a1)
{
}

void __nw_resolver_config_set_provider_name_block_invoke(uint64_t a1)
{
}

void __nw_resolver_config_set_protocol_block_invoke(uint64_t a1)
{
}

void __nw_resolver_config_set_class_block_invoke(uint64_t a1)
{
}

nw_resolver_config_t nw_resolver_config_create_tls(nw_endpoint_t server_endpoint)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  id v1 = server_endpoint;
  id v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)uuid_string_t string = 136446210;
    *(void *)&string[4] = "nw_resolver_config_create_tls";
    xpc_object_t v14 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    out[0] = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type[0];
      if (os_log_type_enabled(v15, type[0]))
      {
        *(_DWORD *)uuid_string_t string = 136446210;
        *(void *)&string[4] = "nw_resolver_config_create_tls";
        _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null server_endpoint", (uint8_t *)string, 0xCu);
      }
    }

    else if (out[0])
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type[0];
      BOOL v21 = os_log_type_enabled(v15, type[0]);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)uuid_string_t string = 136446466;
          *(void *)&string[4] = "nw_resolver_config_create_tls";
          *(_WORD *)&string[12] = 2082;
          *(void *)&string[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s called with null server_endpoint, dumping backtrace:%{public}s",  (uint8_t *)string,  0x16u);
        }

        free(backtrace_string);
        if (!v14) {
          goto LABEL_42;
        }
        goto LABEL_41;
      }

      if (v21)
      {
        *(_DWORD *)uuid_string_t string = 136446210;
        *(void *)&string[4] = "nw_resolver_config_create_tls";
        _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s called with null server_endpoint, no backtrace",  (uint8_t *)string,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type[0];
      if (os_log_type_enabled(v15, type[0]))
      {
        *(_DWORD *)uuid_string_t string = 136446210;
        *(void *)&string[4] = "nw_resolver_config_create_tls";
        _os_log_impl( &dword_181A5C000,  v15,  v25,  "%{public}s called with null server_endpoint, backtrace limit exceeded",  (uint8_t *)string,  0xCu);
      }
    }

    goto LABEL_39;
  }

  id v3 = v1;
  int v4 = -[nw_endpoint type](v3, "type");

  if ((v4 - 3) < 0xFFFFFFFE)
  {
    __nwlog_obj();
    __int16 v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)uuid_string_t string = 136446210;
    *(void *)&string[4] = "nw_resolver_config_create_tls";
    xpc_object_t v14 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    out[0] = 0;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type[0];
      if (os_log_type_enabled(v15, type[0]))
      {
        *(_DWORD *)uuid_string_t string = 136446210;
        *(void *)&string[4] = "nw_resolver_config_create_tls";
        _os_log_impl( &dword_181A5C000,  v15,  v18,  "%{public}s called with null (type == nw_endpoint_type_host || type == nw_endpoint_type_address)",  (uint8_t *)string,  0xCu);
      }
    }

    else if (out[0])
    {
      uint64_t v22 = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type[0];
      BOOL v24 = os_log_type_enabled(v15, type[0]);
      if (v22)
      {
        if (v24)
        {
          *(_DWORD *)uuid_string_t string = 136446466;
          *(void *)&string[4] = "nw_resolver_config_create_tls";
          *(_WORD *)&string[12] = 2082;
          *(void *)&string[14] = v22;
          _os_log_impl( &dword_181A5C000,  v15,  v23,  "%{public}s called with null (type == nw_endpoint_type_host || type == nw_endpoint_type_address), dumping bac ktrace:%{public}s",  (uint8_t *)string,  0x16u);
        }

        free(v22);
LABEL_40:
        if (!v14)
        {
LABEL_42:
          os_log_type_t v9 = 0LL;
          goto LABEL_6;
        }

void sub_1822E3BB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr((uint64_t)va);
  _Unwind_Resume(a1);
}

id nw_resolver_config_copy_dictionary(void *a1)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x4012000000LL;
    os_log_type_t v23 = __Block_byref_object_copy__12_53066;
    BOOL v24 = __Block_byref_object_dispose__13_53067;
    uint64_t v25 = 256LL;
    id v26 = 0LL;
    char v27 = -1;
    v17[0] = MEMORY[0x1895F87A8];
    v17[1] = 3221225472LL;
    v17[2] = __nw_resolver_config_copy_dictionary_block_invoke;
    v17[3] = &unk_189BC9210;
    __int16 v19 = buf;
    os_log_type_t v18 = (os_unfair_lock_s *)v1;
    id v3 = v18 + 22;
    os_unfair_lock_lock(v18 + 22);
    __nw_resolver_config_copy_dictionary_block_invoke((uint64_t)v17);
    os_unfair_lock_unlock(v3);
    uint64_t v4 = *(void *)&buf[8];
    id v5 = *(id *)(*(void *)&buf[8] + 48LL);
    uint64_t v6 = *(void **)(v4 + 48);
    *(void *)(v4 + 4_Block_object_dispose(va, 8) = 0LL;

    _Block_object_dispose(buf, 8);
    id v7 = v26;
    if ((v27 & 1) != 0 && v26)
    {
      id v26 = 0LL;

      id v7 = v26;
    }

    id v26 = 0LL;

    goto LABEL_6;
  }

  __nwlog_obj();
  os_log_type_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_config_copy_dictionary";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v10, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_copy_dictionary";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v20)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_copy_dictionary";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v15)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_copy_dictionary";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_copy_dictionary";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void __Block_byref_object_copy__12_53066(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = *(id *)(a2 + 48);
  *(_BYTE *)(a1 + 56) = *(_BYTE *)(a1 + 56) & 0xFE | *(_BYTE *)(a2 + 56) & 1;
  uint64_t v4 = *(void **)(a2 + 48);
  *(void *)(a2 + 4_Block_object_dispose(va, 8) = 0LL;

  *(_BYTE *)(a2 + 56) &= ~1u;
}

void __Block_byref_object_dispose__13_53067(uint64_t a1)
{
  id v2 = *(void **)(a1 + 48);
  if ((*(_BYTE *)(a1 + 56) & 1) != 0 && v2)
  {
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;

    id v2 = *(void **)(a1 + 48);
  }

  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
}

void __nw_resolver_config_copy_dictionary_block_invoke(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  uint64_t v4 = *(void **)(v3 + 48);
  if ((*(_BYTE *)(v3 + 56) & 1) != 0 && v4)
  {
    *(void *)(v3 + 4_Block_object_dispose(va, 8) = 0LL;

    uint64_t v4 = *(void **)(v3 + 48);
  }

  *(void *)(v3 + 4_Block_object_dispose(va, 8) = 0LL;

  id v5 = *(void **)(v3 + 48);
  *(void *)(v3 + 4_Block_object_dispose(va, 8) = v2;
  id v6 = v2;

  *(_BYTE *)(v3 + 56) |= 1u;
}

CFDataRef nw_resolver_config_copy_plist_data_ref(void *a1)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    *(void *)int v32 = 0LL;
    *(void *)&v32[8] = v32;
    *(void *)&v32[16] = 0x4012000000LL;
    os_log_type_t v33 = __Block_byref_object_copy__15;
    BOOL v34 = __Block_byref_object_dispose__16;
    os_log_type_t v35 = &unk_18296448D;
    CFTypeRef v36 = 0LL;
    char v37 = -1;
    v24[0] = MEMORY[0x1895F87A8];
    v24[1] = 3221225472LL;
    void v24[2] = __nw_resolver_config_copy_plist_data_ref_block_invoke;
    v24[3] = &unk_189BC9210;
    id v26 = v32;
    uint64_t v25 = (os_unfair_lock_s *)v1;
    uint64_t v3 = v25 + 22;
    os_unfair_lock_lock(v25 + 22);
    __nw_resolver_config_copy_plist_data_ref_block_invoke((uint64_t)v24);
    os_unfair_lock_unlock(v3);
    uint64_t v4 = *(const void **)(*(void *)&v32[8] + 48LL);
    if (v4)
    {
      CFDataRef Data = CFPropertyListCreateData( (CFAllocatorRef)*MEMORY[0x189604DB0],  v4,  kCFPropertyListBinaryFormat_v1_0,  0LL,  0LL);
LABEL_12:

      _Block_object_dispose(v32, 8);
      if ((v37 & 1) != 0 && v36) {
        CFRelease(v36);
      }
      goto LABEL_15;
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v29 = "nw_resolver_config_copy_plist_data_ref";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v7, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v29 = "nw_resolver_config_copy_plist_data_ref";
          _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s _CFXPCCreateCFObjectFromXPCObject failed", buf, 0xCu);
        }
      }

      else if (v23)
      {
        backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)__int128 buf = 136446466;
            uint64_t v29 = "nw_resolver_config_copy_plist_data_ref";
            __int16 v30 = 2082;
            uint64_t v31 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v8,  v12,  "%{public}s _CFXPCCreateCFObjectFromXPCObject failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          if (!v7) {
            goto LABEL_11;
          }
          goto LABEL_10;
        }

        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v29 = "nw_resolver_config_copy_plist_data_ref";
          _os_log_impl( &dword_181A5C000,  v8,  v12,  "%{public}s _CFXPCCreateCFObjectFromXPCObject failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (os_log_s *)(id)gLogObj;
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          uint64_t v29 = "nw_resolver_config_copy_plist_data_ref";
          _os_log_impl( &dword_181A5C000,  v8,  v14,  "%{public}s _CFXPCCreateCFObjectFromXPCObject failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v7)
    {
LABEL_11:
      CFDataRef Data = 0LL;
      goto LABEL_12;
    }

void sub_1822E46C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, uint64_t a30, uint64_t a31, char a32)
{
  _Block_object_dispose(&a25, 8);
  if ((a32 & 1) != 0)
  {
    os_log_type_t v35 = *(const void **)(v33 + 48);
    if (v35) {
      CFRelease(v35);
    }
  }

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__15(uint64_t result, uint64_t a2)
{
  *(void *)(result + 4_Block_object_dispose(va, 8) = *(void *)(a2 + 48);
  *(_BYTE *)(result + 56) = *(_BYTE *)(result + 56) & 0xFE | *(_BYTE *)(a2 + 56) & 1;
  *(void *)(a2 + 4_Block_object_dispose(va, 8) = 0LL;
  *(_BYTE *)(a2 + 56) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__16(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 56) & 1) != 0)
  {
    id v2 = *(const void **)(a1 + 48);
    if (v2) {
      CFRelease(v2);
    }
  }

  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
}

void __nw_resolver_config_copy_plist_data_ref_block_invoke(uint64_t a1)
{
  id v6 = *(id *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v2 = _CFXPCCreateCFObjectFromXPCObject();
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  char v4 = *(_BYTE *)(v3 + 56);
  if ((v4 & 1) != 0)
  {
    id v5 = *(const void **)(v3 + 48);
    if (v5)
    {
      CFRelease(v5);
      char v4 = *(_BYTE *)(v3 + 56);
    }
  }

  *(void *)(v3 + 4_Block_object_dispose(va, 8) = v2;
  *(_BYTE *)(v3 + 56) = v4 | 1;
}

void sub_1822E47D0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

dispatch_data_t nw_resolver_config_copy_plist_data(void *a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x4012000000LL;
    os_log_type_t v20 = __Block_byref_object_copy__18_53086;
    BOOL v21 = __Block_byref_object_dispose__19_53087;
    os_log_type_t v22 = &unk_18296448D;
    CFTypeRef cf = nw_resolver_config_copy_plist_data_ref(v1);
    v24 |= 1u;
    uint64_t v3 = *(const __CFData **)(*(void *)&buf[8] + 48LL);
    if (v3)
    {
      BytePtr = CFDataGetBytePtr(v3);
      CFIndex Length = CFDataGetLength(*(CFDataRef *)(*(void *)&buf[8] + 48LL));
      destructor[0] = MEMORY[0x1895F87A8];
      destructor[1] = 3221225472LL;
      destructor[2] = __nw_resolver_config_copy_plist_data_block_invoke;
      destructor[3] = &unk_189BC1630;
      destructor[4] = buf;
      dispatch_data_t v6 = dispatch_data_create(BytePtr, Length, 0LL, destructor);
    }

    else
    {
      dispatch_data_t v6 = 0LL;
    }

    _Block_object_dispose(buf, 8);
    if ((v24 & 1) != 0 && cf) {
      CFRelease(cf);
    }
    goto LABEL_8;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_config_copy_plist_data";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v9, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_copy_plist_data";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_copy_plist_data";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_copy_plist_data";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_copy_plist_data";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E4B50( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, uint64_t a24, CFTypeRef cf, char a26)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__18_53086(uint64_t result, uint64_t a2)
{
  *(void *)(result + 4_Block_object_dispose(va, 8) = *(void *)(a2 + 48);
  *(_BYTE *)(result + 56) = *(_BYTE *)(result + 56) & 0xFE | *(_BYTE *)(a2 + 56) & 1;
  *(void *)(a2 + 4_Block_object_dispose(va, 8) = 0LL;
  *(_BYTE *)(a2 + 56) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__19_53087(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 56) & 1) != 0)
  {
    uint64_t v2 = *(const void **)(a1 + 48);
    if (v2) {
      CFRelease(v2);
    }
  }

  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
}

void __nw_resolver_config_copy_plist_data_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 8LL);
  char v2 = *(_BYTE *)(v1 + 56);
  if ((v2 & 1) != 0)
  {
    uint64_t v3 = *(const void **)(v1 + 48);
    if (v3)
    {
      CFRelease(v3);
      char v2 = *(_BYTE *)(v1 + 56);
    }
  }

  *(void *)(v1 + 4_Block_object_dispose(va, 8) = 0LL;
  *(_BYTE *)(v1 + 56) = v2 | 1;
}

void nw_resolver_config_add_name_server(void *a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  char v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_resolver_config_add_name_server_block_invoke;
    v14[3] = &unk_189BC66E8;
    id v5 = (os_unfair_lock_s *)v3;
    void v14[4] = v5;
    void v14[5] = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_add_name_server_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  dispatch_data_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v18 = "nw_resolver_config_add_name_server";
  id v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v16 = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v7, &v16, &v15))
  {
    if (v16 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v18 = "nw_resolver_config_add_name_server";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v16;
      BOOL v12 = os_log_type_enabled(v8, v16);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v18 = "nw_resolver_config_add_name_server";
          __int16 v19 = 2082;
          os_log_type_t v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v18 = "nw_resolver_config_add_name_server";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v18 = "nw_resolver_config_add_name_server";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E4F14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_add_name_server_block_invoke(uint64_t a1)
{
  char v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (v2)
  {
    id v3 = 0LL;
  }

  else
  {
    id v3 = xpc_array_create(0LL, 0LL);
    char v2 = v3;
  }

  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, *(const char **)(a1 + 40));
  xpc_dictionary_set_value(*(xpc_object_t *)(*(void *)(a1 + 32) + 8LL), "NameServers", v2);

  if (v3) {
}
  }

void sub_1822E4FF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr((uint64_t)va);
  _Unwind_Resume(a1);
}

void nw_resolver_config_clear_name_servers(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  char v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_resolver_config_clear_name_servers_block_invoke;
    v12[3] = &unk_189BC93A0;
    id v3 = (os_unfair_lock_s *)v1;
    void v12[4] = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_name_servers_block_invoke((uint64_t)v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  char v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v16 = "nw_resolver_config_clear_name_servers";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      dispatch_data_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_name_servers";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      dispatch_data_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v16 = "nw_resolver_config_clear_name_servers";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_name_servers";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      dispatch_data_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_name_servers";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E52F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_clear_name_servers_block_invoke(uint64_t a1)
{
}

void nw_resolver_config_add_search_domain(void *a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  char v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_resolver_config_add_search_domain_block_invoke;
    v14[3] = &unk_189BC66E8;
    id v5 = (os_unfair_lock_s *)v3;
    void v14[4] = v5;
    void v14[5] = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_add_search_domain_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  dispatch_data_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v18 = "nw_resolver_config_add_search_domain";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v16 = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v7, &v16, &v15))
  {
    if (v16 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v18 = "nw_resolver_config_add_search_domain";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v16;
      BOOL v12 = os_log_type_enabled(v8, v16);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v18 = "nw_resolver_config_add_search_domain";
          __int16 v19 = 2082;
          os_log_type_t v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v18 = "nw_resolver_config_add_search_domain";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v18 = "nw_resolver_config_add_search_domain";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E5604(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_add_search_domain_block_invoke(uint64_t a1)
{
  char v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (v2)
  {
    id v3 = 0LL;
  }

  else
  {
    id v3 = xpc_array_create(0LL, 0LL);
    char v2 = v3;
  }

  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, *(const char **)(a1 + 40));
  xpc_dictionary_set_value(*(xpc_object_t *)(*(void *)(a1 + 32) + 8LL), "SearchDomains", v2);

  if (v3) {
}
  }

void sub_1822E56E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr((uint64_t)va);
  _Unwind_Resume(a1);
}

void nw_resolver_config_clear_search_domains(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  char v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_resolver_config_clear_search_domains_block_invoke;
    v12[3] = &unk_189BC93A0;
    id v3 = (os_unfair_lock_s *)v1;
    void v12[4] = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_search_domains_block_invoke((uint64_t)v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  char v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v16 = "nw_resolver_config_clear_search_domains";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      dispatch_data_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_search_domains";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      dispatch_data_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v16 = "nw_resolver_config_clear_search_domains";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_search_domains";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      dispatch_data_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_search_domains";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E59E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_clear_search_domains_block_invoke(uint64_t a1)
{
}

void nw_resolver_config_add_match_domain(void *a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  char v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_resolver_config_add_match_domain_block_invoke;
    v14[3] = &unk_189BC66E8;
    id v5 = (os_unfair_lock_s *)v3;
    void v14[4] = v5;
    void v14[5] = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_add_match_domain_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  dispatch_data_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v18 = "nw_resolver_config_add_match_domain";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v16 = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v7, &v16, &v15))
  {
    if (v16 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v18 = "nw_resolver_config_add_match_domain";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v16;
      BOOL v12 = os_log_type_enabled(v8, v16);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v18 = "nw_resolver_config_add_match_domain";
          __int16 v19 = 2082;
          os_log_type_t v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v18 = "nw_resolver_config_add_match_domain";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v18 = "nw_resolver_config_add_match_domain";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E5CF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_add_match_domain_block_invoke(uint64_t a1)
{
  char v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (v2)
  {
    id v3 = 0LL;
  }

  else
  {
    id v3 = xpc_array_create(0LL, 0LL);
    char v2 = v3;
  }

  xpc_array_set_string(v2, 0xFFFFFFFFFFFFFFFFLL, *(const char **)(a1 + 40));
  xpc_dictionary_set_value(*(xpc_object_t *)(*(void *)(a1 + 32) + 8LL), "MatchDomains", v2);

  if (v3) {
}
  }

void sub_1822E5DD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr((uint64_t)va);
  _Unwind_Resume(a1);
}

void nw_resolver_config_clear_match_domains(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  char v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_resolver_config_clear_match_domains_block_invoke;
    v12[3] = &unk_189BC93A0;
    id v3 = (os_unfair_lock_s *)v1;
    void v12[4] = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_match_domains_block_invoke((uint64_t)v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  char v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v16 = "nw_resolver_config_clear_match_domains";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      dispatch_data_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_match_domains";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      dispatch_data_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v16 = "nw_resolver_config_clear_match_domains";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_match_domains";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      dispatch_data_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_match_domains";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E60D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_clear_match_domains_block_invoke(uint64_t a1)
{
}

void nw_resolver_config_enumerate_match_domains(void *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    char v24 = __Block_byref_object_copy__22_52905;
    uint64_t v25 = __Block_byref_object_dispose__23_52906;
    uint64_t v5 = MEMORY[0x1895F87A8];
    id v26 = 0LL;
    v18[0] = MEMORY[0x1895F87A8];
    v18[1] = 3221225472LL;
    void v18[2] = __nw_resolver_config_enumerate_match_domains_block_invoke;
    v18[3] = &unk_189BC9210;
    os_log_type_t v20 = buf;
    uint64_t v19 = (os_unfair_lock_s *)v3;
    dispatch_data_t v6 = v19 + 22;
    os_unfair_lock_lock(v19 + 22);
    __nw_resolver_config_enumerate_match_domains_block_invoke((uint64_t)v18);
    os_unfair_lock_unlock(v6);
    os_log_type_t v7 = *(void **)(*(void *)&buf[8] + 40LL);
    if (v7)
    {
      applier[0] = v5;
      applier[1] = 3221225472LL;
      applier[2] = __nw_resolver_config_enumerate_match_domains_block_invoke_2;
      applier[3] = &unk_189BC0F80;
      id v17 = v4;
      xpc_array_apply(v7, applier);
    }

    _Block_object_dispose(buf, 8);
    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_match_domains";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (__nwlog_fault(v9, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_match_domains";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v21)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_match_domains";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_match_domains";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_match_domains";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E648C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, id a30)
{
  _Block_object_dispose(&a25, 8);
  _Unwind_Resume(a1);
}

void __nw_resolver_config_enumerate_match_domains_block_invoke(uint64_t a1)
{
  id v5 = *(id *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v2 = xpc_dictionary_get_value(v5, "MatchDomains");
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_1822E6530( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t __nw_resolver_config_enumerate_match_domains_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (object_getClass(v4) == (Class)MEMORY[0x1895F92E8])
  {
    uint64_t v6 = *(void *)(a1 + 32);
    string_ptr = xpc_string_get_string_ptr(v4);
    uint64_t v5 = (*(uint64_t (**)(uint64_t, const char *))(v6 + 16))(v6, string_ptr);
  }

  else
  {
    uint64_t v5 = 1LL;
  }

  return v5;
}

void sub_1822E65AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_resolver_config_add_server_raw_public_key(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  uint64_t v6 = v5;
  if (v5)
  {
    v16[0] = MEMORY[0x1895F87A8];
    v16[1] = 3221225472LL;
    v16[2] = __nw_resolver_config_add_server_raw_public_key_block_invoke;
    v16[3] = &unk_189BC73F8;
    os_log_type_t v7 = (os_unfair_lock_s *)v5;
    void v16[4] = v7;
    void v16[5] = a2;
    v16[6] = a3;
    os_unfair_lock_lock(v7 + 22);
    __nw_resolver_config_add_server_raw_public_key_block_invoke((uint64_t)v16);
    os_unfair_lock_unlock(v7 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v20 = "nw_resolver_config_add_server_raw_public_key";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v18 = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v9, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v18;
      if (os_log_type_enabled(v10, v18))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v20 = "nw_resolver_config_add_server_raw_public_key";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v18;
      BOOL v14 = os_log_type_enabled(v10, v18);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v20 = "nw_resolver_config_add_server_raw_public_key";
          __int16 v21 = 2082;
          os_log_type_t v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v20 = "nw_resolver_config_add_server_raw_public_key";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = v18;
      if (os_log_type_enabled(v10, v18))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v20 = "nw_resolver_config_add_server_raw_public_key";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E68A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_add_server_raw_public_key_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (v2)
  {
    id v3 = 0LL;
  }

  else
  {
    id v3 = xpc_array_create(0LL, 0LL);
    uint64_t v2 = v3;
  }

  xpc_array_set_data(v2, 0xFFFFFFFFFFFFFFFFLL, *(const void **)(a1 + 40), *(void *)(a1 + 48));
  xpc_dictionary_set_value(*(xpc_object_t *)(*(void *)(a1 + 32) + 8LL), "ServerRawPublicKey", v2);

  if (v3) {
}
  }

void sub_1822E6980(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr((uint64_t)va);
  _Unwind_Resume(a1);
}

void nw_resolver_config_clear_server_raw_public_keys(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_resolver_config_clear_server_raw_public_keys_block_invoke;
    v12[3] = &unk_189BC93A0;
    id v3 = (os_unfair_lock_s *)v1;
    void v12[4] = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_server_raw_public_keys_block_invoke((uint64_t)v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v16 = "nw_resolver_config_clear_server_raw_public_keys";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_server_raw_public_keys";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v16 = "nw_resolver_config_clear_server_raw_public_keys";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_server_raw_public_keys";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_server_raw_public_keys";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E6C80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_clear_server_raw_public_keys_block_invoke(uint64_t a1)
{
}

void nw_resolver_config_enumerate_server_raw_public_keys(void *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    char v24 = __Block_byref_object_copy__22_52905;
    uint64_t v25 = __Block_byref_object_dispose__23_52906;
    uint64_t v5 = MEMORY[0x1895F87A8];
    id v26 = 0LL;
    v18[0] = MEMORY[0x1895F87A8];
    v18[1] = 3221225472LL;
    void v18[2] = __nw_resolver_config_enumerate_server_raw_public_keys_block_invoke;
    v18[3] = &unk_189BC9210;
    os_log_type_t v20 = buf;
    uint64_t v19 = (os_unfair_lock_s *)v3;
    uint64_t v6 = v19 + 22;
    os_unfair_lock_lock(v19 + 22);
    __nw_resolver_config_enumerate_server_raw_public_keys_block_invoke((uint64_t)v18);
    os_unfair_lock_unlock(v6);
    os_log_type_t v7 = *(void **)(*(void *)&buf[8] + 40LL);
    if (v7)
    {
      applier[0] = v5;
      applier[1] = 3221225472LL;
      applier[2] = __nw_resolver_config_enumerate_server_raw_public_keys_block_invoke_2;
      applier[3] = &unk_189BC0F80;
      id v17 = v4;
      xpc_array_apply(v7, applier);
    }

    _Block_object_dispose(buf, 8);
    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_server_raw_public_keys";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (__nwlog_fault(v9, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_server_raw_public_keys";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v21)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_server_raw_public_keys";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_server_raw_public_keys";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_server_raw_public_keys";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E703C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, id a30)
{
  _Block_object_dispose(&a25, 8);
  _Unwind_Resume(a1);
}

void __nw_resolver_config_enumerate_server_raw_public_keys_block_invoke(uint64_t a1)
{
  id v5 = *(id *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v2 = xpc_dictionary_get_value(v5, "ServerRawPublicKey");
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_1822E70E0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t __nw_resolver_config_enumerate_server_raw_public_keys_block_invoke_2( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (object_getClass(v4) == (Class)MEMORY[0x1895F9240])
  {
    uint64_t v6 = *(void *)(a1 + 32);
    bytes_ptr = xpc_data_get_bytes_ptr(v4);
    size_t length = xpc_data_get_length(v4);
    uint64_t v5 = (*(uint64_t (**)(uint64_t, const void *, size_t))(v6 + 16))(v6, bytes_ptr, length);
  }

  else
  {
    uint64_t v5 = 1LL;
  }

  return v5;
}

void sub_1822E7174(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_resolver_config_add_client_raw_public_key(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  uint64_t v6 = v5;
  if (v5)
  {
    v16[0] = MEMORY[0x1895F87A8];
    v16[1] = 3221225472LL;
    v16[2] = __nw_resolver_config_add_client_raw_public_key_block_invoke;
    v16[3] = &unk_189BC73F8;
    os_log_type_t v7 = (os_unfair_lock_s *)v5;
    void v16[4] = v7;
    void v16[5] = a2;
    v16[6] = a3;
    os_unfair_lock_lock(v7 + 22);
    __nw_resolver_config_add_client_raw_public_key_block_invoke((uint64_t)v16);
    os_unfair_lock_unlock(v7 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v20 = "nw_resolver_config_add_client_raw_public_key";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v18 = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v9, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v18;
      if (os_log_type_enabled(v10, v18))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v20 = "nw_resolver_config_add_client_raw_public_key";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v18;
      BOOL v14 = os_log_type_enabled(v10, v18);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v20 = "nw_resolver_config_add_client_raw_public_key";
          __int16 v21 = 2082;
          os_log_type_t v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v20 = "nw_resolver_config_add_client_raw_public_key";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = v18;
      if (os_log_type_enabled(v10, v18))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v20 = "nw_resolver_config_add_client_raw_public_key";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E746C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_add_client_raw_public_key_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (v2)
  {
    id v3 = 0LL;
  }

  else
  {
    id v3 = xpc_array_create(0LL, 0LL);
    uint64_t v2 = v3;
  }

  xpc_array_set_data(v2, 0xFFFFFFFFFFFFFFFFLL, *(const void **)(a1 + 40), *(void *)(a1 + 48));
  xpc_dictionary_set_value(*(xpc_object_t *)(*(void *)(a1 + 32) + 8LL), "ClientRawPublicKey", v2);

  if (v3) {
}
  }

void sub_1822E7548(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr((uint64_t)va);
  _Unwind_Resume(a1);
}

void nw_resolver_config_clear_client_raw_public_keys(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_resolver_config_clear_client_raw_public_keys_block_invoke;
    v12[3] = &unk_189BC93A0;
    id v3 = (os_unfair_lock_s *)v1;
    void v12[4] = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_client_raw_public_keys_block_invoke((uint64_t)v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v16 = "nw_resolver_config_clear_client_raw_public_keys";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_client_raw_public_keys";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v16 = "nw_resolver_config_clear_client_raw_public_keys";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_client_raw_public_keys";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_client_raw_public_keys";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E7848(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_clear_client_raw_public_keys_block_invoke(uint64_t a1)
{
}

void nw_resolver_config_enumerate_client_raw_public_keys(void *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000LL;
    char v24 = __Block_byref_object_copy__22_52905;
    uint64_t v25 = __Block_byref_object_dispose__23_52906;
    uint64_t v5 = MEMORY[0x1895F87A8];
    id v26 = 0LL;
    v18[0] = MEMORY[0x1895F87A8];
    v18[1] = 3221225472LL;
    void v18[2] = __nw_resolver_config_enumerate_client_raw_public_keys_block_invoke;
    v18[3] = &unk_189BC9210;
    os_log_type_t v20 = buf;
    uint64_t v19 = (os_unfair_lock_s *)v3;
    uint64_t v6 = v19 + 22;
    os_unfair_lock_lock(v19 + 22);
    __nw_resolver_config_enumerate_client_raw_public_keys_block_invoke((uint64_t)v18);
    os_unfair_lock_unlock(v6);
    os_log_type_t v7 = *(void **)(*(void *)&buf[8] + 40LL);
    if (v7)
    {
      applier[0] = v5;
      applier[1] = 3221225472LL;
      applier[2] = __nw_resolver_config_enumerate_client_raw_public_keys_block_invoke_2;
      applier[3] = &unk_189BC0F80;
      id v17 = v4;
      xpc_array_apply(v7, applier);
    }

    _Block_object_dispose(buf, 8);
    goto LABEL_5;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_client_raw_public_keys";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (__nwlog_fault(v9, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_client_raw_public_keys";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v21)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_client_raw_public_keys";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_client_raw_public_keys";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_enumerate_client_raw_public_keys";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E7C04( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, void *a22, uint64_t a23, uint64_t a24, char a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, id a30)
{
  _Block_object_dispose(&a25, 8);
  _Unwind_Resume(a1);
}

void __nw_resolver_config_enumerate_client_raw_public_keys_block_invoke(uint64_t a1)
{
  id v5 = *(id *)(*(void *)(a1 + 32) + 8LL);
  uint64_t v2 = xpc_dictionary_get_value(v5, "ClientRawPublicKey");
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8LL);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_1822E7CA8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

uint64_t __nw_resolver_config_enumerate_client_raw_public_keys_block_invoke_2( uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (object_getClass(v4) == (Class)MEMORY[0x1895F9240])
  {
    uint64_t v6 = *(void *)(a1 + 32);
    bytes_ptr = xpc_data_get_bytes_ptr(v4);
    size_t length = xpc_data_get_length(v4);
    uint64_t v5 = (*(uint64_t (**)(uint64_t, const void *, size_t))(v6 + 16))(v6, bytes_ptr, length);
  }

  else
  {
    uint64_t v5 = 1LL;
  }

  return v5;
}

void sub_1822E7D3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_resolver_config_set_interface_name(void *a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_resolver_config_set_interface_name_block_invoke;
    v14[3] = &unk_189BC66E8;
    uint64_t v5 = (os_unfair_lock_s *)v3;
    void v14[4] = v5;
    void v14[5] = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_set_interface_name_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v18 = "nw_resolver_config_set_interface_name";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v16 = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v7, &v16, &v15))
  {
    if (v16 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v18 = "nw_resolver_config_set_interface_name";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v16;
      BOOL v12 = os_log_type_enabled(v8, v16);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v18 = "nw_resolver_config_set_interface_name";
          __int16 v19 = 2082;
          os_log_type_t v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v18 = "nw_resolver_config_set_interface_name";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v18 = "nw_resolver_config_set_interface_name";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E802C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_set_interface_name_block_invoke(uint64_t a1)
{
}

void nw_resolver_config_clear_interface_name(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_resolver_config_clear_interface_name_block_invoke;
    v12[3] = &unk_189BC93A0;
    id v3 = (os_unfair_lock_s *)v1;
    void v12[4] = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_interface_name_block_invoke((uint64_t)v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  id v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v16 = "nw_resolver_config_clear_interface_name";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_interface_name";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v16 = "nw_resolver_config_clear_interface_name";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_interface_name";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_interface_name";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E8338(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_clear_interface_name_block_invoke(uint64_t a1)
{
}

uint64_t nw_resolver_config_get_interface_name(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    uint64_t v20 = 0LL;
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_resolver_config_get_interface_name_block_invoke;
    v14[3] = &unk_189BC9210;
    os_log_type_t v16 = buf;
    char v15 = (os_unfair_lock_s *)v1;
    id v3 = v15 + 22;
    os_unfair_lock_lock(v15 + 22);
    __nw_resolver_config_get_interface_name_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v3);
    uint64_t v4 = *(void *)(*(void *)&buf[8] + 24LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_config_get_interface_name";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_interface_name";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_get_interface_name";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_interface_name";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_interface_name";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E8684( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_resolver_config_get_interface_name_block_invoke(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 8LL);
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = xpc_dictionary_get_string(v2, "InterfaceName");
}

void sub_1822E8700( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void nw_resolver_config_clear_provider_description(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_resolver_config_clear_provider_description_block_invoke;
    v12[3] = &unk_189BC93A0;
    id v3 = (os_unfair_lock_s *)v1;
    void v12[4] = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_provider_description_block_invoke((uint64_t)v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v16 = "nw_resolver_config_clear_provider_description";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_provider_description";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v16 = "nw_resolver_config_clear_provider_description";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_provider_description";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_provider_description";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E89F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_clear_provider_description_block_invoke(uint64_t a1)
{
}

uint64_t nw_resolver_config_get_provider_description(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    uint64_t v20 = 0LL;
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_resolver_config_get_provider_description_block_invoke;
    v14[3] = &unk_189BC9210;
    os_log_type_t v16 = buf;
    char v15 = (os_unfair_lock_s *)v1;
    id v3 = v15 + 22;
    os_unfair_lock_lock(v15 + 22);
    __nw_resolver_config_get_provider_description_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v3);
    uint64_t v4 = *(void *)(*(void *)&buf[8] + 24LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_config_get_provider_description";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_provider_description";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_get_provider_description";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_provider_description";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_provider_description";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E8D3C( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_resolver_config_get_provider_description_block_invoke(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 8LL);
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = xpc_dictionary_get_string(v2, "ProviderDescription");
}

void sub_1822E8DB8( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void nw_resolver_config_clear_provider_name(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_resolver_config_clear_provider_name_block_invoke;
    v12[3] = &unk_189BC93A0;
    id v3 = (os_unfair_lock_s *)v1;
    void v12[4] = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_provider_name_block_invoke((uint64_t)v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v16 = "nw_resolver_config_clear_provider_name";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_provider_name";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v16 = "nw_resolver_config_clear_provider_name";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_provider_name";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_provider_name";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E90A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_clear_provider_name_block_invoke(uint64_t a1)
{
}

void nw_resolver_config_clear_provider_path(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_resolver_config_clear_provider_path_block_invoke;
    v12[3] = &unk_189BC93A0;
    id v3 = (os_unfair_lock_s *)v1;
    void v12[4] = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_provider_path_block_invoke((uint64_t)v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v16 = "nw_resolver_config_clear_provider_path";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_provider_path";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v16 = "nw_resolver_config_clear_provider_path";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_provider_path";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_provider_path";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E93B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_clear_provider_path_block_invoke(uint64_t a1)
{
}

void nw_resolver_config_set_proxy_agent(void *a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_resolver_config_set_proxy_agent_block_invoke;
    v14[3] = &unk_189BC66E8;
    uint64_t v5 = (os_unfair_lock_s *)v3;
    void v14[4] = v5;
    void v14[5] = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_set_proxy_agent_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v18 = "nw_resolver_config_set_proxy_agent";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v16 = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v7, &v16, &v15))
  {
    if (v16 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v18 = "nw_resolver_config_set_proxy_agent";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v16;
      BOOL v12 = os_log_type_enabled(v8, v16);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v18 = "nw_resolver_config_set_proxy_agent";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v18 = "nw_resolver_config_set_proxy_agent";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v18 = "nw_resolver_config_set_proxy_agent";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E96CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_set_proxy_agent_block_invoke(uint64_t a1)
{
}

void nw_resolver_config_clear_proxy_agent(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_resolver_config_clear_proxy_agent_block_invoke;
    v12[3] = &unk_189BC93A0;
    id v3 = (os_unfair_lock_s *)v1;
    void v12[4] = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_proxy_agent_block_invoke((uint64_t)v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v16 = "nw_resolver_config_clear_proxy_agent";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_proxy_agent";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v16 = "nw_resolver_config_clear_proxy_agent";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_proxy_agent";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_proxy_agent";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E99D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_clear_proxy_agent_block_invoke(uint64_t a1)
{
}

uint64_t nw_resolver_config_get_proxy_agent(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    uint64_t v20 = 0LL;
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_resolver_config_get_proxy_agent_block_invoke;
    v14[3] = &unk_189BC9210;
    os_log_type_t v16 = buf;
    char v15 = (os_unfair_lock_s *)v1;
    id v3 = v15 + 22;
    os_unfair_lock_lock(v15 + 22);
    __nw_resolver_config_get_proxy_agent_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v3);
    uint64_t v4 = *(void *)(*(void *)&buf[8] + 24LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_config_get_proxy_agent";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_proxy_agent";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_get_proxy_agent";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_proxy_agent";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_proxy_agent";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822E9D24( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_resolver_config_get_proxy_agent_block_invoke(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 8LL);
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = xpc_dictionary_get_string(v2, "ProxyAgent");
}

void sub_1822E9DA0( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void nw_resolver_config_set_identity_reference(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  uint64_t v6 = v5;
  if (v5)
  {
    v16[0] = MEMORY[0x1895F87A8];
    v16[1] = 3221225472LL;
    v16[2] = __nw_resolver_config_set_identity_reference_block_invoke;
    v16[3] = &unk_189BC73F8;
    os_log_type_t v7 = (os_unfair_lock_s *)v5;
    void v16[4] = v7;
    void v16[5] = a2;
    v16[6] = a3;
    os_unfair_lock_lock(v7 + 22);
    __nw_resolver_config_set_identity_reference_block_invoke((uint64_t)v16);
    os_unfair_lock_unlock(v7 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v20 = "nw_resolver_config_set_identity_reference";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v18 = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v9, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v18;
      if (os_log_type_enabled(v10, v18))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v20 = "nw_resolver_config_set_identity_reference";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v18;
      BOOL v14 = os_log_type_enabled(v10, v18);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v20 = "nw_resolver_config_set_identity_reference";
          __int16 v21 = 2082;
          os_log_type_t v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v20 = "nw_resolver_config_set_identity_reference";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = v18;
      if (os_log_type_enabled(v10, v18))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v20 = "nw_resolver_config_set_identity_reference";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822EA09C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_set_identity_reference_block_invoke(uint64_t a1)
{
}

void nw_resolver_config_clear_identity_reference(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_resolver_config_clear_identity_reference_block_invoke;
    v12[3] = &unk_189BC93A0;
    id v3 = (os_unfair_lock_s *)v1;
    void v12[4] = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_identity_reference_block_invoke((uint64_t)v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v16 = "nw_resolver_config_clear_identity_reference";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_identity_reference";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v16 = "nw_resolver_config_clear_identity_reference";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_identity_reference";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_identity_reference";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822EA3B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_clear_identity_reference_block_invoke(uint64_t a1)
{
}

uint64_t nw_resolver_config_get_identity_reference(void *a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    uint64_t v23 = 0LL;
    v16[0] = MEMORY[0x1895F87A8];
    v16[1] = 3221225472LL;
    v16[2] = __nw_resolver_config_get_identity_reference_block_invoke;
    v16[3] = &unk_189BC93F0;
    os_log_type_t v18 = buf;
    __int16 v17 = (os_unfair_lock_s *)v3;
    uint64_t v19 = a2;
    id v5 = v17 + 22;
    os_unfair_lock_lock(v17 + 22);
    __nw_resolver_config_get_identity_reference_block_invoke((uint64_t)v16);
    os_unfair_lock_unlock(v5);
    uint64_t v6 = *(void *)(*(void *)&buf[8] + 24LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_config_get_identity_reference";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v9, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_identity_reference";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v20)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_get_identity_reference";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_identity_reference";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_identity_reference";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822EA704( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_resolver_config_get_identity_reference_block_invoke(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 8LL);
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = xpc_dictionary_get_data( v2,  "IdentityReference",  *(size_t **)(a1 + 48));
}

void sub_1822EA784( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void nw_resolver_config_set_odoh_config(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  uint64_t v6 = v5;
  if (v5)
  {
    v16[0] = MEMORY[0x1895F87A8];
    v16[1] = 3221225472LL;
    v16[2] = __nw_resolver_config_set_odoh_config_block_invoke;
    v16[3] = &unk_189BC73F8;
    os_log_type_t v7 = (os_unfair_lock_s *)v5;
    void v16[4] = v7;
    void v16[5] = a2;
    v16[6] = a3;
    os_unfair_lock_lock(v7 + 22);
    __nw_resolver_config_set_odoh_config_block_invoke((uint64_t)v16);
    os_unfair_lock_unlock(v7 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  char v20 = "nw_resolver_config_set_odoh_config";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v18 = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v9, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = v18;
      if (os_log_type_enabled(v10, v18))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v20 = "nw_resolver_config_set_odoh_config";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = v18;
      BOOL v14 = os_log_type_enabled(v10, v18);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          char v20 = "nw_resolver_config_set_odoh_config";
          __int16 v21 = 2082;
          os_log_type_t v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v20 = "nw_resolver_config_set_odoh_config";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = v18;
      if (os_log_type_enabled(v10, v18))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v20 = "nw_resolver_config_set_odoh_config";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822EAA80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_set_odoh_config_block_invoke(uint64_t a1)
{
}

void nw_resolver_config_clear_odoh_config(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1895F87A8];
    v12[1] = 3221225472LL;
    v12[2] = __nw_resolver_config_clear_odoh_config_block_invoke;
    v12[3] = &unk_189BC93A0;
    id v3 = (os_unfair_lock_s *)v1;
    void v12[4] = v3;
    os_unfair_lock_lock(v3 + 22);
    __nw_resolver_config_clear_odoh_config_block_invoke((uint64_t)v12);
    os_unfair_lock_unlock(v3 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v4 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v16 = "nw_resolver_config_clear_odoh_config";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_odoh_config";
        _os_log_impl(&dword_181A5C000, v6, v7, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v16 = "nw_resolver_config_clear_odoh_config";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v6,  v9,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v10)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_odoh_config";
        _os_log_impl(&dword_181A5C000, v6, v9, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v6 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_clear_odoh_config";
        _os_log_impl( &dword_181A5C000,  v6,  v11,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822EAD94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_clear_odoh_config_block_invoke(uint64_t a1)
{
}

uint64_t nw_resolver_config_get_odoh_config(void *a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    uint64_t v23 = 0LL;
    v16[0] = MEMORY[0x1895F87A8];
    v16[1] = 3221225472LL;
    v16[2] = __nw_resolver_config_get_odoh_config_block_invoke;
    v16[3] = &unk_189BC93F0;
    os_log_type_t v18 = buf;
    __int16 v17 = (os_unfair_lock_s *)v3;
    uint64_t v19 = a2;
    id v5 = v17 + 22;
    os_unfair_lock_lock(v17 + 22);
    __nw_resolver_config_get_odoh_config_block_invoke((uint64_t)v16);
    os_unfair_lock_unlock(v5);
    uint64_t v6 = *(void *)(*(void *)&buf[8] + 24LL);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_config_get_odoh_config";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v9, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_odoh_config";
        _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v20)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_get_odoh_config";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v14)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_odoh_config";
        _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_odoh_config";
        _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822EB0E8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_resolver_config_get_odoh_config_block_invoke(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 8LL);
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = xpc_dictionary_get_data( v2,  "ODoHConfig",  *(size_t **)(a1 + 48));
}

void sub_1822EB168( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void nw_resolver_config_set_allow_failover(void *a1, char a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_resolver_config_set_allow_failover_block_invoke;
    v14[3] = &unk_189BC5EB8;
    id v5 = (os_unfair_lock_s *)v3;
    void v14[4] = v5;
    char v15 = a2;
    os_unfair_lock_lock(v5 + 22);
    __nw_resolver_config_set_allow_failover_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v5 + 22);

    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v19 = "nw_resolver_config_set_allow_failover";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v19 = "nw_resolver_config_set_allow_failover";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v16)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v19 = "nw_resolver_config_set_allow_failover";
          __int16 v20 = 2082;
          __int16 v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v19 = "nw_resolver_config_set_allow_failover";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v19 = "nw_resolver_config_set_allow_failover";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822EB460(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_set_allow_failover_block_invoke(uint64_t a1)
{
}

BOOL nw_resolver_config_get_allow_failover(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    *(void *)__int128 buf = 0LL;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000LL;
    char v20 = 0;
    v14[0] = MEMORY[0x1895F87A8];
    v14[1] = 3221225472LL;
    v14[2] = __nw_resolver_config_get_allow_failover_block_invoke;
    v14[3] = &unk_189BC9210;
    char v16 = buf;
    char v15 = (os_unfair_lock_s *)v1;
    id v3 = v15 + 22;
    os_unfair_lock_lock(v15 + 22);
    __nw_resolver_config_get_allow_failover_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v3);
    BOOL v4 = *(_BYTE *)(*(void *)&buf[8] + 24LL) != 0;

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }

  __nwlog_obj();
  uint64_t v6 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_config_get_allow_failover";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_allow_failover";
        _os_log_impl(&dword_181A5C000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v17)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_get_allow_failover";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v8,  v11,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v12)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_allow_failover";
        _os_log_impl(&dword_181A5C000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v8 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_get_allow_failover";
        _os_log_impl( &dword_181A5C000,  v8,  v13,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822EB7B8( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __nw_resolver_config_get_allow_failover_block_invoke(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 8LL);
  *(_BYTE *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = xpc_dictionary_get_BOOL(v2, "AllowFailover");
}

void sub_1822EB834( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

id nw_resolver_config_copy_proxy_config(void *a1)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    __nwlog_obj();
    os_log_type_t v8 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)uu = 136446210;
    *(void *)&uu[4] = "nw_resolver_config_copy_proxy_config";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v9, type, &v19))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v11 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *(_DWORD *)uu = 136446210;
          *(void *)&uu[4] = "nw_resolver_config_copy_proxy_config";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s called with null config", uu, 0xCu);
        }
      }

      else if (v19)
      {
        backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v13 = type[0];
        BOOL v14 = os_log_type_enabled(v10, type[0]);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)uu = 136446466;
            *(void *)&uu[4] = "nw_resolver_config_copy_proxy_config";
            *(_WORD *)&uu[12] = 2082;
            *(void *)&uu[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v10,  v13,  "%{public}s called with null config, dumping backtrace:%{public}s",  uu,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }

        if (v14)
        {
          *(_DWORD *)uu = 136446210;
          *(void *)&uu[4] = "nw_resolver_config_copy_proxy_config";
          _os_log_impl(&dword_181A5C000, v10, v13, "%{public}s called with null config, no backtrace", uu, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *(_DWORD *)uu = 136446210;
          *(void *)&uu[4] = "nw_resolver_config_copy_proxy_config";
          _os_log_impl( &dword_181A5C000,  v10,  v15,  "%{public}s called with null config, backtrace limit exceeded",  uu,  0xCu);
        }
      }
    }

void sub_1822EBB60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  _Unwind_Resume(a1);
}

void nw_resolver_config_add_server_address(nw_resolver_config_t config, nw_endpoint_t server_address)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  id v3 = config;
  id v4 = server_address;
  id v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    BOOL v10 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    int v32 = "nw_resolver_config_add_server_address";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v32 = "nw_resolver_config_add_server_address";
        _os_log_impl(&dword_181A5C000, v12, v13, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v29)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)__int128 buf = 136446466;
          int v32 = "nw_resolver_config_add_server_address";
          __int16 v33 = 2082;
          BOOL v34 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v12,  v19,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v11) {
          goto LABEL_5;
        }
LABEL_56:
        free(v11);
        goto LABEL_5;
      }

      if (v20)
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v32 = "nw_resolver_config_add_server_address";
        _os_log_impl(&dword_181A5C000, v12, v19, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v32 = "nw_resolver_config_add_server_address";
        _os_log_impl( &dword_181A5C000,  v12,  v26,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_1822EC274(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_resolver_config_get_identifier(void *a1, _OWORD *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *a2 = *(_OWORD *)(v3 + 24);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  char v16 = "nw_resolver_config_get_identifier";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v16 = "nw_resolver_config_get_identifier";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          char v16 = "nw_resolver_config_get_identifier";
          __int16 v17 = 2082;
          char v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v16 = "nw_resolver_config_get_identifier";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v16 = "nw_resolver_config_get_identifier";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_resolver_config_set_generation(void *a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *((_DWORD *)v3 + 23) = a2;
    goto LABEL_3;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  char v16 = "nw_resolver_config_set_generation";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v16 = "nw_resolver_config_set_generation";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          char v16 = "nw_resolver_config_set_generation";
          __int16 v17 = 2082;
          char v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v16 = "nw_resolver_config_set_generation";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v16 = "nw_resolver_config_set_generation";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_resolver_config_watch_updates(void *a1, void *a2, void *a3)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  os_log_type_t v8 = v7;
  if (!v5)
  {
    __nwlog_obj();
    char v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v38 = "nw_resolver_config_watch_updates";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v36 = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (v36 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = v36;
      if (os_log_type_enabled(v15, v36))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v38 = "nw_resolver_config_watch_updates";
        _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v35)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = v36;
      BOOL v23 = os_log_type_enabled(v15, v36);
      if (backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v38 = "nw_resolver_config_watch_updates";
          __int16 v39 = 2082;
          uint64_t v40 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v22,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_57:
        if (!v14) {
          goto LABEL_7;
        }
LABEL_58:
        free(v14);
        goto LABEL_7;
      }

      if (v23)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v38 = "nw_resolver_config_watch_updates";
        _os_log_impl(&dword_181A5C000, v15, v22, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      os_log_type_t v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v29 = v36;
      if (os_log_type_enabled(v15, v36))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v38 = "nw_resolver_config_watch_updates";
        _os_log_impl( &dword_181A5C000,  v15,  v29,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_1822ECF38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_watch_updates_block_invoke(void *a1)
{
  uint64_t v57 = *MEMORY[0x1895F89C0];
  id v1 = (dispatch_object_t *)a1[4];
  if (!v1[5])
  {
    id v2 = (void *)a1[5];
    id v3 = (void *)a1[6];
    id v4 = v1;
    id v5 = v2;
    id v6 = v3;
    int v7 = socket(32, 3, 1);
    unsigned int v8 = v7;
    if (v7 < 0)
    {
LABEL_68:

      return;
    }

    uint64_t v9 = (dispatch_object_s *)nw_fd_wrapper_create(v7);
    nw_fd_wrapper_guard(v9);
    int v52 = 9;
    uint64_t v51 = 0x100000001LL;
    if (ioctl(v8, 0x800C6502uLL, &v51))
    {
      int v10 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v11 = (id)gLogObj;
      *(_DWORD *)__int128 buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_resolver_config_watch_kernel_events";
      *(_WORD *)&_BYTE buf[12] = 1024;
      *(_DWORD *)&buf[14] = v10;
      id v12 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v50) = 0;
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v13 = (os_log_s *)(id)gLogObj;
        os_log_type_t v14 = type[0];
        if (os_log_type_enabled(v13, type[0]))
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_watch_kernel_events";
          *(_WORD *)&_BYTE buf[12] = 1024;
          *(_DWORD *)&buf[14] = v10;
          _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s ioctl(SIOCSKEVFILT) failed %{darwin.errno}d", buf, 0x12u);
        }

void sub_1822ED940(_Unwind_Exception *a1)
{
  if (v4) {

  }
  _Unwind_Resume(a1);
}

BOOL nw_resolver_config_update_from_path(NWConcrete_nw_resolver_config *a1)
{
  id v1 = a1;
  uint64_t v9 = 0LL;
  int v10 = &v9;
  uint64_t v11 = 0x4012000000LL;
  id v12 = __Block_byref_object_copy__120;
  char v13 = __Block_byref_object_dispose__121;
  uint64_t v14 = 256LL;
  int v15 = nw_path_copy_resolver_config_for_identifier((uint64_t)v1->identifier);
  v16 |= 1u;
  uint64_t v2 = v10[6];
  if (v2)
  {
    v6[0] = MEMORY[0x1895F87A8];
    v6[1] = 3221225472LL;
    v6[2] = ___ZL35nw_resolver_config_update_from_pathP29NWConcrete_nw_resolver_config_block_invoke;
    _OWORD v6[3] = &unk_189BC9210;
    int v7 = v1;
    unsigned int v8 = &v9;
    id v3 = v7 + 22;
    os_unfair_lock_lock(v7 + 22);
    ___ZL35nw_resolver_config_update_from_pathP29NWConcrete_nw_resolver_config_block_invoke((uint64_t)v6);
    os_unfair_lock_unlock(v3);
  }

  _Block_object_dispose(&v9, 8);
  id v4 = v15;
  if ((v16 & 1) != 0 && v15)
  {
    int v15 = 0LL;

    id v4 = v15;
  }

  int v15 = 0LL;

  return v2 != 0;
}

void sub_1822EDAA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_resolver_config_watch_updates_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

void __Block_byref_object_copy__120(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 4_Block_object_dispose(va, 8) = *(id *)(a2 + 48);
  *(_BYTE *)(a1 + 56) = *(_BYTE *)(a1 + 56) & 0xFE | *(_BYTE *)(a2 + 56) & 1;
  id v4 = *(void **)(a2 + 48);
  *(void *)(a2 + 4_Block_object_dispose(va, 8) = 0LL;

  *(_BYTE *)(a2 + 56) &= ~1u;
}

void __Block_byref_object_dispose__121(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if ((*(_BYTE *)(a1 + 56) & 1) != 0 && v2)
  {
    *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;

    uint64_t v2 = *(void **)(a1 + 48);
  }

  *(void *)(a1 + 4_Block_object_dispose(va, 8) = 0LL;
}

void ___ZL35nw_resolver_config_update_from_pathP29NWConcrete_nw_resolver_config_block_invoke(uint64_t a1)
{
  int v7 = (id *)*(id *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 48LL);
  id v2 = v7[1];
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(void **)(v3 + 8);
  if ((*(_BYTE *)(v3 + 16) & 1) != 0 && v4)
  {
    *(void *)(v3 + _Block_object_dispose(va, 8) = 0LL;

    id v4 = *(void **)(v3 + 8);
  }

  *(void *)(v3 + _Block_object_dispose(va, 8) = 0LL;

  id v5 = *(void **)(v3 + 8);
  *(void *)(v3 + _Block_object_dispose(va, 8) = v2;
  id v6 = v2;

  *(_BYTE *)(v3 + 16) |= 1u;
}

void ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke( uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  v3[0] = MEMORY[0x1895F87A8];
  v3[1] = 3221225472LL;
  v3[2] = ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke_2;
  v3[3] = &unk_189BC93A0;
  id v4 = v1;
  id v2 = (os_unfair_lock_s *)v4;
  os_unfair_lock_lock(v2 + 22);
  ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke_2((uint64_t)v3);
  os_unfair_lock_unlock(v2 + 22);
}

void sub_1822EDC7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke_3( uint64_t a1)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  memset(v32, 0, sizeof(v32));
  while (1)
  {
    ssize_t v2 = recv(*(_DWORD *)(a1 + 48), v32, 0x80uLL, 0);
    unint64_t v3 = v2;
    if (v2 < 1) {
      break;
    }
    id v4 = *(void **)(a1 + 40);
    id v5 = (NWConcrete_nw_resolver_config *)*(id *)(a1 + 32);
    id v6 = v4;
    if (v3 >= 0x18
      && DWORD1(v32[0]) == 1
      && DWORD2(v32[0]) == 1
      && HIDWORD(v32[0]) == 9
      && LODWORD(v32[0]) >= 0x28
      && v3 >= LODWORD(v32[0])
      && (DWORD1(v32[1]) & 0xFFFFFFFE) == 2
      && !uuid_compare(v5->identifier, (const unsigned __int8 *)&v32[1] + 8))
    {
      int v10 = DWORD1(v32[1]);
      if (DWORD1(v32[1]) == 2 || nw_resolver_config_update_from_path(v5)) {
        v6[2](v6, v10 == 2);
      }
    }
  }

  if (v2 < 0)
  {
    int v11 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v11 != 35)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v12 = (id)gLogObj;
      *(_DWORD *)__int128 buf = 136446466;
      dispatch_object_t v27 = "nw_resolver_config_watch_kernel_events_block_invoke_3";
      __int16 v28 = 1024;
      int v29 = v11;
      char v13 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v24 = 0;
      if (__nwlog_fault(v13, &type, &v24))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v14 = (os_log_s *)(id)gLogObj;
          os_log_type_t v15 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)__int128 buf = 136446466;
            dispatch_object_t v27 = "nw_resolver_config_watch_kernel_events_block_invoke";
            __int16 v28 = 1024;
            int v29 = v11;
            _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s receive from kernel event socket failed %{darwin.errno}d",  buf,  0x12u);
          }
        }

        else if (v24)
        {
          backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v14 = (os_log_s *)(id)gLogObj;
          os_log_type_t v19 = type;
          BOOL v20 = os_log_type_enabled(v14, type);
          if (backtrace_string)
          {
            if (v20)
            {
              *(_DWORD *)__int128 buf = 136446722;
              dispatch_object_t v27 = "nw_resolver_config_watch_kernel_events_block_invoke";
              __int16 v28 = 1024;
              int v29 = v11;
              __int16 v30 = 2082;
              os_log_type_t v31 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s receive from kernel event socket failed %{darwin.errno}d, dumping backtrace:%{public}s",  buf,  0x1Cu);
            }

            free(backtrace_string);
            if (!v13) {
              goto LABEL_31;
            }
            goto LABEL_30;
          }

          if (v20)
          {
            *(_DWORD *)__int128 buf = 136446466;
            dispatch_object_t v27 = "nw_resolver_config_watch_kernel_events_block_invoke";
            __int16 v28 = 1024;
            int v29 = v11;
            _os_log_impl( &dword_181A5C000,  v14,  v19,  "%{public}s receive from kernel event socket failed %{darwin.errno}d, no backtrace",  buf,  0x12u);
          }
        }

        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v14 = (os_log_s *)(id)gLogObj;
          os_log_type_t v21 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)__int128 buf = 136446466;
            dispatch_object_t v27 = "nw_resolver_config_watch_kernel_events_block_invoke";
            __int16 v28 = 1024;
            int v29 = v11;
            _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s receive from kernel event socket failed %{darwin.errno}d, backtrace limit exceeded",  buf,  0x12u);
          }
        }
      }

      if (!v13)
      {
LABEL_31:
        char v16 = *(void **)(a1 + 32);
        v22[0] = MEMORY[0x1895F87A8];
        v22[1] = 3221225472LL;
        v22[2] = ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke_119;
        v22[3] = &unk_189BC93A0;
        id v23 = v16;
        os_log_type_t v17 = (os_unfair_lock_s *)v23;
        os_unfair_lock_lock(v17 + 22);
        ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke_119((uint64_t)v22);
        os_unfair_lock_unlock(v17 + 22);

        return;
      }

void sub_1822EE120(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke_119( uint64_t a1)
{
  ssize_t v2 = *(dispatch_source_s **)(*(void *)(a1 + 32) + 40LL);
  if (v2)
  {
    dispatch_source_cancel(v2);
    uint64_t v3 = *(void *)(a1 + 32);
    id v4 = *(void **)(v3 + 40);
    if ((*(_BYTE *)(v3 + 48) & 1) != 0)
    {
      if (v4)
      {
        *(void *)(v3 + 40) = 0LL;

        id v4 = *(void **)(v3 + 40);
      }
    }

    *(void *)(v3 + 40) = 0LL;

    id v5 = *(void **)(v3 + 40);
    *(void *)(v3 + 40) = 0LL;

    *(_BYTE *)(v3 + 48) |= 1u;
  }

void ___ZL38nw_resolver_config_watch_kernel_eventsP29NWConcrete_nw_resolver_configPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvbE_block_invoke_2( uint64_t a1)
{
  ssize_t v2 = *(void **)(*(void *)(a1 + 32) + 56LL);
  if (v2)
  {
    nw_fd_wrapper_close(v2);
    uint64_t v3 = *(void *)(a1 + 32);
    id v4 = *(void **)(v3 + 56);
    if ((*(_BYTE *)(v3 + 64) & 1) != 0)
    {
      if (v4)
      {
        *(void *)(v3 + 56) = 0LL;

        id v4 = *(void **)(v3 + 56);
      }
    }

    *(void *)(v3 + 56) = 0LL;

    id v5 = *(void **)(v3 + 56);
    *(void *)(v3 + 56) = 0LL;

    *(_BYTE *)(v3 + 64) |= 1u;
  }

void nw_resolver_config_cancel_updates(void *a1, void *a2, void *a3)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  unsigned int v8 = v7;
  if (!v5)
  {
    __nwlog_obj();
    id v12 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_resolver_config_cancel_updates";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_cancel_updates";
        _os_log_impl(&dword_181A5C000, v14, v15, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v36)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_cancel_updates";
          *(_WORD *)&_BYTE buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v14,  v21,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_57:
        if (!v13) {
          goto LABEL_7;
        }
LABEL_58:
        free(v13);
        goto LABEL_7;
      }

      if (v22)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_cancel_updates";
        _os_log_impl(&dword_181A5C000, v14, v21, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v14 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_cancel_updates";
        _os_log_impl( &dword_181A5C000,  v14,  v28,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void __nw_resolver_config_cancel_updates_block_invoke(uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  ssize_t v2 = (dispatch_source_s *)v1[5];
  if (v2)
  {
    handler[0] = MEMORY[0x1895F87A8];
    handler[1] = 3221225472LL;
    handler[2] = __nw_resolver_config_cancel_updates_block_invoke_2;
    handler[3] = &unk_189BC50A8;
    unsigned int v8 = v1;
    id v9 = *(id *)(a1 + 40);
    id v10 = *(id *)(a1 + 48);
    dispatch_source_set_cancel_handler(v2, handler);
    dispatch_source_cancel(*(dispatch_source_t *)(*(void *)(a1 + 32) + 40LL));
    uint64_t v4 = *(void *)(a1 + 32);
    id v5 = *(void **)(v4 + 40);
    if ((*(_BYTE *)(v4 + 48) & 1) != 0)
    {
      if (v5)
      {
        *(void *)(v4 + 40) = 0LL;

        id v5 = *(void **)(v4 + 40);
      }
    }

    *(void *)(v4 + 40) = 0LL;

    id v6 = *(void **)(v4 + 40);
    *(void *)(v4 + 40) = 0LL;

    *(_BYTE *)(v4 + 48) |= 1u;
    *(_BYTE *)(*(void *)(*(void *)(a1 + 56) + 8LL) + 24LL) = 1;
  }

void __nw_resolver_config_cancel_updates_block_invoke_2(uint64_t a1)
{
  ssize_t v2 = *(void **)(a1 + 32);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  v4[2] = __nw_resolver_config_cancel_updates_block_invoke_3;
  v4[3] = &unk_189BC93A0;
  id v5 = v2;
  uint64_t v3 = (os_unfair_lock_s *)v5;
  os_unfair_lock_lock(v3 + 22);
  __nw_resolver_config_cancel_updates_block_invoke_3((uint64_t)v4);
  os_unfair_lock_unlock(v3 + 22);

  dispatch_async(*(dispatch_queue_t *)(a1 + 40), *(dispatch_block_t *)(a1 + 48));
}

void sub_1822EEB34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_resolver_config_cancel_updates_block_invoke_3(uint64_t a1)
{
  ssize_t v2 = *(void **)(*(void *)(a1 + 32) + 56LL);
  if (v2)
  {
    nw_fd_wrapper_close(v2);
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void **)(v3 + 56);
    if ((*(_BYTE *)(v3 + 64) & 1) != 0)
    {
      if (v4)
      {
        *(void *)(v3 + 56) = 0LL;

        uint64_t v4 = *(void **)(v3 + 56);
      }
    }

    *(void *)(v3 + 56) = 0LL;

    id v5 = *(void **)(v3 + 56);
    *(void *)(v3 + 56) = 0LL;

    *(_BYTE *)(v3 + 64) |= 1u;
  }

void nw_resolver_config_report_error(void *a1, int a2)
{
  uint64_t v23 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  uint64_t v4 = (unsigned __int8 *)v3;
  if (v3)
  {
    if (!uuid_is_null((const unsigned __int8 *)v3 + 24))
    {
      evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(0LL, 0LL);
      id v6 = (os_unfair_lock_s *)evaluator_for_endpoint;
      *(void *)__int128 buf = evaluator_for_endpoint;
      uint8_t buf[8] = -1;
      if (evaluator_for_endpoint)
      {
        id v7 = evaluator_for_endpoint;
        os_unfair_lock_lock(v6 + 24);
        id v8 = v7[6];
        os_unfair_lock_unlock(v6 + 24);
      }

      else
      {
        id v8 = 0LL;
      }

      *(void *)os_log_type_t type = v8;
      char v18 = -1;
      nw_path_report_error_to_agent(v8, v4 + 24, a2);
      if (v8) {

      }
      if (v6) {
    }
      }

    goto LABEL_10;
  }

  __nwlog_obj();
  id v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_config_report_error";
  id v10 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v10, type, &v19))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_report_error";
        _os_log_impl(&dword_181A5C000, v11, v12, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type[0];
      BOOL v15 = os_log_type_enabled(v11, type[0]);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)__int128 buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_config_report_error";
          __int16 v21 = 2082;
          BOOL v22 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v11,  v14,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }

      if (v15)
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_report_error";
        _os_log_impl(&dword_181A5C000, v11, v14, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      int v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)__int128 buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_config_report_error";
        _os_log_impl( &dword_181A5C000,  v11,  v16,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822EEEC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr((uint64_t)va);
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr((uint64_t)va1);

  _Unwind_Resume(a1);
}

uint64_t nw_resolver_config_publish(void *a1)
{
  uint64_t v35 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  ssize_t v2 = v1;
  if (v1)
  {
    id v3 = (void *)v1[9];
    if (v3)
    {
      v27[0] = MEMORY[0x1895F87A8];
      v27[1] = 3221225472LL;
      v27[2] = __nw_resolver_config_publish_block_invoke;
      v27[3] = &unk_189BC7898;
      os_log_type_t v28 = v1;
      id v4 = v3;
      uint64_t fd = nw_fd_wrapper_get_fd(v4, v27);
    }

    else
    {
      int v6 = nw_network_agent_open_control_socket();
      id v7 = nw_fd_wrapper_create(v6);
      uint64_t v8 = (void *)v2[9];
      if ((v2[10] & 1) != 0 && v8)
      {
        v2[9] = 0LL;

        uint64_t v8 = (void *)v2[9];
      }

      v2[9] = 0LL;

      id v9 = (void *)v2[9];
      v2[9] = v7;

      *((_BYTE *)v2 + 80) |= 1u;
      uint64_t v10 = nw_resolver_config_copy_plist_data_ref(v2);
      uint64_t provider_description = nw_resolver_config_get_provider_description(v2);
      if (!provider_description) {
        uint64_t provider_description = nw_resolver_config_get_provider_name(v2);
      }
      if (provider_description) {
        os_log_type_t v12 = (const char *)provider_description;
      }
      else {
        os_log_type_t v12 = "DNS";
      }
      BytePtr = CFDataGetBytePtr(v10);
      unsigned int Length = CFDataGetLength(v10);
      int v15 = nw_network_agent_ctl_setsockopt( v6,  1,  (unsigned __int8 *)v2 + 24,  "SystemConfig",  "DNSAgent",  (uint64_t)v12,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  BytePtr,  Length);
      uint64_t fd = v15 >= 0;
      if (v15 < 0)
      {
        os_log_type_t v16 = (void *)v2[9];
        if ((v2[10] & 1) != 0 && v16)
        {
          v2[9] = 0LL;

          os_log_type_t v16 = (void *)v2[9];
        }

        v2[9] = 0LL;

        os_log_type_t v17 = (void *)v2[9];
        v2[9] = 0LL;

        *((_BYTE *)v2 + 80) |= 1u;
      }

      if (v10) {
        CFRelease(v10);
      }
    }

    goto LABEL_19;
  }

  __nwlog_obj();
  char v19 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v32 = "nw_resolver_config_publish";
  BOOL v20 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v30 = OS_LOG_TYPE_ERROR;
  char v29 = 0;
  if (__nwlog_fault(v20, &v30, &v29))
  {
    if (v30 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v22 = v30;
      if (os_log_type_enabled(v21, v30))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v32 = "nw_resolver_config_publish";
        _os_log_impl(&dword_181A5C000, v21, v22, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v29)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v24 = v30;
      BOOL v25 = os_log_type_enabled(v21, v30);
      if (backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v32 = "nw_resolver_config_publish";
          __int16 v33 = 2082;
          id v34 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v21,  v24,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_36;
      }

      if (v25)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v32 = "nw_resolver_config_publish";
        _os_log_impl(&dword_181A5C000, v21, v24, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      __int16 v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v26 = v30;
      if (os_log_type_enabled(v21, v30))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v32 = "nw_resolver_config_publish";
        _os_log_impl( &dword_181A5C000,  v21,  v26,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_1822EF304(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL __nw_resolver_config_publish_block_invoke(uint64_t a1, int a2)
{
  id v4 = nw_resolver_config_copy_plist_data_ref(*(void **)(a1 + 32));
  uint64_t provider_description = nw_resolver_config_get_provider_description(*(void **)(a1 + 32));
  if (!provider_description) {
    uint64_t provider_description = nw_resolver_config_get_provider_name(*(void **)(a1 + 32));
  }
  uint64_t v6 = *(void *)(a1 + 32);
  if (provider_description) {
    id v7 = (const char *)provider_description;
  }
  else {
    id v7 = "DNS";
  }
  BytePtr = CFDataGetBytePtr(v4);
  unsigned int Length = CFDataGetLength(v4);
  int v10 = nw_network_agent_ctl_setsockopt( a2,  3,  (unsigned __int8 *)(v6 + 24),  "SystemConfig",  "DNSAgent",  (uint64_t)v7,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  BytePtr,  Length);
  if (v4) {
    CFRelease(v4);
  }
  return v10 >= 0;
}

void sub_1822EF424(_Unwind_Exception *exception_object)
{
  if (v1) {
    CFRelease(v1);
  }
  _Unwind_Resume(exception_object);
}

void nw_resolver_config_unpublish(void *a1)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  ssize_t v2 = v1;
  if (v1)
  {
    id v3 = (void *)v1[9];
    if ((v1[10] & 1) != 0 && v3)
    {
      v1[9] = 0LL;

      id v3 = (void *)v2[9];
    }

    v2[9] = 0LL;

    id v4 = (void *)v2[9];
    v2[9] = 0LL;

    *((_BYTE *)v2 + 80) |= 1u;
    goto LABEL_6;
  }

  __nwlog_obj();
  id v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v16 = "nw_resolver_config_unpublish";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_unpublish";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null config", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v16 = "nw_resolver_config_unpublish";
          __int16 v17 = 2082;
          char v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null config, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_unpublish";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v16 = "nw_resolver_config_unpublish";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null config, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

uint64_t nw_protocol_common_add_input_handler(uint64_t a1, uint64_t a2)
{
  uint64_t v32 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v27 = "nw_protocol_common_add_input_handler";
    os_log_type_t v8 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_71;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v27 = "nw_protocol_common_add_input_handler";
      BOOL v11 = "%{public}s called with null protocol";
      goto LABEL_70;
    }

    if (!v24)
    {
      id v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_71;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v27 = "nw_protocol_common_add_input_handler";
      BOOL v11 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_70;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    id v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v17 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (!v17) {
        goto LABEL_71;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v27 = "nw_protocol_common_add_input_handler";
      BOOL v11 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_70;
    }

    if (!v17) {
      goto LABEL_50;
    }
    *(_DWORD *)__int128 buf = 136446466;
    BOOL v27 = "nw_protocol_common_add_input_handler";
    __int16 v28 = 2082;
    char v29 = backtrace_string;
    char v18 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_49:
    _os_log_impl(&dword_181A5C000, v9, v10, v18, buf, 0x16u);
    goto LABEL_50;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v27 = "nw_protocol_common_add_input_handler";
    os_log_type_t v8 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_71;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v27 = "nw_protocol_common_add_input_handler";
      BOOL v11 = "%{public}s called with null input_protocol";
      goto LABEL_70;
    }

    if (!v24)
    {
      id v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_71;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v27 = "nw_protocol_common_add_input_handler";
      BOOL v11 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_70;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    id v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v19 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (!v19) {
        goto LABEL_71;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v27 = "nw_protocol_common_add_input_handler";
      BOOL v11 = "%{public}s called with null input_protocol, no backtrace";
      goto LABEL_70;
    }

    if (!v19) {
      goto LABEL_50;
    }
    *(_DWORD *)__int128 buf = 136446466;
    BOOL v27 = "nw_protocol_common_add_input_handler";
    __int16 v28 = 2082;
    char v29 = backtrace_string;
    char v18 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
    goto LABEL_49;
  }

  if (a1 == a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446466;
    BOOL v27 = "nw_protocol_common_add_input_handler";
    __int16 v28 = 2048;
    char v29 = (char *)a1;
    os_log_type_t v12 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v27 = "nw_protocol_common_add_input_handler";
      __int16 v28 = 2048;
      char v29 = (char *)a1;
      int v15 = "%{public}s Cannot add input handler %p to itself";
    }

    else if (v24)
    {
      BOOL v20 = (char *)__nw_create_backtrace_string();
      char v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v21 = os_log_type_enabled(v13, type);
      if (v20)
      {
        if (v21)
        {
          *(_DWORD *)__int128 buf = 136446722;
          BOOL v27 = "nw_protocol_common_add_input_handler";
          __int16 v28 = 2048;
          char v29 = (char *)a1;
          __int16 v30 = 2082;
          os_log_type_t v31 = v20;
          _os_log_impl( &dword_181A5C000,  v13,  v14,  "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s",  buf,  0x20u);
        }

        free(v20);
LABEL_66:
        if (v12)
        {
          uint64_t v23 = (char *)v12;
LABEL_73:
          free(v23);
        }

        return 0LL;
      }

      if (!v21) {
        goto LABEL_66;
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v27 = "nw_protocol_common_add_input_handler";
      __int16 v28 = 2048;
      char v29 = (char *)a1;
      int v15 = "%{public}s Cannot add input handler %p to itself, no backtrace";
    }

    else
    {
      char v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v27 = "nw_protocol_common_add_input_handler";
      __int16 v28 = 2048;
      char v29 = (char *)a1;
      int v15 = "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded";
    }

    _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0x16u);
    goto LABEL_66;
  }

  if (*(void *)(a1 + 48))
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v27 = "nw_protocol_common_add_input_handler";
    os_log_type_t v8 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_71;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v27 = "nw_protocol_common_add_input_handler";
      BOOL v11 = "%{public}s Default input handler already exists, common add input handler does not support multiplexing protocols";
      goto LABEL_70;
    }

    if (!v24)
    {
      id v9 = (os_log_s *)__nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_71;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v27 = "nw_protocol_common_add_input_handler";
      BOOL v11 = "%{public}s Default input handler already exists, common add input handler does not support multiplexing prot"
            "ocols, backtrace limit exceeded";
      goto LABEL_70;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    id v9 = (os_log_s *)__nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)__int128 buf = 136446466;
        BOOL v27 = "nw_protocol_common_add_input_handler";
        __int16 v28 = 2082;
        char v29 = backtrace_string;
        char v18 = "%{public}s Default input handler already exists, common add input handler does not support multiplexing pr"
              "otocols, dumping backtrace:%{public}s";
        goto LABEL_49;
      }

uint64_t nw_protocol_common_replace_input_handler(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v42 = "nw_protocol_common_replace_input_handler";
    char v29 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = type;
      if (!os_log_type_enabled(v30, type)) {
        goto LABEL_87;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v42 = "nw_protocol_common_replace_input_handler";
      uint64_t v32 = "%{public}s called with null protocol";
    }

    else if (v39)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __int16 v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = type;
      BOOL v34 = os_log_type_enabled(v30, type);
      if (backtrace_string)
      {
        if (v34)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v42 = "nw_protocol_common_replace_input_handler";
          __int16 v43 = 2082;
          int v44 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v30,  v31,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_87:
        if (!v29) {
          return 0LL;
        }
        goto LABEL_88;
      }

      if (!v34) {
        goto LABEL_87;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v42 = "nw_protocol_common_replace_input_handler";
      uint64_t v32 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      __int16 v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = type;
      if (!os_log_type_enabled(v30, type)) {
        goto LABEL_87;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v42 = "nw_protocol_common_replace_input_handler";
      uint64_t v32 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

    goto LABEL_86;
  }

  id v3 = a2;
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v42 = "nw_protocol_common_replace_input_handler";
    char v29 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v39)
      {
        __int16 v30 = (os_log_s *)__nwlog_obj();
        os_log_type_t v31 = type;
        if (!os_log_type_enabled(v30, type)) {
          goto LABEL_87;
        }
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v42 = "nw_protocol_common_replace_input_handler";
        uint64_t v32 = "%{public}s called with null old_input_protocol, backtrace limit exceeded";
        goto LABEL_86;
      }

      uint64_t v35 = (char *)__nw_create_backtrace_string();
      __int16 v30 = (os_log_s *)__nwlog_obj();
      os_log_type_t v31 = type;
      BOOL v36 = os_log_type_enabled(v30, type);
      if (!v35)
      {
        if (!v36) {
          goto LABEL_87;
        }
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v42 = "nw_protocol_common_replace_input_handler";
        uint64_t v32 = "%{public}s called with null old_input_protocol, no backtrace";
        goto LABEL_86;
      }

      if (v36)
      {
        *(_DWORD *)__int128 buf = 136446466;
        BOOL v42 = "nw_protocol_common_replace_input_handler";
        __int16 v43 = 2082;
        int v44 = v35;
        char v37 = "%{public}s called with null old_input_protocol, dumping backtrace:%{public}s";
LABEL_71:
        _os_log_impl(&dword_181A5C000, v30, v31, v37, buf, 0x16u);
      }

uint64_t nw_protocol_common_remove_input_handler(void *a1, void *a2, uint64_t a3)
{
  return nw_protocol_common_remove_input_handler_with_cleanup_blocks(a1, a2, a3, 0LL, 0LL);
}

uint64_t nw_protocol_common_remove_input_handler_with_cleanup_blocks( void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v78 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v71 = "nw_protocol_common_remove_input_handler_with_cleanup_blocks";
    uint64_t v49 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v68 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v50 = (os_log_s *)__nwlog_obj();
      os_log_type_t v51 = type;
      if (!os_log_type_enabled(v50, type)) {
        goto LABEL_126;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v71 = "nw_protocol_common_remove_input_handler_with_cleanup_blocks";
      int v52 = "%{public}s called with null protocol";
      goto LABEL_125;
    }

    if (!v68)
    {
      int v50 = (os_log_s *)__nwlog_obj();
      os_log_type_t v51 = type;
      if (!os_log_type_enabled(v50, type)) {
        goto LABEL_126;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v71 = "nw_protocol_common_remove_input_handler_with_cleanup_blocks";
      int v52 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_125;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    int v50 = (os_log_s *)__nwlog_obj();
    os_log_type_t v51 = type;
    BOOL v54 = os_log_type_enabled(v50, type);
    if (!backtrace_string)
    {
      if (!v54) {
        goto LABEL_126;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v71 = "nw_protocol_common_remove_input_handler_with_cleanup_blocks";
      int v52 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_125;
    }

    if (v54)
    {
      *(_DWORD *)__int128 buf = 136446466;
      unsigned int v71 = "nw_protocol_common_remove_input_handler_with_cleanup_blocks";
      __int16 v72 = 2082;
      int v73 = backtrace_string;
      _os_log_impl( &dword_181A5C000,  v50,  v51,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
    }

    free(backtrace_string);
LABEL_126:
    if (!v49) {
      return 0LL;
    }
    goto LABEL_127;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v71 = "nw_protocol_common_remove_input_handler_with_cleanup_blocks";
    uint64_t v49 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v68 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v50 = (os_log_s *)__nwlog_obj();
      os_log_type_t v51 = type;
      if (!os_log_type_enabled(v50, type)) {
        goto LABEL_126;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v71 = "nw_protocol_common_remove_input_handler_with_cleanup_blocks";
      int v52 = "%{public}s called with null input_protocol";
      goto LABEL_125;
    }

    if (!v68)
    {
      int v50 = (os_log_s *)__nwlog_obj();
      os_log_type_t v51 = type;
      if (!os_log_type_enabled(v50, type)) {
        goto LABEL_126;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v71 = "nw_protocol_common_remove_input_handler_with_cleanup_blocks";
      int v52 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_125;
    }

    id v55 = (char *)__nw_create_backtrace_string();
    int v50 = (os_log_s *)__nwlog_obj();
    os_log_type_t v51 = type;
    BOOL v56 = os_log_type_enabled(v50, type);
    if (v55)
    {
      if (v56)
      {
        *(_DWORD *)__int128 buf = 136446466;
        unsigned int v71 = "nw_protocol_common_remove_input_handler_with_cleanup_blocks";
        __int16 v72 = 2082;
        int v73 = v55;
        _os_log_impl( &dword_181A5C000,  v50,  v51,  "%{public}s called with null input_protocol, dumping backtrace:%{public}s",  buf,  0x16u);
      }

      free(v55);
      if (!v49) {
        return 0LL;
      }
LABEL_127:
      __int16 v43 = (char *)v49;
      goto LABEL_72;
    }

    if (v56)
    {
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v71 = "nw_protocol_common_remove_input_handler_with_cleanup_blocks";
      int v52 = "%{public}s called with null input_protocol, no backtrace";
LABEL_125:
      _os_log_impl(&dword_181A5C000, v50, v51, v52, buf, 0xCu);
      goto LABEL_126;
    }

    goto LABEL_126;
  }

  os_log_type_t v10 = (void *)a2[4];
  if (v10 == a1 && v10 != 0LL)
  {
    if ((_UNKNOWN *)a1[5] == &nw_protocol_ref_counted_handle)
    {
      uint64_t v33 = a1[11];
      if (v33)
      {
        uint64_t v34 = v33 - 1;
        a1[11] = v34;
        if (!v34)
        {
          uint64_t v35 = (void (**)(void))a1[8];
          if (v35)
          {
            a1[8] = 0LL;
            v35[2](v35);
            _Block_release(v35);
          }

          if ((a1[9] & 1) != 0)
          {
            BOOL v36 = (const void *)a1[8];
            if (v36) {
              _Block_release(v36);
            }
          }

          free(a1);
        }
      }
    }

    a2[4] = 0LL;
  }

  if ((void *)a1[6] != a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v12 = (void *)a1[6];
    *(_DWORD *)__int128 buf = 136446722;
    unsigned int v71 = "nw_protocol_common_remove_input_handler_with_cleanup_blocks";
    __int16 v72 = 2048;
    int v73 = v12;
    __int16 v74 = 2048;
    unsigned __int8 v75 = a2;
    char v13 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v68 = 0;
    if (__nwlog_fault(v13, &type, &v68))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = (os_log_s *)gLogObj;
        os_log_type_t v15 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          os_log_type_t v16 = (void *)a1[6];
          *(_DWORD *)__int128 buf = 136446722;
          unsigned int v71 = "nw_protocol_common_remove_input_handler_with_cleanup_blocks";
          __int16 v72 = 2048;
          int v73 = v16;
          __int16 v74 = 2048;
          unsigned __int8 v75 = a2;
          uint64_t v17 = "%{public}s Input protocol does not match (%p != %p)";
LABEL_69:
          _os_log_impl(&dword_181A5C000, v14, v15, v17, buf, 0x20u);
        }
      }

      else if (v68)
      {
        __int16 v30 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = (os_log_s *)gLogObj;
        os_log_type_t v15 = type;
        BOOL v31 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v30)
        {
          if (v31)
          {
            uint64_t v32 = (void *)a1[6];
            *(_DWORD *)__int128 buf = 136446978;
            unsigned int v71 = "nw_protocol_common_remove_input_handler_with_cleanup_blocks";
            __int16 v72 = 2048;
            int v73 = v32;
            __int16 v74 = 2048;
            unsigned __int8 v75 = a2;
            __int16 v76 = 2082;
            unsigned __int8 v77 = v30;
            _os_log_impl( &dword_181A5C000,  v14,  v15,  "%{public}s Input protocol does not match (%p != %p), dumping backtrace:%{public}s",  buf,  0x2Au);
          }

          free(v30);
          goto LABEL_70;
        }

        if (v31)
        {
          BOOL v42 = (void *)a1[6];
          *(_DWORD *)__int128 buf = 136446722;
          unsigned int v71 = "nw_protocol_common_remove_input_handler_with_cleanup_blocks";
          __int16 v72 = 2048;
          int v73 = v42;
          __int16 v74 = 2048;
          unsigned __int8 v75 = a2;
          uint64_t v17 = "%{public}s Input protocol does not match (%p != %p), no backtrace";
          goto LABEL_69;
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = (os_log_s *)gLogObj;
        os_log_type_t v15 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          os_log_type_t v41 = (void *)a1[6];
          *(_DWORD *)__int128 buf = 136446722;
          unsigned int v71 = "nw_protocol_common_remove_input_handler_with_cleanup_blocks";
          __int16 v72 = 2048;
          int v73 = v41;
          __int16 v74 = 2048;
          unsigned __int8 v75 = a2;
          uint64_t v17 = "%{public}s Input protocol does not match (%p != %p), backtrace limit exceeded";
          goto LABEL_69;
        }
      }
    }

uint64_t nw_protocol_common_get_input_frames( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v48 = "nw_protocol_common_get_input_frames";
    BOOL v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v48 = "nw_protocol_common_get_input_frames";
      uint64_t v22 = "%{public}s called with null protocol";
      goto LABEL_47;
    }

    if (!v45)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v48 = "nw_protocol_common_get_input_frames";
      uint64_t v22 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    uint64_t v20 = (os_log_s *)__nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v40 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (!v40) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v48 = "nw_protocol_common_get_input_frames";
      uint64_t v22 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_47;
    }

    if (!v40) {
      goto LABEL_34;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v48 = "nw_protocol_common_get_input_frames";
    __int16 v49 = 2082;
    int v50 = backtrace_string;
    uint64_t v25 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_33;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v48 = "nw_protocol_common_get_input_frames";
    BOOL v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v48 = "nw_protocol_common_get_input_frames";
      uint64_t v22 = "%{public}s called with null input_protocol";
      goto LABEL_47;
    }

    if (!v45)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v48 = "nw_protocol_common_get_input_frames";
      uint64_t v22 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    uint64_t v20 = (os_log_s *)__nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v41 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (!v41) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v48 = "nw_protocol_common_get_input_frames";
      uint64_t v22 = "%{public}s called with null input_protocol, no backtrace";
      goto LABEL_47;
    }

    if (!v41) {
      goto LABEL_34;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v48 = "nw_protocol_common_get_input_frames";
    __int16 v49 = 2082;
    int v50 = backtrace_string;
    uint64_t v25 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
    goto LABEL_33;
  }

  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v48 = "nw_protocol_common_get_input_frames";
    BOOL v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v48 = "nw_protocol_common_get_input_frames";
      uint64_t v22 = "%{public}s called with null return_array";
      goto LABEL_47;
    }

    if (!v45)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v48 = "nw_protocol_common_get_input_frames";
      uint64_t v22 = "%{public}s called with null return_array, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    uint64_t v20 = (os_log_s *)__nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v42 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (!v42) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v48 = "nw_protocol_common_get_input_frames";
      uint64_t v22 = "%{public}s called with null return_array, no backtrace";
      goto LABEL_47;
    }

    if (!v42) {
      goto LABEL_34;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v48 = "nw_protocol_common_get_input_frames";
    __int16 v49 = 2082;
    int v50 = backtrace_string;
    uint64_t v25 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
    goto LABEL_33;
  }

  uint64_t v7 = *(void *)(a1 + 32);
  if (v7)
  {
    os_log_type_t v8 = *(void **)(v7 + 40);
    if (v8 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v9 = *(void *)(v7 + 88);
      if (v9) {
        *(void *)(v7 + 8_Block_object_dispose(va, 8) = v9 + 1;
      }
    }

    os_log_type_t v10 = *(void **)(a1 + 40);
    if (v10 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v11 = *(void *)(a1 + 88);
      if (v11) {
        *(void *)(a1 + 8_Block_object_dispose(va, 8) = v11 + 1;
      }
    }

    uint64_t v12 = *(void *)(v7 + 24);
    if (v12)
    {
      char v13 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 80);
      if (v13)
      {
        uint64_t v14 = v13(v7, a1);
        if (v10 != &nw_protocol_ref_counted_handle)
        {
LABEL_15:
          if (v8 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v7 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v15 = *(void *)(v7 + 88);
            if (v15)
            {
              uint64_t v16 = v15 - 1;
              *(void *)(v7 + 8_Block_object_dispose(va, 8) = v16;
              if (!v16)
              {
                uint64_t v17 = *(void (***)(void))(v7 + 64);
                if (v17)
                {
                  *(void *)(v7 + 64) = 0LL;
                  v17[2](v17);
                  _Block_release(v17);
                }

                if ((*(_BYTE *)(v7 + 72) & 1) != 0)
                {
                  uint64_t v18 = *(const void **)(v7 + 64);
                  if (v18) {
                    _Block_release(v18);
                  }
                }

                free((void *)v7);
              }
            }
          }

          return v14;
        }

uint64_t nw_protocol_common_get_output_frames( uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v55 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v48 = "nw_protocol_common_get_output_frames";
    BOOL v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v48 = "nw_protocol_common_get_output_frames";
      uint64_t v22 = "%{public}s called with null protocol";
      goto LABEL_47;
    }

    if (!v45)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v48 = "nw_protocol_common_get_output_frames";
      uint64_t v22 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    uint64_t v20 = (os_log_s *)__nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v40 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (!v40) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v48 = "nw_protocol_common_get_output_frames";
      uint64_t v22 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_47;
    }

    if (!v40) {
      goto LABEL_34;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v48 = "nw_protocol_common_get_output_frames";
    __int16 v49 = 2082;
    int v50 = backtrace_string;
    uint64_t v25 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_33;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v48 = "nw_protocol_common_get_output_frames";
    BOOL v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v48 = "nw_protocol_common_get_output_frames";
      uint64_t v22 = "%{public}s called with null input_protocol";
      goto LABEL_47;
    }

    if (!v45)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v48 = "nw_protocol_common_get_output_frames";
      uint64_t v22 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    uint64_t v20 = (os_log_s *)__nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v41 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (!v41) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v48 = "nw_protocol_common_get_output_frames";
      uint64_t v22 = "%{public}s called with null input_protocol, no backtrace";
      goto LABEL_47;
    }

    if (!v41) {
      goto LABEL_34;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v48 = "nw_protocol_common_get_output_frames";
    __int16 v49 = 2082;
    int v50 = backtrace_string;
    uint64_t v25 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
    goto LABEL_33;
  }

  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v48 = "nw_protocol_common_get_output_frames";
    BOOL v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v48 = "nw_protocol_common_get_output_frames";
      uint64_t v22 = "%{public}s called with null return_array";
      goto LABEL_47;
    }

    if (!v45)
    {
      uint64_t v20 = (os_log_s *)__nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v48 = "nw_protocol_common_get_output_frames";
      uint64_t v22 = "%{public}s called with null return_array, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    uint64_t v20 = (os_log_s *)__nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v42 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (!v42) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v48 = "nw_protocol_common_get_output_frames";
      uint64_t v22 = "%{public}s called with null return_array, no backtrace";
      goto LABEL_47;
    }

    if (!v42) {
      goto LABEL_34;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v48 = "nw_protocol_common_get_output_frames";
    __int16 v49 = 2082;
    int v50 = backtrace_string;
    uint64_t v25 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
    goto LABEL_33;
  }

  uint64_t v7 = *(void *)(a1 + 32);
  if (v7)
  {
    os_log_type_t v8 = *(void **)(v7 + 40);
    if (v8 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v9 = *(void *)(v7 + 88);
      if (v9) {
        *(void *)(v7 + 8_Block_object_dispose(va, 8) = v9 + 1;
      }
    }

    os_log_type_t v10 = *(void **)(a1 + 40);
    if (v10 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v11 = *(void *)(a1 + 88);
      if (v11) {
        *(void *)(a1 + 8_Block_object_dispose(va, 8) = v11 + 1;
      }
    }

    uint64_t v12 = *(void *)(v7 + 24);
    if (v12)
    {
      char v13 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 88);
      if (v13)
      {
        uint64_t v14 = v13(v7, a1);
        if (v10 != &nw_protocol_ref_counted_handle)
        {
LABEL_15:
          if (v8 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v7 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v15 = *(void *)(v7 + 88);
            if (v15)
            {
              uint64_t v16 = v15 - 1;
              *(void *)(v7 + 8_Block_object_dispose(va, 8) = v16;
              if (!v16)
              {
                uint64_t v17 = *(void (***)(void))(v7 + 64);
                if (v17)
                {
                  *(void *)(v7 + 64) = 0LL;
                  v17[2](v17);
                  _Block_release(v17);
                }

                if ((*(_BYTE *)(v7 + 72) & 1) != 0)
                {
                  uint64_t v18 = *(const void **)(v7 + 64);
                  if (v18) {
                    _Block_release(v18);
                  }
                }

                free((void *)v7);
              }
            }
          }

          return v14;
        }

uint64_t nw_protocol_common_finalize_output_frames(uint64_t a1, uint64_t a2)
{
  uint64_t v43 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v36 = "nw_protocol_common_finalize_output_frames";
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v36 = "nw_protocol_common_finalize_output_frames";
      uint64_t v15 = "%{public}s called with null protocol";
      goto LABEL_33;
    }

    if (!v33)
    {
      char v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v36 = "nw_protocol_common_finalize_output_frames";
      uint64_t v15 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_33;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    char v13 = (os_log_s *)__nwlog_obj();
    os_log_type_t v14 = type;
    BOOL v29 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (!v29) {
        goto LABEL_34;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v36 = "nw_protocol_common_finalize_output_frames";
      uint64_t v15 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_33;
    }

    if (!v29) {
      goto LABEL_28;
    }
    *(_DWORD *)__int128 buf = 136446466;
    BOOL v36 = "nw_protocol_common_finalize_output_frames";
    __int16 v37 = 2082;
    BOOL v38 = backtrace_string;
    uint64_t v18 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_27;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v36 = "nw_protocol_common_finalize_output_frames";
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v36 = "nw_protocol_common_finalize_output_frames";
      uint64_t v15 = "%{public}s called with null frames";
      goto LABEL_33;
    }

    if (!v33)
    {
      char v13 = (os_log_s *)__nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v36 = "nw_protocol_common_finalize_output_frames";
      uint64_t v15 = "%{public}s called with null frames, backtrace limit exceeded";
      goto LABEL_33;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    char v13 = (os_log_s *)__nwlog_obj();
    os_log_type_t v14 = type;
    BOOL v30 = os_log_type_enabled(v13, type);
    if (!backtrace_string)
    {
      if (!v30) {
        goto LABEL_34;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v36 = "nw_protocol_common_finalize_output_frames";
      uint64_t v15 = "%{public}s called with null frames, no backtrace";
      goto LABEL_33;
    }

    if (!v30) {
      goto LABEL_28;
    }
    *(_DWORD *)__int128 buf = 136446466;
    BOOL v36 = "nw_protocol_common_finalize_output_frames";
    __int16 v37 = 2082;
    BOOL v38 = backtrace_string;
    uint64_t v18 = "%{public}s called with null frames, dumping backtrace:%{public}s";
    goto LABEL_27;
  }

  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v36 = "nw_protocol_common_finalize_output_frames";
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v13 = (os_log_s *)gLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v36 = "nw_protocol_common_finalize_output_frames";
        uint64_t v15 = "%{public}s finalize_output_frames requires an output handler";
LABEL_33:
        _os_log_impl(&dword_181A5C000, v13, v14, v15, buf, 0xCu);
        goto LABEL_34;
      }

      goto LABEL_34;
    }

    if (!v33)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v13 = (os_log_s *)gLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v36 = "nw_protocol_common_finalize_output_frames";
        uint64_t v15 = "%{public}s finalize_output_frames requires an output handler, backtrace limit exceeded";
        goto LABEL_33;
      }

uint64_t nw_protocol_common_get_parameters(uint64_t a1)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v34 = "nw_protocol_common_get_parameters";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v34 = "nw_protocol_common_get_parameters";
      os_log_type_t v14 = "%{public}s called with null protocol";
      goto LABEL_32;
    }

    if (!v31)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v34 = "nw_protocol_common_get_parameters";
      os_log_type_t v14 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_32;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    uint64_t v12 = (os_log_s *)__nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v28 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v28) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v34 = "nw_protocol_common_get_parameters";
      os_log_type_t v14 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_32;
    }

    if (!v28) {
      goto LABEL_27;
    }
    *(_DWORD *)__int128 buf = 136446466;
    os_log_type_t v34 = "nw_protocol_common_get_parameters";
    __int16 v35 = 2082;
    BOOL v36 = backtrace_string;
    BOOL v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_26;
  }

  uint64_t v1 = *(void *)(a1 + 48);
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v34 = "nw_protocol_common_get_parameters";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = (os_log_s *)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v34 = "nw_protocol_common_get_parameters";
        os_log_type_t v14 = "%{public}s get_parameters requires a default input handler";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
        goto LABEL_33;
      }

      goto LABEL_33;
    }

    if (!v31)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = (os_log_s *)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v34 = "nw_protocol_common_get_parameters";
        os_log_type_t v14 = "%{public}s get_parameters requires a default input handler, backtrace limit exceeded";
        goto LABEL_32;
      }

uint64_t nw_protocol_common_get_path(uint64_t a1)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v34 = "nw_protocol_common_get_path";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v34 = "nw_protocol_common_get_path";
      os_log_type_t v14 = "%{public}s called with null protocol";
      goto LABEL_32;
    }

    if (!v31)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v34 = "nw_protocol_common_get_path";
      os_log_type_t v14 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_32;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    uint64_t v12 = (os_log_s *)__nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v28 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v28) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v34 = "nw_protocol_common_get_path";
      os_log_type_t v14 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_32;
    }

    if (!v28) {
      goto LABEL_27;
    }
    *(_DWORD *)__int128 buf = 136446466;
    os_log_type_t v34 = "nw_protocol_common_get_path";
    __int16 v35 = 2082;
    BOOL v36 = backtrace_string;
    BOOL v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_26;
  }

  uint64_t v1 = *(void *)(a1 + 48);
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v34 = "nw_protocol_common_get_path";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = (os_log_s *)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v34 = "nw_protocol_common_get_path";
        os_log_type_t v14 = "%{public}s get_path requires a default input handler";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
        goto LABEL_33;
      }

      goto LABEL_33;
    }

    if (!v31)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = (os_log_s *)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v34 = "nw_protocol_common_get_path";
        os_log_type_t v14 = "%{public}s get_path requires a default input handler, backtrace limit exceeded";
        goto LABEL_32;
      }

uint64_t nw_protocol_common_get_remote_endpoint(uint64_t a1)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v34 = "nw_protocol_common_get_remote_endpoint";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v34 = "nw_protocol_common_get_remote_endpoint";
      os_log_type_t v14 = "%{public}s called with null protocol";
      goto LABEL_32;
    }

    if (!v31)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v34 = "nw_protocol_common_get_remote_endpoint";
      os_log_type_t v14 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_32;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    uint64_t v12 = (os_log_s *)__nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v28 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v28) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v34 = "nw_protocol_common_get_remote_endpoint";
      os_log_type_t v14 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_32;
    }

    if (!v28) {
      goto LABEL_27;
    }
    *(_DWORD *)__int128 buf = 136446466;
    os_log_type_t v34 = "nw_protocol_common_get_remote_endpoint";
    __int16 v35 = 2082;
    BOOL v36 = backtrace_string;
    BOOL v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_26;
  }

  uint64_t v1 = *(void *)(a1 + 48);
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v34 = "nw_protocol_common_get_remote_endpoint";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = (os_log_s *)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v34 = "nw_protocol_common_get_remote_endpoint";
        os_log_type_t v14 = "%{public}s get_remote_endpoint requires a default input handler";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
        goto LABEL_33;
      }

      goto LABEL_33;
    }

    if (!v31)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = (os_log_s *)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v34 = "nw_protocol_common_get_remote_endpoint";
        os_log_type_t v14 = "%{public}s get_remote_endpoint requires a default input handler, backtrace limit exceeded";
        goto LABEL_32;
      }

uint64_t nw_protocol_common_get_local_endpoint(uint64_t a1)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v34 = "nw_protocol_common_get_local_endpoint";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v34 = "nw_protocol_common_get_local_endpoint";
      os_log_type_t v14 = "%{public}s called with null protocol";
      goto LABEL_32;
    }

    if (!v31)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v34 = "nw_protocol_common_get_local_endpoint";
      os_log_type_t v14 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_32;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    uint64_t v12 = (os_log_s *)__nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v28 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v28) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v34 = "nw_protocol_common_get_local_endpoint";
      os_log_type_t v14 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_32;
    }

    if (!v28) {
      goto LABEL_27;
    }
    *(_DWORD *)__int128 buf = 136446466;
    os_log_type_t v34 = "nw_protocol_common_get_local_endpoint";
    __int16 v35 = 2082;
    BOOL v36 = backtrace_string;
    BOOL v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_26;
  }

  uint64_t v1 = *(void *)(a1 + 48);
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v34 = "nw_protocol_common_get_local_endpoint";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = (os_log_s *)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v34 = "nw_protocol_common_get_local_endpoint";
        os_log_type_t v14 = "%{public}s get_local_endpoint requires a default input handler";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
        goto LABEL_33;
      }

      goto LABEL_33;
    }

    if (!v31)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = (os_log_s *)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v34 = "nw_protocol_common_get_local_endpoint";
        os_log_type_t v14 = "%{public}s get_local_endpoint requires a default input handler, backtrace limit exceeded";
        goto LABEL_32;
      }

uint64_t nw_protocol_common_get_output_local_endpoint(uint64_t a1)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v34 = "nw_protocol_common_get_output_local_endpoint";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v34 = "nw_protocol_common_get_output_local_endpoint";
      os_log_type_t v14 = "%{public}s called with null protocol";
      goto LABEL_32;
    }

    if (!v31)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v34 = "nw_protocol_common_get_output_local_endpoint";
      os_log_type_t v14 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_32;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    uint64_t v12 = (os_log_s *)__nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v28 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v28) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v34 = "nw_protocol_common_get_output_local_endpoint";
      os_log_type_t v14 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_32;
    }

    if (!v28) {
      goto LABEL_27;
    }
    *(_DWORD *)__int128 buf = 136446466;
    os_log_type_t v34 = "nw_protocol_common_get_output_local_endpoint";
    __int16 v35 = 2082;
    BOOL v36 = backtrace_string;
    BOOL v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_26;
  }

  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v34 = "nw_protocol_common_get_output_local_endpoint";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = (os_log_s *)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v34 = "nw_protocol_common_get_output_local_endpoint";
        os_log_type_t v14 = "%{public}s get_output_local_endpoint requires an output handler";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
        goto LABEL_33;
      }

      goto LABEL_33;
    }

    if (!v31)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = (os_log_s *)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v34 = "nw_protocol_common_get_output_local_endpoint";
        os_log_type_t v14 = "%{public}s get_output_local_endpoint requires an output handler, backtrace limit exceeded";
        goto LABEL_32;
      }

uint64_t nw_protocol_common_get_output_interface(uint64_t a1)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v34 = "nw_protocol_common_get_output_interface";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v34 = "nw_protocol_common_get_output_interface";
      os_log_type_t v14 = "%{public}s called with null protocol";
      goto LABEL_32;
    }

    if (!v31)
    {
      uint64_t v12 = (os_log_s *)__nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v34 = "nw_protocol_common_get_output_interface";
      os_log_type_t v14 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_32;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    uint64_t v12 = (os_log_s *)__nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v28 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (!v28) {
        goto LABEL_33;
      }
      *(_DWORD *)__int128 buf = 136446210;
      os_log_type_t v34 = "nw_protocol_common_get_output_interface";
      os_log_type_t v14 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_32;
    }

    if (!v28) {
      goto LABEL_27;
    }
    *(_DWORD *)__int128 buf = 136446466;
    os_log_type_t v34 = "nw_protocol_common_get_output_interface";
    __int16 v35 = 2082;
    BOOL v36 = backtrace_string;
    BOOL v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_26;
  }

  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v34 = "nw_protocol_common_get_output_interface";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = (os_log_s *)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v34 = "nw_protocol_common_get_output_interface";
        os_log_type_t v14 = "%{public}s get_output_interface requires an output handler";
LABEL_32:
        _os_log_impl(&dword_181A5C000, v12, v13, v14, buf, 0xCu);
        goto LABEL_33;
      }

      goto LABEL_33;
    }

    if (!v31)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = (os_log_s *)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v34 = "nw_protocol_common_get_output_interface";
        os_log_type_t v14 = "%{public}s get_output_interface requires an output handler, backtrace limit exceeded";
        goto LABEL_32;
      }

uint64_t nw_protocol_common_connect(uint64_t a1, uint64_t a2)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v43 = "nw_protocol_common_connect";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v43 = "nw_protocol_common_connect";
      uint64_t v18 = "%{public}s called with null protocol";
      goto LABEL_46;
    }

    if (!v40)
    {
      BOOL v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v43 = "nw_protocol_common_connect";
      uint64_t v18 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_46;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    BOOL v16 = (os_log_s *)__nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v36 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (!v36) {
        goto LABEL_47;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v43 = "nw_protocol_common_connect";
      uint64_t v18 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_46;
    }

    if (!v36) {
      goto LABEL_33;
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v43 = "nw_protocol_common_connect";
    __int16 v44 = 2082;
    char v45 = backtrace_string;
    os_log_type_t v21 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_32;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v43 = "nw_protocol_common_connect";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v43 = "nw_protocol_common_connect";
      uint64_t v18 = "%{public}s called with null other_protocol";
      goto LABEL_46;
    }

    if (!v40)
    {
      BOOL v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v43 = "nw_protocol_common_connect";
      uint64_t v18 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_46;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    BOOL v16 = (os_log_s *)__nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v37 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (!v37) {
        goto LABEL_47;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v43 = "nw_protocol_common_connect";
      uint64_t v18 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_46;
    }

    if (!v37) {
      goto LABEL_33;
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v43 = "nw_protocol_common_connect";
    __int16 v44 = 2082;
    char v45 = backtrace_string;
    os_log_type_t v21 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
    goto LABEL_32;
  }

  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    uint64_t v4 = *(void **)(v3 + 40);
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = *(void *)(v3 + 88);
      if (v5) {
        *(void *)(v3 + 8_Block_object_dispose(va, 8) = v5 + 1;
      }
    }

    uint64_t v6 = *(void **)(a1 + 40);
    if (v6 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v7 = *(void *)(a1 + 88);
      if (v7) {
        *(void *)(a1 + 8_Block_object_dispose(va, 8) = v7 + 1;
      }
    }

    uint64_t v8 = *(void *)(v3 + 24);
    if (v8)
    {
      uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 24);
      if (v9)
      {
        uint64_t v10 = v9(v3, a1);
        if (v6 != &nw_protocol_ref_counted_handle)
        {
LABEL_14:
          if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v11 = *(void *)(v3 + 88);
            if (v11)
            {
              uint64_t v12 = v11 - 1;
              *(void *)(v3 + 8_Block_object_dispose(va, 8) = v12;
              if (!v12)
              {
                os_log_type_t v13 = *(void (***)(void))(v3 + 64);
                if (v13)
                {
                  *(void *)(v3 + 64) = 0LL;
                  v13[2](v13);
                  _Block_release(v13);
                }

                if ((*(_BYTE *)(v3 + 72) & 1) != 0)
                {
                  os_log_type_t v14 = *(const void **)(v3 + 64);
                  if (v14) {
                    _Block_release(v14);
                  }
                }

                free((void *)v3);
              }
            }
          }

          return v10;
        }

uint64_t nw_protocol_common_reset(uint64_t a1, uint64_t a2)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v43 = "nw_protocol_common_reset";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v43 = "nw_protocol_common_reset";
      uint64_t v18 = "%{public}s called with null protocol";
      goto LABEL_46;
    }

    if (!v40)
    {
      BOOL v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v43 = "nw_protocol_common_reset";
      uint64_t v18 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_46;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    BOOL v16 = (os_log_s *)__nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v36 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (!v36) {
        goto LABEL_47;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v43 = "nw_protocol_common_reset";
      uint64_t v18 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_46;
    }

    if (!v36) {
      goto LABEL_33;
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v43 = "nw_protocol_common_reset";
    __int16 v44 = 2082;
    char v45 = backtrace_string;
    os_log_type_t v21 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_32;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v43 = "nw_protocol_common_reset";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v43 = "nw_protocol_common_reset";
      uint64_t v18 = "%{public}s called with null other_protocol";
      goto LABEL_46;
    }

    if (!v40)
    {
      BOOL v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v43 = "nw_protocol_common_reset";
      uint64_t v18 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_46;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    BOOL v16 = (os_log_s *)__nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v37 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (!v37) {
        goto LABEL_47;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v43 = "nw_protocol_common_reset";
      uint64_t v18 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_46;
    }

    if (!v37) {
      goto LABEL_33;
    }
    *(_DWORD *)__int128 buf = 136446466;
    uint64_t v43 = "nw_protocol_common_reset";
    __int16 v44 = 2082;
    char v45 = backtrace_string;
    os_log_type_t v21 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
    goto LABEL_32;
  }

  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    uint64_t v4 = *(void **)(v3 + 40);
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = *(void *)(v3 + 88);
      if (v5) {
        *(void *)(v3 + 8_Block_object_dispose(va, 8) = v5 + 1;
      }
    }

    uint64_t v6 = *(void **)(a1 + 40);
    if (v6 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v7 = *(void *)(a1 + 88);
      if (v7) {
        *(void *)(a1 + 8_Block_object_dispose(va, 8) = v7 + 1;
      }
    }

    uint64_t v8 = *(void *)(v3 + 24);
    if (v8)
    {
      uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 256);
      if (v9)
      {
        uint64_t v10 = v9(v3, a1);
        if (v6 != &nw_protocol_ref_counted_handle)
        {
LABEL_14:
          if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v11 = *(void *)(v3 + 88);
            if (v11)
            {
              uint64_t v12 = v11 - 1;
              *(void *)(v3 + 8_Block_object_dispose(va, 8) = v12;
              if (!v12)
              {
                os_log_type_t v13 = *(void (***)(void))(v3 + 64);
                if (v13)
                {
                  *(void *)(v3 + 64) = 0LL;
                  v13[2](v13);
                  _Block_release(v13);
                }

                if ((*(_BYTE *)(v3 + 72) & 1) != 0)
                {
                  os_log_type_t v14 = *(const void **)(v3 + 64);
                  if (v14) {
                    _Block_release(v14);
                  }
                }

                free((void *)v3);
              }
            }
          }

          return v10;
        }

void nw_protocol_common_connected(uint64_t a1, uint64_t a2)
{
  uint64_t v78 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v71 = "nw_protocol_common_connected";
    uint64_t v23 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v68 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v68)
      {
        backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
        BOOL v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type;
        BOOL v52 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v52)
          {
            *(_DWORD *)__int128 buf = 136446466;
            unsigned int v71 = "nw_protocol_common_connected";
            __int16 v72 = 2082;
            int v73 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v24,  v25,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
        }

        else if (v52)
        {
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v71 = "nw_protocol_common_connected";
          BOOL v26 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_71;
        }
      }

      else
      {
        BOOL v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v71 = "nw_protocol_common_connected";
          BOOL v26 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_71;
        }
      }

      goto LABEL_72;
    }

    BOOL v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = type;
    if (!os_log_type_enabled(v24, type)) {
      goto LABEL_72;
    }
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v71 = "nw_protocol_common_connected";
    BOOL v26 = "%{public}s called with null protocol";
    goto LABEL_71;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v71 = "nw_protocol_common_connected";
    uint64_t v23 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v68 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v68)
      {
        BOOL v24 = (os_log_s *)__nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v71 = "nw_protocol_common_connected";
          BOOL v26 = "%{public}s called with null other_protocol, backtrace limit exceeded";
          goto LABEL_71;
        }

        goto LABEL_72;
      }

      BOOL v27 = (char *)__nw_create_backtrace_string();
      BOOL v24 = (os_log_s *)__nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v53 = os_log_type_enabled(v24, type);
      if (!v27)
      {
        if (v53)
        {
          *(_DWORD *)__int128 buf = 136446210;
          unsigned int v71 = "nw_protocol_common_connected";
          BOOL v26 = "%{public}s called with null other_protocol, no backtrace";
          goto LABEL_71;
        }

        goto LABEL_72;
      }

      if (!v53) {
        goto LABEL_49;
      }
      *(_DWORD *)__int128 buf = 136446466;
      unsigned int v71 = "nw_protocol_common_connected";
      __int16 v72 = 2082;
      int v73 = v27;
      BOOL v29 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_48:
      _os_log_impl(&dword_181A5C000, v24, v25, v29, buf, 0x16u);
      goto LABEL_49;
    }

    BOOL v24 = (os_log_s *)__nwlog_obj();
    os_log_type_t v25 = type;
    if (!os_log_type_enabled(v24, type)) {
      goto LABEL_72;
    }
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v71 = "nw_protocol_common_connected";
    BOOL v26 = "%{public}s called with null other_protocol";
LABEL_71:
    _os_log_impl(&dword_181A5C000, v24, v25, v26, buf, 0xCu);
    goto LABEL_72;
  }

  uint64_t v4 = *(void *)(a1 + 48);
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v71 = "nw_protocol_common_connected";
    uint64_t v23 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v68 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v24 = (os_log_s *)gLogObj;
      os_log_type_t v25 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v71 = "nw_protocol_common_connected";
      BOOL v26 = "%{public}s connected requires a default input handler";
      goto LABEL_71;
    }

    if (!v68)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v24 = (os_log_s *)gLogObj;
      os_log_type_t v25 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v71 = "nw_protocol_common_connected";
      BOOL v26 = "%{public}s connected requires a default input handler, backtrace limit exceeded";
      goto LABEL_71;
    }

    BOOL v27 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v24 = (os_log_s *)gLogObj;
    os_log_type_t v25 = type;
    BOOL v28 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v27)
    {
      if (!v28) {
        goto LABEL_72;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v71 = "nw_protocol_common_connected";
      BOOL v26 = "%{public}s connected requires a default input handler, no backtrace";
      goto LABEL_71;
    }

    if (!v28) {
      goto LABEL_49;
    }
    *(_DWORD *)__int128 buf = 136446466;
    unsigned int v71 = "nw_protocol_common_connected";
    __int16 v72 = 2082;
    int v73 = v27;
    BOOL v29 = "%{public}s connected requires a default input handler, dumping backtrace:%{public}s";
    goto LABEL_48;
  }

  uint64_t v5 = *(void **)(v4 + 40);
  if (v5 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v6 = *(void *)(v4 + 88);
    if (v6) {
      *(void *)(v4 + 8_Block_object_dispose(va, 8) = v6 + 1;
    }
  }

  uint64_t v7 = *(void **)(a2 + 40);
  if (v7 == &nw_protocol_ref_counted_handle)
  {
    uint64_t v8 = *(void *)(a2 + 88);
    if (v8) {
      *(void *)(a2 + 8_Block_object_dispose(va, 8) = v8 + 1;
    }
  }

  uint64_t v9 = *(void *)(v4 + 24);
  if (v9)
  {
    uint64_t v10 = *(void (**)(uint64_t, uint64_t))(v9 + 40);
    if (v10)
    {
      v10(v4, a2);
      goto LABEL_13;
    }
  }

  __nwlog_obj();
  BOOL v42 = *(const char **)(v4 + 16);
  *(_DWORD *)__int128 buf = 136446722;
  unsigned int v71 = "__nw_protocol_connected";
  if (!v42) {
    BOOL v42 = "invalid";
  }
  __int16 v72 = 2082;
  int v73 = (void *)v42;
  __int16 v74 = 2048;
  uint64_t v75 = v4;
  uint64_t v43 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v68 = 0;
  if (__nwlog_fault(v43, &type, &v68))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v44 = (os_log_s *)__nwlog_obj();
      os_log_type_t v45 = type;
      if (!os_log_type_enabled(v44, type)) {
        goto LABEL_148;
      }
      __int16 v46 = *(const char **)(v4 + 16);
      if (!v46) {
        __int16 v46 = "invalid";
      }
      *(_DWORD *)__int128 buf = 136446722;
      unsigned int v71 = "__nw_protocol_connected";
      __int16 v72 = 2082;
      int v73 = (void *)v46;
      __int16 v74 = 2048;
      uint64_t v75 = v4;
      uint64_t v47 = "%{public}s protocol %{public}s (%p) has invalid connected callback";
      goto LABEL_147;
    }

    if (!v68)
    {
      __int16 v44 = (os_log_s *)__nwlog_obj();
      os_log_type_t v45 = type;
      if (!os_log_type_enabled(v44, type)) {
        goto LABEL_148;
      }
      os_log_type_t v60 = *(const char **)(v4 + 16);
      if (!v60) {
        os_log_type_t v60 = "invalid";
      }
      *(_DWORD *)__int128 buf = 136446722;
      unsigned int v71 = "__nw_protocol_connected";
      __int16 v72 = 2082;
      int v73 = (void *)v60;
      __int16 v74 = 2048;
      uint64_t v75 = v4;
      uint64_t v47 = "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded";
      goto LABEL_147;
    }

    __int16 v48 = (char *)__nw_create_backtrace_string();
    __int16 v44 = (os_log_s *)__nwlog_obj();
    os_log_type_t v45 = type;
    BOOL v49 = os_log_type_enabled(v44, type);
    if (v48)
    {
      if (v49)
      {
        uint64_t v50 = *(const char **)(v4 + 16);
        if (!v50) {
          uint64_t v50 = "invalid";
        }
        *(_DWORD *)__int128 buf = 136446978;
        unsigned int v71 = "__nw_protocol_connected";
        __int16 v72 = 2082;
        int v73 = (void *)v50;
        __int16 v74 = 2048;
        uint64_t v75 = v4;
        __int16 v76 = 2082;
        unsigned __int8 v77 = v48;
        _os_log_impl( &dword_181A5C000,  v44,  v45,  "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s",  buf,  0x2Au);
      }

      free(v48);
      goto LABEL_148;
    }

    if (v49)
    {
      BOOL v64 = *(const char **)(v4 + 16);
      if (!v64) {
        BOOL v64 = "invalid";
      }
      *(_DWORD *)__int128 buf = 136446722;
      unsigned int v71 = "__nw_protocol_connected";
      __int16 v72 = 2082;
      int v73 = (void *)v64;
      __int16 v74 = 2048;
      uint64_t v75 = v4;
      uint64_t v47 = "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace";
LABEL_147:
      _os_log_impl(&dword_181A5C000, v44, v45, v47, buf, 0x20u);
    }
  }

void nw_protocol_common_disconnect(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    char v40 = "nw_protocol_common_disconnect";
    uint64_t v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v40 = "nw_protocol_common_disconnect";
          uint64_t v16 = "%{public}s called with null protocol";
LABEL_47:
          _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
        }
      }

      else if (v37)
      {
        backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v33 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)__int128 buf = 136446466;
            char v40 = "nw_protocol_common_disconnect";
            __int16 v41 = 2082;
            BOOL v42 = backtrace_string;
            uint64_t v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }

void nw_protocol_common_disconnected(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    char v40 = "nw_protocol_common_disconnected";
    uint64_t v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v40 = "nw_protocol_common_disconnected";
          uint64_t v16 = "%{public}s called with null protocol";
LABEL_47:
          _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
        }
      }

      else if (v37)
      {
        backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v33 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)__int128 buf = 136446466;
            char v40 = "nw_protocol_common_disconnected";
            __int16 v41 = 2082;
            BOOL v42 = backtrace_string;
            uint64_t v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }

void nw_protocol_common_input_available(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    char v40 = "nw_protocol_common_input_available";
    uint64_t v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v40 = "nw_protocol_common_input_available";
          uint64_t v16 = "%{public}s called with null protocol";
LABEL_47:
          _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
        }
      }

      else if (v37)
      {
        backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v33 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)__int128 buf = 136446466;
            char v40 = "nw_protocol_common_input_available";
            __int16 v41 = 2082;
            BOOL v42 = backtrace_string;
            uint64_t v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }

void nw_protocol_common_output_available(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    char v40 = "nw_protocol_common_output_available";
    uint64_t v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v40 = "nw_protocol_common_output_available";
          uint64_t v16 = "%{public}s called with null protocol";
LABEL_47:
          _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
        }
      }

      else if (v37)
      {
        backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v33 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)__int128 buf = 136446466;
            char v40 = "nw_protocol_common_output_available";
            __int16 v41 = 2082;
            BOOL v42 = backtrace_string;
            uint64_t v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }

void nw_protocol_common_input_finished(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    char v40 = "nw_protocol_common_input_finished";
    uint64_t v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v40 = "nw_protocol_common_input_finished";
          uint64_t v16 = "%{public}s called with null protocol";
LABEL_47:
          _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
        }
      }

      else if (v37)
      {
        backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v33 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)__int128 buf = 136446466;
            char v40 = "nw_protocol_common_input_finished";
            __int16 v41 = 2082;
            BOOL v42 = backtrace_string;
            uint64_t v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }

void nw_protocol_common_output_finished(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    char v40 = "nw_protocol_common_output_finished";
    uint64_t v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v40 = "nw_protocol_common_output_finished";
          uint64_t v16 = "%{public}s called with null protocol";
LABEL_47:
          _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
        }
      }

      else if (v37)
      {
        backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v33 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)__int128 buf = 136446466;
            char v40 = "nw_protocol_common_output_finished";
            __int16 v41 = 2082;
            BOOL v42 = backtrace_string;
            uint64_t v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }

void nw_protocol_common_input_flush(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    char v40 = "nw_protocol_common_input_flush";
    uint64_t v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v40 = "nw_protocol_common_input_flush";
          uint64_t v16 = "%{public}s called with null protocol";
LABEL_47:
          _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
        }
      }

      else if (v37)
      {
        backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v33 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)__int128 buf = 136446466;
            char v40 = "nw_protocol_common_input_flush";
            __int16 v41 = 2082;
            BOOL v42 = backtrace_string;
            uint64_t v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }

void nw_protocol_common_error(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    char v40 = "nw_protocol_common_error";
    uint64_t v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (__nwlog_fault((const char *)v3, &type, &v37))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          char v40 = "nw_protocol_common_error";
          uint64_t v16 = "%{public}s called with null protocol";
LABEL_47:
          _os_log_impl(&dword_181A5C000, v14, v15, v16, buf, 0xCu);
        }
      }

      else if (v37)
      {
        backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
        os_log_type_t v14 = (os_log_s *)__nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v33 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)__int128 buf = 136446466;
            char v40 = "nw_protocol_common_error";
            __int16 v41 = 2082;
            BOOL v42 = backtrace_string;
            uint64_t v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_32;
          }

void nw_protocol_common_get_message_properties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v42 = "nw_protocol_common_get_message_properties";
    uint64_t v4 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_104;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v42 = "nw_protocol_common_get_message_properties";
      os_log_type_t v27 = "%{public}s called with null protocol";
      goto LABEL_103;
    }

    if (!v39)
    {
      os_log_type_t v25 = (os_log_s *)__nwlog_obj();
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_104;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v42 = "nw_protocol_common_get_message_properties";
      os_log_type_t v27 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_103;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    os_log_type_t v25 = (os_log_s *)__nwlog_obj();
    os_log_type_t v26 = type;
    BOOL v32 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (!v32) {
        goto LABEL_104;
      }
      *(_DWORD *)__int128 buf = 136446210;
      BOOL v42 = "nw_protocol_common_get_message_properties";
      os_log_type_t v27 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_103;
    }

    if (v32)
    {
      *(_DWORD *)__int128 buf = 136446466;
      BOOL v42 = "nw_protocol_common_get_message_properties";
      __int16 v43 = 2082;
      uint64_t v44 = backtrace_string;
      BOOL v33 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_75:
      _os_log_impl(&dword_181A5C000, v25, v26, v33, buf, 0x16u);
    }

uint64_t nw_protocol_common_copy_info(uint64_t a1, int a2)
{
  uint64_t v42 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v35 = "nw_protocol_common_copy_info";
    BOOL v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v32)
      {
        uint64_t v19 = (os_log_s *)__nwlog_obj();
        os_log_type_t v20 = type;
        if (!os_log_type_enabled(v19, type)) {
          goto LABEL_74;
        }
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v35 = "nw_protocol_common_copy_info";
        uint64_t v21 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_73;
      }

      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      uint64_t v19 = (os_log_s *)__nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v26 = os_log_type_enabled(v19, type);
      if (!backtrace_string)
      {
        if (!v26) {
          goto LABEL_74;
        }
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v35 = "nw_protocol_common_copy_info";
        uint64_t v21 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_73;
      }

      if (v26)
      {
        *(_DWORD *)__int128 buf = 136446466;
        BOOL v35 = "nw_protocol_common_copy_info";
        __int16 v36 = 2082;
        char v37 = backtrace_string;
        os_log_type_t v27 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_50:
        _os_log_impl(&dword_181A5C000, v19, v20, v27, buf, 0x16u);
      }

uint64_t nw_protocol_common_supports_external_data(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    uint64_t v13 = "nw_protocol_common_supports_external_data";
    uint64_t v1 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v2 = (os_log_s *)__nwlog_obj();
      os_log_type_t v3 = type;
      if (!os_log_type_enabled(v2, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v13 = "nw_protocol_common_supports_external_data";
      uint64_t v4 = "%{public}s called with null protocol";
    }

    else if (v10)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      uint64_t v2 = (os_log_s *)__nwlog_obj();
      os_log_type_t v3 = type;
      BOOL v9 = os_log_type_enabled(v2, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v13 = "nw_protocol_common_supports_external_data";
          __int16 v14 = 2082;
          os_log_type_t v15 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v2,  v3,  "%{public}s called with null protocol, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        if (v1) {
          goto LABEL_18;
        }
        return 0LL;
      }

      if (!v9) {
        goto LABEL_17;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v13 = "nw_protocol_common_supports_external_data";
      uint64_t v4 = "%{public}s called with null protocol, no backtrace";
    }

    else
    {
      uint64_t v2 = (os_log_s *)__nwlog_obj();
      os_log_type_t v3 = type;
      if (!os_log_type_enabled(v2, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)__int128 buf = 136446210;
      uint64_t v13 = "nw_protocol_common_supports_external_data";
      uint64_t v4 = "%{public}s called with null protocol, backtrace limit exceeded";
    }

uint64_t nw_protocol_common_waiting_for_output(uint64_t a1, uint64_t a2)
{
  uint64_t v50 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v43 = "nw_protocol_common_waiting_for_output";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v43 = "nw_protocol_common_waiting_for_output";
      BOOL v18 = "%{public}s called with null protocol";
      goto LABEL_46;
    }

    if (!v40)
    {
      uint64_t v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v43 = "nw_protocol_common_waiting_for_output";
      BOOL v18 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_46;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    uint64_t v16 = (os_log_s *)__nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v36 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (!v36) {
        goto LABEL_47;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v43 = "nw_protocol_common_waiting_for_output";
      BOOL v18 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_46;
    }

    if (!v36) {
      goto LABEL_33;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v43 = "nw_protocol_common_waiting_for_output";
    __int16 v44 = 2082;
    __int16 v45 = backtrace_string;
    uint64_t v21 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_32;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v43 = "nw_protocol_common_waiting_for_output";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v43 = "nw_protocol_common_waiting_for_output";
      BOOL v18 = "%{public}s called with null other_protocol";
      goto LABEL_46;
    }

    if (!v40)
    {
      uint64_t v16 = (os_log_s *)__nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v43 = "nw_protocol_common_waiting_for_output";
      BOOL v18 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_46;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    uint64_t v16 = (os_log_s *)__nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v37 = os_log_type_enabled(v16, type);
    if (!backtrace_string)
    {
      if (!v37) {
        goto LABEL_47;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v43 = "nw_protocol_common_waiting_for_output";
      BOOL v18 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_46;
    }

    if (!v37) {
      goto LABEL_33;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v43 = "nw_protocol_common_waiting_for_output";
    __int16 v44 = 2082;
    __int16 v45 = backtrace_string;
    uint64_t v21 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
    goto LABEL_32;
  }

  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    uint64_t v4 = *(void **)(v3 + 40);
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = *(void *)(v3 + 88);
      if (v5) {
        *(void *)(v3 + 8_Block_object_dispose(va, 8) = v5 + 1;
      }
    }

    BOOL v6 = *(void **)(a1 + 40);
    if (v6 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v7 = *(void *)(a1 + 88);
      if (v7) {
        *(void *)(a1 + 8_Block_object_dispose(va, 8) = v7 + 1;
      }
    }

    uint64_t v8 = *(void *)(v3 + 24);
    if (v8)
    {
      BOOL v9 = *(uint64_t (**)(uint64_t, uint64_t))(v8 + 216);
      if (v9)
      {
        uint64_t v10 = v9(v3, a1);
        if (v6 != &nw_protocol_ref_counted_handle)
        {
LABEL_14:
          if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v11 = *(void *)(v3 + 88);
            if (v11)
            {
              uint64_t v12 = v11 - 1;
              *(void *)(v3 + 8_Block_object_dispose(va, 8) = v12;
              if (!v12)
              {
                uint64_t v13 = *(void (***)(void))(v3 + 64);
                if (v13)
                {
                  *(void *)(v3 + 64) = 0LL;
                  v13[2](v13);
                  _Block_release(v13);
                }

                if ((*(_BYTE *)(v3 + 72) & 1) != 0)
                {
                  __int16 v14 = *(const void **)(v3 + 64);
                  if (v14) {
                    _Block_release(v14);
                  }
                }

                free((void *)v3);
              }
            }
          }

          return v10;
        }

uint64_t nw_protocol_common_register_notification(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v45 = "nw_protocol_common_register_notification";
    uint64_t v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_register_notification";
      uint64_t v19 = "%{public}s called with null protocol";
      goto LABEL_47;
    }

    if (!v42)
    {
      os_log_type_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_register_notification";
      uint64_t v19 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    os_log_type_t v17 = (os_log_s *)__nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v37 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v37) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_register_notification";
      uint64_t v19 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_47;
    }

    if (!v37) {
      goto LABEL_34;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v45 = "nw_protocol_common_register_notification";
    __int16 v46 = 2082;
    uint64_t v47 = backtrace_string;
    uint64_t v22 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_33;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v45 = "nw_protocol_common_register_notification";
    uint64_t v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_register_notification";
      uint64_t v19 = "%{public}s called with null other_protocol";
      goto LABEL_47;
    }

    if (!v42)
    {
      os_log_type_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_register_notification";
      uint64_t v19 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    os_log_type_t v17 = (os_log_s *)__nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v38 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v38) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_register_notification";
      uint64_t v19 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_47;
    }

    if (!v38) {
      goto LABEL_34;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v45 = "nw_protocol_common_register_notification";
    __int16 v46 = 2082;
    uint64_t v47 = backtrace_string;
    uint64_t v22 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
    goto LABEL_33;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v45 = "nw_protocol_common_register_notification";
    uint64_t v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_register_notification";
      uint64_t v19 = "%{public}s called with null type";
      goto LABEL_47;
    }

    if (!v42)
    {
      os_log_type_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_register_notification";
      uint64_t v19 = "%{public}s called with null type, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    os_log_type_t v17 = (os_log_s *)__nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v39 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v39) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_register_notification";
      uint64_t v19 = "%{public}s called with null type, no backtrace";
      goto LABEL_47;
    }

    if (!v39) {
      goto LABEL_34;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v45 = "nw_protocol_common_register_notification";
    __int16 v46 = 2082;
    uint64_t v47 = backtrace_string;
    uint64_t v22 = "%{public}s called with null type, dumping backtrace:%{public}s";
    goto LABEL_33;
  }

  uint64_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    uint64_t v5 = *(void **)(v4 + 40);
    if (v5 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = *(void *)(v4 + 88);
      if (v6) {
        *(void *)(v4 + 8_Block_object_dispose(va, 8) = v6 + 1;
      }
    }

    uint64_t v7 = *(void **)(a2 + 40);
    if (v7 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v8 = *(void *)(a2 + 88);
      if (v8) {
        *(void *)(a2 + 8_Block_object_dispose(va, 8) = v8 + 1;
      }
    }

    uint64_t v9 = *(void *)(v4 + 24);
    if (v9)
    {
      uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 144);
      if (v10)
      {
        uint64_t v11 = v10(v4, a2);
        if (v7 != &nw_protocol_ref_counted_handle)
        {
LABEL_15:
          if (v5 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v12 = *(void *)(v4 + 88);
            if (v12)
            {
              uint64_t v13 = v12 - 1;
              *(void *)(v4 + 8_Block_object_dispose(va, 8) = v13;
              if (!v13)
              {
                __int16 v14 = *(void (***)(void))(v4 + 64);
                if (v14)
                {
                  *(void *)(v4 + 64) = 0LL;
                  v14[2](v14);
                  _Block_release(v14);
                }

                if ((*(_BYTE *)(v4 + 72) & 1) != 0)
                {
                  os_log_type_t v15 = *(const void **)(v4 + 64);
                  if (v15) {
                    _Block_release(v15);
                  }
                }

                free((void *)v4);
              }
            }
          }

          return v11;
        }

uint64_t nw_protocol_common_unregister_notification(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v45 = "nw_protocol_common_unregister_notification";
    uint64_t v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_unregister_notification";
      uint64_t v19 = "%{public}s called with null protocol";
      goto LABEL_47;
    }

    if (!v42)
    {
      os_log_type_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_unregister_notification";
      uint64_t v19 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    os_log_type_t v17 = (os_log_s *)__nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v37 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v37) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_unregister_notification";
      uint64_t v19 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_47;
    }

    if (!v37) {
      goto LABEL_34;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v45 = "nw_protocol_common_unregister_notification";
    __int16 v46 = 2082;
    uint64_t v47 = backtrace_string;
    uint64_t v22 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_33;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v45 = "nw_protocol_common_unregister_notification";
    uint64_t v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_unregister_notification";
      uint64_t v19 = "%{public}s called with null other_protocol";
      goto LABEL_47;
    }

    if (!v42)
    {
      os_log_type_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_unregister_notification";
      uint64_t v19 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    os_log_type_t v17 = (os_log_s *)__nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v38 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v38) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_unregister_notification";
      uint64_t v19 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_47;
    }

    if (!v38) {
      goto LABEL_34;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v45 = "nw_protocol_common_unregister_notification";
    __int16 v46 = 2082;
    uint64_t v47 = backtrace_string;
    uint64_t v22 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
    goto LABEL_33;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v45 = "nw_protocol_common_unregister_notification";
    uint64_t v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_unregister_notification";
      uint64_t v19 = "%{public}s called with null type";
      goto LABEL_47;
    }

    if (!v42)
    {
      os_log_type_t v17 = (os_log_s *)__nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_unregister_notification";
      uint64_t v19 = "%{public}s called with null type, backtrace limit exceeded";
      goto LABEL_47;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    os_log_type_t v17 = (os_log_s *)__nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v39 = os_log_type_enabled(v17, type);
    if (!backtrace_string)
    {
      if (!v39) {
        goto LABEL_48;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_unregister_notification";
      uint64_t v19 = "%{public}s called with null type, no backtrace";
      goto LABEL_47;
    }

    if (!v39) {
      goto LABEL_34;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v45 = "nw_protocol_common_unregister_notification";
    __int16 v46 = 2082;
    uint64_t v47 = backtrace_string;
    uint64_t v22 = "%{public}s called with null type, dumping backtrace:%{public}s";
    goto LABEL_33;
  }

  uint64_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    uint64_t v5 = *(void **)(v4 + 40);
    if (v5 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = *(void *)(v4 + 88);
      if (v6) {
        *(void *)(v4 + 8_Block_object_dispose(va, 8) = v6 + 1;
      }
    }

    uint64_t v7 = *(void **)(a2 + 40);
    if (v7 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v8 = *(void *)(a2 + 88);
      if (v8) {
        *(void *)(a2 + 8_Block_object_dispose(va, 8) = v8 + 1;
      }
    }

    uint64_t v9 = *(void *)(v4 + 24);
    if (v9)
    {
      uint64_t v10 = *(uint64_t (**)(uint64_t, uint64_t))(v9 + 152);
      if (v10)
      {
        uint64_t v11 = v10(v4, a2);
        if (v7 != &nw_protocol_ref_counted_handle)
        {
LABEL_15:
          if (v5 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v4 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v12 = *(void *)(v4 + 88);
            if (v12)
            {
              uint64_t v13 = v12 - 1;
              *(void *)(v4 + 8_Block_object_dispose(va, 8) = v13;
              if (!v13)
              {
                __int16 v14 = *(void (***)(void))(v4 + 64);
                if (v14)
                {
                  *(void *)(v4 + 64) = 0LL;
                  v14[2](v14);
                  _Block_release(v14);
                }

                if ((*(_BYTE *)(v4 + 72) & 1) != 0)
                {
                  os_log_type_t v15 = *(const void **)(v4 + 64);
                  if (v15) {
                    _Block_release(v15);
                  }
                }

                free((void *)v4);
              }
            }
          }

          return v11;
        }

uint64_t nw_protocol_common_updated_path(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v52 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v45 = "nw_protocol_common_updated_path";
    BOOL v28 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v29 = (os_log_s *)__nwlog_obj();
      os_log_type_t v30 = type;
      if (!os_log_type_enabled(v29, type)) {
        goto LABEL_104;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_updated_path";
      os_log_type_t v31 = "%{public}s called with null protocol";
      goto LABEL_103;
    }

    if (!v42)
    {
      BOOL v29 = (os_log_s *)__nwlog_obj();
      os_log_type_t v30 = type;
      if (!os_log_type_enabled(v29, type)) {
        goto LABEL_104;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_updated_path";
      os_log_type_t v31 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_103;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    BOOL v29 = (os_log_s *)__nwlog_obj();
    os_log_type_t v30 = type;
    BOOL v36 = os_log_type_enabled(v29, type);
    if (!backtrace_string)
    {
      if (!v36) {
        goto LABEL_104;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_updated_path";
      os_log_type_t v31 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_103;
    }

    if (!v36) {
      goto LABEL_77;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v45 = "nw_protocol_common_updated_path";
    __int16 v46 = 2082;
    uint64_t v47 = backtrace_string;
    BOOL v37 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_76:
    _os_log_impl(&dword_181A5C000, v29, v30, v37, buf, 0x16u);
    goto LABEL_77;
  }

  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v45 = "nw_protocol_common_updated_path";
    BOOL v28 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v29 = (os_log_s *)__nwlog_obj();
      os_log_type_t v30 = type;
      if (!os_log_type_enabled(v29, type)) {
        goto LABEL_104;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_updated_path";
      os_log_type_t v31 = "%{public}s called with null other_protocol";
      goto LABEL_103;
    }

    if (!v42)
    {
      BOOL v29 = (os_log_s *)__nwlog_obj();
      os_log_type_t v30 = type;
      if (!os_log_type_enabled(v29, type)) {
        goto LABEL_104;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_updated_path";
      os_log_type_t v31 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_103;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    BOOL v29 = (os_log_s *)__nwlog_obj();
    os_log_type_t v30 = type;
    BOOL v38 = os_log_type_enabled(v29, type);
    if (!backtrace_string)
    {
      if (!v38) {
        goto LABEL_104;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_updated_path";
      os_log_type_t v31 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_103;
    }

    if (!v38) {
      goto LABEL_77;
    }
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v45 = "nw_protocol_common_updated_path";
    __int16 v46 = 2082;
    uint64_t v47 = backtrace_string;
    BOOL v37 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
    goto LABEL_76;
  }

  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v45 = "nw_protocol_common_updated_path";
    BOOL v28 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v29 = (os_log_s *)__nwlog_obj();
      os_log_type_t v30 = type;
      if (!os_log_type_enabled(v29, type)) {
        goto LABEL_104;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_updated_path";
      os_log_type_t v31 = "%{public}s called with null path";
      goto LABEL_103;
    }

    if (!v42)
    {
      BOOL v29 = (os_log_s *)__nwlog_obj();
      os_log_type_t v30 = type;
      if (!os_log_type_enabled(v29, type)) {
        goto LABEL_104;
      }
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v45 = "nw_protocol_common_updated_path";
      os_log_type_t v31 = "%{public}s called with null path, backtrace limit exceeded";
      goto LABEL_103;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    BOOL v29 = (os_log_s *)__nwlog_obj();
    os_log_type_t v30 = type;
    BOOL v39 = os_log_type_enabled(v29, type);
    if (backtrace_string)
    {
      if (v39)
      {
        *(_DWORD *)__int128 buf = 136446466;
        __int16 v45 = "nw_protocol_common_updated_path";
        __int16 v46 = 2082;
        uint64_t v47 = backtrace_string;
        BOOL v37 = "%{public}s called with null path, dumping backtrace:%{public}s";
        goto LABEL_76;
      }

void nw_protocol_common_link_state(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v49 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)__int128 buf = 136446210;
    char v42 = "nw_protocol_common_link_state";
    uint64_t v4 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v39)
      {
        backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
        os_log_type_t v15 = (os_log_s *)__nwlog_obj();
        os_log_type_t v16 = type;
        BOOL v34 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)__int128 buf = 136446466;
            char v42 = "nw_protocol_common_link_state";
            __int16 v43 = 2082;
            __int16 v44 = backtrace_string;
            BOOL v20 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
            goto LABEL_33;
          }

uint64_t (**nw_protocol_set_common_callbacks( uint64_t (**result)(uint64_t a1, uint64_t a2)))(uint64_t a1, uint64_t a2)
{
  *BOOL result = nw_protocol_common_add_input_handler;
  result[1] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_remove_input_handler;
  result[10] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_get_input_frames;
  result[11] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_get_output_frames;
  result[14] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_get_parameters;
  result[15] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_get_path;
  result[16] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_get_local_endpoint;
  result[17] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_get_remote_endpoint;
  result[2] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_replace_input_handler;
  result[3] = nw_protocol_common_connect;
  result[4] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_disconnect;
  result[5] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_connected;
  result[8] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_input_available;
  result[9] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_output_available;
  result[24] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_output_finished;
  result[25] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_get_output_local_endpoint;
  result[33] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_input_flush;
  result[6] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_disconnected;
  result[7] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_error;
  result[31] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_get_message_properties;
  result[32] = nw_protocol_common_reset;
  result[28] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_copy_info;
  result[22] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_supports_external_data;
  result[23] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_input_finished;
  result[26] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_get_output_interface;
  result[27] = nw_protocol_common_waiting_for_output;
  result[18] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_register_notification;
  result[19] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_unregister_notification;
  result[20] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_notify;
  result[21] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_updated_path;
  result[12] = nw_protocol_common_finalize_output_frames;
  result[13] = (uint64_t (*)(uint64_t, uint64_t))nw_protocol_common_link_state;
  return result;
}

void sub_18230147C( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, objc_super a13)
{
  a13.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_nat64_prefixes_resolver;
  -[_Unwind_Exception dealloc](&a13, sel_dealloc);
  _Unwind_Resume(a1);
}

BOOL nw_nat64_can_v4_address_be_synthesized(unsigned int *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  if (a1)
  {
    unsigned int v1 = bswap32(*a1);
    unsigned int v2 = v1 & 0xFF000000;
    BOOL v4 = *a1 != -1 && v1 >> 28 != 14;
    if (v1 >> 8 == 12605539 || (v1 & 0xFFFF0000) == -1442971648 || (v1 & 0xFFFFFFF8) == -1073741824) {
      BOOL v4 = 0;
    }
    if (v2) {
      BOOL v7 = v2 == 2130706432;
    }
    else {
      BOOL v7 = 1;
    }
    return !v7 && v4;
  }

  __nwlog_obj();
  uint64_t v9 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  BOOL v19 = "nw_nat64_can_v4_address_be_synthesized";
  uint64_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v10, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v19 = "nw_nat64_can_v4_address_be_synthesized";
        uint64_t v13 = "%{public}s called with null ipv4_addr";
LABEL_36:
        _os_log_impl(&dword_181A5C000, v11, v12, v13, buf, 0xCu);
      }
    }

    else
    {
      if (v16)
      {
        backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v12 = type;
        BOOL v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)__int128 buf = 136446466;
            BOOL v19 = "nw_nat64_can_v4_address_be_synthesized";
            __int16 v20 = 2082;
            uint64_t v21 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v11,  v12,  "%{public}s called with null ipv4_addr, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_38;
        }

        if (!v15) {
          goto LABEL_37;
        }
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v19 = "nw_nat64_can_v4_address_be_synthesized";
        uint64_t v13 = "%{public}s called with null ipv4_addr, no backtrace";
        goto LABEL_36;
      }

      __nwlog_obj();
      uint64_t v11 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v19 = "nw_nat64_can_v4_address_be_synthesized";
        uint64_t v13 = "%{public}s called with null ipv4_addr, backtrace limit exceeded";
        goto LABEL_36;
      }
    }

uint64_t nw_nat64_v4_address_requires_synthesis(unsigned int *a1)
{
  uint64_t v28 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    os_log_type_t v17 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)uint64_t address = 136446210;
    *(void *)&address[4] = "nw_nat64_v4_address_requires_synthesis";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault(v18, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)uint64_t address = 136446210;
          *(void *)&address[4] = "nw_nat64_v4_address_requires_synthesis";
          _os_log_impl(&dword_181A5C000, v19, v20, "%{public}s called with null ipv4_addr", address, 0xCu);
        }
      }

      else if (v25)
      {
        backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = type;
        BOOL v23 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v23)
          {
            *(_DWORD *)uint64_t address = 136446466;
            *(void *)&address[4] = "nw_nat64_v4_address_requires_synthesis";
            *(_WORD *)&address[12] = 2082;
            *(void *)&address[14] = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v19,  v22,  "%{public}s called with null ipv4_addr, dumping backtrace:%{public}s",  address,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_43;
        }

        if (v23)
        {
          *(_DWORD *)uint64_t address = 136446210;
          *(void *)&address[4] = "nw_nat64_v4_address_requires_synthesis";
          _os_log_impl(&dword_181A5C000, v19, v22, "%{public}s called with null ipv4_addr, no backtrace", address, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        BOOL v19 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)uint64_t address = 136446210;
          *(void *)&address[4] = "nw_nat64_v4_address_requires_synthesis";
          _os_log_impl( &dword_181A5C000,  v19,  v24,  "%{public}s called with null ipv4_addr, backtrace limit exceeded",  address,  0xCu);
        }
      }
    }

void sub_182301B74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_nat64_synthesize_v6(void *__src, __int16 *a2, char *__dst)
{
  *(void *)&v42[13] = *MEMORY[0x1895F89C0];
  if (!__src)
  {
    __nwlog_obj();
    char v25 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    char v40 = "nw_nat64_synthesize_v6";
    BOOL v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_89;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v40 = "nw_nat64_synthesize_v6";
      BOOL v29 = "%{public}s called with null prefix";
LABEL_88:
      _os_log_impl(&dword_181A5C000, v27, v28, v29, buf, 0xCu);
      goto LABEL_89;
    }

    if (!v37)
    {
      __nwlog_obj();
      os_log_type_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v40 = "nw_nat64_synthesize_v6";
        BOOL v29 = "%{public}s called with null prefix, backtrace limit exceeded";
        goto LABEL_88;
      }

      goto LABEL_89;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v28 = type;
    BOOL v33 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (v33)
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v40 = "nw_nat64_synthesize_v6";
        BOOL v29 = "%{public}s called with null prefix, no backtrace";
        goto LABEL_88;
      }

      goto LABEL_89;
    }

    if (!v33) {
      goto LABEL_75;
    }
    *(_DWORD *)__int128 buf = 136446466;
    char v40 = "nw_nat64_synthesize_v6";
    __int16 v41 = 2082;
    *(void *)char v42 = backtrace_string;
    BOOL v34 = "%{public}s called with null prefix, dumping backtrace:%{public}s";
LABEL_74:
    _os_log_impl(&dword_181A5C000, v27, v28, v34, buf, 0x16u);
    goto LABEL_75;
  }

  if (!a2)
  {
    __nwlog_obj();
    os_log_type_t v30 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    char v40 = "nw_nat64_synthesize_v6";
    BOOL v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_89;
      }
      *(_DWORD *)__int128 buf = 136446210;
      char v40 = "nw_nat64_synthesize_v6";
      BOOL v29 = "%{public}s called with null ipv4_addr";
      goto LABEL_88;
    }

    if (!v37)
    {
      __nwlog_obj();
      os_log_type_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v40 = "nw_nat64_synthesize_v6";
        BOOL v29 = "%{public}s called with null ipv4_addr, backtrace limit exceeded";
        goto LABEL_88;
      }

      goto LABEL_89;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    os_log_type_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v28 = type;
    BOOL v35 = os_log_type_enabled(v27, type);
    if (!backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v40 = "nw_nat64_synthesize_v6";
        BOOL v29 = "%{public}s called with null ipv4_addr, no backtrace";
        goto LABEL_88;
      }

      goto LABEL_89;
    }

    if (!v35) {
      goto LABEL_75;
    }
    *(_DWORD *)__int128 buf = 136446466;
    char v40 = "nw_nat64_synthesize_v6";
    __int16 v41 = 2082;
    *(void *)char v42 = backtrace_string;
    BOOL v34 = "%{public}s called with null ipv4_addr, dumping backtrace:%{public}s";
    goto LABEL_74;
  }

  if (!__dst)
  {
    __nwlog_obj();
    os_log_type_t v31 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    char v40 = "nw_nat64_synthesize_v6";
    BOOL v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      os_log_type_t v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        char v40 = "nw_nat64_synthesize_v6";
        BOOL v29 = "%{public}s called with null out_ipv6_addr";
        goto LABEL_88;
      }

uint64_t nw_nat64_extract_v4(unsigned int *a1, char *__s1, uint64_t a3)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    BOOL v36 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)BOOL v53 = 136446210;
    *(void *)&v53[4] = "nw_nat64_extract_v4";
    __int16 v11 = (char *)_os_log_send_and_compose_impl();

    v51[0] = OS_LOG_TYPE_ERROR;
    buf[0] = 0;
    if (v51[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      __int16 v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v37 = v51[0];
      if (!os_log_type_enabled(v12, v51[0])) {
        goto LABEL_36;
      }
      *(_DWORD *)BOOL v53 = 136446210;
      *(void *)&v53[4] = "nw_nat64_extract_v4";
      int v14 = "%{public}s called with null prefix";
      goto LABEL_93;
    }

    if (buf[0])
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      __int16 v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v37 = v51[0];
      BOOL v41 = os_log_type_enabled(v12, v51[0]);
      if (backtrace_string)
      {
        if (!v41) {
          goto LABEL_79;
        }
        *(_DWORD *)BOOL v53 = 136446466;
        *(void *)&v53[4] = "nw_nat64_extract_v4";
        *(_WORD *)&v53[12] = 2082;
        *(void *)&v53[14] = backtrace_string;
        char v42 = "%{public}s called with null prefix, dumping backtrace:%{public}s";
        goto LABEL_78;
      }

      if (!v41) {
        goto LABEL_36;
      }
      *(_DWORD *)BOOL v53 = 136446210;
      *(void *)&v53[4] = "nw_nat64_extract_v4";
      int v14 = "%{public}s called with null prefix, no backtrace";
    }

    else
    {
      __nwlog_obj();
      __int16 v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v37 = v51[0];
      if (!os_log_type_enabled(v12, v51[0])) {
        goto LABEL_36;
      }
      *(_DWORD *)BOOL v53 = 136446210;
      *(void *)&v53[4] = "nw_nat64_extract_v4";
      int v14 = "%{public}s called with null prefix, backtrace limit exceeded";
    }

uint64_t nw_nat64_write_prefix_to_string(unsigned int *a1, char *a2, socklen_t a3)
{
  uint64_t v78 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    int32x4_t v61 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    unsigned int v70 = "nw_nat64_write_prefix_to_string";
    char v39 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v68 = OS_LOG_TYPE_DEFAULT;
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v62 = type[0];
      if (!os_log_type_enabled(v21, type[0])) {
        goto LABEL_68;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v70 = "nw_nat64_write_prefix_to_string";
      int v23 = "%{public}s called with null prefix";
    }

    else if (v68)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v62 = type[0];
      BOOL v65 = os_log_type_enabled(v21, type[0]);
      if (backtrace_string)
      {
        if (v65)
        {
          *(_DWORD *)__int128 buf = 136446466;
          unsigned int v70 = "nw_nat64_write_prefix_to_string";
          __int16 v71 = 2082;
          *(void *)__int16 v72 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v21,  v62,  "%{public}s called with null prefix, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_84;
      }

      if (!v65) {
        goto LABEL_68;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v70 = "nw_nat64_write_prefix_to_string";
      int v23 = "%{public}s called with null prefix, no backtrace";
    }

    else
    {
      __nwlog_obj();
      id v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v62 = type[0];
      if (!os_log_type_enabled(v21, type[0])) {
        goto LABEL_68;
      }
      *(_DWORD *)__int128 buf = 136446210;
      unsigned int v70 = "nw_nat64_write_prefix_to_string";
      int v23 = "%{public}s called with null prefix, backtrace limit exceeded";
    }

uint64_t nw_nat64_copy_prefixes_from_ipv4only_records(uint64_t a1, int a2, void *a3)
{
  uint64_t v79 = *MEMORY[0x1895F89C0];
  if (!a1)
  {
    __nwlog_obj();
    os_log_type_t v35 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int16 v76 = 136446210;
    *(void *)&void v76[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    BOOL v36 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v67) = 0;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      id v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v38 = buf[0];
      if (!os_log_type_enabled(v37, (os_log_type_t)buf[0])) {
        goto LABEL_123;
      }
      *(_DWORD *)__int16 v76 = 136446210;
      *(void *)&void v76[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
      char v39 = "%{public}s called with null ipv6_addrs";
LABEL_122:
      _os_log_impl(&dword_181A5C000, v37, v38, v39, v76, 0xCu);
      goto LABEL_123;
    }

    if (!(_BYTE)v67)
    {
      __nwlog_obj();
      id v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v38 = buf[0];
      if (os_log_type_enabled(v37, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)__int16 v76 = 136446210;
        *(void *)&void v76[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
        char v39 = "%{public}s called with null ipv6_addrs, backtrace limit exceeded";
        goto LABEL_122;
      }

      goto LABEL_123;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    id v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v38 = buf[0];
    BOOL v51 = os_log_type_enabled(v37, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v51)
      {
        *(_DWORD *)__int16 v76 = 136446210;
        *(void *)&void v76[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
        char v39 = "%{public}s called with null ipv6_addrs, no backtrace";
        goto LABEL_122;
      }

      goto LABEL_123;
    }

    if (!v51) {
      goto LABEL_109;
    }
    *(_DWORD *)__int16 v76 = 136446466;
    *(void *)&void v76[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    *(_WORD *)&v76[12] = 2082;
    *(void *)&v76[14] = backtrace_string;
    uint64_t v52 = "%{public}s called with null ipv6_addrs, dumping backtrace:%{public}s";
LABEL_108:
    _os_log_impl(&dword_181A5C000, v37, v38, v52, v76, 0x16u);
LABEL_109:

    free(backtrace_string);
    goto LABEL_124;
  }

  if (!a2)
  {
    __nwlog_obj();
    char v40 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int16 v76 = 136446210;
    *(void *)&void v76[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    BOOL v36 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v67) = 0;
    if (buf[0] == 17)
    {
      __nwlog_obj();
      id v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v38 = buf[0];
      if (!os_log_type_enabled(v37, (os_log_type_t)buf[0])) {
        goto LABEL_123;
      }
      *(_DWORD *)__int16 v76 = 136446210;
      *(void *)&void v76[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
      char v39 = "%{public}s called with null num_ipv6_addrs";
      goto LABEL_122;
    }

    if (!(_BYTE)v67)
    {
      __nwlog_obj();
      id v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v38 = buf[0];
      if (os_log_type_enabled(v37, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)__int16 v76 = 136446210;
        *(void *)&void v76[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
        char v39 = "%{public}s called with null num_ipv6_addrs, backtrace limit exceeded";
        goto LABEL_122;
      }

      goto LABEL_123;
    }

    backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
    __nwlog_obj();
    id v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_t v38 = buf[0];
    BOOL v53 = os_log_type_enabled(v37, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v53)
      {
        *(_DWORD *)__int16 v76 = 136446210;
        *(void *)&void v76[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
        char v39 = "%{public}s called with null num_ipv6_addrs, no backtrace";
        goto LABEL_122;
      }

      goto LABEL_123;
    }

    if (!v53) {
      goto LABEL_109;
    }
    *(_DWORD *)__int16 v76 = 136446466;
    *(void *)&void v76[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    *(_WORD *)&v76[12] = 2082;
    *(void *)&v76[14] = backtrace_string;
    uint64_t v52 = "%{public}s called with null num_ipv6_addrs, dumping backtrace:%{public}s";
    goto LABEL_108;
  }

  if (!a3)
  {
    __nwlog_obj();
    BOOL v41 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int16 v76 = 136446210;
    *(void *)&void v76[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
    BOOL v36 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    LOBYTE(v67) = 0;
    if (__nwlog_fault(v36, buf, &v67))
    {
      if (buf[0] == 17)
      {
        __nwlog_obj();
        id v37 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v38 = buf[0];
        if (os_log_type_enabled(v37, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)__int16 v76 = 136446210;
          *(void *)&void v76[4] = "nw_nat64_copy_prefixes_from_ipv4only_records";
          char v39 = "%{public}s called with null out_prefixes";
          goto LABEL_122;
        }

uint64_t nw_nat64_copy_prefixes(unsigned int *a1, void *a2)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if (sNWIsBetweenForkAndExec == 1 && (sNWParentAllowedDispatch & 1) != 0) {
    return 0LL;
  }
  if ((sNWDispatchAllowedNow & 1) != 0) {
    goto LABEL_9;
  }
  if ((_dispatch_is_fork_of_multithreaded_parent() & 1) == 0 && (_dispatch_is_multithreaded() & 1) != 0
    || (getpid(), sandbox_check() == 1))
  {
    sNWDispatchAllowedNow = 1;
    goto LABEL_9;
  }

  if (sNWDispatchAllowedNow != 1) {
    return 0LL;
  }
LABEL_9:
  if (a2)
  {
    if (gLogDatapath)
    {
      __nwlog_obj();
      __int16 v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        if (a1) {
          unsigned int v13 = *a1;
        }
        else {
          unsigned int v13 = 0;
        }
        *(_DWORD *)__int128 buf = 136446466;
        int v19 = "nw_nat64_copy_prefixes";
        __int16 v20 = 1024;
        LODWORD(v2nw_tcp_options_set_enable_fast_open(options, 1) = v13;
        _os_log_impl( &dword_181A5C000,  v12,  OS_LOG_TYPE_DEBUG,  "%{public}s Start nw_nat64_copy_prefixes(%u)",  buf,  0x12u);
      }
    }

    *a2 = 0LL;
    BOOL v4 = nw_nat64_copy_prefixes_internal(a1, a2, 0LL, 0LL, 0LL, 0LL);
    if (gLogDatapath)
    {
      __nwlog_obj();
      uint64_t v5 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__int128 buf = 136446466;
        int v19 = "nw_nat64_copy_prefixes";
        __int16 v20 = 1024;
        LODWORD(v2nw_tcp_options_set_enable_fast_open(options, 1) = v4;
        _os_log_impl( &dword_181A5C000,  v5,  OS_LOG_TYPE_DEBUG,  "%{public}s nw_nat64_copy_prefixes returning %d",  buf,  0x12u);
      }
    }

    return v4;
  }

  __nwlog_obj();
  BOOL v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  int v19 = "nw_nat64_copy_prefixes";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v8, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      unsigned int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v19 = "nw_nat64_copy_prefixes";
        size_t v11 = "%{public}s called with null out_prefixes";
LABEL_36:
        _os_log_impl(&dword_181A5C000, v9, v10, v11, buf, 0xCu);
      }
    }

    else
    {
      if (v16)
      {
        backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        unsigned int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v10 = type;
        BOOL v15 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)__int128 buf = 136446466;
            int v19 = "nw_nat64_copy_prefixes";
            __int16 v20 = 2082;
            id v21 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v9,  v10,  "%{public}s called with null out_prefixes, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_38;
        }

        if (!v15) {
          goto LABEL_37;
        }
        *(_DWORD *)__int128 buf = 136446210;
        int v19 = "nw_nat64_copy_prefixes";
        size_t v11 = "%{public}s called with null out_prefixes, no backtrace";
        goto LABEL_36;
      }

      __nwlog_obj();
      unsigned int v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        int v19 = "nw_nat64_copy_prefixes";
        size_t v11 = "%{public}s called with null out_prefixes, backtrace limit exceeded";
        goto LABEL_36;
      }
    }

BOOL nw_nat64_copy_prefixes_internal( unsigned int *a1, void *a2, void *a3, DNSServiceRef *a4, _DWORD *a5, void *a6)
{
  uint64_t v117 = *MEMORY[0x1895F89C0];
  size_t v11 = a3;
  id v12 = a6;
  unsigned int v102 = 0;
  if (a1) {
    unsigned int v102 = *a1;
  }
  id v101 = 0LL;
  int interface_state_internal = nw_nat64_get_interface_state_internal(&v102, &v101);
  int v14 = interface_state_internal;
  if (a1) {
    *a1 = v102;
  }
  uint64_t v15 = 0LL;
  switch(interface_state_internal)
  {
    case 1:
      if (!v101)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v43 = (id)gLogObj;
        *(_DWORD *)__int128 buf = 136446210;
        unsigned __int8 v112 = "nw_nat64_copy_prefixes_internal";
        id v37 = (char *)_os_log_send_and_compose_impl();

        LOBYTE(sdRef) = 16;
        LOBYTE(service) = 0;
        if (sdRef == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v44 = (os_log_s *)(id)gLogObj;
          os_log_type_t v45 = sdRef;
          if (os_log_type_enabled(v44, (os_log_type_t)sdRef))
          {
            *(_DWORD *)__int128 buf = 136446210;
            unsigned __int8 v112 = "nw_nat64_copy_prefixes_internal";
            _os_log_impl(&dword_181A5C000, v44, v45, "%{public}s Received invalid path", buf, 0xCu);
          }
        }

        else if ((_BYTE)service)
        {
          backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
          __nwlog_obj();
          BOOL v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v59 = sdRef;
          BOOL v60 = os_log_type_enabled(v44, (os_log_type_t)sdRef);
          if (backtrace_string)
          {
            if (v60)
            {
              *(_DWORD *)__int128 buf = 136446466;
              unsigned __int8 v112 = "nw_nat64_copy_prefixes_internal";
              __int16 v113 = 2082;
              *(void *)uint64_t v114 = backtrace_string;
              _os_log_impl( &dword_181A5C000,  v44,  v59,  "%{public}s Received invalid path, dumping backtrace:%{public}s",  buf,  0x16u);
            }

            free(backtrace_string);
            if (v37) {
LABEL_109:
            }
              free(v37);
LABEL_110:
            uint64_t v15 = 0xFFFFFFFFLL;
            goto LABEL_111;
          }

          if (v60)
          {
            *(_DWORD *)__int128 buf = 136446210;
            unsigned __int8 v112 = "nw_nat64_copy_prefixes_internal";
            _os_log_impl(&dword_181A5C000, v44, v59, "%{public}s Received invalid path, no backtrace", buf, 0xCu);
          }
        }

        else
        {
          __nwlog_obj();
          BOOL v44 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_t v63 = sdRef;
          if (os_log_type_enabled(v44, (os_log_type_t)sdRef))
          {
            *(_DWORD *)__int128 buf = 136446210;
            unsigned __int8 v112 = "nw_nat64_copy_prefixes_internal";
            _os_log_impl( &dword_181A5C000,  v44,  v63,  "%{public}s Received invalid path, backtrace limit exceeded",  buf,  0xCu);
          }
        }

        goto LABEL_108;
      }

      char v16 = (unsigned int *)v101;

      DNSServiceRef sdRef = 0LL;
      p_DNSServiceRef sdRef = (uint64_t)&sdRef;
      uint64_t v105 = 0x2020000000LL;
      size_t v17 = calloc(4uLL, 0x10uLL);
      if (v17) {
        goto LABEL_8;
      }
      __nwlog_obj();
      unsigned __int8 v90 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v90, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int128 buf = 136446722;
      unsigned __int8 v112 = "strict_calloc";
      __int16 v113 = 2048;
      *(void *)uint64_t v114 = 4LL;
      *(_WORD *)&v114[8] = 2048;
      *(void *)&v114[10] = 16LL;
      unsigned __int8 v91 = (void *)_os_log_send_and_compose_impl();

      BOOL result = __nwlog_abort((uint64_t)v91);
      if (result) {
        goto LABEL_134;
      }
      free(v91);
LABEL_8:
      unsigned __int8 v106 = v17;
      size_t v18 = v16[102];
      if ((_DWORD)v18)
      {
        **(_DWORD **)(p_sdRef + 24) = v18;
        memcpy((void *)(*(void *)(p_sdRef + 24) + 4LL), v16 + 98, v18);
        uint64_t v15 = 1LL;
        size_t v19 = v16[107];
        if (!(_DWORD)v19)
        {
LABEL_11:
          size_t v21 = v16[112];
          if ((_DWORD)v21)
          {
            uint64_t v22 = 16LL * v15;
            *(_DWORD *)(*(void *)(p_sdRef + 24) + v22) = v21;
            memcpy((void *)(*(void *)(p_sdRef + 24) + v22 + 4), v16 + 98, v21);
            uint64_t v15 = (v15 + 1);
          }

          size_t v23 = v16[117];
          if ((_DWORD)v23)
          {
            uint64_t v24 = 16LL * v15;
            *(_DWORD *)(*(void *)(p_sdRef + 24) + v24) = v23;
            memcpy((void *)(*(void *)(p_sdRef + 24) + v24 + 4), v16 + 98, v23);
            uint64_t v15 = (v15 + 1);
          }

          if (a2)
          {
            uint64_t v25 = *(void **)(p_sdRef + 24);
            if ((_DWORD)v15)
            {
              *a2 = v25;
            }

            else if (v25)
            {
              free(v25);
              uint64_t v15 = 0LL;
              *(void *)(p_sdRef + 24) = 0LL;
            }

            else
            {
              uint64_t v15 = 0LL;
            }
          }

          else
          {
            block[0] = MEMORY[0x1895F87A8];
            block[1] = 3221225472LL;
            block[2] = ___ZL31nw_nat64_copy_prefixes_internalPjPP17nw_nat64_prefix_tPU28objcproto17OS_dispatch_queue8NSObjectPP16_DNSServiceRef_tPKjU13block_pointerFviS1_E_block_invoke;
            block[3] = &unk_189BC0D00;
            int v100 = v15;
            id v98 = v12;
            unsigned __int8 v99 = &sdRef;
            dispatch_async(v11, block);

            uint64_t v15 = 0x80000000LL;
          }

          _Block_object_dispose(&sdRef, 8);
LABEL_111:

          return v15;
        }
      }

      else
      {
        uint64_t v15 = 0LL;
        size_t v19 = v16[107];
        if (!(_DWORD)v19) {
          goto LABEL_11;
        }
      }

      uint64_t v20 = 16LL * v15;
      *(_DWORD *)(*(void *)(p_sdRef + 24) + v20) = v19;
      memcpy((void *)(*(void *)(p_sdRef + 24) + v20 + 4), v16 + 98, v19);
      uint64_t v15 = (v15 + 1);
      goto LABEL_11;
    case 2:
      uint32_t v26 = v102;
      uint64_t v27 = v11;
      id v28 = v12;
      size_t v29 = v28;
      int v96 = v27;
      if (!a2)
      {
        DNSServiceRef sdRef = (DNSServiceRef)MEMORY[0x1895F87A8];
        p_DNSServiceRef sdRef = 3221225472LL;
        uint64_t v105 = (uint64_t)___ZL43nw_nat64_copy_prefixes_by_querying_ipv4onlyjPP17nw_nat64_prefix_tPU28objcproto17OS_dispatch_queue8NSObjectPP16_DNSServiceRef_tPKjU13block_pointerFviS0_E_block_invoke;
        unsigned __int8 v106 = &unk_189BC0D28;
        id v107 = v28;
        dispatch_queue_t queue = v27;
        aBlock = &sdRef;
        BOOL v46 = (void **)calloc(0x18uLL, 1uLL);
        if (!v46)
        {
          __nwlog_obj();
          unsigned __int8 v92 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          os_log_type_enabled(v92, OS_LOG_TYPE_ERROR);
          *(_DWORD *)__int128 buf = 136446722;
          unsigned __int8 v112 = "strict_calloc";
          __int16 v113 = 2048;
          *(void *)uint64_t v114 = 24LL;
          *(_WORD *)&v114[8] = 2048;
          *(void *)&v114[10] = 1LL;
          id v93 = (void *)_os_log_send_and_compose_impl();

          BOOL result = __nwlog_abort((uint64_t)v93);
          if (result) {
            goto LABEL_134;
          }
          free(v93);
        }

        int v47 = _Block_copy(aBlock);
        __int16 v48 = v46[1];
        v46[1] = v47;

        DNSServiceFlags v49 = 1073844224;
        DNSServiceRef service = 0LL;
        if (a4) {
          p_DNSServiceRef service = a4;
        }
        else {
          p_DNSServiceRef service = &service;
        }
        if (a5) {
          DNSServiceFlags v49 = *a5 | 0x40019000;
        }
        DNSServiceErrorType AddrInfo = DNSServiceGetAddrInfo( p_service,  v49,  v26,  2u,  "ipv4only.arpa",  (DNSServiceGetAddrInfoReply)nw_nat64_getaddrinfo_callback_async,  v46);
        if (AddrInfo)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v52 = (os_log_s *)(id)gLogObj;
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          {
            string_for_dns_service_CFErrorRef error = nwlog_get_string_for_dns_service_error(AddrInfo);
            *(_DWORD *)__int128 buf = 136447490;
            unsigned __int8 v112 = "nw_nat64_query_ipv4only_records_async";
            __int16 v113 = 1024;
            *(_DWORD *)uint64_t v114 = v49;
            *(_WORD *)&v114[4] = 1024;
            *(_DWORD *)&v114[6] = v26;
            *(_WORD *)&v114[10] = 2082;
            *(void *)&v114[12] = "ipv4only.arpa";
            *(_WORD *)&v114[20] = 2082;
            *(void *)&v114[22] = string_for_dns_service_error;
            *(_WORD *)unsigned __int8 v115 = 1024;
            *(_DWORD *)&v115[2] = AddrInfo;
            _os_log_impl( &dword_181A5C000,  v52,  OS_LOG_TYPE_ERROR,  "%{public}s starting DNS query with flags %#x on ifindex %u for %{public}s failed with error=%{public}s(%d)",  buf,  0x32u);
          }

LABEL_49:
          if (service) {
            DNSServiceRefDeallocate(service);
          }
          uint32_t v54 = v46[1];
          v46[1] = 0LL;

          if (*v46) {
            free(*v46);
          }
          free(v46);
          uint64_t v15 = 0xFFFFFFFFLL;
          goto LABEL_89;
        }

        if (a4)
        {
          __nwlog_obj();
          os_log_type_t v62 = (os_log_s *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)__int128 buf = 136446722;
            unsigned __int8 v112 = "nw_nat64_query_ipv4only_records_async";
            __int16 v113 = 1024;
            *(_DWORD *)uint64_t v114 = v26;
            *(_WORD *)&v114[4] = 2082;
            *(void *)&v114[6] = "ipv4only.arpa";
            _os_log_impl( &dword_181A5C000,  v62,  OS_LOG_TYPE_DEBUG,  "%{public}s started DNS query with custom sdRef on ifindex %u for %{public}s successfully",  buf,  0x1Cu);
          }

LABEL_88:
          uint64_t v15 = 0x80000000LL;
LABEL_89:

          goto LABEL_90;
        }

        DNSServiceErrorType v64 = DNSServiceSetDispatchQueue(service, queue);
        __nwlog_obj();
        unsigned int v65 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        unsigned int v66 = v65;
        if (!v64)
        {
          if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)__int128 buf = 136446722;
            unsigned __int8 v112 = "nw_nat64_query_ipv4only_records_async";
            __int16 v113 = 1024;
            *(_DWORD *)uint64_t v114 = v26;
            *(_WORD *)&v114[4] = 2082;
            *(void *)&v114[6] = "ipv4only.arpa";
            _os_log_impl( &dword_181A5C000,  v66,  OS_LOG_TYPE_DEBUG,  "%{public}s started DNS query on ifindex %u for %{public}s successfully",  buf,  0x1Cu);
          }

          goto LABEL_88;
        }

        DNSServiceRef v67 = service;
        os_log_type_t v68 = nwlog_get_string_for_dns_service_error(v64);
        *(_DWORD *)__int128 buf = 136447234;
        unsigned __int8 v112 = "nw_nat64_query_ipv4only_records_async";
        __int16 v113 = 2048;
        *(void *)uint64_t v114 = v67;
        *(_WORD *)&v114[8] = 2048;
        *(void *)&v114[10] = queue;
        *(_WORD *)&v114[18] = 2082;
        *(void *)&v114[20] = v68;
        *(_WORD *)&v114[28] = 1024;
        *(_DWORD *)unsigned __int8 v115 = v64;
        int v69 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v108 = 0;
        if (__nwlog_fault(v69, &type, &v108))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            int v70 = v64;
            __nwlog_obj();
            int v71 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v72 = type;
            if (os_log_type_enabled(v71, type))
            {
              DNSServiceRef v73 = service;
              __int16 v74 = nwlog_get_string_for_dns_service_error(v70);
              *(_DWORD *)__int128 buf = 136447234;
              unsigned __int8 v112 = "nw_nat64_query_ipv4only_records_async";
              __int16 v113 = 2048;
              *(void *)uint64_t v114 = v73;
              *(_WORD *)&v114[8] = 2048;
              *(void *)&v114[10] = queue;
              *(_WORD *)&v114[18] = 2082;
              *(void *)&v114[20] = v74;
              *(_WORD *)&v114[28] = 1024;
              *(_DWORD *)unsigned __int8 v115 = v70;
              _os_log_impl( &dword_181A5C000,  v71,  v72,  "%{public}s DNSServiceSetDispatchQueue(%p,%p) error=%{public}s(%d) failed",  buf,  0x30u);
            }
          }

          else
          {
            if (v108)
            {
              __int16 v76 = (char *)__nw_create_backtrace_string();
              __nwlog_obj();
              __int16 v77 = (os_log_s *)objc_claimAutoreleasedReturnValue();
              os_log_type_t v78 = type;
              BOOL v79 = os_log_type_enabled(v77, type);
              if (v76)
              {
                if (v79)
                {
                  DNSServiceRef v80 = service;
                  unsigned int v81 = nwlog_get_string_for_dns_service_error(v64);
                  *(_DWORD *)__int128 buf = 136447490;
                  unsigned __int8 v112 = "nw_nat64_query_ipv4only_records_async";
                  __int16 v113 = 2048;
                  *(void *)uint64_t v114 = v80;
                  *(_WORD *)&v114[8] = 2048;
                  *(void *)&v114[10] = queue;
                  *(_WORD *)&v114[18] = 2082;
                  *(void *)&v114[20] = v81;
                  *(_WORD *)&v114[28] = 1024;
                  *(_DWORD *)unsigned __int8 v115 = v64;
                  *(_WORD *)&v115[4] = 2082;
                  unsigned __int8 v116 = v76;
                  _os_log_impl( &dword_181A5C000,  v77,  v78,  "%{public}s DNSServiceSetDispatchQueue(%p,%p) error=%{public}s(%d) failed, dumping backtrace:%{public}s",  buf,  0x3Au);
                }

                free(v76);
              }

              else
              {
                if (v79)
                {
                  DNSServiceRef v86 = service;
                  nw_endpoint_t v87 = nwlog_get_string_for_dns_service_error(v64);
                  *(_DWORD *)__int128 buf = 136447234;
                  unsigned __int8 v112 = "nw_nat64_query_ipv4only_records_async";
                  __int16 v113 = 2048;
                  *(void *)uint64_t v114 = v86;
                  *(_WORD *)&v114[8] = 2048;
                  *(void *)&v114[10] = queue;
                  *(_WORD *)&v114[18] = 2082;
                  *(void *)&v114[20] = v87;
                  *(_WORD *)&v114[28] = 1024;
                  *(_DWORD *)unsigned __int8 v115 = v64;
                  _os_log_impl( &dword_181A5C000,  v77,  v78,  "%{public}s DNSServiceSetDispatchQueue(%p,%p) error=%{public}s(%d) failed, no backtrace",  buf,  0x30u);
                }
              }

              goto LABEL_126;
            }

            int v82 = v64;
            __nwlog_obj();
            int v71 = (os_log_s *)objc_claimAutoreleasedReturnValue();
            os_log_type_t v83 = type;
            if (os_log_type_enabled(v71, type))
            {
              DNSServiceRef v84 = service;
              unsigned __int8 v85 = nwlog_get_string_for_dns_service_error(v82);
              *(_DWORD *)__int128 buf = 136447234;
              unsigned __int8 v112 = "nw_nat64_query_ipv4only_records_async";
              __int16 v113 = 2048;
              *(void *)uint64_t v114 = v84;
              *(_WORD *)&v114[8] = 2048;
              *(void *)&v114[10] = queue;
              *(_WORD *)&v114[18] = 2082;
              *(void *)&v114[20] = v85;
              *(_WORD *)&v114[28] = 1024;
              *(_DWORD *)unsigned __int8 v115 = v82;
              _os_log_impl( &dword_181A5C000,  v71,  v83,  "%{public}s DNSServiceSetDispatchQueue(%p,%p) error=%{public}s(%d) failed, backtrace limit exceeded",  buf,  0x30u);
            }
          }
        }

void sub_182306424( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20, uint64_t a21, uint64_t a22, uint64_t a23, void *a24, uint64_t a25, uint64_t a26, uint64_t a27, uint64_t a28, uint64_t a29, void *a30)
{
  _Unwind_Resume(a1);
}

uint64_t nw_nat64_get_interface_state_internal(unsigned int *a1, id *a2)
{
  *(void *)&v64[13] = *MEMORY[0x1895F89C0];
  unsigned int v4 = *a1;
  if (a2)
  {
    id v5 = *a2;
    *a2 = 0LL;
  }

  if (!v4)
  {
    evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(0LL, 0LL);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v62 = "nw_nat64_get_interface_state_internal";
    unsigned int v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (__nwlog_fault(v9, &type, &v59))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v62 = "nw_nat64_get_interface_state_internal";
          _os_log_impl(&dword_181A5C000, v10, v11, "%{public}s nw_path_create_default_evaluator failed", buf, 0xCu);
        }
      }

      else if (v59)
      {
        backtrace_uuid_string_t string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          unsigned int v34 = (char *)backtrace_string;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v35 = (os_log_s *)(id)gLogObj;
          os_log_type_t v36 = type;
          if (os_log_type_enabled(v35, type))
          {
            *(_DWORD *)__int128 buf = 136446466;
            os_log_type_t v62 = "nw_nat64_get_interface_state_internal";
            __int16 v63 = 2082;
            *(void *)DNSServiceErrorType v64 = v34;
            _os_log_impl( &dword_181A5C000,  v35,  v36,  "%{public}s nw_path_create_default_evaluator failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(v34);
          if (!v9) {
            return 4LL;
          }
          goto LABEL_84;
        }

        __nwlog_obj();
        os_log_type_t v10 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v53 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v62 = "nw_nat64_get_interface_state_internal";
          _os_log_impl( &dword_181A5C000,  v10,  v53,  "%{public}s nw_path_create_default_evaluator failed, no backtrace",  buf,  0xCu);
        }
      }

      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (os_log_s *)(id)gLogObj;
        os_log_type_t v51 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          os_log_type_t v62 = "nw_nat64_get_interface_state_internal";
          _os_log_impl( &dword_181A5C000,  v10,  v51,  "%{public}s nw_path_create_default_evaluator failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

    if (!v9) {
      return 4LL;
    }
LABEL_84:
    free(v9);
    return 4LL;
  }

  if (v4 != -1)
  {
    id v12 = nw_interface_create_with_index(v4);
    if (!v12)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v21 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446466;
        os_log_type_t v62 = "nw_nat64_get_interface_state_internal";
        __int16 v63 = 1024;
        *(_DWORD *)DNSServiceErrorType v64 = v4;
        _os_log_impl( &dword_181A5C000,  v21,  OS_LOG_TYPE_ERROR,  "%{public}s nw_interface_create_with_index failed for index %u",  buf,  0x12u);
      }

      return 4LL;
    }

    unsigned int v13 = (nw_interface *)v12;
    int v14 = nw_parameters_create();
    uint64_t v15 = v14;
    if (v14)
    {
      nw_parameters_require_interface(v14, v13);
      evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(0LL, v15);
      if (evaluator_for_endpoint)
      {

LABEL_17:
        char v16 = evaluator_for_endpoint;
        os_unfair_lock_lock((os_unfair_lock_t)evaluator_for_endpoint + 24);
        size_t v17 = (void *)*((void *)v16 + 6);
        id v18 = v17;
        os_unfair_lock_unlock((os_unfair_lock_t)evaluator_for_endpoint + 24);

        if (v18)
        {
          size_t v19 = (NWConcrete_nw_path *)v18;
          if (nw_path_network_is_satisfied_update_reason(v19, 0LL)) {
            unsigned int routed_interface_index = v19->policy_result.routed_interface_index;
          }
          else {
            unsigned int routed_interface_index = 0;
          }

          char is_eligible_for_CrazyIvan46 = nw_path_is_eligible_for_CrazyIvan46(v19);
          if (gLogDatapath)
          {
            BOOL v27 = nw_path_copy_description(v19);
            *a1 = routed_interface_index;
            if (routed_interface_index)
            {
LABEL_31:
              if ((is_eligible_for_CrazyIvan46 & 1) != 0)
              {
                id v28 = v19;
                if ((*((_BYTE *)v28 + 474) & 1) != 0) {
                  uint64_t v6 = 1LL;
                }
                else {
                  uint64_t v6 = 2LL;
                }

                if (!a2)
                {
LABEL_114:
                  if (v27) {
                    free((void *)v27);
                  }
                  goto LABEL_116;
                }

void sub_1823071F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL31nw_nat64_copy_prefixes_internalPjPP17nw_nat64_prefix_tPU28objcproto17OS_dispatch_queue8NSObjectPP16_DNSServiceRef_tPKjU13block_pointerFviS1_E_block_invoke( uint64_t a1)
{
  unsigned int v2 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  if (v2)
  {
    free(v2);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0LL;
  }

void nw_nat64_getaddrinfo_callback_sync( _DNSServiceRef_t *a1, int a2, int a3, int a4, const char *a5, const sockaddr *a6, int a7, int *a8)
{
  uint64_t v41 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v15 = (id)gLogObj;
  if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEBUG))
  {
  }

  else
  {
    int v16 = gLogFDOverride;

    if (v16 == -1) {
      goto LABEL_7;
    }
  }

  nw_endpoint_t address = nw_endpoint_create_address(a6);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v18 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 136448002;
    id v28 = "nw_nat64_getaddrinfo_callback_sync";
    __int16 v29 = 1024;
    *(_DWORD *)uint32_t v30 = a2;
    *(_WORD *)&v30[4] = 1024;
    *(_DWORD *)&v30[6] = a3;
    __int16 v31 = 2082;
    string_for_dns_service_CFErrorRef error = nwlog_get_string_for_dns_service_error(a4);
    __int16 v33 = 1024;
    int v34 = a4;
    __int16 v35 = 2082;
    os_log_type_t v36 = a5;
    __int16 v37 = 2082;
    description = nw_endpoint_get_description(address);
    __int16 v39 = 1024;
    int v40 = a7;
    _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s flags=0x%x ifindex=%u error=%{public}s(%d) hostname=%{public}s addr=%{public}s ttl=%d",  buf,  0x42u);
  }

LABEL_7:
  if (a4 || (a2 & 2) == 0 || !a6 || a6->sa_family != 30) {
    goto LABEL_8;
  }
  uint64_t v19 = a8[2];
  uint64_t v20 = v19 + 1;
  a8[2] = v19 + 1;
  if ((_DWORD)v19 == -1)
  {
    __nwlog_obj();
    size_t v23 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__int128 buf = 136446210;
    id v28 = "_strict_reallocf";
    uint64_t v24 = (void *)_os_log_send_and_compose_impl();

    free(v24);
  }

  uint64_t v21 = 28 * v20;
  id v22 = (sockaddr *)reallocf(*(void **)a8, 28 * v20);
  if (!v22)
  {
    __nwlog_obj();
    os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__int128 buf = 136446466;
    id v28 = "_strict_reallocf";
    __int16 v29 = 2048;
    *(void *)uint32_t v30 = v21;
    uint32_t v26 = (void *)_os_log_send_and_compose_impl();

    if (!__nwlog_abort((uint64_t)v26))
    {
      free(v26);
      goto LABEL_16;
    }

void sub_1823075E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL43nw_nat64_copy_prefixes_by_querying_ipv4onlyjPP17nw_nat64_prefix_tPU28objcproto17OS_dispatch_queue8NSObjectPP16_DNSServiceRef_tPKjU13block_pointerFviS0_E_block_invoke( uint64_t a1, int a2, uint64_t a3)
{
  if (a2 <= 0)
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
  }

  else
  {
    unsigned int v4 = 0LL;
    nw_nat64_copy_prefixes_from_ipv4only_records(a3, a2, &v4);
    (*(void (**)(void))(*(void *)(a1 + 32) + 16LL))();
    if (v4) {
      free(v4);
    }
  }

void nw_nat64_getaddrinfo_callback_async( _DNSServiceRef_t *a1, int a2, int a3, int a4, const char *a5, const sockaddr *a6, int a7, int *a8)
{
  uint64_t v44 = *MEMORY[0x1895F89C0];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v15 = (id)gLogObj;
  if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEBUG))
  {
  }

  else
  {
    int v16 = gLogFDOverride;

    if (v16 == -1) {
      goto LABEL_7;
    }
  }

  nw_endpoint_t address = nw_endpoint_create_address(a6);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v18 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 136448002;
    __int16 v31 = "nw_nat64_getaddrinfo_callback_async";
    __int16 v32 = 1024;
    *(_DWORD *)__int16 v33 = a2;
    *(_WORD *)&v33[4] = 1024;
    *(_DWORD *)&v33[6] = a3;
    __int16 v34 = 2082;
    string_for_dns_service_CFErrorRef error = nwlog_get_string_for_dns_service_error(a4);
    __int16 v36 = 1024;
    int v37 = a4;
    __int16 v38 = 2082;
    __int16 v39 = a5;
    __int16 v40 = 2082;
    description = nw_endpoint_get_description(address);
    __int16 v42 = 1024;
    int v43 = a7;
    _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s flags=0x%x ifindex=%u error=%{public}s(%d) hostname=%{public}s addr=%{public}s ttl=%d",  buf,  0x42u);
  }

LABEL_7:
  if (!a4 && (a2 & 2) != 0 && a6 && a6->sa_family == 30)
  {
    uint64_t v21 = a8[4];
    uint64_t v22 = v21 + 1;
    a8[4] = v21 + 1;
    if ((_DWORD)v21 == -1)
    {
      __nwlog_obj();
      os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int128 buf = 136446210;
      __int16 v31 = "_strict_reallocf";
      uint32_t v26 = (void *)_os_log_send_and_compose_impl();

      free(v26);
    }

    size_t v23 = 28 * v22;
    uint64_t v24 = (sockaddr *)reallocf(*(void **)a8, v23);
    if (v24)
    {
LABEL_20:
      *(void *)a8 = v24;
      v24[a8[4] - 1] = *(sockaddr *)&a6->sa_data[6];
      goto LABEL_8;
    }

    __nwlog_obj();
    BOOL v27 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__int128 buf = 136446466;
    __int16 v31 = "_strict_reallocf";
    __int16 v32 = 2048;
    *(void *)__int16 v33 = v23;
    id v28 = (void *)_os_log_send_and_compose_impl();

    if (!__nwlog_abort((uint64_t)v28))
    {
      free(v28);
      goto LABEL_20;
    }

void sub_182307A08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_nat64_synthesize(unsigned int *a1, __int16 *a2, void **a3)
{
  uint64_t v40 = *MEMORY[0x1895F89C0];
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if (sNWIsBetweenForkAndExec == 1 && (sNWParentAllowedDispatch & 1) != 0) {
    return 0LL;
  }
  if ((sNWDispatchAllowedNow & 1) == 0)
  {
    if ((_dispatch_is_fork_of_multithreaded_parent() & 1) == 0 && (_dispatch_is_multithreaded() & 1) != 0
      || (getpid(), sandbox_check() == 1))
    {
      sNWDispatchAllowedNow = 1;
    }

    else if (sNWDispatchAllowedNow != 1)
    {
      return 0LL;
    }
  }

  if (!a2)
  {
    __nwlog_obj();
    uint64_t v19 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v34 = "nw_nat64_synthesize";
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(__dst[0]) = 16;
    LOBYTE(v32) = 0;
    if (__nwlog_fault(v20, __dst, &v32))
    {
      if (LOBYTE(__dst[0]) == 17)
      {
        __nwlog_obj();
        uint64_t v21 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v22 = __dst[0];
        if (os_log_type_enabled(v21, __dst[0]))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v34 = "nw_nat64_synthesize";
          size_t v23 = "%{public}s called with null ipv4";
LABEL_59:
          _os_log_impl(&dword_181A5C000, v21, v22, v23, buf, 0xCu);
        }

uint64_t nw_nat64_copy_prefixes_async(unsigned int *a1, void *a2, void *a3)
{
  uint64_t v34 = *MEMORY[0x1895F89C0];
  id v5 = a2;
  id v6 = a3;
  nw_allow_use_of_dispatch_internal();
  if (v5)
  {
    if (v6)
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        uint32_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          if (a1) {
            unsigned int v17 = *a1;
          }
          else {
            unsigned int v17 = 0;
          }
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v31 = "nw_nat64_copy_prefixes_async";
          __int16 v32 = 1024;
          LODWORD(v33) = v17;
          _os_log_impl( &dword_181A5C000,  v16,  OS_LOG_TYPE_DEBUG,  "%{public}s Start nw_nat64_copy_prefixes_async(%u)",  buf,  0x12u);
        }
      }

      BOOL v7 = nw_nat64_copy_prefixes_internal(a1, 0LL, v5, 0LL, 0LL, v6);
      block[0] = MEMORY[0x1895F87A8];
      block[1] = 3221225472LL;
      block[2] = __nw_nat64_copy_prefixes_async_block_invoke;
      block[3] = &unk_189BC87B8;
      BOOL v27 = v7;
      id v26 = v6;
      dispatch_async(v5, block);

      uint64_t v8 = 1LL;
      goto LABEL_5;
    }

    __nwlog_obj();
    int v14 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v31 = "nw_nat64_copy_prefixes_async";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v11, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        int v12 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v31 = "nw_nat64_copy_prefixes_async";
          _os_log_impl(&dword_181A5C000, v12, v15, "%{public}s called with null block", buf, 0xCu);
        }

void sub_1823086F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_nat64_copy_prefixes_async_block_invoke(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1895F89C0];
  if (gLogDatapath)
  {
    __nwlog_obj();
    unsigned int v3 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      int v4 = *(_DWORD *)(a1 + 40);
      int v5 = 136446466;
      id v6 = "nw_nat64_copy_prefixes_async_block_invoke";
      __int16 v7 = 1024;
      int v8 = v4;
      _os_log_impl( &dword_181A5C000,  v3,  OS_LOG_TYPE_DEBUG,  "%{public}s nw_nat64_copy_prefixes_async returning %d",  (uint8_t *)&v5,  0x12u);
    }
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16LL))();
}

uint64_t nw_nat64_copy_prefixes_async_override_dns( unsigned int *a1, void *a2, DNSServiceRef *a3, _DWORD *a4, void *a5)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  uint64_t v9 = a2;
  id v10 = a5;
  nw_allow_use_of_dispatch_internal();
  if (v9)
  {
    if (v10)
    {
      if (gLogDatapath)
      {
        __nwlog_obj();
        BOOL v20 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          if (a1) {
            unsigned int v21 = *a1;
          }
          else {
            unsigned int v21 = 0;
          }
          *(_DWORD *)__int128 buf = 136446466;
          __int16 v35 = "nw_nat64_copy_prefixes_async_override_dns";
          __int16 v36 = 1024;
          LODWORD(v37) = v21;
          _os_log_impl( &dword_181A5C000,  v20,  OS_LOG_TYPE_DEBUG,  "%{public}s Start nw_nat64_copy_prefixes_async_override_dns(%u)",  buf,  0x12u);
        }
      }

      BOOL v11 = nw_nat64_copy_prefixes_internal(a1, 0LL, v9, a3, a4, v10);
      block[0] = MEMORY[0x1895F87A8];
      block[1] = 3221225472LL;
      block[2] = __nw_nat64_copy_prefixes_async_override_dns_block_invoke;
      block[3] = &unk_189BC87B8;
      id v30 = v10;
      BOOL v31 = v11;
      dispatch_async(v9, block);

      uint64_t v12 = 1LL;
      goto LABEL_5;
    }

    __nwlog_obj();
    id v18 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v35 = "nw_nat64_copy_prefixes_async_override_dns";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (__nwlog_fault(v15, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        uint32_t v16 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v35 = "nw_nat64_copy_prefixes_async_override_dns";
          _os_log_impl(&dword_181A5C000, v16, v19, "%{public}s called with null block", buf, 0xCu);
        }

void sub_182308DA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_nat64_copy_prefixes_async_override_dns_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 32) + 16LL))( *(void *)(a1 + 32),  *(unsigned int *)(a1 + 40),  0LL);
}

uint64_t nw_nat64_does_interface_index_support_nat64(unsigned int a1)
{
  unsigned int v2 = a1;
  return (3u >> ((nw_nat64_get_interface_state_internal(&v2, 0LL) - 1) & 0xF)) & 1;
}

NWConcrete_nw_nat64_prefixes_resolver *nw_nat64_prefixes_resolver_create(void *a1)
{
  uint64_t v38 = *MEMORY[0x1895F89C0];
  id v2 = a1;
  unsigned int v3 = objc_alloc(&OBJC_CLASS___NWConcrete_nw_nat64_prefixes_resolver);
  id v4 = v2;
  if (!v3) {
    goto LABEL_31;
  }
  v33.os_log_type_t receiver = v3;
  v33.super_class = (Class)&OBJC_CLASS___NWConcrete_nw_nat64_prefixes_resolver;
  int v5 = (id *)objc_msgSendSuper2(&v33, sel_init);
  id v6 = v5;
  if (!v5)
  {
    __nwlog_obj();
    os_log_type_t v23 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    __int16 v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
    BOOL v24 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if ((__nwlog_fault(v24, &type, &v31) & 1) != 0)
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __nwlog_obj();
        os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
          _os_log_impl(&dword_181A5C000, v25, v26, "%{public}s [super init] failed", buf, 0xCu);
        }
      }

      else if (v31)
      {
        backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
        __nwlog_obj();
        os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v28 = type;
        BOOL v29 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v29)
          {
            *(_DWORD *)__int128 buf = 136446466;
            __int16 v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
            __int16 v36 = 2082;
            int v37 = backtrace_string;
            _os_log_impl( &dword_181A5C000,  v25,  v28,  "%{public}s [super init] failed, dumping backtrace:%{public}s",  buf,  0x16u);
          }

          free(backtrace_string);
          goto LABEL_48;
        }

        if (v29)
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
          _os_log_impl(&dword_181A5C000, v25, v28, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }

      else
      {
        __nwlog_obj();
        os_log_type_t v25 = (os_log_s *)objc_claimAutoreleasedReturnValue();
        os_log_type_t v30 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)__int128 buf = 136446210;
          __int16 v35 = "-[NWConcrete_nw_nat64_prefixes_resolver initWithParameters:]";
          _os_log_impl( &dword_181A5C000,  v25,  v30,  "%{public}s [super init] failed, backtrace limit exceeded",  buf,  0xCu);
        }
      }
    }

void sub_1823093F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_nat64_prefixes_resolver_set_queue(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 2);
    objc_storeStrong((id *)v3 + 10, a2);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 2);
    goto LABEL_3;
  }

  __nwlog_obj();
  int v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  nw_interface_t v16 = "nw_nat64_prefixes_resolver_set_queue";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        nw_interface_t v16 = "nw_nat64_prefixes_resolver_set_queue";
        _os_log_impl(&dword_181A5C000, v7, v8, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if (v13)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          nw_interface_t v16 = "nw_nat64_prefixes_resolver_set_queue";
          __int16 v17 = 2082;
          id v18 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolver, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        nw_interface_t v16 = "nw_nat64_prefixes_resolver_set_queue";
        _os_log_impl(&dword_181A5C000, v7, v10, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        nw_interface_t v16 = "nw_nat64_prefixes_resolver_set_queue";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null resolver, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_nat64_prefixes_resolver_set_update_handler(void *a1, void *a2, void *a3)
{
  uint64_t v31 = *MEMORY[0x1895F89C0];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  os_log_type_t v8 = v7;
  if (!v5)
  {
    __nwlog_obj();
    BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    os_log_type_t v28 = "nw_nat64_prefixes_resolver_set_update_handler";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v28 = "nw_nat64_prefixes_resolver_set_update_handler";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if (v25)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v28 = "nw_nat64_prefixes_resolver_set_update_handler";
          __int16 v29 = 2082;
          os_log_type_t v30 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v18,  "%{public}s called with null resolver, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v12) {
          goto LABEL_6;
        }
LABEL_41:
        free(v12);
        goto LABEL_6;
      }

      if (v19)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v28 = "nw_nat64_prefixes_resolver_set_update_handler";
        _os_log_impl(&dword_181A5C000, v13, v18, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v28 = "nw_nat64_prefixes_resolver_set_update_handler";
        _os_log_impl( &dword_181A5C000,  v13,  v23,  "%{public}s called with null resolver, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void nw_nat64_prefixes_resolver_set_cancel_handler(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    os_unfair_lock_lock(v3 + 2);
    id v5 = _Block_copy(v4);
    id v6 = *(void **)&v3[18]._os_unfair_lock_opaque;
    *(void *)&v3[18]._uint32_t os_unfair_lock_opaque = v5;

    os_unfair_lock_unlock(v3 + 2);
    goto LABEL_3;
  }

  __nwlog_obj();
  id v7 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  os_log_type_t v18 = "nw_nat64_prefixes_resolver_set_cancel_handler";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v18 = "nw_nat64_prefixes_resolver_set_cancel_handler";
        _os_log_impl(&dword_181A5C000, v9, v10, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if (v15)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)__int128 buf = 136446466;
          os_log_type_t v18 = "nw_nat64_prefixes_resolver_set_cancel_handler";
          __int16 v19 = 2082;
          BOOL v20 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v9,  v12,  "%{public}s called with null resolver, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }

      if (v13)
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v18 = "nw_nat64_prefixes_resolver_set_cancel_handler";
        _os_log_impl(&dword_181A5C000, v9, v12, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      id v9 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v18 = "nw_nat64_prefixes_resolver_set_cancel_handler";
        _os_log_impl( &dword_181A5C000,  v9,  v14,  "%{public}s called with null resolver, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void nw_nat64_prefixes_resolver_start(void *a1)
{
  *(void *)&v47[13] = *MEMORY[0x1895F89C0];
  id v1 = a1;
  nw_allow_use_of_dispatch_internal();
  if (v1)
  {
    os_unfair_lock_lock((os_unfair_lock_t)v1 + 2);
    if (!*((void *)v1 + 8))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)v1 + 2);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v2 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v45 = "nw_nat64_prefixes_resolver_start";
        _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_ERROR,  "%{public}s The nat64 prefixes resolver's handler is not set. You must set this resolver's handler using nw_nat 64_prefixes_resolver_set_update_handler() in order to successfully start it.",  buf,  0xCu);
      }

      goto LABEL_13;
    }

    if (!*((void *)v1 + 10))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)v1 + 2);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v2 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v45 = "nw_nat64_prefixes_resolver_start";
        _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_ERROR,  "%{public}s The nat64 prefixes resolver's client_queue is not set. You must set this resolver's client_queue us ing nw_nat64_prefixes_resolver_set_update_handler() in order to successfully start it.",  buf,  0xCu);
      }

      goto LABEL_13;
    }

    if (*((void *)v1 + 6))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)v1 + 2);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v2 = (os_log_s *)(id)gLogObj;
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int128 buf = 136446210;
        os_log_type_t v45 = "nw_nat64_prefixes_resolver_start";
        _os_log_impl( &dword_181A5C000,  v2,  OS_LOG_TYPE_ERROR,  "%{public}s The nat64 prefixes resolver has already been started.",  buf,  0xCu);
      }

void sub_18230A8C0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void __nw_nat64_prefixes_resolver_start_block_invoke(uint64_t a1, void *a2)
{
  id v3 = (os_unfair_lock_s *)(*(void *)(a1 + 32) + 8LL);
  id v4 = a2;
  os_unfair_lock_lock(v3);
  nw_nat64_prefixes_resolver_path_update_callback_locked(*(void **)(a1 + 32), v4);

  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 8LL));
}

void sub_18230A96C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_nat64_prefixes_resolver_path_update_callback_locked(void *a1, void *a2)
{
  uint64_t v33 = *MEMORY[0x1895F89C0];
  id v3 = a1;
  id v4 = a2;
  unsigned int v5 = v4;
  if (!v3)
  {
    __nwlog_obj();
    BOOL v13 = (void *)objc_claimAutoreleasedReturnValue();
    *(_DWORD *)__int128 buf = 136446210;
    BOOL v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
        _os_log_impl(&dword_181A5C000, v15, v16, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if (v27)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)__int128 buf = 136446466;
          BOOL v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
          __int16 v31 = 2082;
          char v32 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v15,  v20,  "%{public}s called with null resolver, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
LABEL_49:
        if (!v14) {
          goto LABEL_11;
        }
LABEL_50:
        free(v14);
        goto LABEL_11;
      }

      if (v21)
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
        _os_log_impl(&dword_181A5C000, v15, v20, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      char v15 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        BOOL v30 = "nw_nat64_prefixes_resolver_path_update_callback_locked";
        _os_log_impl( &dword_181A5C000,  v15,  v25,  "%{public}s called with null resolver, backtrace limit exceeded",  buf,  0xCu);
      }
    }

void sub_18230AF84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_nat64_prefixes_resolver_start_dns_query_locked(NWConcrete_nw_nat64_prefixes_resolver *a1)
{
  id v1 = a1;
  id v2 = (void *)*((void *)v1 + 3);
  v4[0] = MEMORY[0x1895F87A8];
  v4[1] = 3221225472LL;
  v4[2] = ___ZL49nw_nat64_prefixes_resolver_start_dns_query_lockedP37NWConcrete_nw_nat64_prefixes_resolver_block_invoke;
  v4[3] = &unk_189BC93A0;
  id v3 = v1;
  unsigned int v5 = v3;
  nw_queue_context_async(v2, v4);
}

void sub_18230B018( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZL49nw_nat64_prefixes_resolver_start_dns_query_lockedP37NWConcrete_nw_nat64_prefixes_resolver_block_invoke( uint64_t a1)
{
  uint64_t v37 = *MEMORY[0x1895F89C0];
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 8LL));
  __int128 v35 = xmmword_18272C760;
  __int128 v36 = unk_18272C770;
  strcpy((char *)v34, "DNSServiceGetAddrInfo");
  HIWORD(v34[2]) = 0;
  v34[3] = 0LL;
  *(void *)(*(void *)(a1 + 32) + 48LL) = 0LL;
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = (DNSServiceRef *)(v2 + 48);
  uint32_t required_interface_index = nw_parameters_get_required_interface_index(*(void **)(v2 + 16));
  DNSServiceErrorType AddrInfo = DNSServiceGetAddrInfo( v3,  0x9000u,  required_interface_index,  2u,  "ipv4only.arpa",  (DNSServiceGetAddrInfoReply)nw_nat64_prefixes_resolver_dns_callback,  *(void **)(a1 + 32));
  if (AddrInfo == -65569)
  {
    *(void *)(*(void *)(a1 + 32) + 48LL) = 0LL;
    uint64_t v7 = *(void *)(a1 + 32);
    os_log_type_t v8 = (DNSServiceRef *)(v7 + 48);
    uint32_t v9 = nw_parameters_get_required_interface_index(*(void **)(v7 + 16));
    DNSServiceErrorType v10 = DNSServiceGetAddrInfo( v8,  0x9000u,  v9,  2u,  "ipv4only.arpa",  (DNSServiceGetAddrInfoReply)nw_nat64_prefixes_resolver_dns_callback,  *(void **)(a1 + 32));
    DNSServiceErrorType v6 = v10;
    if (v10 == -65569) {
      goto LABEL_8;
    }
    if (v10) {
      goto LABEL_3;
    }
  }

  else
  {
    DNSServiceErrorType v6 = AddrInfo;
    if (AddrInfo)
    {
LABEL_3:
      if (!v6) {
        goto LABEL_15;
      }
      goto LABEL_8;
    }
  }

  strcpy((char *)v34, "DNSServiceSetDispatchQueue");
  uint64_t v11 = *(void *)(a1 + 32);
  os_log_type_t v12 = *(_DNSServiceRef_t **)(v11 + 48);
  BOOL v13 = nw_context_copy_workloop(*(void **)(v11 + 24));
  DNSServiceErrorType v6 = DNSServiceSetDispatchQueue(v12, (dispatch_queue_t)v13);

  if (!v6)
  {
LABEL_15:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v19 = (os_log_s *)(id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__int128 buf = 136446466;
      os_log_type_t v25 = "nw_nat64_prefixes_resolver_start_dns_query_locked_block_invoke";
      __int16 v26 = 2082;
      char v27 = "ipv4only.arpa";
      _os_log_impl( &dword_181A5C000,  v19,  OS_LOG_TYPE_DEBUG,  "%{public}s started DNS query for %{public}s successfully",  buf,  0x16u);
    }

    os_log_type_t v20 = *(void **)(a1 + 32);
    BOOL v21 = v20;
    os_log_type_t v18 = (void *)v20[4];
    void v20[4] = v21;
    goto LABEL_18;
  }

void sub_18230B36C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_nat64_prefixes_resolver_dns_callback( _DNSServiceRef_t *a1, int a2, int a3, int a4, const char *a5, const sockaddr *a6, int a7, void *a8)
{
  uint64_t v56 = *MEMORY[0x1895F89C0];
  nw_allow_use_of_dispatch_internal();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v15 = (id)gLogObj;
  if (os_log_type_enabled((os_log_t)v15, OS_LOG_TYPE_DEBUG))
  {
  }

  else
  {
    int v16 = gLogFDOverride;

    if (v16 == -1) {
      goto LABEL_7;
    }
  }

  nw_endpoint_t address = nw_endpoint_create_address(a6);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v18 = (os_log_s *)(id)gLogObj;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)__int128 buf = 136448002;
    *(void *)&uint8_t buf[4] = "nw_nat64_prefixes_resolver_dns_callback";
    *(_WORD *)&_BYTE buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = a3;
    *(_WORD *)BOOL v47 = 2082;
    *(void *)&v47[2] = nwlog_get_string_for_dns_service_error(a4);
    __int16 v48 = 1024;
    int v49 = a4;
    __int16 v50 = 2082;
    os_log_type_t v51 = a5;
    __int16 v52 = 2082;
    description = nw_endpoint_get_description(address);
    __int16 v54 = 1024;
    int v55 = a7;
    _os_log_impl( &dword_181A5C000,  v18,  OS_LOG_TYPE_DEBUG,  "%{public}s flags=0x%x ifindex=%u error=%{public}s(%d) hostname=%{public}s addr=%{public}s ttl=%d",  buf,  0x42u);
  }

LABEL_7:
  if (a8)
  {
    id v19 = a8;
    os_unfair_lock_lock((os_unfair_lock_t)v19 + 2);
    if (!*((void *)v19 + 8))
    {
LABEL_22:
      os_unfair_lock_unlock((os_unfair_lock_t)v19 + 2);

      return;
    }

    if (a4 || (a2 & 2) == 0 || !a6 || a6->sa_family != 30)
    {
LABEL_10:
      if ((a2 & 1) == 0)
      {
        *(void *)__int128 buf = 0LL;
        *(void *)&uint8_t buf[8] = buf;
        *(void *)&buf[16] = 0x2020000000LL;
        *(void *)BOOL v47 = 0LL;
        int v20 = v19[26];
        if (v20 < 1)
        {
          int v21 = 0;
        }

        else
        {
          int v21 = nw_nat64_copy_prefixes_from_ipv4only_records(*((void *)v19 + 11), v20, v47);
          v19[26] = 0;
          os_log_type_t v22 = (void *)*((void *)v19 + 11);
          if (v22)
          {
            free(v22);
            *((void *)v19 + 1nw_tcp_options_set_enable_fast_open(options, 1) = 0LL;
          }
        }

        char v27 = (dispatch_queue_s *)*((void *)v19 + 10);
        block[0] = MEMORY[0x1895F87A8];
        block[1] = 3221225472LL;
        block[2] = ___ZL39nw_nat64_prefixes_resolver_dns_callbackP16_DNSServiceRef_tjjiPKcPK8sockaddrjPv_block_invoke;
        block[3] = &unk_189BC7870;
        int v43 = v21;
        id v41 = v19;
        char v42 = buf;
        dispatch_async(v27, block);

        _Block_object_dispose(buf, 8);
      }

      goto LABEL_22;
    }

    uint64_t v23 = v19[26];
    uint64_t v24 = v23 + 1;
    v19[26] = v23 + 1;
    if ((_DWORD)v23 == -1)
    {
      __nwlog_obj();
      __int128 v36 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_enabled(v36, OS_LOG_TYPE_ERROR);
      *(_DWORD *)__int128 buf = 136446210;
      *(void *)&uint8_t buf[4] = "_strict_reallocf";
      uint64_t v37 = (void *)_os_log_send_and_compose_impl();

      free(v37);
    }

    uint64_t v25 = 28 * v24;
    __int16 v26 = (sockaddr *)reallocf(*((void **)v19 + 11), 28 * v24);
    if (v26)
    {
LABEL_19:
      *((void *)v19 + 1nw_tcp_options_set_enable_fast_open(options, 1) = v26;
      v26[v19[26] - 1] = *(sockaddr *)&a6->sa_data[6];
      goto LABEL_10;
    }

    __nwlog_obj();
    BOOL v38 = (os_log_s *)objc_claimAutoreleasedReturnValue();
    os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
    *(_DWORD *)__int128 buf = 136446466;
    *(void *)&uint8_t buf[4] = "_strict_reallocf";
    *(_WORD *)&_BYTE buf[12] = 2048;
    *(void *)&buf[14] = v25;
    os_log_type_t v39 = (void *)_os_log_send_and_compose_impl();

    if (!__nwlog_abort((uint64_t)v39))
    {
      free(v39);
      goto LABEL_19;
    }

void sub_18230B9A0( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  _Unwind_Resume(a1);
}

void ___ZL49nw_nat64_prefixes_resolver_start_dns_query_lockedP37NWConcrete_nw_nat64_prefixes_resolver_block_invoke_89( uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = *(const void **)(v2 + 64);
  if (v3)
  {
    id v4 = _Block_copy(v3);
    os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 8LL));
    (*((void (**)(id, void, void))v4 + 2))(v4, 0LL, 0LL);
  }

  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 8));
  }

void sub_18230BA54( _Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
}

void ___ZL39nw_nat64_prefixes_resolver_dns_callbackP16_DNSServiceRef_tjjiPKcPK8sockaddrjPv_block_invoke( uint64_t a1)
{
  v7[2] = *MEMORY[0x1895F89C0];
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 8LL));
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = *(const void **)(v2 + 64);
  if (v3)
  {
    id v4 = (void (**)(void *, uint64_t, void))_Block_copy(v3);
    os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 8LL));
    uint64_t v5 = *(unsigned int *)(a1 + 48);
    if ((_DWORD)v5)
    {
      v4[2](v4, v5, *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL));
    }

    else
    {
      v7[0] = 0LL;
      v7[1] = 0LL;
      ((void (**)(void *, uint64_t, void *))v4)[2](v4, v5, v7);
    }
  }

  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 8));
  }

  DNSServiceErrorType v6 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL);
  if (v6)
  {
    free(v6);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8LL) + 24LL) = 0LL;
  }

void sub_18230BB4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_nat64_prefixes_resolver_cancel_dns_query_locked(NWConcrete_nw_nat64_prefixes_resolver *a1)
{
  uint64_t v22 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  uint64_t v3 = *((void *)v1 + 6);
  if (!v3) {
    goto LABEL_4;
  }
  if (*((void *)v1 + 4))
  {
    *((void *)v1 + 6) = 0LL;
    id v4 = (void *)*((void *)v1 + 3);
    v13[0] = MEMORY[0x1895F87A8];
    v13[1] = 3221225472LL;
    v13[2] = ___ZL50nw_nat64_prefixes_resolver_cancel_dns_query_lockedP37NWConcrete_nw_nat64_prefixes_resolver_block_invoke;
    v13[3] = &unk_189BC66E8;
    uint64_t v15 = v3;
    os_log_type_t v14 = v1;
    nw_queue_context_async_if_needed(v4, v13);

    goto LABEL_4;
  }

  __nwlog_obj();
  uint64_t v5 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  id v19 = "nw_nat64_prefixes_resolver_cancel_dns_query_locked";
  DNSServiceErrorType v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v17 = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &v17, &v16))
  {
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v8 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v19 = "nw_nat64_prefixes_resolver_cancel_dns_query_locked";
        _os_log_impl( &dword_181A5C000,  v7,  v8,  "%{public}s called with null resolver->internally_retained_object",  buf,  0xCu);
      }
    }

    else if (v16)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v10 = v17;
      BOOL v11 = os_log_type_enabled(v7, v17);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)__int128 buf = 136446466;
          id v19 = "nw_nat64_prefixes_resolver_cancel_dns_query_locked";
          __int16 v20 = 2082;
          int v21 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolver->internally_retained_object, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }

      if (v11)
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v19 = "nw_nat64_prefixes_resolver_cancel_dns_query_locked";
        _os_log_impl( &dword_181A5C000,  v7,  v10,  "%{public}s called with null resolver->internally_retained_object, no backtrace",  buf,  0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      uint64_t v7 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v12 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)__int128 buf = 136446210;
        id v19 = "nw_nat64_prefixes_resolver_cancel_dns_query_locked";
        _os_log_impl( &dword_181A5C000,  v7,  v12,  "%{public}s called with null resolver->internally_retained_object, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }

void sub_18230BE58( _Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void ___ZL50nw_nat64_prefixes_resolver_cancel_dns_query_lockedP37NWConcrete_nw_nat64_prefixes_resolver_block_invoke( uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void **)(v2 + 32);
  *(void *)(v2 + 32) = 0LL;
}

void nw_nat64_prefixes_resolver_cancel(void *a1)
{
  uint64_t v25 = *MEMORY[0x1895F89C0];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 2);
    nw_nat64_prefixes_resolver_cancel_dns_query_locked((NWConcrete_nw_nat64_prefixes_resolver *)v2);
    uint64_t v3 = *(void **)&v2[16]._os_unfair_lock_opaque;
    *(void *)&v2[16]._uint32_t os_unfair_lock_opaque = 0LL;

    id v4 = *(void **)&v2[24]._os_unfair_lock_opaque;
    if (v4)
    {
      nw_path_evaluator_cancel(v4);
      uint64_t v5 = *(void **)&v2[24]._os_unfair_lock_opaque;
      *(void *)&v2[24]._uint32_t os_unfair_lock_opaque = 0LL;
    }

    DNSServiceErrorType v6 = *(void **)&v2[22]._os_unfair_lock_opaque;
    if (v6)
    {
      free(v6);
      *(void *)&v2[22]._uint32_t os_unfair_lock_opaque = 0LL;
    }

    v2[26]._uint32_t os_unfair_lock_opaque = 0;
    uint64_t v7 = *(const void **)&v2[18]._os_unfair_lock_opaque;
    if (v7)
    {
      os_log_type_t v8 = _Block_copy(v7);
      uint32_t v9 = *(void **)&v2[18]._os_unfair_lock_opaque;
      *(void *)&v2[18]._uint32_t os_unfair_lock_opaque = 0LL;

      dispatch_async(*(dispatch_queue_t *)&v2[20]._os_unfair_lock_opaque, v8);
    }

    os_log_type_t v10 = *(void **)&v2[20]._os_unfair_lock_opaque;
    *(void *)&v2[20]._uint32_t os_unfair_lock_opaque = 0LL;

    os_unfair_lock_unlock(v2 + 2);
    goto LABEL_9;
  }

  __nwlog_obj();
  BOOL v11 = (void *)objc_claimAutoreleasedReturnValue();
  *(_DWORD *)__int128 buf = 136446210;
  uint64_t v22 = "nw_nat64_prefixes_resolver_cancel";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v12, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __nwlog_obj();
      BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v22 = "nw_nat64_prefixes_resolver_cancel";
        _os_log_impl(&dword_181A5C000, v13, v14, "%{public}s called with null resolver", buf, 0xCu);
      }
    }

    else if (v19)
    {
      backtrace_uuid_string_t string = (char *)__nw_create_backtrace_string();
      __nwlog_obj();
      BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)__int128 buf = 136446466;
          uint64_t v22 = "nw_nat64_prefixes_resolver_cancel";
          __int16 v23 = 2082;
          uint64_t v24 = backtrace_string;
          _os_log_impl( &dword_181A5C000,  v13,  v16,  "%{public}s called with null resolver, dumping backtrace:%{public}s",  buf,  0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }

      if (v17)
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v22 = "nw_nat64_prefixes_resolver_cancel";
        _os_log_impl(&dword_181A5C000, v13, v16, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }

    else
    {
      __nwlog_obj();
      BOOL v13 = (os_log_s *)objc_claimAutoreleasedReturnValue();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)__int128 buf = 136446210;
        uint64_t v22 = "nw_nat64_prefixes_resolver_cancel";
        _os_log_impl( &dword_181A5C000,  v13,  v18,  "%{public}s called with null resolver, backtrace limit exceeded",  buf,  0xCu);
      }
    }
  }